CCS PCH C Compiler, Version 5.104, 57077               08-8-25 20:02

               Filename:   build\mmj_cigs_main.lst

               ROM used:   37938 bytes (29%)
                           Largest free fragment is 65520
               RAM used:   886 (25%) at main() level
                           3223 (90%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   8B32
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "cigs/system/mmj_cigs_main.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 46,6C
0028C:  DATA 61,73
0028E:  DATA 68,20
00290:  DATA 71,75
00292:  DATA 65,75
00294:  DATA 65,20
00296:  DATA 69,73
00298:  DATA 20,66
0029A:  DATA 75,6C
0029C:  DATA 6C,21
0029E:  DATA 21,21
002A0:  DATA 0D,0A
002A2:  DATA 00,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,65
002B4:  DATA 6D,70
002B6:  DATA 74,79
002B8:  DATA 0D,0A
002BA:  DATA 00,00
002BC:  DATA 0D,0A
002BE:  DATA 53,74
002C0:  DATA 61,72
002C2:  DATA 74,20
002C4:  DATA 6D,61
002C6:  DATA 6B,65
002C8:  DATA 5F,72
002CA:  DATA 65,63
002CC:  DATA 65,69
002CE:  DATA 76,65
002D0:  DATA 5F,63
002D2:  DATA 6F,6D
002D4:  DATA 6D,61
002D6:  DATA 6E,64
002D8:  DATA 0D,0A
002DA:  DATA 00,00
002DC:  DATA 09,5B
002DE:  DATA 42,4F
002E0:  DATA 53,53
002E2:  DATA 5D,20
002E4:  DATA 3E,3E
002E6:  DATA 3E,20
002E8:  DATA 00,00
002EA:  DATA 45,6E
002EC:  DATA 64,20
002EE:  DATA 6D,61
002F0:  DATA 6B,65
002F2:  DATA 5F,72
002F4:  DATA 65,63
002F6:  DATA 69,76
002F8:  DATA 65,5F
002FA:  DATA 63,6F
002FC:  DATA 6D,6D
002FE:  DATA 61,6E
00300:  DATA 64,0D
00302:  DATA 0A,0D
00304:  DATA 0A,00
00306:  DATA 73,69
00308:  DATA 67,6E
0030A:  DATA 61,6C
0030C:  DATA 20,65
0030E:  DATA 6E,64
00310:  DATA 20,77
00312:  DATA 69,74
00314:  DATA 68,20
00316:  DATA 53,46
00318:  DATA 44,0D
0031A:  DATA 0A,00
0031C:  DATA 64,6F
0031E:  DATA 6E,27
00320:  DATA 74,20
00322:  DATA 66,69
00324:  DATA 6E,64
00326:  DATA 20,53
00328:  DATA 46,44
0032A:  DATA 0D,0A
0032C:  DATA 00,00
0032E:  DATA 09,2D
00330:  DATA 3E,20
00332:  DATA 49,6E
00334:  DATA 76,61
00336:  DATA 6C,69
00338:  DATA 64,20
0033A:  DATA 46,72
0033C:  DATA 61,6D
0033E:  DATA 65,20
00340:  DATA 49,44
00342:  DATA 20,72
00344:  DATA 65,63
00346:  DATA 65,69
00348:  DATA 76,65
0034A:  DATA 64,3A
0034C:  DATA 20,25
0034E:  DATA 58,0D
00350:  DATA 0A,00
00352:  DATA 09,2D
00354:  DATA 3E,20
00356:  DATA 43,52
00358:  DATA 43,20
0035A:  DATA 65,72
0035C:  DATA 72,6F
0035E:  DATA 72,21
00360:  DATA 0D,0A
00362:  DATA 00,00
00364:  DATA 09,09
00366:  DATA 2D,3E
00368:  DATA 20,72
0036A:  DATA 65,63
0036C:  DATA 65,69
0036E:  DATA 76,65
00370:  DATA 64,20
00372:  DATA 43,52
00374:  DATA 43,3A
00376:  DATA 20,25
00378:  DATA 58,0D
0037A:  DATA 0A,00
0037C:  DATA 09,09
0037E:  DATA 20,20
00380:  DATA 20,63
00382:  DATA 6F,6C
00384:  DATA 6C,65
00386:  DATA 63,74
00388:  DATA 20,43
0038A:  DATA 52,43
0038C:  DATA 20,3A
0038E:  DATA 20,25
00390:  DATA 58,0D
00392:  DATA 0A,00
00394:  DATA 09,2D
00396:  DATA 3E,20
00398:  DATA 49,6E
0039A:  DATA 76,61
0039C:  DATA 6C,69
0039E:  DATA 64,20
003A0:  DATA 64,65
003A2:  DATA 76,69
003A4:  DATA 63,65
003A6:  DATA 20,49
003A8:  DATA 44,20
003AA:  DATA 72,65
003AC:  DATA 63,65
003AE:  DATA 69,76
003B0:  DATA 65,64
003B2:  DATA 0D,0A
003B4:  DATA 00,00
003B6:  DATA 09,09
003B8:  DATA 2D,3E
003BA:  DATA 20,72
003BC:  DATA 65,63
003BE:  DATA 65,69
003C0:  DATA 76,65
003C2:  DATA 64,3A
003C4:  DATA 20,20
003C6:  DATA 20,20
003C8:  DATA 20,25
003CA:  DATA 58,0D
003CC:  DATA 0A,00
003CE:  DATA 09,09
003D0:  DATA 20,20
003D2:  DATA 20,4D
003D4:  DATA 79,20
003D6:  DATA 64,65
003D8:  DATA 76,69
003DA:  DATA 63,65
003DC:  DATA 20,49
003DE:  DATA 44,3A
003E0:  DATA 20,25
003E2:  DATA 58,0D
003E4:  DATA 0A,00
003E6:  DATA 09,5B
003E8:  DATA 42,4F
003EA:  DATA 53,53
003EC:  DATA 5D,20
003EE:  DATA 3C,3C
003F0:  DATA 3C,20
003F2:  DATA 00,00
003F4:  DATA 53,74
003F6:  DATA 61,72
003F8:  DATA 74,20
003FA:  DATA 53,4D
003FC:  DATA 46,20
003FE:  DATA 75,73
00400:  DATA 69,6E
00402:  DATA 67,20
00404:  DATA 72,65
00406:  DATA 71,65
00408:  DATA 73,74
0040A:  DATA 20,73
0040C:  DATA 65,61
0040E:  DATA 71,75
00410:  DATA 65,6E
00412:  DATA 63,65
00414:  DATA 0D,0A
00416:  DATA 00,00
00418:  DATA 45,72
0041A:  DATA 72,6F
0041C:  DATA 72,21
0041E:  DATA 20,52
00420:  DATA 65,63
00422:  DATA 65,69
00424:  DATA 76,69
00426:  DATA 6E,67
00428:  DATA 20,63
0042A:  DATA 6F,6D
0042C:  DATA 6D,61
0042E:  DATA 6E,64
00430:  DATA 20,69
00432:  DATA 6E,63
00434:  DATA 6F,6E
00436:  DATA 73,69
00438:  DATA 73,74
0043A:  DATA 65,6E
0043C:  DATA 74,20
0043E:  DATA 77,69
00440:  DATA 74,68
00442:  DATA 20,74
00444:  DATA 68,65
00446:  DATA 20,64
00448:  DATA 65,73
0044A:  DATA 69,67
0044C:  DATA 6E,0D
0044E:  DATA 0A,00
00450:  DATA 53,4D
00452:  DATA 46,20
00454:  DATA 75,73
00456:  DATA 65,20
00458:  DATA 72,65
0045A:  DATA 71,75
0045C:  DATA 65,73
0045E:  DATA 74,20
00460:  DATA 61,6C
00462:  DATA 6C,6F
00464:  DATA 77,65
00466:  DATA 64,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 64,65
0047C:  DATA 6E,79
0047E:  DATA 65,64
00480:  DATA 0D,0A
00482:  DATA 00,00
00484:  DATA 52,65
00486:  DATA 74,72
00488:  DATA 79,20
0048A:  DATA 72,65
0048C:  DATA 71,75
0048E:  DATA 65,73
00490:  DATA 74,20
00492:  DATA 74,6F
00494:  DATA 20,42
00496:  DATA 4F,53
00498:  DATA 53,20
0049A:  DATA 50,49
0049C:  DATA 43,0D
0049E:  DATA 0A,00
004A0:  DATA 45,72
004A2:  DATA 72,6F
004A4:  DATA 72,21
004A6:  DATA 20,52
004A8:  DATA 65,63
004AA:  DATA 65,69
004AC:  DATA 76,69
004AE:  DATA 6E,67
004B0:  DATA 20,63
004B2:  DATA 6F,6D
004B4:  DATA 6D,61
004B6:  DATA 6E,64
004B8:  DATA 20,69
004BA:  DATA 6E,63
004BC:  DATA 6F,6E
004BE:  DATA 73,69
004C0:  DATA 73,74
004C2:  DATA 65,6E
004C4:  DATA 74,20
004C6:  DATA 77,69
004C8:  DATA 74,68
004CA:  DATA 20,74
004CC:  DATA 68,65
004CE:  DATA 20,64
004D0:  DATA 65,73
004D2:  DATA 69,67
004D4:  DATA 6E,0D
004D6:  DATA 0A,00
004D8:  DATA 45,6E
004DA:  DATA 64,20
004DC:  DATA 53,4D
004DE:  DATA 46,20
004E0:  DATA 75,73
004E2:  DATA 69,6E
004E4:  DATA 67,20
004E6:  DATA 72,65
004E8:  DATA 71,65
004EA:  DATA 73,74
004EC:  DATA 20,73
004EE:  DATA 65,61
004F0:  DATA 71,75
004F2:  DATA 65,6E
004F4:  DATA 63,65
004F6:  DATA 0D,0A
004F8:  DATA 00,00
004FA:  DATA 49,4F
004FC:  DATA 20,49
004FE:  DATA 6E,69
00500:  DATA 74,69
00502:  DATA 61,6C
00504:  DATA 69,7A
00506:  DATA 65,0D
00508:  DATA 0A,00
0050A:  DATA 09,43
0050C:  DATA 6F,6D
0050E:  DATA 70,6C
00510:  DATA 65,74
00512:  DATA 65,0D
00514:  DATA 0A,00
00516:  DATA 53,74
00518:  DATA 61,72
0051A:  DATA 74,20
0051C:  DATA 54,45
0051E:  DATA 53,54
00520:  DATA 20,53
00522:  DATA 57,45
00524:  DATA 45,50
00526:  DATA 0D,0A
00528:  DATA 00,00
0052A:  DATA 73,74
0052C:  DATA 65,70
0052E:  DATA 2C,20
00530:  DATA 76,6F
00532:  DATA 6C,74
00534:  DATA 61,67
00536:  DATA 65,2C
00538:  DATA 20,63
0053A:  DATA 75,72
0053C:  DATA 72,65
0053E:  DATA 6E,74
00540:  DATA 0D,0A
00542:  DATA 00,00
00544:  DATA 53,74
00546:  DATA 61,72
00548:  DATA 74,20
0054A:  DATA 41,44
0054C:  DATA 43,20
0054E:  DATA 54,45
00550:  DATA 53,54
00552:  DATA 0D,0A
00554:  DATA 00,00
00556:  DATA 41,44
00558:  DATA 43,20
0055A:  DATA 56,6F
0055C:  DATA 6C,74
0055E:  DATA 61,67
00560:  DATA 65,3A
00562:  DATA 20,25
00564:  DATA 30,34
00566:  DATA 4C,58
00568:  DATA 0D,0A
0056A:  DATA 00,00
0056C:  DATA 41,44
0056E:  DATA 43,20
00570:  DATA 43,75
00572:  DATA 72,72
00574:  DATA 65,6E
00576:  DATA 74,3A
00578:  DATA 20,25
0057A:  DATA 30,34
0057C:  DATA 4C,58
0057E:  DATA 0D,0A
00580:  DATA 00,00
00582:  DATA 41,44
00584:  DATA 43,20
00586:  DATA 43,49
00588:  DATA 47,53
0058A:  DATA 31,20
0058C:  DATA 41,6D
0058E:  DATA 70,3A
00590:  DATA 20,25
00592:  DATA 30,34
00594:  DATA 4C,58
00596:  DATA 0D,0A
00598:  DATA 00,00
0059A:  DATA 41,44
0059C:  DATA 43,20
0059E:  DATA 43,49
005A0:  DATA 47,53
005A2:  DATA 31,20
005A4:  DATA 56,52
005A6:  DATA 45,46
005A8:  DATA 3A,20
005AA:  DATA 25,30
005AC:  DATA 34,4C
005AE:  DATA 58,0D
005B0:  DATA 0A,00
005B2:  DATA 53,74
005B4:  DATA 61,72
005B6:  DATA 74,20
005B8:  DATA 53,57
005BA:  DATA 45,45
005BC:  DATA 50,20
005BE:  DATA 32,70
005C0:  DATA 6F,72
005C2:  DATA 74,73
005C4:  DATA 0D,0A
005C6:  DATA 00,00
005C8:  DATA 09,53
005CA:  DATA 77,65
005CC:  DATA 65,70
005CE:  DATA 20,73
005D0:  DATA 74,65
005D2:  DATA 70,20
005D4:  DATA 3A,20
005D6:  DATA 25,75
005D8:  DATA 0D,0A
005DA:  DATA 00,00
005DC:  DATA 45,4E
005DE:  DATA 44,20
005E0:  DATA 53,57
005E2:  DATA 45,45
005E4:  DATA 50,20
005E6:  DATA 32,70
005E8:  DATA 6F,72
005EA:  DATA 74,0D
005EC:  DATA 0A,00
005EE:  DATA 53,74
005F0:  DATA 61,72
005F2:  DATA 74,20
005F4:  DATA 43,49
005F6:  DATA 47,53
005F8:  DATA 20,64
005FA:  DATA 61,74
005FC:  DATA 61,20
005FE:  DATA 63,6F
00600:  DATA 6E,76
00602:  DATA 65,72
00604:  DATA 73,69
00606:  DATA 6F,6E
00608:  DATA 0D,0A
0060A:  DATA 00,00
0060C:  DATA 53,74
0060E:  DATA 61,72
00610:  DATA 74,20
00612:  DATA 53,57
00614:  DATA 45,45
00616:  DATA 50,20
00618:  DATA 50,4F
0061A:  DATA 52,54
0061C:  DATA 31,0D
0061E:  DATA 0A,00
00620:  DATA 09,53
00622:  DATA 77,65
00624:  DATA 65,70
00626:  DATA 20,73
00628:  DATA 74,65
0062A:  DATA 70,20
0062C:  DATA 3A,20
0062E:  DATA 25,75
00630:  DATA 0D,0A
00632:  DATA 00,00
00634:  DATA 45,4E
00636:  DATA 44,20
00638:  DATA 53,57
0063A:  DATA 45,45
0063C:  DATA 50,20
0063E:  DATA 50,4F
00640:  DATA 52,54
00642:  DATA 31,0D
00644:  DATA 0A,00
00646:  DATA 53,74
00648:  DATA 61,72
0064A:  DATA 74,20
0064C:  DATA 43,49
0064E:  DATA 47,53
00650:  DATA 20,64
00652:  DATA 61,74
00654:  DATA 61,20
00656:  DATA 63,6F
00658:  DATA 6E,76
0065A:  DATA 65,72
0065C:  DATA 73,69
0065E:  DATA 6F,6E
00660:  DATA 0D,0A
00662:  DATA 00,00
00664:  DATA 45,6E
00666:  DATA 64,20
00668:  DATA 43,49
0066A:  DATA 47,53
0066C:  DATA 20,64
0066E:  DATA 61,74
00670:  DATA 61,20
00672:  DATA 63,6F
00674:  DATA 6E,76
00676:  DATA 65,72
00678:  DATA 73,69
0067A:  DATA 6F,6E
0067C:  DATA 0D,0A
0067E:  DATA 00,00
00680:  DATA 53,74
00682:  DATA 61,72
00684:  DATA 74,20
00686:  DATA 53,57
00688:  DATA 45,45
0068A:  DATA 50,20
0068C:  DATA 50,4F
0068E:  DATA 52,54
00690:  DATA 32,0D
00692:  DATA 0A,00
00694:  DATA 09,53
00696:  DATA 77,65
00698:  DATA 65,70
0069A:  DATA 20,73
0069C:  DATA 74,65
0069E:  DATA 70,20
006A0:  DATA 3A,20
006A2:  DATA 25,75
006A4:  DATA 0D,0A
006A6:  DATA 00,00
006A8:  DATA 45,4E
006AA:  DATA 44,20
006AC:  DATA 53,57
006AE:  DATA 45,45
006B0:  DATA 50,20
006B2:  DATA 50,4F
006B4:  DATA 52,54
006B6:  DATA 32,0D
006B8:  DATA 0A,00
006BA:  DATA 53,74
006BC:  DATA 61,72
006BE:  DATA 74,20
006C0:  DATA 43,49
006C2:  DATA 47,53
006C4:  DATA 20,64
006C6:  DATA 61,74
006C8:  DATA 61,20
006CA:  DATA 63,6F
006CC:  DATA 6E,76
006CE:  DATA 65,72
006D0:  DATA 73,69
006D2:  DATA 6F,6E
006D4:  DATA 0D,0A
006D6:  DATA 00,00
006D8:  DATA 53,74
006DA:  DATA 61,72
006DC:  DATA 74,20
006DE:  DATA 53,57
006E0:  DATA 45,45
006E2:  DATA 50,20
006E4:  DATA 77,69
006E6:  DATA 74,68
006E8:  DATA 20,74
006EA:  DATA 68,72
006EC:  DATA 65,73
006EE:  DATA 68,6F
006F0:  DATA 6C,64
006F2:  DATA 0D,0A
006F4:  DATA 00,00
006F6:  DATA 43,49
006F8:  DATA 47,53
006FA:  DATA 32,20
006FC:  DATA 64,61
006FE:  DATA 74,61
00700:  DATA 3A,20
00702:  DATA 25,30
00704:  DATA 34,4C
00706:  DATA 58,2C
00708:  DATA 20,25
0070A:  DATA 30,34
0070C:  DATA 4C,58
0070E:  DATA 0D,0A
00710:  DATA 00,00
00712:  DATA 4D,61
00714:  DATA 78,69
00716:  DATA 6D,75
00718:  DATA 6D,20
0071A:  DATA 73,74
0071C:  DATA 65,70
0071E:  DATA 20,63
00720:  DATA 6F,75
00722:  DATA 6E,74
00724:  DATA 20,72
00726:  DATA 65,61
00728:  DATA 63,68
0072A:  DATA 65,64
0072C:  DATA 3A,20
0072E:  DATA 25,6C
00730:  DATA 64,0D
00732:  DATA 0A,00
00734:  DATA 43,49
00736:  DATA 47,53
00738:  DATA 31,20
0073A:  DATA 63,75
0073C:  DATA 72,72
0073E:  DATA 65,6E
00740:  DATA 74,20
00742:  DATA 6C,69
00744:  DATA 6D,69
00746:  DATA 74,20
00748:  DATA 72,65
0074A:  DATA 61,63
0074C:  DATA 68,65
0074E:  DATA 64,3A
00750:  DATA 00,00
00752:  DATA 43,49
00754:  DATA 47,53
00756:  DATA 31,20
00758:  DATA 63,75
0075A:  DATA 72,72
0075C:  DATA 65,6E
0075E:  DATA 74,20
00760:  DATA 62,65
00762:  DATA 6C,6F
00764:  DATA 77,20
00766:  DATA 74,68
00768:  DATA 72,65
0076A:  DATA 73,68
0076C:  DATA 6F,6C
0076E:  DATA 64,00
00770:  DATA 43,49
00772:  DATA 47,53
00774:  DATA 32,20
00776:  DATA 63,75
00778:  DATA 72,72
0077A:  DATA 65,6E
0077C:  DATA 74,20
0077E:  DATA 6C,69
00780:  DATA 6D,69
00782:  DATA 74,20
00784:  DATA 72,65
00786:  DATA 61,63
00788:  DATA 68,65
0078A:  DATA 64,3A
0078C:  DATA 20,00
0078E:  DATA 43,49
00790:  DATA 47,53
00792:  DATA 32,20
00794:  DATA 63,75
00796:  DATA 72,72
00798:  DATA 65,6E
0079A:  DATA 74,20
0079C:  DATA 62,65
0079E:  DATA 6C,6F
007A0:  DATA 77,20
007A2:  DATA 74,68
007A4:  DATA 72,65
007A6:  DATA 73,68
007A8:  DATA 6F,6C
007AA:  DATA 64,3A
007AC:  DATA 00,00
007AE:  DATA 45,6E
007B0:  DATA 64,20
007B2:  DATA 53,57
007B4:  DATA 45,45
007B6:  DATA 50,20
007B8:  DATA 77,69
007BA:  DATA 74,68
007BC:  DATA 20,74
007BE:  DATA 68,72
007C0:  DATA 65,73
007C2:  DATA 68,6F
007C4:  DATA 6C,64
007C6:  DATA 0D,0A
007C8:  DATA 00,00
007CA:  DATA 45,6E
007CC:  DATA 64,20
007CE:  DATA 43,49
007D0:  DATA 47,53
007D2:  DATA 20,64
007D4:  DATA 61,74
007D6:  DATA 61,20
007D8:  DATA 63,6F
007DA:  DATA 6E,76
007DC:  DATA 65,72
007DE:  DATA 73,69
007E0:  DATA 6F,6E
007E2:  DATA 0D,0A
007E4:  DATA 00,00
007E6:  DATA 43,52
007E8:  DATA 43,20
007EA:  DATA 76,65
007EC:  DATA 72,69
007EE:  DATA 66,69
007F0:  DATA 63,61
007F2:  DATA 74,69
007F4:  DATA 6F,6E
007F6:  DATA 20,70
007F8:  DATA 61,73
007FA:  DATA 73,65
007FC:  DATA 64,20
007FE:  DATA 6F,6E
00800:  DATA 20,61
00802:  DATA 74,74
00804:  DATA 65,6D
00806:  DATA 70,74
00808:  DATA 20,25
0080A:  DATA 75,0D
0080C:  DATA 0A,00
0080E:  DATA 43,52
00810:  DATA 43,20
00812:  DATA 76,65
00814:  DATA 72,69
00816:  DATA 66,69
00818:  DATA 63,61
0081A:  DATA 74,69
0081C:  DATA 6F,6E
0081E:  DATA 20,70
00820:  DATA 61,73
00822:  DATA 73,65
00824:  DATA 64,20
00826:  DATA 6F,6E
00828:  DATA 20,61
0082A:  DATA 74,74
0082C:  DATA 65,6D
0082E:  DATA 70,74
00830:  DATA 20,25
00832:  DATA 64,0D
00834:  DATA 0A,00
00836:  DATA 45,72
00838:  DATA 72,6F
0083A:  DATA 72,3A
0083C:  DATA 20,43
0083E:  DATA 52,43
00840:  DATA 20,76
00842:  DATA 65,72
00844:  DATA 69,66
00846:  DATA 69,63
00848:  DATA 61,74
0084A:  DATA 69,6F
0084C:  DATA 6E,20
0084E:  DATA 66,61
00850:  DATA 69,6C
00852:  DATA 65,64
00854:  DATA 20,61
00856:  DATA 66,74
00858:  DATA 65,72
0085A:  DATA 20,25
0085C:  DATA 64,20
0085E:  DATA 61,74
00860:  DATA 74,65
00862:  DATA 6D,70
00864:  DATA 74,73
00866:  DATA 0D,0A
00868:  DATA 00,00
0086A:  DATA 0D,0A
0086C:  DATA 5F,5F
0086E:  DATA 5F,5F
00870:  DATA 5F,5F
00872:  DATA 5F,5F
00874:  DATA 5F,5F
00876:  DATA 5F,5F
00878:  DATA 5F,5F
0087A:  DATA 5F,5F
0087C:  DATA 5F,5F
0087E:  DATA 5F,5F
00880:  DATA 0D,0A
00882:  DATA 00,00
00884:  DATA 5F,5F
00886:  DATA 5F,53
00888:  DATA 74,61
0088A:  DATA 72,74
0088C:  DATA 20,63
0088E:  DATA 6F,70
00890:  DATA 79,5F
00892:  DATA 64,61
00894:  DATA 74,61
00896:  DATA 5F,5F
00898:  DATA 0D,0A
0089A:  DATA 00,00
0089C:  DATA 49,6E
0089E:  DATA 20,53
008A0:  DATA 4D,46
008A2:  DATA 20,6D
008A4:  DATA 69,73
008A6:  DATA 73,69
008A8:  DATA 6F,6E
008AA:  DATA 20,64
008AC:  DATA 61,74
008AE:  DATA 61,20
008B0:  DATA 73,74
008B2:  DATA 61,72
008B4:  DATA 74,20
008B6:  DATA 20,20
008B8:  DATA 61,64
008BA:  DATA 64,72
008BC:  DATA 65,73
008BE:  DATA 73,3A
008C0:  DATA 20,25
008C2:  DATA 4C,58
008C4:  DATA 0D,0A
008C6:  DATA 00,00
008C8:  DATA 49,6E
008CA:  DATA 20,53
008CC:  DATA 4D,46
008CE:  DATA 20,6D
008D0:  DATA 69,73
008D2:  DATA 73,69
008D4:  DATA 6F,6E
008D6:  DATA 20,64
008D8:  DATA 61,74
008DA:  DATA 61,20
008DC:  DATA 65,6E
008DE:  DATA 64,20
008E0:  DATA 20,20
008E2:  DATA 20,20
008E4:  DATA 61,64
008E6:  DATA 64,72
008E8:  DATA 65,73
008EA:  DATA 73,3A
008EC:  DATA 20,25
008EE:  DATA 4C,58
008F0:  DATA 0D,0A
008F2:  DATA 00,00
008F4:  DATA 49,6E
008F6:  DATA 20,4D
008F8:  DATA 49,53
008FA:  DATA 20,46
008FC:  DATA 4D,20
008FE:  DATA 57,72
00900:  DATA 69,74
00902:  DATA 65,20
00904:  DATA 73,6F
00906:  DATA 75,72
00908:  DATA 63,65
0090A:  DATA 20,64
0090C:  DATA 61,74
0090E:  DATA 61,20
00910:  DATA 61,64
00912:  DATA 64,72
00914:  DATA 65,73
00916:  DATA 73,3A
00918:  DATA 20,25
0091A:  DATA 4C,58
0091C:  DATA 0D,0A
0091E:  DATA 00,00
00920:  DATA 49,6E
00922:  DATA 20,4D
00924:  DATA 49,53
00926:  DATA 20,46
00928:  DATA 4D,20
0092A:  DATA 57,72
0092C:  DATA 69,74
0092E:  DATA 65,20
00930:  DATA 64,61
00932:  DATA 74,61
00934:  DATA 20,73
00936:  DATA 69,7A
00938:  DATA 65,20
0093A:  DATA 20,20
0093C:  DATA 20,20
0093E:  DATA 20,20
00940:  DATA 20,20
00942:  DATA 20,3A
00944:  DATA 20,25
00946:  DATA 6C,75
00948:  DATA 20,28
0094A:  DATA 30,78
0094C:  DATA 25,6C
0094E:  DATA 78,29
00950:  DATA 0D,0A
00952:  DATA 0D,0A
00954:  DATA 00,00
00956:  DATA 45,72
00958:  DATA 72,6F
0095A:  DATA 72,3A
0095C:  DATA 20,4D
0095E:  DATA 49,53
00960:  DATA 20,46
00962:  DATA 4D,20
00964:  DATA 69,73
00966:  DATA 20,6E
00968:  DATA 6F,74
0096A:  DATA 20,63
0096C:  DATA 6F,6E
0096E:  DATA 6E,65
00970:  DATA 63,74
00972:  DATA 65,64
00974:  DATA 0D,0A
00976:  DATA 00,00
00978:  DATA 45,72
0097A:  DATA 72,6F
0097C:  DATA 72,3A
0097E:  DATA 20,53
00980:  DATA 4D,46
00982:  DATA 20,69
00984:  DATA 73,20
00986:  DATA 6E,6F
00988:  DATA 74,20
0098A:  DATA 63,6F
0098C:  DATA 6E,6E
0098E:  DATA 65,63
00990:  DATA 74,65
00992:  DATA 64,0D
00994:  DATA 0A,00
00996:  DATA 53,69
00998:  DATA 7A,65
0099A:  DATA 20,61
0099C:  DATA 72,65
0099E:  DATA 61,20
009A0:  DATA 72,65
009A2:  DATA 61,64
009A4:  DATA 0D,0A
009A6:  DATA 00,00
009A8:  DATA 75,73
009AA:  DATA 65,64
009AC:  DATA 5F,73
009AE:  DATA 69,7A
009B0:  DATA 65,20
009B2:  DATA 3D,20
009B4:  DATA 25,6C
009B6:  DATA 64,20
009B8:  DATA 28,73
009BA:  DATA 72,63
009BC:  DATA 20,30
009BE:  DATA 78,25
009C0:  DATA 30,38
009C2:  DATA 4C,58
009C4:  DATA 29,0D
009C6:  DATA 0A,00
009C8:  DATA 6C,6F
009CA:  DATA 6F,70
009CC:  DATA 20,63
009CE:  DATA 6F,75
009D0:  DATA 6E,74
009D2:  DATA 3D,20
009D4:  DATA 25,64
009D6:  DATA 20,20
009D8:  DATA 28,73
009DA:  DATA 72,63
009DC:  DATA 20,30
009DE:  DATA 78,25
009E0:  DATA 30,38
009E2:  DATA 4C,58
009E4:  DATA 29,0D
009E6:  DATA 0A,0D
009E8:  DATA 0A,00
009EA:  DATA 57,72
009EC:  DATA 61,70
009EE:  DATA 20,74
009F0:  DATA 72,69
009F2:  DATA 67,67
009F4:  DATA 65,72
009F6:  DATA 65,64
009F8:  DATA 3A,20
009FA:  DATA 52,65
009FC:  DATA 73,65
009FE:  DATA 74,74
00A00:  DATA 69,6E
00A02:  DATA 67,20
00A04:  DATA 64,61
00A06:  DATA 74,61
00A08:  DATA 5F,77
00A0A:  DATA 72,69
00A0C:  DATA 74,65
00A0E:  DATA 5F,61
00A10:  DATA 64,64
00A12:  DATA 72,20
00A14:  DATA 74,6F
00A16:  DATA 20,73
00A18:  DATA 74,61
00A1A:  DATA 72,74
00A1C:  DATA 0D,0A
00A1E:  DATA 00,00
00A20:  DATA 75,73
00A22:  DATA 65,64
00A24:  DATA 5F,73
00A26:  DATA 69,7A
00A28:  DATA 65,20
00A2A:  DATA 3D,20
00A2C:  DATA 25,6C
00A2E:  DATA 64,0D
00A30:  DATA 0A,00
00A32:  DATA 6C,6F
00A34:  DATA 6F,70
00A36:  DATA 5F,63
00A38:  DATA 6F,75
00A3A:  DATA 6E,74
00A3C:  DATA 20,3D
00A3E:  DATA 20,25
00A40:  DATA 75,0D
00A42:  DATA 0A,0D
00A44:  DATA 0A,00
00A46:  DATA 0D,0A
00A48:  DATA 5F,5F
00A4A:  DATA 5F,45
00A4C:  DATA 6E,64
00A4E:  DATA 20,63
00A50:  DATA 6F,70
00A52:  DATA 79,5F
00A54:  DATA 64,61
00A56:  DATA 74,61
00A58:  DATA 5F,5F
00A5A:  DATA 5F,5F
00A5C:  DATA 0D,0A
00A5E:  DATA 00,00
00A60:  DATA 5F,5F
00A62:  DATA 5F,5F
00A64:  DATA 5F,5F
00A66:  DATA 5F,5F
00A68:  DATA 5F,5F
00A6A:  DATA 5F,5F
00A6C:  DATA 5F,5F
00A6E:  DATA 5F,5F
00A70:  DATA 5F,5F
00A72:  DATA 5F,5F
00A74:  DATA 0D,0A
00A76:  DATA 0D,0A
00A78:  DATA 00,00
00A7A:  DATA 0D,0A
00A7C:  DATA 5F,5F
00A7E:  DATA 5F,5F
00A80:  DATA 5F,5F
00A82:  DATA 5F,5F
00A84:  DATA 5F,5F
00A86:  DATA 5F,5F
00A88:  DATA 5F,5F
00A8A:  DATA 5F,5F
00A8C:  DATA 5F,5F
00A8E:  DATA 5F,5F
00A90:  DATA 0D,0A
00A92:  DATA 00,00
00A94:  DATA 5F,5F
00A96:  DATA 5F,53
00A98:  DATA 74,61
00A9A:  DATA 72,74
00A9C:  DATA 20,53
00A9E:  DATA 4D,46
00AA0:  DATA 20,52
00AA2:  DATA 65,61
00AA4:  DATA 64,5F
00AA6:  DATA 5F,5F
00AA8:  DATA 5F,0D
00AAA:  DATA 0A,00
00AAC:  DATA 49,6E
00AAE:  DATA 20,53
00AB0:  DATA 4D,46
00AB2:  DATA 20,52
00AB4:  DATA 65,61
00AB6:  DATA 64,20
00AB8:  DATA 73,6F
00ABA:  DATA 75,72
00ABC:  DATA 63,65
00ABE:  DATA 20,64
00AC0:  DATA 61,74
00AC2:  DATA 61,20
00AC4:  DATA 61,64
00AC6:  DATA 64,72
00AC8:  DATA 65,73
00ACA:  DATA 73,3A
00ACC:  DATA 20,25
00ACE:  DATA 4C,58
00AD0:  DATA 0D,0A
00AD2:  DATA 00,00
00AD4:  DATA 49,6E
00AD6:  DATA 20,53
00AD8:  DATA 4D,46
00ADA:  DATA 20,52
00ADC:  DATA 65,61
00ADE:  DATA 64,20
00AE0:  DATA 64,61
00AE2:  DATA 74,61
00AE4:  DATA 20,73
00AE6:  DATA 69,7A
00AE8:  DATA 65,20
00AEA:  DATA 20,20
00AEC:  DATA 20,20
00AEE:  DATA 20,20
00AF0:  DATA 20,20
00AF2:  DATA 20,3A
00AF4:  DATA 20,25
00AF6:  DATA 6C,75
00AF8:  DATA 20,28
00AFA:  DATA 30,78
00AFC:  DATA 25,6C
00AFE:  DATA 78,29
00B00:  DATA 0D,0A
00B02:  DATA 0D,0A
00B04:  DATA 00,00
00B06:  DATA 45,72
00B08:  DATA 72,6F
00B0A:  DATA 72,3A
00B0C:  DATA 20,53
00B0E:  DATA 4D,46
00B10:  DATA 20,69
00B12:  DATA 73,20
00B14:  DATA 6E,6F
00B16:  DATA 74,20
00B18:  DATA 63,6F
00B1A:  DATA 6E,6E
00B1C:  DATA 65,63
00B1E:  DATA 74,65
00B20:  DATA 64,0D
00B22:  DATA 0A,00
00B24:  DATA 52,45
00B26:  DATA 41,44
00B28:  DATA 20,44
00B2A:  DATA 41,54
00B2C:  DATA 41,20
00B2E:  DATA 46,52
00B30:  DATA 4F,4D
00B32:  DATA 20,53
00B34:  DATA 4D,46
00B36:  DATA 2E,2E
00B38:  DATA 2E,0D
00B3A:  DATA 0A,00
00B3C:  DATA 0D,0A
00B3E:  DATA 5F,5F
00B40:  DATA 5F,45
00B42:  DATA 6E,64
00B44:  DATA 20,53
00B46:  DATA 4D,46
00B48:  DATA 20,52
00B4A:  DATA 65,61
00B4C:  DATA 64,5F
00B4E:  DATA 5F,5F
00B50:  DATA 5F,0D
00B52:  DATA 0A,00
00B54:  DATA 5F,5F
00B56:  DATA 5F,5F
00B58:  DATA 5F,5F
00B5A:  DATA 5F,5F
00B5C:  DATA 5F,5F
00B5E:  DATA 5F,5F
00B60:  DATA 5F,5F
00B62:  DATA 5F,5F
00B64:  DATA 5F,5F
00B66:  DATA 5F,5F
00B68:  DATA 0D,0A
00B6A:  DATA 0D,0A
00B6C:  DATA 00,00
00B6E:  DATA 0D,0A
00B70:  DATA 5F,5F
00B72:  DATA 5F,5F
00B74:  DATA 5F,5F
00B76:  DATA 5F,5F
00B78:  DATA 5F,5F
00B7A:  DATA 5F,5F
00B7C:  DATA 5F,5F
00B7E:  DATA 5F,5F
00B80:  DATA 5F,5F
00B82:  DATA 5F,5F
00B84:  DATA 0D,0A
00B86:  DATA 00,00
00B88:  DATA 5F,5F
00B8A:  DATA 5F,53
00B8C:  DATA 74,61
00B8E:  DATA 72,74
00B90:  DATA 20,73
00B92:  DATA 6D,66
00B94:  DATA 5F,65
00B96:  DATA 72,61
00B98:  DATA 73,65
00B9A:  DATA 5F,5F
00B9C:  DATA 5F,5F
00B9E:  DATA 0D,0A
00BA0:  DATA 00,00
00BA2:  DATA 49,6E
00BA4:  DATA 20,53
00BA6:  DATA 4D,46
00BA8:  DATA 20,6D
00BAA:  DATA 69,73
00BAC:  DATA 73,69
00BAE:  DATA 6F,6E
00BB0:  DATA 20,64
00BB2:  DATA 61,74
00BB4:  DATA 61,20
00BB6:  DATA 73,74
00BB8:  DATA 61,72
00BBA:  DATA 74,20
00BBC:  DATA 20,20
00BBE:  DATA 61,64
00BC0:  DATA 64,72
00BC2:  DATA 65,73
00BC4:  DATA 73,3A
00BC6:  DATA 20,25
00BC8:  DATA 4C,58
00BCA:  DATA 0D,0A
00BCC:  DATA 00,00
00BCE:  DATA 49,6E
00BD0:  DATA 20,53
00BD2:  DATA 4D,46
00BD4:  DATA 20,6D
00BD6:  DATA 69,73
00BD8:  DATA 73,69
00BDA:  DATA 6F,6E
00BDC:  DATA 20,64
00BDE:  DATA 61,74
00BE0:  DATA 61,20
00BE2:  DATA 65,6E
00BE4:  DATA 64,20
00BE6:  DATA 20,20
00BE8:  DATA 20,20
00BEA:  DATA 61,64
00BEC:  DATA 64,72
00BEE:  DATA 65,73
00BF0:  DATA 73,3A
00BF2:  DATA 20,25
00BF4:  DATA 4C,58
00BF6:  DATA 0D,0A
00BF8:  DATA 00,00
00BFA:  DATA 49,6E
00BFC:  DATA 20,53
00BFE:  DATA 4D,46
00C00:  DATA 20,45
00C02:  DATA 72,61
00C04:  DATA 73,65
00C06:  DATA 20,73
00C08:  DATA 6F,75
00C0A:  DATA 72,63
00C0C:  DATA 65,20
00C0E:  DATA 64,61
00C10:  DATA 74,61
00C12:  DATA 20,61
00C14:  DATA 64,64
00C16:  DATA 72,65
00C18:  DATA 73,73
00C1A:  DATA 3A,20
00C1C:  DATA 25,4C
00C1E:  DATA 58,0D
00C20:  DATA 0A,00
00C22:  DATA 49,6E
00C24:  DATA 20,53
00C26:  DATA 4D,46
00C28:  DATA 20,45
00C2A:  DATA 72,61
00C2C:  DATA 73,65
00C2E:  DATA 20,64
00C30:  DATA 61,74
00C32:  DATA 61,20
00C34:  DATA 73,69
00C36:  DATA 7A,65
00C38:  DATA 20,20
00C3A:  DATA 20,20
00C3C:  DATA 20,20
00C3E:  DATA 20,20
00C40:  DATA 20,20
00C42:  DATA 3A,20
00C44:  DATA 25,6C
00C46:  DATA 75,20
00C48:  DATA 28,30
00C4A:  DATA 78,25
00C4C:  DATA 6C,78
00C4E:  DATA 29,0D
00C50:  DATA 0A,0D
00C52:  DATA 0A,00
00C54:  DATA 45,72
00C56:  DATA 72,6F
00C58:  DATA 72,3A
00C5A:  DATA 20,53
00C5C:  DATA 4D,46
00C5E:  DATA 20,69
00C60:  DATA 73,20
00C62:  DATA 6E,6F
00C64:  DATA 74,20
00C66:  DATA 63,6F
00C68:  DATA 6E,6E
00C6A:  DATA 65,63
00C6C:  DATA 74,65
00C6E:  DATA 64,0D
00C70:  DATA 0A,00
00C72:  DATA 45,72
00C74:  DATA 72,6F
00C76:  DATA 72,3A
00C78:  DATA 20,45
00C7A:  DATA 72,61
00C7C:  DATA 73,65
00C7E:  DATA 20,73
00C80:  DATA 6F,75
00C82:  DATA 72,63
00C84:  DATA 65,20
00C86:  DATA 61,64
00C88:  DATA 64,72
00C8A:  DATA 65,73
00C8C:  DATA 73,20
00C8E:  DATA 30,78
00C90:  DATA 25,4C
00C92:  DATA 58,20
00C94:  DATA 69,73
00C96:  DATA 20,6F
00C98:  DATA 75,74
00C9A:  DATA 73,69
00C9C:  DATA 64,65
00C9E:  DATA 20,6D
00CA0:  DATA 69,73
00CA2:  DATA 73,69
00CA4:  DATA 6F,6E
00CA6:  DATA 20,72
00CA8:  DATA 61,6E
00CAA:  DATA 67,65
00CAC:  DATA 20,5B
00CAE:  DATA 30,78
00CB0:  DATA 25,4C
00CB2:  DATA 58,20
00CB4:  DATA 2D,20
00CB6:  DATA 30,78
00CB8:  DATA 25,4C
00CBA:  DATA 58,5D
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 45,72
00CC2:  DATA 72,6F
00CC4:  DATA 72,3A
00CC6:  DATA 20,45
00CC8:  DATA 72,61
00CCA:  DATA 73,65
00CCC:  DATA 20,6F
00CCE:  DATA 70,65
00CD0:  DATA 72,61
00CD2:  DATA 74,69
00CD4:  DATA 6F,6E
00CD6:  DATA 20,77
00CD8:  DATA 6F,75
00CDA:  DATA 6C,64
00CDC:  DATA 20,65
00CDE:  DATA 78,63
00CE0:  DATA 65,65
00CE2:  DATA 64,20
00CE4:  DATA 6D,69
00CE6:  DATA 73,73
00CE8:  DATA 69,6F
00CEA:  DATA 6E,20
00CEC:  DATA 65,6E
00CEE:  DATA 64,20
00CF0:  DATA 61,64
00CF2:  DATA 64,72
00CF4:  DATA 65,73
00CF6:  DATA 73,20
00CF8:  DATA 30,78
00CFA:  DATA 25,4C
00CFC:  DATA 58,0D
00CFE:  DATA 0A,00
00D00:  DATA 4C,69
00D02:  DATA 6D,69
00D04:  DATA 74,69
00D06:  DATA 6E,67
00D08:  DATA 20,65
00D0A:  DATA 72,61
00D0C:  DATA 73,65
00D0E:  DATA 20,73
00D10:  DATA 69,7A
00D12:  DATA 65,20
00D14:  DATA 74,6F
00D16:  DATA 20,73
00D18:  DATA 74,61
00D1A:  DATA 79,20
00D1C:  DATA 77,69
00D1E:  DATA 74,68
00D20:  DATA 69,6E
00D22:  DATA 20,6D
00D24:  DATA 69,73
00D26:  DATA 73,69
00D28:  DATA 6F,6E
00D2A:  DATA 20,62
00D2C:  DATA 6F,75
00D2E:  DATA 6E,64
00D30:  DATA 73,0D
00D32:  DATA 0A,00
00D34:  DATA 45,72
00D36:  DATA 61,73
00D38:  DATA 65,20
00D3A:  DATA 6F,70
00D3C:  DATA 65,72
00D3E:  DATA 61,74
00D40:  DATA 69,6F
00D42:  DATA 6E,20
00D44:  DATA 76,61
00D46:  DATA 6C,69
00D48:  DATA 64,61
00D4A:  DATA 74,65
00D4C:  DATA 64,20
00D4E:  DATA 77,69
00D50:  DATA 74,68
00D52:  DATA 69,6E
00D54:  DATA 20,6D
00D56:  DATA 69,73
00D58:  DATA 73,69
00D5A:  DATA 6F,6E
00D5C:  DATA 20,72
00D5E:  DATA 61,6E
00D60:  DATA 67,65
00D62:  DATA 0D,0A
00D64:  DATA 00,00
00D66:  DATA 0D,0A
00D68:  DATA 5F,5F
00D6A:  DATA 5F,45
00D6C:  DATA 6E,64
00D6E:  DATA 20,73
00D70:  DATA 6D,66
00D72:  DATA 5F,65
00D74:  DATA 72,61
00D76:  DATA 73,65
00D78:  DATA 5F,5F
00D7A:  DATA 5F,5F
00D7C:  DATA 0D,0A
00D7E:  DATA 00,00
00D80:  DATA 5F,5F
00D82:  DATA 5F,5F
00D84:  DATA 5F,5F
00D86:  DATA 5F,5F
00D88:  DATA 5F,5F
00D8A:  DATA 5F,5F
00D8C:  DATA 5F,5F
00D8E:  DATA 5F,5F
00D90:  DATA 5F,5F
00D92:  DATA 5F,5F
00D94:  DATA 0D,0A
00D96:  DATA 0D,0A
00D98:  DATA 00,00
00D9A:  DATA 45,72
00D9C:  DATA 72,6F
00D9E:  DATA 72,3A
00DA0:  DATA 20,55
00DA2:  DATA 6E,6B
00DA4:  DATA 6E,6F
00DA6:  DATA 77,6E
00DA8:  DATA 20,6D
00DAA:  DATA 69,73
00DAC:  DATA 73,69
00DAE:  DATA 6F,6E
00DB0:  DATA 5F,69
00DB2:  DATA 64,3A
00DB4:  DATA 20,25
00DB6:  DATA 30,32
00DB8:  DATA 58,0D
00DBA:  DATA 0A,00
00DBC:  DATA 55,70
00DBE:  DATA 64,61
00DC0:  DATA 74,65
00DC2:  DATA 64,20
00DC4:  DATA 70,61
00DC6:  DATA 72,74
00DC8:  DATA 69,74
00DCA:  DATA 69,6F
00DCC:  DATA 6E,20
00DCE:  DATA 66,6F
00DD0:  DATA 72,20
00DD2:  DATA 6D,69
00DD4:  DATA 73,73
00DD6:  DATA 69,6F
00DD8:  DATA 6E,5F
00DDA:  DATA 69,64
00DDC:  DATA 20,25
00DDE:  DATA 30,32
00DE0:  DATA 58,3A
00DE2:  DATA 20,75
00DE4:  DATA 73,65
00DE6:  DATA 64,5F
00DE8:  DATA 73,69
00DEA:  DATA 7A,65
00DEC:  DATA 3D,25
00DEE:  DATA 6C,64
00DF0:  DATA 2C,20
00DF2:  DATA 6C,6F
00DF4:  DATA 6F,70
00DF6:  DATA 5F,63
00DF8:  DATA 6F,75
00DFA:  DATA 6E,74
00DFC:  DATA 65,72
00DFE:  DATA 3D,25
00E00:  DATA 6C,64
00E02:  DATA 0D,0A
00E04:  DATA 00,00
00E06:  DATA 4D,49
00E08:  DATA 53,53
00E0A:  DATA 49,4F
00E0C:  DATA 4E,20
00E0E:  DATA 46,4C
00E10:  DATA 41,53
00E12:  DATA 48,20
00E14:  DATA 49,6E
00E16:  DATA 69,74
00E18:  DATA 69,61
00E1A:  DATA 6C,69
00E1C:  DATA 7A,65
00E1E:  DATA 0D,0A
00E20:  DATA 00,00
00E22:  DATA 09,5B
00E24:  DATA 4D,49
00E26:  DATA 53,20
00E28:  DATA 46,4D
00E2A:  DATA 5D,20
00E2C:  DATA 52,45
00E2E:  DATA 41,44
00E30:  DATA 20,49
00E32:  DATA 44,3A
00E34:  DATA 20,00
00E36:  DATA 09,5B
00E38:  DATA 53,4D
00E3A:  DATA 46,20
00E3C:  DATA 20,20
00E3E:  DATA 5D,20
00E40:  DATA 52,45
00E42:  DATA 41,44
00E44:  DATA 20,49
00E46:  DATA 44,3A
00E48:  DATA 20,00
00E4A:  DATA 09,5B
00E4C:  DATA 53,4D
00E4E:  DATA 46,20
00E50:  DATA 20,20
00E52:  DATA 5D,20
00E54:  DATA 63,6F
00E56:  DATA 6E,6E
00E58:  DATA 65,63
00E5A:  DATA 74,20
00E5C:  DATA 65,72
00E5E:  DATA 72,6F
00E60:  DATA 72,21
00E62:  DATA 0D,0A
00E64:  DATA 00,00
00E66:  DATA 09,5B
00E68:  DATA 53,4D
00E6A:  DATA 46,20
00E6C:  DATA 20,20
00E6E:  DATA 5D,20
00E70:  DATA 69,73
00E72:  DATA 20,63
00E74:  DATA 6F,6E
00E76:  DATA 6E,65
00E78:  DATA 63,74
00E7A:  DATA 65,64
00E7C:  DATA 0D,0A
00E7E:  DATA 00,00
00E80:  DATA 09,5B
00E82:  DATA 4D,49
00E84:  DATA 53,20
00E86:  DATA 46,4D
00E88:  DATA 5D,20
00E8A:  DATA 63,6F
00E8C:  DATA 6E,6E
00E8E:  DATA 65,63
00E90:  DATA 74,20
00E92:  DATA 65,72
00E94:  DATA 72,6F
00E96:  DATA 72,21
00E98:  DATA 0D,0A
00E9A:  DATA 00,00
00E9C:  DATA 09,5B
00E9E:  DATA 4D,49
00EA0:  DATA 53,20
00EA2:  DATA 46,4D
00EA4:  DATA 5D,20
00EA6:  DATA 69,73
00EA8:  DATA 20,63
00EAA:  DATA 6F,6E
00EAC:  DATA 6E,65
00EAE:  DATA 63,74
00EB0:  DATA 65,64
00EB2:  DATA 0D,0A
00EB4:  DATA 00,00
00EB6:  DATA 09,5B
00EB8:  DATA 4D,49
00EBA:  DATA 53,20
00EBC:  DATA 46,4D
00EBE:  DATA 5D,20
00EC0:  DATA 43,52
00EC2:  DATA 43,20
00EC4:  DATA 65,72
00EC6:  DATA 72,6F
00EC8:  DATA 72,21
00ECA:  DATA 0D,0A
00ECC:  DATA 00,00
00ECE:  DATA 09,7C
00ED0:  DATA 20,4D
00ED2:  DATA 49,53
00ED4:  DATA 46,20
00ED6:  DATA 7C,20
00ED8:  DATA 50,49
00EDA:  DATA 43,4C
00EDC:  DATA 4F,47
00EDE:  DATA 20,20
00EE0:  DATA 20,20
00EE2:  DATA 7C,20
00EE4:  DATA 55,73
00EE6:  DATA 65,20
00EE8:  DATA 43,6F
00EEA:  DATA 75,6E
00EEC:  DATA 74,65
00EEE:  DATA 72,20
00EF0:  DATA 20,20
00EF2:  DATA 20,20
00EF4:  DATA 20,3A
00EF6:  DATA 20,30
00EF8:  DATA 78,25
00EFA:  DATA 30,38
00EFC:  DATA 4C,58
00EFE:  DATA 0D,0A
00F00:  DATA 00,00
00F02:  DATA 09,7C
00F04:  DATA 20,4D
00F06:  DATA 49,53
00F08:  DATA 46,20
00F0A:  DATA 7C,20
00F0C:  DATA 50,49
00F0E:  DATA 43,4C
00F10:  DATA 4F,47
00F12:  DATA 20,20
00F14:  DATA 20,20
00F16:  DATA 7C,20
00F18:  DATA 55,6E
00F1A:  DATA 63,6F
00F1C:  DATA 70,79
00F1E:  DATA 65,64
00F20:  DATA 20,43
00F22:  DATA 6F,75
00F24:  DATA 6E,74
00F26:  DATA 65,72
00F28:  DATA 20,3A
00F2A:  DATA 20,30
00F2C:  DATA 78,25
00F2E:  DATA 30,38
00F30:  DATA 4C,58
00F32:  DATA 0D,0A
00F34:  DATA 00,00
00F36:  DATA 09,7C
00F38:  DATA 20,4D
00F3A:  DATA 49,53
00F3C:  DATA 46,20
00F3E:  DATA 7C,20
00F40:  DATA 50,49
00F42:  DATA 43,4C
00F44:  DATA 4F,47
00F46:  DATA 20,20
00F48:  DATA 20,20
00F4A:  DATA 7C,20
00F4C:  DATA 52,65
00F4E:  DATA 73,65
00F50:  DATA 72,76
00F52:  DATA 65,20
00F54:  DATA 43,6F
00F56:  DATA 75,6E
00F58:  DATA 74,65
00F5A:  DATA 72,31
00F5C:  DATA 20,3A
00F5E:  DATA 20,30
00F60:  DATA 78,25
00F62:  DATA 30,32
00F64:  DATA 58,0D
00F66:  DATA 0A,00
00F68:  DATA 09,7C
00F6A:  DATA 20,4D
00F6C:  DATA 49,53
00F6E:  DATA 46,20
00F70:  DATA 7C,20
00F72:  DATA 50,49
00F74:  DATA 43,4C
00F76:  DATA 4F,47
00F78:  DATA 20,20
00F7A:  DATA 20,20
00F7C:  DATA 7C,20
00F7E:  DATA 52,65
00F80:  DATA 73,65
00F82:  DATA 72,76
00F84:  DATA 65,20
00F86:  DATA 43,6F
00F88:  DATA 75,6E
00F8A:  DATA 74,65
00F8C:  DATA 72,32
00F8E:  DATA 20,3A
00F90:  DATA 20,30
00F92:  DATA 78,25
00F94:  DATA 30,32
00F96:  DATA 58,0D
00F98:  DATA 0A,00
00F9A:  DATA 09,7C
00F9C:  DATA 20,4D
00F9E:  DATA 49,53
00FA0:  DATA 46,20
00FA2:  DATA 7C,20
00FA4:  DATA 45,4E
00FA6:  DATA 56,49
00FA8:  DATA 52,4F
00FAA:  DATA 20,20
00FAC:  DATA 20,20
00FAE:  DATA 7C,20
00FB0:  DATA 55,73
00FB2:  DATA 65,20
00FB4:  DATA 43,6F
00FB6:  DATA 75,6E
00FB8:  DATA 74,65
00FBA:  DATA 72,20
00FBC:  DATA 20,20
00FBE:  DATA 20,20
00FC0:  DATA 20,3A
00FC2:  DATA 20,30
00FC4:  DATA 78,25
00FC6:  DATA 30,38
00FC8:  DATA 4C,58
00FCA:  DATA 0D,0A
00FCC:  DATA 00,00
00FCE:  DATA 09,7C
00FD0:  DATA 20,4D
00FD2:  DATA 49,53
00FD4:  DATA 46,20
00FD6:  DATA 7C,20
00FD8:  DATA 45,4E
00FDA:  DATA 56,49
00FDC:  DATA 52,4F
00FDE:  DATA 20,20
00FE0:  DATA 20,20
00FE2:  DATA 7C,20
00FE4:  DATA 55,6E
00FE6:  DATA 63,6F
00FE8:  DATA 70,79
00FEA:  DATA 65,64
00FEC:  DATA 20,43
00FEE:  DATA 6F,75
00FF0:  DATA 6E,74
00FF2:  DATA 65,72
00FF4:  DATA 20,3A
00FF6:  DATA 20,30
00FF8:  DATA 78,25
00FFA:  DATA 30,38
00FFC:  DATA 4C,58
00FFE:  DATA 0D,0A
01000:  DATA 00,00
01002:  DATA 09,7C
01004:  DATA 20,4D
01006:  DATA 49,53
01008:  DATA 46,20
0100A:  DATA 7C,20
0100C:  DATA 45,4E
0100E:  DATA 56,49
01010:  DATA 52,4F
01012:  DATA 20,20
01014:  DATA 20,20
01016:  DATA 7C,20
01018:  DATA 52,65
0101A:  DATA 73,65
0101C:  DATA 72,76
0101E:  DATA 65,20
01020:  DATA 43,6F
01022:  DATA 75,6E
01024:  DATA 74,65
01026:  DATA 72,31
01028:  DATA 20,3A
0102A:  DATA 20,30
0102C:  DATA 78,25
0102E:  DATA 30,32
01030:  DATA 58,0D
01032:  DATA 0A,00
01034:  DATA 09,7C
01036:  DATA 20,4D
01038:  DATA 49,53
0103A:  DATA 46,20
0103C:  DATA 7C,20
0103E:  DATA 45,4E
01040:  DATA 56,49
01042:  DATA 52,4F
01044:  DATA 20,20
01046:  DATA 20,20
01048:  DATA 7C,20
0104A:  DATA 52,65
0104C:  DATA 73,65
0104E:  DATA 72,76
01050:  DATA 65,20
01052:  DATA 43,6F
01054:  DATA 75,6E
01056:  DATA 74,65
01058:  DATA 72,32
0105A:  DATA 20,3A
0105C:  DATA 20,30
0105E:  DATA 78,25
01060:  DATA 30,32
01062:  DATA 58,0D
01064:  DATA 0A,00
01066:  DATA 09,7C
01068:  DATA 20,4D
0106A:  DATA 49,53
0106C:  DATA 46,20
0106E:  DATA 7C,20
01070:  DATA 49,56
01072:  DATA 20,48
01074:  DATA 45,41
01076:  DATA 44,45
01078:  DATA 52,20
0107A:  DATA 7C,20
0107C:  DATA 55,73
0107E:  DATA 65,20
01080:  DATA 43,6F
01082:  DATA 75,6E
01084:  DATA 74,65
01086:  DATA 72,20
01088:  DATA 20,20
0108A:  DATA 20,20
0108C:  DATA 20,3A
0108E:  DATA 20,30
01090:  DATA 78,25
01092:  DATA 30,38
01094:  DATA 4C,58
01096:  DATA 0D,0A
01098:  DATA 00,00
0109A:  DATA 09,7C
0109C:  DATA 20,4D
0109E:  DATA 49,53
010A0:  DATA 46,20
010A2:  DATA 7C,20
010A4:  DATA 49,56
010A6:  DATA 20,48
010A8:  DATA 45,41
010AA:  DATA 44,45
010AC:  DATA 52,20
010AE:  DATA 7C,20
010B0:  DATA 55,6E
010B2:  DATA 63,6F
010B4:  DATA 70,79
010B6:  DATA 65,64
010B8:  DATA 20,43
010BA:  DATA 6F,75
010BC:  DATA 6E,74
010BE:  DATA 65,72
010C0:  DATA 20,3A
010C2:  DATA 20,30
010C4:  DATA 78,25
010C6:  DATA 30,38
010C8:  DATA 4C,58
010CA:  DATA 0D,0A
010CC:  DATA 00,00
010CE:  DATA 09,7C
010D0:  DATA 20,4D
010D2:  DATA 49,53
010D4:  DATA 46,20
010D6:  DATA 7C,20
010D8:  DATA 49,56
010DA:  DATA 20,48
010DC:  DATA 45,41
010DE:  DATA 44,45
010E0:  DATA 52,20
010E2:  DATA 7C,20
010E4:  DATA 52,65
010E6:  DATA 73,65
010E8:  DATA 72,76
010EA:  DATA 65,20
010EC:  DATA 43,6F
010EE:  DATA 75,6E
010F0:  DATA 74,65
010F2:  DATA 72,31
010F4:  DATA 20,3A
010F6:  DATA 20,30
010F8:  DATA 78,25
010FA:  DATA 30,32
010FC:  DATA 58,0D
010FE:  DATA 0A,00
01100:  DATA 09,7C
01102:  DATA 20,4D
01104:  DATA 49,53
01106:  DATA 46,20
01108:  DATA 7C,20
0110A:  DATA 49,56
0110C:  DATA 20,48
0110E:  DATA 45,41
01110:  DATA 44,45
01112:  DATA 52,20
01114:  DATA 7C,20
01116:  DATA 52,65
01118:  DATA 73,65
0111A:  DATA 72,76
0111C:  DATA 65,20
0111E:  DATA 43,6F
01120:  DATA 75,6E
01122:  DATA 74,65
01124:  DATA 72,32
01126:  DATA 20,3A
01128:  DATA 20,30
0112A:  DATA 78,25
0112C:  DATA 30,32
0112E:  DATA 58,0D
01130:  DATA 0A,00
01132:  DATA 09,7C
01134:  DATA 20,4D
01136:  DATA 49,53
01138:  DATA 46,20
0113A:  DATA 7C,20
0113C:  DATA 49,56
0113E:  DATA 20,44
01140:  DATA 41,54
01142:  DATA 41,20
01144:  DATA 20,20
01146:  DATA 7C,20
01148:  DATA 55,73
0114A:  DATA 65,20
0114C:  DATA 43,6F
0114E:  DATA 75,6E
01150:  DATA 74,65
01152:  DATA 72,20
01154:  DATA 20,20
01156:  DATA 20,20
01158:  DATA 20,3A
0115A:  DATA 20,30
0115C:  DATA 78,25
0115E:  DATA 30,38
01160:  DATA 4C,58
01162:  DATA 0D,0A
01164:  DATA 00,00
01166:  DATA 09,7C
01168:  DATA 20,4D
0116A:  DATA 49,53
0116C:  DATA 46,20
0116E:  DATA 7C,20
01170:  DATA 49,56
01172:  DATA 20,44
01174:  DATA 41,54
01176:  DATA 41,20
01178:  DATA 20,20
0117A:  DATA 7C,20
0117C:  DATA 55,6E
0117E:  DATA 63,6F
01180:  DATA 70,79
01182:  DATA 65,64
01184:  DATA 20,43
01186:  DATA 6F,75
01188:  DATA 6E,74
0118A:  DATA 65,72
0118C:  DATA 20,3A
0118E:  DATA 20,30
01190:  DATA 78,25
01192:  DATA 30,38
01194:  DATA 4C,58
01196:  DATA 0D,0A
01198:  DATA 00,00
0119A:  DATA 09,7C
0119C:  DATA 20,4D
0119E:  DATA 49,53
011A0:  DATA 46,20
011A2:  DATA 7C,20
011A4:  DATA 49,56
011A6:  DATA 20,44
011A8:  DATA 41,54
011AA:  DATA 41,20
011AC:  DATA 20,20
011AE:  DATA 7C,20
011B0:  DATA 52,65
011B2:  DATA 73,65
011B4:  DATA 72,76
011B6:  DATA 65,20
011B8:  DATA 43,6F
011BA:  DATA 75,6E
011BC:  DATA 74,65
011BE:  DATA 72,31
011C0:  DATA 20,3A
011C2:  DATA 20,30
011C4:  DATA 78,25
011C6:  DATA 30,32
011C8:  DATA 58,0D
011CA:  DATA 0A,00
011CC:  DATA 09,7C
011CE:  DATA 20,4D
011D0:  DATA 49,53
011D2:  DATA 46,20
011D4:  DATA 7C,20
011D6:  DATA 49,56
011D8:  DATA 20,44
011DA:  DATA 41,54
011DC:  DATA 41,20
011DE:  DATA 20,20
011E0:  DATA 7C,20
011E2:  DATA 52,65
011E4:  DATA 73,65
011E6:  DATA 72,76
011E8:  DATA 65,20
011EA:  DATA 43,6F
011EC:  DATA 75,6E
011EE:  DATA 74,65
011F0:  DATA 72,32
011F2:  DATA 20,3A
011F4:  DATA 20,30
011F6:  DATA 78,25
011F8:  DATA 30,32
011FA:  DATA 58,0D
011FC:  DATA 0A,00
011FE:  DATA 09,43
01200:  DATA 6F,6D
01202:  DATA 70,6C
01204:  DATA 65,74
01206:  DATA 65,0D
01208:  DATA 0A,00
0120A:  DATA 0D,0A
0120C:  DATA 5F,5F
0120E:  DATA 5F,5F
01210:  DATA 5F,5F
01212:  DATA 5F,5F
01214:  DATA 5F,5F
01216:  DATA 5F,5F
01218:  DATA 5F,5F
0121A:  DATA 5F,5F
0121C:  DATA 5F,5F
0121E:  DATA 5F,5F
01220:  DATA 5F,5F
01222:  DATA 5F,5F
01224:  DATA 5F,5F
01226:  DATA 5F,5F
01228:  DATA 5F,5F
0122A:  DATA 0D,0A
0122C:  DATA 5F,5F
0122E:  DATA 5F,5F
01230:  DATA 5F,53
01232:  DATA 74,61
01234:  DATA 72,74
01236:  DATA 20,65
01238:  DATA 78,65
0123A:  DATA 63,75
0123C:  DATA 74,65
0123E:  DATA 5F,6D
01240:  DATA 69,73
01242:  DATA 73,69
01244:  DATA 6F,6E
01246:  DATA 5F,5F
01248:  DATA 5F,5F
0124A:  DATA 5F,0D
0124C:  DATA 0A,0D
0124E:  DATA 0A,00
01250:  DATA 43,6F
01252:  DATA 6D,6D
01254:  DATA 61,6E
01256:  DATA 64,20
01258:  DATA 49,44
0125A:  DATA 3A,20
0125C:  DATA 25,58
0125E:  DATA 0D,0A
01260:  DATA 0D,0A
01262:  DATA 00,00
01264:  DATA 09,09
01266:  DATA 2D,3E
01268:  DATA 20,49
0126A:  DATA 6E,76
0126C:  DATA 61,6C
0126E:  DATA 69,64
01270:  DATA 20,43
01272:  DATA 4D,44
01274:  DATA 20,49
01276:  DATA 44,21
01278:  DATA 0D,0A
0127A:  DATA 00,00
0127C:  DATA 0D,0A
0127E:  DATA 5F,5F
01280:  DATA 5F,5F
01282:  DATA 5F,5F
01284:  DATA 45,6E
01286:  DATA 64,20
01288:  DATA 65,78
0128A:  DATA 65,63
0128C:  DATA 75,74
0128E:  DATA 65,5F
01290:  DATA 6D,69
01292:  DATA 73,73
01294:  DATA 69,6F
01296:  DATA 6E,5F
01298:  DATA 5F,5F
0129A:  DATA 5F,5F
0129C:  DATA 5F,0D
0129E:  DATA 0A,5F
012A0:  DATA 5F,5F
012A2:  DATA 5F,5F
012A4:  DATA 5F,5F
012A6:  DATA 5F,5F
012A8:  DATA 5F,5F
012AA:  DATA 5F,5F
012AC:  DATA 5F,5F
012AE:  DATA 5F,5F
012B0:  DATA 5F,5F
012B2:  DATA 5F,5F
012B4:  DATA 5F,5F
012B6:  DATA 5F,5F
012B8:  DATA 5F,5F
012BA:  DATA 5F,5F
012BC:  DATA 5F,5F
012BE:  DATA 0D,0A
012C0:  DATA 00,00
012C2:  DATA 53,74
012C4:  DATA 61,72
012C6:  DATA 74,20
012C8:  DATA 65,78
012CA:  DATA 65,63
012CC:  DATA 75,74
012CE:  DATA 65,5F
012D0:  DATA 63,6F
012D2:  DATA 6D,6D
012D4:  DATA 61,6E
012D6:  DATA 64,0D
012D8:  DATA 0A,00
012DA:  DATA 09,2D
012DC:  DATA 3E,20
012DE:  DATA 55,70
012E0:  DATA 6C,69
012E2:  DATA 6E,6B
012E4:  DATA 20,63
012E6:  DATA 6F,6D
012E8:  DATA 6D,61
012EA:  DATA 6E,64
012EC:  DATA 0D,0A
012EE:  DATA 00,00
012F0:  DATA 09,20
012F2:  DATA 20,20
012F4:  DATA 54,72
012F6:  DATA 61,6E
012F8:  DATA 73,6D
012FA:  DATA 69,74
012FC:  DATA 20,41
012FE:  DATA 63,6B
01300:  DATA 6E,6F
01302:  DATA 6C,65
01304:  DATA 67,64
01306:  DATA 65,0D
01308:  DATA 0A,00
0130A:  DATA 09,2D
0130C:  DATA 3E,20
0130E:  DATA 53,74
01310:  DATA 61,74
01312:  DATA 75,73
01314:  DATA 20,63
01316:  DATA 68,65
01318:  DATA 63,6B
0131A:  DATA 0D,0A
0131C:  DATA 00,00
0131E:  DATA 09,20
01320:  DATA 20,20
01322:  DATA 54,72
01324:  DATA 61,6E
01326:  DATA 73,6D
01328:  DATA 69,74
0132A:  DATA 20,4D
0132C:  DATA 49,53
0132E:  DATA 20,4D
01330:  DATA 43,55
01332:  DATA 20,53
01334:  DATA 74,61
01336:  DATA 74,75
01338:  DATA 73,0D
0133A:  DATA 0A,00
0133C:  DATA 66,69
0133E:  DATA 6E,69
01340:  DATA 73,68
01342:  DATA 65,64
01344:  DATA 20,69
01346:  DATA 6E,20
01348:  DATA 73,74
0134A:  DATA 61,74
0134C:  DATA 75,73
0134E:  DATA 5F,63
01350:  DATA 68,65
01352:  DATA 63,6B
01354:  DATA 0D,0A
01356:  DATA 00,00
01358:  DATA 09,2D
0135A:  DATA 3E,20
0135C:  DATA 53,4D
0135E:  DATA 46,20
01360:  DATA 61,76
01362:  DATA 61,69
01364:  DATA 6C,61
01366:  DATA 62,6C
01368:  DATA 65,20
0136A:  DATA 63,68
0136C:  DATA 65,63
0136E:  DATA 6B,0D
01370:  DATA 0A,00
01372:  DATA 09,20
01374:  DATA 20,20
01376:  DATA 54,72
01378:  DATA 61,6E
0137A:  DATA 73,6D
0137C:  DATA 69,74
0137E:  DATA 20,41
01380:  DATA 63,6B
01382:  DATA 6E,6F
01384:  DATA 77,6C
01386:  DATA 65,64
01388:  DATA 67,65
0138A:  DATA 6D,65
0138C:  DATA 6E,74
0138E:  DATA 0D,0A
01390:  DATA 00,00
01392:  DATA 09,09
01394:  DATA 2D,3E
01396:  DATA 20,61
01398:  DATA 6C,6C
0139A:  DATA 6F,77
0139C:  DATA 65,64
0139E:  DATA 0D,0A
013A0:  DATA 00,00
013A2:  DATA 09,09
013A4:  DATA 2D,3E
013A6:  DATA 20,64
013A8:  DATA 65,6E
013AA:  DATA 69,65
013AC:  DATA 64,0D
013AE:  DATA 0A,00
013B0:  DATA 53,74
013B2:  DATA 61,72
013B4:  DATA 74,20
013B6:  DATA 4D,4F
013B8:  DATA 44,45
013BA:  DATA 20,44
013BC:  DATA 55,4D
013BE:  DATA 4D,59
013C0:  DATA 0D,0A
013C2:  DATA 00,00
013C4:  DATA 09,4D
013C6:  DATA 4F,44
013C8:  DATA 45,20
013CA:  DATA 20,20
013CC:  DATA 20,20
013CE:  DATA 3A,20
013D0:  DATA 25,30
013D2:  DATA 32,58
013D4:  DATA 0D,0A
013D6:  DATA 00,00
013D8:  DATA 09,50
013DA:  DATA 61,72
013DC:  DATA 61,6D
013DE:  DATA 31,20
013E0:  DATA 20,20
013E2:  DATA 3A,20
013E4:  DATA 30,78
013E6:  DATA 25,30
013E8:  DATA 38,4C
013EA:  DATA 58,0D
013EC:  DATA 0A,00
013EE:  DATA 09,50
013F0:  DATA 61,72
013F2:  DATA 61,6D
013F4:  DATA 32,20
013F6:  DATA 20,20
013F8:  DATA 3A,20
013FA:  DATA 30,78
013FC:  DATA 25,30
013FE:  DATA 34,4C
01400:  DATA 58,0D
01402:  DATA 0A,00
01404:  DATA 45,6E
01406:  DATA 64,20
01408:  DATA 4D,4F
0140A:  DATA 44,45
0140C:  DATA 20,44
0140E:  DATA 55,4D
01410:  DATA 4D,59
01412:  DATA 0D,0A
01414:  DATA 00,00
01416:  DATA 53,74
01418:  DATA 61,72
0141A:  DATA 74,20
0141C:  DATA 4D,4F
0141E:  DATA 44,45
01420:  DATA 20,54
01422:  DATA 45,53
01424:  DATA 54,20
01426:  DATA 49,56
01428:  DATA 0D,0A
0142A:  DATA 00,00
0142C:  DATA 09,53
0142E:  DATA 77,65
01430:  DATA 65,70
01432:  DATA 20,73
01434:  DATA 74,65
01436:  DATA 70,20
01438:  DATA 3A,20
0143A:  DATA 25,75
0143C:  DATA 0D,0A
0143E:  DATA 00,00
01440:  DATA 45,6E
01442:  DATA 64,20
01444:  DATA 4D,4F
01446:  DATA 44,45
01448:  DATA 20,54
0144A:  DATA 45,53
0144C:  DATA 54,20
0144E:  DATA 49,56
01450:  DATA 0D,0A
01452:  DATA 00,00
01454:  DATA 53,74
01456:  DATA 61,72
01458:  DATA 74,20
0145A:  DATA 4D,4F
0145C:  DATA 44,45
0145E:  DATA 20,4D
01460:  DATA 45,41
01462:  DATA 53,20
01464:  DATA 49,56
01466:  DATA 0D,0A
01468:  DATA 00,00
0146A:  DATA 09,49
0146C:  DATA 44,3A
0146E:  DATA 20,25
01470:  DATA 30,32
01472:  DATA 58,0D
01474:  DATA 0A,00
01476:  DATA 09,53
01478:  DATA 6C,65
0147A:  DATA 65,70
0147C:  DATA 20,54
0147E:  DATA 69,6D
01480:  DATA 65,3A
01482:  DATA 20,25
01484:  DATA 30,34
01486:  DATA 4C,58
01488:  DATA 20,6D
0148A:  DATA 73,0D
0148C:  DATA 0A,00
0148E:  DATA 09,43
01490:  DATA 75,72
01492:  DATA 72,65
01494:  DATA 6E,74
01496:  DATA 20,54
01498:  DATA 68,72
0149A:  DATA 65,73
0149C:  DATA 68,6F
0149E:  DATA 6C,64
014A0:  DATA 3A,20
014A2:  DATA 25,30
014A4:  DATA 34,4C
014A6:  DATA 58,20
014A8:  DATA 6D,41
014AA:  DATA 0D,0A
014AC:  DATA 00,00
014AE:  DATA 09,50
014B0:  DATA 44,20
014B2:  DATA 54,68
014B4:  DATA 72,65
014B6:  DATA 73,68
014B8:  DATA 6F,6C
014BA:  DATA 64,3A
014BC:  DATA 20,25
014BE:  DATA 30,34
014C0:  DATA 4C,58
014C2:  DATA 20,6D
014C4:  DATA 41,0D
014C6:  DATA 0A,00
014C8:  DATA 09,43
014CA:  DATA 75,72
014CC:  DATA 72,65
014CE:  DATA 6E,74
014D0:  DATA 20,4C
014D2:  DATA 69,6D
014D4:  DATA 69,74
014D6:  DATA 3A,20
014D8:  DATA 25,30
014DA:  DATA 34,4C
014DC:  DATA 58,20
014DE:  DATA 6D,41
014E0:  DATA 0D,0A
014E2:  DATA 00,00
014E4:  DATA 09,4D
014E6:  DATA 65,61
014E8:  DATA 73,75
014EA:  DATA 72,65
014EC:  DATA 6D,65
014EE:  DATA 6E,74
014F0:  DATA 20,54
014F2:  DATA 69,6D
014F4:  DATA 65,3A
014F6:  DATA 20,25
014F8:  DATA 30,34
014FA:  DATA 4C,58
014FC:  DATA 20,73
014FE:  DATA 0D,0A
01500:  DATA 00,00
01502:  DATA 09,49
01504:  DATA 73,20
01506:  DATA 46,69
01508:  DATA 6E,69
0150A:  DATA 73,68
0150C:  DATA 65,64
0150E:  DATA 3A,20
01510:  DATA 25,75
01512:  DATA 0D,0A
01514:  DATA 00,00
01516:  DATA 45,6E
01518:  DATA 64,20
0151A:  DATA 4D,4F
0151C:  DATA 44,45
0151E:  DATA 20,4D
01520:  DATA 45,41
01522:  DATA 53,20
01524:  DATA 49,56
01526:  DATA 0D,0A
01528:  DATA 00,00
0152A:  DATA 53,74
0152C:  DATA 61,72
0152E:  DATA 74,20
01530:  DATA 46,6C
01532:  DATA 61,73
01534:  DATA 68,20
01536:  DATA 45,72
01538:  DATA 61,73
0153A:  DATA 65,20
0153C:  DATA 41,6C
0153E:  DATA 6C,0D
01540:  DATA 0A,00
01542:  DATA 45,6E
01544:  DATA 64,20
01546:  DATA 46,6C
01548:  DATA 61,73
0154A:  DATA 68,20
0154C:  DATA 45,72
0154E:  DATA 61,73
01550:  DATA 65,20
01552:  DATA 41,6C
01554:  DATA 6C,0D
01556:  DATA 0A,00
01558:  DATA 53,74
0155A:  DATA 61,72
0155C:  DATA 74,20
0155E:  DATA 46,6C
01560:  DATA 61,73
01562:  DATA 68,20
01564:  DATA 45,72
01566:  DATA 61,73
01568:  DATA 65,20
0156A:  DATA 31,20
0156C:  DATA 53,65
0156E:  DATA 63,74
01570:  DATA 6F,72
01572:  DATA 0D,0A
01574:  DATA 00,00
01576:  DATA 09,53
01578:  DATA 65,63
0157A:  DATA 74,6F
0157C:  DATA 72,20
0157E:  DATA 41,64
01580:  DATA 64,72
01582:  DATA 65,73
01584:  DATA 73,3A
01586:  DATA 20,30
01588:  DATA 78,25
0158A:  DATA 30,38
0158C:  DATA 4C,58
0158E:  DATA 0D,0A
01590:  DATA 00,00
01592:  DATA 45,6E
01594:  DATA 64,20
01596:  DATA 46,6C
01598:  DATA 61,73
0159A:  DATA 68,20
0159C:  DATA 45,72
0159E:  DATA 61,73
015A0:  DATA 65,20
015A2:  DATA 31,20
015A4:  DATA 53,65
015A6:  DATA 63,74
015A8:  DATA 6F,72
015AA:  DATA 0D,0A
015AC:  DATA 00,00
015AE:  DATA 53,74
015B0:  DATA 61,72
015B2:  DATA 74,20
015B4:  DATA 46,6C
015B6:  DATA 61,73
015B8:  DATA 68,20
015BA:  DATA 43,6F
015BC:  DATA 70,79
015BE:  DATA 20,31
015C0:  DATA 20,53
015C2:  DATA 65,63
015C4:  DATA 74,6F
015C6:  DATA 72,0D
015C8:  DATA 0A,00
015CA:  DATA 09,53
015CC:  DATA 75,62
015CE:  DATA 73,65
015D0:  DATA 63,74
015D2:  DATA 6F,72
015D4:  DATA 20,41
015D6:  DATA 64,64
015D8:  DATA 72,65
015DA:  DATA 73,73
015DC:  DATA 3A,20
015DE:  DATA 30,78
015E0:  DATA 25,30
015E2:  DATA 38,4C
015E4:  DATA 58,0D
015E6:  DATA 0A,00
015E8:  DATA 45,6E
015EA:  DATA 64,20
015EC:  DATA 46,6C
015EE:  DATA 61,73
015F0:  DATA 68,20
015F2:  DATA 43,6F
015F4:  DATA 70,79
015F6:  DATA 20,31
015F8:  DATA 20,53
015FA:  DATA 65,63
015FC:  DATA 74,6F
015FE:  DATA 72,0D
01600:  DATA 0A,00
01602:  DATA 53,74
01604:  DATA 61,72
01606:  DATA 74,20
01608:  DATA 46,6C
0160A:  DATA 61,73
0160C:  DATA 68,20
0160E:  DATA 45,72
01610:  DATA 61,73
01612:  DATA 65,20
01614:  DATA 36,34
01616:  DATA 6B,42
01618:  DATA 79,74
0161A:  DATA 65,20
0161C:  DATA 53,75
0161E:  DATA 62,73
01620:  DATA 65,63
01622:  DATA 74,6F
01624:  DATA 72,0D
01626:  DATA 0A,00
01628:  DATA 09,53
0162A:  DATA 75,62
0162C:  DATA 73,65
0162E:  DATA 63,74
01630:  DATA 6F,72
01632:  DATA 20,41
01634:  DATA 64,64
01636:  DATA 72,65
01638:  DATA 73,73
0163A:  DATA 3A,20
0163C:  DATA 30,78
0163E:  DATA 25,30
01640:  DATA 38,4C
01642:  DATA 58,0D
01644:  DATA 0A,00
01646:  DATA 45,6E
01648:  DATA 64,20
0164A:  DATA 46,6C
0164C:  DATA 61,73
0164E:  DATA 68,20
01650:  DATA 45,72
01652:  DATA 61,73
01654:  DATA 65,20
01656:  DATA 36,34
01658:  DATA 6B,42
0165A:  DATA 79,74
0165C:  DATA 65,20
0165E:  DATA 53,75
01660:  DATA 62,73
01662:  DATA 65,63
01664:  DATA 74,6F
01666:  DATA 72,0D
01668:  DATA 0A,00
0166A:  DATA 53,74
0166C:  DATA 61,72
0166E:  DATA 74,20
01670:  DATA 46,6C
01672:  DATA 61,73
01674:  DATA 68,20
01676:  DATA 57,72
01678:  DATA 69,74
0167A:  DATA 65,20
0167C:  DATA 44,65
0167E:  DATA 6D,6F
01680:  DATA 0D,0A
01682:  DATA 00,00
01684:  DATA 09,4D
01686:  DATA 4F,44
01688:  DATA 45,20
0168A:  DATA 20,20
0168C:  DATA 20,20
0168E:  DATA 3A,20
01690:  DATA 25,30
01692:  DATA 32,58
01694:  DATA 0D,0A
01696:  DATA 00,00
01698:  DATA 09,41
0169A:  DATA 64,64
0169C:  DATA 72,65
0169E:  DATA 73,73
016A0:  DATA 20,20
016A2:  DATA 3A,20
016A4:  DATA 30,78
016A6:  DATA 25,30
016A8:  DATA 38,4C
016AA:  DATA 58,0D
016AC:  DATA 0A,00
016AE:  DATA 09,50
016B0:  DATA 61,63
016B2:  DATA 6B,65
016B4:  DATA 74,4E
016B6:  DATA 75,6D
016B8:  DATA 3A,20
016BA:  DATA 30,78
016BC:  DATA 25,30
016BE:  DATA 34,4C
016C0:  DATA 58,0D
016C2:  DATA 0A,00
016C4:  DATA 57,72
016C6:  DATA 69,74
016C8:  DATA 65,20
016CA:  DATA 44,61
016CC:  DATA 74,61
016CE:  DATA 0D,0A
016D0:  DATA 00,00
016D2:  DATA 45,6E
016D4:  DATA 64,20
016D6:  DATA 46,6C
016D8:  DATA 61,73
016DA:  DATA 68,20
016DC:  DATA 57,72
016DE:  DATA 69,74
016E0:  DATA 65,20
016E2:  DATA 44,65
016E4:  DATA 6D,6F
016E6:  DATA 0D,0A
016E8:  DATA 00,00
016EA:  DATA 53,74
016EC:  DATA 61,72
016EE:  DATA 74,20
016F0:  DATA 46,6C
016F2:  DATA 61,73
016F4:  DATA 68,20
016F6:  DATA 57,72
016F8:  DATA 69,74
016FA:  DATA 65,20
016FC:  DATA 34,6B
016FE:  DATA 42,79
01700:  DATA 74,65
01702:  DATA 20,53
01704:  DATA 75,62
01706:  DATA 73,65
01708:  DATA 63,74
0170A:  DATA 6F,72
0170C:  DATA 0D,0A
0170E:  DATA 00,00
01710:  DATA 45,6E
01712:  DATA 64,20
01714:  DATA 46,6C
01716:  DATA 61,73
01718:  DATA 68,20
0171A:  DATA 57,72
0171C:  DATA 69,74
0171E:  DATA 65,20
01720:  DATA 34,6B
01722:  DATA 42,79
01724:  DATA 74,65
01726:  DATA 20,53
01728:  DATA 75,62
0172A:  DATA 73,65
0172C:  DATA 63,74
0172E:  DATA 6F,72
01730:  DATA 0D,0A
01732:  DATA 00,00
01734:  DATA 53,74
01736:  DATA 61,72
01738:  DATA 74,20
0173A:  DATA 46,6C
0173C:  DATA 61,73
0173E:  DATA 68,20
01740:  DATA 52,65
01742:  DATA 61,64
01744:  DATA 0D,0A
01746:  DATA 00,00
01748:  DATA 09,4D
0174A:  DATA 4F,44
0174C:  DATA 45,20
0174E:  DATA 20,20
01750:  DATA 20,20
01752:  DATA 3A,20
01754:  DATA 25,30
01756:  DATA 32,58
01758:  DATA 0D,0A
0175A:  DATA 00,00
0175C:  DATA 09,41
0175E:  DATA 64,64
01760:  DATA 72,65
01762:  DATA 73,73
01764:  DATA 20,20
01766:  DATA 3A,20
01768:  DATA 30,78
0176A:  DATA 25,30
0176C:  DATA 38,4C
0176E:  DATA 58,0D
01770:  DATA 0A,00
01772:  DATA 09,50
01774:  DATA 61,63
01776:  DATA 6B,65
01778:  DATA 74,4E
0177A:  DATA 75,6D
0177C:  DATA 3A,20
0177E:  DATA 30,78
01780:  DATA 25,30
01782:  DATA 34,4C
01784:  DATA 58,0D
01786:  DATA 0A,00
01788:  DATA 52,45
0178A:  DATA 41,44
0178C:  DATA 20,44
0178E:  DATA 41,54
01790:  DATA 41,0D
01792:  DATA 0A,00
01794:  DATA 4D,69
01796:  DATA 73,73
01798:  DATA 69,6F
0179A:  DATA 6E,20
0179C:  DATA 46,6C
0179E:  DATA 61,73
017A0:  DATA 68,20
017A2:  DATA 69,73
017A4:  DATA 20,6E
017A6:  DATA 6F,74
017A8:  DATA 20,63
017AA:  DATA 6F,6E
017AC:  DATA 6E,65
017AE:  DATA 63,74
017B0:  DATA 65,64
017B2:  DATA 0D,0A
017B4:  DATA 00,00
017B6:  DATA 45,6E
017B8:  DATA 64,20
017BA:  DATA 46,6C
017BC:  DATA 61,73
017BE:  DATA 68,20
017C0:  DATA 52,65
017C2:  DATA 61,64
017C4:  DATA 0D,0A
017C6:  DATA 00,00
017C8:  DATA 53,74
017CA:  DATA 61,72
017CC:  DATA 74,20
017CE:  DATA 46,6C
017D0:  DATA 61,73
017D2:  DATA 68,20
017D4:  DATA 52,65
017D6:  DATA 61,64
017D8:  DATA 20,41
017DA:  DATA 64,64
017DC:  DATA 72,65
017DE:  DATA 73,73
017E0:  DATA 0D,0A
017E2:  DATA 00,00
017E4:  DATA 52,65
017E6:  DATA 61,64
017E8:  DATA 20,44
017EA:  DATA 61,74
017EC:  DATA 61,3A
017EE:  DATA 20,25
017F0:  DATA 30,32
017F2:  DATA 58,20
017F4:  DATA 25,30
017F6:  DATA 32,58
017F8:  DATA 20,25
017FA:  DATA 30,32
017FC:  DATA 58,20
017FE:  DATA 25,30
01800:  DATA 32,58
01802:  DATA 0D,0A
01804:  DATA 00,00
01806:  DATA 45,6E
01808:  DATA 64,20
0180A:  DATA 46,6C
0180C:  DATA 61,73
0180E:  DATA 68,20
01810:  DATA 52,65
01812:  DATA 61,64
01814:  DATA 20,41
01816:  DATA 64,64
01818:  DATA 72,65
0181A:  DATA 73,73
0181C:  DATA 0D,0A
0181E:  DATA 00,00
01820:  DATA 53,74
01822:  DATA 61,72
01824:  DATA 74,20
01826:  DATA 46,6C
01828:  DATA 61,73
0182A:  DATA 68,20
0182C:  DATA 45,72
0182E:  DATA 61,73
01830:  DATA 65,20
01832:  DATA 61,6E
01834:  DATA 64,20
01836:  DATA 52,65
01838:  DATA 73,65
0183A:  DATA 74,0D
0183C:  DATA 0A,00
0183E:  DATA 45,6E
01840:  DATA 64,20
01842:  DATA 46,6C
01844:  DATA 61,73
01846:  DATA 68,20
01848:  DATA 45,72
0184A:  DATA 61,73
0184C:  DATA 65,20
0184E:  DATA 61,6E
01850:  DATA 64,20
01852:  DATA 52,65
01854:  DATA 73,65
01856:  DATA 74,0D
01858:  DATA 0A,00
0185A:  DATA 53,74
0185C:  DATA 61,72
0185E:  DATA 74,20
01860:  DATA 46,6C
01862:  DATA 61,73
01864:  DATA 68,20
01866:  DATA 41,64
01868:  DATA 64,72
0186A:  DATA 65,73
0186C:  DATA 73,20
0186E:  DATA 52,65
01870:  DATA 73,65
01872:  DATA 74,0D
01874:  DATA 0A,00
01876:  DATA 45,6E
01878:  DATA 64,20
0187A:  DATA 46,6C
0187C:  DATA 61,73
0187E:  DATA 68,20
01880:  DATA 41,64
01882:  DATA 64,72
01884:  DATA 65,73
01886:  DATA 73,20
01888:  DATA 52,65
0188A:  DATA 73,65
0188C:  DATA 74,0D
0188E:  DATA 0A,00
01890:  DATA 53,74
01892:  DATA 61,72
01894:  DATA 74,20
01896:  DATA 46,6C
01898:  DATA 61,73
0189A:  DATA 68,20
0189C:  DATA 53,4D
0189E:  DATA 46,20
018A0:  DATA 43,6F
018A2:  DATA 70,79
018A4:  DATA 0D,0A
018A6:  DATA 00,00
018A8:  DATA 45,6E
018AA:  DATA 64,20
018AC:  DATA 46,6C
018AE:  DATA 61,73
018B0:  DATA 68,20
018B2:  DATA 53,4D
018B4:  DATA 46,20
018B6:  DATA 43,6F
018B8:  DATA 70,79
018BA:  DATA 0D,0A
018BC:  DATA 00,00
018BE:  DATA 53,74
018C0:  DATA 61,72
018C2:  DATA 74,20
018C4:  DATA 46,6C
018C6:  DATA 61,73
018C8:  DATA 68,20
018CA:  DATA 53,4D
018CC:  DATA 46,20
018CE:  DATA 52,65
018D0:  DATA 61,64
018D2:  DATA 0D,0A
018D4:  DATA 00,00
018D6:  DATA 52,65
018D8:  DATA 61,64
018DA:  DATA 20,44
018DC:  DATA 61,74
018DE:  DATA 61,3A
018E0:  DATA 20,00
018E2:  DATA 0D,0A
018E4:  DATA 45,6E
018E6:  DATA 64,20
018E8:  DATA 46,6C
018EA:  DATA 61,73
018EC:  DATA 68,20
018EE:  DATA 53,4D
018F0:  DATA 46,20
018F2:  DATA 52,65
018F4:  DATA 61,64
018F6:  DATA 0D,0A
018F8:  DATA 00,00
018FA:  DATA 53,74
018FC:  DATA 61,72
018FE:  DATA 74,20
01900:  DATA 46,6C
01902:  DATA 61,73
01904:  DATA 68,20
01906:  DATA 53,4D
01908:  DATA 46,20
0190A:  DATA 45,72
0190C:  DATA 61,73
0190E:  DATA 65,0D
01910:  DATA 0A,00
01912:  DATA 45,6E
01914:  DATA 64,20
01916:  DATA 46,6C
01918:  DATA 61,73
0191A:  DATA 68,20
0191C:  DATA 53,4D
0191E:  DATA 46,20
01920:  DATA 45,72
01922:  DATA 61,73
01924:  DATA 65,0D
01926:  DATA 0A,00
01928:  DATA 53,74
0192A:  DATA 61,72
0192C:  DATA 74,20
0192E:  DATA 46,6C
01930:  DATA 61,73
01932:  DATA 68,20
01934:  DATA 41,64
01936:  DATA 64,72
01938:  DATA 65,73
0193A:  DATA 73,20
0193C:  DATA 52,65
0193E:  DATA 73,65
01940:  DATA 74,0D
01942:  DATA 0A,00
01944:  DATA 45,6E
01946:  DATA 64,20
01948:  DATA 46,6C
0194A:  DATA 61,73
0194C:  DATA 68,20
0194E:  DATA 41,64
01950:  DATA 64,72
01952:  DATA 65,73
01954:  DATA 73,20
01956:  DATA 52,65
01958:  DATA 73,65
0195A:  DATA 74,0D
0195C:  DATA 0A,00
0195E:  DATA 53,4D
01960:  DATA 46,20
01962:  DATA 69,73
01964:  DATA 20,6E
01966:  DATA 6F,74
01968:  DATA 20,63
0196A:  DATA 6F,6E
0196C:  DATA 6E,65
0196E:  DATA 63,74
01970:  DATA 65,64
01972:  DATA 0D,0A
01974:  DATA 00,00
01976:  DATA 53,74
01978:  DATA 61,72
0197A:  DATA 74,20
0197C:  DATA 46,6C
0197E:  DATA 61,73
01980:  DATA 68,20
01982:  DATA 53,4D
01984:  DATA 46,20
01986:  DATA 52,65
01988:  DATA 61,64
0198A:  DATA 20,46
0198C:  DATA 6F,72
0198E:  DATA 63,65
01990:  DATA 0D,0A
01992:  DATA 00,00
01994:  DATA 09,41
01996:  DATA 64,64
01998:  DATA 72,65
0199A:  DATA 73,73
0199C:  DATA 20,20
0199E:  DATA 3A,20
019A0:  DATA 30,78
019A2:  DATA 25,30
019A4:  DATA 38,4C
019A6:  DATA 58,0D
019A8:  DATA 0A,00
019AA:  DATA 09,50
019AC:  DATA 61,63
019AE:  DATA 6B,65
019B0:  DATA 74,4E
019B2:  DATA 75,6D
019B4:  DATA 3A,20
019B6:  DATA 30,78
019B8:  DATA 25,30
019BA:  DATA 34,4C
019BC:  DATA 58,0D
019BE:  DATA 0A,00
019C0:  DATA 72,65
019C2:  DATA 61,64
019C4:  DATA 20,64
019C6:  DATA 61,74
019C8:  DATA 61,0D
019CA:  DATA 0A,00
019CC:  DATA 0D,0A
019CE:  DATA 45,6E
019D0:  DATA 64,20
019D2:  DATA 46,6C
019D4:  DATA 61,73
019D6:  DATA 68,20
019D8:  DATA 53,4D
019DA:  DATA 46,20
019DC:  DATA 52,65
019DE:  DATA 61,64
019E0:  DATA 20,46
019E2:  DATA 6F,72
019E4:  DATA 63,65
019E6:  DATA 0D,0A
019E8:  DATA 00,00
019EA:  DATA 53,74
019EC:  DATA 61,72
019EE:  DATA 74,20
019F0:  DATA 53,4D
019F2:  DATA 46,20
019F4:  DATA 45,72
019F6:  DATA 61,73
019F8:  DATA 65,20
019FA:  DATA 41,6C
019FC:  DATA 6C,0D
019FE:  DATA 0A,00
01A00:  DATA 45,6E
01A02:  DATA 64,20
01A04:  DATA 53,4D
01A06:  DATA 46,20
01A08:  DATA 45,72
01A0A:  DATA 61,73
01A0C:  DATA 65,20
01A0E:  DATA 41,6C
01A10:  DATA 6C,0D
01A12:  DATA 0A,00
01A14:  DATA 53,74
01A16:  DATA 61,72
01A18:  DATA 74,20
01A1A:  DATA 53,4D
01A1C:  DATA 46,20
01A1E:  DATA 52,65
01A20:  DATA 73,65
01A22:  DATA 74,0D
01A24:  DATA 0A,00
01A26:  DATA 45,6E
01A28:  DATA 64,20
01A2A:  DATA 53,4D
01A2C:  DATA 46,20
01A2E:  DATA 52,65
01A30:  DATA 73,65
01A32:  DATA 74,0D
01A34:  DATA 0A,00
01A36:  DATA 0D,0A
01A38:  DATA 0D,0A
01A3A:  DATA 0D,0A
01A3C:  DATA 3D,3D
01A3E:  DATA 3D,3D
01A40:  DATA 3D,3D
01A42:  DATA 3D,3D
01A44:  DATA 3D,3D
01A46:  DATA 3D,3D
01A48:  DATA 3D,3D
01A4A:  DATA 3D,3D
01A4C:  DATA 3D,3D
01A4E:  DATA 3D,3D
01A50:  DATA 3D,3D
01A52:  DATA 3D,3D
01A54:  DATA 3D,3D
01A56:  DATA 3D,3D
01A58:  DATA 3D,3D
01A5A:  DATA 3D,3D
01A5C:  DATA 3D,3D
01A5E:  DATA 3D,3D
01A60:  DATA 3D,3D
01A62:  DATA 3D,3D
01A64:  DATA 3D,3D
01A66:  DATA 3D,3D
01A68:  DATA 3D,3D
01A6A:  DATA 3D,3D
01A6C:  DATA 3D,3D
01A6E:  DATA 3D,3D
01A70:  DATA 3D,3D
01A72:  DATA 3D,3D
01A74:  DATA 3D,3D
01A76:  DATA 3D,3D
01A78:  DATA 0D,0A
01A7A:  DATA 00,00
01A7C:  DATA 54,68
01A7E:  DATA 69,73
01A80:  DATA 20,69
01A82:  DATA 73,20
01A84:  DATA 4D,4F
01A86:  DATA 4D,49
01A88:  DATA 4A,49
01A8A:  DATA 20,43
01A8C:  DATA 49,47
01A8E:  DATA 53,20
01A90:  DATA 50,49
01A92:  DATA 43,20
01A94:  DATA 42,42
01A96:  DATA 4D,20
01A98:  DATA 66,6F
01A9A:  DATA 72,20
01A9C:  DATA 4D,49
01A9E:  DATA 53,37
01AA0:  DATA 5F,42
01AA2:  DATA 42,4D
01AA4:  DATA 34,2E
01AA6:  DATA 0D,0A
01AA8:  DATA 00,00
01AAA:  DATA 4C,61
01AAC:  DATA 73,74
01AAE:  DATA 20,75
01AB0:  DATA 70,64
01AB2:  DATA 61,74
01AB4:  DATA 65,64
01AB6:  DATA 20,6F
01AB8:  DATA 6E,20
01ABA:  DATA 25,73
01ABC:  DATA 20,25
01ABE:  DATA 73,2C
01AC0:  DATA 20,62
01AC2:  DATA 79,20
01AC4:  DATA 49,6E
01AC6:  DATA 6F,75
01AC8:  DATA 65,2E
01ACA:  DATA 0D,0A
01ACC:  DATA 0D,0A
01ACE:  DATA 00,00
01AD0:  DATA 38,2D
01AD2:  DATA 41,75
01AD4:  DATA 67,2D
01AD6:  DATA 32,35
01AD8:  DATA 00,00
01ADA:  DATA 32,30
01ADC:  DATA 3A,30
01ADE:  DATA 32,3A
01AE0:  DATA 31,32
01AE2:  DATA 00,00
01AE4:  DATA 5F,5F
01AE6:  DATA 5F,5F
01AE8:  DATA 43,49
01AEA:  DATA 47,53
01AEC:  DATA 20,50
01AEE:  DATA 49,43
01AF0:  DATA 20,53
01AF2:  DATA 74,61
01AF4:  DATA 72,74
01AF6:  DATA 20,4F
01AF8:  DATA 70,65
01AFA:  DATA 72,61
01AFC:  DATA 74,69
01AFE:  DATA 6F,6E
01B00:  DATA 5F,5F
01B02:  DATA 5F,5F
01B04:  DATA 5F,0D
01B06:  DATA 0A,0D
01B08:  DATA 0A,00
01B0A:  DATA 77,61
01B0C:  DATA 69,74
01B0E:  DATA 69,6E
01B10:  DATA 67,20
01B12:  DATA 66,6F
01B14:  DATA 72,20
01B16:  DATA 42,4F
01B18:  DATA 53,53
01B1A:  DATA 20,50
01B1C:  DATA 49,43
01B1E:  DATA 20,63
01B20:  DATA 6F,6D
01B22:  DATA 6D,61
01B24:  DATA 6E,64
01B26:  DATA 00,00
01B28:  DATA 0D,0A
01B2A:  DATA 77,61
01B2C:  DATA 69,74
01B2E:  DATA 69,6E
01B30:  DATA 67,20
01B32:  DATA 66,6F
01B34:  DATA 72,20
01B36:  DATA 42,4F
01B38:  DATA 53,53
01B3A:  DATA 20,50
01B3C:  DATA 49,43
01B3E:  DATA 20,63
01B40:  DATA 6F,6D
01B42:  DATA 6D,61
01B44:  DATA 6E,64
01B46:  DATA 00,00
01B48:  DATA 0D,0A
01B4A:  DATA 0D,0A
01B4C:  DATA 3D,3D
01B4E:  DATA 3D,3D
01B50:  DATA 3D,3D
01B52:  DATA 0D,0A
01B54:  DATA 0D,0A
01B56:  DATA 46,69
01B58:  DATA 6E,69
01B5A:  DATA 73,68
01B5C:  DATA 65,64
01B5E:  DATA 20,70
01B60:  DATA 72,6F
01B62:  DATA 63,65
01B64:  DATA 73,73
01B66:  DATA 2E,0D
01B68:  DATA 0A,57
01B6A:  DATA 61,69
01B6C:  DATA 74,20
01B6E:  DATA 66,6F
01B70:  DATA 72,20
01B72:  DATA 42,4F
01B74:  DATA 53,53
01B76:  DATA 20,50
01B78:  DATA 49,43
01B7A:  DATA 20,74
01B7C:  DATA 75,72
01B7E:  DATA 6E,20
01B80:  DATA 6F,66
01B82:  DATA 66,20
01B84:  DATA 6D,65
01B86:  DATA 00,00
01B88:  DATA 45,6E
01B8A:  DATA 64,20
01B8C:  DATA 6D,61
01B8E:  DATA 69,6E
01B90:  DATA 0D,0A
01B92:  DATA 00,00
*
01C14:  TBLRD*+
01C16:  MOVF   FF5,F
01C18:  BTFSC  FD8.2
01C1A:  GOTO   1C42
01C1E:  MOVFF  FF6,C11
01C22:  MOVFF  FF7,C12
01C26:  MOVFF  FF8,C13
01C2A:  MOVFF  FF5,C14
01C2E:  CALL   1BC2
01C32:  MOVFF  C11,FF6
01C36:  MOVFF  C12,FF7
01C3A:  MOVFF  C13,FF8
01C3E:  GOTO   1C14
01C42:  RETURN 0
01C44:  TBLRD*+
01C46:  MOVFF  FF6,BC2
01C4A:  MOVFF  FF7,BC3
01C4E:  MOVFF  FF8,BC4
01C52:  MOVFF  FF5,C14
01C56:  CALL   1BC2
01C5A:  MOVFF  BC2,FF6
01C5E:  MOVFF  BC3,FF7
01C62:  MOVFF  BC4,FF8
01C66:  MOVLB  B
01C68:  DECFSZ xC1,F
01C6A:  BRA    1C70
01C6C:  BRA    1C76
01C6E:  MOVLB  0
01C70:  MOVLB  0
01C72:  GOTO   1C44
01C76:  MOVLB  0
01C78:  RETURN 0
*
01E98:  MOVLB  B
01E9A:  BTFSS  xC2.7
01E9C:  BRA    1EA4
01E9E:  MOVLB  0
01EA0:  GOTO   1ED4
01EA4:  MOVLW  0F
01EA6:  MOVWF  00
01EA8:  SWAPF  xC1,W
01EAA:  ANDWF  00,F
01EAC:  MOVLW  0A
01EAE:  SUBWF  00,W
01EB0:  BTFSS  FD8.0
01EB2:  BRA    1EBA
01EB4:  MOVLB  0
01EB6:  GOTO   1EC4
01EBA:  MOVLW  30
01EBC:  ADDWF  00,F
01EBE:  MOVLB  0
01EC0:  GOTO   1ECC
01EC4:  MOVLB  B
01EC6:  MOVF   xC2,W
01EC8:  ADDWF  00,F
01ECA:  MOVLB  0
01ECC:  MOVFF  00,C14
01ED0:  CALL   1BC2
01ED4:  MOVLW  0F
01ED6:  MOVLB  B
01ED8:  ANDWF  xC1,F
01EDA:  MOVLW  0A
01EDC:  SUBWF  xC1,W
01EDE:  BTFSS  FD8.0
01EE0:  BRA    1EE8
01EE2:  MOVLB  0
01EE4:  GOTO   1EF0
01EE8:  MOVLW  30
01EEA:  MOVLB  0
01EEC:  GOTO   1EF8
01EF0:  MOVLB  B
01EF2:  BCF    xC2.7
01EF4:  MOVF   xC2,W
01EF6:  MOVLB  0
01EF8:  MOVLB  B
01EFA:  ADDWF  xC1,F
01EFC:  MOVFF  BC1,C14
01F00:  MOVLB  0
01F02:  CALL   1BC2
01F06:  RETURN 0
*
023AA:  MOVLB  C
023AC:  MOVF   x71,W
023AE:  ANDLW  07
023B0:  MOVWF  00
023B2:  RRCF   x71,W
023B4:  MOVWF  01
023B6:  RRCF   01,F
023B8:  RRCF   01,F
023BA:  MOVLW  1F
023BC:  ANDWF  01,F
023BE:  MOVF   01,W
023C0:  ADDWF  x73,W
023C2:  MOVWF  FE9
023C4:  MOVLW  00
023C6:  ADDWFC x74,W
023C8:  MOVWF  FEA
023CA:  CLRF   01
023CC:  INCF   01,F
023CE:  INCF   00,F
023D0:  MOVLB  0
023D2:  GOTO   23D8
023D6:  RLCF   01,F
023D8:  DECFSZ 00,F
023DA:  GOTO   23D6
023DE:  MOVLB  C
023E0:  MOVF   x72,F
023E2:  BTFSS  FD8.2
023E4:  BRA    23EC
023E6:  MOVLB  0
023E8:  GOTO   23F6
023EC:  MOVF   01,W
023EE:  IORWF  FEF,F
023F0:  MOVLB  0
023F2:  GOTO   23FC
023F6:  COMF   01,F
023F8:  MOVF   01,W
023FA:  ANDWF  FEF,F
023FC:  RETURN 0
*
03C00:  TSTFSZ 01
03C02:  GOTO   3C10
03C06:  TSTFSZ 02
03C08:  GOTO   3C12
03C0C:  GOTO   3C22
03C10:  INCF   02,F
03C12:  MOVFF  00,FEE
03C16:  DECFSZ 01,F
03C18:  GOTO   3C12
03C1C:  DECFSZ 02,F
03C1E:  GOTO   3C12
03C22:  RETURN 0
*
05EDC:  MOVLB  3
05EDE:  MOVF   xA9,W
05EE0:  CLRF   01
05EE2:  SUBWF  xA8,W
05EE4:  BTFSS  FD8.0
05EE6:  BRA    5EEE
05EE8:  MOVLB  0
05EEA:  GOTO   5EF8
05EEE:  MOVF   xA8,W
05EF0:  MOVWF  00
05EF2:  MOVLB  0
05EF4:  GOTO   5F22
05EF8:  CLRF   00
05EFA:  MOVLW  08
05EFC:  MOVLB  3
05EFE:  MOVWF  xAA
05F00:  MOVLB  0
05F02:  MOVLB  3
05F04:  RLCF   xA8,F
05F06:  RLCF   00,F
05F08:  MOVF   xA9,W
05F0A:  SUBWF  00,W
05F0C:  BTFSC  FD8.0
05F0E:  MOVWF  00
05F10:  RLCF   01,F
05F12:  DECFSZ xAA,F
05F14:  BRA    5F1A
05F16:  BRA    5F20
05F18:  MOVLB  0
05F1A:  MOVLB  0
05F1C:  GOTO   5F02
05F20:  MOVLB  0
05F22:  RETURN 0
05F24:  MOVF   01,W
05F26:  MOVFF  3A6,3A8
05F2A:  MOVLW  64
05F2C:  MOVLB  3
05F2E:  MOVWF  xA9
05F30:  MOVLB  0
05F32:  CALL   5EDC
05F36:  MOVFF  00,3A6
05F3A:  MOVF   01,W
05F3C:  MOVLW  30
05F3E:  BTFSS  FD8.2
05F40:  GOTO   5F64
05F44:  MOVLB  3
05F46:  BTFSC  xA7.1
05F48:  BRA    5F50
05F4A:  MOVLB  0
05F4C:  GOTO   5F78
05F50:  BTFSS  xA7.3
05F52:  BRA    5F5A
05F54:  MOVLB  0
05F56:  GOTO   5F78
05F5A:  BTFSC  xA7.4
05F5C:  MOVLW  20
05F5E:  MOVLB  0
05F60:  GOTO   5F6E
05F64:  MOVLB  3
05F66:  BCF    xA7.3
05F68:  BCF    xA7.4
05F6A:  BSF    xA7.0
05F6C:  MOVLB  0
05F6E:  ADDWF  01,F
05F70:  MOVFF  01,C14
05F74:  CALL   1BC2
05F78:  MOVFF  3A6,3A8
05F7C:  MOVLW  0A
05F7E:  MOVLB  3
05F80:  MOVWF  xA9
05F82:  MOVLB  0
05F84:  CALL   5EDC
05F88:  MOVFF  00,3A6
05F8C:  MOVF   01,W
05F8E:  MOVLW  30
05F90:  BTFSS  FD8.2
05F92:  GOTO   5FB2
05F96:  MOVLB  3
05F98:  BTFSS  xA7.3
05F9A:  BRA    5FA2
05F9C:  MOVLB  0
05F9E:  GOTO   5FBC
05FA2:  BTFSC  xA7.0
05FA4:  BRA    5FAC
05FA6:  MOVLB  0
05FA8:  GOTO   5FBC
05FAC:  BTFSC  xA7.4
05FAE:  MOVLW  20
05FB0:  MOVLB  0
05FB2:  ADDWF  01,F
05FB4:  MOVFF  01,C14
05FB8:  CALL   1BC2
05FBC:  MOVLW  30
05FBE:  MOVLB  3
05FC0:  ADDWF  xA6,F
05FC2:  MOVFF  3A6,C14
05FC6:  MOVLB  0
05FC8:  CALL   1BC2
05FCC:  GOTO   855C (RETURN)
05FD0:  BTFSC  FD8.1
05FD2:  GOTO   5FDE
05FD6:  MOVLW  0B
05FD8:  MOVWF  FEA
05FDA:  MOVLW  DA
05FDC:  MOVWF  FE9
05FDE:  CLRF   00
05FE0:  CLRF   01
05FE2:  CLRF   02
05FE4:  CLRF   03
05FE6:  MOVLB  B
05FE8:  CLRF   xDA
05FEA:  CLRF   xDB
05FEC:  CLRF   xDC
05FEE:  CLRF   xDD
05FF0:  MOVF   xD9,W
05FF2:  IORWF  xD8,W
05FF4:  IORWF  xD7,W
05FF6:  IORWF  xD6,W
05FF8:  BTFSS  FD8.2
05FFA:  BRA    6002
05FFC:  MOVLB  0
05FFE:  GOTO   6092
06002:  MOVLB  0
06004:  MOVLW  20
06006:  MOVLB  B
06008:  MOVWF  xDE
0600A:  MOVLB  0
0600C:  BCF    FD8.0
0600E:  MOVLB  B
06010:  RLCF   xD2,F
06012:  RLCF   xD3,F
06014:  RLCF   xD4,F
06016:  RLCF   xD5,F
06018:  RLCF   xDA,F
0601A:  RLCF   xDB,F
0601C:  RLCF   xDC,F
0601E:  RLCF   xDD,F
06020:  MOVF   xD9,W
06022:  SUBWF  xDD,W
06024:  BTFSC  FD8.2
06026:  BRA    602E
06028:  MOVLB  0
0602A:  GOTO   6050
0602E:  MOVF   xD8,W
06030:  SUBWF  xDC,W
06032:  BTFSC  FD8.2
06034:  BRA    603C
06036:  MOVLB  0
06038:  GOTO   6050
0603C:  MOVF   xD7,W
0603E:  SUBWF  xDB,W
06040:  BTFSC  FD8.2
06042:  BRA    604A
06044:  MOVLB  0
06046:  GOTO   6050
0604A:  MOVF   xD6,W
0604C:  SUBWF  xDA,W
0604E:  MOVLB  0
06050:  BTFSS  FD8.0
06052:  GOTO   6078
06056:  MOVLB  B
06058:  MOVF   xD6,W
0605A:  SUBWF  xDA,F
0605C:  MOVF   xD7,W
0605E:  BTFSS  FD8.0
06060:  INCFSZ xD7,W
06062:  SUBWF  xDB,F
06064:  MOVF   xD8,W
06066:  BTFSS  FD8.0
06068:  INCFSZ xD8,W
0606A:  SUBWF  xDC,F
0606C:  MOVF   xD9,W
0606E:  BTFSS  FD8.0
06070:  INCFSZ xD9,W
06072:  SUBWF  xDD,F
06074:  BSF    FD8.0
06076:  MOVLB  0
06078:  RLCF   00,F
0607A:  RLCF   01,F
0607C:  RLCF   02,F
0607E:  RLCF   03,F
06080:  MOVLB  B
06082:  DECFSZ xDE,F
06084:  BRA    608A
06086:  BRA    6090
06088:  MOVLB  0
0608A:  MOVLB  0
0608C:  GOTO   600C
06090:  MOVLB  0
06092:  MOVFF  BDA,FEF
06096:  MOVFF  BDB,FEC
0609A:  MOVFF  BDC,FEC
0609E:  MOVFF  BDD,FEC
060A2:  MOVF   FED,F
060A4:  MOVF   FED,F
060A6:  MOVF   FED,F
060A8:  GOTO   60D0 (RETURN)
*
06166:  MOVFF  FEA,BC5
0616A:  MOVFF  FE9,BC4
0616E:  MOVLB  B
06170:  BTFSC  xBE.7
06172:  BRA    617A
06174:  MOVLB  0
06176:  GOTO   618C
0617A:  BSF    xC4.7
0617C:  BTFSS  xC4.4
0617E:  INCF   xC4,F
06180:  COMF   xBD,F
06182:  COMF   xBE,F
06184:  INCF   xBD,F
06186:  BTFSC  FD8.2
06188:  INCF   xBE,F
0618A:  MOVLB  0
0618C:  MOVLB  B
0618E:  SWAPF  xBE,W
06190:  IORLW  F0
06192:  MOVWF  xC0
06194:  ADDWF  xC0,F
06196:  ADDLW  E2
06198:  MOVWF  xC1
0619A:  ADDLW  32
0619C:  MOVWF  xC3
0619E:  MOVF   xBE,W
061A0:  ANDLW  0F
061A2:  ADDWF  xC1,F
061A4:  ADDWF  xC1,F
061A6:  ADDWF  xC3,F
061A8:  ADDLW  E9
061AA:  MOVWF  xC2
061AC:  ADDWF  xC2,F
061AE:  ADDWF  xC2,F
061B0:  SWAPF  xBD,W
061B2:  ANDLW  0F
061B4:  ADDWF  xC2,F
061B6:  ADDWF  xC3,F
061B8:  RLCF   xC2,F
061BA:  RLCF   xC3,F
061BC:  COMF   xC3,F
061BE:  RLCF   xC3,F
061C0:  MOVF   xBD,W
061C2:  ANDLW  0F
061C4:  ADDWF  xC3,F
061C6:  RLCF   xC0,F
061C8:  MOVLW  07
061CA:  MOVWF  xBF
061CC:  MOVLW  0A
061CE:  MOVLB  0
061D0:  MOVLB  B
061D2:  DECF   xC2,F
061D4:  ADDWF  xC3,F
061D6:  BTFSC  FD8.0
061D8:  BRA    61E0
061DA:  MOVLB  0
061DC:  GOTO   61D0
061E0:  MOVLB  0
061E2:  MOVLB  B
061E4:  DECF   xC1,F
061E6:  ADDWF  xC2,F
061E8:  BTFSC  FD8.0
061EA:  BRA    61F2
061EC:  MOVLB  0
061EE:  GOTO   61E2
061F2:  MOVLB  0
061F4:  MOVLB  B
061F6:  DECF   xC0,F
061F8:  ADDWF  xC1,F
061FA:  BTFSC  FD8.0
061FC:  BRA    6204
061FE:  MOVLB  0
06200:  GOTO   61F4
06204:  MOVLB  0
06206:  MOVLB  B
06208:  DECF   xBF,F
0620A:  ADDWF  xC0,F
0620C:  BTFSC  FD8.0
0620E:  BRA    6216
06210:  MOVLB  0
06212:  GOTO   6206
06216:  MOVLW  0B
06218:  MOVWF  FEA
0621A:  MOVLW  BF
0621C:  MOVWF  FE9
0621E:  MOVLW  07
06220:  ANDWF  xC4,W
06222:  BCF    xC4.6
06224:  MOVF   FED,F
06226:  ANDWF  xC4,W
06228:  BTFSC  FD8.2
0622A:  BRA    6232
0622C:  MOVLB  0
0622E:  GOTO   624A
06232:  BTFSC  xC4.4
06234:  MOVF   FEE,F
06236:  BTFSS  xC4.4
06238:  BRA    6240
0623A:  MOVLB  0
0623C:  GOTO   624A
06240:  MOVLW  20
06242:  MOVWF  00
06244:  MOVLB  0
06246:  GOTO   62C4
0624A:  ADDWF  FE9,F
0624C:  MOVLW  00
0624E:  ADDWFC FEA,F
06250:  MOVF   FE9,W
06252:  SUBLW  C3
06254:  BTFSS  FD8.2
06256:  GOTO   626A
0625A:  MOVF   FEA,W
0625C:  SUBLW  0B
0625E:  BTFSS  FD8.2
06260:  GOTO   626A
06264:  MOVLB  B
06266:  BSF    xC4.6
06268:  MOVLB  0
0626A:  MOVF   FEF,W
0626C:  MOVWF  00
0626E:  BTFSS  FD8.2
06270:  GOTO   629C
06274:  MOVLB  B
06276:  BTFSS  xC4.6
06278:  BRA    6280
0627A:  MOVLB  0
0627C:  GOTO   629C
06280:  BTFSS  xC4.4
06282:  BRA    628A
06284:  MOVLB  0
06286:  GOTO   62DC
0628A:  BTFSS  xC4.3
0628C:  BRA    6294
0628E:  MOVLB  0
06290:  GOTO   629C
06294:  MOVLW  20
06296:  MOVLB  0
06298:  GOTO   62C2
0629C:  MOVLB  B
0629E:  BTFSC  xC4.7
062A0:  BRA    62A8
062A2:  MOVLB  0
062A4:  GOTO   62B8
062A8:  MOVLW  2D
062AA:  MOVWF  00
062AC:  MOVF   FED,W
062AE:  BCF    xC4.6
062B0:  BCF    xC4.7
062B2:  MOVLB  0
062B4:  GOTO   62C4
062B8:  MOVLB  B
062BA:  BSF    xC4.3
062BC:  BCF    xC4.4
062BE:  MOVLW  30
062C0:  MOVLB  0
062C2:  ADDWF  00,F
062C4:  MOVFF  FEA,BBE
062C8:  MOVFF  FE9,BBD
062CC:  MOVFF  00,C14
062D0:  CALL   1BC2
062D4:  MOVFF  BBE,FEA
062D8:  MOVFF  BBD,FE9
062DC:  MOVF   FEE,W
062DE:  MOVLB  B
062E0:  BTFSC  xC4.6
062E2:  BRA    62EA
062E4:  MOVLB  0
062E6:  GOTO   6250
062EA:  MOVLB  0
062EC:  GOTO   7C5A (RETURN)
*
07EC6:  MOVLB  3
07EC8:  MOVF   xA9,W
07ECA:  MULWF  xAB
07ECC:  MOVFF  FF3,01
07ED0:  MOVFF  FF4,00
07ED4:  MULWF  xAC
07ED6:  MOVF   FF3,W
07ED8:  ADDWF  00,F
07EDA:  MOVF   xAA,W
07EDC:  MULWF  xAB
07EDE:  MOVF   FF3,W
07EE0:  ADDWFC 00,W
07EE2:  MOVWF  02
07EE4:  MOVLB  0
07EE6:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01B94:  MOVLW  0C
01B96:  MOVWF  FEA
01B98:  MOVLW  6B
01B9A:  MOVWF  FE9
01B9C:  MOVF   FEF,W
01B9E:  BTFSC  FD8.2
01BA0:  GOTO   1BC0
01BA4:  MOVLW  05
01BA6:  MOVWF  01
01BA8:  CLRF   00
01BAA:  DECFSZ 00,F
01BAC:  BRA    1BAA
01BAE:  DECFSZ 01,F
01BB0:  BRA    1BA8
01BB2:  MOVLW  2E
01BB4:  MOVWF  00
01BB6:  DECFSZ 00,F
01BB8:  BRA    1BB6
01BBA:  BRA    1BBC
01BBC:  DECFSZ FEF,F
01BBE:  BRA    1BA4
01BC0:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
03C62:  BTFSS  FA6.4
03C64:  GOTO   3C62
03C68:  MOVLB  F
03C6A:  MOVWF  x29
03C6C:  MOVLB  0
03C6E:  GOTO   3CA4 (RETURN)
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01BC2:  BCF    F93.6
01BC4:  BCF    F8A.6
01BC6:  MOVLW  08
01BC8:  MOVWF  01
01BCA:  BRA    1BCC
01BCC:  NOP   
01BCE:  BSF    01.7
01BD0:  GOTO   1BF8
01BD4:  BCF    01.7
01BD6:  MOVLB  C
01BD8:  RRCF   x14,F
01BDA:  MOVLB  0
01BDC:  BTFSC  FD8.0
01BDE:  BSF    F8A.6
01BE0:  BTFSS  FD8.0
01BE2:  BCF    F8A.6
01BE4:  BSF    01.6
01BE6:  GOTO   1BF8
01BEA:  BCF    01.6
01BEC:  DECFSZ 01,F
01BEE:  GOTO   1BD6
01BF2:  BRA    1BF4
01BF4:  NOP   
01BF6:  BSF    F8A.6
01BF8:  MOVLW  84
01BFA:  MOVWF  FE9
01BFC:  DECFSZ FE9,F
01BFE:  GOTO   1BFC
01C02:  BRA    1C04
01C04:  NOP   
01C06:  BTFSC  01.7
01C08:  GOTO   1BD4
01C0C:  BTFSC  01.6
01C0E:  GOTO   1BEA
01C12:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
0247A:  MOVLB  C
0247C:  MOVF   x8E,W
0247E:  SUBLW  08
02480:  BTFSS  FD8.2
02482:  BRA    248A
02484:  MOVLB  0
02486:  GOTO   24A2
0248A:  MOVWF  x90
0248C:  MOVLB  0
0248E:  MOVLB  C
02490:  RLCF   x8D,F
02492:  DECFSZ x90,F
02494:  BRA    249A
02496:  BRA    24A0
02498:  MOVLB  0
0249A:  MOVLB  0
0249C:  GOTO   248E
024A0:  MOVLB  0
024A2:  BSF    F92.1
024A4:  BCF    F92.0
024A6:  BCF    F92.3
024A8:  BCF    F89.3
024AA:  MOVFF  C8E,C90
024AE:  MOVLB  C
024B0:  BTFSS  x8D.7
024B2:  BCF    F89.0
024B4:  BTFSC  x8D.7
024B6:  BSF    F89.0
024B8:  RLCF   x8D,F
024BA:  BSF    F89.3
024BC:  MOVLW  02
024BE:  MOVWF  x91
024C0:  MOVLB  0
024C2:  MOVLB  C
024C4:  DECFSZ x91,F
024C6:  BRA    24CC
024C8:  BRA    24D2
024CA:  MOVLB  0
024CC:  MOVLB  0
024CE:  GOTO   24C2
024D2:  RLCF   01,F
024D4:  BTFSS  F80.1
024D6:  BCF    01.0
024D8:  BTFSC  F80.1
024DA:  BSF    01.0
024DC:  BCF    F89.3
024DE:  MOVLB  0
024E0:  BRA    24E2
024E2:  MOVLB  C
024E4:  DECFSZ x90,F
024E6:  BRA    24EC
024E8:  BRA    24F2
024EA:  MOVLB  0
024EC:  MOVLB  0
024EE:  GOTO   24AE
024F2:  MOVLB  0
024F4:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
023FE:  MOVLB  C
02400:  MOVF   x8E,W
02402:  SUBLW  08
02404:  BTFSS  FD8.2
02406:  BRA    240E
02408:  MOVLB  0
0240A:  GOTO   2426
0240E:  MOVWF  x90
02410:  MOVLB  0
02412:  MOVLB  C
02414:  RLCF   x8D,F
02416:  DECFSZ x90,F
02418:  BRA    241E
0241A:  BRA    2424
0241C:  MOVLB  0
0241E:  MOVLB  0
02420:  GOTO   2412
02424:  MOVLB  0
02426:  BSF    F96.0
02428:  BCF    F96.6
0242A:  BCF    F96.1
0242C:  BCF    F8D.1
0242E:  MOVFF  C8E,C90
02432:  MOVLB  C
02434:  BTFSS  x8D.7
02436:  BCF    F8D.6
02438:  BTFSC  x8D.7
0243A:  BSF    F8D.6
0243C:  RLCF   x8D,F
0243E:  BSF    F8D.1
02440:  MOVLW  02
02442:  MOVWF  x91
02444:  MOVLB  0
02446:  MOVLB  C
02448:  DECFSZ x91,F
0244A:  BRA    2450
0244C:  BRA    2456
0244E:  MOVLB  0
02450:  MOVLB  0
02452:  GOTO   2446
02456:  RLCF   01,F
02458:  BTFSS  F84.0
0245A:  BCF    01.0
0245C:  BTFSC  F84.0
0245E:  BSF    01.0
02460:  BCF    F8D.1
02462:  MOVLB  0
02464:  BRA    2466
02466:  MOVLB  C
02468:  DECFSZ x90,F
0246A:  BRA    2470
0246C:  BRA    2476
0246E:  MOVLB  0
02470:  MOVLB  0
02472:  GOTO   2432
02476:  MOVLB  0
02478:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=0, BITS=16, STREAM=ADCDAC_STREAM)
*
01D9E:  MOVLB  B
01DA0:  MOVF   xDB,W
01DA2:  SUBLW  10
01DA4:  BTFSS  FD8.2
01DA6:  BRA    1DAE
01DA8:  MOVLB  0
01DAA:  GOTO   1DC8
01DAE:  MOVWF  xDD
01DB0:  MOVLB  0
01DB2:  MOVLB  B
01DB4:  RLCF   xD9,F
01DB6:  RLCF   xDA,F
01DB8:  DECFSZ xDD,F
01DBA:  BRA    1DC0
01DBC:  BRA    1DC6
01DBE:  MOVLB  0
01DC0:  MOVLB  0
01DC2:  GOTO   1DB2
01DC6:  MOVLB  0
01DC8:  BSF    F93.4
01DCA:  BCF    F93.5
01DCC:  BCF    F93.2
01DCE:  BCF    F8A.2
01DD0:  MOVFF  BDB,BDD
01DD4:  MOVLB  B
01DD6:  BTFSS  xDA.7
01DD8:  BCF    F8A.5
01DDA:  BTFSC  xDA.7
01DDC:  BSF    F8A.5
01DDE:  RLCF   xD9,F
01DE0:  RLCF   xDA,F
01DE2:  BSF    F8A.2
01DE4:  RLCF   01,F
01DE6:  RLCF   02,F
01DE8:  BTFSS  F81.4
01DEA:  BCF    01.0
01DEC:  BTFSC  F81.4
01DEE:  BSF    01.0
01DF0:  BCF    F8A.2
01DF2:  DECFSZ xDD,F
01DF4:  BRA    1DFA
01DF6:  BRA    1E00
01DF8:  MOVLB  0
01DFA:  MOVLB  0
01DFC:  GOTO   1DD4
01E00:  MOVLB  0
01E02:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/mcu/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/devices/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... #include "../../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_MEASURE_DATA_START_ADDRESS 0x06AA1000
.................... #define CIGS_MEASURE_DATA_END_ADDRESS 0x07AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x07AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x07AA1FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "../core/measurement/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/storage/mmj_cigs_flash.h"
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... unsigned int8 PICLOG_STARTUP = 0x00;
.................... 
.................... // PICLOG Parameter
.................... #define PICLOG_PARAM_START 0x01
.................... #define PICLOG_PARAM_END 0x02
.................... 
.................... 
.................... // PICLOG
.................... typedef union {
....................     struct {
....................         unsigned int32  time;
....................         unsigned int8   function;
....................         unsigned int8   parameter;
....................     };
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];  
.................... } PICLOG;
.................... 
.................... // extern宣言を追加（実体は.cファイルで定義）
.................... #define PICLOG_BLANK_SIZE 4 // PICLOGの空データサイズ
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00, 0x00}; // PICLOGの空データ
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "../application/mission/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... #include "../hardware/mcu/src/timer.c"
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
*
000CA:  MOVLW  80
000CC:  MOVWF  FCF
000CE:  MOVLW  12
000D0:  MOVWF  FCE
000D2:  NOP   
....................    sec++;
000D4:  MOVLW  01
000D6:  ADDWF  20,F
000D8:  BTFSC  FD8.0
000DA:  INCF   21,F
000DC:  BTFSC  FD8.2
000DE:  INCF   22,F
000E0:  BTFSC  FD8.2
000E2:  INCF   23,F
....................    /*
....................    if (++subsec >= 100)
....................    {
....................       subsec = 0;
....................       sec++;
.................... 
....................       if (sec >= SEC_IN_A_DAY)
....................       {
....................          day++;
....................       }
....................    }*/
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01CF2:  MOVLW  EA
01CF4:  MOVWF  FF6
01CF6:  MOVLW  00
01CF8:  MOVWF  FF7
01CFA:  MOVLW  00
01CFC:  MOVWF  FF8
01CFE:  CALL   1C14
....................    clear_interrupt(INT_TIMER1);
01D02:  BCF    F9E.0
....................    //sec = 0;
....................    // 外部クロックをT1CKIピンから入力、プリスケーラなし
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01D04:  MOVLW  8F
01D06:  MOVWF  FCD
01D08:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01D0A:  MOVLW  80
01D0C:  MOVWF  FCF
01D0E:  MOVLW  12
01D10:  MOVWF  FCE
01D12:  NOP   
....................    //set_timer1(0);  // タイマーカウント初期値設定
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);   
01D14:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01D16:  MOVLW  C0
01D18:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01D1A:  MOVLW  FE
01D1C:  MOVWF  FF6
01D1E:  MOVLW  00
01D20:  MOVWF  FF7
01D22:  MOVLW  00
01D24:  MOVWF  FF8
01D26:  CALL   1C14
01D2A:  GOTO   92BE (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
02E52:  MOVFF  20,00
02E56:  MOVFF  21,01
02E5A:  MOVFF  22,02
02E5E:  MOVFF  23,03
02E62:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
*
060AC:  BCF    FD8.1
060AE:  MOVFF  1F,BD5
060B2:  MOVFF  1E,BD4
060B6:  MOVFF  1D,BD3
060BA:  MOVFF  1C,BD2
060BE:  MOVLB  B
060C0:  CLRF   xD9
060C2:  CLRF   xD8
060C4:  CLRF   xD7
060C6:  MOVLW  0A
060C8:  MOVWF  xD6
060CA:  MOVLB  0
060CC:  GOTO   5FD0
060D0:  MOVF   01,W
060D2:  MOVWF  02
060D4:  MOVF   00,W
060D6:  MOVWF  01
060D8:  GOTO   60F4 (RETURN)
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... 
.................... 
.................... 
.................... #include "../hardware/mcu/src/uart.c"
.................... #INT_RDA3
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  47.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   46,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   46,W
0014C:  INCF   46,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  26
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,C96
00160:  MOVFF  FE9,C95
00164:  GOTO   010A
00168:  MOVFF  C96,FEA
0016C:  MOVFF  C95,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
.................... 
....................    //fprintf(PC, "RDA Interrupt: %d bytes received\r\n", boss_receive_buffer_size);
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01CC8:  MOVLW  7A
01CCA:  MOVWF  FF6
01CCC:  MOVLW  01
01CCE:  MOVWF  FF7
01CD0:  MOVLW  00
01CD2:  MOVWF  FF8
01CD4:  CALL   1C14
....................    enable_interrupts(INT_RDA3);
01CD8:  BSF    F61.5
....................    enable_interrupts(global);
01CDA:  MOVLW  C0
01CDC:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CDE:  MOVLW  8C
01CE0:  MOVWF  FF6
01CE2:  MOVLW  01
01CE4:  MOVWF  FF7
01CE6:  MOVLW  00
01CE8:  MOVWF  FF8
01CEA:  CALL   1C14
01CEE:  GOTO   92BA (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
03C24:  MOVFF  378,03
03C28:  MOVLB  3
03C2A:  MOVF   x77,W
03C2C:  MOVWF  FE9
03C2E:  MOVFF  03,FEA
03C32:  MOVFF  FEF,379
03C36:  MOVFF  376,FEA
03C3A:  MOVFF  375,FE9
03C3E:  CLRF   00
03C40:  CLRF   02
03C42:  MOVFF  379,01
03C46:  MOVLB  0
03C48:  CALL   3C00
....................    *receive_signal_size = 0;
03C4C:  MOVFF  378,03
03C50:  MOVLB  3
03C52:  MOVF   x77,W
03C54:  MOVWF  FE9
03C56:  MOVFF  03,FEA
03C5A:  CLRF   FEF
03C5C:  MOVLB  0
03C5E:  GOTO   9362 (RETURN)
.................... }
.................... 
.................... 
.................... #include "../hardware/devices/src/ad7490_driver.c"
.................... #include "../ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=0, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01F08:  MOVLW  98
01F0A:  MOVWF  FF6
01F0C:  MOVLW  01
01F0E:  MOVWF  FF7
01F10:  MOVLW  00
01F12:  MOVWF  FF8
01F14:  CALL   1C14
....................     output_high(ADC_CS); // Set CS pin high to deselect the ADC
01F18:  MOVLW  F4
01F1A:  MOVWF  F93
01F1C:  BSF    F8A.1
....................     delay_ms(10); // Wait for the ADC to stabilize
01F1E:  MOVLW  0A
01F20:  MOVLB  C
01F22:  MOVWF  x6B
01F24:  MOVLB  0
01F26:  CALL   1B94
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR); // Read a dummy value to initialize the ADC
01F2A:  MOVLW  05
01F2C:  MOVLB  B
01F2E:  MOVWF  xD2
01F30:  MOVLB  0
01F32:  CALL   1E04
01F36:  MOVFF  02,376
01F3A:  MOVFF  01,375
....................     delay_ms(1); // Wait for the ADC to stabilize after reading
01F3E:  MOVLW  01
01F40:  MOVLB  C
01F42:  MOVWF  x6B
01F44:  MOVLB  0
01F46:  CALL   1B94
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01F4A:  MOVLW  09
01F4C:  MOVLB  C
01F4E:  MOVWF  x14
01F50:  MOVLB  0
01F52:  CALL   1BC2
01F56:  MOVFF  376,BC1
01F5A:  MOVLW  37
01F5C:  MOVLB  B
01F5E:  MOVWF  xC2
01F60:  MOVLB  0
01F62:  CALL   1E98
01F66:  MOVFF  375,BC1
01F6A:  MOVLW  37
01F6C:  MOVLB  B
01F6E:  MOVWF  xC2
01F70:  MOVLB  0
01F72:  CALL   1E98
01F76:  MOVLW  0D
01F78:  MOVLB  C
01F7A:  MOVWF  x14
01F7C:  MOVLB  0
01F7E:  CALL   1BC2
01F82:  MOVLW  0A
01F84:  MOVLB  C
01F86:  MOVWF  x14
01F88:  MOVLB  0
01F8A:  CALL   1BC2
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F8E:  MOVLB  3
01F90:  INCFSZ x75,W
01F92:  BRA    1F98
01F94:  BRA    1F9E
01F96:  MOVLB  0
01F98:  MOVLB  0
01F9A:  GOTO   1FB6
01F9E:  MOVLB  0
01FA0:  MOVLB  3
01FA2:  INCFSZ x76,W
01FA4:  BRA    1FAA
01FA6:  BRA    1FB0
01FA8:  MOVLB  0
01FAA:  MOVLB  0
01FAC:  GOTO   1FB6
01FB0:  MOVLB  0
01FB2:  GOTO   1FD6
01FB6:  MOVLB  3
01FB8:  MOVF   x75,F
01FBA:  BTFSC  FD8.2
01FBC:  BRA    1FC4
01FBE:  MOVLB  0
01FC0:  GOTO   1FEA
01FC4:  MOVLB  0
01FC6:  MOVLB  3
01FC8:  MOVF   x76,F
01FCA:  BTFSC  FD8.2
01FCC:  BRA    1FD4
01FCE:  MOVLB  0
01FD0:  GOTO   1FEA
01FD4:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01FD6:  MOVLW  AC
01FD8:  MOVWF  FF6
01FDA:  MOVLW  01
01FDC:  MOVWF  FF7
01FDE:  MOVLW  00
01FE0:  MOVWF  FF8
01FE2:  CALL   1C14
....................     } else {
01FE6:  GOTO   1FFA
....................         fprintf(PC, "\tConnect successful\r\n");
01FEA:  MOVLW  BE
01FEC:  MOVWF  FF6
01FEE:  MOVLW  01
01FF0:  MOVWF  FF7
01FF2:  MOVLW  00
01FF4:  MOVWF  FF8
01FF6:  CALL   1C14
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01FFA:  MOVLW  D4
01FFC:  MOVWF  FF6
01FFE:  MOVLW  01
02000:  MOVWF  FF7
02002:  MOVLW  00
02004:  MOVWF  FF8
02006:  CALL   1C14
0200A:  GOTO   92C2 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01E04:  MOVFF  BD2,BD9
01E08:  GOTO   1D2E
01E0C:  MOVFF  02,BD4
01E10:  MOVFF  01,BD3
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     // Send the command to the ADC
....................     output_low(ADC_CS); // Set CS pin low to select the ADC
01E14:  MOVLW  F4
01E16:  MOVWF  F93
01E18:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01E1A:  MOVLW  0D
01E1C:  MOVWF  00
01E1E:  DECFSZ 00,F
01E20:  BRA    1E1E
....................     spi_xfer(ADC_STREAM, cmd); // Dummy transfer to start communication
01E22:  MOVFF  BD4,BDA
01E26:  MOVFF  BD3,BD9
01E2A:  MOVLW  10
01E2C:  MOVLB  B
01E2E:  MOVWF  xDB
01E30:  MOVLW  01
01E32:  MOVWF  xDC
01E34:  MOVLB  0
01E36:  CALL   1D9E
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     delay_us(10); // Wait for the ADC to process the command
01E3A:  MOVLW  0D
01E3C:  MOVWF  00
01E3E:  DECFSZ 00,F
01E40:  BRA    1E3E
....................     output_high(ADC_CS); // Set CS pin high to end communication
01E42:  MOVLW  F4
01E44:  MOVWF  F93
01E46:  BSF    F8A.1
....................     delay_us(10); // Wait for the ADC to process the command
01E48:  MOVLW  0D
01E4A:  MOVWF  00
01E4C:  DECFSZ 00,F
01E4E:  BRA    1E4C
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01E50:  MOVLW  F4
01E52:  MOVWF  F93
01E54:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01E56:  MOVLW  0D
01E58:  MOVWF  00
01E5A:  DECFSZ 00,F
01E5C:  BRA    1E5A
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000); // Read data from ADC
01E5E:  MOVLB  B
01E60:  CLRF   xDA
01E62:  CLRF   xD9
01E64:  MOVLW  10
01E66:  MOVWF  xDB
01E68:  MOVLW  01
01E6A:  MOVWF  xDC
01E6C:  MOVLB  0
01E6E:  CALL   1D9E
01E72:  MOVFF  02,BD6
01E76:  MOVFF  01,BD5
....................     output_high(ADC_CS); 
01E7A:  MOVLW  F4
01E7C:  MOVWF  F93
01E7E:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E80:  MOVLB  B
01E82:  MOVF   xD5,W
01E84:  MOVWF  xD7
01E86:  MOVF   xD6,W
01E88:  ANDLW  0F
01E8A:  MOVWF  xD8
....................     
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E8C:  MOVF   xD7,W
01E8E:  MOVWF  01
01E90:  MOVF   xD8,W
01E92:  MOVWF  02
01E94:  MOVLB  0
01E96:  RETURN 0
.................... }
.................... 
.................... #include "../hardware/devices/src/mcp4901_driver.c"
.................... #include "../mcp4901_driver.h"                        // 同じデバイスフォルダのヘッダー
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=0, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/mcp4901.h"              // DACデバイスライブラリ
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
021E6:  MOVLW  E0
021E8:  MOVWF  FF6
021EA:  MOVLW  01
021EC:  MOVWF  FF7
021EE:  MOVLW  00
021F0:  MOVWF  FF8
021F2:  CALL   1C14
....................     output_high(DAC1_CS); 
021F6:  MOVLW  F4
021F8:  MOVWF  F93
021FA:  BSF    F8A.3
....................     output_high(DAC2_CS); 
021FC:  MOVLW  F4
021FE:  MOVWF  F93
02200:  BSF    F8A.0
....................     delay_ms(10); 
02202:  MOVLW  0A
02204:  MOVLB  C
02206:  MOVWF  x6B
02208:  MOVLB  0
0220A:  CALL   1B94
....................     mcp4901_1_write(0); 
0220E:  MOVLB  B
02210:  CLRF   xBE
02212:  CLRF   xBD
02214:  MOVLB  0
02216:  CALL   2162
....................     mcp4901_2_write(0); 
0221A:  MOVLB  B
0221C:  CLRF   xBE
0221E:  CLRF   xBD
02220:  MOVLB  0
02222:  CALL   21A4
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
02226:  MOVLW  08
02228:  MOVLB  B
0222A:  MOVWF  xD2
0222C:  MOVLB  0
0222E:  CALL   1E04
02232:  MOVFF  02,376
02236:  MOVFF  01,375
....................     fprintf(PC, "%04LX\r\n", readdata);
0223A:  MOVFF  376,BC1
0223E:  MOVLW  37
02240:  MOVLB  B
02242:  MOVWF  xC2
02244:  MOVLB  0
02246:  CALL   1E98
0224A:  MOVFF  375,BC1
0224E:  MOVLW  37
02250:  MOVLB  B
02252:  MOVWF  xC2
02254:  MOVLB  0
02256:  CALL   1E98
0225A:  MOVLW  0D
0225C:  MOVLB  C
0225E:  MOVWF  x14
02260:  MOVLB  0
02262:  CALL   1BC2
02266:  MOVLW  0A
02268:  MOVLB  C
0226A:  MOVWF  x14
0226C:  MOVLB  0
0226E:  CALL   1BC2
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
02272:  MOVLB  3
02274:  INCFSZ x75,W
02276:  BRA    227C
02278:  BRA    2282
0227A:  MOVLB  0
0227C:  MOVLB  0
0227E:  GOTO   229A
02282:  MOVLB  0
02284:  MOVLB  3
02286:  INCFSZ x76,W
02288:  BRA    228E
0228A:  BRA    2294
0228C:  MOVLB  0
0228E:  MOVLB  0
02290:  GOTO   229A
02294:  MOVLB  0
02296:  GOTO   22BA
0229A:  MOVLB  3
0229C:  MOVF   x75,F
0229E:  BTFSC  FD8.2
022A0:  BRA    22A8
022A2:  MOVLB  0
022A4:  GOTO   22CE
022A8:  MOVLB  0
022AA:  MOVLB  3
022AC:  MOVF   x76,F
022AE:  BTFSC  FD8.2
022B0:  BRA    22B8
022B2:  MOVLB  0
022B4:  GOTO   22CE
022B8:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
022BA:  MOVLW  F6
022BC:  MOVWF  FF6
022BE:  MOVLW  01
022C0:  MOVWF  FF7
022C2:  MOVLW  00
022C4:  MOVWF  FF8
022C6:  CALL   1C14
....................     } else {
022CA:  GOTO   22DE
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
022CE:  MOVLW  16
022D0:  MOVWF  FF6
022D2:  MOVLW  02
022D4:  MOVWF  FF7
022D6:  MOVLW  00
022D8:  MOVWF  FF8
022DA:  CALL   1C14
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
022DE:  MOVFF  376,BC1
022E2:  MOVLW  37
022E4:  MOVLB  B
022E6:  MOVWF  xC2
022E8:  MOVLB  0
022EA:  CALL   1E98
022EE:  MOVFF  375,BC1
022F2:  MOVLW  37
022F4:  MOVLB  B
022F6:  MOVWF  xC2
022F8:  MOVLB  0
022FA:  CALL   1E98
022FE:  MOVLW  0D
02300:  MOVLB  C
02302:  MOVWF  x14
02304:  MOVLB  0
02306:  CALL   1BC2
0230A:  MOVLW  0A
0230C:  MOVLB  C
0230E:  MOVWF  x14
02310:  MOVLB  0
02312:  CALL   1BC2
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
02316:  MOVLW  09
02318:  MOVLB  B
0231A:  MOVWF  xD2
0231C:  MOVLB  0
0231E:  CALL   1E04
02322:  MOVFF  02,376
02326:  MOVFF  01,375
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
0232A:  MOVLB  3
0232C:  INCFSZ x75,W
0232E:  BRA    2334
02330:  BRA    233A
02332:  MOVLB  0
02334:  MOVLB  0
02336:  GOTO   2352
0233A:  MOVLB  0
0233C:  MOVLB  3
0233E:  INCFSZ x76,W
02340:  BRA    2346
02342:  BRA    234C
02344:  MOVLB  0
02346:  MOVLB  0
02348:  GOTO   2352
0234C:  MOVLB  0
0234E:  GOTO   2372
02352:  MOVLB  3
02354:  MOVF   x75,F
02356:  BTFSC  FD8.2
02358:  BRA    2360
0235A:  MOVLB  0
0235C:  GOTO   2386
02360:  MOVLB  0
02362:  MOVLB  3
02364:  MOVF   x76,F
02366:  BTFSC  FD8.2
02368:  BRA    2370
0236A:  MOVLB  0
0236C:  GOTO   2386
02370:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
02372:  MOVLW  3A
02374:  MOVWF  FF6
02376:  MOVLW  02
02378:  MOVWF  FF7
0237A:  MOVLW  00
0237C:  MOVWF  FF8
0237E:  CALL   1C14
....................     } else {
02382:  GOTO   2396
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02386:  MOVLW  5A
02388:  MOVWF  FF6
0238A:  MOVLW  02
0238C:  MOVWF  FF7
0238E:  MOVLW  00
02390:  MOVWF  FF8
02392:  CALL   1C14
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02396:  MOVLW  7E
02398:  MOVWF  FF6
0239A:  MOVLW  02
0239C:  MOVWF  FF7
0239E:  MOVLW  00
023A0:  MOVWF  FF8
023A2:  CALL   1C14
023A6:  GOTO   92C6 (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
02162:  MOVFF  BBE,BC2
02166:  MOVFF  BBD,BC1
0216A:  CALL   200E
0216E:  MOVFF  02,BC0
02172:  MOVFF  01,BBF
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
02176:  MOVLW  F4
02178:  MOVWF  F93
0217A:  BCF    F8A.3
....................    delay_us(10); 
0217C:  MOVLW  0D
0217E:  MOVWF  00
02180:  DECFSZ 00,F
02182:  BRA    2180
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02184:  MOVFF  BC0,BDA
02188:  MOVFF  BBF,BD9
0218C:  MOVLW  10
0218E:  MOVLB  B
02190:  MOVWF  xDB
02192:  MOVLW  01
02194:  MOVWF  xDC
02196:  MOVLB  0
02198:  CALL   1D9E
....................    output_high(DAC1_CS); 
0219C:  MOVLW  F4
0219E:  MOVWF  F93
021A0:  BSF    F8A.3
021A2:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
021A4:  MOVFF  BBE,BC2
021A8:  MOVFF  BBD,BC1
021AC:  CALL   200E
021B0:  MOVFF  02,BC0
021B4:  MOVFF  01,BBF
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
021B8:  MOVLW  F4
021BA:  MOVWF  F93
021BC:  BCF    F8A.0
....................    delay_us(10); 
021BE:  MOVLW  0D
021C0:  MOVWF  00
021C2:  DECFSZ 00,F
021C4:  BRA    21C2
....................    spi_xfer(ADCDAC_STREAM, cmd); 
021C6:  MOVFF  BC0,BDA
021CA:  MOVFF  BBF,BD9
021CE:  MOVLW  10
021D0:  MOVLB  B
021D2:  MOVWF  xDB
021D4:  MOVLW  01
021D6:  MOVWF  xDC
021D8:  MOVLB  0
021DA:  CALL   1D9E
....................    output_high(DAC2_CS); 
021DE:  MOVLW  F4
021E0:  MOVWF  F93
021E2:  BSF    F8A.0
021E4:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01D2E:  MOVLB  B
01D30:  BCF    xDA.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01D32:  BCF    xDA.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01D34:  BCF    xDA.2
....................     cmd.fields.reserved3 = 0;
01D36:  BCF    xDA.3
....................     cmd.fields.coding = 1; // Two's complement
01D38:  BSF    xDA.4
....................     cmd.fields.range = 1; // Normal mode
01D3A:  BSF    xDA.5
....................     cmd.fields.weak_tri = 0; // Strong trigger
01D3C:  BCF    xDA.6
....................     cmd.fields.shadow = 0; // Direct access
01D3E:  BCF    xDA.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01D40:  BSF    xDB.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01D42:  BSF    xDB.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01D44:  MOVF   xD9,W
01D46:  ANDLW  01
01D48:  MOVWF  01
01D4A:  BCF    xDB.2
01D4C:  BTFSC  01.0
01D4E:  BSF    xDB.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01D50:  BCF    FD8.0
01D52:  RRCF   xD9,W
01D54:  ANDLW  01
01D56:  MOVWF  01
01D58:  BCF    xDB.3
01D5A:  BTFSC  01.0
01D5C:  BSF    xDB.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01D5E:  RRCF   xD9,W
01D60:  MOVWF  00
01D62:  RRCF   00,F
01D64:  MOVLW  3F
01D66:  ANDWF  00,F
01D68:  MOVF   00,W
01D6A:  ANDLW  01
01D6C:  MOVWF  01
01D6E:  BCF    xDB.4
01D70:  BTFSC  01.0
01D72:  BSF    xDB.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D74:  RRCF   xD9,W
01D76:  MOVWF  00
01D78:  RRCF   00,F
01D7A:  RRCF   00,F
01D7C:  MOVLW  1F
01D7E:  ANDWF  00,F
01D80:  MOVF   00,W
01D82:  ANDLW  01
01D84:  MOVWF  01
01D86:  BCF    xDB.5
01D88:  BTFSC  01.0
01D8A:  BSF    xDB.5
....................     cmd.fields.seq = 0; // Random mode
01D8C:  BCF    xDB.6
....................     cmd.fields.write = 1; // Read operation
01D8E:  BSF    xDB.7
.................... 
.................... 
....................     return cmd.value;
01D90:  MOVF   xDA,W
01D92:  MOVWF  01
01D94:  MOVF   xDB,W
01D96:  MOVWF  02
01D98:  MOVLB  0
01D9A:  GOTO   1E0C (RETURN)
.................... }
.................... 
.................... #include "../../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
0200E:  MOVLB  B
02010:  BCF    xC4.7
....................    cmd.fields.buffer = 1; // Buffer used
02012:  BSF    xC4.6
....................    cmd.fields.gain = 1; // Gain 1x
02014:  BSF    xC4.5
....................    cmd.fields.shutdown = 1; // Normal operation
02016:  BSF    xC4.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
02018:  RRCF   xC2,W
0201A:  MOVWF  xC6
0201C:  RRCF   xC1,W
0201E:  MOVWF  xC5
02020:  RRCF   xC6,F
02022:  RRCF   xC5,F
02024:  RRCF   xC6,F
02026:  RRCF   xC5,F
02028:  RRCF   xC6,F
0202A:  RRCF   xC5,F
0202C:  RRCF   xC6,F
0202E:  RRCF   xC5,F
02030:  RRCF   xC6,F
02032:  RRCF   xC5,F
02034:  RRCF   xC6,F
02036:  RRCF   xC5,F
02038:  MOVLW  01
0203A:  ANDWF  xC6,F
0203C:  MOVF   xC5,W
0203E:  ANDLW  01
02040:  MOVWF  00
02042:  CLRF   03
02044:  MOVF   00,W
02046:  MOVWF  01
02048:  BCF    xC4.3
0204A:  BTFSC  01.0
0204C:  BSF    xC4.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
0204E:  RRCF   xC2,W
02050:  MOVWF  xC6
02052:  RRCF   xC1,W
02054:  MOVWF  xC5
02056:  RRCF   xC6,F
02058:  RRCF   xC5,F
0205A:  RRCF   xC6,F
0205C:  RRCF   xC5,F
0205E:  RRCF   xC6,F
02060:  RRCF   xC5,F
02062:  RRCF   xC6,F
02064:  RRCF   xC5,F
02066:  RRCF   xC6,F
02068:  RRCF   xC5,F
0206A:  MOVLW  03
0206C:  ANDWF  xC6,F
0206E:  MOVF   xC5,W
02070:  ANDLW  01
02072:  MOVWF  00
02074:  CLRF   03
02076:  MOVF   00,W
02078:  MOVWF  01
0207A:  BCF    xC4.2
0207C:  BTFSC  01.0
0207E:  BSF    xC4.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
02080:  RRCF   xC2,W
02082:  MOVWF  xC6
02084:  RRCF   xC1,W
02086:  MOVWF  xC5
02088:  RRCF   xC6,F
0208A:  RRCF   xC5,F
0208C:  RRCF   xC6,F
0208E:  RRCF   xC5,F
02090:  RRCF   xC6,F
02092:  RRCF   xC5,F
02094:  RRCF   xC6,F
02096:  RRCF   xC5,F
02098:  MOVLW  07
0209A:  ANDWF  xC6,F
0209C:  MOVF   xC5,W
0209E:  ANDLW  01
020A0:  MOVWF  00
020A2:  CLRF   03
020A4:  MOVF   00,W
020A6:  MOVWF  01
020A8:  BCF    xC4.1
020AA:  BTFSC  01.0
020AC:  BSF    xC4.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
020AE:  RRCF   xC2,W
020B0:  MOVWF  xC6
020B2:  RRCF   xC1,W
020B4:  MOVWF  xC5
020B6:  RRCF   xC6,F
020B8:  RRCF   xC5,F
020BA:  RRCF   xC6,F
020BC:  RRCF   xC5,F
020BE:  RRCF   xC6,F
020C0:  RRCF   xC5,F
020C2:  MOVLW  0F
020C4:  ANDWF  xC6,F
020C6:  MOVF   xC5,W
020C8:  ANDLW  01
020CA:  MOVWF  00
020CC:  CLRF   03
020CE:  MOVF   00,W
020D0:  MOVWF  01
020D2:  BCF    xC4.0
020D4:  BTFSC  01.0
020D6:  BSF    xC4.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
020D8:  RRCF   xC2,W
020DA:  MOVWF  xC6
020DC:  RRCF   xC1,W
020DE:  MOVWF  xC5
020E0:  RRCF   xC6,F
020E2:  RRCF   xC5,F
020E4:  RRCF   xC6,F
020E6:  RRCF   xC5,F
020E8:  MOVLW  1F
020EA:  ANDWF  xC6,F
020EC:  MOVF   xC5,W
020EE:  ANDLW  01
020F0:  MOVWF  00
020F2:  CLRF   03
020F4:  MOVF   00,W
020F6:  MOVWF  01
020F8:  BCF    xC3.7
020FA:  BTFSC  01.0
020FC:  BSF    xC3.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
020FE:  RRCF   xC2,W
02100:  MOVWF  xC6
02102:  RRCF   xC1,W
02104:  MOVWF  xC5
02106:  RRCF   xC6,F
02108:  RRCF   xC5,F
0210A:  MOVLW  3F
0210C:  ANDWF  xC6,F
0210E:  MOVF   xC5,W
02110:  ANDLW  01
02112:  MOVWF  00
02114:  CLRF   03
02116:  MOVF   00,W
02118:  MOVWF  01
0211A:  BCF    xC3.6
0211C:  BTFSC  01.0
0211E:  BSF    xC3.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
02120:  BCF    FD8.0
02122:  RRCF   xC2,W
02124:  MOVWF  xC6
02126:  RRCF   xC1,W
02128:  MOVWF  xC5
0212A:  MOVF   xC5,W
0212C:  ANDLW  01
0212E:  MOVWF  00
02130:  CLRF   03
02132:  MOVF   00,W
02134:  MOVWF  01
02136:  BCF    xC3.5
02138:  BTFSC  01.0
0213A:  BSF    xC3.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
0213C:  MOVF   xC1,W
0213E:  ANDLW  01
02140:  MOVWF  00
02142:  CLRF   03
02144:  MOVF   00,W
02146:  MOVWF  01
02148:  BCF    xC3.4
0214A:  BTFSC  01.0
0214C:  BSF    xC3.4
....................    cmd.fields.reserved = 0; // Reserved bits
0214E:  BCF    xC3.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
02150:  BCF    xC3.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
02152:  BCF    xC3.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
02154:  BCF    xC3.0
.................... 
....................    return cmd.value;
02156:  MOVF   xC3,W
02158:  MOVWF  01
0215A:  MOVF   xC4,W
0215C:  MOVWF  02
0215E:  MOVLB  0
02160:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
02E64:  MOVLB  C
02E66:  MOVF   x6B,W
02E68:  XORLW  00
02E6A:  MOVLB  0
02E6C:  BTFSC  FD8.2
02E6E:  GOTO   2E7E
02E72:  XORLW  01
02E74:  BTFSC  FD8.2
02E76:  GOTO   2EE6
02E7A:  GOTO   2F4E
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
02E7E:  MOVLB  C
02E80:  CLRF   x74
02E82:  CLRF   x73
02E84:  MOVLB  0
02E86:  MOVLB  C
02E88:  MOVF   x74,W
02E8A:  SUBWF  x72,W
02E8C:  BTFSC  FD8.0
02E8E:  BRA    2E96
02E90:  MOVLB  0
02E92:  GOTO   2EE2
02E96:  MOVLB  0
02E98:  BTFSS  FD8.2
02E9A:  GOTO   2EB0
02E9E:  MOVLB  C
02EA0:  MOVF   x71,W
02EA2:  SUBWF  x73,W
02EA4:  BTFSS  FD8.0
02EA6:  BRA    2EAE
02EA8:  MOVLB  0
02EAA:  GOTO   2EE2
02EAE:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
02EB0:  MOVLB  C
02EB2:  MOVF   x6F,W
02EB4:  ADDWF  x73,W
02EB6:  MOVWF  FE9
02EB8:  MOVF   x70,W
02EBA:  ADDWFC x74,W
02EBC:  MOVWF  FEA
02EBE:  MOVFF  FEF,C77
02EC2:  MOVFF  C77,C8D
02EC6:  MOVLW  08
02EC8:  MOVWF  x8E
02ECA:  MOVLW  01
02ECC:  MOVWF  x8F
02ECE:  MOVLB  0
02ED0:  CALL   23FE
02ED4:  MOVLB  C
02ED6:  INCF   x73,F
02ED8:  BTFSC  FD8.2
02EDA:  INCF   x74,F
02EDC:  MOVLB  0
02EDE:  GOTO   2E86
....................          break;
02EE2:  GOTO   2F52
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
02EE6:  MOVLB  C
02EE8:  CLRF   x76
02EEA:  CLRF   x75
02EEC:  MOVLB  0
02EEE:  MOVLB  C
02EF0:  MOVF   x76,W
02EF2:  SUBWF  x72,W
02EF4:  BTFSC  FD8.0
02EF6:  BRA    2EFE
02EF8:  MOVLB  0
02EFA:  GOTO   2F4A
02EFE:  MOVLB  0
02F00:  BTFSS  FD8.2
02F02:  GOTO   2F18
02F06:  MOVLB  C
02F08:  MOVF   x71,W
02F0A:  SUBWF  x75,W
02F0C:  BTFSS  FD8.0
02F0E:  BRA    2F16
02F10:  MOVLB  0
02F12:  GOTO   2F4A
02F16:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
02F18:  MOVLB  C
02F1A:  MOVF   x6F,W
02F1C:  ADDWF  x75,W
02F1E:  MOVWF  FE9
02F20:  MOVF   x70,W
02F22:  ADDWFC x76,W
02F24:  MOVWF  FEA
02F26:  MOVFF  FEF,C77
02F2A:  MOVFF  C77,C8D
02F2E:  MOVLW  08
02F30:  MOVWF  x8E
02F32:  MOVLW  01
02F34:  MOVWF  x8F
02F36:  MOVLB  0
02F38:  CALL   247A
02F3C:  MOVLB  C
02F3E:  INCF   x75,F
02F40:  BTFSC  FD8.2
02F42:  INCF   x76,F
02F44:  MOVLB  0
02F46:  GOTO   2EEE
....................          break;
02F4A:  GOTO   2F52
....................          
....................       default:
....................          break;
02F4E:  GOTO   2F52
....................    }
....................    return;
02F52:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
024F6:  MOVLB  C
024F8:  MOVF   x71,W
024FA:  XORLW  00
024FC:  MOVLB  0
024FE:  BTFSC  FD8.2
02500:  GOTO   2510
02504:  XORLW  01
02506:  BTFSC  FD8.2
02508:  GOTO   261A
0250C:  GOTO   2724
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
02510:  MOVLB  C
02512:  CLRF   x80
02514:  CLRF   x7F
02516:  MOVLB  0
02518:  MOVLB  C
0251A:  MOVF   x80,W
0251C:  SUBWF  x78,W
0251E:  BTFSC  FD8.0
02520:  BRA    2528
02522:  MOVLB  0
02524:  GOTO   2574
02528:  MOVLB  0
0252A:  BTFSS  FD8.2
0252C:  GOTO   2542
02530:  MOVLB  C
02532:  MOVF   x77,W
02534:  SUBWF  x7F,W
02536:  BTFSS  FD8.0
02538:  BRA    2540
0253A:  MOVLB  0
0253C:  GOTO   2574
02540:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
02542:  MOVLB  C
02544:  MOVF   x75,W
02546:  ADDWF  x7F,W
02548:  MOVWF  FE9
0254A:  MOVF   x76,W
0254C:  ADDWFC x80,W
0254E:  MOVWF  FEA
02550:  MOVFF  FEF,C8B
02554:  MOVFF  C8B,C8D
02558:  MOVLW  08
0255A:  MOVWF  x8E
0255C:  MOVLW  01
0255E:  MOVWF  x8F
02560:  MOVLB  0
02562:  CALL   23FE
02566:  MOVLB  C
02568:  INCF   x7F,F
0256A:  BTFSC  FD8.2
0256C:  INCF   x80,F
0256E:  MOVLB  0
02570:  GOTO   2518
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02574:  MOVLB  C
02576:  CLRF   x84
02578:  CLRF   x83
0257A:  CLRF   x82
0257C:  CLRF   x81
0257E:  MOVLB  0
02580:  MOVLB  C
02582:  MOVF   x84,W
02584:  SUBWF  x7E,W
02586:  BTFSC  FD8.0
02588:  BRA    2590
0258A:  MOVLB  0
0258C:  GOTO   2616
02590:  MOVLB  0
02592:  BTFSS  FD8.2
02594:  GOTO   25DA
02598:  MOVLB  C
0259A:  MOVF   x83,W
0259C:  SUBWF  x7D,W
0259E:  BTFSC  FD8.0
025A0:  BRA    25A8
025A2:  MOVLB  0
025A4:  GOTO   2616
025A8:  MOVLB  0
025AA:  BTFSS  FD8.2
025AC:  GOTO   25DA
025B0:  MOVLB  C
025B2:  MOVF   x82,W
025B4:  SUBWF  x7C,W
025B6:  BTFSC  FD8.0
025B8:  BRA    25C0
025BA:  MOVLB  0
025BC:  GOTO   2616
025C0:  MOVLB  0
025C2:  BTFSS  FD8.2
025C4:  GOTO   25DA
025C8:  MOVLB  C
025CA:  MOVF   x7B,W
025CC:  SUBWF  x81,W
025CE:  BTFSS  FD8.0
025D0:  BRA    25D8
025D2:  MOVLB  0
025D4:  GOTO   2616
025D8:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
025DA:  MOVLB  C
025DC:  MOVF   x79,W
025DE:  ADDWF  x81,W
025E0:  MOVWF  FE9
025E2:  MOVF   x7A,W
025E4:  ADDWFC x82,W
025E6:  MOVWF  FEA
025E8:  MOVLW  02
025EA:  MOVWF  x8D
025EC:  MOVLW  08
025EE:  MOVWF  x8E
025F0:  MOVLW  01
025F2:  MOVWF  x8F
025F4:  MOVLB  0
025F6:  CALL   23FE
025FA:  MOVFF  01,FEF
025FE:  MOVLW  01
02600:  MOVLB  C
02602:  ADDWF  x81,F
02604:  BTFSC  FD8.0
02606:  INCF   x82,F
02608:  BTFSC  FD8.2
0260A:  INCF   x83,F
0260C:  BTFSC  FD8.2
0260E:  INCF   x84,F
02610:  MOVLB  0
02612:  GOTO   2580
....................          break;
02616:  GOTO   2728
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
0261A:  MOVLB  C
0261C:  CLRF   x86
0261E:  CLRF   x85
02620:  MOVLB  0
02622:  MOVLB  C
02624:  MOVF   x86,W
02626:  SUBWF  x78,W
02628:  BTFSC  FD8.0
0262A:  BRA    2632
0262C:  MOVLB  0
0262E:  GOTO   267E
02632:  MOVLB  0
02634:  BTFSS  FD8.2
02636:  GOTO   264C
0263A:  MOVLB  C
0263C:  MOVF   x77,W
0263E:  SUBWF  x85,W
02640:  BTFSS  FD8.0
02642:  BRA    264A
02644:  MOVLB  0
02646:  GOTO   267E
0264A:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
0264C:  MOVLB  C
0264E:  MOVF   x75,W
02650:  ADDWF  x85,W
02652:  MOVWF  FE9
02654:  MOVF   x76,W
02656:  ADDWFC x86,W
02658:  MOVWF  FEA
0265A:  MOVFF  FEF,C8B
0265E:  MOVFF  C8B,C8D
02662:  MOVLW  08
02664:  MOVWF  x8E
02666:  MOVLW  01
02668:  MOVWF  x8F
0266A:  MOVLB  0
0266C:  CALL   247A
02670:  MOVLB  C
02672:  INCF   x85,F
02674:  BTFSC  FD8.2
02676:  INCF   x86,F
02678:  MOVLB  0
0267A:  GOTO   2622
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0267E:  MOVLB  C
02680:  CLRF   x8A
02682:  CLRF   x89
02684:  CLRF   x88
02686:  CLRF   x87
02688:  MOVLB  0
0268A:  MOVLB  C
0268C:  MOVF   x8A,W
0268E:  SUBWF  x7E,W
02690:  BTFSC  FD8.0
02692:  BRA    269A
02694:  MOVLB  0
02696:  GOTO   2720
0269A:  MOVLB  0
0269C:  BTFSS  FD8.2
0269E:  GOTO   26E4
026A2:  MOVLB  C
026A4:  MOVF   x89,W
026A6:  SUBWF  x7D,W
026A8:  BTFSC  FD8.0
026AA:  BRA    26B2
026AC:  MOVLB  0
026AE:  GOTO   2720
026B2:  MOVLB  0
026B4:  BTFSS  FD8.2
026B6:  GOTO   26E4
026BA:  MOVLB  C
026BC:  MOVF   x88,W
026BE:  SUBWF  x7C,W
026C0:  BTFSC  FD8.0
026C2:  BRA    26CA
026C4:  MOVLB  0
026C6:  GOTO   2720
026CA:  MOVLB  0
026CC:  BTFSS  FD8.2
026CE:  GOTO   26E4
026D2:  MOVLB  C
026D4:  MOVF   x7B,W
026D6:  SUBWF  x87,W
026D8:  BTFSS  FD8.0
026DA:  BRA    26E2
026DC:  MOVLB  0
026DE:  GOTO   2720
026E2:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
026E4:  MOVLB  C
026E6:  MOVF   x79,W
026E8:  ADDWF  x87,W
026EA:  MOVWF  FE9
026EC:  MOVF   x7A,W
026EE:  ADDWFC x88,W
026F0:  MOVWF  FEA
026F2:  MOVLW  01
026F4:  MOVWF  x8D
026F6:  MOVLW  08
026F8:  MOVWF  x8E
026FA:  MOVLW  01
026FC:  MOVWF  x8F
026FE:  MOVLB  0
02700:  CALL   247A
02704:  MOVFF  01,FEF
02708:  MOVLW  01
0270A:  MOVLB  C
0270C:  ADDWF  x87,F
0270E:  BTFSC  FD8.0
02710:  INCF   x88,F
02712:  BTFSC  FD8.2
02714:  INCF   x89,F
02716:  BTFSC  FD8.2
02718:  INCF   x8A,F
0271A:  MOVLB  0
0271C:  GOTO   268A
....................          break;
02720:  GOTO   2728
....................    
....................          
....................       default:
....................          break;
02724:  GOTO   2728
....................    }
....................    return;
02728:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
02F54:  MOVLB  C
02F56:  MOVF   x6B,W
02F58:  XORLW  00
02F5A:  MOVLB  0
02F5C:  BTFSC  FD8.2
02F5E:  GOTO   2F6E
02F62:  XORLW  01
02F64:  BTFSC  FD8.2
02F66:  GOTO   301C
02F6A:  GOTO   30CA
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
02F6E:  MOVLB  C
02F70:  CLRF   x76
02F72:  MOVLB  0
02F74:  MOVLB  C
02F76:  MOVF   x71,W
02F78:  SUBWF  x76,W
02F7A:  BTFSS  FD8.0
02F7C:  BRA    2F84
02F7E:  MOVLB  0
02F80:  GOTO   2FB4
02F84:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
02F86:  MOVLB  C
02F88:  MOVF   x76,W
02F8A:  ADDWF  x6F,W
02F8C:  MOVWF  FE9
02F8E:  MOVLW  00
02F90:  ADDWFC x70,W
02F92:  MOVWF  FEA
02F94:  MOVFF  FEF,C7C
02F98:  MOVFF  C7C,C8D
02F9C:  MOVLW  08
02F9E:  MOVWF  x8E
02FA0:  MOVLW  01
02FA2:  MOVWF  x8F
02FA4:  MOVLB  0
02FA6:  CALL   23FE
02FAA:  MOVLB  C
02FAC:  INCF   x76,F
02FAE:  MOVLB  0
02FB0:  GOTO   2F74
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
02FB4:  MOVLB  C
02FB6:  CLRF   x78
02FB8:  CLRF   x77
02FBA:  MOVLB  0
02FBC:  MOVLB  C
02FBE:  MOVF   x78,W
02FC0:  SUBWF  x75,W
02FC2:  BTFSC  FD8.0
02FC4:  BRA    2FCC
02FC6:  MOVLB  0
02FC8:  GOTO   3018
02FCC:  MOVLB  0
02FCE:  BTFSS  FD8.2
02FD0:  GOTO   2FE6
02FD4:  MOVLB  C
02FD6:  MOVF   x74,W
02FD8:  SUBWF  x77,W
02FDA:  BTFSS  FD8.0
02FDC:  BRA    2FE4
02FDE:  MOVLB  0
02FE0:  GOTO   3018
02FE4:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
02FE6:  MOVLB  C
02FE8:  MOVF   x72,W
02FEA:  ADDWF  x77,W
02FEC:  MOVWF  FE9
02FEE:  MOVF   x73,W
02FF0:  ADDWFC x78,W
02FF2:  MOVWF  FEA
02FF4:  MOVFF  FEF,C7C
02FF8:  MOVFF  C7C,C8D
02FFC:  MOVLW  08
02FFE:  MOVWF  x8E
03000:  MOVLW  01
03002:  MOVWF  x8F
03004:  MOVLB  0
03006:  CALL   23FE
0300A:  MOVLB  C
0300C:  INCF   x77,F
0300E:  BTFSC  FD8.2
03010:  INCF   x78,F
03012:  MOVLB  0
03014:  GOTO   2FBC
....................          break;
03018:  GOTO   30CE
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
0301C:  MOVLB  C
0301E:  CLRF   x79
03020:  MOVLB  0
03022:  MOVLB  C
03024:  MOVF   x71,W
03026:  SUBWF  x79,W
03028:  BTFSS  FD8.0
0302A:  BRA    3032
0302C:  MOVLB  0
0302E:  GOTO   3062
03032:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
03034:  MOVLB  C
03036:  MOVF   x79,W
03038:  ADDWF  x6F,W
0303A:  MOVWF  FE9
0303C:  MOVLW  00
0303E:  ADDWFC x70,W
03040:  MOVWF  FEA
03042:  MOVFF  FEF,C7C
03046:  MOVFF  C7C,C8D
0304A:  MOVLW  08
0304C:  MOVWF  x8E
0304E:  MOVLW  01
03050:  MOVWF  x8F
03052:  MOVLB  0
03054:  CALL   247A
03058:  MOVLB  C
0305A:  INCF   x79,F
0305C:  MOVLB  0
0305E:  GOTO   3022
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03062:  MOVLB  C
03064:  CLRF   x7B
03066:  CLRF   x7A
03068:  MOVLB  0
0306A:  MOVLB  C
0306C:  MOVF   x7B,W
0306E:  SUBWF  x75,W
03070:  BTFSC  FD8.0
03072:  BRA    307A
03074:  MOVLB  0
03076:  GOTO   30C6
0307A:  MOVLB  0
0307C:  BTFSS  FD8.2
0307E:  GOTO   3094
03082:  MOVLB  C
03084:  MOVF   x74,W
03086:  SUBWF  x7A,W
03088:  BTFSS  FD8.0
0308A:  BRA    3092
0308C:  MOVLB  0
0308E:  GOTO   30C6
03092:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
03094:  MOVLB  C
03096:  MOVF   x72,W
03098:  ADDWF  x7A,W
0309A:  MOVWF  FE9
0309C:  MOVF   x73,W
0309E:  ADDWFC x7B,W
030A0:  MOVWF  FEA
030A2:  MOVFF  FEF,C7C
030A6:  MOVFF  C7C,C8D
030AA:  MOVLW  08
030AC:  MOVWF  x8E
030AE:  MOVLW  01
030B0:  MOVWF  x8F
030B2:  MOVLB  0
030B4:  CALL   247A
030B8:  MOVLB  C
030BA:  INCF   x7A,F
030BC:  BTFSC  FD8.2
030BE:  INCF   x7B,F
030C0:  MOVLB  0
030C2:  GOTO   306A
....................          break;
030C6:  GOTO   30CE
....................          
....................       default:
....................          break;
030CA:  GOTO   30CE
....................    }
....................    return;
030CE:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
04DC6:  MOVFF  48B,C71
04DCA:  MOVLW  01
04DCC:  MOVLB  C
04DCE:  MOVWF  x72
04DD0:  MOVLW  0F
04DD2:  MOVWF  x74
04DD4:  MOVLW  89
04DD6:  MOVWF  x73
04DD8:  MOVLB  0
04DDA:  CALL   23AA
04DDE:  MOVFF  48B,C71
04DE2:  MOVLB  C
04DE4:  CLRF   x72
04DE6:  MOVLW  0F
04DE8:  MOVWF  x74
04DEA:  MOVLW  92
04DEC:  MOVWF  x73
04DEE:  MOVLB  0
04DF0:  CALL   23AA
04DF4:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
030D0:  MOVLW  05
030D2:  MOVLB  C
030D4:  MOVWF  x6F
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
030D6:  MOVFF  C6D,C71
030DA:  CLRF   x72
030DC:  MOVLW  0F
030DE:  MOVWF  x74
030E0:  MOVLW  89
030E2:  MOVWF  x73
030E4:  MOVLB  0
030E6:  CALL   23AA
030EA:  MOVFF  C6D,C71
030EE:  MOVLB  C
030F0:  CLRF   x72
030F2:  MOVLW  0F
030F4:  MOVWF  x74
030F6:  MOVLW  92
030F8:  MOVWF  x73
030FA:  MOVLB  0
030FC:  CALL   23AA
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
03100:  MOVFF  C6E,C74
03104:  MOVFF  C6D,C73
03108:  MOVFF  C6C,C72
0310C:  MOVFF  C6B,C71
03110:  MOVLW  0C
03112:  MOVLB  C
03114:  MOVWF  x76
03116:  MOVLW  6F
03118:  MOVWF  x75
0311A:  CLRF   x78
0311C:  MOVLW  01
0311E:  MOVWF  x77
03120:  MOVLW  0C
03122:  MOVWF  x7A
03124:  MOVLW  70
03126:  MOVWF  x79
03128:  CLRF   x7E
0312A:  CLRF   x7D
0312C:  CLRF   x7C
0312E:  MOVLW  01
03130:  MOVWF  x7B
03132:  MOVLB  0
03134:  CALL   24F6
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
03138:  MOVFF  C6D,C71
0313C:  MOVLW  01
0313E:  MOVLB  C
03140:  MOVWF  x72
03142:  MOVLW  0F
03144:  MOVWF  x74
03146:  MOVLW  89
03148:  MOVWF  x73
0314A:  MOVLB  0
0314C:  CALL   23AA
03150:  MOVFF  C6D,C71
03154:  MOVLB  C
03156:  CLRF   x72
03158:  MOVLW  0F
0315A:  MOVWF  x74
0315C:  MOVLW  92
0315E:  MOVWF  x73
03160:  MOVLB  0
03162:  CALL   23AA
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
03166:  MOVLB  C
03168:  MOVF   x70,W
0316A:  MOVWF  01
0316C:  MOVLB  0
0316E:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
03DD2:  MOVLB  3
03DD4:  MOVF   xC5,F
03DD6:  BTFSC  FD8.2
03DD8:  BRA    3DE0
03DDA:  MOVLB  0
03DDC:  GOTO   3F38
03DE0:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
03DE2:  MOVLW  06
03DE4:  MOVLB  3
03DE6:  MOVWF  xCC
03DE8:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
03DEA:  MOVLW  D8
03DEC:  MOVLB  3
03DEE:  MOVWF  xCD
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03DF0:  MOVFF  3CA,3D9
03DF4:  MOVFF  3CB,3DA
03DF8:  CLRF   xDB
03DFA:  CLRF   xDC
03DFC:  MOVF   xD9,W
03DFE:  MOVWF  00
03E00:  CLRF   01
03E02:  CLRF   02
03E04:  CLRF   03
03E06:  MOVFF  00,3CE
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03E0A:  MOVFF  3C9,3D9
03E0E:  MOVFF  3CA,3DA
03E12:  MOVFF  3CB,3DB
03E16:  CLRF   xDC
03E18:  MOVF   xD9,W
03E1A:  MOVWF  00
03E1C:  CLRF   01
03E1E:  CLRF   02
03E20:  CLRF   03
03E22:  MOVFF  00,3CF
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
03E26:  MOVF   xC8,W
03E28:  MOVWF  00
03E2A:  CLRF   01
03E2C:  CLRF   02
03E2E:  CLRF   03
03E30:  MOVFF  00,3D0
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03E34:  MOVFF  3C6,C71
03E38:  MOVLB  C
03E3A:  CLRF   x72
03E3C:  MOVLW  0F
03E3E:  MOVWF  x74
03E40:  MOVLW  89
03E42:  MOVWF  x73
03E44:  MOVLB  0
03E46:  CALL   23AA
03E4A:  MOVFF  3C6,C71
03E4E:  MOVLB  C
03E50:  CLRF   x72
03E52:  MOVLW  0F
03E54:  MOVWF  x74
03E56:  MOVLW  92
03E58:  MOVWF  x73
03E5A:  MOVLB  0
03E5C:  CALL   23AA
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03E60:  MOVFF  3C7,C6E
03E64:  MOVFF  3C6,C6D
03E68:  MOVFF  3C5,C6C
03E6C:  MOVFF  3C4,C6B
03E70:  MOVLW  03
03E72:  MOVLB  C
03E74:  MOVWF  x70
03E76:  MOVLW  CC
03E78:  MOVWF  x6F
03E7A:  CLRF   x72
03E7C:  MOVLW  01
03E7E:  MOVWF  x71
03E80:  MOVLB  0
03E82:  CALL   2E64
....................       output_high(flash_stream.cs_pin);
03E86:  MOVFF  3C6,C71
03E8A:  MOVLW  01
03E8C:  MOVLB  C
03E8E:  MOVWF  x72
03E90:  MOVLW  0F
03E92:  MOVWF  x74
03E94:  MOVLW  89
03E96:  MOVWF  x73
03E98:  MOVLB  0
03E9A:  CALL   23AA
03E9E:  MOVFF  3C6,C71
03EA2:  MOVLB  C
03EA4:  CLRF   x72
03EA6:  MOVLW  0F
03EA8:  MOVWF  x74
03EAA:  MOVLW  92
03EAC:  MOVWF  x73
03EAE:  MOVLB  0
03EB0:  CALL   23AA
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03EB4:  MOVFF  3C6,C71
03EB8:  MOVLB  C
03EBA:  CLRF   x72
03EBC:  MOVLW  0F
03EBE:  MOVWF  x74
03EC0:  MOVLW  89
03EC2:  MOVWF  x73
03EC4:  MOVLB  0
03EC6:  CALL   23AA
03ECA:  MOVFF  3C6,C71
03ECE:  MOVLB  C
03ED0:  CLRF   x72
03ED2:  MOVLW  0F
03ED4:  MOVWF  x74
03ED6:  MOVLW  92
03ED8:  MOVWF  x73
03EDA:  MOVLB  0
03EDC:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
03EE0:  MOVFF  3C7,C6E
03EE4:  MOVFF  3C6,C6D
03EE8:  MOVFF  3C5,C6C
03EEC:  MOVFF  3C4,C6B
03EF0:  MOVLW  03
03EF2:  MOVLB  C
03EF4:  MOVWF  x70
03EF6:  MOVLW  CD
03EF8:  MOVWF  x6F
03EFA:  CLRF   x72
03EFC:  MOVLW  04
03EFE:  MOVWF  x71
03F00:  MOVLB  0
03F02:  CALL   2E64
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03F06:  MOVFF  3C6,C71
03F0A:  MOVLW  01
03F0C:  MOVLB  C
03F0E:  MOVWF  x72
03F10:  MOVLW  0F
03F12:  MOVWF  x74
03F14:  MOVLW  89
03F16:  MOVWF  x73
03F18:  MOVLB  0
03F1A:  CALL   23AA
03F1E:  MOVFF  3C6,C71
03F22:  MOVLB  C
03F24:  CLRF   x72
03F26:  MOVLW  0F
03F28:  MOVWF  x74
03F2A:  MOVLW  92
03F2C:  MOVWF  x73
03F2E:  MOVLB  0
03F30:  CALL   23AA
....................    }
03F34:  GOTO   40B8
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
03F38:  MOVLB  3
03F3A:  DECFSZ xC5,W
03F3C:  BRA    3F42
03F3E:  BRA    3F48
03F40:  MOVLB  0
03F42:  MOVLB  0
03F44:  GOTO   40B8
03F48:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
03F4A:  MOVLW  06
03F4C:  MOVLB  3
03F4E:  MOVWF  xD1
03F50:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
03F52:  MOVLW  DC
03F54:  MOVLB  3
03F56:  MOVWF  xD2
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
03F58:  MOVFF  3CB,3D9
03F5C:  CLRF   xDA
03F5E:  CLRF   xDB
03F60:  CLRF   xDC
03F62:  MOVF   xD9,W
03F64:  MOVWF  00
03F66:  CLRF   01
03F68:  CLRF   02
03F6A:  CLRF   03
03F6C:  MOVFF  00,3D3
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03F70:  MOVFF  3CA,3D9
03F74:  MOVFF  3CB,3DA
03F78:  CLRF   xDB
03F7A:  CLRF   xDC
03F7C:  MOVF   xD9,W
03F7E:  MOVWF  00
03F80:  CLRF   01
03F82:  CLRF   02
03F84:  CLRF   03
03F86:  MOVFF  00,3D4
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03F8A:  MOVFF  3C9,3D9
03F8E:  MOVFF  3CA,3DA
03F92:  MOVFF  3CB,3DB
03F96:  CLRF   xDC
03F98:  MOVF   xD9,W
03F9A:  MOVWF  00
03F9C:  CLRF   01
03F9E:  CLRF   02
03FA0:  CLRF   03
03FA2:  MOVFF  00,3D5
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
03FA6:  MOVF   xC8,W
03FA8:  MOVWF  00
03FAA:  CLRF   01
03FAC:  CLRF   02
03FAE:  CLRF   03
03FB0:  MOVFF  00,3D6
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03FB4:  MOVFF  3C6,C71
03FB8:  MOVLB  C
03FBA:  CLRF   x72
03FBC:  MOVLW  0F
03FBE:  MOVWF  x74
03FC0:  MOVLW  89
03FC2:  MOVWF  x73
03FC4:  MOVLB  0
03FC6:  CALL   23AA
03FCA:  MOVFF  3C6,C71
03FCE:  MOVLB  C
03FD0:  CLRF   x72
03FD2:  MOVLW  0F
03FD4:  MOVWF  x74
03FD6:  MOVLW  92
03FD8:  MOVWF  x73
03FDA:  MOVLB  0
03FDC:  CALL   23AA
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03FE0:  MOVFF  3C7,C6E
03FE4:  MOVFF  3C6,C6D
03FE8:  MOVFF  3C5,C6C
03FEC:  MOVFF  3C4,C6B
03FF0:  MOVLW  03
03FF2:  MOVLB  C
03FF4:  MOVWF  x70
03FF6:  MOVLW  D1
03FF8:  MOVWF  x6F
03FFA:  CLRF   x72
03FFC:  MOVLW  01
03FFE:  MOVWF  x71
04000:  MOVLB  0
04002:  CALL   2E64
....................       output_high(flash_stream.cs_pin);
04006:  MOVFF  3C6,C71
0400A:  MOVLW  01
0400C:  MOVLB  C
0400E:  MOVWF  x72
04010:  MOVLW  0F
04012:  MOVWF  x74
04014:  MOVLW  89
04016:  MOVWF  x73
04018:  MOVLB  0
0401A:  CALL   23AA
0401E:  MOVFF  3C6,C71
04022:  MOVLB  C
04024:  CLRF   x72
04026:  MOVLW  0F
04028:  MOVWF  x74
0402A:  MOVLW  92
0402C:  MOVWF  x73
0402E:  MOVLB  0
04030:  CALL   23AA
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04034:  MOVFF  3C6,C71
04038:  MOVLB  C
0403A:  CLRF   x72
0403C:  MOVLW  0F
0403E:  MOVWF  x74
04040:  MOVLW  89
04042:  MOVWF  x73
04044:  MOVLB  0
04046:  CALL   23AA
0404A:  MOVFF  3C6,C71
0404E:  MOVLB  C
04050:  CLRF   x72
04052:  MOVLW  0F
04054:  MOVWF  x74
04056:  MOVLW  92
04058:  MOVWF  x73
0405A:  MOVLB  0
0405C:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04060:  MOVFF  3C7,C6E
04064:  MOVFF  3C6,C6D
04068:  MOVFF  3C5,C6C
0406C:  MOVFF  3C4,C6B
04070:  MOVLW  03
04072:  MOVLB  C
04074:  MOVWF  x70
04076:  MOVLW  D2
04078:  MOVWF  x6F
0407A:  CLRF   x72
0407C:  MOVLW  05
0407E:  MOVWF  x71
04080:  MOVLB  0
04082:  CALL   2E64
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04086:  MOVFF  3C6,C71
0408A:  MOVLW  01
0408C:  MOVLB  C
0408E:  MOVWF  x72
04090:  MOVLW  0F
04092:  MOVWF  x74
04094:  MOVLW  89
04096:  MOVWF  x73
04098:  MOVLB  0
0409A:  CALL   23AA
0409E:  MOVFF  3C6,C71
040A2:  MOVLB  C
040A4:  CLRF   x72
040A6:  MOVLW  0F
040A8:  MOVWF  x74
040AA:  MOVLW  92
040AC:  MOVWF  x73
040AE:  MOVLB  0
040B0:  CALL   23AA
....................    }
040B4:  GOTO   40B8
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
040B8:  MOVLB  3
040BA:  CLRF   xD7
040BC:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
040BE:  MOVFF  3C7,C6E
040C2:  MOVFF  3C6,C6D
040C6:  MOVFF  3C5,C6C
040CA:  MOVFF  3C4,C6B
040CE:  CALL   30D0
040D2:  MOVF   01,W
040D4:  ANDLW  01
040D6:  SUBLW  01
040D8:  BTFSS  FD8.2
040DA:  GOTO   412C
....................       if(timeout_counter > 10)
040DE:  MOVLB  3
040E0:  MOVF   xD7,W
040E2:  SUBLW  0A
040E4:  BTFSS  FD8.0
040E6:  BRA    40EE
040E8:  MOVLB  0
040EA:  GOTO   4100
040EE:  MOVLB  0
....................          delay_ms(200);
040F0:  MOVLW  C8
040F2:  MOVLB  C
040F4:  MOVWF  x6B
040F6:  MOVLB  0
040F8:  CALL   1B94
040FC:  GOTO   410C
....................       else
....................          delay_ms(10);   
04100:  MOVLW  0A
04102:  MOVLB  C
04104:  MOVWF  x6B
04106:  MOVLB  0
04108:  CALL   1B94
....................       
....................       if(timeout_counter > 100){
0410C:  MOVLB  3
0410E:  MOVF   xD7,W
04110:  SUBLW  64
04112:  BTFSS  FD8.0
04114:  BRA    411C
04116:  MOVLB  0
04118:  GOTO   4122
0411C:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
0411E:  GOTO   412C
....................       }  
....................       timeout_counter++;
04122:  MOVLB  3
04124:  INCF   xD7,F
04126:  MOVLB  0
04128:  GOTO   40BE
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
0412C:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
0438E:  MOVLB  3
04390:  MOVF   x86,F
04392:  BTFSC  FD8.2
04394:  BRA    439C
04396:  MOVLB  0
04398:  GOTO   44F4
0439C:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
0439E:  MOVLW  06
043A0:  MOVLB  3
043A2:  MOVWF  x8D
043A4:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
043A6:  MOVLW  20
043A8:  MOVLB  3
043AA:  MOVWF  x8E
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
043AC:  MOVFF  38B,39A
043B0:  MOVFF  38C,39B
043B4:  CLRF   x9C
043B6:  CLRF   x9D
043B8:  MOVF   x9A,W
043BA:  MOVWF  00
043BC:  CLRF   01
043BE:  CLRF   02
043C0:  CLRF   03
043C2:  MOVFF  00,38F
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
043C6:  MOVFF  38A,39A
043CA:  MOVFF  38B,39B
043CE:  MOVFF  38C,39C
043D2:  CLRF   x9D
043D4:  MOVF   x9A,W
043D6:  MOVWF  00
043D8:  CLRF   01
043DA:  CLRF   02
043DC:  CLRF   03
043DE:  MOVFF  00,390
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
043E2:  MOVF   x89,W
043E4:  MOVWF  00
043E6:  CLRF   01
043E8:  CLRF   02
043EA:  CLRF   03
043EC:  MOVFF  00,391
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
043F0:  MOVFF  387,C71
043F4:  MOVLB  C
043F6:  CLRF   x72
043F8:  MOVLW  0F
043FA:  MOVWF  x74
043FC:  MOVLW  89
043FE:  MOVWF  x73
04400:  MOVLB  0
04402:  CALL   23AA
04406:  MOVFF  387,C71
0440A:  MOVLB  C
0440C:  CLRF   x72
0440E:  MOVLW  0F
04410:  MOVWF  x74
04412:  MOVLW  92
04414:  MOVWF  x73
04416:  MOVLB  0
04418:  CALL   23AA
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0441C:  MOVFF  388,C6E
04420:  MOVFF  387,C6D
04424:  MOVFF  386,C6C
04428:  MOVFF  385,C6B
0442C:  MOVLW  03
0442E:  MOVLB  C
04430:  MOVWF  x70
04432:  MOVLW  8D
04434:  MOVWF  x6F
04436:  CLRF   x72
04438:  MOVLW  01
0443A:  MOVWF  x71
0443C:  MOVLB  0
0443E:  CALL   2E64
....................       output_high(flash_stream.cs_pin);
04442:  MOVFF  387,C71
04446:  MOVLW  01
04448:  MOVLB  C
0444A:  MOVWF  x72
0444C:  MOVLW  0F
0444E:  MOVWF  x74
04450:  MOVLW  89
04452:  MOVWF  x73
04454:  MOVLB  0
04456:  CALL   23AA
0445A:  MOVFF  387,C71
0445E:  MOVLB  C
04460:  CLRF   x72
04462:  MOVLW  0F
04464:  MOVWF  x74
04466:  MOVLW  92
04468:  MOVWF  x73
0446A:  MOVLB  0
0446C:  CALL   23AA
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04470:  MOVFF  387,C71
04474:  MOVLB  C
04476:  CLRF   x72
04478:  MOVLW  0F
0447A:  MOVWF  x74
0447C:  MOVLW  89
0447E:  MOVWF  x73
04480:  MOVLB  0
04482:  CALL   23AA
04486:  MOVFF  387,C71
0448A:  MOVLB  C
0448C:  CLRF   x72
0448E:  MOVLW  0F
04490:  MOVWF  x74
04492:  MOVLW  92
04494:  MOVWF  x73
04496:  MOVLB  0
04498:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
0449C:  MOVFF  388,C6E
044A0:  MOVFF  387,C6D
044A4:  MOVFF  386,C6C
044A8:  MOVFF  385,C6B
044AC:  MOVLW  03
044AE:  MOVLB  C
044B0:  MOVWF  x70
044B2:  MOVLW  8E
044B4:  MOVWF  x6F
044B6:  CLRF   x72
044B8:  MOVLW  04
044BA:  MOVWF  x71
044BC:  MOVLB  0
044BE:  CALL   2E64
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
044C2:  MOVFF  387,C71
044C6:  MOVLW  01
044C8:  MOVLB  C
044CA:  MOVWF  x72
044CC:  MOVLW  0F
044CE:  MOVWF  x74
044D0:  MOVLW  89
044D2:  MOVWF  x73
044D4:  MOVLB  0
044D6:  CALL   23AA
044DA:  MOVFF  387,C71
044DE:  MOVLB  C
044E0:  CLRF   x72
044E2:  MOVLW  0F
044E4:  MOVWF  x74
044E6:  MOVLW  92
044E8:  MOVWF  x73
044EA:  MOVLB  0
044EC:  CALL   23AA
....................    }
044F0:  GOTO   4674
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
044F4:  MOVLB  3
044F6:  DECFSZ x86,W
044F8:  BRA    44FE
044FA:  BRA    4504
044FC:  MOVLB  0
044FE:  MOVLB  0
04500:  GOTO   4674
04504:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04506:  MOVLW  06
04508:  MOVLB  3
0450A:  MOVWF  x92
0450C:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
0450E:  MOVLW  21
04510:  MOVLB  3
04512:  MOVWF  x93
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04514:  MOVFF  38C,39A
04518:  CLRF   x9B
0451A:  CLRF   x9C
0451C:  CLRF   x9D
0451E:  MOVF   x9A,W
04520:  MOVWF  00
04522:  CLRF   01
04524:  CLRF   02
04526:  CLRF   03
04528:  MOVFF  00,394
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0452C:  MOVFF  38B,39A
04530:  MOVFF  38C,39B
04534:  CLRF   x9C
04536:  CLRF   x9D
04538:  MOVF   x9A,W
0453A:  MOVWF  00
0453C:  CLRF   01
0453E:  CLRF   02
04540:  CLRF   03
04542:  MOVFF  00,395
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04546:  MOVFF  38A,39A
0454A:  MOVFF  38B,39B
0454E:  MOVFF  38C,39C
04552:  CLRF   x9D
04554:  MOVF   x9A,W
04556:  MOVWF  00
04558:  CLRF   01
0455A:  CLRF   02
0455C:  CLRF   03
0455E:  MOVFF  00,396
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04562:  MOVF   x89,W
04564:  MOVWF  00
04566:  CLRF   01
04568:  CLRF   02
0456A:  CLRF   03
0456C:  MOVFF  00,397
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04570:  MOVFF  387,C71
04574:  MOVLB  C
04576:  CLRF   x72
04578:  MOVLW  0F
0457A:  MOVWF  x74
0457C:  MOVLW  89
0457E:  MOVWF  x73
04580:  MOVLB  0
04582:  CALL   23AA
04586:  MOVFF  387,C71
0458A:  MOVLB  C
0458C:  CLRF   x72
0458E:  MOVLW  0F
04590:  MOVWF  x74
04592:  MOVLW  92
04594:  MOVWF  x73
04596:  MOVLB  0
04598:  CALL   23AA
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0459C:  MOVFF  388,C6E
045A0:  MOVFF  387,C6D
045A4:  MOVFF  386,C6C
045A8:  MOVFF  385,C6B
045AC:  MOVLW  03
045AE:  MOVLB  C
045B0:  MOVWF  x70
045B2:  MOVLW  92
045B4:  MOVWF  x6F
045B6:  CLRF   x72
045B8:  MOVLW  01
045BA:  MOVWF  x71
045BC:  MOVLB  0
045BE:  CALL   2E64
....................       output_high(flash_stream.cs_pin);
045C2:  MOVFF  387,C71
045C6:  MOVLW  01
045C8:  MOVLB  C
045CA:  MOVWF  x72
045CC:  MOVLW  0F
045CE:  MOVWF  x74
045D0:  MOVLW  89
045D2:  MOVWF  x73
045D4:  MOVLB  0
045D6:  CALL   23AA
045DA:  MOVFF  387,C71
045DE:  MOVLB  C
045E0:  CLRF   x72
045E2:  MOVLW  0F
045E4:  MOVWF  x74
045E6:  MOVLW  92
045E8:  MOVWF  x73
045EA:  MOVLB  0
045EC:  CALL   23AA
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
045F0:  MOVFF  387,C71
045F4:  MOVLB  C
045F6:  CLRF   x72
045F8:  MOVLW  0F
045FA:  MOVWF  x74
045FC:  MOVLW  89
045FE:  MOVWF  x73
04600:  MOVLB  0
04602:  CALL   23AA
04606:  MOVFF  387,C71
0460A:  MOVLB  C
0460C:  CLRF   x72
0460E:  MOVLW  0F
04610:  MOVWF  x74
04612:  MOVLW  92
04614:  MOVWF  x73
04616:  MOVLB  0
04618:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
0461C:  MOVFF  388,C6E
04620:  MOVFF  387,C6D
04624:  MOVFF  386,C6C
04628:  MOVFF  385,C6B
0462C:  MOVLW  03
0462E:  MOVLB  C
04630:  MOVWF  x70
04632:  MOVLW  93
04634:  MOVWF  x6F
04636:  CLRF   x72
04638:  MOVLW  05
0463A:  MOVWF  x71
0463C:  MOVLB  0
0463E:  CALL   2E64
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04642:  MOVFF  387,C71
04646:  MOVLW  01
04648:  MOVLB  C
0464A:  MOVWF  x72
0464C:  MOVLW  0F
0464E:  MOVWF  x74
04650:  MOVLW  89
04652:  MOVWF  x73
04654:  MOVLB  0
04656:  CALL   23AA
0465A:  MOVFF  387,C71
0465E:  MOVLB  C
04660:  CLRF   x72
04662:  MOVLW  0F
04664:  MOVWF  x74
04666:  MOVLW  92
04668:  MOVWF  x73
0466A:  MOVLB  0
0466C:  CALL   23AA
....................    }
04670:  GOTO   4674
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04674:  MOVLB  3
04676:  CLRF   x98
04678:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
0467A:  MOVFF  388,C6E
0467E:  MOVFF  387,C6D
04682:  MOVFF  386,C6C
04686:  MOVFF  385,C6B
0468A:  CALL   30D0
0468E:  MOVF   01,W
04690:  ANDLW  01
04692:  SUBLW  01
04694:  BTFSS  FD8.2
04696:  GOTO   46E8
....................       if(timeout_counter > 10)
0469A:  MOVLB  3
0469C:  MOVF   x98,W
0469E:  SUBLW  0A
046A0:  BTFSS  FD8.0
046A2:  BRA    46AA
046A4:  MOVLB  0
046A6:  GOTO   46BC
046AA:  MOVLB  0
....................          delay_ms(200);
046AC:  MOVLW  C8
046AE:  MOVLB  C
046B0:  MOVWF  x6B
046B2:  MOVLB  0
046B4:  CALL   1B94
046B8:  GOTO   46C8
....................       else
....................          delay_ms(10);   
046BC:  MOVLW  0A
046BE:  MOVLB  C
046C0:  MOVWF  x6B
046C2:  MOVLB  0
046C4:  CALL   1B94
....................       
....................       if(timeout_counter > 100){
046C8:  MOVLB  3
046CA:  MOVF   x98,W
046CC:  SUBLW  64
046CE:  BTFSS  FD8.0
046D0:  BRA    46D8
046D2:  MOVLB  0
046D4:  GOTO   46DE
046D8:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
046DA:  GOTO   46E8
....................       }  
....................       timeout_counter++;
046DE:  MOVLB  3
046E0:  INCF   x98,F
046E2:  MOVLB  0
046E4:  GOTO   467A
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
046E8:  GOTO   485E (RETURN)
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
027F2:  MOVLB  4
027F4:  MOVF   x8A,F
027F6:  BTFSC  FD8.2
027F8:  BRA    2800
027FA:  MOVLB  0
027FC:  GOTO   28F2
02800:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
02802:  MOVLW  03
02804:  MOVLB  4
02806:  MOVWF  x97
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
02808:  MOVFF  48F,4A1
0280C:  MOVFF  490,4A2
02810:  CLRF   xA3
02812:  CLRF   xA4
02814:  MOVF   xA1,W
02816:  MOVWF  00
02818:  CLRF   01
0281A:  CLRF   02
0281C:  CLRF   03
0281E:  MOVFF  00,498
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
02822:  MOVFF  48E,4A1
02826:  MOVFF  48F,4A2
0282A:  MOVFF  490,4A3
0282E:  CLRF   xA4
02830:  MOVF   xA1,W
02832:  MOVWF  00
02834:  CLRF   01
02836:  CLRF   02
02838:  CLRF   03
0283A:  MOVFF  00,499
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
0283E:  MOVF   x8D,W
02840:  MOVWF  00
02842:  CLRF   01
02844:  CLRF   02
02846:  CLRF   03
02848:  MOVFF  00,49A
....................             
....................       output_low(flash_stream.cs_pin);
0284C:  MOVFF  48B,C71
02850:  MOVLB  C
02852:  CLRF   x72
02854:  MOVLW  0F
02856:  MOVWF  x74
02858:  MOVLW  89
0285A:  MOVWF  x73
0285C:  MOVLB  0
0285E:  CALL   23AA
02862:  MOVFF  48B,C71
02866:  MOVLB  C
02868:  CLRF   x72
0286A:  MOVLW  0F
0286C:  MOVWF  x74
0286E:  MOVLW  92
02870:  MOVWF  x73
02872:  MOVLB  0
02874:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
02878:  MOVFF  48C,C74
0287C:  MOVFF  48B,C73
02880:  MOVFF  48A,C72
02884:  MOVFF  489,C71
02888:  MOVLW  04
0288A:  MOVLB  C
0288C:  MOVWF  x76
0288E:  MOVLW  97
02890:  MOVWF  x75
02892:  CLRF   x78
02894:  MOVLW  04
02896:  MOVWF  x77
02898:  MOVFF  492,C7A
0289C:  MOVFF  491,C79
028A0:  MOVFF  496,C7E
028A4:  MOVFF  495,C7D
028A8:  MOVFF  494,C7C
028AC:  MOVFF  493,C7B
028B0:  MOVLB  0
028B2:  CALL   24F6
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
028B6:  MOVLW  02
028B8:  MOVWF  00
028BA:  DECFSZ 00,F
028BC:  BRA    28BA
028BE:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
028C0:  MOVFF  48B,C71
028C4:  MOVLW  01
028C6:  MOVLB  C
028C8:  MOVWF  x72
028CA:  MOVLW  0F
028CC:  MOVWF  x74
028CE:  MOVLW  89
028D0:  MOVWF  x73
028D2:  MOVLB  0
028D4:  CALL   23AA
028D8:  MOVFF  48B,C71
028DC:  MOVLB  C
028DE:  CLRF   x72
028E0:  MOVLW  0F
028E2:  MOVWF  x74
028E4:  MOVLW  92
028E6:  MOVWF  x73
028E8:  MOVLB  0
028EA:  CALL   23AA
....................    }
028EE:  GOTO   2A08
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
028F2:  MOVLB  4
028F4:  DECFSZ x8A,W
028F6:  BRA    28FC
028F8:  BRA    2902
028FA:  MOVLB  0
028FC:  MOVLB  0
028FE:  GOTO   2A08
02902:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
02904:  MOVLW  13
02906:  MOVLB  4
02908:  MOVWF  x9B
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
0290A:  MOVFF  490,4A1
0290E:  CLRF   xA2
02910:  CLRF   xA3
02912:  CLRF   xA4
02914:  MOVF   xA1,W
02916:  MOVWF  00
02918:  CLRF   01
0291A:  CLRF   02
0291C:  CLRF   03
0291E:  MOVFF  00,49C
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
02922:  MOVFF  48F,4A1
02926:  MOVFF  490,4A2
0292A:  CLRF   xA3
0292C:  CLRF   xA4
0292E:  MOVF   xA1,W
02930:  MOVWF  00
02932:  CLRF   01
02934:  CLRF   02
02936:  CLRF   03
02938:  MOVFF  00,49D
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0293C:  MOVFF  48E,4A1
02940:  MOVFF  48F,4A2
02944:  MOVFF  490,4A3
02948:  CLRF   xA4
0294A:  MOVF   xA1,W
0294C:  MOVWF  00
0294E:  CLRF   01
02950:  CLRF   02
02952:  CLRF   03
02954:  MOVFF  00,49E
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02958:  MOVF   x8D,W
0295A:  MOVWF  00
0295C:  CLRF   01
0295E:  CLRF   02
02960:  CLRF   03
02962:  MOVFF  00,49F
....................    
....................       output_low(flash_stream.cs_pin);
02966:  MOVFF  48B,C71
0296A:  MOVLB  C
0296C:  CLRF   x72
0296E:  MOVLW  0F
02970:  MOVWF  x74
02972:  MOVLW  89
02974:  MOVWF  x73
02976:  MOVLB  0
02978:  CALL   23AA
0297C:  MOVFF  48B,C71
02980:  MOVLB  C
02982:  CLRF   x72
02984:  MOVLW  0F
02986:  MOVWF  x74
02988:  MOVLW  92
0298A:  MOVWF  x73
0298C:  MOVLB  0
0298E:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02992:  MOVFF  48C,C74
02996:  MOVFF  48B,C73
0299A:  MOVFF  48A,C72
0299E:  MOVFF  489,C71
029A2:  MOVLW  04
029A4:  MOVLB  C
029A6:  MOVWF  x76
029A8:  MOVLW  9B
029AA:  MOVWF  x75
029AC:  CLRF   x78
029AE:  MOVLW  05
029B0:  MOVWF  x77
029B2:  MOVFF  492,C7A
029B6:  MOVFF  491,C79
029BA:  MOVFF  496,C7E
029BE:  MOVFF  495,C7D
029C2:  MOVFF  494,C7C
029C6:  MOVFF  493,C7B
029CA:  MOVLB  0
029CC:  CALL   24F6
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029D0:  MOVLW  02
029D2:  MOVWF  00
029D4:  DECFSZ 00,F
029D6:  BRA    29D4
029D8:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029DA:  MOVFF  48B,C71
029DE:  MOVLW  01
029E0:  MOVLB  C
029E2:  MOVWF  x72
029E4:  MOVLW  0F
029E6:  MOVWF  x74
029E8:  MOVLW  89
029EA:  MOVWF  x73
029EC:  MOVLB  0
029EE:  CALL   23AA
029F2:  MOVFF  48B,C71
029F6:  MOVLB  C
029F8:  CLRF   x72
029FA:  MOVLW  0F
029FC:  MOVWF  x74
029FE:  MOVLW  92
02A00:  MOVWF  x73
02A02:  MOVLB  0
02A04:  CALL   23AA
....................    }
....................    return;
02A08:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
03170:  MOVLB  C
03172:  MOVF   x54,F
03174:  BTFSC  FD8.2
03176:  BRA    317E
03178:  MOVLB  0
0317A:  GOTO   32EC
0317E:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
03180:  MOVLW  06
03182:  MOVLB  C
03184:  MOVWF  x5F
03186:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
03188:  MOVLW  02
0318A:  MOVLB  C
0318C:  MOVWF  x60
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0318E:  MOVFF  C59,C6C
03192:  MOVFF  C5A,C6D
03196:  CLRF   x6E
03198:  CLRF   x6F
0319A:  MOVF   x6C,W
0319C:  MOVWF  00
0319E:  CLRF   01
031A0:  CLRF   02
031A2:  CLRF   03
031A4:  MOVFF  00,C61
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
031A8:  MOVFF  C58,C6C
031AC:  MOVFF  C59,C6D
031B0:  MOVFF  C5A,C6E
031B4:  CLRF   x6F
031B6:  MOVF   x6C,W
031B8:  MOVWF  00
031BA:  CLRF   01
031BC:  CLRF   02
031BE:  CLRF   03
031C0:  MOVFF  00,C62
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
031C4:  MOVF   x57,W
031C6:  MOVWF  00
031C8:  CLRF   01
031CA:  CLRF   02
031CC:  CLRF   03
031CE:  MOVFF  00,C63
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
031D2:  MOVFF  C55,C71
031D6:  CLRF   x72
031D8:  MOVLW  0F
031DA:  MOVWF  x74
031DC:  MOVLW  89
031DE:  MOVWF  x73
031E0:  MOVLB  0
031E2:  CALL   23AA
031E6:  MOVFF  C55,C71
031EA:  MOVLB  C
031EC:  CLRF   x72
031EE:  MOVLW  0F
031F0:  MOVWF  x74
031F2:  MOVLW  92
031F4:  MOVWF  x73
031F6:  MOVLB  0
031F8:  CALL   23AA
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
031FC:  MOVFF  C56,C6E
03200:  MOVFF  C55,C6D
03204:  MOVFF  C54,C6C
03208:  MOVFF  C53,C6B
0320C:  MOVLW  0C
0320E:  MOVLB  C
03210:  MOVWF  x70
03212:  MOVLW  5F
03214:  MOVWF  x6F
03216:  CLRF   x72
03218:  MOVLW  01
0321A:  MOVWF  x71
0321C:  MOVLB  0
0321E:  CALL   2E64
....................       output_high(flash_stream.cs_pin);
03222:  MOVFF  C55,C71
03226:  MOVLW  01
03228:  MOVLB  C
0322A:  MOVWF  x72
0322C:  MOVLW  0F
0322E:  MOVWF  x74
03230:  MOVLW  89
03232:  MOVWF  x73
03234:  MOVLB  0
03236:  CALL   23AA
0323A:  MOVFF  C55,C71
0323E:  MOVLB  C
03240:  CLRF   x72
03242:  MOVLW  0F
03244:  MOVWF  x74
03246:  MOVLW  92
03248:  MOVWF  x73
0324A:  MOVLB  0
0324C:  CALL   23AA
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03250:  MOVFF  C55,C71
03254:  MOVLB  C
03256:  CLRF   x72
03258:  MOVLW  0F
0325A:  MOVWF  x74
0325C:  MOVLW  89
0325E:  MOVWF  x73
03260:  MOVLB  0
03262:  CALL   23AA
03266:  MOVFF  C55,C71
0326A:  MOVLB  C
0326C:  CLRF   x72
0326E:  MOVLW  0F
03270:  MOVWF  x74
03272:  MOVLW  92
03274:  MOVWF  x73
03276:  MOVLB  0
03278:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
0327C:  MOVFF  C56,C6E
03280:  MOVFF  C55,C6D
03284:  MOVFF  C54,C6C
03288:  MOVFF  C53,C6B
0328C:  MOVLW  0C
0328E:  MOVLB  C
03290:  MOVWF  x70
03292:  MOVLW  60
03294:  MOVWF  x6F
03296:  MOVLW  04
03298:  MOVWF  x71
0329A:  MOVFF  C5C,C73
0329E:  MOVFF  C5B,C72
032A2:  MOVFF  C5E,C75
032A6:  MOVFF  C5D,C74
032AA:  MOVLB  0
032AC:  CALL   2F54
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
032B0:  MOVLW  02
032B2:  MOVWF  00
032B4:  DECFSZ 00,F
032B6:  BRA    32B4
032B8:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
032BA:  MOVFF  C55,C71
032BE:  MOVLW  01
032C0:  MOVLB  C
032C2:  MOVWF  x72
032C4:  MOVLW  0F
032C6:  MOVWF  x74
032C8:  MOVLW  89
032CA:  MOVWF  x73
032CC:  MOVLB  0
032CE:  CALL   23AA
032D2:  MOVFF  C55,C71
032D6:  MOVLB  C
032D8:  CLRF   x72
032DA:  MOVLW  0F
032DC:  MOVWF  x74
032DE:  MOVLW  92
032E0:  MOVWF  x73
032E2:  MOVLB  0
032E4:  CALL   23AA
....................    }
032E8:  GOTO   347E
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
032EC:  MOVLB  C
032EE:  DECFSZ x54,W
032F0:  BRA    32F6
032F2:  BRA    32FC
032F4:  MOVLB  0
032F6:  MOVLB  0
032F8:  GOTO   347E
032FC:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
032FE:  MOVLW  06
03300:  MOVLB  C
03302:  MOVWF  x64
03304:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
03306:  MOVLW  12
03308:  MOVLB  C
0330A:  MOVWF  x65
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
0330C:  MOVFF  C5A,C6C
03310:  CLRF   x6D
03312:  CLRF   x6E
03314:  CLRF   x6F
03316:  MOVF   x6C,W
03318:  MOVWF  00
0331A:  CLRF   01
0331C:  CLRF   02
0331E:  CLRF   03
03320:  MOVFF  00,C66
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03324:  MOVFF  C59,C6C
03328:  MOVFF  C5A,C6D
0332C:  CLRF   x6E
0332E:  CLRF   x6F
03330:  MOVF   x6C,W
03332:  MOVWF  00
03334:  CLRF   01
03336:  CLRF   02
03338:  CLRF   03
0333A:  MOVFF  00,C67
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0333E:  MOVFF  C58,C6C
03342:  MOVFF  C59,C6D
03346:  MOVFF  C5A,C6E
0334A:  CLRF   x6F
0334C:  MOVF   x6C,W
0334E:  MOVWF  00
03350:  CLRF   01
03352:  CLRF   02
03354:  CLRF   03
03356:  MOVFF  00,C68
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
0335A:  MOVF   x57,W
0335C:  MOVWF  00
0335E:  CLRF   01
03360:  CLRF   02
03362:  CLRF   03
03364:  MOVFF  00,C69
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03368:  MOVFF  C55,C71
0336C:  CLRF   x72
0336E:  MOVLW  0F
03370:  MOVWF  x74
03372:  MOVLW  89
03374:  MOVWF  x73
03376:  MOVLB  0
03378:  CALL   23AA
0337C:  MOVFF  C55,C71
03380:  MOVLB  C
03382:  CLRF   x72
03384:  MOVLW  0F
03386:  MOVWF  x74
03388:  MOVLW  92
0338A:  MOVWF  x73
0338C:  MOVLB  0
0338E:  CALL   23AA
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03392:  MOVFF  C56,C6E
03396:  MOVFF  C55,C6D
0339A:  MOVFF  C54,C6C
0339E:  MOVFF  C53,C6B
033A2:  MOVLW  0C
033A4:  MOVLB  C
033A6:  MOVWF  x70
033A8:  MOVLW  64
033AA:  MOVWF  x6F
033AC:  CLRF   x72
033AE:  MOVLW  01
033B0:  MOVWF  x71
033B2:  MOVLB  0
033B4:  CALL   2E64
....................       output_high(flash_stream.cs_pin);
033B8:  MOVFF  C55,C71
033BC:  MOVLW  01
033BE:  MOVLB  C
033C0:  MOVWF  x72
033C2:  MOVLW  0F
033C4:  MOVWF  x74
033C6:  MOVLW  89
033C8:  MOVWF  x73
033CA:  MOVLB  0
033CC:  CALL   23AA
033D0:  MOVFF  C55,C71
033D4:  MOVLB  C
033D6:  CLRF   x72
033D8:  MOVLW  0F
033DA:  MOVWF  x74
033DC:  MOVLW  92
033DE:  MOVWF  x73
033E0:  MOVLB  0
033E2:  CALL   23AA
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
033E6:  MOVFF  C55,C71
033EA:  MOVLB  C
033EC:  CLRF   x72
033EE:  MOVLW  0F
033F0:  MOVWF  x74
033F2:  MOVLW  89
033F4:  MOVWF  x73
033F6:  MOVLB  0
033F8:  CALL   23AA
033FC:  MOVFF  C55,C71
03400:  MOVLB  C
03402:  CLRF   x72
03404:  MOVLW  0F
03406:  MOVWF  x74
03408:  MOVLW  92
0340A:  MOVWF  x73
0340C:  MOVLB  0
0340E:  CALL   23AA
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
03412:  MOVFF  C56,C6E
03416:  MOVFF  C55,C6D
0341A:  MOVFF  C54,C6C
0341E:  MOVFF  C53,C6B
03422:  MOVLW  0C
03424:  MOVLB  C
03426:  MOVWF  x70
03428:  MOVLW  65
0342A:  MOVWF  x6F
0342C:  MOVLW  05
0342E:  MOVWF  x71
03430:  MOVFF  C5C,C73
03434:  MOVFF  C5B,C72
03438:  MOVFF  C5E,C75
0343C:  MOVFF  C5D,C74
03440:  MOVLB  0
03442:  CALL   2F54
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
03446:  MOVLW  02
03448:  MOVWF  00
0344A:  DECFSZ 00,F
0344C:  BRA    344A
0344E:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03450:  MOVFF  C55,C71
03454:  MOVLW  01
03456:  MOVLB  C
03458:  MOVWF  x72
0345A:  MOVLW  0F
0345C:  MOVWF  x74
0345E:  MOVLW  89
03460:  MOVWF  x73
03462:  MOVLB  0
03464:  CALL   23AA
03468:  MOVFF  C55,C71
0346C:  MOVLB  C
0346E:  CLRF   x72
03470:  MOVLW  0F
03472:  MOVWF  x74
03474:  MOVLW  92
03476:  MOVWF  x73
03478:  MOVLB  0
0347A:  CALL   23AA
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
0347E:  MOVLB  C
03480:  CLRF   x6A
03482:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
03484:  MOVFF  C56,C6E
03488:  MOVFF  C55,C6D
0348C:  MOVFF  C54,C6C
03490:  MOVFF  C53,C6B
03494:  CALL   30D0
03498:  MOVF   01,W
0349A:  ANDLW  01
0349C:  SUBLW  01
0349E:  BTFSS  FD8.2
034A0:  GOTO   34F2
....................       if(timeout_counter > 10)
034A4:  MOVLB  C
034A6:  MOVF   x6A,W
034A8:  SUBLW  0A
034AA:  BTFSS  FD8.0
034AC:  BRA    34B4
034AE:  MOVLB  0
034B0:  GOTO   34C6
034B4:  MOVLB  0
....................          delay_ms(200);
034B6:  MOVLW  C8
034B8:  MOVLB  C
034BA:  MOVWF  x6B
034BC:  MOVLB  0
034BE:  CALL   1B94
034C2:  GOTO   34D2
....................       else
....................          delay_ms(10);   
034C6:  MOVLW  0A
034C8:  MOVLB  C
034CA:  MOVWF  x6B
034CC:  MOVLB  0
034CE:  CALL   1B94
....................       
....................       if(timeout_counter > 100){
034D2:  MOVLB  C
034D4:  MOVF   x6A,W
034D6:  SUBLW  64
034D8:  BTFSS  FD8.0
034DA:  BRA    34E2
034DC:  MOVLB  0
034DE:  GOTO   34E8
034E2:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
034E4:  GOTO   34F2
....................       }  
....................       timeout_counter++;
034E8:  MOVLB  C
034EA:  INCF   x6A,F
034EC:  MOVLB  0
034EE:  GOTO   3484
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
034F2:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
0272A:  MOVLW  9F
0272C:  MOVLB  4
0272E:  MOVWF  x45
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
02730:  MOVFF  42F,C71
02734:  MOVLB  C
02736:  CLRF   x72
02738:  MOVLW  0F
0273A:  MOVWF  x74
0273C:  MOVLW  89
0273E:  MOVWF  x73
02740:  MOVLB  0
02742:  CALL   23AA
02746:  MOVFF  42F,C71
0274A:  MOVLB  C
0274C:  CLRF   x72
0274E:  MOVLW  0F
02750:  MOVWF  x74
02752:  MOVLW  92
02754:  MOVWF  x73
02756:  MOVLB  0
02758:  CALL   23AA
....................    delay_us(10);  
0275C:  MOVLW  0D
0275E:  MOVWF  00
02760:  DECFSZ 00,F
02762:  BRA    2760
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
02764:  MOVFF  430,C74
02768:  MOVFF  42F,C73
0276C:  MOVFF  42E,C72
02770:  MOVFF  42D,C71
02774:  MOVLW  04
02776:  MOVLB  C
02778:  MOVWF  x76
0277A:  MOVLW  45
0277C:  MOVWF  x75
0277E:  CLRF   x78
02780:  MOVLW  01
02782:  MOVWF  x77
02784:  MOVLW  04
02786:  MOVWF  x7A
02788:  MOVLW  31
0278A:  MOVWF  x79
0278C:  CLRF   x7E
0278E:  CLRF   x7D
02790:  CLRF   x7C
02792:  MOVLW  14
02794:  MOVWF  x7B
02796:  MOVLB  0
02798:  CALL   24F6
....................    output_high(flash_stream.cs_pin);
0279C:  MOVFF  42F,C71
027A0:  MOVLW  01
027A2:  MOVLB  C
027A4:  MOVWF  x72
027A6:  MOVLW  0F
027A8:  MOVWF  x74
027AA:  MOVLW  89
027AC:  MOVWF  x73
027AE:  MOVLB  0
027B0:  CALL   23AA
027B4:  MOVFF  42F,C71
027B8:  MOVLB  C
027BA:  CLRF   x72
027BC:  MOVLW  0F
027BE:  MOVWF  x74
027C0:  MOVLW  92
027C2:  MOVWF  x73
027C4:  MOVLB  0
027C6:  CALL   23AA
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
027CA:  MOVLB  4
027CC:  MOVF   x31,W
027CE:  SUBLW  20
027D0:  BTFSC  FD8.2
027D2:  BRA    27DA
027D4:  MOVLB  0
027D6:  GOTO   27E8
027DA:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
027DC:  MOVLW  01
027DE:  MOVWF  01
027E0:  GOTO   27F0
....................    }
027E4:  GOTO   27F0
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
027E8:  MOVLW  00
027EA:  MOVWF  01
027EC:  GOTO   27F0
....................    }
027F0:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
02A40:  MOVLB  C
02A42:  MOVF   x55,F
02A44:  BTFSC  FD8.2
02A46:  BRA    2A4E
02A48:  MOVLB  0
02A4A:  GOTO   2A58
02A4E:  MOVLB  0
02A50:  MOVLW  00
02A52:  MOVWF  01
02A54:  GOTO   2AAA
.................... 
....................    unsigned int8 crc = *frame++;
02A58:  MOVLB  C
02A5A:  MOVF   x54,W
02A5C:  MOVWF  03
02A5E:  MOVF   x53,W
02A60:  INCF   x53,F
02A62:  BTFSC  FD8.2
02A64:  INCF   x54,F
02A66:  MOVWF  FE9
02A68:  MOVFF  03,FEA
02A6C:  MOVFF  FEF,C56
02A70:  MOVLB  0
....................    while (--payload_size > 0)
02A72:  MOVLB  C
02A74:  DECF   x55,F
02A76:  MOVF   x55,F
02A78:  BTFSS  FD8.2
02A7A:  BRA    2A82
02A7C:  MOVLB  0
02A7E:  GOTO   2AA2
02A82:  MOVLB  0
....................       crc ^= *frame++;
02A84:  MOVLB  C
02A86:  MOVF   x54,W
02A88:  MOVWF  03
02A8A:  MOVF   x53,W
02A8C:  INCF   x53,F
02A8E:  BTFSC  FD8.2
02A90:  INCF   x54,F
02A92:  MOVWF  FE9
02A94:  MOVFF  03,FEA
02A98:  MOVF   FEF,W
02A9A:  XORWF  x56,F
02A9C:  MOVLB  0
02A9E:  GOTO   2A72
.................... 
....................    return crc;
02AA2:  MOVLB  C
02AA4:  MOVF   x56,W
02AA6:  MOVWF  01
02AA8:  MOVLB  0
02AAA:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... 
.................... #include "../../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_MEASURE_DATA_START_ADDRESS 0x06AA1000
.................... #define CIGS_MEASURE_DATA_END_ADDRESS 0x07AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x07AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x07AA1FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
*
07EE8:  MOVLW  01
07EEA:  MOVLB  1
07EEC:  ADDWF  xAD,W
07EEE:  ANDLW  0F
07EF0:  MOVLB  3
07EF2:  MOVWF  xA8
.................... {   
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
.................... 
....................    if(next_tail == flash_queue.head_index)
07EF4:  MOVLB  1
07EF6:  MOVF   xAC,W
07EF8:  MOVLB  3
07EFA:  SUBWF  xA8,W
07EFC:  BTFSC  FD8.2
07EFE:  BRA    7F06
07F00:  MOVLB  0
07F02:  GOTO   7F1C
07F06:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
07F08:  MOVLW  8A
07F0A:  MOVWF  FF6
07F0C:  MOVLW  02
07F0E:  MOVWF  FF7
07F10:  MOVLW  00
07F12:  MOVWF  FF8
07F14:  CALL   1C14
07F18:  GOTO   8320
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
07F1C:  MOVLB  3
07F1E:  CLRF   xAA
07F20:  MOVFF  1AD,3A9
07F24:  CLRF   xAC
07F26:  MOVLW  16
07F28:  MOVWF  xAB
07F2A:  MOVLB  0
07F2C:  CALL   7EC6
07F30:  MOVFF  02,3AA
07F34:  MOVFF  01,3A9
07F38:  MOVLW  4C
07F3A:  MOVLB  3
07F3C:  ADDWF  xA9,W
07F3E:  MOVWF  01
07F40:  MOVLW  00
07F42:  ADDWFC xAA,W
07F44:  MOVWF  03
07F46:  MOVF   01,W
07F48:  MOVWF  xAB
07F4A:  MOVFF  03,3AC
07F4E:  MOVF   xA6,W
07F50:  MOVWF  FE9
07F52:  MOVF   xA7,W
07F54:  MOVWF  FEA
07F56:  MOVF   FEF,W
07F58:  MOVWF  xAD
07F5A:  MOVFF  3AC,FEA
07F5E:  MOVFF  3AB,FE9
07F62:  MOVFF  3AD,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
07F66:  CLRF   xAA
07F68:  MOVFF  1AD,3A9
07F6C:  CLRF   xAC
07F6E:  MOVLW  16
07F70:  MOVWF  xAB
07F72:  MOVLB  0
07F74:  CALL   7EC6
07F78:  MOVFF  02,3AA
07F7C:  MOVFF  01,3A9
07F80:  MOVLW  09
07F82:  MOVLB  3
07F84:  ADDWF  xA9,W
07F86:  MOVWF  01
07F88:  MOVLW  00
07F8A:  ADDWFC xAA,W
07F8C:  MOVWF  03
07F8E:  MOVF   01,W
07F90:  ADDLW  4C
07F92:  MOVWF  01
07F94:  MOVLW  00
07F96:  ADDWFC 03,F
07F98:  MOVF   01,W
07F9A:  MOVWF  xA9
07F9C:  MOVFF  03,3AA
07FA0:  MOVLW  09
07FA2:  ADDWF  xA6,W
07FA4:  MOVWF  FE9
07FA6:  MOVLW  00
07FA8:  ADDWFC xA7,W
07FAA:  MOVWF  FEA
07FAC:  MOVF   FEF,W
07FAE:  MOVWF  xAB
07FB0:  MOVFF  3AA,FEA
07FB4:  MOVFF  3A9,FE9
07FB8:  MOVFF  3AB,FEF
....................       flash_queue.entries[flash_queue.tail_index].src        = data->src;
07FBC:  CLRF   xAA
07FBE:  MOVFF  1AD,3A9
07FC2:  CLRF   xAC
07FC4:  MOVLW  16
07FC6:  MOVWF  xAB
07FC8:  MOVLB  0
07FCA:  CALL   7EC6
07FCE:  MOVFF  02,3AA
07FD2:  MOVFF  01,3A9
07FD6:  MOVLW  01
07FD8:  MOVLB  3
07FDA:  ADDWF  xA9,W
07FDC:  MOVWF  01
07FDE:  MOVLW  00
07FE0:  ADDWFC xAA,W
07FE2:  MOVWF  03
07FE4:  MOVF   01,W
07FE6:  ADDLW  4C
07FE8:  MOVWF  01
07FEA:  MOVLW  00
07FEC:  ADDWFC 03,F
07FEE:  MOVF   01,W
07FF0:  MOVWF  xA9
07FF2:  MOVFF  03,3AA
07FF6:  MOVLW  01
07FF8:  ADDWF  xA6,W
07FFA:  MOVWF  FE9
07FFC:  MOVLW  00
07FFE:  ADDWFC xA7,W
08000:  MOVWF  FEA
08002:  MOVFF  FEF,00
08006:  MOVFF  FEC,01
0800A:  MOVFF  FEC,02
0800E:  MOVFF  FEC,03
08012:  MOVF   FED,F
08014:  MOVF   FED,F
08016:  MOVF   FED,F
08018:  MOVFF  03,3AE
0801C:  MOVFF  02,3AD
08020:  MOVFF  01,3AC
08024:  MOVFF  00,3AB
08028:  MOVFF  3AA,FEA
0802C:  MOVFF  3A9,FE9
08030:  MOVFF  3AB,FEF
08034:  MOVFF  3AC,FEC
08038:  MOVFF  3AD,FEC
0803C:  MOVFF  3AE,FEC
08040:  MOVF   FED,F
08042:  MOVF   FED,F
08044:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].size       = data->size;
08046:  CLRF   xAA
08048:  MOVFF  1AD,3A9
0804C:  CLRF   xAC
0804E:  MOVLW  16
08050:  MOVWF  xAB
08052:  MOVLB  0
08054:  CALL   7EC6
08058:  MOVFF  02,3AA
0805C:  MOVFF  01,3A9
08060:  MOVLW  05
08062:  MOVLB  3
08064:  ADDWF  xA9,W
08066:  MOVWF  01
08068:  MOVLW  00
0806A:  ADDWFC xAA,W
0806C:  MOVWF  03
0806E:  MOVF   01,W
08070:  ADDLW  4C
08072:  MOVWF  01
08074:  MOVLW  00
08076:  ADDWFC 03,F
08078:  MOVF   01,W
0807A:  MOVWF  xA9
0807C:  MOVFF  03,3AA
08080:  MOVLW  05
08082:  ADDWF  xA6,W
08084:  MOVWF  FE9
08086:  MOVLW  00
08088:  ADDWFC xA7,W
0808A:  MOVWF  FEA
0808C:  MOVFF  FEF,00
08090:  MOVFF  FEC,01
08094:  MOVFF  FEC,02
08098:  MOVFF  FEC,03
0809C:  MOVF   FED,F
0809E:  MOVF   FED,F
080A0:  MOVF   FED,F
080A2:  MOVFF  03,3AE
080A6:  MOVFF  02,3AD
080AA:  MOVFF  01,3AC
080AE:  MOVFF  00,3AB
080B2:  MOVFF  3AA,FEA
080B6:  MOVFF  3A9,FE9
080BA:  MOVFF  3AB,FEF
080BE:  MOVFF  3AC,FEC
080C2:  MOVFF  3AD,FEC
080C6:  MOVFF  3AE,FEC
080CA:  MOVF   FED,F
080CC:  MOVF   FED,F
080CE:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
080D0:  CLRF   xAA
080D2:  MOVFF  1AD,3A9
080D6:  CLRF   xAC
080D8:  MOVLW  16
080DA:  MOVWF  xAB
080DC:  MOVLB  0
080DE:  CALL   7EC6
080E2:  MOVFF  02,3AA
080E6:  MOVFF  01,3A9
080EA:  MOVLW  0A
080EC:  MOVLB  3
080EE:  ADDWF  xA9,W
080F0:  MOVWF  01
080F2:  MOVLW  00
080F4:  ADDWFC xAA,W
080F6:  MOVWF  03
080F8:  MOVF   01,W
080FA:  ADDLW  4C
080FC:  MOVWF  01
080FE:  MOVLW  00
08100:  ADDWFC 03,F
08102:  MOVF   01,W
08104:  MOVWF  xA9
08106:  MOVFF  03,3AA
0810A:  MOVLW  0A
0810C:  ADDWF  xA6,W
0810E:  MOVWF  FE9
08110:  MOVLW  00
08112:  ADDWFC xA7,W
08114:  MOVWF  FEA
08116:  MOVF   FEF,W
08118:  MOVWF  xAB
0811A:  MOVFF  3AA,FEA
0811E:  MOVFF  3A9,FE9
08122:  MOVFF  3AB,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
08126:  CLRF   xAA
08128:  MOVFF  1AD,3A9
0812C:  CLRF   xAC
0812E:  MOVLW  16
08130:  MOVWF  xAB
08132:  MOVLB  0
08134:  CALL   7EC6
08138:  MOVFF  02,3AA
0813C:  MOVFF  01,3A9
08140:  MOVLW  0B
08142:  MOVLB  3
08144:  ADDWF  xA9,W
08146:  MOVWF  01
08148:  MOVLW  00
0814A:  ADDWFC xAA,W
0814C:  MOVWF  03
0814E:  MOVF   01,W
08150:  ADDLW  4C
08152:  MOVWF  01
08154:  MOVLW  00
08156:  ADDWFC 03,F
08158:  MOVF   01,W
0815A:  MOVWF  xA9
0815C:  MOVFF  03,3AA
08160:  MOVLW  0B
08162:  ADDWF  xA6,W
08164:  MOVWF  01
08166:  MOVLW  00
08168:  ADDWFC xA7,W
0816A:  MOVWF  03
0816C:  MOVF   01,W
0816E:  MOVWF  FE9
08170:  MOVFF  03,FEA
08174:  MOVLW  00
08176:  BTFSC  FEF.0
08178:  MOVLW  01
0817A:  MOVWF  01
0817C:  BTFSS  01.0
0817E:  BRA    8186
08180:  MOVLB  0
08182:  GOTO   8196
08186:  MOVLB  0
08188:  MOVFF  3AA,FEA
0818C:  MOVFF  3A9,FE9
08190:  BCF    FEF.0
08192:  GOTO   81A0
08196:  MOVFF  3AA,FEA
0819A:  MOVFF  3A9,FE9
0819E:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
081A0:  MOVLB  3
081A2:  CLRF   xAA
081A4:  MOVFF  1AD,3A9
081A8:  CLRF   xAC
081AA:  MOVLW  16
081AC:  MOVWF  xAB
081AE:  MOVLB  0
081B0:  CALL   7EC6
081B4:  MOVFF  02,3AA
081B8:  MOVFF  01,3A9
081BC:  MOVLW  0C
081BE:  MOVLB  3
081C0:  ADDWF  xA9,W
081C2:  MOVWF  01
081C4:  MOVLW  00
081C6:  ADDWFC xAA,W
081C8:  MOVWF  03
081CA:  MOVF   01,W
081CC:  ADDLW  4C
081CE:  MOVWF  01
081D0:  MOVLW  00
081D2:  ADDWFC 03,F
081D4:  MOVF   01,W
081D6:  MOVWF  xA9
081D8:  MOVFF  03,3AA
081DC:  MOVLW  0C
081DE:  ADDWF  xA6,W
081E0:  MOVWF  FE9
081E2:  MOVLW  00
081E4:  ADDWFC xA7,W
081E6:  MOVWF  FEA
081E8:  MOVFF  FEF,00
081EC:  MOVFF  FEC,01
081F0:  MOVFF  FEC,02
081F4:  MOVFF  FEC,03
081F8:  MOVF   FED,F
081FA:  MOVF   FED,F
081FC:  MOVF   FED,F
081FE:  MOVFF  03,3AE
08202:  MOVFF  02,3AD
08206:  MOVFF  01,3AC
0820A:  MOVFF  00,3AB
0820E:  MOVFF  3AA,FEA
08212:  MOVFF  3A9,FE9
08216:  MOVFF  3AB,FEF
0821A:  MOVFF  3AC,FEC
0821E:  MOVFF  3AD,FEC
08222:  MOVFF  3AE,FEC
08226:  MOVF   FED,F
08228:  MOVF   FED,F
0822A:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
0822C:  CLRF   xAA
0822E:  MOVFF  1AD,3A9
08232:  CLRF   xAC
08234:  MOVLW  16
08236:  MOVWF  xAB
08238:  MOVLB  0
0823A:  CALL   7EC6
0823E:  MOVFF  02,3AA
08242:  MOVFF  01,3A9
08246:  MOVLW  10
08248:  MOVLB  3
0824A:  ADDWF  xA9,W
0824C:  MOVWF  01
0824E:  MOVLW  00
08250:  ADDWFC xAA,W
08252:  MOVWF  03
08254:  MOVF   01,W
08256:  ADDLW  4C
08258:  MOVWF  01
0825A:  MOVLW  00
0825C:  ADDWFC 03,F
0825E:  MOVF   01,W
08260:  MOVWF  xA9
08262:  MOVFF  03,3AA
08266:  MOVLW  10
08268:  ADDWF  xA6,W
0826A:  MOVWF  FE9
0826C:  MOVLW  00
0826E:  ADDWFC xA7,W
08270:  MOVWF  FEA
08272:  MOVFF  FEF,00
08276:  MOVFF  FEC,01
0827A:  MOVFF  FEC,02
0827E:  MOVFF  FEC,03
08282:  MOVF   FED,F
08284:  MOVF   FED,F
08286:  MOVF   FED,F
08288:  MOVFF  03,3AE
0828C:  MOVFF  02,3AD
08290:  MOVFF  01,3AC
08294:  MOVFF  00,3AB
08298:  MOVFF  3AA,FEA
0829C:  MOVFF  3A9,FE9
082A0:  MOVFF  3AB,FEF
082A4:  MOVFF  3AC,FEC
082A8:  MOVFF  3AD,FEC
082AC:  MOVFF  3AE,FEC
082B0:  MOVF   FED,F
082B2:  MOVF   FED,F
082B4:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].manager = data->manager;
082B6:  CLRF   xAA
082B8:  MOVFF  1AD,3A9
082BC:  CLRF   xAC
082BE:  MOVLW  16
082C0:  MOVWF  xAB
082C2:  MOVLB  0
082C4:  CALL   7EC6
082C8:  MOVFF  02,3AA
082CC:  MOVFF  01,3A9
082D0:  MOVLW  14
082D2:  MOVLB  3
082D4:  ADDWF  xA9,W
082D6:  MOVWF  01
082D8:  MOVLW  00
082DA:  ADDWFC xAA,W
082DC:  MOVWF  03
082DE:  MOVF   01,W
082E0:  ADDLW  4C
082E2:  MOVWF  01
082E4:  MOVLW  00
082E6:  ADDWFC 03,F
082E8:  MOVF   01,W
082EA:  MOVWF  xA9
082EC:  MOVFF  03,3AA
082F0:  MOVLW  14
082F2:  ADDWF  xA6,W
082F4:  MOVWF  FE9
082F6:  MOVLW  00
082F8:  ADDWFC xA7,W
082FA:  MOVWF  FEA
082FC:  MOVFF  FEC,03
08300:  MOVF   FED,F
08302:  MOVF   FEF,W
08304:  MOVWF  xAB
08306:  MOVFF  03,3AC
0830A:  MOVFF  3AA,FEA
0830E:  MOVFF  3A9,FE9
08312:  MOVFF  3AC,FEC
08316:  MOVF   FED,F
08318:  MOVFF  3AB,FEF
.................... 
....................       flash_queue.tail_index = next_tail;
0831C:  MOVFF  3A8,1AD
08320:  MOVLB  0
....................    }
08322:  GOTO   86D0 (RETURN)
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
....................    {
....................       printf("Flash queue is empty\r\n");
....................       return 0x00;
....................    }
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
....................       return &flash_queue.entries[current_head];
....................    }
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
08946:  MOVLB  1
08948:  MOVF   xAD,W
0894A:  SUBWF  xAC,W
0894C:  BTFSS  FD8.2
0894E:  BRA    8956
08950:  MOVLB  0
08952:  GOTO   895E
08956:  MOVLB  0
08958:  MOVLW  00
0895A:  GOTO   8960
0895E:  MOVLW  01
08960:  MOVWF  01
08962:  GOTO   89B6 (RETURN)
.................... }
.................... 
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type)
.................... {
....................    SmfMissionStruct mis_struct = {0};
....................    
....................    if (func_type == SMF_WRITE)
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
....................    }
....................    else if (func_type == SMF_READ)
....................    {
....................       mis_struct.start_address = CIGS_MEASURE_DATA_START_ADDRESS;
....................       mis_struct.end_address   = CIGS_MEASURE_DATA_END_ADDRESS;
....................    }
....................    else if (func_type == SMF_ERASE)
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
....................    }
....................    
....................    return mis_struct;
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
03A04:  MOVLB  3
03A06:  CLRF   x7E
03A08:  CLRF   x7F
03A0A:  CLRF   x80
03A0C:  CLRF   x81
03A0E:  CLRF   x82
03A10:  CLRF   x83
03A12:  CLRF   x84
03A14:  CLRF   x85
03A16:  CLRF   x86
03A18:  CLRF   x87
03A1A:  CLRF   x88
03A1C:  CLRF   x89
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
03A1E:  MOVLW  BC
03A20:  MOVWF  FF6
03A22:  MOVLW  02
03A24:  MOVWF  FF7
03A26:  MOVLW  00
03A28:  MOVWF  FF8
03A2A:  MOVLB  0
03A2C:  CALL   1C14
....................    fprintf(PC, "\t[BOSS] >>> ");
03A30:  MOVLW  DC
03A32:  MOVWF  FF6
03A34:  MOVLW  02
03A36:  MOVWF  FF7
03A38:  MOVLW  00
03A3A:  MOVWF  FF8
03A3C:  CALL   1C14
....................    for (int8 i = 0; i < receive_signal_size; i++)
03A40:  MOVLB  3
03A42:  CLRF   x8A
03A44:  MOVLB  0
03A46:  MOVLB  3
03A48:  MOVF   x7D,W
03A4A:  SUBWF  x8A,W
03A4C:  BTFSS  FD8.0
03A4E:  BRA    3A56
03A50:  MOVLB  0
03A52:  GOTO   3A90
03A56:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
03A58:  MOVLB  3
03A5A:  MOVF   x8A,W
03A5C:  ADDWF  x7B,W
03A5E:  MOVWF  FE9
03A60:  MOVLW  00
03A62:  ADDWFC x7C,W
03A64:  MOVWF  FEA
03A66:  MOVFF  FEF,391
03A6A:  MOVFF  391,BC1
03A6E:  MOVLW  37
03A70:  MOVLB  B
03A72:  MOVWF  xC2
03A74:  MOVLB  0
03A76:  CALL   1E98
03A7A:  MOVLW  20
03A7C:  MOVLB  C
03A7E:  MOVWF  x14
03A80:  MOVLB  0
03A82:  CALL   1BC2
03A86:  MOVLB  3
03A88:  INCF   x8A,F
03A8A:  MOVLB  0
03A8C:  GOTO   3A46
....................    fprintf(PC, "\r\n");
03A90:  MOVLW  0D
03A92:  MOVLB  C
03A94:  MOVWF  x14
03A96:  MOVLB  0
03A98:  CALL   1BC2
03A9C:  MOVLW  0A
03A9E:  MOVLB  C
03AA0:  MOVWF  x14
03AA2:  MOVLB  0
03AA4:  CALL   1BC2
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
03AA8:  MOVFF  37C,392
03AAC:  MOVFF  37B,391
03AB0:  MOVFF  37D,393
03AB4:  GOTO   36FC
03AB8:  MOVFF  01,38B
....................    if (frame_start_position == -1)
03ABC:  MOVLB  3
03ABE:  MOVF   x8B,W
03AC0:  SUBLW  FF
03AC2:  BTFSC  FD8.2
03AC4:  BRA    3ACC
03AC6:  MOVLB  0
03AC8:  GOTO   3ADA
03ACC:  MOVLB  0
....................       return command;
03ACE:  MOVLW  7E
03AD0:  MOVWF  01
03AD2:  MOVLW  03
03AD4:  MOVWF  02
03AD6:  GOTO   3BFC
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
03ADA:  MOVLB  3
03ADC:  MOVF   x8B,W
03ADE:  ADDWF  x7B,W
03AE0:  MOVWF  01
03AE2:  MOVLW  00
03AE4:  ADDWFC x7C,W
03AE6:  MOVWF  03
03AE8:  MOVF   01,W
03AEA:  MOVWF  x8C
03AEC:  MOVFF  03,38D
03AF0:  MOVF   x8C,W
03AF2:  MOVWF  FE9
03AF4:  MOVF   x8D,W
03AF6:  MOVWF  FEA
03AF8:  MOVF   FEF,W
03AFA:  ANDLW  0F
03AFC:  MOVWF  x8E
03AFE:  MOVFF  38E,391
03B02:  MOVLB  0
03B04:  GOTO   37A4
03B08:  MOVFF  01,38F
....................    if (content_size == -1)
03B0C:  MOVLB  3
03B0E:  MOVF   x8F,W
03B10:  SUBLW  FF
03B12:  BTFSC  FD8.2
03B14:  BRA    3B1C
03B16:  MOVLB  0
03B18:  GOTO   3B2A
03B1C:  MOVLB  0
....................       return command;
03B1E:  MOVLW  7E
03B20:  MOVWF  01
03B22:  MOVLW  03
03B24:  MOVWF  02
03B26:  GOTO   3BFC
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
03B2A:  MOVLB  3
03B2C:  MOVF   x8B,W
03B2E:  SUBWF  x7D,W
03B30:  MOVWF  x90
....................    
....................    if (!check_crc(frame, receive_frame_size))
03B32:  MOVFF  38D,392
03B36:  MOVFF  38C,391
03B3A:  MOVFF  390,393
03B3E:  MOVLB  0
03B40:  GOTO   3860
03B44:  MOVF   01,F
03B46:  BTFSS  FD8.2
03B48:  GOTO   3B58
....................       return command;
03B4C:  MOVLW  7E
03B4E:  MOVWF  01
03B50:  MOVLW  03
03B52:  MOVWF  02
03B54:  GOTO   3BFC
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
03B58:  MOVLB  3
03B5A:  MOVF   x8C,W
03B5C:  MOVWF  FE9
03B5E:  MOVF   x8D,W
03B60:  MOVWF  FEA
03B62:  MOVF   FEF,W
03B64:  ANDLW  F0
03B66:  MOVWF  00
03B68:  SWAPF  00,W
03B6A:  MOVWF  x91
03B6C:  MOVLW  0F
03B6E:  ANDWF  x91,F
03B70:  MOVFF  391,392
03B74:  MOVLB  0
03B76:  GOTO   394A
03B7A:  MOVF   01,F
03B7C:  BTFSS  FD8.2
03B7E:  GOTO   3B8E
....................       return command;
03B82:  MOVLW  7E
03B84:  MOVWF  01
03B86:  MOVLW  03
03B88:  MOVWF  02
03B8A:  GOTO   3BFC
.................... 
....................    command.frame_id = frame_id;
03B8E:  MOVFF  38E,37E
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
03B92:  MOVLW  01
03B94:  MOVLB  3
03B96:  ADDWF  x8C,W
03B98:  MOVWF  01
03B9A:  MOVLW  00
03B9C:  ADDWFC x8D,W
03B9E:  MOVWF  03
03BA0:  MOVF   01,W
03BA2:  MOVWF  x91
03BA4:  MOVFF  03,392
03BA8:  MOVLW  02
03BAA:  SUBWF  x90,W
03BAC:  MOVWF  x93
03BAE:  MOVLW  03
03BB0:  MOVWF  FEA
03BB2:  MOVLW  81
03BB4:  MOVWF  FE9
03BB6:  MOVFF  392,FE2
03BBA:  MOVFF  391,FE1
03BBE:  MOVF   x93,W
03BC0:  MOVWF  01
03BC2:  BTFSS  FD8.2
03BC4:  BRA    3BCC
03BC6:  MOVLB  0
03BC8:  GOTO   3BD8
03BCC:  MOVLB  0
03BCE:  MOVFF  FE6,FEE
03BD2:  DECFSZ 01,F
03BD4:  GOTO   3BCE
....................    command.size = receive_frame_size-2;
03BD8:  MOVLW  02
03BDA:  MOVLB  3
03BDC:  SUBWF  x90,W
03BDE:  MOVWF  x7F
....................    command.is_exist = TRUE;
03BE0:  BSF    x80.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
03BE2:  MOVLW  EA
03BE4:  MOVWF  FF6
03BE6:  MOVLW  02
03BE8:  MOVWF  FF7
03BEA:  MOVLW  00
03BEC:  MOVWF  FF8
03BEE:  MOVLB  0
03BF0:  CALL   1C14
....................    return command;
03BF4:  MOVLW  7E
03BF6:  MOVWF  01
03BF8:  MOVLW  03
03BFA:  MOVWF  02
03BFC:  GOTO   932C (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
036FC:  MOVLB  3
036FE:  CLRF   x94
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
03700:  CLRF   x94
03702:  MOVLB  0
03704:  MOVLW  01
03706:  MOVLB  3
03708:  SUBWF  x93,W
0370A:  SUBWF  x94,W
0370C:  BTFSS  FD8.0
0370E:  BRA    3716
03710:  MOVLB  0
03712:  GOTO   374E
03716:  MOVLB  0
....................       if(receive_signal[i] == SFD)
03718:  MOVLB  3
0371A:  MOVF   x94,W
0371C:  ADDWF  x91,W
0371E:  MOVWF  FE9
03720:  MOVLW  00
03722:  ADDWFC x92,W
03724:  MOVWF  FEA
03726:  MOVF   FEF,W
03728:  SUBLW  AA
0372A:  BTFSC  FD8.2
0372C:  BRA    3734
0372E:  MOVLB  0
03730:  GOTO   3744
03734:  MOVLB  0
....................          return i+1;
03736:  MOVLW  01
03738:  MOVLB  3
0373A:  ADDWF  x94,W
0373C:  MOVWF  01
0373E:  MOVLB  0
03740:  GOTO   37A0
03744:  MOVLB  3
03746:  INCF   x94,F
03748:  MOVLB  0
0374A:  GOTO   3704
....................    if (receive_signal[i] == SFD)
0374E:  MOVLB  3
03750:  MOVF   x94,W
03752:  ADDWF  x91,W
03754:  MOVWF  FE9
03756:  MOVLW  00
03758:  ADDWFC x92,W
0375A:  MOVWF  FEA
0375C:  MOVF   FEF,W
0375E:  SUBLW  AA
03760:  BTFSC  FD8.2
03762:  BRA    376A
03764:  MOVLB  0
03766:  GOTO   3788
0376A:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
0376C:  MOVLW  06
0376E:  MOVWF  FF6
03770:  MOVLW  03
03772:  MOVWF  FF7
03774:  MOVLW  00
03776:  MOVWF  FF8
03778:  CALL   1C14
....................       return -1;
0377C:  MOVLW  FF
0377E:  MOVWF  01
03780:  GOTO   37A0
....................    }
03784:  GOTO   37A0
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
03788:  MOVLW  1C
0378A:  MOVWF  FF6
0378C:  MOVLW  03
0378E:  MOVWF  FF7
03790:  MOVLW  00
03792:  MOVWF  FF8
03794:  CALL   1C14
....................       return -1;
03798:  MOVLW  FF
0379A:  MOVWF  01
0379C:  GOTO   37A0
....................    }
037A0:  GOTO   3AB8 (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
037A4:  MOVLB  3
037A6:  CLRF   x92
037A8:  MOVLB  0
037AA:  MOVLB  3
037AC:  MOVF   x92,W
037AE:  SUBLW  02
037B0:  BTFSC  FD8.0
037B2:  BRA    37BA
037B4:  MOVLB  0
037B6:  GOTO   3818
037BA:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
037BC:  BCF    FD8.0
037BE:  MOVLB  3
037C0:  RLCF   x92,W
037C2:  CLRF   x94
037C4:  MOVWF  x93
037C6:  MOVLW  06
037C8:  ADDWF  x93,W
037CA:  MOVWF  FE9
037CC:  MOVLW  03
037CE:  ADDWFC x94,W
037D0:  MOVWF  FEA
037D2:  MOVF   FEF,W
037D4:  SUBWF  x91,W
037D6:  BTFSC  FD8.2
037D8:  BRA    37E0
037DA:  MOVLB  0
037DC:  GOTO   380E
037E0:  MOVLB  0
....................          return frame_ids[i].length;
037E2:  BCF    FD8.0
037E4:  MOVLB  3
037E6:  RLCF   x92,W
037E8:  CLRF   x94
037EA:  MOVWF  x93
037EC:  MOVLW  01
037EE:  ADDWF  x93,W
037F0:  MOVWF  01
037F2:  MOVLW  00
037F4:  ADDWFC x94,W
037F6:  MOVWF  03
037F8:  MOVF   01,W
037FA:  ADDLW  06
037FC:  MOVWF  FE9
037FE:  MOVLW  03
03800:  ADDWFC 03,W
03802:  MOVWF  FEA
03804:  MOVF   FEF,W
03806:  MOVWF  01
03808:  MOVLB  0
0380A:  GOTO   385C
0380E:  MOVLB  3
03810:  INCF   x92,F
03812:  MOVLB  0
03814:  GOTO   37AA
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
03818:  MOVLW  2E
0381A:  MOVWF  FF6
0381C:  MOVLW  03
0381E:  MOVWF  FF7
03820:  MOVLW  00
03822:  MOVWF  FF8
03824:  MOVLW  1F
03826:  MOVLB  B
03828:  MOVWF  xC1
0382A:  MOVLB  0
0382C:  CALL   1C44
03830:  MOVFF  391,BC1
03834:  MOVLW  37
03836:  MOVLB  B
03838:  MOVWF  xC2
0383A:  MOVLB  0
0383C:  CALL   1E98
03840:  MOVLW  0D
03842:  MOVLB  C
03844:  MOVWF  x14
03846:  MOVLB  0
03848:  CALL   1BC2
0384C:  MOVLW  0A
0384E:  MOVLB  C
03850:  MOVWF  x14
03852:  MOVLB  0
03854:  CALL   1BC2
....................    return -1;
03858:  MOVLW  FF
0385A:  MOVWF  01
0385C:  GOTO   3B08 (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
03860:  MOVLW  01
03862:  MOVLB  3
03864:  SUBWF  x93,W
03866:  ADDWF  x91,W
03868:  MOVWF  FE9
0386A:  MOVLW  00
0386C:  ADDWFC x92,W
0386E:  MOVWF  FEA
03870:  MOVFF  FEF,394
03874:  MOVLW  01
03876:  SUBWF  x93,W
03878:  MOVWF  x96
0387A:  MOVFF  392,C54
0387E:  MOVFF  391,C53
03882:  MOVFF  396,C55
03886:  MOVLB  0
03888:  CALL   2A40
0388C:  MOVFF  01,395
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
03890:  MOVLB  3
03892:  MOVF   x95,W
03894:  SUBWF  x94,W
03896:  BTFSC  FD8.2
03898:  BRA    38A0
0389A:  MOVLB  0
0389C:  GOTO   38AE
038A0:  MOVLB  0
....................       return TRUE;
038A2:  MOVLW  01
038A4:  MOVWF  01
038A6:  GOTO   3946
038AA:  GOTO   3946
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
038AE:  MOVLW  52
038B0:  MOVWF  FF6
038B2:  MOVLW  03
038B4:  MOVWF  FF7
038B6:  MOVLW  00
038B8:  MOVWF  FF8
038BA:  CALL   1C14
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
038BE:  MOVLW  64
038C0:  MOVWF  FF6
038C2:  MOVLW  03
038C4:  MOVWF  FF7
038C6:  MOVLW  00
038C8:  MOVWF  FF8
038CA:  MOVLW  13
038CC:  MOVLB  B
038CE:  MOVWF  xC1
038D0:  MOVLB  0
038D2:  CALL   1C44
038D6:  MOVFF  394,BC1
038DA:  MOVLW  37
038DC:  MOVLB  B
038DE:  MOVWF  xC2
038E0:  MOVLB  0
038E2:  CALL   1E98
038E6:  MOVLW  0D
038E8:  MOVLB  C
038EA:  MOVWF  x14
038EC:  MOVLB  0
038EE:  CALL   1BC2
038F2:  MOVLW  0A
038F4:  MOVLB  C
038F6:  MOVWF  x14
038F8:  MOVLB  0
038FA:  CALL   1BC2
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
038FE:  MOVLW  7C
03900:  MOVWF  FF6
03902:  MOVLW  03
03904:  MOVWF  FF7
03906:  MOVLW  00
03908:  MOVWF  FF8
0390A:  MOVLW  13
0390C:  MOVLB  B
0390E:  MOVWF  xC1
03910:  MOVLB  0
03912:  CALL   1C44
03916:  MOVFF  395,BC1
0391A:  MOVLW  37
0391C:  MOVLB  B
0391E:  MOVWF  xC2
03920:  MOVLB  0
03922:  CALL   1E98
03926:  MOVLW  0D
03928:  MOVLB  C
0392A:  MOVWF  x14
0392C:  MOVLB  0
0392E:  CALL   1BC2
03932:  MOVLW  0A
03934:  MOVLB  C
03936:  MOVWF  x14
03938:  MOVLB  0
0393A:  CALL   1BC2
....................       return FALSE;
0393E:  MOVLW  00
03940:  MOVWF  01
03942:  GOTO   3946
....................    }
03946:  GOTO   3B44 (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
0394A:  MOVLB  3
0394C:  MOVF   x92,W
0394E:  SUBLW  0C
03950:  BTFSC  FD8.2
03952:  BRA    395A
03954:  MOVLB  0
03956:  GOTO   3968
0395A:  MOVLB  0
....................       return TRUE;
0395C:  MOVLW  01
0395E:  MOVWF  01
03960:  GOTO   3A00
03964:  GOTO   3A00
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
03968:  MOVLW  94
0396A:  MOVWF  FF6
0396C:  MOVLW  03
0396E:  MOVWF  FF7
03970:  MOVLW  00
03972:  MOVWF  FF8
03974:  CALL   1C14
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
03978:  MOVLW  B6
0397A:  MOVWF  FF6
0397C:  MOVLW  03
0397E:  MOVWF  FF7
03980:  MOVLW  00
03982:  MOVWF  FF8
03984:  MOVLW  13
03986:  MOVLB  B
03988:  MOVWF  xC1
0398A:  MOVLB  0
0398C:  CALL   1C44
03990:  MOVFF  392,BC1
03994:  MOVLW  37
03996:  MOVLB  B
03998:  MOVWF  xC2
0399A:  MOVLB  0
0399C:  CALL   1E98
039A0:  MOVLW  0D
039A2:  MOVLB  C
039A4:  MOVWF  x14
039A6:  MOVLB  0
039A8:  CALL   1BC2
039AC:  MOVLW  0A
039AE:  MOVLB  C
039B0:  MOVWF  x14
039B2:  MOVLB  0
039B4:  CALL   1BC2
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
039B8:  MOVLW  CE
039BA:  MOVWF  FF6
039BC:  MOVLW  03
039BE:  MOVWF  FF7
039C0:  MOVLW  00
039C2:  MOVWF  FF8
039C4:  MOVLW  13
039C6:  MOVLB  B
039C8:  MOVWF  xC1
039CA:  MOVLB  0
039CC:  CALL   1C44
039D0:  MOVLW  0C
039D2:  MOVLB  B
039D4:  MOVWF  xC1
039D6:  MOVLW  37
039D8:  MOVWF  xC2
039DA:  MOVLB  0
039DC:  CALL   1E98
039E0:  MOVLW  0D
039E2:  MOVLB  C
039E4:  MOVWF  x14
039E6:  MOVLB  0
039E8:  CALL   1BC2
039EC:  MOVLW  0A
039EE:  MOVLB  C
039F0:  MOVWF  x14
039F2:  MOVLB  0
039F4:  CALL   1BC2
....................       return FALSE;  
039F8:  MOVLW  00
039FA:  MOVWF  01
039FC:  GOTO   3A00
....................    }
03A00:  GOTO   3B7A (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
03D2A:  MOVLW  AA
03D2C:  MOVLB  3
03D2E:  MOVWF  x7D
....................    data[1] = (BOSS_PIC << 4) | frame_id;
03D30:  MOVF   x79,W
03D32:  IORLW  50
03D34:  MOVWF  x7E
....................    memcpy(&data[2], content, size);
03D36:  MOVLW  03
03D38:  MOVWF  FEA
03D3A:  MOVLW  7F
03D3C:  MOVWF  FE9
03D3E:  MOVFF  37B,FE2
03D42:  MOVFF  37A,FE1
03D46:  MOVF   x7C,W
03D48:  MOVWF  01
03D4A:  BTFSS  FD8.2
03D4C:  BRA    3D54
03D4E:  MOVLB  0
03D50:  GOTO   3D60
03D54:  MOVLB  0
03D56:  MOVFF  FE6,FEE
03D5A:  DECFSZ 01,F
03D5C:  GOTO   3D56
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
03D60:  MOVLW  02
03D62:  MOVLB  3
03D64:  ADDWF  x7C,W
03D66:  MOVWF  x8D
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
03D68:  CLRF   03
03D6A:  MOVF   x8D,W
03D6C:  ADDLW  7D
03D6E:  MOVWF  01
03D70:  MOVLW  03
03D72:  ADDWFC 03,F
03D74:  MOVF   01,W
03D76:  MOVWF  x8F
03D78:  MOVFF  03,390
03D7C:  MOVLW  01
03D7E:  SUBWF  x8D,W
03D80:  MOVWF  x91
03D82:  MOVLW  03
03D84:  MOVLB  C
03D86:  MOVWF  x54
03D88:  MOVLW  7E
03D8A:  MOVWF  x53
03D8C:  MOVFF  391,C55
03D90:  MOVLB  0
03D92:  CALL   2A40
03D96:  MOVFF  390,FEA
03D9A:  MOVFF  38F,FE9
03D9E:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
03DA2:  MOVLW  01
03DA4:  MOVLB  3
03DA6:  ADDWF  x8D,W
03DA8:  MOVWF  x8E
....................    
....................    transmit(data, data_size);
03DAA:  MOVLW  03
03DAC:  MOVWF  x90
03DAE:  MOVLW  7D
03DB0:  MOVWF  x8F
03DB2:  MOVFF  38E,391
03DB6:  MOVLB  0
03DB8:  GOTO   3C72
03DBC:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
03C72:  MOVLB  3
03C74:  CLRF   x92
03C76:  MOVLB  0
03C78:  MOVLB  3
03C7A:  MOVF   x91,W
03C7C:  SUBWF  x92,W
03C7E:  BTFSS  FD8.0
03C80:  BRA    3C88
03C82:  MOVLB  0
03C84:  GOTO   3CAE
03C88:  MOVLB  0
....................       fputc(data[i], BOSS);
03C8A:  MOVLB  3
03C8C:  MOVF   x92,W
03C8E:  ADDWF  x8F,W
03C90:  MOVWF  FE9
03C92:  MOVLW  00
03C94:  ADDWFC x90,W
03C96:  MOVWF  FEA
03C98:  MOVFF  FEF,394
03C9C:  MOVF   x94,W
03C9E:  MOVLB  0
03CA0:  GOTO   3C62
03CA4:  MOVLB  3
03CA6:  INCF   x92,F
03CA8:  MOVLB  0
03CAA:  GOTO   3C78
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
03CAE:  MOVLW  E6
03CB0:  MOVWF  FF6
03CB2:  MOVLW  03
03CB4:  MOVWF  FF7
03CB6:  MOVLW  00
03CB8:  MOVWF  FF8
03CBA:  CALL   1C14
....................    for(int i = 0; i < data_size; i++)
03CBE:  MOVLB  3
03CC0:  CLRF   x93
03CC2:  MOVLB  0
03CC4:  MOVLB  3
03CC6:  MOVF   x91,W
03CC8:  SUBWF  x93,W
03CCA:  BTFSS  FD8.0
03CCC:  BRA    3CD4
03CCE:  MOVLB  0
03CD0:  GOTO   3D0E
03CD4:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
03CD6:  MOVLB  3
03CD8:  MOVF   x93,W
03CDA:  ADDWF  x8F,W
03CDC:  MOVWF  FE9
03CDE:  MOVLW  00
03CE0:  ADDWFC x90,W
03CE2:  MOVWF  FEA
03CE4:  MOVFF  FEF,394
03CE8:  MOVFF  394,BC1
03CEC:  MOVLW  37
03CEE:  MOVLB  B
03CF0:  MOVWF  xC2
03CF2:  MOVLB  0
03CF4:  CALL   1E98
03CF8:  MOVLW  20
03CFA:  MOVLB  C
03CFC:  MOVWF  x14
03CFE:  MOVLB  0
03D00:  CALL   1BC2
03D04:  MOVLB  3
03D06:  INCF   x93,F
03D08:  MOVLB  0
03D0A:  GOTO   3CC4
....................    fprintf(PC, "\r\n");
03D0E:  MOVLW  0D
03D10:  MOVLB  C
03D12:  MOVWF  x14
03D14:  MOVLB  0
03D16:  CALL   1BC2
03D1A:  MOVLW  0A
03D1C:  MOVLB  C
03D1E:  MOVWF  x14
03D20:  MOVLB  0
03D22:  CALL   1BC2
03D26:  GOTO   3DBC (RETURN)
.................... }
.................... 
.................... #include "../../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
03DBE:  MOVLW  0F
03DC0:  MOVLB  3
03DC2:  MOVWF  x79
03DC4:  CLRF   x7B
03DC6:  CLRF   x7A
03DC8:  CLRF   x7C
03DCA:  MOVLB  0
03DCC:  CALL   3D2A
03DD0:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
089CE:  MOVLW  03
089D0:  MOVLB  3
089D2:  MOVWF  x79
089D4:  CLRF   x7B
089D6:  MOVLW  48
089D8:  MOVWF  x7A
089DA:  MOVLW  04
089DC:  MOVWF  x7C
089DE:  MOVLB  0
089E0:  CALL   3D2A
089E4:  GOTO   8A0C (RETURN)
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "../core/measurement/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=0, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../storage/mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
01C7A:  MOVLW  FA
01C7C:  MOVWF  FF6
01C7E:  MOVLW  04
01C80:  MOVWF  FF7
01C82:  MOVLW  00
01C84:  MOVWF  FF8
01C86:  CALL   1C14
....................     // output_high(ADC_CS); // ADC Chip Select
....................     output_high(MIS_FM_CS); // DAC Chip Select
01C8A:  MOVLW  DB
01C8C:  MOVWF  F92
01C8E:  BSF    F89.5
....................     output_high(SMF_CS); // SMF Chip Select
01C90:  MOVLW  DB
01C92:  MOVWF  F92
01C94:  BSF    F89.2
....................     output_low(CONNECT_CIGS1);
01C96:  MOVLW  5E
01C98:  MOVWF  F94
01C9A:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
01C9C:  MOVLW  5E
01C9E:  MOVWF  F94
01CA0:  BCF    F8B.5
....................     output_high(EN_NPWR);
01CA2:  MOVLW  5E
01CA4:  MOVWF  F94
01CA6:  BSF    F8B.7
....................     delay_ms(1);
01CA8:  MOVLW  01
01CAA:  MOVLB  C
01CAC:  MOVWF  x6B
01CAE:  MOVLB  0
01CB0:  CALL   1B94
....................     fprintf(PC, "\tComplete\r\n");
01CB4:  MOVLW  0A
01CB6:  MOVWF  FF6
01CB8:  MOVLW  05
01CBA:  MOVWF  FF7
01CBC:  MOVLW  00
01CBE:  MOVWF  FF8
01CC0:  CALL   1C14
01CC4:  GOTO   92B6 (RETURN)
.................... }
.................... 
.................... 
.................... void test_sweep(unsigned int8 sweep_step)
.................... {
....................     fprintf(PC, "Start TEST SWEEP\r\n");
....................     output_high(CONNECT_CIGS1);
....................     output_low(EN_NPWR); // Enable power to CIGS
....................     delay_us(100); // wait for the CIGS to stabilize
....................     fprintf(PC, "step, voltage, current\r\n");
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     delay_ms(100); // wait for the DAC to stabilize
.................... 
.................... 
....................     unsigned int16 volt;
....................     unsigned int16 curr;
....................     for (unsigned int8 count = 0; count < sweep_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
.................... 
....................         volt = ad7490_read(ADC_CIGS1_AMP); // read CIGS voltage
....................         curr = ad7490_read(ADC_CIGS1_CURR); // read CIGS current
....................         
....................         fprintf(PC, "%u, %lu, %lu\r\n", count, volt, curr);
....................         delay_ms(1); // wait for the ADC to stabilize
....................     }
.................... }
.................... 
.................... void test_adc()
.................... {
....................     unsigned int16 ans;
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     fprintf(PC, "Start ADC TEST\r\n");
....................     ans = ad7490_read(ADC_CIGS1_VOLT);
....................     fprintf(PC, "ADC Voltage: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_CURR);
....................     fprintf(PC, "ADC Current: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_AMP);
....................     fprintf(PC, "ADC CIGS1 Amp: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_VREF);
....................     fprintf(PC, "ADC CIGS1 VREF: %04LX\r\n", ans);
.................... }
.................... 
.................... void sweep_2ports(unsigned int8 measurement_step)
.................... { 
....................     fprintf(PC, "Start SWEEP 2ports\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1 and CIGS2
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
....................     unsigned int16 cigs2_buffer[2][0xFF];
.................... 
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_VOLT);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP 2port\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... 
.................... void sweep_port1(unsigned int8 measurement_step)
.................... {
....................     fprintf(PC, "Start SWEEP PORT1\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1
....................     output_high(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(10);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................     }
....................     
.................... 
.................... 
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP PORT1\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
....................     
.................... 
....................     
....................     //make_meas_header(packetdata, parameter); // Create measurement header
....................     unsigned int8 packetdata_index = 0; // Index for packet data
....................    
....................     for (unsigned int16 i = 0; i < measurement_step; i++)
....................     {        
....................         packetdata[packetdata_index]      = (cigs1_buffer[0][i] >> 4) & 0xFF;
....................         packetdata_index++; 
....................         packetdata[packetdata_index]    = (cigs1_buffer[0][i] & 0x0F) << 4 | (cigs1_buffer[1][i] >>8 )& 0x0F;
....................         packetdata_index++; 
....................         packetdata[packetdata_index]    = cigs1_buffer[1][i] & 0xFF;
....................         packetdata_index++; 
.................... 
....................         if (packetdata_index == PACKET_SIZE-1) {
....................             // Add CRC
....................             //fprintf(PC, "Adding CRC to packetdata\r\n");
....................             packetdata[PACKET_SIZE-1] = calc_crc8(packetdata, PACKET_SIZE-1);            
....................             
....................             
....................             // Flash 書き込み処理
....................             unsigned int32 write_address = ADDRESS_MISF_MEASUREMENT_START + iv_data.used_counter;
....................             //fprintf(PC, "write data\r\n");
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................             //fprintf(PC, "Add Counter\r\n");
....................             // カウンタ更新
....................             //fprintf(PC, "before misf_meas_use_counter: %08LX\r\n", misf_meas_use_counter);
....................             iv_data.used_counter += PACKET_SIZE;
....................             //fprintf(PC, "after misf_meas_use_counter: %08LX\r\n", misf_meas_use_counter);
....................             iv_data.uncopied_counter += PACKET_SIZE;
....................             packetdata_index = 0; // Reset packet byte counter
....................             memset(packetdata, 0x00, PACKET_SIZE); // これ重要
....................             //fprintf(PC, "Added Counter\r\n");
....................         }
....................     }
.................... 
....................     //fprintf(PC, "End CIGS data conversion\r\n");
....................     //fprintf(PC, "Start CIGS data conversion\r\n");
....................     
....................     if (packetdata_index < PACKET_SIZE-1) {
....................         // Fill the remaining bytes with 0x00
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE-1; j++ ) {
....................             packetdata[j] = 0x00;
....................         }
....................         // Flash 書き込み処理
....................         unsigned int32 write_address = ADDRESS_MISF_MEASUREMENT_START + iv_data.used_counter;
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................         //fprintf(PC, "before misf_meas_use_counter: %08LX\r\n", misf_meas_use_counter);
....................         // カウンタ更新
....................         iv_data.used_counter += PACKET_SIZE;
....................         //fprintf(PC, "after misf_meas_use_counter: %08LX\r\n", misf_meas_use_counter);
....................         iv_data.uncopied_counter += PACKET_SIZE;
....................     }
....................         
....................     write_misf_address_area();
....................     //misf_init(); // Initialize the mission flash
....................     fprintf(PC, "End CIGS data conversion\r\n");
....................     
.................... }
.................... 
.................... void sweep_port2(unsigned int8 measurement_step)
.................... {
....................     fprintf(PC, "Start SWEEP PORT2\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS2
....................     output_low(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
....................     unsigned int16 cigs2_buffer[2][0xFF]; // Buffer for CIGS2 data
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP PORT2\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... /*
.................... void add_smf_queue_data()
.................... {
....................     SmfDataStruct smf_data;
....................     smf_data.type = SMF_DATA_TYPE_CIGS;
....................     smf_data.length = PACKET_SIZE;
....................     memcpy(smf_data.data, packetdata, PACKET_SIZE);
....................     enqueue_smf_data(&smf_data);
.................... }
.................... */
.................... void add_smf_queue_piclog()
.................... {}
.................... 
.................... void convert_datas(MEASUREMENT_DATA measured_data, )
.................... {
.................... 
.................... }
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, "Start SWEEP with threshold\r\n");
*
06912:  MOVLW  D8
06914:  MOVWF  FF6
06916:  MOVLW  06
06918:  MOVWF  FF7
0691A:  MOVLW  00
0691C:  MOVWF  FF8
0691E:  CALL   1C14
....................    
....................     // Enable both CIGS ports
....................     output_high(CONNECT_CIGS1);
06922:  MOVLW  5E
06924:  MOVWF  F94
06926:  BSF    F8B.0
....................     output_high(CONNECT_CIGS2);
06928:  MOVLW  5E
0692A:  MOVWF  F94
0692C:  BSF    F8B.5
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     SWEEP_CONFIG port1 = {0};
0692E:  MOVLB  3
06930:  CLRF   xAC
06932:  CLRF   xAD
06934:  CLRF   xAE
06936:  CLRF   xAF
06938:  CLRF   xB0
0693A:  CLRF   xB1
0693C:  CLRF   xB2
0693E:  CLRF   xB3
06940:  CLRF   xB4
06942:  CLRF   xB5
06944:  CLRF   xB6
06946:  CLRF   xB7
06948:  CLRF   xB8
0694A:  CLRF   xB9
0694C:  CLRF   xBA
0694E:  CLRF   xBB
06950:  CLRF   xBC
06952:  CLRF   xBD
06954:  CLRF   xBE
06956:  CLRF   xBF
06958:  CLRF   xC0
0695A:  CLRF   xC1
0695C:  CLRF   xC2
0695E:  CLRF   xC3
06960:  CLRF   xC4
06962:  CLRF   xC5
06964:  CLRF   xC6
06966:  CLRF   xC7
06968:  CLRF   xC8
0696A:  CLRF   xC9
0696C:  CLRF   xCA
0696E:  CLRF   xCB
06970:  CLRF   xCC
06972:  CLRF   xCD
06974:  CLRF   xCE
06976:  CLRF   xCF
06978:  CLRF   xD0
0697A:  CLRF   xD1
0697C:  CLRF   xD2
0697E:  CLRF   xD3
06980:  CLRF   xD4
06982:  CLRF   xD5
06984:  CLRF   xD6
06986:  CLRF   xD7
06988:  CLRF   xD8
0698A:  CLRF   xD9
0698C:  CLRF   xDA
0698E:  CLRF   xDB
06990:  CLRF   xDC
06992:  CLRF   xDD
06994:  CLRF   xDE
06996:  CLRF   xDF
06998:  CLRF   xE0
0699A:  CLRF   xE1
0699C:  CLRF   xE2
0699E:  CLRF   xE3
069A0:  CLRF   xE4
069A2:  CLRF   xE5
069A4:  CLRF   xE6
069A6:  CLRF   xE7
069A8:  CLRF   xE8
069AA:  CLRF   xE9
069AC:  CLRF   xEA
069AE:  CLRF   xEB
069B0:  CLRF   xEC
069B2:  CLRF   xED
069B4:  CLRF   xEE
069B6:  CLRF   xEF
069B8:  CLRF   xF0
069BA:  CLRF   xF1
069BC:  CLRF   xF2
069BE:  CLRF   xF3
069C0:  CLRF   xF4
069C2:  CLRF   xF5
069C4:  CLRF   xF6
069C6:  CLRF   xF7
069C8:  CLRF   xF8
069CA:  CLRF   xF9
069CC:  CLRF   xFA
069CE:  CLRF   xFB
069D0:  CLRF   xFC
069D2:  CLRF   xFD
069D4:  CLRF   xFE
069D6:  CLRF   xFF
069D8:  MOVLB  4
069DA:  CLRF   x00
069DC:  CLRF   x01
069DE:  CLRF   x02
069E0:  CLRF   x03
069E2:  CLRF   x04
069E4:  CLRF   x05
069E6:  CLRF   x06
069E8:  CLRF   x07
069EA:  CLRF   x08
069EC:  CLRF   x09
069EE:  CLRF   x0A
069F0:  CLRF   x0B
069F2:  CLRF   x0C
069F4:  CLRF   x0D
069F6:  CLRF   x0E
069F8:  CLRF   x0F
069FA:  CLRF   x10
069FC:  CLRF   x11
069FE:  CLRF   x12
06A00:  CLRF   x13
06A02:  CLRF   x14
06A04:  CLRF   x15
06A06:  CLRF   x16
06A08:  CLRF   x17
06A0A:  CLRF   x18
06A0C:  CLRF   x19
06A0E:  CLRF   x1A
06A10:  CLRF   x1B
06A12:  CLRF   x1C
06A14:  CLRF   x1D
06A16:  CLRF   x1E
06A18:  CLRF   x1F
06A1A:  CLRF   x20
06A1C:  CLRF   x21
06A1E:  CLRF   x22
06A20:  CLRF   x23
06A22:  CLRF   x24
06A24:  CLRF   x25
06A26:  CLRF   x26
06A28:  CLRF   x27
06A2A:  CLRF   x28
06A2C:  CLRF   x29
06A2E:  CLRF   x2A
06A30:  CLRF   x2B
06A32:  CLRF   x2C
06A34:  CLRF   x2D
06A36:  CLRF   x2E
06A38:  CLRF   x2F
06A3A:  CLRF   x30
06A3C:  CLRF   x31
06A3E:  CLRF   x32
06A40:  CLRF   x33
06A42:  CLRF   x34
06A44:  CLRF   x35
06A46:  CLRF   x36
06A48:  CLRF   x37
06A4A:  CLRF   x38
06A4C:  CLRF   x39
06A4E:  CLRF   x3A
06A50:  CLRF   x3B
06A52:  CLRF   x3C
06A54:  CLRF   x3D
06A56:  CLRF   x3E
06A58:  CLRF   x3F
06A5A:  CLRF   x40
06A5C:  CLRF   x41
06A5E:  CLRF   x42
06A60:  CLRF   x43
06A62:  CLRF   x44
06A64:  CLRF   x45
06A66:  CLRF   x46
06A68:  CLRF   x47
06A6A:  CLRF   x48
06A6C:  CLRF   x49
06A6E:  CLRF   x4A
06A70:  CLRF   x4B
06A72:  CLRF   x4C
06A74:  CLRF   x4D
06A76:  CLRF   x4E
06A78:  CLRF   x4F
06A7A:  CLRF   x50
06A7C:  CLRF   x51
06A7E:  CLRF   x52
06A80:  CLRF   x53
06A82:  CLRF   x54
06A84:  CLRF   x55
06A86:  CLRF   x56
06A88:  CLRF   x57
06A8A:  CLRF   x58
06A8C:  CLRF   x59
06A8E:  CLRF   x5A
06A90:  CLRF   x5B
06A92:  CLRF   x5C
06A94:  CLRF   x5D
06A96:  CLRF   x5E
06A98:  CLRF   x5F
06A9A:  CLRF   x60
06A9C:  CLRF   x61
06A9E:  CLRF   x62
06AA0:  CLRF   x63
06AA2:  CLRF   x64
06AA4:  CLRF   x65
06AA6:  CLRF   x66
06AA8:  CLRF   x67
06AAA:  CLRF   x68
06AAC:  CLRF   x69
06AAE:  CLRF   x6A
06AB0:  CLRF   x6B
06AB2:  CLRF   x6C
06AB4:  CLRF   x6D
06AB6:  CLRF   x6E
06AB8:  CLRF   x6F
06ABA:  CLRF   x70
06ABC:  CLRF   x71
06ABE:  CLRF   x72
06AC0:  CLRF   x73
06AC2:  CLRF   x74
06AC4:  CLRF   x75
06AC6:  CLRF   x76
06AC8:  CLRF   x77
06ACA:  CLRF   x78
06ACC:  CLRF   x79
06ACE:  CLRF   x7A
06AD0:  CLRF   x7B
06AD2:  CLRF   x7C
06AD4:  CLRF   x7D
06AD6:  CLRF   x7E
06AD8:  CLRF   x7F
06ADA:  CLRF   x80
06ADC:  CLRF   x81
06ADE:  CLRF   x82
06AE0:  CLRF   x83
06AE2:  CLRF   x84
06AE4:  CLRF   x85
06AE6:  CLRF   x86
06AE8:  CLRF   x87
06AEA:  CLRF   x88
06AEC:  CLRF   x89
06AEE:  CLRF   x8A
06AF0:  CLRF   x8B
06AF2:  CLRF   x8C
06AF4:  CLRF   x8D
06AF6:  CLRF   x8E
06AF8:  CLRF   x8F
06AFA:  CLRF   x90
06AFC:  CLRF   x91
06AFE:  CLRF   x92
06B00:  CLRF   x93
06B02:  CLRF   x94
06B04:  CLRF   x95
06B06:  CLRF   x96
06B08:  CLRF   x97
06B0A:  CLRF   x98
06B0C:  CLRF   x99
06B0E:  CLRF   x9A
06B10:  CLRF   x9B
06B12:  CLRF   x9C
06B14:  CLRF   x9D
06B16:  CLRF   x9E
06B18:  CLRF   x9F
06B1A:  CLRF   xA0
06B1C:  CLRF   xA1
06B1E:  CLRF   xA2
06B20:  CLRF   xA3
06B22:  CLRF   xA4
06B24:  CLRF   xA5
06B26:  CLRF   xA6
06B28:  CLRF   xA7
06B2A:  CLRF   xA8
06B2C:  CLRF   xA9
06B2E:  CLRF   xAA
06B30:  CLRF   xAB
06B32:  CLRF   xAC
06B34:  CLRF   xAD
06B36:  CLRF   xAE
06B38:  CLRF   xAF
06B3A:  CLRF   xB0
06B3C:  CLRF   xB1
06B3E:  CLRF   xB2
06B40:  CLRF   xB3
06B42:  CLRF   xB4
06B44:  CLRF   xB5
06B46:  CLRF   xB6
06B48:  CLRF   xB7
06B4A:  CLRF   xB8
06B4C:  CLRF   xB9
06B4E:  CLRF   xBA
06B50:  CLRF   xBB
06B52:  CLRF   xBC
06B54:  CLRF   xBD
06B56:  CLRF   xBE
06B58:  CLRF   xBF
06B5A:  CLRF   xC0
06B5C:  CLRF   xC1
06B5E:  CLRF   xC2
06B60:  CLRF   xC3
06B62:  CLRF   xC4
06B64:  CLRF   xC5
06B66:  CLRF   xC6
06B68:  CLRF   xC7
06B6A:  CLRF   xC8
06B6C:  CLRF   xC9
06B6E:  CLRF   xCA
06B70:  CLRF   xCB
06B72:  CLRF   xCC
06B74:  CLRF   xCD
06B76:  CLRF   xCE
06B78:  CLRF   xCF
06B7A:  CLRF   xD0
06B7C:  CLRF   xD1
06B7E:  CLRF   xD2
06B80:  CLRF   xD3
06B82:  CLRF   xD4
06B84:  CLRF   xD5
06B86:  CLRF   xD6
06B88:  CLRF   xD7
06B8A:  CLRF   xD8
06B8C:  CLRF   xD9
06B8E:  CLRF   xDA
06B90:  CLRF   xDB
06B92:  CLRF   xDC
06B94:  CLRF   xDD
06B96:  CLRF   xDE
06B98:  CLRF   xDF
06B9A:  CLRF   xE0
06B9C:  CLRF   xE1
06B9E:  CLRF   xE2
06BA0:  CLRF   xE3
06BA2:  CLRF   xE4
06BA4:  CLRF   xE5
06BA6:  CLRF   xE6
06BA8:  CLRF   xE7
06BAA:  CLRF   xE8
06BAC:  CLRF   xE9
06BAE:  CLRF   xEA
06BB0:  CLRF   xEB
06BB2:  CLRF   xEC
06BB4:  CLRF   xED
06BB6:  CLRF   xEE
06BB8:  CLRF   xEF
06BBA:  CLRF   xF0
06BBC:  CLRF   xF1
06BBE:  CLRF   xF2
06BC0:  CLRF   xF3
06BC2:  CLRF   xF4
06BC4:  CLRF   xF5
06BC6:  CLRF   xF6
06BC8:  CLRF   xF7
06BCA:  CLRF   xF8
06BCC:  CLRF   xF9
06BCE:  CLRF   xFA
06BD0:  CLRF   xFB
06BD2:  CLRF   xFC
06BD4:  CLRF   xFD
06BD6:  CLRF   xFE
06BD8:  CLRF   xFF
06BDA:  MOVLB  5
06BDC:  CLRF   x00
06BDE:  CLRF   x01
06BE0:  CLRF   x02
06BE2:  CLRF   x03
06BE4:  CLRF   x04
06BE6:  CLRF   x05
06BE8:  CLRF   x06
06BEA:  CLRF   x07
06BEC:  CLRF   x08
06BEE:  CLRF   x09
06BF0:  CLRF   x0A
06BF2:  CLRF   x0B
06BF4:  CLRF   x0C
06BF6:  CLRF   x0D
06BF8:  CLRF   x0E
06BFA:  CLRF   x0F
06BFC:  CLRF   x10
06BFE:  CLRF   x11
06C00:  CLRF   x12
06C02:  CLRF   x13
06C04:  CLRF   x14
06C06:  CLRF   x15
06C08:  CLRF   x16
06C0A:  CLRF   x17
06C0C:  CLRF   x18
06C0E:  CLRF   x19
06C10:  CLRF   x1A
06C12:  CLRF   x1B
06C14:  CLRF   x1C
06C16:  CLRF   x1D
06C18:  CLRF   x1E
06C1A:  CLRF   x1F
06C1C:  CLRF   x20
06C1E:  CLRF   x21
06C20:  CLRF   x22
06C22:  CLRF   x23
06C24:  CLRF   x24
06C26:  CLRF   x25
06C28:  CLRF   x26
06C2A:  CLRF   x27
06C2C:  CLRF   x28
06C2E:  CLRF   x29
06C30:  CLRF   x2A
06C32:  CLRF   x2B
06C34:  CLRF   x2C
06C36:  CLRF   x2D
06C38:  CLRF   x2E
06C3A:  CLRF   x2F
06C3C:  CLRF   x30
06C3E:  CLRF   x31
06C40:  CLRF   x32
06C42:  CLRF   x33
06C44:  CLRF   x34
06C46:  CLRF   x35
06C48:  CLRF   x36
06C4A:  CLRF   x37
06C4C:  CLRF   x38
06C4E:  CLRF   x39
06C50:  CLRF   x3A
06C52:  CLRF   x3B
06C54:  CLRF   x3C
06C56:  CLRF   x3D
06C58:  CLRF   x3E
06C5A:  CLRF   x3F
06C5C:  CLRF   x40
06C5E:  CLRF   x41
06C60:  CLRF   x42
06C62:  CLRF   x43
06C64:  CLRF   x44
06C66:  CLRF   x45
06C68:  CLRF   x46
06C6A:  CLRF   x47
06C6C:  CLRF   x48
06C6E:  CLRF   x49
06C70:  CLRF   x4A
06C72:  CLRF   x4B
06C74:  CLRF   x4C
06C76:  CLRF   x4D
06C78:  CLRF   x4E
06C7A:  CLRF   x4F
06C7C:  CLRF   x50
06C7E:  CLRF   x51
06C80:  CLRF   x52
06C82:  CLRF   x53
06C84:  CLRF   x54
06C86:  CLRF   x55
06C88:  CLRF   x56
06C8A:  CLRF   x57
06C8C:  CLRF   x58
06C8E:  CLRF   x59
06C90:  CLRF   x5A
06C92:  CLRF   x5B
06C94:  CLRF   x5C
06C96:  CLRF   x5D
06C98:  CLRF   x5E
06C9A:  CLRF   x5F
06C9C:  CLRF   x60
06C9E:  CLRF   x61
06CA0:  CLRF   x62
06CA2:  CLRF   x63
06CA4:  CLRF   x64
06CA6:  CLRF   x65
06CA8:  CLRF   x66
06CAA:  CLRF   x67
06CAC:  CLRF   x68
06CAE:  CLRF   x69
06CB0:  CLRF   x6A
06CB2:  CLRF   x6B
06CB4:  CLRF   x6C
06CB6:  CLRF   x6D
06CB8:  CLRF   x6E
06CBA:  CLRF   x6F
06CBC:  CLRF   x70
06CBE:  CLRF   x71
06CC0:  CLRF   x72
06CC2:  CLRF   x73
06CC4:  CLRF   x74
06CC6:  CLRF   x75
06CC8:  CLRF   x76
06CCA:  CLRF   x77
06CCC:  CLRF   x78
06CCE:  CLRF   x79
06CD0:  CLRF   x7A
06CD2:  CLRF   x7B
06CD4:  CLRF   x7C
06CD6:  CLRF   x7D
06CD8:  CLRF   x7E
06CDA:  CLRF   x7F
06CDC:  CLRF   x80
06CDE:  CLRF   x81
06CE0:  CLRF   x82
06CE2:  CLRF   x83
06CE4:  CLRF   x84
06CE6:  CLRF   x85
06CE8:  CLRF   x86
06CEA:  CLRF   x87
06CEC:  CLRF   x88
06CEE:  CLRF   x89
06CF0:  CLRF   x8A
06CF2:  CLRF   x8B
06CF4:  CLRF   x8C
06CF6:  CLRF   x8D
06CF8:  CLRF   x8E
06CFA:  CLRF   x8F
06CFC:  CLRF   x90
06CFE:  CLRF   x91
06D00:  CLRF   x92
06D02:  CLRF   x93
06D04:  CLRF   x94
06D06:  CLRF   x95
06D08:  CLRF   x96
06D0A:  CLRF   x97
06D0C:  CLRF   x98
06D0E:  CLRF   x99
06D10:  CLRF   x9A
06D12:  CLRF   x9B
06D14:  CLRF   x9C
06D16:  CLRF   x9D
06D18:  CLRF   x9E
06D1A:  CLRF   x9F
06D1C:  CLRF   xA0
06D1E:  CLRF   xA1
06D20:  CLRF   xA2
06D22:  CLRF   xA3
06D24:  CLRF   xA4
06D26:  CLRF   xA5
06D28:  CLRF   xA6
06D2A:  CLRF   xA7
06D2C:  CLRF   xA8
06D2E:  CLRF   xA9
06D30:  CLRF   xAA
06D32:  CLRF   xAB
06D34:  CLRF   xAC
06D36:  CLRF   xAD
06D38:  CLRF   xAE
06D3A:  CLRF   xAF
06D3C:  CLRF   xB0
06D3E:  CLRF   xB1
06D40:  CLRF   xB2
06D42:  CLRF   xB3
06D44:  CLRF   xB4
06D46:  CLRF   xB5
06D48:  CLRF   xB6
06D4A:  CLRF   xB7
06D4C:  CLRF   xB8
06D4E:  CLRF   xB9
06D50:  CLRF   xBA
06D52:  CLRF   xBB
06D54:  CLRF   xBC
06D56:  CLRF   xBD
06D58:  CLRF   xBE
06D5A:  CLRF   xBF
06D5C:  CLRF   xC0
06D5E:  CLRF   xC1
06D60:  CLRF   xC2
06D62:  CLRF   xC3
06D64:  CLRF   xC4
06D66:  CLRF   xC5
06D68:  CLRF   xC6
06D6A:  CLRF   xC7
06D6C:  CLRF   xC8
06D6E:  CLRF   xC9
06D70:  CLRF   xCA
06D72:  CLRF   xCB
06D74:  CLRF   xCC
06D76:  CLRF   xCD
06D78:  CLRF   xCE
06D7A:  CLRF   xCF
06D7C:  CLRF   xD0
06D7E:  CLRF   xD1
06D80:  CLRF   xD2
06D82:  CLRF   xD3
06D84:  CLRF   xD4
06D86:  CLRF   xD5
06D88:  CLRF   xD6
06D8A:  CLRF   xD7
06D8C:  CLRF   xD8
06D8E:  CLRF   xD9
06D90:  CLRF   xDA
06D92:  CLRF   xDB
06D94:  CLRF   xDC
06D96:  CLRF   xDD
06D98:  CLRF   xDE
06D9A:  CLRF   xDF
06D9C:  CLRF   xE0
06D9E:  CLRF   xE1
06DA0:  CLRF   xE2
06DA2:  CLRF   xE3
06DA4:  CLRF   xE4
06DA6:  CLRF   xE5
06DA8:  CLRF   xE6
06DAA:  CLRF   xE7
06DAC:  CLRF   xE8
06DAE:  CLRF   xE9
06DB0:  CLRF   xEA
06DB2:  CLRF   xEB
06DB4:  CLRF   xEC
06DB6:  CLRF   xED
06DB8:  CLRF   xEE
06DBA:  CLRF   xEF
06DBC:  CLRF   xF0
06DBE:  CLRF   xF1
06DC0:  CLRF   xF2
06DC2:  CLRF   xF3
06DC4:  CLRF   xF4
06DC6:  CLRF   xF5
06DC8:  CLRF   xF6
06DCA:  CLRF   xF7
06DCC:  CLRF   xF8
06DCE:  CLRF   xF9
06DD0:  CLRF   xFA
06DD2:  CLRF   xFB
06DD4:  CLRF   xFC
06DD6:  CLRF   xFD
06DD8:  CLRF   xFE
06DDA:  CLRF   xFF
06DDC:  MOVLB  6
06DDE:  CLRF   x00
06DE0:  CLRF   x01
06DE2:  CLRF   x02
06DE4:  CLRF   x03
06DE6:  CLRF   x04
06DE8:  CLRF   x05
06DEA:  CLRF   x06
06DEC:  CLRF   x07
06DEE:  CLRF   x08
06DF0:  CLRF   x09
06DF2:  CLRF   x0A
06DF4:  CLRF   x0B
06DF6:  CLRF   x0C
06DF8:  CLRF   x0D
06DFA:  CLRF   x0E
06DFC:  CLRF   x0F
06DFE:  CLRF   x10
06E00:  CLRF   x11
06E02:  CLRF   x12
06E04:  CLRF   x13
06E06:  CLRF   x14
06E08:  CLRF   x15
06E0A:  CLRF   x16
06E0C:  CLRF   x17
06E0E:  CLRF   x18
06E10:  CLRF   x19
06E12:  CLRF   x1A
06E14:  CLRF   x1B
06E16:  CLRF   x1C
06E18:  CLRF   x1D
06E1A:  CLRF   x1E
06E1C:  CLRF   x1F
06E1E:  CLRF   x20
06E20:  CLRF   x21
06E22:  CLRF   x22
06E24:  CLRF   x23
06E26:  CLRF   x24
06E28:  CLRF   x25
06E2A:  CLRF   x26
06E2C:  CLRF   x27
06E2E:  CLRF   x28
06E30:  CLRF   x29
06E32:  CLRF   x2A
06E34:  CLRF   x2B
06E36:  CLRF   x2C
06E38:  CLRF   x2D
06E3A:  CLRF   x2E
06E3C:  CLRF   x2F
06E3E:  CLRF   x30
06E40:  CLRF   x31
06E42:  CLRF   x32
06E44:  CLRF   x33
06E46:  CLRF   x34
06E48:  CLRF   x35
06E4A:  CLRF   x36
06E4C:  CLRF   x37
06E4E:  CLRF   x38
06E50:  CLRF   x39
06E52:  CLRF   x3A
06E54:  CLRF   x3B
06E56:  CLRF   x3C
06E58:  CLRF   x3D
06E5A:  CLRF   x3E
06E5C:  CLRF   x3F
06E5E:  CLRF   x40
06E60:  CLRF   x41
06E62:  CLRF   x42
06E64:  CLRF   x43
06E66:  CLRF   x44
06E68:  CLRF   x45
06E6A:  CLRF   x46
06E6C:  CLRF   x47
06E6E:  CLRF   x48
06E70:  CLRF   x49
06E72:  CLRF   x4A
06E74:  CLRF   x4B
06E76:  CLRF   x4C
06E78:  CLRF   x4D
06E7A:  CLRF   x4E
06E7C:  CLRF   x4F
06E7E:  CLRF   x50
06E80:  CLRF   x51
06E82:  CLRF   x52
06E84:  CLRF   x53
06E86:  CLRF   x54
06E88:  CLRF   x55
06E8A:  CLRF   x56
06E8C:  CLRF   x57
06E8E:  CLRF   x58
06E90:  CLRF   x59
06E92:  CLRF   x5A
06E94:  CLRF   x5B
06E96:  CLRF   x5C
06E98:  CLRF   x5D
06E9A:  CLRF   x5E
06E9C:  CLRF   x5F
06E9E:  CLRF   x60
06EA0:  CLRF   x61
06EA2:  CLRF   x62
06EA4:  CLRF   x63
06EA6:  CLRF   x64
06EA8:  CLRF   x65
06EAA:  CLRF   x66
06EAC:  CLRF   x67
06EAE:  CLRF   x68
06EB0:  CLRF   x69
06EB2:  CLRF   x6A
06EB4:  CLRF   x6B
06EB6:  CLRF   x6C
06EB8:  CLRF   x6D
06EBA:  CLRF   x6E
06EBC:  CLRF   x6F
06EBE:  CLRF   x70
06EC0:  CLRF   x71
06EC2:  CLRF   x72
06EC4:  CLRF   x73
06EC6:  CLRF   x74
06EC8:  CLRF   x75
06ECA:  CLRF   x76
06ECC:  CLRF   x77
06ECE:  CLRF   x78
06ED0:  CLRF   x79
06ED2:  CLRF   x7A
06ED4:  CLRF   x7B
06ED6:  CLRF   x7C
06ED8:  CLRF   x7D
06EDA:  CLRF   x7E
06EDC:  CLRF   x7F
06EDE:  CLRF   x80
06EE0:  CLRF   x81
06EE2:  CLRF   x82
06EE4:  CLRF   x83
06EE6:  CLRF   x84
06EE8:  CLRF   x85
06EEA:  CLRF   x86
06EEC:  CLRF   x87
06EEE:  CLRF   x88
06EF0:  CLRF   x89
06EF2:  CLRF   x8A
06EF4:  CLRF   x8B
06EF6:  CLRF   x8C
06EF8:  CLRF   x8D
06EFA:  CLRF   x8E
06EFC:  CLRF   x8F
06EFE:  CLRF   x90
06F00:  CLRF   x91
06F02:  CLRF   x92
06F04:  CLRF   x93
06F06:  CLRF   x94
06F08:  CLRF   x95
06F0A:  CLRF   x96
06F0C:  CLRF   x97
06F0E:  CLRF   x98
06F10:  CLRF   x99
06F12:  CLRF   x9A
06F14:  CLRF   x9B
06F16:  CLRF   x9C
06F18:  CLRF   x9D
06F1A:  CLRF   x9E
06F1C:  CLRF   x9F
06F1E:  CLRF   xA0
06F20:  CLRF   xA1
06F22:  CLRF   xA2
06F24:  CLRF   xA3
06F26:  CLRF   xA4
06F28:  CLRF   xA5
06F2A:  CLRF   xA6
06F2C:  CLRF   xA7
06F2E:  CLRF   xA8
06F30:  CLRF   xA9
06F32:  CLRF   xAA
06F34:  CLRF   xAB
06F36:  CLRF   xAC
06F38:  CLRF   xAD
06F3A:  CLRF   xAE
06F3C:  CLRF   xAF
06F3E:  CLRF   xB0
06F40:  CLRF   xB1
06F42:  CLRF   xB2
06F44:  CLRF   xB3
06F46:  CLRF   xB4
06F48:  CLRF   xB5
06F4A:  CLRF   xB6
06F4C:  CLRF   xB7
06F4E:  CLRF   xB8
06F50:  CLRF   xB9
06F52:  CLRF   xBA
06F54:  CLRF   xBB
06F56:  CLRF   xBC
06F58:  CLRF   xBD
06F5A:  CLRF   xBE
06F5C:  CLRF   xBF
06F5E:  CLRF   xC0
06F60:  CLRF   xC1
06F62:  CLRF   xC2
06F64:  CLRF   xC3
06F66:  CLRF   xC4
06F68:  CLRF   xC5
06F6A:  CLRF   xC6
06F6C:  CLRF   xC7
06F6E:  CLRF   xC8
06F70:  CLRF   xC9
06F72:  CLRF   xCA
06F74:  CLRF   xCB
06F76:  CLRF   xCC
06F78:  CLRF   xCD
06F7A:  CLRF   xCE
06F7C:  CLRF   xCF
06F7E:  CLRF   xD0
06F80:  CLRF   xD1
06F82:  CLRF   xD2
06F84:  CLRF   xD3
06F86:  CLRF   xD4
06F88:  CLRF   xD5
06F8A:  CLRF   xD6
06F8C:  CLRF   xD7
06F8E:  CLRF   xD8
06F90:  CLRF   xD9
06F92:  CLRF   xDA
06F94:  CLRF   xDB
06F96:  CLRF   xDC
06F98:  CLRF   xDD
06F9A:  CLRF   xDE
06F9C:  CLRF   xDF
06F9E:  CLRF   xE0
06FA0:  CLRF   xE1
06FA2:  CLRF   xE2
06FA4:  CLRF   xE3
06FA6:  CLRF   xE4
06FA8:  CLRF   xE5
06FAA:  CLRF   xE6
06FAC:  CLRF   xE7
06FAE:  CLRF   xE8
06FB0:  CLRF   xE9
06FB2:  CLRF   xEA
06FB4:  CLRF   xEB
06FB6:  CLRF   xEC
06FB8:  CLRF   xED
06FBA:  CLRF   xEE
06FBC:  CLRF   xEF
06FBE:  CLRF   xF0
06FC0:  CLRF   xF1
06FC2:  CLRF   xF2
06FC4:  CLRF   xF3
06FC6:  CLRF   xF4
06FC8:  CLRF   xF5
06FCA:  CLRF   xF6
06FCC:  CLRF   xF7
06FCE:  CLRF   xF8
06FD0:  CLRF   xF9
06FD2:  CLRF   xFA
06FD4:  CLRF   xFB
06FD6:  CLRF   xFC
06FD8:  CLRF   xFD
06FDA:  CLRF   xFE
06FDC:  CLRF   xFF
06FDE:  MOVLB  7
06FE0:  CLRF   x00
06FE2:  CLRF   x01
06FE4:  CLRF   x02
06FE6:  CLRF   x03
06FE8:  CLRF   x04
06FEA:  CLRF   x05
06FEC:  CLRF   x06
06FEE:  CLRF   x07
06FF0:  CLRF   x08
06FF2:  CLRF   x09
06FF4:  CLRF   x0A
06FF6:  CLRF   x0B
06FF8:  CLRF   x0C
06FFA:  CLRF   x0D
06FFC:  CLRF   x0E
06FFE:  CLRF   x0F
07000:  CLRF   x10
07002:  CLRF   x11
07004:  CLRF   x12
07006:  CLRF   x13
07008:  CLRF   x14
0700A:  CLRF   x15
0700C:  CLRF   x16
0700E:  CLRF   x17
07010:  CLRF   x18
07012:  CLRF   x19
07014:  CLRF   x1A
07016:  CLRF   x1B
07018:  CLRF   x1C
0701A:  CLRF   x1D
0701C:  CLRF   x1E
0701E:  CLRF   x1F
07020:  CLRF   x20
07022:  CLRF   x21
07024:  CLRF   x22
07026:  CLRF   x23
07028:  CLRF   x24
0702A:  CLRF   x25
0702C:  CLRF   x26
0702E:  CLRF   x27
07030:  CLRF   x28
07032:  CLRF   x29
07034:  CLRF   x2A
07036:  CLRF   x2B
07038:  CLRF   x2C
0703A:  CLRF   x2D
0703C:  CLRF   x2E
0703E:  CLRF   x2F
07040:  CLRF   x30
07042:  CLRF   x31
07044:  CLRF   x32
07046:  CLRF   x33
07048:  CLRF   x34
0704A:  CLRF   x35
0704C:  CLRF   x36
0704E:  CLRF   x37
07050:  CLRF   x38
07052:  CLRF   x39
07054:  CLRF   x3A
07056:  CLRF   x3B
07058:  CLRF   x3C
0705A:  CLRF   x3D
0705C:  CLRF   x3E
0705E:  CLRF   x3F
07060:  CLRF   x40
07062:  CLRF   x41
07064:  CLRF   x42
07066:  CLRF   x43
07068:  CLRF   x44
0706A:  CLRF   x45
0706C:  CLRF   x46
0706E:  CLRF   x47
07070:  CLRF   x48
07072:  CLRF   x49
07074:  CLRF   x4A
07076:  CLRF   x4B
07078:  CLRF   x4C
0707A:  CLRF   x4D
0707C:  CLRF   x4E
0707E:  CLRF   x4F
07080:  CLRF   x50
07082:  CLRF   x51
07084:  CLRF   x52
07086:  CLRF   x53
07088:  CLRF   x54
0708A:  CLRF   x55
0708C:  CLRF   x56
0708E:  CLRF   x57
07090:  CLRF   x58
07092:  CLRF   x59
07094:  CLRF   x5A
07096:  CLRF   x5B
07098:  CLRF   x5C
0709A:  CLRF   x5D
0709C:  CLRF   x5E
0709E:  CLRF   x5F
070A0:  CLRF   x60
070A2:  CLRF   x61
070A4:  CLRF   x62
070A6:  CLRF   x63
070A8:  CLRF   x64
070AA:  CLRF   x65
070AC:  CLRF   x66
070AE:  CLRF   x67
070B0:  CLRF   x68
070B2:  CLRF   x69
070B4:  CLRF   x6A
070B6:  CLRF   x6B
070B8:  CLRF   x6C
070BA:  CLRF   x6D
070BC:  CLRF   x6E
070BE:  CLRF   x6F
070C0:  CLRF   x70
070C2:  CLRF   x71
070C4:  CLRF   x72
070C6:  CLRF   x73
070C8:  CLRF   x74
070CA:  CLRF   x75
070CC:  CLRF   x76
070CE:  CLRF   x77
070D0:  CLRF   x78
070D2:  CLRF   x79
070D4:  CLRF   x7A
070D6:  CLRF   x7B
070D8:  CLRF   x7C
070DA:  CLRF   x7D
070DC:  CLRF   x7E
070DE:  CLRF   x7F
070E0:  CLRF   x80
070E2:  CLRF   x81
070E4:  CLRF   x82
070E6:  CLRF   x83
070E8:  CLRF   x84
070EA:  CLRF   x85
070EC:  CLRF   x86
070EE:  CLRF   x87
070F0:  CLRF   x88
070F2:  CLRF   x89
070F4:  CLRF   x8A
070F6:  CLRF   x8B
070F8:  CLRF   x8C
070FA:  CLRF   x8D
070FC:  CLRF   x8E
070FE:  CLRF   x8F
07100:  CLRF   x90
07102:  CLRF   x91
07104:  CLRF   x92
07106:  CLRF   x93
07108:  CLRF   x94
0710A:  CLRF   x95
0710C:  CLRF   x96
0710E:  CLRF   x97
07110:  CLRF   x98
07112:  CLRF   x99
07114:  CLRF   x9A
07116:  CLRF   x9B
07118:  CLRF   x9C
0711A:  CLRF   x9D
0711C:  CLRF   x9E
0711E:  CLRF   x9F
07120:  CLRF   xA0
07122:  CLRF   xA1
07124:  CLRF   xA2
07126:  CLRF   xA3
07128:  CLRF   xA4
0712A:  CLRF   xA5
0712C:  CLRF   xA6
0712E:  CLRF   xA7
07130:  CLRF   xA8
07132:  CLRF   xA9
07134:  CLRF   xAA
07136:  CLRF   xAB
....................     port1.port_num = 1;
07138:  MOVLW  01
0713A:  MOVLB  3
0713C:  MOVWF  xAC
....................     port1.sweep_step = 0;
0713E:  CLRF   xAE
07140:  CLRF   xAD
....................     port1.active = 1;
07142:  MOVLB  7
07144:  BSF    xAB.0
.................... 
....................     // Init Port2
....................     SWEEP_CONFIG port2 = {0};
07146:  CLRF   xAC
07148:  CLRF   xAD
0714A:  CLRF   xAE
0714C:  CLRF   xAF
0714E:  CLRF   xB0
07150:  CLRF   xB1
07152:  CLRF   xB2
07154:  CLRF   xB3
07156:  CLRF   xB4
07158:  CLRF   xB5
0715A:  CLRF   xB6
0715C:  CLRF   xB7
0715E:  CLRF   xB8
07160:  CLRF   xB9
07162:  CLRF   xBA
07164:  CLRF   xBB
07166:  CLRF   xBC
07168:  CLRF   xBD
0716A:  CLRF   xBE
0716C:  CLRF   xBF
0716E:  CLRF   xC0
07170:  CLRF   xC1
07172:  CLRF   xC2
07174:  CLRF   xC3
07176:  CLRF   xC4
07178:  CLRF   xC5
0717A:  CLRF   xC6
0717C:  CLRF   xC7
0717E:  CLRF   xC8
07180:  CLRF   xC9
07182:  CLRF   xCA
07184:  CLRF   xCB
07186:  CLRF   xCC
07188:  CLRF   xCD
0718A:  CLRF   xCE
0718C:  CLRF   xCF
0718E:  CLRF   xD0
07190:  CLRF   xD1
07192:  CLRF   xD2
07194:  CLRF   xD3
07196:  CLRF   xD4
07198:  CLRF   xD5
0719A:  CLRF   xD6
0719C:  CLRF   xD7
0719E:  CLRF   xD8
071A0:  CLRF   xD9
071A2:  CLRF   xDA
071A4:  CLRF   xDB
071A6:  CLRF   xDC
071A8:  CLRF   xDD
071AA:  CLRF   xDE
071AC:  CLRF   xDF
071AE:  CLRF   xE0
071B0:  CLRF   xE1
071B2:  CLRF   xE2
071B4:  CLRF   xE3
071B6:  CLRF   xE4
071B8:  CLRF   xE5
071BA:  CLRF   xE6
071BC:  CLRF   xE7
071BE:  CLRF   xE8
071C0:  CLRF   xE9
071C2:  CLRF   xEA
071C4:  CLRF   xEB
071C6:  CLRF   xEC
071C8:  CLRF   xED
071CA:  CLRF   xEE
071CC:  CLRF   xEF
071CE:  CLRF   xF0
071D0:  CLRF   xF1
071D2:  CLRF   xF2
071D4:  CLRF   xF3
071D6:  CLRF   xF4
071D8:  CLRF   xF5
071DA:  CLRF   xF6
071DC:  CLRF   xF7
071DE:  CLRF   xF8
071E0:  CLRF   xF9
071E2:  CLRF   xFA
071E4:  CLRF   xFB
071E6:  CLRF   xFC
071E8:  CLRF   xFD
071EA:  CLRF   xFE
071EC:  CLRF   xFF
071EE:  MOVLB  8
071F0:  CLRF   x00
071F2:  CLRF   x01
071F4:  CLRF   x02
071F6:  CLRF   x03
071F8:  CLRF   x04
071FA:  CLRF   x05
071FC:  CLRF   x06
071FE:  CLRF   x07
07200:  CLRF   x08
07202:  CLRF   x09
07204:  CLRF   x0A
07206:  CLRF   x0B
07208:  CLRF   x0C
0720A:  CLRF   x0D
0720C:  CLRF   x0E
0720E:  CLRF   x0F
07210:  CLRF   x10
07212:  CLRF   x11
07214:  CLRF   x12
07216:  CLRF   x13
07218:  CLRF   x14
0721A:  CLRF   x15
0721C:  CLRF   x16
0721E:  CLRF   x17
07220:  CLRF   x18
07222:  CLRF   x19
07224:  CLRF   x1A
07226:  CLRF   x1B
07228:  CLRF   x1C
0722A:  CLRF   x1D
0722C:  CLRF   x1E
0722E:  CLRF   x1F
07230:  CLRF   x20
07232:  CLRF   x21
07234:  CLRF   x22
07236:  CLRF   x23
07238:  CLRF   x24
0723A:  CLRF   x25
0723C:  CLRF   x26
0723E:  CLRF   x27
07240:  CLRF   x28
07242:  CLRF   x29
07244:  CLRF   x2A
07246:  CLRF   x2B
07248:  CLRF   x2C
0724A:  CLRF   x2D
0724C:  CLRF   x2E
0724E:  CLRF   x2F
07250:  CLRF   x30
07252:  CLRF   x31
07254:  CLRF   x32
07256:  CLRF   x33
07258:  CLRF   x34
0725A:  CLRF   x35
0725C:  CLRF   x36
0725E:  CLRF   x37
07260:  CLRF   x38
07262:  CLRF   x39
07264:  CLRF   x3A
07266:  CLRF   x3B
07268:  CLRF   x3C
0726A:  CLRF   x3D
0726C:  CLRF   x3E
0726E:  CLRF   x3F
07270:  CLRF   x40
07272:  CLRF   x41
07274:  CLRF   x42
07276:  CLRF   x43
07278:  CLRF   x44
0727A:  CLRF   x45
0727C:  CLRF   x46
0727E:  CLRF   x47
07280:  CLRF   x48
07282:  CLRF   x49
07284:  CLRF   x4A
07286:  CLRF   x4B
07288:  CLRF   x4C
0728A:  CLRF   x4D
0728C:  CLRF   x4E
0728E:  CLRF   x4F
07290:  CLRF   x50
07292:  CLRF   x51
07294:  CLRF   x52
07296:  CLRF   x53
07298:  CLRF   x54
0729A:  CLRF   x55
0729C:  CLRF   x56
0729E:  CLRF   x57
072A0:  CLRF   x58
072A2:  CLRF   x59
072A4:  CLRF   x5A
072A6:  CLRF   x5B
072A8:  CLRF   x5C
072AA:  CLRF   x5D
072AC:  CLRF   x5E
072AE:  CLRF   x5F
072B0:  CLRF   x60
072B2:  CLRF   x61
072B4:  CLRF   x62
072B6:  CLRF   x63
072B8:  CLRF   x64
072BA:  CLRF   x65
072BC:  CLRF   x66
072BE:  CLRF   x67
072C0:  CLRF   x68
072C2:  CLRF   x69
072C4:  CLRF   x6A
072C6:  CLRF   x6B
072C8:  CLRF   x6C
072CA:  CLRF   x6D
072CC:  CLRF   x6E
072CE:  CLRF   x6F
072D0:  CLRF   x70
072D2:  CLRF   x71
072D4:  CLRF   x72
072D6:  CLRF   x73
072D8:  CLRF   x74
072DA:  CLRF   x75
072DC:  CLRF   x76
072DE:  CLRF   x77
072E0:  CLRF   x78
072E2:  CLRF   x79
072E4:  CLRF   x7A
072E6:  CLRF   x7B
072E8:  CLRF   x7C
072EA:  CLRF   x7D
072EC:  CLRF   x7E
072EE:  CLRF   x7F
072F0:  CLRF   x80
072F2:  CLRF   x81
072F4:  CLRF   x82
072F6:  CLRF   x83
072F8:  CLRF   x84
072FA:  CLRF   x85
072FC:  CLRF   x86
072FE:  CLRF   x87
07300:  CLRF   x88
07302:  CLRF   x89
07304:  CLRF   x8A
07306:  CLRF   x8B
07308:  CLRF   x8C
0730A:  CLRF   x8D
0730C:  CLRF   x8E
0730E:  CLRF   x8F
07310:  CLRF   x90
07312:  CLRF   x91
07314:  CLRF   x92
07316:  CLRF   x93
07318:  CLRF   x94
0731A:  CLRF   x95
0731C:  CLRF   x96
0731E:  CLRF   x97
07320:  CLRF   x98
07322:  CLRF   x99
07324:  CLRF   x9A
07326:  CLRF   x9B
07328:  CLRF   x9C
0732A:  CLRF   x9D
0732C:  CLRF   x9E
0732E:  CLRF   x9F
07330:  CLRF   xA0
07332:  CLRF   xA1
07334:  CLRF   xA2
07336:  CLRF   xA3
07338:  CLRF   xA4
0733A:  CLRF   xA5
0733C:  CLRF   xA6
0733E:  CLRF   xA7
07340:  CLRF   xA8
07342:  CLRF   xA9
07344:  CLRF   xAA
07346:  CLRF   xAB
07348:  CLRF   xAC
0734A:  CLRF   xAD
0734C:  CLRF   xAE
0734E:  CLRF   xAF
07350:  CLRF   xB0
07352:  CLRF   xB1
07354:  CLRF   xB2
07356:  CLRF   xB3
07358:  CLRF   xB4
0735A:  CLRF   xB5
0735C:  CLRF   xB6
0735E:  CLRF   xB7
07360:  CLRF   xB8
07362:  CLRF   xB9
07364:  CLRF   xBA
07366:  CLRF   xBB
07368:  CLRF   xBC
0736A:  CLRF   xBD
0736C:  CLRF   xBE
0736E:  CLRF   xBF
07370:  CLRF   xC0
07372:  CLRF   xC1
07374:  CLRF   xC2
07376:  CLRF   xC3
07378:  CLRF   xC4
0737A:  CLRF   xC5
0737C:  CLRF   xC6
0737E:  CLRF   xC7
07380:  CLRF   xC8
07382:  CLRF   xC9
07384:  CLRF   xCA
07386:  CLRF   xCB
07388:  CLRF   xCC
0738A:  CLRF   xCD
0738C:  CLRF   xCE
0738E:  CLRF   xCF
07390:  CLRF   xD0
07392:  CLRF   xD1
07394:  CLRF   xD2
07396:  CLRF   xD3
07398:  CLRF   xD4
0739A:  CLRF   xD5
0739C:  CLRF   xD6
0739E:  CLRF   xD7
073A0:  CLRF   xD8
073A2:  CLRF   xD9
073A4:  CLRF   xDA
073A6:  CLRF   xDB
073A8:  CLRF   xDC
073AA:  CLRF   xDD
073AC:  CLRF   xDE
073AE:  CLRF   xDF
073B0:  CLRF   xE0
073B2:  CLRF   xE1
073B4:  CLRF   xE2
073B6:  CLRF   xE3
073B8:  CLRF   xE4
073BA:  CLRF   xE5
073BC:  CLRF   xE6
073BE:  CLRF   xE7
073C0:  CLRF   xE8
073C2:  CLRF   xE9
073C4:  CLRF   xEA
073C6:  CLRF   xEB
073C8:  CLRF   xEC
073CA:  CLRF   xED
073CC:  CLRF   xEE
073CE:  CLRF   xEF
073D0:  CLRF   xF0
073D2:  CLRF   xF1
073D4:  CLRF   xF2
073D6:  CLRF   xF3
073D8:  CLRF   xF4
073DA:  CLRF   xF5
073DC:  CLRF   xF6
073DE:  CLRF   xF7
073E0:  CLRF   xF8
073E2:  CLRF   xF9
073E4:  CLRF   xFA
073E6:  CLRF   xFB
073E8:  CLRF   xFC
073EA:  CLRF   xFD
073EC:  CLRF   xFE
073EE:  CLRF   xFF
073F0:  MOVLB  9
073F2:  CLRF   x00
073F4:  CLRF   x01
073F6:  CLRF   x02
073F8:  CLRF   x03
073FA:  CLRF   x04
073FC:  CLRF   x05
073FE:  CLRF   x06
07400:  CLRF   x07
07402:  CLRF   x08
07404:  CLRF   x09
07406:  CLRF   x0A
07408:  CLRF   x0B
0740A:  CLRF   x0C
0740C:  CLRF   x0D
0740E:  CLRF   x0E
07410:  CLRF   x0F
07412:  CLRF   x10
07414:  CLRF   x11
07416:  CLRF   x12
07418:  CLRF   x13
0741A:  CLRF   x14
0741C:  CLRF   x15
0741E:  CLRF   x16
07420:  CLRF   x17
07422:  CLRF   x18
07424:  CLRF   x19
07426:  CLRF   x1A
07428:  CLRF   x1B
0742A:  CLRF   x1C
0742C:  CLRF   x1D
0742E:  CLRF   x1E
07430:  CLRF   x1F
07432:  CLRF   x20
07434:  CLRF   x21
07436:  CLRF   x22
07438:  CLRF   x23
0743A:  CLRF   x24
0743C:  CLRF   x25
0743E:  CLRF   x26
07440:  CLRF   x27
07442:  CLRF   x28
07444:  CLRF   x29
07446:  CLRF   x2A
07448:  CLRF   x2B
0744A:  CLRF   x2C
0744C:  CLRF   x2D
0744E:  CLRF   x2E
07450:  CLRF   x2F
07452:  CLRF   x30
07454:  CLRF   x31
07456:  CLRF   x32
07458:  CLRF   x33
0745A:  CLRF   x34
0745C:  CLRF   x35
0745E:  CLRF   x36
07460:  CLRF   x37
07462:  CLRF   x38
07464:  CLRF   x39
07466:  CLRF   x3A
07468:  CLRF   x3B
0746A:  CLRF   x3C
0746C:  CLRF   x3D
0746E:  CLRF   x3E
07470:  CLRF   x3F
07472:  CLRF   x40
07474:  CLRF   x41
07476:  CLRF   x42
07478:  CLRF   x43
0747A:  CLRF   x44
0747C:  CLRF   x45
0747E:  CLRF   x46
07480:  CLRF   x47
07482:  CLRF   x48
07484:  CLRF   x49
07486:  CLRF   x4A
07488:  CLRF   x4B
0748A:  CLRF   x4C
0748C:  CLRF   x4D
0748E:  CLRF   x4E
07490:  CLRF   x4F
07492:  CLRF   x50
07494:  CLRF   x51
07496:  CLRF   x52
07498:  CLRF   x53
0749A:  CLRF   x54
0749C:  CLRF   x55
0749E:  CLRF   x56
074A0:  CLRF   x57
074A2:  CLRF   x58
074A4:  CLRF   x59
074A6:  CLRF   x5A
074A8:  CLRF   x5B
074AA:  CLRF   x5C
074AC:  CLRF   x5D
074AE:  CLRF   x5E
074B0:  CLRF   x5F
074B2:  CLRF   x60
074B4:  CLRF   x61
074B6:  CLRF   x62
074B8:  CLRF   x63
074BA:  CLRF   x64
074BC:  CLRF   x65
074BE:  CLRF   x66
074C0:  CLRF   x67
074C2:  CLRF   x68
074C4:  CLRF   x69
074C6:  CLRF   x6A
074C8:  CLRF   x6B
074CA:  CLRF   x6C
074CC:  CLRF   x6D
074CE:  CLRF   x6E
074D0:  CLRF   x6F
074D2:  CLRF   x70
074D4:  CLRF   x71
074D6:  CLRF   x72
074D8:  CLRF   x73
074DA:  CLRF   x74
074DC:  CLRF   x75
074DE:  CLRF   x76
074E0:  CLRF   x77
074E2:  CLRF   x78
074E4:  CLRF   x79
074E6:  CLRF   x7A
074E8:  CLRF   x7B
074EA:  CLRF   x7C
074EC:  CLRF   x7D
074EE:  CLRF   x7E
074F0:  CLRF   x7F
074F2:  CLRF   x80
074F4:  CLRF   x81
074F6:  CLRF   x82
074F8:  CLRF   x83
074FA:  CLRF   x84
074FC:  CLRF   x85
074FE:  CLRF   x86
07500:  CLRF   x87
07502:  CLRF   x88
07504:  CLRF   x89
07506:  CLRF   x8A
07508:  CLRF   x8B
0750A:  CLRF   x8C
0750C:  CLRF   x8D
0750E:  CLRF   x8E
07510:  CLRF   x8F
07512:  CLRF   x90
07514:  CLRF   x91
07516:  CLRF   x92
07518:  CLRF   x93
0751A:  CLRF   x94
0751C:  CLRF   x95
0751E:  CLRF   x96
07520:  CLRF   x97
07522:  CLRF   x98
07524:  CLRF   x99
07526:  CLRF   x9A
07528:  CLRF   x9B
0752A:  CLRF   x9C
0752C:  CLRF   x9D
0752E:  CLRF   x9E
07530:  CLRF   x9F
07532:  CLRF   xA0
07534:  CLRF   xA1
07536:  CLRF   xA2
07538:  CLRF   xA3
0753A:  CLRF   xA4
0753C:  CLRF   xA5
0753E:  CLRF   xA6
07540:  CLRF   xA7
07542:  CLRF   xA8
07544:  CLRF   xA9
07546:  CLRF   xAA
07548:  CLRF   xAB
0754A:  CLRF   xAC
0754C:  CLRF   xAD
0754E:  CLRF   xAE
07550:  CLRF   xAF
07552:  CLRF   xB0
07554:  CLRF   xB1
07556:  CLRF   xB2
07558:  CLRF   xB3
0755A:  CLRF   xB4
0755C:  CLRF   xB5
0755E:  CLRF   xB6
07560:  CLRF   xB7
07562:  CLRF   xB8
07564:  CLRF   xB9
07566:  CLRF   xBA
07568:  CLRF   xBB
0756A:  CLRF   xBC
0756C:  CLRF   xBD
0756E:  CLRF   xBE
07570:  CLRF   xBF
07572:  CLRF   xC0
07574:  CLRF   xC1
07576:  CLRF   xC2
07578:  CLRF   xC3
0757A:  CLRF   xC4
0757C:  CLRF   xC5
0757E:  CLRF   xC6
07580:  CLRF   xC7
07582:  CLRF   xC8
07584:  CLRF   xC9
07586:  CLRF   xCA
07588:  CLRF   xCB
0758A:  CLRF   xCC
0758C:  CLRF   xCD
0758E:  CLRF   xCE
07590:  CLRF   xCF
07592:  CLRF   xD0
07594:  CLRF   xD1
07596:  CLRF   xD2
07598:  CLRF   xD3
0759A:  CLRF   xD4
0759C:  CLRF   xD5
0759E:  CLRF   xD6
075A0:  CLRF   xD7
075A2:  CLRF   xD8
075A4:  CLRF   xD9
075A6:  CLRF   xDA
075A8:  CLRF   xDB
075AA:  CLRF   xDC
075AC:  CLRF   xDD
075AE:  CLRF   xDE
075B0:  CLRF   xDF
075B2:  CLRF   xE0
075B4:  CLRF   xE1
075B6:  CLRF   xE2
075B8:  CLRF   xE3
075BA:  CLRF   xE4
075BC:  CLRF   xE5
075BE:  CLRF   xE6
075C0:  CLRF   xE7
075C2:  CLRF   xE8
075C4:  CLRF   xE9
075C6:  CLRF   xEA
075C8:  CLRF   xEB
075CA:  CLRF   xEC
075CC:  CLRF   xED
075CE:  CLRF   xEE
075D0:  CLRF   xEF
075D2:  CLRF   xF0
075D4:  CLRF   xF1
075D6:  CLRF   xF2
075D8:  CLRF   xF3
075DA:  CLRF   xF4
075DC:  CLRF   xF5
075DE:  CLRF   xF6
075E0:  CLRF   xF7
075E2:  CLRF   xF8
075E4:  CLRF   xF9
075E6:  CLRF   xFA
075E8:  CLRF   xFB
075EA:  CLRF   xFC
075EC:  CLRF   xFD
075EE:  CLRF   xFE
075F0:  CLRF   xFF
075F2:  MOVLB  A
075F4:  CLRF   x00
075F6:  CLRF   x01
075F8:  CLRF   x02
075FA:  CLRF   x03
075FC:  CLRF   x04
075FE:  CLRF   x05
07600:  CLRF   x06
07602:  CLRF   x07
07604:  CLRF   x08
07606:  CLRF   x09
07608:  CLRF   x0A
0760A:  CLRF   x0B
0760C:  CLRF   x0C
0760E:  CLRF   x0D
07610:  CLRF   x0E
07612:  CLRF   x0F
07614:  CLRF   x10
07616:  CLRF   x11
07618:  CLRF   x12
0761A:  CLRF   x13
0761C:  CLRF   x14
0761E:  CLRF   x15
07620:  CLRF   x16
07622:  CLRF   x17
07624:  CLRF   x18
07626:  CLRF   x19
07628:  CLRF   x1A
0762A:  CLRF   x1B
0762C:  CLRF   x1C
0762E:  CLRF   x1D
07630:  CLRF   x1E
07632:  CLRF   x1F
07634:  CLRF   x20
07636:  CLRF   x21
07638:  CLRF   x22
0763A:  CLRF   x23
0763C:  CLRF   x24
0763E:  CLRF   x25
07640:  CLRF   x26
07642:  CLRF   x27
07644:  CLRF   x28
07646:  CLRF   x29
07648:  CLRF   x2A
0764A:  CLRF   x2B
0764C:  CLRF   x2C
0764E:  CLRF   x2D
07650:  CLRF   x2E
07652:  CLRF   x2F
07654:  CLRF   x30
07656:  CLRF   x31
07658:  CLRF   x32
0765A:  CLRF   x33
0765C:  CLRF   x34
0765E:  CLRF   x35
07660:  CLRF   x36
07662:  CLRF   x37
07664:  CLRF   x38
07666:  CLRF   x39
07668:  CLRF   x3A
0766A:  CLRF   x3B
0766C:  CLRF   x3C
0766E:  CLRF   x3D
07670:  CLRF   x3E
07672:  CLRF   x3F
07674:  CLRF   x40
07676:  CLRF   x41
07678:  CLRF   x42
0767A:  CLRF   x43
0767C:  CLRF   x44
0767E:  CLRF   x45
07680:  CLRF   x46
07682:  CLRF   x47
07684:  CLRF   x48
07686:  CLRF   x49
07688:  CLRF   x4A
0768A:  CLRF   x4B
0768C:  CLRF   x4C
0768E:  CLRF   x4D
07690:  CLRF   x4E
07692:  CLRF   x4F
07694:  CLRF   x50
07696:  CLRF   x51
07698:  CLRF   x52
0769A:  CLRF   x53
0769C:  CLRF   x54
0769E:  CLRF   x55
076A0:  CLRF   x56
076A2:  CLRF   x57
076A4:  CLRF   x58
076A6:  CLRF   x59
076A8:  CLRF   x5A
076AA:  CLRF   x5B
076AC:  CLRF   x5C
076AE:  CLRF   x5D
076B0:  CLRF   x5E
076B2:  CLRF   x5F
076B4:  CLRF   x60
076B6:  CLRF   x61
076B8:  CLRF   x62
076BA:  CLRF   x63
076BC:  CLRF   x64
076BE:  CLRF   x65
076C0:  CLRF   x66
076C2:  CLRF   x67
076C4:  CLRF   x68
076C6:  CLRF   x69
076C8:  CLRF   x6A
076CA:  CLRF   x6B
076CC:  CLRF   x6C
076CE:  CLRF   x6D
076D0:  CLRF   x6E
076D2:  CLRF   x6F
076D4:  CLRF   x70
076D6:  CLRF   x71
076D8:  CLRF   x72
076DA:  CLRF   x73
076DC:  CLRF   x74
076DE:  CLRF   x75
076E0:  CLRF   x76
076E2:  CLRF   x77
076E4:  CLRF   x78
076E6:  CLRF   x79
076E8:  CLRF   x7A
076EA:  CLRF   x7B
076EC:  CLRF   x7C
076EE:  CLRF   x7D
076F0:  CLRF   x7E
076F2:  CLRF   x7F
076F4:  CLRF   x80
076F6:  CLRF   x81
076F8:  CLRF   x82
076FA:  CLRF   x83
076FC:  CLRF   x84
076FE:  CLRF   x85
07700:  CLRF   x86
07702:  CLRF   x87
07704:  CLRF   x88
07706:  CLRF   x89
07708:  CLRF   x8A
0770A:  CLRF   x8B
0770C:  CLRF   x8C
0770E:  CLRF   x8D
07710:  CLRF   x8E
07712:  CLRF   x8F
07714:  CLRF   x90
07716:  CLRF   x91
07718:  CLRF   x92
0771A:  CLRF   x93
0771C:  CLRF   x94
0771E:  CLRF   x95
07720:  CLRF   x96
07722:  CLRF   x97
07724:  CLRF   x98
07726:  CLRF   x99
07728:  CLRF   x9A
0772A:  CLRF   x9B
0772C:  CLRF   x9C
0772E:  CLRF   x9D
07730:  CLRF   x9E
07732:  CLRF   x9F
07734:  CLRF   xA0
07736:  CLRF   xA1
07738:  CLRF   xA2
0773A:  CLRF   xA3
0773C:  CLRF   xA4
0773E:  CLRF   xA5
07740:  CLRF   xA6
07742:  CLRF   xA7
07744:  CLRF   xA8
07746:  CLRF   xA9
07748:  CLRF   xAA
0774A:  CLRF   xAB
0774C:  CLRF   xAC
0774E:  CLRF   xAD
07750:  CLRF   xAE
07752:  CLRF   xAF
07754:  CLRF   xB0
07756:  CLRF   xB1
07758:  CLRF   xB2
0775A:  CLRF   xB3
0775C:  CLRF   xB4
0775E:  CLRF   xB5
07760:  CLRF   xB6
07762:  CLRF   xB7
07764:  CLRF   xB8
07766:  CLRF   xB9
07768:  CLRF   xBA
0776A:  CLRF   xBB
0776C:  CLRF   xBC
0776E:  CLRF   xBD
07770:  CLRF   xBE
07772:  CLRF   xBF
07774:  CLRF   xC0
07776:  CLRF   xC1
07778:  CLRF   xC2
0777A:  CLRF   xC3
0777C:  CLRF   xC4
0777E:  CLRF   xC5
07780:  CLRF   xC6
07782:  CLRF   xC7
07784:  CLRF   xC8
07786:  CLRF   xC9
07788:  CLRF   xCA
0778A:  CLRF   xCB
0778C:  CLRF   xCC
0778E:  CLRF   xCD
07790:  CLRF   xCE
07792:  CLRF   xCF
07794:  CLRF   xD0
07796:  CLRF   xD1
07798:  CLRF   xD2
0779A:  CLRF   xD3
0779C:  CLRF   xD4
0779E:  CLRF   xD5
077A0:  CLRF   xD6
077A2:  CLRF   xD7
077A4:  CLRF   xD8
077A6:  CLRF   xD9
077A8:  CLRF   xDA
077AA:  CLRF   xDB
077AC:  CLRF   xDC
077AE:  CLRF   xDD
077B0:  CLRF   xDE
077B2:  CLRF   xDF
077B4:  CLRF   xE0
077B6:  CLRF   xE1
077B8:  CLRF   xE2
077BA:  CLRF   xE3
077BC:  CLRF   xE4
077BE:  CLRF   xE5
077C0:  CLRF   xE6
077C2:  CLRF   xE7
077C4:  CLRF   xE8
077C6:  CLRF   xE9
077C8:  CLRF   xEA
077CA:  CLRF   xEB
077CC:  CLRF   xEC
077CE:  CLRF   xED
077D0:  CLRF   xEE
077D2:  CLRF   xEF
077D4:  CLRF   xF0
077D6:  CLRF   xF1
077D8:  CLRF   xF2
077DA:  CLRF   xF3
077DC:  CLRF   xF4
077DE:  CLRF   xF5
077E0:  CLRF   xF6
077E2:  CLRF   xF7
077E4:  CLRF   xF8
077E6:  CLRF   xF9
077E8:  CLRF   xFA
077EA:  CLRF   xFB
077EC:  CLRF   xFC
077EE:  CLRF   xFD
077F0:  CLRF   xFE
077F2:  CLRF   xFF
077F4:  MOVLB  B
077F6:  CLRF   x00
077F8:  CLRF   x01
077FA:  CLRF   x02
077FC:  CLRF   x03
077FE:  CLRF   x04
07800:  CLRF   x05
07802:  CLRF   x06
07804:  CLRF   x07
07806:  CLRF   x08
07808:  CLRF   x09
0780A:  CLRF   x0A
0780C:  CLRF   x0B
0780E:  CLRF   x0C
07810:  CLRF   x0D
07812:  CLRF   x0E
07814:  CLRF   x0F
07816:  CLRF   x10
07818:  CLRF   x11
0781A:  CLRF   x12
0781C:  CLRF   x13
0781E:  CLRF   x14
07820:  CLRF   x15
07822:  CLRF   x16
07824:  CLRF   x17
07826:  CLRF   x18
07828:  CLRF   x19
0782A:  CLRF   x1A
0782C:  CLRF   x1B
0782E:  CLRF   x1C
07830:  CLRF   x1D
07832:  CLRF   x1E
07834:  CLRF   x1F
07836:  CLRF   x20
07838:  CLRF   x21
0783A:  CLRF   x22
0783C:  CLRF   x23
0783E:  CLRF   x24
07840:  CLRF   x25
07842:  CLRF   x26
07844:  CLRF   x27
07846:  CLRF   x28
07848:  CLRF   x29
0784A:  CLRF   x2A
0784C:  CLRF   x2B
0784E:  CLRF   x2C
07850:  CLRF   x2D
07852:  CLRF   x2E
07854:  CLRF   x2F
07856:  CLRF   x30
07858:  CLRF   x31
0785A:  CLRF   x32
0785C:  CLRF   x33
0785E:  CLRF   x34
07860:  CLRF   x35
07862:  CLRF   x36
07864:  CLRF   x37
07866:  CLRF   x38
07868:  CLRF   x39
0786A:  CLRF   x3A
0786C:  CLRF   x3B
0786E:  CLRF   x3C
07870:  CLRF   x3D
07872:  CLRF   x3E
07874:  CLRF   x3F
07876:  CLRF   x40
07878:  CLRF   x41
0787A:  CLRF   x42
0787C:  CLRF   x43
0787E:  CLRF   x44
07880:  CLRF   x45
07882:  CLRF   x46
07884:  CLRF   x47
07886:  CLRF   x48
07888:  CLRF   x49
0788A:  CLRF   x4A
0788C:  CLRF   x4B
0788E:  CLRF   x4C
07890:  CLRF   x4D
07892:  CLRF   x4E
07894:  CLRF   x4F
07896:  CLRF   x50
07898:  CLRF   x51
0789A:  CLRF   x52
0789C:  CLRF   x53
0789E:  CLRF   x54
078A0:  CLRF   x55
078A2:  CLRF   x56
078A4:  CLRF   x57
078A6:  CLRF   x58
078A8:  CLRF   x59
078AA:  CLRF   x5A
078AC:  CLRF   x5B
078AE:  CLRF   x5C
078B0:  CLRF   x5D
078B2:  CLRF   x5E
078B4:  CLRF   x5F
078B6:  CLRF   x60
078B8:  CLRF   x61
078BA:  CLRF   x62
078BC:  CLRF   x63
078BE:  CLRF   x64
078C0:  CLRF   x65
078C2:  CLRF   x66
078C4:  CLRF   x67
078C6:  CLRF   x68
078C8:  CLRF   x69
078CA:  CLRF   x6A
078CC:  CLRF   x6B
078CE:  CLRF   x6C
078D0:  CLRF   x6D
078D2:  CLRF   x6E
078D4:  CLRF   x6F
078D6:  CLRF   x70
078D8:  CLRF   x71
078DA:  CLRF   x72
078DC:  CLRF   x73
078DE:  CLRF   x74
078E0:  CLRF   x75
078E2:  CLRF   x76
078E4:  CLRF   x77
078E6:  CLRF   x78
078E8:  CLRF   x79
078EA:  CLRF   x7A
078EC:  CLRF   x7B
078EE:  CLRF   x7C
078F0:  CLRF   x7D
078F2:  CLRF   x7E
078F4:  CLRF   x7F
078F6:  CLRF   x80
078F8:  CLRF   x81
078FA:  CLRF   x82
078FC:  CLRF   x83
078FE:  CLRF   x84
07900:  CLRF   x85
07902:  CLRF   x86
07904:  CLRF   x87
07906:  CLRF   x88
07908:  CLRF   x89
0790A:  CLRF   x8A
0790C:  CLRF   x8B
0790E:  CLRF   x8C
07910:  CLRF   x8D
07912:  CLRF   x8E
07914:  CLRF   x8F
07916:  CLRF   x90
07918:  CLRF   x91
0791A:  CLRF   x92
0791C:  CLRF   x93
0791E:  CLRF   x94
07920:  CLRF   x95
07922:  CLRF   x96
07924:  CLRF   x97
07926:  CLRF   x98
07928:  CLRF   x99
0792A:  CLRF   x9A
0792C:  CLRF   x9B
0792E:  CLRF   x9C
07930:  CLRF   x9D
07932:  CLRF   x9E
07934:  CLRF   x9F
07936:  CLRF   xA0
07938:  CLRF   xA1
0793A:  CLRF   xA2
0793C:  CLRF   xA3
0793E:  CLRF   xA4
07940:  CLRF   xA5
07942:  CLRF   xA6
07944:  CLRF   xA7
07946:  CLRF   xA8
07948:  CLRF   xA9
0794A:  CLRF   xAA
0794C:  CLRF   xAB
....................     port2.port_num = 2;
0794E:  MOVLW  02
07950:  MOVLB  7
07952:  MOVWF  xAC
....................     port2.sweep_step = 0;
07954:  CLRF   xAE
07956:  CLRF   xAD
....................     port2.active = 1;
07958:  MOVLB  B
0795A:  BSF    xAB.0
.................... 
....................     int16 count = 1;
0795C:  CLRF   xAD
0795E:  MOVLW  01
07960:  MOVWF  xAC
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
07962:  CLRF   xBE
07964:  MOVLW  01
07966:  MOVWF  xBD
07968:  MOVLB  0
0796A:  CALL   2162
....................     mcp4901_2_write(1);
0796E:  MOVLB  B
07970:  CLRF   xBE
07972:  MOVLW  01
07974:  MOVWF  xBD
07976:  MOVLB  0
07978:  CALL   21A4
....................     ad7490_read(ADC_CIGS1_CURR);
0797C:  MOVLW  01
0797E:  MOVLB  B
07980:  MOVWF  xD2
07982:  MOVLB  0
07984:  CALL   1E04
....................     ad7490_read(ADC_CIGS2_CURR);
07988:  MOVLW  05
0798A:  MOVLB  B
0798C:  MOVWF  xD2
0798E:  MOVLB  0
07990:  CALL   1E04
....................     ad7490_read(ADC_CIGS2_CURR);
07994:  MOVLW  05
07996:  MOVLB  B
07998:  MOVWF  xD2
0799A:  MOVLB  0
0799C:  CALL   1E04
....................     delay_ms(200);
079A0:  MOVLW  C8
079A2:  MOVLB  C
079A4:  MOVWF  x6B
079A6:  MOVLB  0
079A8:  CALL   1B94
.................... 
....................     // Read initial PD value
....................     MEASUREMENT_DATA measured_data = create_meas_data();
079AC:  GOTO   60DC
079B0:  MOVFF  02,03
079B4:  MOVF   01,W
079B6:  MOVWF  FE1
079B8:  MOVFF  03,FE2
079BC:  MOVLW  0B
079BE:  MOVWF  FEA
079C0:  MOVLW  AE
079C2:  MOVWF  FE9
079C4:  MOVLW  0F
079C6:  MOVWF  01
079C8:  MOVFF  FE6,FEE
079CC:  DECFSZ 01,F
079CE:  GOTO   79C8
....................     // Continue measurement while at least one port is active
....................     while (port1.active || port2.active)
079D2:  MOVLB  7
079D4:  BTFSS  xAB.0
079D6:  BRA    79DE
079D8:  MOVLB  0
079DA:  GOTO   79EE
079DE:  MOVLB  0
079E0:  MOVLB  B
079E2:  BTFSC  xAB.0
079E4:  BRA    79EC
079E6:  MOVLB  0
079E8:  GOTO   7E76
079EC:  MOVLB  0
....................     {
....................         // Set DAC values for both ports (synchronized timing)
....................         mcp4901_1_write(count);
079EE:  MOVFF  BAD,BBE
079F2:  MOVFF  BAC,BBD
079F6:  CALL   2162
....................         mcp4901_2_write(count);
079FA:  MOVFF  BAD,BBE
079FE:  MOVFF  BAC,BBD
07A02:  CALL   21A4
....................         delay_ms(1); // wait for DAC to stabilize
07A06:  MOVLW  01
07A08:  MOVLB  C
07A0A:  MOVWF  x6B
07A0C:  MOVLB  0
07A0E:  CALL   1B94
.................... 
....................         // Read CIGS1 data (port1) only if still active
....................         if (port1.active) {
07A12:  MOVLB  7
07A14:  BTFSC  xAB.0
07A16:  BRA    7A1E
07A18:  MOVLB  0
07A1A:  GOTO   7AAA
07A1E:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
07A20:  BCF    FD8.0
07A22:  MOVLB  B
07A24:  RLCF   xAC,W
07A26:  MOVWF  02
07A28:  RLCF   xAD,W
07A2A:  MOVWF  03
07A2C:  MOVF   02,W
07A2E:  ADDLW  AF
07A30:  MOVWF  01
07A32:  MOVLW  03
07A34:  ADDWFC 03,F
07A36:  MOVF   01,W
07A38:  MOVWF  xBD
07A3A:  MOVFF  03,BBE
07A3E:  MOVLW  02
07A40:  MOVWF  xD2
07A42:  MOVLB  0
07A44:  CALL   1E04
07A48:  MOVFF  BBE,FEA
07A4C:  MOVFF  BBD,FE9
07A50:  MOVFF  02,FEC
07A54:  MOVF   FED,F
07A56:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
07A5A:  BCF    FD8.0
07A5C:  MOVLB  B
07A5E:  RLCF   xAC,W
07A60:  MOVWF  02
07A62:  RLCF   xAD,W
07A64:  MOVWF  03
07A66:  MOVF   02,W
07A68:  ADDLW  AD
07A6A:  MOVWF  01
07A6C:  MOVLW  05
07A6E:  ADDWFC 03,F
07A70:  MOVF   01,W
07A72:  MOVWF  xBD
07A74:  MOVFF  03,BBE
07A78:  MOVLW  01
07A7A:  MOVWF  xD2
07A7C:  MOVLB  0
07A7E:  CALL   1E04
07A82:  MOVFF  BBE,FEA
07A86:  MOVFF  BBD,FE9
07A8A:  MOVFF  02,FEC
07A8E:  MOVF   FED,F
07A90:  MOVFF  01,FEF
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
07A94:  MOVLW  01
07A96:  MOVLB  B
07A98:  ADDWF  xAC,W
07A9A:  MOVLB  3
07A9C:  MOVWF  xAD
07A9E:  MOVLW  00
07AA0:  MOVLB  B
07AA2:  ADDWFC xAD,W
07AA4:  MOVLB  3
07AA6:  MOVWF  xAE
07AA8:  MOVLB  0
....................         }
....................         
....................         // Read CIGS2 data (port2) only if still active
....................         if (port2.active) {
07AAA:  MOVLB  B
07AAC:  BTFSC  xAB.0
07AAE:  BRA    7AB6
07AB0:  MOVLB  0
07AB2:  GOTO   7C0A
07AB6:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
07AB8:  BCF    FD8.0
07ABA:  MOVLB  B
07ABC:  RLCF   xAC,W
07ABE:  MOVWF  02
07AC0:  RLCF   xAD,W
07AC2:  MOVWF  03
07AC4:  MOVF   02,W
07AC6:  ADDLW  AF
07AC8:  MOVWF  01
07ACA:  MOVLW  07
07ACC:  ADDWFC 03,F
07ACE:  MOVF   01,W
07AD0:  MOVWF  xBD
07AD2:  MOVFF  03,BBE
07AD6:  MOVLW  06
07AD8:  MOVWF  xD2
07ADA:  MOVLB  0
07ADC:  CALL   1E04
07AE0:  MOVFF  BBE,FEA
07AE4:  MOVFF  BBD,FE9
07AE8:  MOVFF  02,FEC
07AEC:  MOVF   FED,F
07AEE:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
07AF2:  BCF    FD8.0
07AF4:  MOVLB  B
07AF6:  RLCF   xAC,W
07AF8:  MOVWF  02
07AFA:  RLCF   xAD,W
07AFC:  MOVWF  03
07AFE:  MOVF   02,W
07B00:  ADDLW  AD
07B02:  MOVWF  01
07B04:  MOVLW  09
07B06:  ADDWFC 03,F
07B08:  MOVF   01,W
07B0A:  MOVWF  xBD
07B0C:  MOVFF  03,BBE
07B10:  MOVLW  05
07B12:  MOVWF  xD2
07B14:  MOVLB  0
07B16:  CALL   1E04
07B1A:  MOVFF  BBE,FEA
07B1E:  MOVFF  BBD,FE9
07B22:  MOVFF  02,FEC
07B26:  MOVF   FED,F
07B28:  MOVFF  01,FEF
....................             fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
07B2C:  BCF    FD8.0
07B2E:  MOVLB  B
07B30:  RLCF   xAC,W
07B32:  MOVWF  02
07B34:  RLCF   xAD,W
07B36:  MOVWF  03
07B38:  MOVF   02,W
07B3A:  ADDLW  AF
07B3C:  MOVWF  FE9
07B3E:  MOVLW  07
07B40:  ADDWFC 03,W
07B42:  MOVWF  FEA
07B44:  MOVFF  FEC,BBE
07B48:  MOVF   FED,F
07B4A:  MOVFF  FEF,BBD
07B4E:  BCF    FD8.0
07B50:  RLCF   xAC,W
07B52:  MOVWF  02
07B54:  RLCF   xAD,W
07B56:  MOVWF  03
07B58:  MOVF   02,W
07B5A:  ADDLW  AD
07B5C:  MOVWF  FE9
07B5E:  MOVLW  09
07B60:  ADDWFC 03,W
07B62:  MOVWF  FEA
07B64:  MOVFF  FEC,BC0
07B68:  MOVF   FED,F
07B6A:  MOVFF  FEF,BBF
07B6E:  MOVLW  F6
07B70:  MOVWF  FF6
07B72:  MOVLW  06
07B74:  MOVWF  FF7
07B76:  MOVLW  00
07B78:  MOVWF  FF8
07B7A:  MOVLW  0C
07B7C:  MOVWF  xC1
07B7E:  MOVLB  0
07B80:  CALL   1C44
07B84:  MOVFF  BBE,BC1
07B88:  MOVLW  37
07B8A:  MOVLB  B
07B8C:  MOVWF  xC2
07B8E:  MOVLB  0
07B90:  CALL   1E98
07B94:  MOVFF  BBD,BC1
07B98:  MOVLW  37
07B9A:  MOVLB  B
07B9C:  MOVWF  xC2
07B9E:  MOVLB  0
07BA0:  CALL   1E98
07BA4:  MOVLW  2C
07BA6:  MOVLB  C
07BA8:  MOVWF  x14
07BAA:  MOVLB  0
07BAC:  CALL   1BC2
07BB0:  MOVLW  20
07BB2:  MOVLB  C
07BB4:  MOVWF  x14
07BB6:  MOVLB  0
07BB8:  CALL   1BC2
07BBC:  MOVFF  BC0,BC1
07BC0:  MOVLW  37
07BC2:  MOVLB  B
07BC4:  MOVWF  xC2
07BC6:  MOVLB  0
07BC8:  CALL   1E98
07BCC:  MOVFF  BBF,BC1
07BD0:  MOVLW  37
07BD2:  MOVLB  B
07BD4:  MOVWF  xC2
07BD6:  MOVLB  0
07BD8:  CALL   1E98
07BDC:  MOVLW  0D
07BDE:  MOVLB  C
07BE0:  MOVWF  x14
07BE2:  MOVLB  0
07BE4:  CALL   1BC2
07BE8:  MOVLW  0A
07BEA:  MOVLB  C
07BEC:  MOVWF  x14
07BEE:  MOVLB  0
07BF0:  CALL   1BC2
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
07BF4:  MOVLW  01
07BF6:  MOVLB  B
07BF8:  ADDWF  xAC,W
07BFA:  MOVLB  7
07BFC:  MOVWF  xAD
07BFE:  MOVLW  00
07C00:  MOVLB  B
07C02:  ADDWFC xAD,W
07C04:  MOVLB  7
07C06:  MOVWF  xAE
07C08:  MOVLB  0
....................         }
.................... 
....................         count++;
07C0A:  MOVLB  B
07C0C:  INCF   xAC,F
07C0E:  BTFSC  FD8.2
07C10:  INCF   xAD,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
07C12:  MOVF   xAD,F
07C14:  BTFSC  FD8.2
07C16:  BRA    7C1E
07C18:  MOVLB  0
07C1A:  GOTO   7C32
07C1E:  MOVLB  0
07C20:  MOVLB  B
07C22:  MOVF   xAC,W
07C24:  SUBLW  FE
07C26:  BTFSS  FD8.0
07C28:  BRA    7C30
07C2A:  MOVLB  0
07C2C:  GOTO   7C76
07C30:  MOVLB  0
....................             fprintf(PC, "Maximum step count reached: %ld\r\n", count);
07C32:  MOVLW  12
07C34:  MOVWF  FF6
07C36:  MOVLW  07
07C38:  MOVWF  FF7
07C3A:  MOVLW  00
07C3C:  MOVWF  FF8
07C3E:  MOVLW  1C
07C40:  MOVLB  B
07C42:  MOVWF  xC1
07C44:  MOVLB  0
07C46:  CALL   1C44
07C4A:  MOVLW  10
07C4C:  MOVWF  FE9
07C4E:  MOVFF  BAD,BBE
07C52:  MOVFF  BAC,BBD
07C56:  GOTO   6166
07C5A:  MOVLW  0D
07C5C:  MOVLB  C
07C5E:  MOVWF  x14
07C60:  MOVLB  0
07C62:  CALL   1BC2
07C66:  MOVLW  0A
07C68:  MOVLB  C
07C6A:  MOVWF  x14
07C6C:  MOVLB  0
07C6E:  CALL   1BC2
....................             break;
07C72:  GOTO   7E76
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
07C76:  MOVLB  7
07C78:  BTFSC  xAB.0
07C7A:  BRA    7C82
07C7C:  MOVLB  0
07C7E:  GOTO   7D74
07C82:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
07C84:  MOVLW  01
07C86:  MOVLB  B
07C88:  SUBWF  xAC,W
07C8A:  MOVWF  xBD
07C8C:  MOVLW  00
07C8E:  SUBWFB xAD,W
07C90:  MOVWF  xBE
07C92:  BCF    FD8.0
07C94:  RLCF   xBD,W
07C96:  MOVWF  02
07C98:  RLCF   xBE,W
07C9A:  MOVWF  03
07C9C:  MOVF   02,W
07C9E:  ADDLW  AD
07CA0:  MOVWF  FE9
07CA2:  MOVLW  05
07CA4:  ADDWFC 03,W
07CA6:  MOVWF  FEA
07CA8:  MOVFF  FEC,BBE
07CAC:  MOVF   FED,F
07CAE:  MOVFF  FEF,BBD
07CB2:  MOVF   xBE,W
07CB4:  MOVLB  3
07CB6:  SUBWF  xAB,W
07CB8:  BTFSC  FD8.0
07CBA:  BRA    7CC2
07CBC:  MOVLB  0
07CBE:  GOTO   7CFE
07CC2:  MOVLB  0
07CC4:  BTFSS  FD8.2
07CC6:  GOTO   7CDE
07CCA:  MOVLB  3
07CCC:  MOVF   xAA,W
07CCE:  MOVLB  B
07CD0:  SUBWF  xBD,W
07CD2:  BTFSS  FD8.0
07CD4:  BRA    7CDC
07CD6:  MOVLB  0
07CD8:  GOTO   7CFE
07CDC:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current limit reached:");
07CDE:  MOVLW  34
07CE0:  MOVWF  FF6
07CE2:  MOVLW  07
07CE4:  MOVWF  FF7
07CE6:  MOVLW  00
07CE8:  MOVWF  FF8
07CEA:  CALL   1C14
....................                 port1.active = 0;
07CEE:  MOVLB  7
07CF0:  BCF    xAB.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
07CF2:  MOVLW  5E
07CF4:  MOVWF  F94
07CF6:  BCF    F8B.0
07CF8:  MOVLB  0
....................             }
07CFA:  GOTO   7D74
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
07CFE:  MOVLW  01
07D00:  MOVLB  B
07D02:  SUBWF  xAC,W
07D04:  MOVWF  xBD
07D06:  MOVLW  00
07D08:  SUBWFB xAD,W
07D0A:  MOVWF  xBE
07D0C:  BCF    FD8.0
07D0E:  RLCF   xBD,W
07D10:  MOVWF  02
07D12:  RLCF   xBE,W
07D14:  MOVWF  03
07D16:  MOVF   02,W
07D18:  ADDLW  AD
07D1A:  MOVWF  FE9
07D1C:  MOVLW  05
07D1E:  ADDWFC 03,W
07D20:  MOVWF  FEA
07D22:  MOVFF  FEC,BBE
07D26:  MOVF   FED,F
07D28:  MOVFF  FEF,BBD
07D2C:  MOVF   xBE,W
07D2E:  MOVLB  3
07D30:  SUBWF  xA7,W
07D32:  BTFSC  FD8.0
07D34:  BRA    7D3C
07D36:  MOVLB  0
07D38:  GOTO   7D74
07D3C:  MOVLB  0
07D3E:  BTFSS  FD8.2
07D40:  GOTO   7D58
07D44:  MOVLB  3
07D46:  MOVF   xA6,W
07D48:  MOVLB  B
07D4A:  SUBWF  xBD,W
07D4C:  BTFSS  FD8.0
07D4E:  BRA    7D56
07D50:  MOVLB  0
07D52:  GOTO   7D74
07D56:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current below threshold");
07D58:  MOVLW  52
07D5A:  MOVWF  FF6
07D5C:  MOVLW  07
07D5E:  MOVWF  FF7
07D60:  MOVLW  00
07D62:  MOVWF  FF8
07D64:  CALL   1C14
....................                 port1.active = 0;
07D68:  MOVLB  7
07D6A:  BCF    xAB.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
07D6C:  MOVLW  5E
07D6E:  MOVWF  F94
07D70:  BCF    F8B.0
07D72:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
07D74:  MOVLB  B
07D76:  BTFSC  xAB.0
07D78:  BRA    7D80
07D7A:  MOVLB  0
07D7C:  GOTO   7E72
07D80:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
07D82:  MOVLW  01
07D84:  MOVLB  B
07D86:  SUBWF  xAC,W
07D88:  MOVWF  xBD
07D8A:  MOVLW  00
07D8C:  SUBWFB xAD,W
07D8E:  MOVWF  xBE
07D90:  BCF    FD8.0
07D92:  RLCF   xBD,W
07D94:  MOVWF  02
07D96:  RLCF   xBE,W
07D98:  MOVWF  03
07D9A:  MOVF   02,W
07D9C:  ADDLW  AD
07D9E:  MOVWF  FE9
07DA0:  MOVLW  09
07DA2:  ADDWFC 03,W
07DA4:  MOVWF  FEA
07DA6:  MOVFF  FEC,BBE
07DAA:  MOVF   FED,F
07DAC:  MOVFF  FEF,BBD
07DB0:  MOVF   xBE,W
07DB2:  MOVLB  3
07DB4:  SUBWF  xAB,W
07DB6:  BTFSC  FD8.0
07DB8:  BRA    7DC0
07DBA:  MOVLB  0
07DBC:  GOTO   7DFC
07DC0:  MOVLB  0
07DC2:  BTFSS  FD8.2
07DC4:  GOTO   7DDC
07DC8:  MOVLB  3
07DCA:  MOVF   xAA,W
07DCC:  MOVLB  B
07DCE:  SUBWF  xBD,W
07DD0:  BTFSS  FD8.0
07DD2:  BRA    7DDA
07DD4:  MOVLB  0
07DD6:  GOTO   7DFC
07DDA:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current limit reached: ");
07DDC:  MOVLW  70
07DDE:  MOVWF  FF6
07DE0:  MOVLW  07
07DE2:  MOVWF  FF7
07DE4:  MOVLW  00
07DE6:  MOVWF  FF8
07DE8:  CALL   1C14
....................                 port2.active = 0;
07DEC:  MOVLB  B
07DEE:  BCF    xAB.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
07DF0:  MOVLW  5E
07DF2:  MOVWF  F94
07DF4:  BCF    F8B.5
07DF6:  MOVLB  0
....................             }
07DF8:  GOTO   7E72
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
07DFC:  MOVLW  01
07DFE:  MOVLB  B
07E00:  SUBWF  xAC,W
07E02:  MOVWF  xBD
07E04:  MOVLW  00
07E06:  SUBWFB xAD,W
07E08:  MOVWF  xBE
07E0A:  BCF    FD8.0
07E0C:  RLCF   xBD,W
07E0E:  MOVWF  02
07E10:  RLCF   xBE,W
07E12:  MOVWF  03
07E14:  MOVF   02,W
07E16:  ADDLW  AD
07E18:  MOVWF  FE9
07E1A:  MOVLW  09
07E1C:  ADDWFC 03,W
07E1E:  MOVWF  FEA
07E20:  MOVFF  FEC,BBE
07E24:  MOVF   FED,F
07E26:  MOVFF  FEF,BBD
07E2A:  MOVF   xBE,W
07E2C:  MOVLB  3
07E2E:  SUBWF  xA7,W
07E30:  BTFSC  FD8.0
07E32:  BRA    7E3A
07E34:  MOVLB  0
07E36:  GOTO   7E72
07E3A:  MOVLB  0
07E3C:  BTFSS  FD8.2
07E3E:  GOTO   7E56
07E42:  MOVLB  3
07E44:  MOVF   xA6,W
07E46:  MOVLB  B
07E48:  SUBWF  xBD,W
07E4A:  BTFSS  FD8.0
07E4C:  BRA    7E54
07E4E:  MOVLB  0
07E50:  GOTO   7E72
07E54:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current below threshold:");
07E56:  MOVLW  8E
07E58:  MOVWF  FF6
07E5A:  MOVLW  07
07E5C:  MOVWF  FF7
07E5E:  MOVLW  00
07E60:  MOVWF  FF8
07E62:  CALL   1C14
....................                 port2.active = 0;
07E66:  MOVLB  B
07E68:  BCF    xAB.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
07E6A:  MOVLW  5E
07E6C:  MOVWF  F94
07E6E:  BCF    F8B.5
07E70:  MOVLB  0
....................             }
....................         }
07E72:  GOTO   79D2
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
07E76:  MOVLW  5E
07E78:  MOVWF  F94
07E7A:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
07E7C:  MOVLW  5E
07E7E:  MOVWF  F94
07E80:  BCF    F8B.5
....................     // output_high(EN_NPWR);
.................... 
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
07E82:  MOVLW  0B
07E84:  MOVLB  B
07E86:  MOVWF  xBE
07E88:  MOVLW  AE
07E8A:  MOVWF  xBD
07E8C:  MOVLW  03
07E8E:  MOVWF  xC0
07E90:  MOVLW  AC
07E92:  MOVWF  xBF
07E94:  MOVLB  0
07E96:  CALL   62F0
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
07E9A:  MOVLW  0B
07E9C:  MOVLB  B
07E9E:  MOVWF  xBE
07EA0:  MOVLW  AE
07EA2:  MOVWF  xBD
07EA4:  MOVLW  07
07EA6:  MOVWF  xC0
07EA8:  MOVLW  AC
07EAA:  MOVWF  xBF
07EAC:  MOVLB  0
07EAE:  CALL   62F0
.................... 
....................     fprintf(PC, "End SWEEP with threshold\r\n");
07EB2:  MOVLW  AE
07EB4:  MOVWF  FF6
07EB6:  MOVLW  07
07EB8:  MOVWF  FF7
07EBA:  MOVLW  00
07EBC:  MOVWF  FF8
07EBE:  CALL   1C14
07EC2:  GOTO   8668 (RETURN)
.................... }
.................... 
.................... 
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data)
*
06374:  CLRF   x01
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
*
062F0:  MOVLB  B
062F2:  CLRF   xC1
062F4:  CLRF   xC2
062F6:  CLRF   xC3
062F8:  CLRF   xC4
062FA:  CLRF   xC5
062FC:  CLRF   xC6
062FE:  CLRF   xC7
06300:  CLRF   xC8
06302:  CLRF   xC9
06304:  CLRF   xCA
06306:  CLRF   xCB
06308:  CLRF   xCC
0630A:  CLRF   xCD
0630C:  CLRF   xCE
0630E:  CLRF   xCF
06310:  CLRF   xD0
06312:  CLRF   xD1
06314:  CLRF   xD2
06316:  CLRF   xD3
06318:  CLRF   xD4
0631A:  CLRF   xD5
0631C:  CLRF   xD6
0631E:  CLRF   xD7
06320:  CLRF   xD8
06322:  CLRF   xD9
06324:  CLRF   xDA
06326:  CLRF   xDB
06328:  CLRF   xDC
0632A:  CLRF   xDD
0632C:  CLRF   xDE
0632E:  CLRF   xDF
06330:  CLRF   xE0
06332:  CLRF   xE1
06334:  CLRF   xE2
06336:  CLRF   xE3
06338:  CLRF   xE4
0633A:  CLRF   xE5
0633C:  CLRF   xE6
0633E:  CLRF   xE7
06340:  CLRF   xE8
06342:  CLRF   xE9
06344:  CLRF   xEA
06346:  CLRF   xEB
06348:  CLRF   xEC
0634A:  CLRF   xED
0634C:  CLRF   xEE
0634E:  CLRF   xEF
06350:  CLRF   xF0
06352:  CLRF   xF1
06354:  CLRF   xF2
06356:  CLRF   xF3
06358:  CLRF   xF4
0635A:  CLRF   xF5
0635C:  CLRF   xF6
0635E:  CLRF   xF7
06360:  CLRF   xF8
06362:  CLRF   xF9
06364:  CLRF   xFA
06366:  CLRF   xFB
06368:  CLRF   xFC
0636A:  CLRF   xFD
0636C:  CLRF   xFE
0636E:  CLRF   xFF
06370:  MOVLB  C
06372:  CLRF   x00
....................     unsigned int8 packetdata_index = 0; // Index for packet data
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
06376:  MOVLB  B
06378:  SETF   xC1
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data->port_num & 0x0F);
0637A:  MOVF   xBF,W
0637C:  MOVWF  FE9
0637E:  MOVF   xC0,W
06380:  MOVWF  FEA
06382:  MOVF   FEF,W
06384:  ANDLW  0F
06386:  IORLW  F0
06388:  MOVWF  xC2
....................     packetdata[2] = measured_data->time_sec >> 24 & 0xFF;
0638A:  MOVF   xBD,W
0638C:  MOVWF  FE9
0638E:  MOVF   xBE,W
06390:  MOVWF  FEA
06392:  MOVFF  FEF,C11
06396:  MOVFF  FEC,C12
0639A:  MOVFF  FEC,C13
0639E:  MOVFF  FEC,C14
063A2:  MOVF   FED,F
063A4:  MOVF   FED,F
063A6:  MOVF   FED,F
063A8:  MOVFF  C14,C11
063AC:  MOVLB  C
063AE:  CLRF   x12
063B0:  CLRF   x13
063B2:  CLRF   x14
063B4:  MOVF   x11,W
063B6:  MOVLB  B
063B8:  MOVWF  xC3
....................     packetdata[3] = measured_data->time_sec >> 16 & 0xFF;
063BA:  MOVF   xBD,W
063BC:  MOVWF  FE9
063BE:  MOVF   xBE,W
063C0:  MOVWF  FEA
063C2:  MOVFF  FEF,C11
063C6:  MOVFF  FEC,C12
063CA:  MOVFF  FEC,C13
063CE:  MOVFF  FEC,C14
063D2:  MOVF   FED,F
063D4:  MOVF   FED,F
063D6:  MOVF   FED,F
063D8:  MOVFF  C13,C11
063DC:  MOVFF  C14,C12
063E0:  MOVLB  C
063E2:  CLRF   x13
063E4:  CLRF   x14
063E6:  MOVF   x11,W
063E8:  MOVLB  B
063EA:  MOVWF  xC4
....................     packetdata[4] = measured_data->time_sec >> 8 & 0xFF;
063EC:  MOVF   xBD,W
063EE:  MOVWF  FE9
063F0:  MOVF   xBE,W
063F2:  MOVWF  FEA
063F4:  MOVFF  FEF,C11
063F8:  MOVFF  FEC,C12
063FC:  MOVFF  FEC,C13
06400:  MOVFF  FEC,C14
06404:  MOVF   FED,F
06406:  MOVF   FED,F
06408:  MOVF   FED,F
0640A:  MOVFF  C12,C11
0640E:  MOVFF  C13,C12
06412:  MOVFF  C14,C13
06416:  MOVLB  C
06418:  CLRF   x14
0641A:  MOVF   x11,W
0641C:  MOVLB  B
0641E:  MOVWF  xC5
....................     packetdata[5] = measured_data->time_sec & 0xFF;
06420:  MOVF   xBD,W
06422:  MOVWF  FE9
06424:  MOVF   xBE,W
06426:  MOVWF  FEA
06428:  MOVFF  FEF,C11
0642C:  MOVFF  FEC,C12
06430:  MOVFF  FEC,C13
06434:  MOVFF  FEC,C14
06438:  MOVF   FED,F
0643A:  MOVF   FED,F
0643C:  MOVF   FED,F
0643E:  MOVLB  C
06440:  MOVF   x11,W
06442:  MOVLB  B
06444:  MOVWF  xC6
....................     packetdata[6] = (measured_data->time_msec & 0x0F) >>4 | measured_data->pd >> 8 & 0x0F;
06446:  MOVLW  04
06448:  ADDWF  xBD,W
0644A:  MOVWF  FE9
0644C:  MOVLW  00
0644E:  ADDWFC xBE,W
06450:  MOVWF  FEA
06452:  MOVF   FEF,W
06454:  ANDLW  0F
06456:  MOVWF  00
06458:  SWAPF  00,W
0645A:  MOVLB  C
0645C:  MOVWF  x11
0645E:  MOVLW  0F
06460:  ANDWF  x11,F
06462:  MOVLW  0D
06464:  MOVLB  B
06466:  ADDWF  xBD,W
06468:  MOVWF  FE9
0646A:  MOVLW  00
0646C:  ADDWFC xBE,W
0646E:  MOVWF  FEA
06470:  MOVFF  FEC,C13
06474:  MOVF   FED,F
06476:  MOVFF  FEF,C12
0647A:  MOVFF  C13,C12
0647E:  MOVLB  C
06480:  CLRF   x13
06482:  MOVF   x12,W
06484:  ANDLW  0F
06486:  MOVWF  00
06488:  CLRF   03
0648A:  MOVF   00,W
0648C:  IORWF  x11,W
0648E:  MOVLB  B
06490:  MOVWF  xC7
....................     packetdata[7] = measured_data->pd & 0xFF;
06492:  MOVLW  0D
06494:  ADDWF  xBD,W
06496:  MOVWF  FE9
06498:  MOVLW  00
0649A:  ADDWFC xBE,W
0649C:  MOVWF  FEA
0649E:  MOVFF  FEC,C12
064A2:  MOVF   FED,F
064A4:  MOVFF  FEF,C11
064A8:  MOVLB  C
064AA:  MOVF   x11,W
064AC:  MOVLB  B
064AE:  MOVWF  xC8
....................     packetdata[8] = (measured_data->open_voltage >> 4) & 0xFF; // PD start low byte
064B0:  MOVLW  05
064B2:  ADDWF  xBD,W
064B4:  MOVWF  FE9
064B6:  MOVLW  00
064B8:  ADDWFC xBE,W
064BA:  MOVWF  FEA
064BC:  MOVFF  FEC,C12
064C0:  MOVF   FED,F
064C2:  MOVFF  FEF,C11
064C6:  MOVLB  C
064C8:  RRCF   x12,F
064CA:  RRCF   x11,F
064CC:  RRCF   x12,F
064CE:  RRCF   x11,F
064D0:  RRCF   x12,F
064D2:  RRCF   x11,F
064D4:  RRCF   x12,F
064D6:  RRCF   x11,F
064D8:  MOVLW  0F
064DA:  ANDWF  x12,F
064DC:  MOVF   x11,W
064DE:  MOVLB  B
064E0:  MOVWF  xC9
....................     packetdata[9] = (measured_data->open_voltage & 0x0F) << 4 | (measured_data->temp_py_top >> 8) & 0x0F;
064E2:  MOVLW  05
064E4:  ADDWF  xBD,W
064E6:  MOVWF  FE9
064E8:  MOVLW  00
064EA:  ADDWFC xBE,W
064EC:  MOVWF  FEA
064EE:  MOVFF  FEC,C12
064F2:  MOVF   FED,F
064F4:  MOVFF  FEF,C11
064F8:  MOVLW  0F
064FA:  MOVLB  C
064FC:  ANDWF  x11,F
064FE:  CLRF   x12
06500:  RLCF   x11,F
06502:  RLCF   x12,F
06504:  RLCF   x11,F
06506:  RLCF   x12,F
06508:  RLCF   x11,F
0650A:  RLCF   x12,F
0650C:  RLCF   x11,F
0650E:  RLCF   x12,F
06510:  MOVLW  F0
06512:  ANDWF  x11,F
06514:  MOVLW  07
06516:  MOVLB  B
06518:  ADDWF  xBD,W
0651A:  MOVWF  FE9
0651C:  MOVLW  00
0651E:  ADDWFC xBE,W
06520:  MOVWF  FEA
06522:  MOVFF  FEC,C14
06526:  MOVF   FED,F
06528:  MOVFF  FEF,C13
0652C:  MOVFF  C14,C13
06530:  MOVLB  C
06532:  CLRF   x14
06534:  MOVF   x13,W
06536:  ANDLW  0F
06538:  MOVWF  00
0653A:  CLRF   03
0653C:  MOVF   00,W
0653E:  IORWF  x11,W
06540:  MOVLB  B
06542:  MOVWF  xCA
....................     packetdata[10] = measured_data->temp_py_top & 0xFF;
06544:  MOVLW  07
06546:  ADDWF  xBD,W
06548:  MOVWF  FE9
0654A:  MOVLW  00
0654C:  ADDWFC xBE,W
0654E:  MOVWF  FEA
06550:  MOVFF  FEC,C12
06554:  MOVF   FED,F
06556:  MOVFF  FEF,C11
0655A:  MOVLB  C
0655C:  MOVF   x11,W
0655E:  MOVLB  B
06560:  MOVWF  xCB
....................     packetdata[11] = (measured_data->temp_py_bot >> 4) & 0xFF; // PD start low byte
06562:  MOVLW  09
06564:  ADDWF  xBD,W
06566:  MOVWF  FE9
06568:  MOVLW  00
0656A:  ADDWFC xBE,W
0656C:  MOVWF  FEA
0656E:  MOVFF  FEC,C12
06572:  MOVF   FED,F
06574:  MOVFF  FEF,C11
06578:  MOVLB  C
0657A:  RRCF   x12,F
0657C:  RRCF   x11,F
0657E:  RRCF   x12,F
06580:  RRCF   x11,F
06582:  RRCF   x12,F
06584:  RRCF   x11,F
06586:  RRCF   x12,F
06588:  RRCF   x11,F
0658A:  MOVLW  0F
0658C:  ANDWF  x12,F
0658E:  MOVF   x11,W
06590:  MOVLB  B
06592:  MOVWF  xCC
....................     packetdata[12] = (measured_data->temp_py_bot & 0x0F) << 4 | (measured_data->temp_mis7 >> 8) & 0x0F;
06594:  MOVLW  09
06596:  ADDWF  xBD,W
06598:  MOVWF  FE9
0659A:  MOVLW  00
0659C:  ADDWFC xBE,W
0659E:  MOVWF  FEA
065A0:  MOVFF  FEC,C12
065A4:  MOVF   FED,F
065A6:  MOVFF  FEF,C11
065AA:  MOVLW  0F
065AC:  MOVLB  C
065AE:  ANDWF  x11,F
065B0:  CLRF   x12
065B2:  RLCF   x11,F
065B4:  RLCF   x12,F
065B6:  RLCF   x11,F
065B8:  RLCF   x12,F
065BA:  RLCF   x11,F
065BC:  RLCF   x12,F
065BE:  RLCF   x11,F
065C0:  RLCF   x12,F
065C2:  MOVLW  F0
065C4:  ANDWF  x11,F
065C6:  MOVLW  0B
065C8:  MOVLB  B
065CA:  ADDWF  xBD,W
065CC:  MOVWF  FE9
065CE:  MOVLW  00
065D0:  ADDWFC xBE,W
065D2:  MOVWF  FEA
065D4:  MOVFF  FEC,C14
065D8:  MOVF   FED,F
065DA:  MOVFF  FEF,C13
065DE:  MOVFF  C14,C13
065E2:  MOVLB  C
065E4:  CLRF   x14
065E6:  MOVF   x13,W
065E8:  ANDLW  0F
065EA:  MOVWF  00
065EC:  CLRF   03
065EE:  MOVF   00,W
065F0:  IORWF  x11,W
065F2:  MOVLB  B
065F4:  MOVWF  xCD
....................     packetdata[13] = measured_data->temp_mis7 & 0xFF;
065F6:  MOVLW  0B
065F8:  ADDWF  xBD,W
065FA:  MOVWF  FE9
065FC:  MOVLW  00
065FE:  ADDWFC xBE,W
06600:  MOVWF  FEA
06602:  MOVFF  FEC,C12
06606:  MOVF   FED,F
06608:  MOVFF  FEF,C11
0660C:  MOVLB  C
0660E:  MOVF   x11,W
06610:  MOVLB  B
06612:  MOVWF  xCE
.................... 
....................     packetdata_index = 14; // Start index for data
06614:  MOVLW  0E
06616:  MOVLB  C
06618:  MOVWF  x01
.................... 
....................     for (unsigned int16 i = 0; i < port_data->sweep_step ; i++) {
0661A:  CLRF   x03
0661C:  CLRF   x02
0661E:  MOVLB  0
06620:  MOVLW  01
06622:  MOVLB  B
06624:  ADDWF  xBF,W
06626:  MOVWF  FE9
06628:  MOVLW  00
0662A:  ADDWFC xC0,W
0662C:  MOVWF  FEA
0662E:  MOVFF  FEC,03
06632:  MOVF   FED,F
06634:  MOVF   FEF,W
06636:  MOVWF  01
06638:  MOVLB  C
0663A:  MOVF   x03,W
0663C:  SUBWF  03,W
0663E:  BTFSC  FD8.0
06640:  BRA    6648
06642:  MOVLB  0
06644:  GOTO   6824
06648:  MOVLB  0
0664A:  BTFSS  FD8.2
0664C:  GOTO   6662
06650:  MOVF   01,W
06652:  MOVLB  C
06654:  SUBWF  x02,W
06656:  BTFSS  FD8.0
06658:  BRA    6660
0665A:  MOVLB  0
0665C:  GOTO   6824
06660:  MOVLB  0
....................         unsigned int16 data0 = port_data->data_buffer[0][i];
....................         unsigned int16 data1 = port_data->data_buffer[1][i];
06662:  BCF    FD8.0
06664:  MOVLB  C
06666:  RLCF   x02,W
06668:  MOVWF  02
0666A:  RLCF   x03,W
0666C:  MOVWF  03
0666E:  MOVF   02,W
06670:  ADDLW  03
06672:  MOVWF  01
06674:  MOVLW  00
06676:  ADDWFC 03,F
06678:  MOVF   01,W
0667A:  MOVLB  B
0667C:  ADDWF  xBF,W
0667E:  MOVWF  FE9
06680:  MOVF   xC0,W
06682:  ADDWFC 03,W
06684:  MOVWF  FEA
06686:  MOVFF  FEC,C05
0668A:  MOVF   FED,F
0668C:  MOVFF  FEF,C04
06690:  BCF    FD8.0
06692:  MOVLB  C
06694:  RLCF   x02,W
06696:  MOVWF  02
06698:  RLCF   x03,W
0669A:  MOVWF  03
0669C:  MOVF   02,W
0669E:  ADDLW  01
066A0:  MOVWF  01
066A2:  MOVLW  02
066A4:  ADDWFC 03,F
066A6:  MOVF   01,W
066A8:  MOVLB  B
066AA:  ADDWF  xBF,W
066AC:  MOVWF  FE9
066AE:  MOVF   xC0,W
066B0:  ADDWFC 03,W
066B2:  MOVWF  FEA
066B4:  MOVFF  FEC,C07
066B8:  MOVF   FED,F
066BA:  MOVFF  FEF,C06
066BE:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
066C0:  MOVLB  C
066C2:  MOVF   x01,W
066C4:  INCF   x01,F
066C6:  CLRF   03
066C8:  ADDLW  C1
066CA:  MOVWF  FE9
066CC:  MOVLW  0B
066CE:  ADDWFC 03,W
066D0:  MOVWF  FEA
066D2:  RRCF   x05,W
066D4:  MOVWF  x14
066D6:  RRCF   x04,W
066D8:  MOVWF  x13
066DA:  RRCF   x14,F
066DC:  RRCF   x13,F
066DE:  RRCF   x14,F
066E0:  RRCF   x13,F
066E2:  RRCF   x14,F
066E4:  RRCF   x13,F
066E6:  MOVLW  0F
066E8:  ANDWF  x14,F
066EA:  MOVF   x13,W
066EC:  MOVWF  00
066EE:  CLRF   03
066F0:  MOVF   00,W
066F2:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
066F4:  MOVF   x01,W
066F6:  INCF   x01,F
066F8:  CLRF   03
066FA:  ADDLW  C1
066FC:  MOVWF  FE9
066FE:  MOVLW  0B
06700:  ADDWFC 03,W
06702:  MOVWF  FEA
06704:  MOVF   x04,W
06706:  ANDLW  0F
06708:  MOVWF  x13
0670A:  CLRF   x14
0670C:  RLCF   x13,F
0670E:  RLCF   x14,F
06710:  RLCF   x13,F
06712:  RLCF   x14,F
06714:  RLCF   x13,F
06716:  RLCF   x14,F
06718:  RLCF   x13,F
0671A:  RLCF   x14,F
0671C:  MOVLW  F0
0671E:  ANDWF  x13,F
06720:  MOVFF  C07,C15
06724:  CLRF   x16
06726:  MOVF   x15,W
06728:  ANDLW  0F
0672A:  MOVWF  00
0672C:  CLRF   03
0672E:  MOVF   00,W
06730:  IORWF  x13,W
06732:  MOVWF  00
06734:  MOVF   03,W
06736:  IORWF  x14,W
06738:  MOVWF  03
0673A:  MOVF   00,W
0673C:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
0673E:  MOVF   x01,W
06740:  INCF   x01,F
06742:  CLRF   03
06744:  ADDLW  C1
06746:  MOVWF  FE9
06748:  MOVLW  0B
0674A:  ADDWFC 03,W
0674C:  MOVWF  FEA
0674E:  MOVF   x06,W
06750:  MOVWF  00
06752:  CLRF   03
06754:  MOVF   00,W
06756:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
06758:  MOVLW  03
0675A:  ADDWF  x01,W
0675C:  SUBLW  3E
0675E:  BTFSS  FD8.0
06760:  BRA    6768
06762:  MOVLB  0
06764:  GOTO   6816
06768:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
0676A:  MOVLW  0B
0676C:  MOVLB  C
0676E:  MOVWF  x54
06770:  MOVLW  C1
06772:  MOVWF  x53
06774:  MOVLW  3F
06776:  MOVWF  x55
06778:  MOVLB  0
0677A:  CALL   2A40
0677E:  MOVFF  01,C00
....................             unsigned int32 write_address = ADDRESS_MISF_MEASUREMENT_START + iv_data.used_counter;
06782:  MOVLB  3
06784:  MOVF   x2E,W
06786:  MOVLB  C
06788:  MOVWF  x08
0678A:  MOVLB  3
0678C:  MOVF   x2F,W
0678E:  MOVLB  C
06790:  MOVWF  x09
06792:  MOVLW  16
06794:  MOVLB  3
06796:  ADDWF  x30,W
06798:  MOVLB  C
0679A:  MOVWF  x0A
0679C:  MOVLW  00
0679E:  MOVLB  3
067A0:  ADDWFC x31,W
067A2:  MOVLB  C
067A4:  MOVWF  x0B
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
067A6:  MOVFF  301,C56
067AA:  MOVFF  300,C55
067AE:  MOVFF  2FF,C54
067B2:  MOVFF  2FE,C53
067B6:  MOVFF  C0B,C5A
067BA:  MOVFF  C0A,C59
067BE:  MOVFF  C09,C58
067C2:  MOVFF  C08,C57
067C6:  MOVLW  0B
067C8:  MOVWF  x5C
067CA:  MOVLW  C1
067CC:  MOVWF  x5B
067CE:  CLRF   x5E
067D0:  MOVLW  40
067D2:  MOVWF  x5D
067D4:  MOVLB  0
067D6:  CALL   3170
....................             iv_data.used_counter += PACKET_SIZE;
067DA:  MOVLW  40
067DC:  MOVLB  3
067DE:  ADDWF  x2E,F
067E0:  MOVLW  00
067E2:  ADDWFC x2F,F
067E4:  MOVLW  00
067E6:  ADDWFC x30,F
067E8:  MOVLW  00
067EA:  ADDWFC x31,F
....................             iv_data.uncopied_counter += PACKET_SIZE;
067EC:  MOVLW  40
067EE:  ADDWF  x32,F
067F0:  MOVLW  00
067F2:  ADDWFC x33,F
067F4:  MOVLW  00
067F6:  ADDWFC x34,F
067F8:  MOVLW  00
067FA:  ADDWFC x35,F
....................             packetdata_index = 0;
067FC:  MOVLB  C
067FE:  CLRF   x01
....................             memset(packetdata, 0x00, PACKET_SIZE);
06800:  MOVLW  0B
06802:  MOVWF  FEA
06804:  MOVLW  C1
06806:  MOVWF  FE9
06808:  CLRF   00
0680A:  CLRF   02
0680C:  MOVLW  40
0680E:  MOVWF  01
06810:  MOVLB  0
06812:  CALL   3C00
....................         }
06816:  MOVLB  C
06818:  INCF   x02,F
0681A:  BTFSC  FD8.2
0681C:  INCF   x03,F
0681E:  MOVLB  0
06820:  GOTO   6620
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
06824:  MOVLB  C
06826:  MOVF   x01,F
06828:  BTFSS  FD8.2
0682A:  BRA    6832
0682C:  MOVLB  0
0682E:  GOTO   68FC
06832:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
06834:  MOVFF  C01,C0C
06838:  MOVLB  C
0683A:  MOVF   x0C,W
0683C:  SUBLW  3E
0683E:  BTFSC  FD8.0
06840:  BRA    6848
06842:  MOVLB  0
06844:  GOTO   6868
06848:  MOVLB  0
....................             packetdata[j] = 0x00;
0684A:  CLRF   03
0684C:  MOVLB  C
0684E:  MOVF   x0C,W
06850:  ADDLW  C1
06852:  MOVWF  FE9
06854:  MOVLW  0B
06856:  ADDWFC 03,W
06858:  MOVWF  FEA
0685A:  CLRF   FEF
0685C:  MOVLB  0
0685E:  MOVLB  C
06860:  INCF   x0C,F
06862:  MOVLB  0
06864:  GOTO   6838
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
06868:  MOVLW  0B
0686A:  MOVLB  C
0686C:  MOVWF  x54
0686E:  MOVLW  C1
06870:  MOVWF  x53
06872:  MOVLW  3F
06874:  MOVWF  x55
06876:  MOVLB  0
06878:  CALL   2A40
0687C:  MOVFF  01,C00
....................         unsigned int32 write_address = ADDRESS_MISF_MEASUREMENT_START + iv_data.used_counter;
06880:  MOVLB  3
06882:  MOVF   x2E,W
06884:  MOVLB  C
06886:  MOVWF  x0D
06888:  MOVLB  3
0688A:  MOVF   x2F,W
0688C:  MOVLB  C
0688E:  MOVWF  x0E
06890:  MOVLW  16
06892:  MOVLB  3
06894:  ADDWF  x30,W
06896:  MOVLB  C
06898:  MOVWF  x0F
0689A:  MOVLW  00
0689C:  MOVLB  3
0689E:  ADDWFC x31,W
068A0:  MOVLB  C
068A2:  MOVWF  x10
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
068A4:  MOVFF  301,C56
068A8:  MOVFF  300,C55
068AC:  MOVFF  2FF,C54
068B0:  MOVFF  2FE,C53
068B4:  MOVFF  C10,C5A
068B8:  MOVFF  C0F,C59
068BC:  MOVFF  C0E,C58
068C0:  MOVFF  C0D,C57
068C4:  MOVLW  0B
068C6:  MOVWF  x5C
068C8:  MOVLW  C1
068CA:  MOVWF  x5B
068CC:  CLRF   x5E
068CE:  MOVLW  40
068D0:  MOVWF  x5D
068D2:  MOVLB  0
068D4:  CALL   3170
....................         iv_data.used_counter += PACKET_SIZE;
068D8:  MOVLW  40
068DA:  MOVLB  3
068DC:  ADDWF  x2E,F
068DE:  MOVLW  00
068E0:  ADDWFC x2F,F
068E2:  MOVLW  00
068E4:  ADDWFC x30,F
068E6:  MOVLW  00
068E8:  ADDWFC x31,F
....................         iv_data.uncopied_counter += PACKET_SIZE;
068EA:  MOVLW  40
068EC:  ADDWF  x32,F
068EE:  MOVLW  00
068F0:  ADDWFC x33,F
068F2:  MOVLW  00
068F4:  ADDWFC x34,F
068F6:  MOVLW  00
068F8:  ADDWFC x35,F
068FA:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "End CIGS data conversion\r\n");
068FC:  MOVLW  CA
068FE:  MOVWF  FF6
06900:  MOVLW  07
06902:  MOVWF  FF7
06904:  MOVLW  00
06906:  MOVWF  FF8
06908:  CALL   1C14
....................     write_misf_address_area(); // Write the mission flash address area
0690C:  CALL   34F4
06910:  RETURN 0
.................... }
.................... 
.................... MEASUREMENT_DATA create_meas_data()
.................... {
....................     MEASUREMENT_DATA data;
....................     data.time_sec = get_current_sec();
*
060DC:  CALL   2E52
060E0:  MOVFF  03,BC6
060E4:  MOVFF  02,BC5
060E8:  MOVFF  01,BC4
060EC:  MOVFF  00,BC3
....................     data.time_msec = get_current_msec();
060F0:  GOTO   60AC
060F4:  MOVFF  01,BC7
....................     data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
060F8:  MOVLW  0D
060FA:  MOVLB  B
060FC:  MOVWF  xD2
060FE:  MOVLB  0
06100:  CALL   1E04
06104:  MOVFF  02,BCB
06108:  MOVFF  01,BCA
....................     data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
0610C:  MOVLW  0E
0610E:  MOVLB  B
06110:  MOVWF  xD2
06112:  MOVLB  0
06114:  CALL   1E04
06118:  MOVFF  02,BCD
0611C:  MOVFF  01,BCC
....................     data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
06120:  MOVLW  0C
06122:  MOVLB  B
06124:  MOVWF  xD2
06126:  MOVLB  0
06128:  CALL   1E04
0612C:  MOVFF  02,BCF
06130:  MOVFF  01,BCE
....................     data.pd = ad7490_read(ADC_PD);
06134:  MOVLW  0F
06136:  MOVLB  B
06138:  MOVWF  xD2
0613A:  MOVLB  0
0613C:  CALL   1E04
06140:  MOVFF  02,BD1
06144:  MOVFF  01,BD0
....................     data.open_voltage = ad7490_read(ADC_CIGS1_VOLT); // Assuming this is the correct ADC channel for open voltage
06148:  MOVLB  B
0614A:  CLRF   xD2
0614C:  MOVLB  0
0614E:  CALL   1E04
06152:  MOVFF  02,BC9
06156:  MOVFF  01,BC8
....................     return data;
0615A:  MOVLW  C3
0615C:  MOVWF  01
0615E:  MOVLW  0B
06160:  MOVWF  02
06162:  GOTO   79B0 (RETURN)
.................... }
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... unsigned int8 PICLOG_STARTUP = 0x00;
.................... 
.................... // PICLOG Parameter
.................... #define PICLOG_PARAM_START 0x01
.................... #define PICLOG_PARAM_END 0x02
.................... 
.................... 
.................... // PICLOG
.................... typedef union {
....................     struct {
....................         unsigned int32  time;
....................         unsigned int8   function;
....................         unsigned int8   parameter;
....................     };
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];  
.................... } PICLOG;
.................... 
.................... // extern宣言を追加（実体は.cファイルで定義）
.................... #define PICLOG_BLANK_SIZE 4 // PICLOGの空データサイズ
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00, 0x00}; // PICLOGの空データ
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/mcu/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../storage/mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
*
035F0:  CALL   2E52
035F4:  MOVFF  03,3DC
035F8:  MOVFF  02,3DB
035FC:  MOVFF  01,3DA
03600:  MOVFF  00,3D9
.................... {
....................     int8 piclog[PICLOG_PACKET_SIZE];
....................     int32 time = get_current_sec();
....................     piclog[0] = (time >> 24) & 0xFF; // Time high byte
03604:  MOVFF  3DC,3E2
03608:  MOVLB  3
0360A:  CLRF   xE3
0360C:  CLRF   xE4
0360E:  CLRF   xE5
03610:  MOVF   xE2,W
03612:  MOVWF  xD3
....................     piclog[1] = (time >> 16) & 0xFF;
03614:  MOVFF  3DB,3E2
03618:  MOVFF  3DC,3E3
0361C:  CLRF   xE4
0361E:  CLRF   xE5
03620:  MOVF   xE2,W
03622:  MOVWF  xD4
....................     piclog[2] = (time >> 8) & 0xFF;  // Time middle byte
03624:  MOVFF  3DA,3E2
03628:  MOVFF  3DB,3E3
0362C:  MOVFF  3DC,3E4
03630:  CLRF   xE5
03632:  MOVF   xE2,W
03634:  MOVWF  xD5
....................     piclog[3] = time & 0xFF;         // Time low byte
03636:  MOVF   xD9,W
03638:  MOVWF  xD6
....................     piclog[4] = function;            // Function code
0363A:  MOVFF  3D1,3D7
....................     piclog[5] = parameter;           // Parameter code
0363E:  MOVFF  3D2,3D8
.................... 
....................     #ifdef PICLOG_DEBUG
....................         printf("[PICLOG] : ");
....................         for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
....................             printf("%02X ", piclog[i]);
....................         }
....................         printf("\r\n");
....................     #endif
.................... 
....................     int32 write_address = ADDRESS_MISF_PICLOG_DATA_START + piclog_data.used_counter;
03642:  MOVF   x0D,W
03644:  MOVWF  xDD
03646:  MOVF   x0E,W
03648:  MOVWF  xDE
0364A:  MOVLW  02
0364C:  ADDWF  x0F,W
0364E:  MOVWF  xDF
03650:  MOVLW  00
03652:  ADDWFC x10,W
03654:  MOVWF  xE0
....................     
....................     write_data_bytes(mis_fm, (int32)write_address, piclog, (int16)PICLOG_PACKET_SIZE);
03656:  MOVFF  301,C56
0365A:  MOVFF  300,C55
0365E:  MOVFF  2FF,C54
03662:  MOVFF  2FE,C53
03666:  MOVFF  3E0,C5A
0366A:  MOVFF  3DF,C59
0366E:  MOVFF  3DE,C58
03672:  MOVFF  3DD,C57
03676:  MOVLW  03
03678:  MOVLB  C
0367A:  MOVWF  x5C
0367C:  MOVLW  D3
0367E:  MOVWF  x5B
03680:  CLRF   x5E
03682:  MOVLW  06
03684:  MOVWF  x5D
03686:  MOVLB  0
03688:  CALL   3170
....................     
....................     // 統合管理システムでカウンタを更新
....................     write_misf_address_area();
0368C:  CALL   34F4
.................... 
....................     // Next Packet
....................     if (piclog_data.reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
03690:  MOVLW  06
03692:  MOVLB  3
03694:  ADDWF  x15,W
03696:  SUBLW  3F
03698:  BTFSS  FD8.0
0369A:  BRA    36A2
0369C:  MOVLB  0
0369E:  GOTO   36F6
036A2:  MOVLB  0
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + piclog_data.used_counter;
036A4:  MOVLB  3
036A6:  MOVF   x0D,W
036A8:  MOVWF  xDD
036AA:  MOVF   x0E,W
036AC:  MOVWF  xDE
036AE:  MOVLW  02
036B0:  ADDWF  x0F,W
036B2:  MOVWF  xDF
036B4:  MOVLW  00
036B6:  ADDWFC x10,W
036B8:  MOVWF  xE0
....................         write_data_bytes(mis_fm, (int32)write_address, PICLOG_BLANK_DATA, (int16)PICLOG_PACKET_SIZE);
036BA:  MOVFF  301,C56
036BE:  MOVFF  300,C55
036C2:  MOVFF  2FF,C54
036C6:  MOVFF  2FE,C53
036CA:  MOVFF  3E0,C5A
036CE:  MOVFF  3DF,C59
036D2:  MOVFF  3DE,C58
036D6:  MOVFF  3DD,C57
036DA:  MOVLW  03
036DC:  MOVLB  C
036DE:  MOVWF  x5C
036E0:  MOVLW  39
036E2:  MOVWF  x5B
036E4:  CLRF   x5E
036E6:  MOVLW  06
036E8:  MOVWF  x5D
036EA:  MOVLB  0
036EC:  CALL   3170
....................         piclog_data.reserve_counter1 = 0;
036F0:  MOVLB  3
036F2:  CLRF   x15
036F4:  MOVLB  0
....................     }
.................... 
....................     write_misf_address_area(); // Update the address area after writing
036F6:  CALL   34F4
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
....................     #ifdef PICLOG_DEBUG
036FA:  RETURN 0
....................         //fprintf(PC, "PICLOG written: %02X %02X %02X %02X %02X %02X\r\n", piclog_data.bytes[0], data[1], data[2], data[3], data[4], data[5]);
....................     #endif
.................... }
.................... 
.................... #include "../core/storage/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... #include "../../../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_MEASURE_DATA_START_ADDRESS 0x06AA1000
.................... #define CIGS_MEASURE_DATA_END_ADDRESS 0x07AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x07AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x07AA1FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void read_smf_header()
.................... {
....................     int8 read_data[PACKET_SIZE];
....................     int8 retry_count;
....................     
....................     // 統合管理システムから読み込み操作をキューに追加
....................     FlashOperationStruct read_op;
....................     read_op.mission_id = 0x01;
....................     read_op.func_type = SMF_READ;
....................     read_op.src = CIGS_DATA_TABLE_START_ADDRESS;
....................     read_op.size = PACKET_SIZE;
....................     read_op.manager = get_misf_smf_manager(0x01);
....................     enqueue_flash_operation(&read_op);
....................     
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, read_data, PACKET_SIZE);
....................         if (is_crc_valid(read_data, PACKET_SIZE-1))
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     param.meas.used_size = lsb_array_to_int32(read_data, 0);
....................     param.meas.loop_counter = read_data[4];
....................     param.piclog.used_size = lsb_array_to_int32(read_data, 5);
....................     param.piclog.loop_counter = read_data[9];
.................... }
.................... 
.................... void write_smf_header()
.................... {
....................     int8 writedata[PACKET_SIZE];
.................... 
....................     // ヘッダー情報をwritedataに設定
....................     int32_to_be_array(param.meas.used_size, writedata, 0);
....................     writedata[4] = param.meas.loop_counter;
....................     int32_to_be_array(param.piclog.used_size, writedata, 5);
....................     writedata[9] = param.piclog.loop_counter;
.................... 
....................     writedata[63] = calc_crc8(writedata, PACKET_SIZE-1); // CRCを計算してバッファに書き込み
.................... 
....................     // 統合管理システムから書き込み操作をキューに追加
....................     FlashOperationStruct write_op;
....................     write_op.mission_id = 0x01;
....................     write_op.func_type = SMF_WRITE;
....................     write_op.write_mode = SMF_WRITE_OVERWRITE;
....................     write_op.source_type = SOURCE_MISF_MANUAL;
....................     write_op.src = CIGS_DATA_TABLE_START_ADDRESS;
....................     write_op.size = PACKET_SIZE;
....................     write_op.manager = get_misf_smf_manager(0x01);
....................     enqueue_flash_operation(&write_op);
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, writedata, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
....................     fprintf(PC, "___Start copy_data__\r\n");
....................     
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfMissionStruct mission_type = get_smf_mission_struct(smf_data->func_type);
....................     // status[1] = smf_data->mission_id; // `i` is assigned mis mcu status flag. so mission_flag start `i+1`
....................     unsigned int32 mis_start_address = mission_type.start_address;
....................     unsigned int32 mis_end_address = mission_type.end_address;
....................     unsigned int32 write_src = smf_data->src;
....................     unsigned int32 write_size = smf_data->size;
....................     fprintf(PC, "In SMF mission data start   address: %LX\r\n", mis_start_address);
....................     fprintf(PC, "In SMF mission data end     address: %LX\r\n", mis_end_address);
....................     fprintf(PC, "In MIS FM Write source data address: %LX\r\n", write_src);
....................     fprintf(PC, "In MIS FM Write data size          : %lu (0x%lx)\r\n\r\n", write_size, write_size);
.................... 
....................     if (!is_connect(mis_fm))
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
....................     }    
.................... 
....................     if (!is_connect(smf))
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
....................     }    
.................... 
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header();
.................... 
....................     // PartitionParamから値を取得
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
....................     fprintf(PC, "Size area read\r\n");
....................     fprintf(PC, "used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
....................     fprintf(PC, "loop count= %d  (src 0x%08LX)\r\n\r\n", loop_count, mis_start_address + 4);
....................     
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
....................         loop_count++;
....................         used_size = 0;
....................         data_write_addr = data_region_start;
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
....................         
....................         unsigned int32 erase_ptr = data_region_start;
....................         while (erase_ptr < data_region_end)
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
....................         subsector_4kByte_erase(smf, addr);
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     while (remaining > 0)
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
....................         for (unsigned int32 i = 0; i < chunk; i++)
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
....................         }
....................         src_addr += chunk;
....................         data_write_addr += chunk;
....................         used_size += chunk;
....................         remaining -= chunk;
....................     }
....................     // write size area
....................     write_smf_header();
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
....................     fprintf(PC, "____________________\r\n\r\n");
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
....................     fprintf(PC, "___Start SMF Read____\r\n");
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfMissionStruct mission_type = get_smf_mission_struct(smf_data->func_type);
....................     // status[1] = smf_data->mission_id; // `i` is assigned mis mcu status flag. so mission_flag start `i+1`
....................     unsigned int32 read_src = smf_data->src;
....................     unsigned int32 read_size = smf_data->size;
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_src);
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
.................... 
....................     if (!is_connect(smf)){
....................         fprintf(PC, "Error: SMF is not connected\r\n");
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
....................     for (unsigned int32 addr = read_src; addr < read_src + read_size; addr += PACKET_SIZE)
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
....................         }
....................         fprintf(PC, "\r\n");
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
....................     fprintf(PC, "____________________\r\n\r\n");
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
....................     fprintf(PC, "___Start smf_erase____\r\n");
.................... 
....................     SmfMissionStruct mission_type = get_smf_mission_struct(smf_data->func_type);
....................     // status[1] = smf_data->mission_id; // `i` is assigned mis mcu status flag. so mission_flag start `i+1`
....................     unsigned int32 mis_start_address = mission_type.start_address;
....................     unsigned int32 mis_end_address = mission_type.end_address;
....................     unsigned int32 erase_src = smf_data->src;
....................     unsigned int32 erase_size = smf_data->size;
....................     fprintf(PC, "In SMF mission data start   address: %LX\r\n", mis_start_address);
....................     fprintf(PC, "In SMF mission data end     address: %LX\r\n", mis_end_address);
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_src);
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
.................... 
....................     if (!is_connect(smf)){
....................         fprintf(PC, "Error: SMF is not connected\r\n");
....................         return;
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_src < mis_start_address || erase_src >= mis_end_address) {
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_src, mis_start_address, mis_end_address);
....................         return;
....................     }
....................     
....................     if ((erase_src + erase_size) > mis_end_address) {
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mis_end_address);
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
....................         erase_size = mis_end_address - erase_src;
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
....................     subsector_4kByte_erase(smf, erase_src);
....................     
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
....................     fprintf(PC, "____________________\r\n\r\n");
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... 
.................... #include "../core/storage/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           // 同じフォルダのヘッダー
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=0, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"                // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"             // ツールライブラリ
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"              // SMFキュー管理
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
02AAC:  MOVLW  06
02AAE:  MOVWF  FF6
02AB0:  MOVLW  0E
02AB2:  MOVWF  FF7
02AB4:  MOVLW  00
02AB6:  MOVWF  FF8
02AB8:  CALL   1C14
.................... 
....................     // 初期状態としてCSを非アクティブに
....................     output_high(MIS_FM_CS);
02ABC:  MOVLW  DB
02ABE:  MOVWF  F92
02AC0:  BSF    F89.5
....................     output_high(SMF_CS);
02AC2:  MOVLW  DB
02AC4:  MOVWF  F92
02AC6:  BSF    F89.2
....................     delay_ms(100);
02AC8:  MOVLW  64
02ACA:  MOVLB  C
02ACC:  MOVWF  x6B
02ACE:  MOVLB  0
02AD0:  CALL   1B94
.................... 
....................     //=== [MIS_FM] READ ID ===//
....................     READ_ID_DATA misf_read_id_data;
....................     int8 flash_cmd = CMD_READ_ID;
02AD4:  MOVLW  9F
02AD6:  MOVLB  3
02AD8:  MOVWF  xD6
.................... 
....................     output_low(mis_fm.cs_pin);
02ADA:  MOVFF  300,C71
02ADE:  MOVLB  C
02AE0:  CLRF   x72
02AE2:  MOVLW  0F
02AE4:  MOVWF  x74
02AE6:  MOVLW  89
02AE8:  MOVWF  x73
02AEA:  MOVLB  0
02AEC:  CALL   23AA
02AF0:  MOVFF  300,C71
02AF4:  MOVLB  C
02AF6:  CLRF   x72
02AF8:  MOVLW  0F
02AFA:  MOVWF  x74
02AFC:  MOVLW  92
02AFE:  MOVWF  x73
02B00:  MOVLB  0
02B02:  CALL   23AA
....................     spi_xfer_and_read_select_stream(mis_fm, &flash_cmd, 1, misf_read_id_data.bytes, READ_ID_DATASIZE);
02B06:  MOVFF  301,C74
02B0A:  MOVFF  300,C73
02B0E:  MOVFF  2FF,C72
02B12:  MOVFF  2FE,C71
02B16:  MOVLW  03
02B18:  MOVLB  C
02B1A:  MOVWF  x76
02B1C:  MOVLW  D6
02B1E:  MOVWF  x75
02B20:  CLRF   x78
02B22:  MOVLW  01
02B24:  MOVWF  x77
02B26:  MOVLW  03
02B28:  MOVWF  x7A
02B2A:  MOVLW  C2
02B2C:  MOVWF  x79
02B2E:  CLRF   x7E
02B30:  CLRF   x7D
02B32:  CLRF   x7C
02B34:  MOVLW  14
02B36:  MOVWF  x7B
02B38:  MOVLB  0
02B3A:  CALL   24F6
....................     output_high(mis_fm.cs_pin);
02B3E:  MOVFF  300,C71
02B42:  MOVLW  01
02B44:  MOVLB  C
02B46:  MOVWF  x72
02B48:  MOVLW  0F
02B4A:  MOVWF  x74
02B4C:  MOVLW  89
02B4E:  MOVWF  x73
02B50:  MOVLB  0
02B52:  CALL   23AA
02B56:  MOVFF  300,C71
02B5A:  MOVLB  C
02B5C:  CLRF   x72
02B5E:  MOVLW  0F
02B60:  MOVWF  x74
02B62:  MOVLW  92
02B64:  MOVWF  x73
02B66:  MOVLB  0
02B68:  CALL   23AA
.................... 
....................     fprintf(PC, "\t[MIS FM] READ ID: ");
02B6C:  MOVLW  22
02B6E:  MOVWF  FF6
02B70:  MOVLW  0E
02B72:  MOVWF  FF7
02B74:  MOVLW  00
02B76:  MOVWF  FF8
02B78:  CALL   1C14
....................     for (unsigned int8 i = 0; i < 4; i++) {
02B7C:  MOVLB  3
02B7E:  CLRF   xD7
02B80:  MOVLB  0
02B82:  MOVLB  3
02B84:  MOVF   xD7,W
02B86:  SUBLW  03
02B88:  BTFSC  FD8.0
02B8A:  BRA    2B92
02B8C:  MOVLB  0
02B8E:  GOTO   2BCE
02B92:  MOVLB  0
....................         fprintf(PC, "%02X ", misf_read_id_data.bytes[i]);
02B94:  CLRF   03
02B96:  MOVLB  3
02B98:  MOVF   xD7,W
02B9A:  ADDLW  C2
02B9C:  MOVWF  FE9
02B9E:  MOVLW  03
02BA0:  ADDWFC 03,W
02BA2:  MOVWF  FEA
02BA4:  MOVFF  FEF,42D
02BA8:  MOVFF  42D,BC1
02BAC:  MOVLW  37
02BAE:  MOVLB  B
02BB0:  MOVWF  xC2
02BB2:  MOVLB  0
02BB4:  CALL   1E98
02BB8:  MOVLW  20
02BBA:  MOVLB  C
02BBC:  MOVWF  x14
02BBE:  MOVLB  0
02BC0:  CALL   1BC2
02BC4:  MOVLB  3
02BC6:  INCF   xD7,F
02BC8:  MOVLB  0
02BCA:  GOTO   2B82
....................     }
....................     fprintf(PC, "\r\n");
02BCE:  MOVLW  0D
02BD0:  MOVLB  C
02BD2:  MOVWF  x14
02BD4:  MOVLB  0
02BD6:  CALL   1BC2
02BDA:  MOVLW  0A
02BDC:  MOVLB  C
02BDE:  MOVWF  x14
02BE0:  MOVLB  0
02BE2:  CALL   1BC2
.................... 
....................     //=== [SMF] READ ID ===//
....................     READ_ID_DATA smf_read_id_data;
.................... 
....................     output_low(SMF_CS);
02BE6:  MOVLW  DB
02BE8:  MOVWF  F92
02BEA:  BCF    F89.2
....................     delay_us(100); // 微小ディレイ
02BEC:  MOVLW  85
02BEE:  MOVWF  00
02BF0:  DECFSZ 00,F
02BF2:  BRA    2BF0
....................     spi_xfer_and_read_select_stream(smf, &flash_cmd, 1, smf_read_id_data.bytes, READ_ID_DATASIZE);
02BF4:  MOVFF  305,C74
02BF8:  MOVFF  304,C73
02BFC:  MOVFF  303,C72
02C00:  MOVFF  302,C71
02C04:  MOVLW  03
02C06:  MOVLB  C
02C08:  MOVWF  x76
02C0A:  MOVLW  D6
02C0C:  MOVWF  x75
02C0E:  CLRF   x78
02C10:  MOVLW  01
02C12:  MOVWF  x77
02C14:  MOVLW  03
02C16:  MOVWF  x7A
02C18:  MOVLW  D8
02C1A:  MOVWF  x79
02C1C:  CLRF   x7E
02C1E:  CLRF   x7D
02C20:  CLRF   x7C
02C22:  MOVLW  14
02C24:  MOVWF  x7B
02C26:  MOVLB  0
02C28:  CALL   24F6
....................     output_high(SMF_CS);
02C2C:  MOVLW  DB
02C2E:  MOVWF  F92
02C30:  BSF    F89.2
.................... 
....................     fprintf(PC, "\t[SMF   ] READ ID: ");
02C32:  MOVLW  36
02C34:  MOVWF  FF6
02C36:  MOVLW  0E
02C38:  MOVWF  FF7
02C3A:  MOVLW  00
02C3C:  MOVWF  FF8
02C3E:  CALL   1C14
....................     for (unsigned int8 i = 0; i < 4; i++) {
02C42:  MOVLB  3
02C44:  CLRF   xEC
02C46:  MOVLB  0
02C48:  MOVLB  3
02C4A:  MOVF   xEC,W
02C4C:  SUBLW  03
02C4E:  BTFSC  FD8.0
02C50:  BRA    2C58
02C52:  MOVLB  0
02C54:  GOTO   2C94
02C58:  MOVLB  0
....................         fprintf(PC, "%02X ", smf_read_id_data.bytes[i]);
02C5A:  CLRF   03
02C5C:  MOVLB  3
02C5E:  MOVF   xEC,W
02C60:  ADDLW  D8
02C62:  MOVWF  FE9
02C64:  MOVLW  03
02C66:  ADDWFC 03,W
02C68:  MOVWF  FEA
02C6A:  MOVFF  FEF,42D
02C6E:  MOVFF  42D,BC1
02C72:  MOVLW  37
02C74:  MOVLB  B
02C76:  MOVWF  xC2
02C78:  MOVLB  0
02C7A:  CALL   1E98
02C7E:  MOVLW  20
02C80:  MOVLB  C
02C82:  MOVWF  x14
02C84:  MOVLB  0
02C86:  CALL   1BC2
02C8A:  MOVLB  3
02C8C:  INCF   xEC,F
02C8E:  MOVLB  0
02C90:  GOTO   2C48
....................     }
....................     fprintf(PC, "\r\n");
02C94:  MOVLW  0D
02C96:  MOVLB  C
02C98:  MOVWF  x14
02C9A:  MOVLB  0
02C9C:  CALL   1BC2
02CA0:  MOVLW  0A
02CA2:  MOVLB  C
02CA4:  MOVWF  x14
02CA6:  MOVLB  0
02CA8:  CALL   1BC2
.................... 
....................     //=== 接続確認 ===//
....................     if (!is_connect(smf)) {
02CAC:  MOVFF  305,430
02CB0:  MOVFF  304,42F
02CB4:  MOVFF  303,42E
02CB8:  MOVFF  302,42D
02CBC:  CALL   272A
02CC0:  MOVF   01,F
02CC2:  BTFSS  FD8.2
02CC4:  GOTO   2CDC
....................         fprintf(PC, "\t[SMF   ] connect error!\r\n");
02CC8:  MOVLW  4A
02CCA:  MOVWF  FF6
02CCC:  MOVLW  0E
02CCE:  MOVWF  FF7
02CD0:  MOVLW  00
02CD2:  MOVWF  FF8
02CD4:  CALL   1C14
....................     } else {
02CD8:  GOTO   2CEC
....................         fprintf(PC, "\t[SMF   ] is connected\r\n");
02CDC:  MOVLW  66
02CDE:  MOVWF  FF6
02CE0:  MOVLW  0E
02CE2:  MOVWF  FF7
02CE4:  MOVLW  00
02CE6:  MOVWF  FF8
02CE8:  CALL   1C14
....................     }
.................... 
....................     delay_ms(100);
02CEC:  MOVLW  64
02CEE:  MOVLB  C
02CF0:  MOVWF  x6B
02CF2:  MOVLB  0
02CF4:  CALL   1B94
.................... 
....................     if (!is_connect(mis_fm)) {
02CF8:  MOVFF  301,430
02CFC:  MOVFF  300,42F
02D00:  MOVFF  2FF,42E
02D04:  MOVFF  2FE,42D
02D08:  CALL   272A
02D0C:  MOVF   01,F
02D0E:  BTFSS  FD8.2
02D10:  GOTO   2D28
....................         fprintf(PC, "\t[MIS FM] connect error!\r\n");
02D14:  MOVLW  80
02D16:  MOVWF  FF6
02D18:  MOVLW  0E
02D1A:  MOVWF  FF7
02D1C:  MOVLW  00
02D1E:  MOVWF  FF8
02D20:  CALL   1C14
....................     } else {
02D24:  GOTO   2D38
....................         fprintf(PC, "\t[MIS FM] is connected\r\n");
02D28:  MOVLW  9C
02D2A:  MOVWF  FF6
02D2C:  MOVLW  0E
02D2E:  MOVWF  FF7
02D30:  MOVLW  00
02D32:  MOVWF  FF8
02D34:  CALL   1C14
....................     }
.................... 
....................     //=== MIS_FMからログ領域読み出し ===//
....................     FlashData_t flash_data;
....................     read_misf_address_area(flash_data.bytes);
02D38:  MOVLW  03
02D3A:  MOVLB  4
02D3C:  MOVWF  x2E
02D3E:  MOVLW  ED
02D40:  MOVWF  x2D
02D42:  MOVFF  42E,430
02D46:  MOVFF  42D,42F
02D4A:  MOVLB  0
02D4C:  GOTO   2A0A
.................... 
....................     if (flash_data.packet.crc != calc_crc8(flash_data.bytes, PACKET_SIZE - 1)) {
02D50:  MOVFF  42B,42D
02D54:  MOVLW  03
02D56:  MOVLB  4
02D58:  MOVWF  x2F
02D5A:  MOVLW  ED
02D5C:  MOVWF  x2E
02D5E:  MOVFF  42F,C54
02D62:  MOVFF  42E,C53
02D66:  MOVLW  3F
02D68:  MOVLB  C
02D6A:  MOVWF  x55
02D6C:  MOVLB  0
02D6E:  CALL   2A40
02D72:  MOVF   01,W
02D74:  MOVLB  4
02D76:  SUBWF  x2D,W
02D78:  BTFSS  FD8.2
02D7A:  BRA    2D82
02D7C:  MOVLB  0
02D7E:  GOTO   2D98
02D82:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error!\r\n");
02D84:  MOVLW  B6
02D86:  MOVWF  FF6
02D88:  MOVLW  0E
02D8A:  MOVWF  FF7
02D8C:  MOVLW  00
02D8E:  MOVWF  FF8
02D90:  CALL   1C14
....................         return;
02D94:  GOTO   2E50
....................     }
.................... 
....................     //=== カウンタ情報の反映 ===//
....................     piclog_data       = *((Flash_t*)&flash_data.packet.payload.logdata.piclog);
02D98:  MOVLW  03
02D9A:  MOVLB  4
02D9C:  MOVWF  x2E
02D9E:  MOVLW  ED
02DA0:  MOVWF  x2D
02DA2:  MOVFF  42E,03
02DA6:  MOVF   x2D,W
02DA8:  MOVWF  FE1
02DAA:  MOVFF  03,FE2
02DAE:  MOVLW  03
02DB0:  MOVWF  FEA
02DB2:  MOVLW  0C
02DB4:  MOVWF  FE9
02DB6:  MOVLW  0B
02DB8:  MOVWF  01
02DBA:  MOVLB  0
02DBC:  MOVFF  FE6,FEE
02DC0:  DECFSZ 01,F
02DC2:  GOTO   2DBC
....................     environment_data  = *((Flash_t*)&flash_data.packet.payload.logdata.environment);
02DC6:  MOVLW  03
02DC8:  MOVLB  4
02DCA:  MOVWF  x2E
02DCC:  MOVLW  F7
02DCE:  MOVWF  x2D
02DD0:  MOVFF  42E,03
02DD4:  MOVF   x2D,W
02DD6:  MOVWF  FE1
02DD8:  MOVFF  03,FE2
02DDC:  MOVLW  03
02DDE:  MOVWF  FEA
02DE0:  MOVLW  17
02DE2:  MOVWF  FE9
02DE4:  MOVLW  0B
02DE6:  MOVWF  01
02DE8:  MOVLB  0
02DEA:  MOVFF  FE6,FEE
02DEE:  DECFSZ 01,F
02DF0:  GOTO   2DEA
....................     iv_header         = *((Flash_t*)&flash_data.packet.payload.logdata.iv_header);
02DF4:  MOVLW  04
02DF6:  MOVLB  4
02DF8:  MOVWF  x2E
02DFA:  MOVLW  01
02DFC:  MOVWF  x2D
02DFE:  MOVFF  42E,03
02E02:  MOVF   x2D,W
02E04:  MOVWF  FE1
02E06:  MOVFF  03,FE2
02E0A:  MOVLW  03
02E0C:  MOVWF  FEA
02E0E:  MOVLW  22
02E10:  MOVWF  FE9
02E12:  MOVLW  0B
02E14:  MOVWF  01
02E16:  MOVLB  0
02E18:  MOVFF  FE6,FEE
02E1C:  DECFSZ 01,F
02E1E:  GOTO   2E18
....................     iv_data           = *((Flash_t*)&flash_data.packet.payload.logdata.iv_data);
02E22:  MOVLW  04
02E24:  MOVLB  4
02E26:  MOVWF  x2E
02E28:  MOVLW  0B
02E2A:  MOVWF  x2D
02E2C:  MOVFF  42E,03
02E30:  MOVF   x2D,W
02E32:  MOVWF  FE1
02E34:  MOVFF  03,FE2
02E38:  MOVLW  03
02E3A:  MOVWF  FEA
02E3C:  MOVLW  2D
02E3E:  MOVWF  FE9
02E40:  MOVLW  0B
02E42:  MOVWF  01
02E44:  MOVLB  0
02E46:  MOVFF  FE6,FEE
02E4A:  DECFSZ 01,F
02E4C:  GOTO   2E46
02E50:  RETURN 0
.................... }
.................... 
.................... void smf_init()
.................... {
*
0576E:  GOTO   58F2 (RETURN)
....................    //Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... void read_misf_address_area(unsigned int8 *data)
.................... {
....................     read_data_bytes(mis_fm, ADDRESS_MANAGE_START, data, PACKET_SIZE);
*
02A0A:  MOVFF  301,48C
02A0E:  MOVFF  300,48B
02A12:  MOVFF  2FF,48A
02A16:  MOVFF  2FE,489
02A1A:  MOVLB  4
02A1C:  CLRF   x90
02A1E:  CLRF   x8F
02A20:  CLRF   x8E
02A22:  CLRF   x8D
02A24:  MOVFF  430,492
02A28:  MOVFF  42F,491
02A2C:  CLRF   x96
02A2E:  CLRF   x95
02A30:  CLRF   x94
02A32:  MOVLW  40
02A34:  MOVWF  x93
02A36:  MOVLB  0
02A38:  CALL   27F2
02A3C:  GOTO   2D50 (RETURN)
.................... }
.................... 
.................... void write_misf_address_area()
.................... {
....................     FlashData_t flash_data;
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
*
034F4:  MOVLW  0C
034F6:  MOVLB  C
034F8:  MOVWF  x52
034FA:  MOVLW  11
034FC:  MOVWF  x51
034FE:  MOVFF  C52,C54
03502:  MOVFF  C51,C53
03506:  MOVLW  3F
03508:  MOVWF  x55
0350A:  MOVLB  0
0350C:  CALL   2A40
03510:  MOVFF  01,C51
03514:  MOVFF  C51,C4F
....................     flash_data.packet.payload.logdata.piclog.used_counter = piclog_data.used_counter;
03518:  MOVFF  30D,C11
0351C:  MOVFF  30E,C12
03520:  MOVFF  30F,C13
03524:  MOVFF  310,C14
....................     flash_data.packet.payload.logdata.piclog.uncopied_counter = piclog_data.uncopied_counter;
03528:  MOVFF  311,C15
0352C:  MOVFF  312,C16
03530:  MOVFF  313,C17
03534:  MOVFF  314,C18
....................     flash_data.packet.payload.logdata.piclog.reserve_counter1 = piclog_data.reserve_counter1;
03538:  MOVFF  315,C19
....................     flash_data.packet.payload.logdata.piclog.reserve_counter2 = piclog_data.reserve_counter2;
0353C:  MOVFF  316,C1A
....................     flash_data.packet.payload.logdata.environment.used_counter = environment_data.used_counter;
03540:  MOVFF  318,C1B
03544:  MOVFF  319,C1C
03548:  MOVFF  31A,C1D
0354C:  MOVFF  31B,C1E
....................     flash_data.packet.payload.logdata.environment.uncopied_counter = environment_data.uncopied_counter;
03550:  MOVFF  31C,C1F
03554:  MOVFF  31D,C20
03558:  MOVFF  31E,C21
0355C:  MOVFF  31F,C22
....................     flash_data.packet.payload.logdata.environment.reserve_counter1 = environment_data.reserve_counter1;
03560:  MOVFF  320,C23
....................     flash_data.packet.payload.logdata.environment.reserve_counter2 = environment_data.reserve_counter2;
03564:  MOVFF  321,C24
....................     flash_data.packet.payload.logdata.iv_header.used_counter = iv_header.used_counter;
03568:  MOVFF  323,C25
0356C:  MOVFF  324,C26
03570:  MOVFF  325,C27
03574:  MOVFF  326,C28
....................     flash_data.packet.payload.logdata.iv_header.uncopied_counter = iv_header.uncopied_counter;
03578:  MOVFF  327,C29
0357C:  MOVFF  328,C2A
03580:  MOVFF  329,C2B
03584:  MOVFF  32A,C2C
....................     flash_data.packet.payload.logdata.iv_header.reserve_counter1 = iv_header.reserve_counter1;
03588:  MOVFF  32B,C2D
....................     flash_data.packet.payload.logdata.iv_header.reserve_counter2 = iv_header.reserve_counter2;
0358C:  MOVFF  32C,C2E
....................     flash_data.packet.payload.logdata.iv_data.used_counter = iv_data.used_counter;
03590:  MOVFF  32E,C2F
03594:  MOVFF  32F,C30
03598:  MOVFF  330,C31
0359C:  MOVFF  331,C32
....................     flash_data.packet.payload.logdata.iv_data.uncopied_counter = iv_data.uncopied_counter;
035A0:  MOVFF  332,C33
035A4:  MOVFF  333,C34
035A8:  MOVFF  334,C35
035AC:  MOVFF  335,C36
....................     flash_data.packet.payload.logdata.iv_data.reserve_counter1 = iv_data.reserve_counter1;
035B0:  MOVFF  336,C37
....................     flash_data.packet.payload.logdata.iv_data.reserve_counter2 = iv_data.reserve_counter2;
035B4:  MOVFF  337,C38
.................... 
....................     write_data_bytes(mis_fm, ADDRESS_MANAGE_START, flash_data.bytes, PACKET_SIZE);
035B8:  MOVLW  0C
035BA:  MOVLB  C
035BC:  MOVWF  x52
035BE:  MOVLW  11
035C0:  MOVWF  x51
035C2:  MOVFF  301,C56
035C6:  MOVFF  300,C55
035CA:  MOVFF  2FF,C54
035CE:  MOVFF  2FE,C53
035D2:  CLRF   x5A
035D4:  CLRF   x59
035D6:  CLRF   x58
035D8:  CLRF   x57
035DA:  MOVFF  C52,C5C
035DE:  MOVFF  C51,C5B
035E2:  CLRF   x5E
035E4:  MOVLW  40
035E6:  MOVWF  x5D
035E8:  MOVLB  0
035EA:  CALL   3170
035EE:  RETURN 0
.................... }
.................... 
.................... void add_smf_queue(int8 mission_id)
.................... {
....................     FlashOperationStruct data;
....................     SmfMissionStruct mis_struct;
....................     
....................     // 構造体の初期化
....................     data.func_type = SMF_WRITE;
....................     data.mission_id = mission_id;
....................     data.write_mode = SMF_WRITE_CIRCULAR;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     data.src = 0;
....................     data.size = 0;
....................     data.misf_start_addr = 0;
....................     data.misf_size = 0;
....................     data.manager = 0;
....................     
....................     //mis_struct = get_smf_mission_struct(SMF_WRITE);
.................... 
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG    | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
....................     fprintf(PC, "\t| MISF | PICLOG    | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
....................     fprintf(PC, "\t| MISF | ENVIRO    | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
....................     fprintf(PC, "\t| MISF | ENVIRO    | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
....................     fprintf(PC, "\t| MISF | IV HEADER | Use Counter      : 0x%08LX\r\n", iv_header.used_counter);
....................     fprintf(PC, "\t| MISF | IV HEADER | Uncopyed Counter : 0x%08LX\r\n", iv_header.uncopied_counter);
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter1 : 0x%02X\r\n", iv_header.reserve_counter1);
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter2 : 0x%02X\r\n", iv_header.reserve_counter2);
....................     fprintf(PC, "\t| MISF | IV DATA   | Use Counter      : 0x%08LX\r\n", iv_data.used_counter);
....................     fprintf(PC, "\t| MISF | IV DATA   | Uncopyed Counter : 0x%08LX\r\n", iv_data.uncopied_counter);
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter1 : 0x%02X\r\n", iv_data.reserve_counter1);
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter2 : 0x%02X\r\n", iv_data.reserve_counter2);
.................... 
.................... 
....................     fprintf(PC, "\tComplete\r\n");
.................... }
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "../application/mission/mmj_cigs_excute_mission.c"
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=0, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
086E4:  MOVLB  3
086E6:  MOVF   x7B,W
086E8:  MOVWF  FE9
086EA:  MOVF   x7C,W
086EC:  MOVWF  FEA
086EE:  MOVFF  FEF,37D
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
086F2:  MOVLW  0A
086F4:  MOVWF  FF6
086F6:  MOVLW  12
086F8:  MOVWF  FF7
086FA:  MOVLW  00
086FC:  MOVWF  FF8
086FE:  MOVLB  0
08700:  CALL   1C14
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
08704:  MOVLW  50
08706:  MOVWF  FF6
08708:  MOVLW  12
0870A:  MOVWF  FF7
0870C:  MOVLW  00
0870E:  MOVWF  FF8
08710:  MOVLW  0C
08712:  MOVLB  B
08714:  MOVWF  xC1
08716:  MOVLB  0
08718:  CALL   1C44
0871C:  MOVFF  37D,BC1
08720:  MOVLW  37
08722:  MOVLB  B
08724:  MOVWF  xC2
08726:  MOVLB  0
08728:  CALL   1E98
0872C:  MOVLW  5E
0872E:  MOVWF  FF6
08730:  MOVLW  12
08732:  MOVWF  FF7
08734:  MOVLW  00
08736:  MOVWF  FF8
08738:  MOVLW  04
0873A:  MOVLB  B
0873C:  MOVWF  xC1
0873E:  MOVLB  0
08740:  CALL   1C44
....................    switch(command_id)
08744:  MOVLB  3
08746:  MOVF   x7D,W
08748:  XORLW  10
0874A:  MOVLB  0
0874C:  BTFSC  FD8.2
0874E:  GOTO   87FE
08752:  XORLW  01
08754:  BTFSC  FD8.2
08756:  GOTO   8802
0875A:  XORLW  03
0875C:  BTFSC  FD8.2
0875E:  GOTO   8806
08762:  XORLW  13
08764:  BTFSC  FD8.2
08766:  GOTO   880A
0876A:  XORLW  12
0876C:  BTFSC  FD8.2
0876E:  GOTO   880E
08772:  XORLW  93
08774:  BTFSC  FD8.2
08776:  GOTO   8812
0877A:  XORLW  01
0877C:  BTFSC  FD8.2
0877E:  GOTO   8822
08782:  XORLW  03
08784:  BTFSC  FD8.2
08786:  GOTO   8832
0878A:  XORLW  01
0878C:  BTFSC  FD8.2
0878E:  GOTO   8842
08792:  XORLW  07
08794:  BTFSC  FD8.2
08796:  GOTO   8852
0879A:  XORLW  01
0879C:  BTFSC  FD8.2
0879E:  GOTO   8862
087A2:  XORLW  03
087A4:  BTFSC  FD8.2
087A6:  GOTO   8872
087AA:  XORLW  01
087AC:  BTFSC  FD8.2
087AE:  GOTO   8882
087B2:  XORLW  0F
087B4:  BTFSC  FD8.2
087B6:  GOTO   8892
087BA:  XORLW  18
087BC:  BTFSC  FD8.2
087BE:  GOTO   88A2
087C2:  XORLW  01
087C4:  BTFSC  FD8.2
087C6:  GOTO   88B2
087CA:  XORLW  03
087CC:  BTFSC  FD8.2
087CE:  GOTO   88C2
087D2:  XORLW  01
087D4:  BTFSC  FD8.2
087D6:  GOTO   88D2
087DA:  XORLW  07
087DC:  BTFSC  FD8.2
087DE:  GOTO   88E2
087E2:  XORLW  01
087E4:  BTFSC  FD8.2
087E6:  GOTO   88F2
087EA:  XORLW  03
087EC:  BTFSC  FD8.2
087EE:  GOTO   8902
087F2:  XORLW  36
087F4:  BTFSC  FD8.2
087F6:  GOTO   8912
087FA:  GOTO   8922
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
087FE:  GOTO   8932
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
08802:  GOTO   8932
....................       case 0x12:
....................          // test_adc();
....................          break;
08806:  GOTO   8932
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
0880A:  GOTO   8932
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
0880E:  GOTO   8932
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
08812:  MOVFF  37C,381
08816:  MOVFF  37B,380
0881A:  CALL   412E
....................          break;
0881E:  GOTO   8932
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
08822:  MOVFF  37C,37F
08826:  MOVFF  37B,37E
0882A:  GOTO   41F4
....................          break;
0882E:  GOTO   8932
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
08832:  MOVFF  37C,37F
08836:  MOVFF  37B,37E
0883A:  GOTO   46EC
....................          break;
0883E:  GOTO   8932
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
08842:  MOVFF  37C,37F
08846:  MOVFF  37B,37E
0884A:  GOTO   4882
....................          break;
0884E:  GOTO   8932
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
08852:  MOVFF  37C,37F
08856:  MOVFF  37B,37E
0885A:  GOTO   49F8
....................          break;
0885E:  GOTO   8932
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
08862:  MOVFF  37C,37F
08866:  MOVFF  37B,37E
0886A:  GOTO   4DF6
....................          break;
0886E:  GOTO   8932
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
08872:  MOVFF  37C,37F
08876:  MOVFF  37B,37E
0887A:  GOTO   4E6E
....................          break;
0887E:  GOTO   8932
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
08882:  MOVFF  37C,37F
08886:  MOVFF  37B,37E
0888A:  GOTO   52F6
....................          break;
0888E:  GOTO   8932
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
08892:  MOVFF  37C,37F
08896:  MOVFF  37B,37E
0889A:  GOTO   5516
....................          break;
0889E:  GOTO   8932
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
088A2:  MOVFF  37C,37F
088A6:  MOVFF  37B,37E
088AA:  GOTO   556E
....................          break;
088AE:  GOTO   8932
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
088B2:  MOVFF  37C,37F
088B6:  MOVFF  37B,37E
088BA:  GOTO   564A
....................          break;
088BE:  GOTO   8932
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
088C2:  MOVFF  37C,37F
088C6:  MOVFF  37B,37E
088CA:  GOTO   5706
....................          break;
088CE:  GOTO   8932
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
088D2:  MOVFF  37C,37F
088D6:  MOVFF  37B,37E
088DA:  CALL   5772
....................          break;
088DE:  GOTO   8932
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
088E2:  MOVFF  37C,37F
088E6:  MOVFF  37B,37E
088EA:  GOTO   5920
....................          break;
088EE:  GOTO   8932
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
088F2:  MOVFF  37C,37F
088F6:  MOVFF  37B,37E
088FA:  GOTO   5D06
....................          break;
088FE:  GOTO   8932
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
08902:  MOVFF  37C,37F
08906:  MOVFF  37B,37E
0890A:  CALL   5772
....................          break;
0890E:  GOTO   8932
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
08912:  MOVFF  37C,37F
08916:  MOVFF  37B,37E
0891A:  GOTO   8326
....................          break;
0891E:  GOTO   8932
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
08922:  MOVLW  64
08924:  MOVWF  FF6
08926:  MOVLW  12
08928:  MOVWF  FF7
0892A:  MOVLW  00
0892C:  MOVWF  FF8
0892E:  CALL   1C14
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
08932:  MOVLW  7C
08934:  MOVWF  FF6
08936:  MOVLW  12
08938:  MOVWF  FF7
0893A:  MOVLW  00
0893C:  MOVWF  FF8
0893E:  CALL   1C14
08942:  GOTO   89B2 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
08AB0:  MOVLW  C2
08AB2:  MOVWF  FF6
08AB4:  MOVLW  12
08AB6:  MOVWF  FF7
08AB8:  MOVLW  00
08ABA:  MOVWF  FF8
08ABC:  CALL   1C14
....................    
....................    switch(command->frame_id)
08AC0:  MOVLB  3
08AC2:  MOVF   x75,W
08AC4:  MOVWF  FE9
08AC6:  MOVF   x76,W
08AC8:  MOVWF  FEA
08ACA:  MOVF   FEF,W
08ACC:  XORLW  00
08ACE:  MOVLB  0
08AD0:  BTFSC  FD8.2
08AD2:  GOTO   8AEA
08AD6:  XORLW  01
08AD8:  BTFSC  FD8.2
08ADA:  GOTO   8AFA
08ADE:  XORLW  03
08AE0:  BTFSC  FD8.2
08AE2:  GOTO   8B1A
08AE6:  GOTO   8B2A
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
08AEA:  MOVFF  376,378
08AEE:  MOVFF  375,377
08AF2:  GOTO   8966
....................          break;
08AF6:  GOTO   8B2A
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
08AFA:  MOVFF  376,378
08AFE:  MOVFF  375,377
08B02:  GOTO   89E8
08B06:  MOVF   01,F
08B08:  BTFSC  FD8.2
08B0A:  GOTO   8B16
....................             return TRUE; // if status is finished, return TRUE
08B0E:  MOVLW  01
08B10:  MOVWF  01
08B12:  GOTO   8B2E
....................          }        
....................          break;
08B16:  GOTO   8B2A
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
08B1A:  MOVFF  376,378
08B1E:  MOVFF  375,377
08B22:  GOTO   8A3E
....................          break;
08B26:  GOTO   8B2A
....................    }
....................    return FALSE;
08B2A:  MOVLW  00
08B2C:  MOVWF  01
08B2E:  GOTO   9380 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
08966:  MOVLW  DA
08968:  MOVWF  FF6
0896A:  MOVLW  12
0896C:  MOVWF  FF7
0896E:  MOVLW  00
08970:  MOVWF  FF8
08972:  CALL   1C14
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
08976:  MOVLW  F0
08978:  MOVWF  FF6
0897A:  MOVLW  12
0897C:  MOVWF  FF7
0897E:  MOVLW  00
08980:  MOVWF  FF8
08982:  CALL   1C14
....................    transmit_ack();
08986:  CALL   3DBE
.................... 
....................    status[0] = EXECUTING_MISSION;
0898A:  MOVLW  02
0898C:  MOVWF  48
....................    execute_mission(command->content);
0898E:  MOVLW  03
08990:  MOVLB  3
08992:  ADDWF  x77,W
08994:  MOVWF  01
08996:  MOVLW  00
08998:  ADDWFC x78,W
0899A:  MOVWF  03
0899C:  MOVF   01,W
0899E:  MOVWF  x79
089A0:  MOVFF  03,37A
089A4:  MOVFF  37A,37C
089A8:  MOVFF  379,37B
089AC:  MOVLB  0
089AE:  GOTO   86E4
....................    if (is_empty_flash_queue())
089B2:  GOTO   8946
089B6:  MOVF   01,F
089B8:  BTFSC  FD8.2
089BA:  GOTO   89C6
....................       status[0] = FINISHED;
089BE:  MOVLW  06
089C0:  MOVWF  48
089C2:  GOTO   89CA
....................    else
....................       status[0] = SMF_USE_REQ;
089C6:  MOVLW  04
089C8:  MOVWF  48
089CA:  GOTO   8AF6 (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
089E8:  MOVLW  0A
089EA:  MOVWF  FF6
089EC:  MOVLW  13
089EE:  MOVWF  FF7
089F0:  MOVLW  00
089F2:  MOVWF  FF8
089F4:  CALL   1C14
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
089F8:  MOVLW  1E
089FA:  MOVWF  FF6
089FC:  MOVLW  13
089FE:  MOVWF  FF7
08A00:  MOVLW  00
08A02:  MOVWF  FF8
08A04:  CALL   1C14
....................    transmit_status();
08A08:  GOTO   89CE
....................    if (status[0] == FINISHED)
08A0C:  MOVF   48,W
08A0E:  SUBLW  06
08A10:  BTFSS  FD8.2
08A12:  GOTO   8A32
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
08A16:  MOVLW  3C
08A18:  MOVWF  FF6
08A1A:  MOVLW  13
08A1C:  MOVWF  FF7
08A1E:  MOVLW  00
08A20:  MOVWF  FF8
08A22:  CALL   1C14
....................       return TRUE;
08A26:  MOVLW  01
08A28:  MOVWF  01
08A2A:  GOTO   8A3A
....................    }
08A2E:  GOTO   8A3A
....................    else{
....................       return FALSE;
08A32:  MOVLW  00
08A34:  MOVWF  01
08A36:  GOTO   8A3A
....................    }
08A3A:  GOTO   8B06 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command) {
....................    fprintf(PC, "\t-> SMF available check\r\n");
08A3E:  MOVLW  58
08A40:  MOVWF  FF6
08A42:  MOVLW  13
08A44:  MOVWF  FF7
08A46:  MOVLW  00
08A48:  MOVWF  FF8
08A4A:  CALL   1C14
....................    fprintf(PC, "\t   Transmit Acknowledgement\r\n");
08A4E:  MOVLW  72
08A50:  MOVWF  FF6
08A52:  MOVLW  13
08A54:  MOVWF  FF7
08A56:  MOVLW  00
08A58:  MOVWF  FF8
08A5A:  CALL   1C14
....................    transmit_ack();
08A5E:  CALL   3DBE
....................    
....................    if (command->content[0] == ALLOW) {
08A62:  MOVLW  03
08A64:  MOVLB  3
08A66:  ADDWF  x77,W
08A68:  MOVWF  FE9
08A6A:  MOVLW  00
08A6C:  ADDWFC x78,W
08A6E:  MOVWF  FEA
08A70:  DECFSZ FEF,W
08A72:  BRA    8A78
08A74:  BRA    8A7E
08A76:  MOVLB  0
08A78:  MOVLB  0
08A7A:  GOTO   8A9C
08A7E:  MOVLB  0
....................       fprintf(PC, "\t\t-> allowed\r\n");
08A80:  MOVLW  92
08A82:  MOVWF  FF6
08A84:  MOVLW  13
08A86:  MOVWF  FF7
08A88:  MOVLW  00
08A8A:  MOVWF  FF8
08A8C:  CALL   1C14
....................       status[0] = COPYING;
08A90:  MOVLW  05
08A92:  MOVWF  48
....................       /*
....................       // キューが空になるまでループ処理
....................       int8 processed_count = 0;
....................       while (!is_empty_flash_queue()) {
....................          fprintf(PC, "\t\t-> Processing SMF data [%d]\r\n", processed_count);
....................          
....................          FlashOperationStruct *smf_data = dequeue_flash_operation();
....................          if (smf_data != 0x00) {
....................             int8 func_type = smf_data->func_type;
....................             fprintf(PC, "func type : 0x%02X",func_type);
....................             if (func_type == 0x00) {  // SMF_WRITE
....................                fprintf(PC, "\t\t-> Executing SMF WRITE (single)\r\n");
....................                smf_write(smf_data);
....................             }
....................             if (func_type == 0x01) {  // SMF_READ
....................                fprintf(PC, "\t\t-> Executing SMF READ (single)\r\n");
....................                smf_read(smf_data);
....................             }
.................... 
....................             if (func_type == 0x02) {  // SMF_ERASE
....................                fprintf(PC, "\t\t-> Executing SMF ERASE (single)\r\n");
....................                smf_erase(smf_data);
....................             }
....................             if (func_type > 2) {
....................                fprintf(PC, "\t\t-> Unknown SMF function type\r\n");
....................             }
....................             processed_count++;
....................          } else {
....................             fprintf(PC, "\t\t-> Error: Failed to dequeue SMF data\r\n");
....................             break;
....................          }
....................       }
....................       
....................       fprintf(PC, "\t\t-> Completed processing %d SMF operations\r\n", processed_count);
....................       */
....................       status[0] = FINISHED;
08A94:  MOVLW  06
08A96:  MOVWF  48
....................    } else {
08A98:  GOTO   8AAC
....................       fprintf(PC, "\t\t-> denied\r\n");
08A9C:  MOVLW  A2
08A9E:  MOVWF  FF6
08AA0:  MOVLW  13
08AA2:  MOVWF  FF7
08AA4:  MOVLW  00
08AA6:  MOVWF  FF8
08AA8:  CALL   1C14
....................    }
08AAC:  GOTO   8B26 (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... unsigned int8 PICLOG_STARTUP = 0x00;
.................... 
.................... // PICLOG Parameter
.................... #define PICLOG_PARAM_START 0x01
.................... #define PICLOG_PARAM_END 0x02
.................... 
.................... 
.................... // PICLOG
.................... typedef union {
....................     struct {
....................         unsigned int32  time;
....................         unsigned int8   function;
....................         unsigned int8   parameter;
....................     };
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];  
.................... } PICLOG;
.................... 
.................... // extern宣言を追加（実体は.cファイルで定義）
.................... #define PICLOG_BLANK_SIZE 4 // PICLOGの空データサイズ
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00, 0x00}; // PICLOGの空データ
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[])
.................... {
....................    unsigned int8 measurement_step = uplinkcmd[1]; // Get the measurement step from the parameter array
....................    fprintf(PC, "Start MODE TEST IV\r\n");
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(uplinkcmd); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
....................    sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
08326:  MOVLW  54
08328:  MOVWF  FF6
0832A:  MOVLW  14
0832C:  MOVWF  FF7
0832E:  MOVLW  00
08330:  MOVWF  FF8
08332:  CALL   1C14
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
08336:  MOVFF  37F,3AD
0833A:  MOVFF  37E,3AC
0833E:  GOTO   5DCE
08342:  MOVFF  02,03
08346:  MOVF   01,W
08348:  MOVWF  FE1
0834A:  MOVFF  03,FE2
0834E:  MOVLW  03
08350:  MOVWF  FEA
08352:  MOVLW  80
08354:  MOVWF  FE9
08356:  MOVLW  0C
08358:  MOVWF  01
0835A:  MOVFF  FE6,FEE
0835E:  DECFSZ 01,F
08360:  GOTO   835A
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
08364:  MOVLW  6A
08366:  MOVWF  FF6
08368:  MOVLW  14
0836A:  MOVWF  FF7
0836C:  MOVLW  00
0836E:  MOVWF  FF8
08370:  MOVLW  05
08372:  MOVLB  B
08374:  MOVWF  xC1
08376:  MOVLB  0
08378:  CALL   1C44
0837C:  MOVFF  380,BC1
08380:  MOVLW  37
08382:  MOVLB  B
08384:  MOVWF  xC2
08386:  MOVLB  0
08388:  CALL   1E98
0838C:  MOVLW  0D
0838E:  MOVLB  C
08390:  MOVWF  x14
08392:  MOVLB  0
08394:  CALL   1BC2
08398:  MOVLW  0A
0839A:  MOVLB  C
0839C:  MOVWF  x14
0839E:  MOVLB  0
083A0:  CALL   1BC2
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
083A4:  MOVLW  76
083A6:  MOVWF  FF6
083A8:  MOVLW  14
083AA:  MOVWF  FF7
083AC:  MOVLW  00
083AE:  MOVWF  FF8
083B0:  MOVLW  0D
083B2:  MOVLB  B
083B4:  MOVWF  xC1
083B6:  MOVLB  0
083B8:  CALL   1C44
083BC:  MOVFF  382,BC1
083C0:  MOVLW  37
083C2:  MOVLB  B
083C4:  MOVWF  xC2
083C6:  MOVLB  0
083C8:  CALL   1E98
083CC:  MOVFF  381,BC1
083D0:  MOVLW  37
083D2:  MOVLB  B
083D4:  MOVWF  xC2
083D6:  MOVLB  0
083D8:  CALL   1E98
083DC:  MOVLW  88
083DE:  MOVWF  FF6
083E0:  MOVLW  14
083E2:  MOVWF  FF7
083E4:  MOVLW  00
083E6:  MOVWF  FF8
083E8:  MOVLW  05
083EA:  MOVLB  B
083EC:  MOVWF  xC1
083EE:  MOVLB  0
083F0:  CALL   1C44
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
083F4:  MOVLW  8E
083F6:  MOVWF  FF6
083F8:  MOVLW  14
083FA:  MOVWF  FF7
083FC:  MOVLW  00
083FE:  MOVWF  FF8
08400:  MOVLW  14
08402:  MOVLB  B
08404:  MOVWF  xC1
08406:  MOVLB  0
08408:  CALL   1C44
0840C:  MOVFF  384,BC1
08410:  MOVLW  37
08412:  MOVLB  B
08414:  MOVWF  xC2
08416:  MOVLB  0
08418:  CALL   1E98
0841C:  MOVFF  383,BC1
08420:  MOVLW  37
08422:  MOVLB  B
08424:  MOVWF  xC2
08426:  MOVLB  0
08428:  CALL   1E98
0842C:  MOVLW  A7
0842E:  MOVWF  FF6
08430:  MOVLW  14
08432:  MOVWF  FF7
08434:  MOVLW  00
08436:  MOVWF  FF8
08438:  MOVLW  05
0843A:  MOVLB  B
0843C:  MOVWF  xC1
0843E:  MOVLB  0
08440:  CALL   1C44
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
08444:  MOVLW  AE
08446:  MOVWF  FF6
08448:  MOVLW  14
0844A:  MOVWF  FF7
0844C:  MOVLW  00
0844E:  MOVWF  FF8
08450:  MOVLW  0F
08452:  MOVLB  B
08454:  MOVWF  xC1
08456:  MOVLB  0
08458:  CALL   1C44
0845C:  MOVFF  386,BC1
08460:  MOVLW  37
08462:  MOVLB  B
08464:  MOVWF  xC2
08466:  MOVLB  0
08468:  CALL   1E98
0846C:  MOVFF  385,BC1
08470:  MOVLW  37
08472:  MOVLB  B
08474:  MOVWF  xC2
08476:  MOVLB  0
08478:  CALL   1E98
0847C:  MOVLW  C2
0847E:  MOVWF  FF6
08480:  MOVLW  14
08482:  MOVWF  FF7
08484:  MOVLW  00
08486:  MOVWF  FF8
08488:  MOVLW  05
0848A:  MOVLB  B
0848C:  MOVWF  xC1
0848E:  MOVLB  0
08490:  CALL   1C44
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
08494:  MOVLW  C8
08496:  MOVWF  FF6
08498:  MOVLW  14
0849A:  MOVWF  FF7
0849C:  MOVLW  00
0849E:  MOVWF  FF8
084A0:  MOVLW  10
084A2:  MOVLB  B
084A4:  MOVWF  xC1
084A6:  MOVLB  0
084A8:  CALL   1C44
084AC:  MOVFF  388,BC1
084B0:  MOVLW  37
084B2:  MOVLB  B
084B4:  MOVWF  xC2
084B6:  MOVLB  0
084B8:  CALL   1E98
084BC:  MOVFF  387,BC1
084C0:  MOVLW  37
084C2:  MOVLB  B
084C4:  MOVWF  xC2
084C6:  MOVLB  0
084C8:  CALL   1E98
084CC:  MOVLW  DD
084CE:  MOVWF  FF6
084D0:  MOVLW  14
084D2:  MOVWF  FF7
084D4:  MOVLW  00
084D6:  MOVWF  FF8
084D8:  MOVLW  05
084DA:  MOVLB  B
084DC:  MOVWF  xC1
084DE:  MOVLB  0
084E0:  CALL   1C44
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
084E4:  MOVLW  E4
084E6:  MOVWF  FF6
084E8:  MOVLW  14
084EA:  MOVWF  FF7
084EC:  MOVLW  00
084EE:  MOVWF  FF8
084F0:  MOVLW  13
084F2:  MOVLB  B
084F4:  MOVWF  xC1
084F6:  MOVLB  0
084F8:  CALL   1C44
084FC:  MOVFF  38A,BC1
08500:  MOVLW  37
08502:  MOVLB  B
08504:  MOVWF  xC2
08506:  MOVLB  0
08508:  CALL   1E98
0850C:  MOVFF  389,BC1
08510:  MOVLW  37
08512:  MOVLB  B
08514:  MOVWF  xC2
08516:  MOVLB  0
08518:  CALL   1E98
0851C:  MOVLW  FC
0851E:  MOVWF  FF6
08520:  MOVLW  14
08522:  MOVWF  FF7
08524:  MOVLW  00
08526:  MOVWF  FF8
08528:  MOVLW  04
0852A:  MOVLB  B
0852C:  MOVWF  xC1
0852E:  MOVLB  0
08530:  CALL   1C44
....................    fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
08534:  MOVLW  02
08536:  MOVWF  FF6
08538:  MOVLW  15
0853A:  MOVWF  FF7
0853C:  MOVLW  00
0853E:  MOVWF  FF8
08540:  MOVLW  0E
08542:  MOVLB  B
08544:  MOVWF  xC1
08546:  MOVLB  0
08548:  CALL   1C44
0854C:  MOVFF  38B,3A6
08550:  MOVLW  1B
08552:  MOVLB  3
08554:  MOVWF  xA7
08556:  MOVLB  0
08558:  GOTO   5F24
0855C:  MOVLW  0D
0855E:  MOVLB  C
08560:  MOVWF  x14
08562:  MOVLB  0
08564:  CALL   1BC2
08568:  MOVLW  0A
0856A:  MOVLB  C
0856C:  MOVWF  x14
0856E:  MOVLB  0
08570:  CALL   1BC2
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
08574:  MOVFF  380,3D1
08578:  MOVLW  01
0857A:  MOVLB  3
0857C:  MOVWF  xD2
0857E:  MOVLB  0
08580:  CALL   35F0
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
08584:  CALL   2E52
08588:  MOVFF  01,38D
0858C:  MOVFF  00,38C
08590:  MOVLB  3
08592:  CLRF   x8F
08594:  CLRF   x8E
08596:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
08598:  CALL   2E52
0859C:  MOVFF  03,3A9
085A0:  MOVFF  02,3A8
085A4:  MOVFF  01,3A7
085A8:  MOVFF  00,3A6
085AC:  MOVLB  3
085AE:  MOVF   x8C,W
085B0:  SUBWF  xA6,F
085B2:  MOVF   x8D,W
085B4:  SUBWFB xA7,F
085B6:  MOVLW  00
085B8:  SUBWFB xA8,F
085BA:  MOVLW  00
085BC:  SUBWFB xA9,F
085BE:  MOVF   xA9,F
085C0:  BTFSC  FD8.2
085C2:  BRA    85CA
085C4:  MOVLB  0
085C6:  GOTO   8694
085CA:  MOVLB  0
085CC:  MOVLB  3
085CE:  MOVF   xA8,F
085D0:  BTFSC  FD8.2
085D2:  BRA    85DA
085D4:  MOVLB  0
085D6:  GOTO   8694
085DA:  MOVLB  0
085DC:  MOVLB  3
085DE:  MOVF   xA7,W
085E0:  SUBWF  x8A,W
085E2:  BTFSC  FD8.0
085E4:  BRA    85EC
085E6:  MOVLB  0
085E8:  GOTO   8694
085EC:  MOVLB  0
085EE:  BTFSS  FD8.2
085F0:  GOTO   8606
085F4:  MOVLB  3
085F6:  MOVF   x89,W
085F8:  SUBWF  xA6,W
085FA:  BTFSS  FD8.0
085FC:  BRA    8604
085FE:  MOVLB  0
08600:  GOTO   8694
08604:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
08606:  CALL   2E52
0860A:  MOVFF  01,38F
0860E:  MOVFF  00,38E
....................       if (current_sec - start_time >= cmd.meas_time) {
08612:  MOVLB  3
08614:  MOVF   x8C,W
08616:  SUBWF  x8E,W
08618:  MOVWF  xA6
0861A:  MOVF   x8D,W
0861C:  SUBWFB x8F,W
0861E:  MOVWF  xA7
08620:  MOVF   x8A,W
08622:  SUBWF  xA7,W
08624:  BTFSC  FD8.0
08626:  BRA    862E
08628:  MOVLB  0
0862A:  GOTO   864C
0862E:  MOVLB  0
08630:  BTFSS  FD8.2
08632:  GOTO   8648
08636:  MOVLB  3
08638:  MOVF   x89,W
0863A:  SUBWF  xA6,W
0863C:  BTFSC  FD8.0
0863E:  BRA    8646
08640:  MOVLB  0
08642:  GOTO   864C
08646:  MOVLB  0
....................           break;
08648:  GOTO   8694
....................       }
....................       sweep_with_threshold(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
0864C:  MOVFF  384,3A7
08650:  MOVFF  383,3A6
08654:  MOVFF  386,3A9
08658:  MOVFF  385,3A8
0865C:  MOVFF  388,3AB
08660:  MOVFF  387,3AA
08664:  GOTO   6912
....................       // Sleep for the specified time
....................       delay_ms(cmd.sleep_time);
08668:  MOVFF  382,3A6
0866C:  MOVLB  3
0866E:  INCF   xA6,F
08670:  MOVLB  0
08672:  MOVLB  3
08674:  DECFSZ xA6,F
08676:  BRA    867C
08678:  MOVLB  0
0867A:  BRA    8688
0867C:  MOVLB  C
0867E:  SETF   x6B
08680:  MOVLB  0
08682:  CALL   1B94
08686:  BRA    8672
08688:  MOVFF  381,C6B
0868C:  CALL   1B94
08690:  GOTO   8598
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
08694:  MOVFF  380,3D1
08698:  MOVLW  02
0869A:  MOVLB  3
0869C:  MOVWF  xD2
0869E:  MOVLB  0
086A0:  CALL   35F0
.................... 
....................    FlashOperationStruct data;
....................    data.func_type = SMF_WRITE;
086A4:  CLRF   03
086A6:  MOVLW  00
086A8:  MOVWF  02
086AA:  MOVLW  02
086AC:  MOVWF  01
086AE:  MOVLW  6A
086B0:  MOVWF  00
086B2:  MOVFF  00,399
....................    data.mission_id = 0x01; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
086B6:  MOVLW  01
086B8:  MOVLB  3
086BA:  MOVWF  x90
....................    data.write_mode = SMF_WRITE_CIRCULAR;
086BC:  MOVLW  02
086BE:  MOVWF  x9A
....................    data.source_type = SOURCE_MISF_UNCOPIED;
086C0:  BCF    x9B.0
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
086C2:  MOVLW  03
086C4:  MOVWF  xA7
086C6:  MOVLW  90
086C8:  MOVWF  xA6
086CA:  MOVLB  0
086CC:  GOTO   7EE8
.................... 
....................    fprintf(PC, "End MODE MEAS IV\r\n");
086D0:  MOVLW  16
086D2:  MOVWF  FF6
086D4:  MOVLW  15
086D6:  MOVWF  FF7
086D8:  MOVLW  00
086DA:  MOVWF  FF8
086DC:  CALL   1C14
086E0:  GOTO   891E (RETURN)
.................... }
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
05DCE:  MOVLB  3
05DD0:  MOVF   xAC,W
05DD2:  MOVWF  FE9
05DD4:  MOVF   xAD,W
05DD6:  MOVWF  FEA
05DD8:  MOVFF  FEF,3AE
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
05DDC:  MOVLW  01
05DDE:  ADDWF  xAC,W
05DE0:  MOVWF  FE9
05DE2:  MOVLW  00
05DE4:  ADDWFC xAD,W
05DE6:  MOVWF  FEA
05DE8:  MOVF   FEF,W
05DEA:  CLRF   xBB
05DEC:  MOVWF  xBA
05DEE:  MOVFF  3BA,3BB
05DF2:  CLRF   xBA
05DF4:  MOVLW  02
05DF6:  ADDWF  xAC,W
05DF8:  MOVWF  FE9
05DFA:  MOVLW  00
05DFC:  ADDWFC xAD,W
05DFE:  MOVWF  FEA
05E00:  MOVF   FEF,W
05E02:  CLRF   03
05E04:  IORWF  xBA,W
05E06:  MOVWF  xAF
05E08:  MOVF   03,W
05E0A:  IORWF  xBB,W
05E0C:  MOVWF  xB0
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
05E0E:  MOVLW  03
05E10:  ADDWF  xAC,W
05E12:  MOVWF  FE9
05E14:  MOVLW  00
05E16:  ADDWFC xAD,W
05E18:  MOVWF  FEA
05E1A:  MOVF   FEF,W
05E1C:  CLRF   xBB
05E1E:  MOVWF  xBA
05E20:  RLCF   xBA,W
05E22:  MOVWF  xB1
05E24:  RLCF   xBB,W
05E26:  MOVWF  xB2
05E28:  RLCF   xB1,F
05E2A:  RLCF   xB2,F
05E2C:  RLCF   xB1,F
05E2E:  RLCF   xB2,F
05E30:  RLCF   xB1,F
05E32:  RLCF   xB2,F
05E34:  MOVLW  F0
05E36:  ANDWF  xB1,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
05E38:  MOVLW  04
05E3A:  ADDWF  xAC,W
05E3C:  MOVWF  FE9
05E3E:  MOVLW  00
05E40:  ADDWFC xAD,W
05E42:  MOVWF  FEA
05E44:  MOVF   FEF,W
05E46:  CLRF   xBB
05E48:  MOVWF  xBA
05E4A:  RLCF   xBA,W
05E4C:  MOVWF  xB3
05E4E:  RLCF   xBB,W
05E50:  MOVWF  xB4
05E52:  RLCF   xB3,F
05E54:  RLCF   xB4,F
05E56:  RLCF   xB3,F
05E58:  RLCF   xB4,F
05E5A:  RLCF   xB3,F
05E5C:  RLCF   xB4,F
05E5E:  MOVLW  F0
05E60:  ANDWF  xB3,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
05E62:  MOVLW  05
05E64:  ADDWF  xAC,W
05E66:  MOVWF  FE9
05E68:  MOVLW  00
05E6A:  ADDWFC xAD,W
05E6C:  MOVWF  FEA
05E6E:  MOVF   FEF,W
05E70:  CLRF   xBB
05E72:  MOVWF  xBA
05E74:  RLCF   xBA,W
05E76:  MOVWF  xB5
05E78:  RLCF   xBB,W
05E7A:  MOVWF  xB6
05E7C:  RLCF   xB5,F
05E7E:  RLCF   xB6,F
05E80:  RLCF   xB5,F
05E82:  RLCF   xB6,F
05E84:  RLCF   xB5,F
05E86:  RLCF   xB6,F
05E88:  MOVLW  F0
05E8A:  ANDWF  xB5,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
05E8C:  MOVLW  06
05E8E:  ADDWF  xAC,W
05E90:  MOVWF  FE9
05E92:  MOVLW  00
05E94:  ADDWFC xAD,W
05E96:  MOVWF  FEA
05E98:  MOVF   FEF,W
05E9A:  CLRF   xBB
05E9C:  MOVWF  xBA
05E9E:  MOVFF  3BA,3BB
05EA2:  CLRF   xBA
05EA4:  MOVLW  07
05EA6:  ADDWF  xAC,W
05EA8:  MOVWF  FE9
05EAA:  MOVLW  00
05EAC:  ADDWFC xAD,W
05EAE:  MOVWF  FEA
05EB0:  MOVF   FEF,W
05EB2:  CLRF   03
05EB4:  IORWF  xBA,W
05EB6:  MOVWF  xB7
05EB8:  MOVF   03,W
05EBA:  IORWF  xBB,W
05EBC:  MOVWF  xB8
....................    cmd.is_finished = uplinkcmd[8];
05EBE:  MOVLW  08
05EC0:  ADDWF  xAC,W
05EC2:  MOVWF  FE9
05EC4:  MOVLW  00
05EC6:  ADDWFC xAD,W
05EC8:  MOVWF  FEA
05ECA:  MOVFF  FEF,3B9
....................    return cmd;
05ECE:  MOVLW  AE
05ED0:  MOVWF  01
05ED2:  MOVLW  03
05ED4:  MOVWF  02
05ED6:  MOVLB  0
05ED8:  GOTO   8342 (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfMissionStruct;
.................... 
.................... typedef struct {
....................     int8 mission_id;                // ミッションID
....................     int32 src;                      // ソースアドレス（MISFアドレス）
....................     int32 size;                     // データサイズ
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
....................     MisfSmfManagerStruct *manager;  // MISF/SMF管理構造体へのポインタ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfMissionStruct get_smf_mission_struct(FunctionType func_type);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef  MMJ_CIGS_FLASH_H
.................... #define  MMJ_CIGS_FLASH_H
.................... 
.................... 
.................... 
.................... 
.................... // MIS_FM Function
.................... void misf_init(void);
.................... void update_misf_data_header(void);
.................... void write_misf_address_area(void);
.................... void read_misf_address_area(unsigned int8 *data);
.................... 
.................... 
.................... #define PACKET_SIZE 64
.................... #define MISF_DATA_HEADER_SIZE 64 // MISFデータヘッダーのサイズ
.................... #define MISF_PICLOG_MAX_COUNT 60
.................... 
.................... 
.................... 
.................... 
.................... // __________MISF-ADDRESS__________
.................... #define ADDRESS_MISF_START              0x00000000
.................... #define ADDRESS_MISF_END                0x00F42400
.................... #define ADDRESS_MANAGE_START            0x00000000
.................... #define ADDRESS_MANAGE_END              0x0000FFFF
.................... #define ADDRESS_MISF_PICLOG_INDEX_START 0x00010000
.................... #define ADDRESS_MISF_PICLOG_INDEX_END   0x0001FFFF
.................... #define ADDRESS_MISF_PICLOG_DATA_START  0x00020000
.................... #define ADDRESS_MISF_PICLOG_DATA_END    0x0015FFFF
.................... #define ADDRESS_MISF_MEASUREMENT_START  0x00160000
.................... #define ADDRESS_MISF_MEASUREMENT_END    0x0095FFFF
.................... 
.................... //
.................... #define SECTOR_64K_BYTE 0x10000 // 64KByte
.................... #define SECTOR_32K_BYTE 0x8000  // 32KByte
.................... #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... 
.................... 
.................... 
.................... // Flashに関する構造体。基本的にこれを用いる
.................... typedef struct {
....................     enum{} id;
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } Flash_t;
.................... 
.................... // Flash_t instances
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 各データブロックのカウンタ情報
.................... typedef struct __attribute__((packed)) {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8 reserve_counter1;
....................     unsigned int8 reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // union定義
.................... typedef union __attribute__((packed)) {
....................     unsigned int8 bytes[PACKET_SIZE];
....................     struct {
....................         union {
....................             unsigned int8 raw[PACKET_SIZE - 2];
.................... 
....................             struct __attribute__((packed)) {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................                 // 合計サイズ: (4+4+1+1)*4 = 40 バイト
....................             } logdata;
.................... 
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
.................... } FlashData_t;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define DATA_HEADER_SIZE 64 
.................... 
.................... 
.................... 
.................... 
.................... // ___________SMF-ADDRESS___________
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... unsigned int8 PICLOG_STARTUP = 0x00;
.................... 
.................... // PICLOG Parameter
.................... #define PICLOG_PARAM_START 0x01
.................... #define PICLOG_PARAM_END 0x02
.................... 
.................... 
.................... // PICLOG
.................... typedef union {
....................     struct {
....................         unsigned int32  time;
....................         unsigned int8   function;
....................         unsigned int8   parameter;
....................     };
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];  
.................... } PICLOG;
.................... 
.................... // extern宣言を追加（実体は.cファイルで定義）
.................... #define PICLOG_BLANK_SIZE 4 // PICLOGの空データサイズ
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00, 0x00}; // PICLOGの空データ
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
0412E:  MOVLW  2A
04130:  MOVWF  FF6
04132:  MOVLW  15
04134:  MOVWF  FF7
04136:  MOVLW  00
04138:  MOVWF  FF8
0413A:  CALL   1C14
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
0413E:  MOVLB  3
04140:  MOVF   x80,W
04142:  MOVWF  FE9
04144:  MOVF   x81,W
04146:  MOVWF  FEA
04148:  MOVFF  FEF,382
....................    piclog_make(cmd, 0x00); // Log the command execution
0414C:  MOVFF  382,3D1
04150:  CLRF   xD2
04152:  MOVLB  0
04154:  CALL   35F0
....................    
....................    for (int32 address = ADDRESS_MISF_START; address < ADDRESS_MISF_END; address += SECTOR_64K_BYTE) {
04158:  MOVLB  3
0415A:  CLRF   x86
0415C:  CLRF   x85
0415E:  CLRF   x84
04160:  CLRF   x83
04162:  MOVLB  0
04164:  MOVLB  3
04166:  MOVF   x86,F
04168:  BTFSC  FD8.2
0416A:  BRA    4172
0416C:  MOVLB  0
0416E:  GOTO   41D2
04172:  MOVLB  0
04174:  MOVLB  3
04176:  MOVF   x85,W
04178:  SUBLW  F4
0417A:  BTFSC  FD8.0
0417C:  BRA    4184
0417E:  MOVLB  0
04180:  GOTO   41D2
04184:  MOVLB  0
04186:  BTFSS  FD8.2
04188:  GOTO   419E
0418C:  MOVLB  3
0418E:  MOVF   x84,W
04190:  SUBLW  23
04192:  BTFSC  FD8.0
04194:  BRA    419C
04196:  MOVLB  0
04198:  GOTO   41D2
0419C:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
0419E:  MOVFF  301,3C7
041A2:  MOVFF  300,3C6
041A6:  MOVFF  2FF,3C5
041AA:  MOVFF  2FE,3C4
041AE:  MOVFF  386,3CB
041B2:  MOVFF  385,3CA
041B6:  MOVFF  384,3C9
041BA:  MOVFF  383,3C8
041BE:  CALL   3DD2
041C2:  MOVLW  01
041C4:  MOVLB  3
041C6:  ADDWF  x85,F
041C8:  MOVLW  00
041CA:  ADDWFC x86,F
041CC:  MOVLB  0
041CE:  GOTO   4164
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
041D2:  MOVFF  382,3D1
041D6:  MOVLW  02
041D8:  MOVLB  3
041DA:  MOVWF  xD2
041DC:  MOVLB  0
041DE:  CALL   35F0
....................    printf("End Flash Erase All\r\n");
041E2:  MOVLW  42
041E4:  MOVWF  FF6
041E6:  MOVLW  15
041E8:  MOVWF  FF7
041EA:  MOVLW  00
041EC:  MOVWF  FF8
041EE:  CALL   1C14
041F2:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
041F4:  MOVLW  58
041F6:  MOVWF  FF6
041F8:  MOVLW  15
041FA:  MOVWF  FF7
041FC:  MOVLW  00
041FE:  MOVWF  FF8
04200:  CALL   1C14
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
04204:  MOVLB  3
04206:  MOVF   x7E,W
04208:  MOVWF  FE9
0420A:  MOVF   x7F,W
0420C:  MOVWF  FEA
0420E:  MOVFF  FEF,380
04212:  MOVLW  01
04214:  ADDWF  x7E,W
04216:  MOVWF  FE9
04218:  MOVLW  00
0421A:  ADDWFC x7F,W
0421C:  MOVWF  FEA
0421E:  MOVF   FEF,W
04220:  CLRF   x88
04222:  CLRF   x87
04224:  CLRF   x86
04226:  MOVWF  x85
04228:  MOVFF  385,388
0422C:  CLRF   x85
0422E:  CLRF   x86
04230:  CLRF   x87
04232:  MOVLW  02
04234:  ADDWF  x7E,W
04236:  MOVWF  FE9
04238:  MOVLW  00
0423A:  ADDWFC x7F,W
0423C:  MOVWF  FEA
0423E:  MOVF   FEF,W
04240:  CLRF   x8D
04242:  CLRF   x8C
04244:  CLRF   x8B
04246:  MOVWF  x8A
04248:  MOVFF  38B,03
0424C:  MOVFF  38A,02
04250:  CLRF   00
04252:  CLRF   01
04254:  MOVF   00,W
04256:  IORWF  x85,F
04258:  MOVF   01,W
0425A:  IORWF  x86,F
0425C:  MOVF   02,W
0425E:  IORWF  x87,F
04260:  MOVF   03,W
04262:  IORWF  x88,F
04264:  MOVLW  03
04266:  ADDWF  x7E,W
04268:  MOVWF  FE9
0426A:  MOVLW  00
0426C:  ADDWFC x7F,W
0426E:  MOVWF  FEA
04270:  MOVF   FEF,W
04272:  CLRF   x8D
04274:  CLRF   x8C
04276:  CLRF   x8B
04278:  MOVWF  x8A
0427A:  MOVFF  38C,03
0427E:  MOVFF  38B,02
04282:  MOVFF  38A,01
04286:  CLRF   00
04288:  MOVF   00,W
0428A:  IORWF  x85,F
0428C:  MOVF   01,W
0428E:  IORWF  x86,F
04290:  MOVF   02,W
04292:  IORWF  x87,F
04294:  MOVF   03,W
04296:  IORWF  x88,F
04298:  MOVLW  04
0429A:  ADDWF  x7E,W
0429C:  MOVWF  FE9
0429E:  MOVLW  00
042A0:  ADDWFC x7F,W
042A2:  MOVWF  FEA
042A4:  MOVF   FEF,W
042A6:  MOVWF  00
042A8:  CLRF   01
042AA:  CLRF   02
042AC:  CLRF   03
042AE:  MOVF   00,W
042B0:  IORWF  x85,W
042B2:  MOVWF  x81
042B4:  MOVF   01,W
042B6:  IORWF  x86,W
042B8:  MOVWF  x82
042BA:  MOVF   02,W
042BC:  IORWF  x87,W
042BE:  MOVWF  x83
042C0:  MOVF   03,W
042C2:  IORWF  x88,W
042C4:  MOVWF  x84
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
042C6:  MOVLW  76
042C8:  MOVWF  FF6
042CA:  MOVLW  15
042CC:  MOVWF  FF7
042CE:  MOVLW  00
042D0:  MOVWF  FF8
042D2:  MOVLW  13
042D4:  MOVLB  B
042D6:  MOVWF  xC1
042D8:  MOVLB  0
042DA:  CALL   1C44
042DE:  MOVFF  384,BC1
042E2:  MOVLW  37
042E4:  MOVLB  B
042E6:  MOVWF  xC2
042E8:  MOVLB  0
042EA:  CALL   1E98
042EE:  MOVFF  383,BC1
042F2:  MOVLW  37
042F4:  MOVLB  B
042F6:  MOVWF  xC2
042F8:  MOVLB  0
042FA:  CALL   1E98
042FE:  MOVFF  382,BC1
04302:  MOVLW  37
04304:  MOVLB  B
04306:  MOVWF  xC2
04308:  MOVLB  0
0430A:  CALL   1E98
0430E:  MOVFF  381,BC1
04312:  MOVLW  37
04314:  MOVLB  B
04316:  MOVWF  xC2
04318:  MOVLB  0
0431A:  CALL   1E98
0431E:  MOVLW  0D
04320:  MOVLB  C
04322:  MOVWF  x14
04324:  MOVLB  0
04326:  CALL   1BC2
0432A:  MOVLW  0A
0432C:  MOVLB  C
0432E:  MOVWF  x14
04330:  MOVLB  0
04332:  CALL   1BC2
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04336:  MOVFF  380,3D1
0433A:  MOVLW  01
0433C:  MOVLB  3
0433E:  MOVWF  xD2
04340:  MOVLB  0
04342:  CALL   35F0
....................    
....................    sector_erase(mis_fm, sector_address);
04346:  MOVFF  301,3C7
0434A:  MOVFF  300,3C6
0434E:  MOVFF  2FF,3C5
04352:  MOVFF  2FE,3C4
04356:  MOVFF  384,3CB
0435A:  MOVFF  383,3CA
0435E:  MOVFF  382,3C9
04362:  MOVFF  381,3C8
04366:  CALL   3DD2
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0436A:  MOVFF  380,3D1
0436E:  MOVLW  02
04370:  MOVLB  3
04372:  MOVWF  xD2
04374:  MOVLB  0
04376:  CALL   35F0
....................    printf("End Flash Erase 1 Sector\r\n");
0437A:  MOVLW  92
0437C:  MOVWF  FF6
0437E:  MOVLW  15
04380:  MOVWF  FF7
04382:  MOVLW  00
04384:  MOVWF  FF8
04386:  CALL   1C14
0438A:  GOTO   882E (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
046EC:  MOVLW  AE
046EE:  MOVWF  FF6
046F0:  MOVLW  15
046F2:  MOVWF  FF7
046F4:  MOVLW  00
046F6:  MOVWF  FF8
046F8:  CALL   1C14
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
046FC:  MOVLB  3
046FE:  MOVF   x7E,W
04700:  MOVWF  FE9
04702:  MOVF   x7F,W
04704:  MOVWF  FEA
04706:  MOVFF  FEF,380
0470A:  MOVLW  01
0470C:  ADDWF  x7E,W
0470E:  MOVWF  FE9
04710:  MOVLW  00
04712:  ADDWFC x7F,W
04714:  MOVWF  FEA
04716:  MOVF   FEF,W
04718:  CLRF   x88
0471A:  CLRF   x87
0471C:  CLRF   x86
0471E:  MOVWF  x85
04720:  MOVFF  385,388
04724:  CLRF   x85
04726:  CLRF   x86
04728:  CLRF   x87
0472A:  MOVLW  02
0472C:  ADDWF  x7E,W
0472E:  MOVWF  FE9
04730:  MOVLW  00
04732:  ADDWFC x7F,W
04734:  MOVWF  FEA
04736:  MOVF   FEF,W
04738:  CLRF   x8D
0473A:  CLRF   x8C
0473C:  CLRF   x8B
0473E:  MOVWF  x8A
04740:  MOVFF  38B,03
04744:  MOVFF  38A,02
04748:  CLRF   00
0474A:  CLRF   01
0474C:  MOVF   00,W
0474E:  IORWF  x85,F
04750:  MOVF   01,W
04752:  IORWF  x86,F
04754:  MOVF   02,W
04756:  IORWF  x87,F
04758:  MOVF   03,W
0475A:  IORWF  x88,F
0475C:  MOVLW  03
0475E:  ADDWF  x7E,W
04760:  MOVWF  FE9
04762:  MOVLW  00
04764:  ADDWFC x7F,W
04766:  MOVWF  FEA
04768:  MOVF   FEF,W
0476A:  CLRF   x8D
0476C:  CLRF   x8C
0476E:  CLRF   x8B
04770:  MOVWF  x8A
04772:  MOVFF  38C,03
04776:  MOVFF  38B,02
0477A:  MOVFF  38A,01
0477E:  CLRF   00
04780:  MOVF   00,W
04782:  IORWF  x85,F
04784:  MOVF   01,W
04786:  IORWF  x86,F
04788:  MOVF   02,W
0478A:  IORWF  x87,F
0478C:  MOVF   03,W
0478E:  IORWF  x88,F
04790:  MOVLW  04
04792:  ADDWF  x7E,W
04794:  MOVWF  FE9
04796:  MOVLW  00
04798:  ADDWFC x7F,W
0479A:  MOVWF  FEA
0479C:  MOVF   FEF,W
0479E:  MOVWF  00
047A0:  CLRF   01
047A2:  CLRF   02
047A4:  CLRF   03
047A6:  MOVF   00,W
047A8:  IORWF  x85,W
047AA:  MOVWF  x81
047AC:  MOVF   01,W
047AE:  IORWF  x86,W
047B0:  MOVWF  x82
047B2:  MOVF   02,W
047B4:  IORWF  x87,W
047B6:  MOVWF  x83
047B8:  MOVF   03,W
047BA:  IORWF  x88,W
047BC:  MOVWF  x84
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
047BE:  MOVLW  CA
047C0:  MOVWF  FF6
047C2:  MOVLW  15
047C4:  MOVWF  FF7
047C6:  MOVLW  00
047C8:  MOVWF  FF8
047CA:  MOVLW  16
047CC:  MOVLB  B
047CE:  MOVWF  xC1
047D0:  MOVLB  0
047D2:  CALL   1C44
047D6:  MOVFF  384,BC1
047DA:  MOVLW  37
047DC:  MOVLB  B
047DE:  MOVWF  xC2
047E0:  MOVLB  0
047E2:  CALL   1E98
047E6:  MOVFF  383,BC1
047EA:  MOVLW  37
047EC:  MOVLB  B
047EE:  MOVWF  xC2
047F0:  MOVLB  0
047F2:  CALL   1E98
047F6:  MOVFF  382,BC1
047FA:  MOVLW  37
047FC:  MOVLB  B
047FE:  MOVWF  xC2
04800:  MOVLB  0
04802:  CALL   1E98
04806:  MOVFF  381,BC1
0480A:  MOVLW  37
0480C:  MOVLB  B
0480E:  MOVWF  xC2
04810:  MOVLB  0
04812:  CALL   1E98
04816:  MOVLW  0D
04818:  MOVLB  C
0481A:  MOVWF  x14
0481C:  MOVLB  0
0481E:  CALL   1BC2
04822:  MOVLW  0A
04824:  MOVLB  C
04826:  MOVWF  x14
04828:  MOVLB  0
0482A:  CALL   1BC2
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
0482E:  MOVFF  380,3D1
04832:  MOVLW  01
04834:  MOVLB  3
04836:  MOVWF  xD2
04838:  MOVLB  0
0483A:  CALL   35F0
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
0483E:  MOVFF  301,388
04842:  MOVFF  300,387
04846:  MOVFF  2FF,386
0484A:  MOVFF  2FE,385
0484E:  MOVLB  3
04850:  CLRF   x8C
04852:  CLRF   x8B
04854:  CLRF   x8A
04856:  CLRF   x89
04858:  MOVLB  0
0485A:  GOTO   438E
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0485E:  MOVFF  380,3D1
04862:  MOVLW  02
04864:  MOVLB  3
04866:  MOVWF  xD2
04868:  MOVLB  0
0486A:  CALL   35F0
....................    printf("End Flash Copy 1 Sector\r\n");
0486E:  MOVLW  E8
04870:  MOVWF  FF6
04872:  MOVLW  15
04874:  MOVWF  FF7
04876:  MOVLW  00
04878:  MOVWF  FF8
0487A:  CALL   1C14
0487E:  GOTO   883E (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
04882:  MOVLW  02
04884:  MOVWF  FF6
04886:  MOVLW  16
04888:  MOVWF  FF7
0488A:  MOVLW  00
0488C:  MOVWF  FF8
0488E:  CALL   1C14
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
04892:  MOVLB  3
04894:  MOVF   x7E,W
04896:  MOVWF  FE9
04898:  MOVF   x7F,W
0489A:  MOVWF  FEA
0489C:  MOVFF  FEF,380
048A0:  MOVLW  01
048A2:  ADDWF  x7E,W
048A4:  MOVWF  FE9
048A6:  MOVLW  00
048A8:  ADDWFC x7F,W
048AA:  MOVWF  FEA
048AC:  MOVF   FEF,W
048AE:  CLRF   x88
048B0:  CLRF   x87
048B2:  CLRF   x86
048B4:  MOVWF  x85
048B6:  MOVFF  385,388
048BA:  CLRF   x85
048BC:  CLRF   x86
048BE:  CLRF   x87
048C0:  MOVLW  02
048C2:  ADDWF  x7E,W
048C4:  MOVWF  FE9
048C6:  MOVLW  00
048C8:  ADDWFC x7F,W
048CA:  MOVWF  FEA
048CC:  MOVF   FEF,W
048CE:  CLRF   x8D
048D0:  CLRF   x8C
048D2:  CLRF   x8B
048D4:  MOVWF  x8A
048D6:  MOVFF  38B,03
048DA:  MOVFF  38A,02
048DE:  CLRF   00
048E0:  CLRF   01
048E2:  MOVF   00,W
048E4:  IORWF  x85,F
048E6:  MOVF   01,W
048E8:  IORWF  x86,F
048EA:  MOVF   02,W
048EC:  IORWF  x87,F
048EE:  MOVF   03,W
048F0:  IORWF  x88,F
048F2:  MOVLW  03
048F4:  ADDWF  x7E,W
048F6:  MOVWF  FE9
048F8:  MOVLW  00
048FA:  ADDWFC x7F,W
048FC:  MOVWF  FEA
048FE:  MOVF   FEF,W
04900:  CLRF   x8D
04902:  CLRF   x8C
04904:  CLRF   x8B
04906:  MOVWF  x8A
04908:  MOVFF  38C,03
0490C:  MOVFF  38B,02
04910:  MOVFF  38A,01
04914:  CLRF   00
04916:  MOVF   00,W
04918:  IORWF  x85,F
0491A:  MOVF   01,W
0491C:  IORWF  x86,F
0491E:  MOVF   02,W
04920:  IORWF  x87,F
04922:  MOVF   03,W
04924:  IORWF  x88,F
04926:  MOVLW  04
04928:  ADDWF  x7E,W
0492A:  MOVWF  FE9
0492C:  MOVLW  00
0492E:  ADDWFC x7F,W
04930:  MOVWF  FEA
04932:  MOVF   FEF,W
04934:  MOVWF  00
04936:  CLRF   01
04938:  CLRF   02
0493A:  CLRF   03
0493C:  MOVF   00,W
0493E:  IORWF  x85,W
04940:  MOVWF  x81
04942:  MOVF   01,W
04944:  IORWF  x86,W
04946:  MOVWF  x82
04948:  MOVF   02,W
0494A:  IORWF  x87,W
0494C:  MOVWF  x83
0494E:  MOVF   03,W
04950:  IORWF  x88,W
04952:  MOVWF  x84
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
04954:  MOVLW  28
04956:  MOVWF  FF6
04958:  MOVLW  16
0495A:  MOVWF  FF7
0495C:  MOVLW  00
0495E:  MOVWF  FF8
04960:  MOVLW  16
04962:  MOVLB  B
04964:  MOVWF  xC1
04966:  MOVLB  0
04968:  CALL   1C44
0496C:  MOVFF  384,BC1
04970:  MOVLW  37
04972:  MOVLB  B
04974:  MOVWF  xC2
04976:  MOVLB  0
04978:  CALL   1E98
0497C:  MOVFF  383,BC1
04980:  MOVLW  37
04982:  MOVLB  B
04984:  MOVWF  xC2
04986:  MOVLB  0
04988:  CALL   1E98
0498C:  MOVFF  382,BC1
04990:  MOVLW  37
04992:  MOVLB  B
04994:  MOVWF  xC2
04996:  MOVLB  0
04998:  CALL   1E98
0499C:  MOVFF  381,BC1
049A0:  MOVLW  37
049A2:  MOVLB  B
049A4:  MOVWF  xC2
049A6:  MOVLB  0
049A8:  CALL   1E98
049AC:  MOVLW  0D
049AE:  MOVLB  C
049B0:  MOVWF  x14
049B2:  MOVLB  0
049B4:  CALL   1BC2
049B8:  MOVLW  0A
049BA:  MOVLB  C
049BC:  MOVWF  x14
049BE:  MOVLB  0
049C0:  CALL   1BC2
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
049C4:  MOVFF  380,3D1
049C8:  MOVLW  01
049CA:  MOVLB  3
049CC:  MOVWF  xD2
049CE:  MOVLB  0
049D0:  CALL   35F0
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
049D4:  MOVFF  380,3D1
049D8:  MOVLW  02
049DA:  MOVLB  3
049DC:  MOVWF  xD2
049DE:  MOVLB  0
049E0:  CALL   35F0
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
049E4:  MOVLW  46
049E6:  MOVWF  FF6
049E8:  MOVLW  16
049EA:  MOVWF  FF7
049EC:  MOVLW  00
049EE:  MOVWF  FF8
049F0:  CALL   1C14
049F4:  GOTO   884E (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
049F8:  MOVLW  6A
049FA:  MOVWF  FF6
049FC:  MOVLW  16
049FE:  MOVWF  FF7
04A00:  MOVLW  00
04A02:  MOVWF  FF8
04A04:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
04A08:  MOVLB  3
04A0A:  MOVF   x7E,W
04A0C:  MOVWF  FE9
04A0E:  MOVF   x7F,W
04A10:  MOVWF  FEA
04A12:  MOVFF  FEF,3D0
04A16:  MOVFF  3D0,3D1
04A1A:  MOVLW  01
04A1C:  MOVWF  xD2
04A1E:  MOVLB  0
04A20:  CALL   35F0
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
04A24:  MOVLB  3
04A26:  CLRF   x80
04A28:  CLRF   x81
04A2A:  CLRF   x82
04A2C:  CLRF   x83
04A2E:  CLRF   x84
04A30:  CLRF   x85
04A32:  CLRF   x86
....................    
....................    flash_write_param.id = parameter[0];
04A34:  MOVF   x7E,W
04A36:  MOVWF  FE9
04A38:  MOVF   x7F,W
04A3A:  MOVWF  FEA
04A3C:  MOVFF  FEF,380
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
04A40:  MOVLW  01
04A42:  ADDWF  x7E,W
04A44:  MOVWF  FE9
04A46:  MOVLW  00
04A48:  ADDWFC x7F,W
04A4A:  MOVWF  FEA
04A4C:  MOVF   FEF,W
04A4E:  CLRF   xD3
04A50:  CLRF   xD2
04A52:  CLRF   xD1
04A54:  MOVWF  xD0
04A56:  MOVFF  3D0,3D3
04A5A:  CLRF   xD0
04A5C:  CLRF   xD1
04A5E:  CLRF   xD2
04A60:  MOVLW  02
04A62:  ADDWF  x7E,W
04A64:  MOVWF  FE9
04A66:  MOVLW  00
04A68:  ADDWFC x7F,W
04A6A:  MOVWF  FEA
04A6C:  MOVF   FEF,W
04A6E:  CLRF   xD8
04A70:  CLRF   xD7
04A72:  CLRF   xD6
04A74:  MOVWF  xD5
04A76:  MOVFF  3D6,03
04A7A:  MOVFF  3D5,02
04A7E:  CLRF   00
04A80:  CLRF   01
04A82:  MOVF   00,W
04A84:  IORWF  xD0,F
04A86:  MOVF   01,W
04A88:  IORWF  xD1,F
04A8A:  MOVF   02,W
04A8C:  IORWF  xD2,F
04A8E:  MOVF   03,W
04A90:  IORWF  xD3,F
04A92:  MOVLW  03
04A94:  ADDWF  x7E,W
04A96:  MOVWF  FE9
04A98:  MOVLW  00
04A9A:  ADDWFC x7F,W
04A9C:  MOVWF  FEA
04A9E:  MOVF   FEF,W
04AA0:  CLRF   xD8
04AA2:  CLRF   xD7
04AA4:  CLRF   xD6
04AA6:  MOVWF  xD5
04AA8:  MOVFF  3D7,03
04AAC:  MOVFF  3D6,02
04AB0:  MOVFF  3D5,01
04AB4:  CLRF   00
04AB6:  MOVF   00,W
04AB8:  IORWF  xD0,F
04ABA:  MOVF   01,W
04ABC:  IORWF  xD1,F
04ABE:  MOVF   02,W
04AC0:  IORWF  xD2,F
04AC2:  MOVF   03,W
04AC4:  IORWF  xD3,F
04AC6:  MOVLW  04
04AC8:  ADDWF  x7E,W
04ACA:  MOVWF  FE9
04ACC:  MOVLW  00
04ACE:  ADDWFC x7F,W
04AD0:  MOVWF  FEA
04AD2:  MOVF   FEF,W
04AD4:  MOVWF  00
04AD6:  CLRF   01
04AD8:  CLRF   02
04ADA:  CLRF   03
04ADC:  MOVF   00,W
04ADE:  IORWF  xD0,W
04AE0:  MOVWF  x81
04AE2:  MOVF   01,W
04AE4:  IORWF  xD1,W
04AE6:  MOVWF  x82
04AE8:  MOVF   02,W
04AEA:  IORWF  xD2,W
04AEC:  MOVWF  x83
04AEE:  MOVF   03,W
04AF0:  IORWF  xD3,W
04AF2:  MOVWF  x84
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
04AF4:  MOVLW  07
04AF6:  ADDWF  x7E,W
04AF8:  MOVWF  FE9
04AFA:  MOVLW  00
04AFC:  ADDWFC x7F,W
04AFE:  MOVWF  FEA
04B00:  MOVF   FEF,W
04B02:  CLRF   xD1
04B04:  MOVWF  xD0
04B06:  MOVFF  3D0,3D1
04B0A:  CLRF   xD0
04B0C:  MOVLW  08
04B0E:  ADDWF  x7E,W
04B10:  MOVWF  FE9
04B12:  MOVLW  00
04B14:  ADDWFC x7F,W
04B16:  MOVWF  FEA
04B18:  MOVF   FEF,W
04B1A:  CLRF   03
04B1C:  IORWF  xD0,W
04B1E:  MOVWF  x85
04B20:  MOVF   03,W
04B22:  IORWF  xD1,W
04B24:  MOVWF  x86
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
04B26:  MOVLW  84
04B28:  MOVWF  FF6
04B2A:  MOVLW  16
04B2C:  MOVWF  FF7
04B2E:  MOVLW  00
04B30:  MOVWF  FF8
04B32:  MOVLW  0C
04B34:  MOVLB  B
04B36:  MOVWF  xC1
04B38:  MOVLB  0
04B3A:  CALL   1C44
04B3E:  MOVFF  380,BC1
04B42:  MOVLW  37
04B44:  MOVLB  B
04B46:  MOVWF  xC2
04B48:  MOVLB  0
04B4A:  CALL   1E98
04B4E:  MOVLW  0D
04B50:  MOVLB  C
04B52:  MOVWF  x14
04B54:  MOVLB  0
04B56:  CALL   1BC2
04B5A:  MOVLW  0A
04B5C:  MOVLB  C
04B5E:  MOVWF  x14
04B60:  MOVLB  0
04B62:  CALL   1BC2
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
04B66:  MOVLW  98
04B68:  MOVWF  FF6
04B6A:  MOVLW  16
04B6C:  MOVWF  FF7
04B6E:  MOVLW  00
04B70:  MOVWF  FF8
04B72:  MOVLW  0E
04B74:  MOVLB  B
04B76:  MOVWF  xC1
04B78:  MOVLB  0
04B7A:  CALL   1C44
04B7E:  MOVFF  384,BC1
04B82:  MOVLW  37
04B84:  MOVLB  B
04B86:  MOVWF  xC2
04B88:  MOVLB  0
04B8A:  CALL   1E98
04B8E:  MOVFF  383,BC1
04B92:  MOVLW  37
04B94:  MOVLB  B
04B96:  MOVWF  xC2
04B98:  MOVLB  0
04B9A:  CALL   1E98
04B9E:  MOVFF  382,BC1
04BA2:  MOVLW  37
04BA4:  MOVLB  B
04BA6:  MOVWF  xC2
04BA8:  MOVLB  0
04BAA:  CALL   1E98
04BAE:  MOVFF  381,BC1
04BB2:  MOVLW  37
04BB4:  MOVLB  B
04BB6:  MOVWF  xC2
04BB8:  MOVLB  0
04BBA:  CALL   1E98
04BBE:  MOVLW  0D
04BC0:  MOVLB  C
04BC2:  MOVWF  x14
04BC4:  MOVLB  0
04BC6:  CALL   1BC2
04BCA:  MOVLW  0A
04BCC:  MOVLB  C
04BCE:  MOVWF  x14
04BD0:  MOVLB  0
04BD2:  CALL   1BC2
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
04BD6:  MOVLW  AE
04BD8:  MOVWF  FF6
04BDA:  MOVLW  16
04BDC:  MOVWF  FF7
04BDE:  MOVLW  00
04BE0:  MOVWF  FF8
04BE2:  MOVLW  0E
04BE4:  MOVLB  B
04BE6:  MOVWF  xC1
04BE8:  MOVLB  0
04BEA:  CALL   1C44
04BEE:  MOVFF  386,BC1
04BF2:  MOVLW  37
04BF4:  MOVLB  B
04BF6:  MOVWF  xC2
04BF8:  MOVLB  0
04BFA:  CALL   1E98
04BFE:  MOVFF  385,BC1
04C02:  MOVLW  37
04C04:  MOVLB  B
04C06:  MOVWF  xC2
04C08:  MOVLB  0
04C0A:  CALL   1E98
04C0E:  MOVLW  0D
04C10:  MOVLB  C
04C12:  MOVWF  x14
04C14:  MOVLB  0
04C16:  CALL   1BC2
04C1A:  MOVLW  0A
04C1C:  MOVLB  C
04C1E:  MOVWF  x14
04C20:  MOVLB  0
04C22:  CALL   1BC2
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
04C26:  MOVFF  380,3D1
04C2A:  MOVLB  3
04C2C:  CLRF   xD2
04C2E:  MOVLB  0
04C30:  CALL   35F0
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
04C34:  MOVLW  C4
04C36:  MOVWF  FF6
04C38:  MOVLW  16
04C3A:  MOVWF  FF7
04C3C:  MOVLW  00
04C3E:  MOVWF  FF8
04C40:  CALL   1C14
....................    for (p = 0; p < flash_write_param.packetnum; p++)
04C44:  MOVLB  3
04C46:  CLRF   xC8
04C48:  CLRF   xC7
04C4A:  MOVLB  0
04C4C:  MOVLB  3
04C4E:  MOVF   xC8,W
04C50:  SUBWF  x86,W
04C52:  BTFSC  FD8.0
04C54:  BRA    4C5C
04C56:  MOVLB  0
04C58:  GOTO   4D8A
04C5C:  MOVLB  0
04C5E:  BTFSS  FD8.2
04C60:  GOTO   4C76
04C64:  MOVLB  3
04C66:  MOVF   x85,W
04C68:  SUBWF  xC7,W
04C6A:  BTFSS  FD8.0
04C6C:  BRA    4C74
04C6E:  MOVLB  0
04C70:  GOTO   4D8A
04C74:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
04C76:  MOVLB  3
04C78:  RLCF   xC7,W
04C7A:  MOVWF  xC9
04C7C:  RLCF   xC8,W
04C7E:  MOVWF  xCA
04C80:  RLCF   xC9,F
04C82:  RLCF   xCA,F
04C84:  RLCF   xC9,F
04C86:  RLCF   xCA,F
04C88:  RLCF   xC9,F
04C8A:  RLCF   xCA,F
04C8C:  RLCF   xC9,F
04C8E:  RLCF   xCA,F
04C90:  RLCF   xC9,F
04C92:  RLCF   xCA,F
04C94:  MOVLW  C0
04C96:  ANDWF  xC9,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
04C98:  CLRF   xCB
04C9A:  MOVLB  0
04C9C:  MOVLB  3
04C9E:  MOVF   xCB,W
04CA0:  SUBLW  3F
04CA2:  BTFSC  FD8.0
04CA4:  BRA    4CAC
04CA6:  MOVLB  0
04CA8:  GOTO   4D0C
04CAC:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
04CAE:  CLRF   03
04CB0:  MOVLB  3
04CB2:  MOVF   xCB,W
04CB4:  ADDLW  87
04CB6:  MOVWF  FE9
04CB8:  MOVLW  03
04CBA:  ADDWFC 03,W
04CBC:  MOVWF  FEA
04CBE:  MOVF   xCB,W
04CC0:  ADDWF  xC9,W
04CC2:  MOVWF  xD2
04CC4:  MOVLW  00
04CC6:  ADDWFC xCA,W
04CC8:  MOVWF  xD3
04CCA:  MOVF   xD2,W
04CCC:  MOVWF  00
04CCE:  CLRF   03
04CD0:  MOVF   00,W
04CD2:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
04CD4:  CLRF   03
04CD6:  MOVF   xCB,W
04CD8:  ADDLW  87
04CDA:  MOVWF  FE9
04CDC:  MOVLW  03
04CDE:  ADDWFC 03,W
04CE0:  MOVWF  FEA
04CE2:  MOVFF  FEF,3D0
04CE6:  MOVFF  3D0,BC1
04CEA:  MOVLW  37
04CEC:  MOVLB  B
04CEE:  MOVWF  xC2
04CF0:  MOVLB  0
04CF2:  CALL   1E98
04CF6:  MOVLW  20
04CF8:  MOVLB  C
04CFA:  MOVWF  x14
04CFC:  MOVLB  0
04CFE:  CALL   1BC2
04D02:  MOVLB  3
04D04:  INCF   xCB,F
04D06:  MOVLB  0
04D08:  GOTO   4C9C
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
04D0C:  MOVLB  3
04D0E:  RLCF   xC7,W
04D10:  MOVWF  02
04D12:  RLCF   xC8,W
04D14:  MOVWF  03
04D16:  RLCF   02,F
04D18:  RLCF   03,F
04D1A:  RLCF   02,F
04D1C:  RLCF   03,F
04D1E:  RLCF   02,F
04D20:  RLCF   03,F
04D22:  RLCF   02,F
04D24:  RLCF   03,F
04D26:  RLCF   02,F
04D28:  RLCF   03,F
04D2A:  MOVLW  C0
04D2C:  ANDWF  02,F
04D2E:  MOVF   02,W
04D30:  ADDWF  x81,W
04D32:  MOVWF  xCC
04D34:  MOVF   03,W
04D36:  ADDWFC x82,W
04D38:  MOVWF  xCD
04D3A:  MOVLW  00
04D3C:  ADDWFC x83,W
04D3E:  MOVWF  xCE
04D40:  MOVLW  00
04D42:  ADDWFC x84,W
04D44:  MOVWF  xCF
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
04D46:  MOVFF  301,C56
04D4A:  MOVFF  300,C55
04D4E:  MOVFF  2FF,C54
04D52:  MOVFF  2FE,C53
04D56:  MOVFF  3CF,C5A
04D5A:  MOVFF  3CE,C59
04D5E:  MOVFF  3CD,C58
04D62:  MOVFF  3CC,C57
04D66:  MOVLW  03
04D68:  MOVLB  C
04D6A:  MOVWF  x5C
04D6C:  MOVLW  87
04D6E:  MOVWF  x5B
04D70:  CLRF   x5E
04D72:  MOVLW  40
04D74:  MOVWF  x5D
04D76:  MOVLB  0
04D78:  CALL   3170
04D7C:  MOVLB  3
04D7E:  INCF   xC7,F
04D80:  BTFSC  FD8.2
04D82:  INCF   xC8,F
04D84:  MOVLB  0
04D86:  GOTO   4C4C
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
04D8A:  MOVFF  380,3D1
04D8E:  MOVLW  02
04D90:  MOVLB  3
04D92:  MOVWF  xD2
04D94:  MOVLB  0
04D96:  CALL   35F0
....................    fprintf(PC, "\r\n");
04D9A:  MOVLW  0D
04D9C:  MOVLB  C
04D9E:  MOVWF  x14
04DA0:  MOVLB  0
04DA2:  CALL   1BC2
04DA6:  MOVLW  0A
04DA8:  MOVLB  C
04DAA:  MOVWF  x14
04DAC:  MOVLB  0
04DAE:  CALL   1BC2
....................    fprintf(PC, "End Flash Write Demo\r\n");
04DB2:  MOVLW  D2
04DB4:  MOVWF  FF6
04DB6:  MOVLW  16
04DB8:  MOVWF  FF7
04DBA:  MOVLW  00
04DBC:  MOVWF  FF8
04DBE:  CALL   1C14
04DC2:  GOTO   885E (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
04DF6:  MOVLW  EA
04DF8:  MOVWF  FF6
04DFA:  MOVLW  16
04DFC:  MOVWF  FF7
04DFE:  MOVLW  00
04E00:  MOVWF  FF8
04E02:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
04E06:  MOVLB  3
04E08:  MOVF   x7E,W
04E0A:  MOVWF  FE9
04E0C:  MOVF   x7F,W
04E0E:  MOVWF  FEA
04E10:  MOVFF  FEF,384
04E14:  MOVFF  384,3D1
04E18:  MOVLW  01
04E1A:  MOVWF  xD2
04E1C:  MOVLB  0
04E1E:  CALL   35F0
....................    flash_setting(mis_fm);
04E22:  MOVFF  301,48C
04E26:  MOVFF  300,48B
04E2A:  MOVFF  2FF,48A
04E2E:  MOVFF  2FE,489
04E32:  CALL   4DC6
....................    unsigned int32 write_address = 0x00000000;
04E36:  MOVLB  3
04E38:  CLRF   x83
04E3A:  CLRF   x82
04E3C:  CLRF   x81
04E3E:  CLRF   x80
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
04E40:  MOVF   x7E,W
04E42:  MOVWF  FE9
04E44:  MOVF   x7F,W
04E46:  MOVWF  FEA
04E48:  MOVFF  FEF,384
04E4C:  MOVFF  384,3D1
04E50:  MOVLW  02
04E52:  MOVWF  xD2
04E54:  MOVLB  0
04E56:  CALL   35F0
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
04E5A:  MOVLW  10
04E5C:  MOVWF  FF6
04E5E:  MOVLW  17
04E60:  MOVWF  FF7
04E62:  MOVLW  00
04E64:  MOVWF  FF8
04E66:  CALL   1C14
04E6A:  GOTO   886E (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
04E6E:  MOVLW  34
04E70:  MOVWF  FF6
04E72:  MOVLW  17
04E74:  MOVWF  FF7
04E76:  MOVLW  00
04E78:  MOVWF  FF8
04E7A:  CALL   1C14
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
04E7E:  MOVLB  3
04E80:  MOVF   x7E,W
04E82:  MOVWF  FE9
04E84:  MOVF   x7F,W
04E86:  MOVWF  FEA
04E88:  MOVFF  FEF,3D0
04E8C:  MOVFF  3D0,3D1
04E90:  MOVLW  01
04E92:  MOVWF  xD2
04E94:  MOVLB  0
04E96:  CALL   35F0
....................    FLASH_PARAM flash_param = {0};
04E9A:  MOVLB  3
04E9C:  CLRF   x80
04E9E:  CLRF   x81
04EA0:  CLRF   x82
04EA2:  CLRF   x83
04EA4:  CLRF   x84
04EA6:  CLRF   x85
04EA8:  CLRF   x86
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
04EAA:  MOVF   x7E,W
04EAC:  MOVWF  FE9
04EAE:  MOVF   x7F,W
04EB0:  MOVWF  FEA
04EB2:  MOVFF  FEF,380
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
04EB6:  MOVLW  01
04EB8:  ADDWF  x7E,W
04EBA:  MOVWF  FE9
04EBC:  MOVLW  00
04EBE:  ADDWFC x7F,W
04EC0:  MOVWF  FEA
04EC2:  MOVF   FEF,W
04EC4:  CLRF   xD3
04EC6:  CLRF   xD2
04EC8:  CLRF   xD1
04ECA:  MOVWF  xD0
04ECC:  MOVFF  3D0,3D3
04ED0:  CLRF   xD0
04ED2:  CLRF   xD1
04ED4:  CLRF   xD2
04ED6:  MOVLW  02
04ED8:  ADDWF  x7E,W
04EDA:  MOVWF  FE9
04EDC:  MOVLW  00
04EDE:  ADDWFC x7F,W
04EE0:  MOVWF  FEA
04EE2:  MOVF   FEF,W
04EE4:  CLRF   xD8
04EE6:  CLRF   xD7
04EE8:  CLRF   xD6
04EEA:  MOVWF  xD5
04EEC:  MOVFF  3D6,03
04EF0:  MOVFF  3D5,02
04EF4:  CLRF   00
04EF6:  CLRF   01
04EF8:  MOVF   00,W
04EFA:  IORWF  xD0,F
04EFC:  MOVF   01,W
04EFE:  IORWF  xD1,F
04F00:  MOVF   02,W
04F02:  IORWF  xD2,F
04F04:  MOVF   03,W
04F06:  IORWF  xD3,F
04F08:  MOVLW  03
04F0A:  ADDWF  x7E,W
04F0C:  MOVWF  FE9
04F0E:  MOVLW  00
04F10:  ADDWFC x7F,W
04F12:  MOVWF  FEA
04F14:  MOVF   FEF,W
04F16:  CLRF   xD8
04F18:  CLRF   xD7
04F1A:  CLRF   xD6
04F1C:  MOVWF  xD5
04F1E:  MOVFF  3D7,03
04F22:  MOVFF  3D6,02
04F26:  MOVFF  3D5,01
04F2A:  CLRF   00
04F2C:  MOVF   00,W
04F2E:  IORWF  xD0,F
04F30:  MOVF   01,W
04F32:  IORWF  xD1,F
04F34:  MOVF   02,W
04F36:  IORWF  xD2,F
04F38:  MOVF   03,W
04F3A:  IORWF  xD3,F
04F3C:  MOVLW  04
04F3E:  ADDWF  x7E,W
04F40:  MOVWF  FE9
04F42:  MOVLW  00
04F44:  ADDWFC x7F,W
04F46:  MOVWF  FEA
04F48:  MOVF   FEF,W
04F4A:  MOVWF  00
04F4C:  CLRF   01
04F4E:  CLRF   02
04F50:  CLRF   03
04F52:  MOVF   00,W
04F54:  IORWF  xD0,W
04F56:  MOVWF  x83
04F58:  MOVF   01,W
04F5A:  IORWF  xD1,W
04F5C:  MOVWF  x84
04F5E:  MOVF   02,W
04F60:  IORWF  xD2,W
04F62:  MOVWF  x85
04F64:  MOVF   03,W
04F66:  IORWF  xD3,W
04F68:  MOVWF  x86
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
04F6A:  MOVLW  07
04F6C:  ADDWF  x7E,W
04F6E:  MOVWF  FE9
04F70:  MOVLW  00
04F72:  ADDWFC x7F,W
04F74:  MOVWF  FEA
04F76:  MOVF   FEF,W
04F78:  CLRF   xD1
04F7A:  MOVWF  xD0
04F7C:  MOVFF  3D0,3D1
04F80:  CLRF   xD0
04F82:  MOVLW  08
04F84:  ADDWF  x7E,W
04F86:  MOVWF  FE9
04F88:  MOVLW  00
04F8A:  ADDWFC x7F,W
04F8C:  MOVWF  FEA
04F8E:  MOVF   FEF,W
04F90:  CLRF   03
04F92:  IORWF  xD0,W
04F94:  MOVWF  x81
04F96:  MOVF   03,W
04F98:  IORWF  xD1,W
04F9A:  MOVWF  x82
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
04F9C:  MOVLW  48
04F9E:  MOVWF  FF6
04FA0:  MOVLW  17
04FA2:  MOVWF  FF7
04FA4:  MOVLW  00
04FA6:  MOVWF  FF8
04FA8:  MOVLW  0C
04FAA:  MOVLB  B
04FAC:  MOVWF  xC1
04FAE:  MOVLB  0
04FB0:  CALL   1C44
04FB4:  MOVFF  380,BC1
04FB8:  MOVLW  37
04FBA:  MOVLB  B
04FBC:  MOVWF  xC2
04FBE:  MOVLB  0
04FC0:  CALL   1E98
04FC4:  MOVLW  0D
04FC6:  MOVLB  C
04FC8:  MOVWF  x14
04FCA:  MOVLB  0
04FCC:  CALL   1BC2
04FD0:  MOVLW  0A
04FD2:  MOVLB  C
04FD4:  MOVWF  x14
04FD6:  MOVLB  0
04FD8:  CALL   1BC2
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
04FDC:  MOVLW  5C
04FDE:  MOVWF  FF6
04FE0:  MOVLW  17
04FE2:  MOVWF  FF7
04FE4:  MOVLW  00
04FE6:  MOVWF  FF8
04FE8:  MOVLW  0E
04FEA:  MOVLB  B
04FEC:  MOVWF  xC1
04FEE:  MOVLB  0
04FF0:  CALL   1C44
04FF4:  MOVFF  386,BC1
04FF8:  MOVLW  37
04FFA:  MOVLB  B
04FFC:  MOVWF  xC2
04FFE:  MOVLB  0
05000:  CALL   1E98
05004:  MOVFF  385,BC1
05008:  MOVLW  37
0500A:  MOVLB  B
0500C:  MOVWF  xC2
0500E:  MOVLB  0
05010:  CALL   1E98
05014:  MOVFF  384,BC1
05018:  MOVLW  37
0501A:  MOVLB  B
0501C:  MOVWF  xC2
0501E:  MOVLB  0
05020:  CALL   1E98
05024:  MOVFF  383,BC1
05028:  MOVLW  37
0502A:  MOVLB  B
0502C:  MOVWF  xC2
0502E:  MOVLB  0
05030:  CALL   1E98
05034:  MOVLW  0D
05036:  MOVLB  C
05038:  MOVWF  x14
0503A:  MOVLB  0
0503C:  CALL   1BC2
05040:  MOVLW  0A
05042:  MOVLB  C
05044:  MOVWF  x14
05046:  MOVLB  0
05048:  CALL   1BC2
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
0504C:  MOVLW  72
0504E:  MOVWF  FF6
05050:  MOVLW  17
05052:  MOVWF  FF7
05054:  MOVLW  00
05056:  MOVWF  FF8
05058:  MOVLW  0E
0505A:  MOVLB  B
0505C:  MOVWF  xC1
0505E:  MOVLB  0
05060:  CALL   1C44
05064:  MOVFF  382,BC1
05068:  MOVLW  37
0506A:  MOVLB  B
0506C:  MOVWF  xC2
0506E:  MOVLB  0
05070:  CALL   1E98
05074:  MOVFF  381,BC1
05078:  MOVLW  37
0507A:  MOVLB  B
0507C:  MOVWF  xC2
0507E:  MOVLB  0
05080:  CALL   1E98
05084:  MOVLW  0D
05086:  MOVLB  C
05088:  MOVWF  x14
0508A:  MOVLB  0
0508C:  CALL   1BC2
05090:  MOVLW  0A
05092:  MOVLB  C
05094:  MOVWF  x14
05096:  MOVLB  0
05098:  CALL   1BC2
....................    
....................    piclog_make(flash_param.id, 0x00);
0509C:  MOVFF  380,3D1
050A0:  MOVLB  3
050A2:  CLRF   xD2
050A4:  MOVLB  0
050A6:  CALL   35F0
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
050AA:  MOVLB  3
050AC:  CLRF   x87
050AE:  CLRF   x88
050B0:  CLRF   x89
050B2:  CLRF   x8A
050B4:  CLRF   x8B
050B6:  CLRF   x8C
050B8:  CLRF   x8D
050BA:  CLRF   x8E
050BC:  CLRF   x8F
050BE:  CLRF   x90
050C0:  CLRF   x91
050C2:  CLRF   x92
050C4:  CLRF   x93
050C6:  CLRF   x94
050C8:  CLRF   x95
050CA:  CLRF   x96
050CC:  CLRF   x97
050CE:  CLRF   x98
050D0:  CLRF   x99
050D2:  CLRF   x9A
050D4:  CLRF   x9B
050D6:  CLRF   x9C
050D8:  CLRF   x9D
050DA:  CLRF   x9E
050DC:  CLRF   x9F
050DE:  CLRF   xA0
050E0:  CLRF   xA1
050E2:  CLRF   xA2
050E4:  CLRF   xA3
050E6:  CLRF   xA4
050E8:  CLRF   xA5
050EA:  CLRF   xA6
050EC:  CLRF   xA7
050EE:  CLRF   xA8
050F0:  CLRF   xA9
050F2:  CLRF   xAA
050F4:  CLRF   xAB
050F6:  CLRF   xAC
050F8:  CLRF   xAD
050FA:  CLRF   xAE
050FC:  CLRF   xAF
050FE:  CLRF   xB0
05100:  CLRF   xB1
05102:  CLRF   xB2
05104:  CLRF   xB3
05106:  CLRF   xB4
05108:  CLRF   xB5
0510A:  CLRF   xB6
0510C:  CLRF   xB7
0510E:  CLRF   xB8
05110:  CLRF   xB9
05112:  CLRF   xBA
05114:  CLRF   xBB
05116:  CLRF   xBC
05118:  CLRF   xBD
0511A:  CLRF   xBE
0511C:  CLRF   xBF
0511E:  CLRF   xC0
05120:  CLRF   xC1
05122:  CLRF   xC2
05124:  CLRF   xC3
05126:  CLRF   xC4
05128:  CLRF   xC5
0512A:  CLRF   xC6
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
0512C:  MOVLW  88
0512E:  MOVWF  FF6
05130:  MOVLW  17
05132:  MOVWF  FF7
05134:  MOVLW  00
05136:  MOVWF  FF8
05138:  MOVLB  0
0513A:  CALL   1C14
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
0513E:  MOVFF  301,430
05142:  MOVFF  300,42F
05146:  MOVFF  2FF,42E
0514A:  MOVFF  2FE,42D
0514E:  CALL   272A
05152:  MOVF   01,F
05154:  BTFSS  FD8.2
05156:  GOTO   516A
....................       fprintf(PC, "Mission Flash is not connected\r\n");
0515A:  MOVLW  94
0515C:  MOVWF  FF6
0515E:  MOVLW  17
05160:  MOVWF  FF7
05162:  MOVLW  00
05164:  MOVWF  FF8
05166:  CALL   1C14
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
0516A:  MOVLB  3
0516C:  CLRF   xCE
0516E:  CLRF   xCD
05170:  CLRF   xCC
05172:  CLRF   xCB
05174:  MOVLB  0
05176:  MOVLB  3
05178:  MOVF   xCE,F
0517A:  BTFSC  FD8.2
0517C:  BRA    5184
0517E:  MOVLB  0
05180:  GOTO   52D2
05184:  MOVLB  0
05186:  MOVLB  3
05188:  MOVF   xCD,F
0518A:  BTFSC  FD8.2
0518C:  BRA    5194
0518E:  MOVLB  0
05190:  GOTO   52D2
05194:  MOVLB  0
05196:  MOVLB  3
05198:  MOVF   xCC,W
0519A:  SUBWF  x82,W
0519C:  BTFSC  FD8.0
0519E:  BRA    51A6
051A0:  MOVLB  0
051A2:  GOTO   52D2
051A6:  MOVLB  0
051A8:  BTFSS  FD8.2
051AA:  GOTO   51C0
051AE:  MOVLB  3
051B0:  MOVF   x81,W
051B2:  SUBWF  xCB,W
051B4:  BTFSS  FD8.0
051B6:  BRA    51BE
051B8:  MOVLB  0
051BA:  GOTO   52D2
051BE:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
051C0:  MOVLB  3
051C2:  RLCF   xCB,W
051C4:  MOVWF  00
051C6:  RLCF   xCC,W
051C8:  MOVWF  01
051CA:  RLCF   xCD,W
051CC:  MOVWF  02
051CE:  RLCF   xCE,W
051D0:  MOVWF  03
051D2:  RLCF   00,F
051D4:  RLCF   01,F
051D6:  RLCF   02,F
051D8:  RLCF   03,F
051DA:  RLCF   00,F
051DC:  RLCF   01,F
051DE:  RLCF   02,F
051E0:  RLCF   03,F
051E2:  RLCF   00,F
051E4:  RLCF   01,F
051E6:  RLCF   02,F
051E8:  RLCF   03,F
051EA:  RLCF   00,F
051EC:  RLCF   01,F
051EE:  RLCF   02,F
051F0:  RLCF   03,F
051F2:  RLCF   00,F
051F4:  RLCF   01,F
051F6:  RLCF   02,F
051F8:  RLCF   03,F
051FA:  MOVLW  C0
051FC:  ANDWF  00,F
051FE:  MOVF   00,W
05200:  ADDWF  x83,W
05202:  MOVWF  xC7
05204:  MOVF   01,W
05206:  ADDWFC x84,W
05208:  MOVWF  xC8
0520A:  MOVF   02,W
0520C:  ADDWFC x85,W
0520E:  MOVWF  xC9
05210:  MOVF   03,W
05212:  ADDWFC x86,W
05214:  MOVWF  xCA
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
05216:  MOVFF  301,48C
0521A:  MOVFF  300,48B
0521E:  MOVFF  2FF,48A
05222:  MOVFF  2FE,489
05226:  MOVFF  3CA,490
0522A:  MOVFF  3C9,48F
0522E:  MOVFF  3C8,48E
05232:  MOVFF  3C7,48D
05236:  MOVLW  03
05238:  MOVLB  4
0523A:  MOVWF  x92
0523C:  MOVLW  87
0523E:  MOVWF  x91
05240:  CLRF   x96
05242:  CLRF   x95
05244:  CLRF   x94
05246:  MOVLW  40
05248:  MOVWF  x93
0524A:  MOVLB  0
0524C:  CALL   27F2
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
05250:  MOVLB  3
05252:  CLRF   xCF
05254:  MOVLB  0
05256:  MOVLB  3
05258:  MOVF   xCF,W
0525A:  SUBLW  3F
0525C:  BTFSC  FD8.0
0525E:  BRA    5266
05260:  MOVLB  0
05262:  GOTO   52A2
05266:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
05268:  CLRF   03
0526A:  MOVLB  3
0526C:  MOVF   xCF,W
0526E:  ADDLW  87
05270:  MOVWF  FE9
05272:  MOVLW  03
05274:  ADDWFC 03,W
05276:  MOVWF  FEA
05278:  MOVFF  FEF,3D0
0527C:  MOVFF  3D0,BC1
05280:  MOVLW  37
05282:  MOVLB  B
05284:  MOVWF  xC2
05286:  MOVLB  0
05288:  CALL   1E98
0528C:  MOVLW  20
0528E:  MOVLB  C
05290:  MOVWF  x14
05292:  MOVLB  0
05294:  CALL   1BC2
05298:  MOVLB  3
0529A:  INCF   xCF,F
0529C:  MOVLB  0
0529E:  GOTO   5256
....................       }
....................       fprintf(PC,"\r\n");
052A2:  MOVLW  0D
052A4:  MOVLB  C
052A6:  MOVWF  x14
052A8:  MOVLB  0
052AA:  CALL   1BC2
052AE:  MOVLW  0A
052B0:  MOVLB  C
052B2:  MOVWF  x14
052B4:  MOVLB  0
052B6:  CALL   1BC2
052BA:  MOVLW  01
052BC:  MOVLB  3
052BE:  ADDWF  xCB,F
052C0:  BTFSC  FD8.0
052C2:  INCF   xCC,F
052C4:  BTFSC  FD8.2
052C6:  INCF   xCD,F
052C8:  BTFSC  FD8.2
052CA:  INCF   xCE,F
052CC:  MOVLB  0
052CE:  GOTO   5176
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
052D2:  MOVFF  380,3D1
052D6:  MOVLW  02
052D8:  MOVLB  3
052DA:  MOVWF  xD2
052DC:  MOVLB  0
052DE:  CALL   35F0
....................    fprintf(PC, "End Flash Read\r\n");
052E2:  MOVLW  B6
052E4:  MOVWF  FF6
052E6:  MOVLW  17
052E8:  MOVWF  FF7
052EA:  MOVLW  00
052EC:  MOVWF  FF8
052EE:  CALL   1C14
052F2:  GOTO   887E (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
052F6:  MOVLW  C8
052F8:  MOVWF  FF6
052FA:  MOVLW  17
052FC:  MOVWF  FF7
052FE:  MOVLW  00
05300:  MOVWF  FF8
05302:  CALL   1C14
....................    flash_setting(mis_fm);
05306:  MOVFF  301,48C
0530A:  MOVFF  300,48B
0530E:  MOVFF  2FF,48A
05312:  MOVFF  2FE,489
05316:  CALL   4DC6
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
0531A:  MOVLB  3
0531C:  CLRF   x83
0531E:  CLRF   x82
05320:  CLRF   x81
05322:  CLRF   x80
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
05324:  MOVFF  301,48C
05328:  MOVFF  300,48B
0532C:  MOVFF  2FF,48A
05330:  MOVFF  2FE,489
05334:  MOVFF  383,490
05338:  MOVFF  382,48F
0533C:  MOVFF  381,48E
05340:  MOVFF  380,48D
05344:  MOVLW  03
05346:  MOVLB  4
05348:  MOVWF  x92
0534A:  MOVLW  84
0534C:  MOVWF  x91
0534E:  CLRF   x96
05350:  CLRF   x95
05352:  CLRF   x94
05354:  MOVLW  04
05356:  MOVWF  x93
05358:  MOVLB  0
0535A:  CALL   27F2
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
0535E:  MOVLW  E4
05360:  MOVWF  FF6
05362:  MOVLW  17
05364:  MOVWF  FF7
05366:  MOVLW  00
05368:  MOVWF  FF8
0536A:  MOVLW  0B
0536C:  MOVLB  B
0536E:  MOVWF  xC1
05370:  MOVLB  0
05372:  CALL   1C44
05376:  MOVFF  384,BC1
0537A:  MOVLW  37
0537C:  MOVLB  B
0537E:  MOVWF  xC2
05380:  MOVLB  0
05382:  CALL   1E98
05386:  MOVLW  20
05388:  MOVLB  C
0538A:  MOVWF  x14
0538C:  MOVLB  0
0538E:  CALL   1BC2
05392:  MOVFF  385,BC1
05396:  MOVLW  37
05398:  MOVLB  B
0539A:  MOVWF  xC2
0539C:  MOVLB  0
0539E:  CALL   1E98
053A2:  MOVLW  20
053A4:  MOVLB  C
053A6:  MOVWF  x14
053A8:  MOVLB  0
053AA:  CALL   1BC2
053AE:  MOVFF  386,BC1
053B2:  MOVLW  37
053B4:  MOVLB  B
053B6:  MOVWF  xC2
053B8:  MOVLB  0
053BA:  CALL   1E98
053BE:  MOVLW  20
053C0:  MOVLB  C
053C2:  MOVWF  x14
053C4:  MOVLB  0
053C6:  CALL   1BC2
053CA:  MOVFF  387,BC1
053CE:  MOVLW  37
053D0:  MOVLB  B
053D2:  MOVWF  xC2
053D4:  MOVLB  0
053D6:  CALL   1E98
053DA:  MOVLW  0D
053DC:  MOVLB  C
053DE:  MOVWF  x14
053E0:  MOVLB  0
053E2:  CALL   1BC2
053E6:  MOVLW  0A
053E8:  MOVLB  C
053EA:  MOVWF  x14
053EC:  MOVLB  0
053EE:  CALL   1BC2
....................    fprintf(PC, "End Flash Read Address\r\n");
053F2:  MOVLW  06
053F4:  MOVWF  FF6
053F6:  MOVLW  18
053F8:  MOVWF  FF7
053FA:  MOVLW  00
053FC:  MOVWF  FF8
053FE:  CALL   1C14
05402:  GOTO   888E (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
05516:  MOVLW  20
05518:  MOVWF  FF6
0551A:  MOVLW  18
0551C:  MOVWF  FF7
0551E:  MOVLW  00
05520:  MOVWF  FF8
05522:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05526:  MOVLB  3
05528:  MOVF   x7E,W
0552A:  MOVWF  FE9
0552C:  MOVF   x7F,W
0552E:  MOVWF  FEA
05530:  MOVFF  FEF,380
05534:  MOVFF  380,3D1
05538:  MOVLW  01
0553A:  MOVWF  xD2
0553C:  MOVLB  0
0553E:  CALL   35F0
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
05542:  MOVFF  37F,381
05546:  MOVFF  37E,380
0554A:  CALL   412E
....................    mode_misf_address_reset(parameter); // Reset the address area
0554E:  MOVFF  37F,381
05552:  MOVFF  37E,380
05556:  GOTO   5406
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
0555A:  MOVLW  3E
0555C:  MOVWF  FF6
0555E:  MOVLW  18
05560:  MOVWF  FF7
05562:  MOVLW  00
05564:  MOVWF  FF8
05566:  CALL   1C14
0556A:  GOTO   889E (RETURN)
.................... }
.................... 
.................... void mode_flash_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    unsigned int8 writedata[PACKET_SIZE] = {0x00}; // Initialize write data to zero
....................    
....................    write_data_bytes(mis_fm, ADDRESS_MANAGE_START, writedata, PACKET_SIZE);
....................    misf_init(); // Update the address area after writing
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End Flash Address Reset\r\n");
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
0556E:  MOVLW  90
05570:  MOVWF  FF6
05572:  MOVLW  18
05574:  MOVWF  FF7
05576:  MOVLW  00
05578:  MOVWF  FF8
0557A:  CALL   1C14
....................    flash_setting(mis_fm);
0557E:  MOVFF  301,48C
05582:  MOVFF  300,48B
05586:  MOVFF  2FF,48A
0558A:  MOVFF  2FE,489
0558E:  CALL   4DC6
....................    flash_setting(smf);
05592:  MOVFF  305,48C
05596:  MOVFF  304,48B
0559A:  MOVFF  303,48A
0559E:  MOVFF  302,489
055A2:  CALL   4DC6
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
055A6:  MOVLB  3
055A8:  MOVF   x7E,W
055AA:  MOVWF  FE9
055AC:  MOVF   x7F,W
055AE:  MOVWF  FEA
055B0:  MOVFF  FEF,380
055B4:  CLRF   x84
055B6:  CLRF   x83
055B8:  CLRF   x82
055BA:  CLRF   x81
055BC:  CLRF   x88
055BE:  CLRF   x87
055C0:  MOVLW  10
055C2:  MOVWF  x86
055C4:  CLRF   x85
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
055C6:  MOVFF  301,48C
055CA:  MOVFF  300,48B
055CE:  MOVFF  2FF,48A
055D2:  MOVFF  2FE,489
055D6:  MOVFF  384,490
055DA:  MOVFF  383,48F
055DE:  MOVFF  382,48E
055E2:  MOVFF  381,48D
055E6:  MOVLW  03
055E8:  MOVLB  4
055EA:  MOVWF  x92
055EC:  MOVLW  89
055EE:  MOVWF  x91
055F0:  CLRF   x96
055F2:  CLRF   x95
055F4:  MOVLW  01
055F6:  MOVWF  x94
055F8:  CLRF   x93
055FA:  MOVLB  0
055FC:  CALL   27F2
....................    write_data_bytes(smf, dest_address, read_data, 256);
05600:  MOVFF  305,C56
05604:  MOVFF  304,C55
05608:  MOVFF  303,C54
0560C:  MOVFF  302,C53
05610:  MOVFF  388,C5A
05614:  MOVFF  387,C59
05618:  MOVFF  386,C58
0561C:  MOVFF  385,C57
05620:  MOVLW  03
05622:  MOVLB  C
05624:  MOVWF  x5C
05626:  MOVLW  89
05628:  MOVWF  x5B
0562A:  MOVLW  01
0562C:  MOVWF  x5E
0562E:  CLRF   x5D
05630:  MOVLB  0
05632:  CALL   3170
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
05636:  MOVLW  A8
05638:  MOVWF  FF6
0563A:  MOVLW  18
0563C:  MOVWF  FF7
0563E:  MOVLW  00
05640:  MOVWF  FF8
05642:  CALL   1C14
05646:  GOTO   88AE (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
0564A:  MOVLW  BE
0564C:  MOVWF  FF6
0564E:  MOVLW  18
05650:  MOVWF  FF7
05652:  MOVLW  00
05654:  MOVWF  FF8
05656:  CALL   1C14
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
0565A:  MOVFF  305,48C
0565E:  MOVFF  304,48B
05662:  MOVFF  303,48A
05666:  MOVFF  302,489
0566A:  MOVLB  4
0566C:  CLRF   x90
0566E:  CLRF   x8F
05670:  MOVLW  03
05672:  MOVWF  x8E
05674:  MOVLW  80
05676:  MOVWF  x8D
05678:  MOVLW  03
0567A:  MOVWF  x92
0567C:  MOVLW  80
0567E:  MOVWF  x91
05680:  CLRF   x96
05682:  CLRF   x95
05684:  CLRF   x94
05686:  MOVLW  40
05688:  MOVWF  x93
0568A:  MOVLB  0
0568C:  CALL   27F2
....................    fprintf(PC, "Read Data: ");
05690:  MOVLW  D6
05692:  MOVWF  FF6
05694:  MOVLW  18
05696:  MOVWF  FF7
05698:  MOVLW  00
0569A:  MOVWF  FF8
0569C:  CALL   1C14
....................    for (int i = 0; i < PACKET_SIZE; i++)
056A0:  MOVLB  3
056A2:  CLRF   xC0
056A4:  MOVLB  0
056A6:  MOVLB  3
056A8:  MOVF   xC0,W
056AA:  SUBLW  3F
056AC:  BTFSC  FD8.0
056AE:  BRA    56B6
056B0:  MOVLB  0
056B2:  GOTO   56F2
056B6:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
056B8:  CLRF   03
056BA:  MOVLB  3
056BC:  MOVF   xC0,W
056BE:  ADDLW  80
056C0:  MOVWF  FE9
056C2:  MOVLW  03
056C4:  ADDWFC 03,W
056C6:  MOVWF  FEA
056C8:  MOVFF  FEF,3C1
056CC:  MOVFF  3C1,BC1
056D0:  MOVLW  37
056D2:  MOVLB  B
056D4:  MOVWF  xC2
056D6:  MOVLB  0
056D8:  CALL   1E98
056DC:  MOVLW  20
056DE:  MOVLB  C
056E0:  MOVWF  x14
056E2:  MOVLB  0
056E4:  CALL   1BC2
056E8:  MOVLB  3
056EA:  INCF   xC0,F
056EC:  MOVLB  0
056EE:  GOTO   56A6
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
056F2:  MOVLW  E2
056F4:  MOVWF  FF6
056F6:  MOVLW  18
056F8:  MOVWF  FF7
056FA:  MOVLW  00
056FC:  MOVWF  FF8
056FE:  CALL   1C14
05702:  GOTO   88BE (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
05706:  MOVLW  FA
05708:  MOVWF  FF6
0570A:  MOVLW  18
0570C:  MOVWF  FF7
0570E:  MOVLW  00
05710:  MOVWF  FF8
05712:  CALL   1C14
....................    flash_setting(smf);
05716:  MOVFF  305,48C
0571A:  MOVFF  304,48B
0571E:  MOVFF  303,48A
05722:  MOVFF  302,489
05726:  CALL   4DC6
....................    unsigned int32 erase_address = 0x00000000; // Example address
0572A:  MOVLB  3
0572C:  CLRF   x83
0572E:  CLRF   x82
05730:  CLRF   x81
05732:  CLRF   x80
....................    sector_erase(smf, erase_address); // Erase the sector
05734:  MOVFF  305,3C7
05738:  MOVFF  304,3C6
0573C:  MOVFF  303,3C5
05740:  MOVFF  302,3C4
05744:  MOVFF  383,3CB
05748:  MOVFF  382,3CA
0574C:  MOVFF  381,3C9
05750:  MOVFF  380,3C8
05754:  MOVLB  0
05756:  CALL   3DD2
....................    fprintf(PC, "End Flash SMF Erase\r\n");
0575A:  MOVLW  12
0575C:  MOVWF  FF6
0575E:  MOVLW  19
05760:  MOVWF  FF7
05762:  MOVLW  00
05764:  MOVWF  FF8
05766:  CALL   1C14
0576A:  GOTO   88CE (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
05406:  MOVLW  28
05408:  MOVWF  FF6
0540A:  MOVLW  19
0540C:  MOVWF  FF7
0540E:  MOVLW  00
05410:  MOVWF  FF8
05412:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05416:  MOVLB  3
05418:  MOVF   x80,W
0541A:  MOVWF  FE9
0541C:  MOVF   x81,W
0541E:  MOVWF  FEA
05420:  MOVFF  FEF,3C2
05424:  MOVFF  3C2,3D1
05428:  MOVLW  01
0542A:  MOVWF  xD2
0542C:  MOVLB  0
0542E:  CALL   35F0
....................    unsigned int8 writedata[PACKET_SIZE] = {0x00}; // Initialize write data to zero
05432:  MOVLB  3
05434:  CLRF   x82
05436:  CLRF   x83
05438:  CLRF   x84
0543A:  CLRF   x85
0543C:  CLRF   x86
0543E:  CLRF   x87
05440:  CLRF   x88
05442:  CLRF   x89
05444:  CLRF   x8A
05446:  CLRF   x8B
05448:  CLRF   x8C
0544A:  CLRF   x8D
0544C:  CLRF   x8E
0544E:  CLRF   x8F
05450:  CLRF   x90
05452:  CLRF   x91
05454:  CLRF   x92
05456:  CLRF   x93
05458:  CLRF   x94
0545A:  CLRF   x95
0545C:  CLRF   x96
0545E:  CLRF   x97
05460:  CLRF   x98
05462:  CLRF   x99
05464:  CLRF   x9A
05466:  CLRF   x9B
05468:  CLRF   x9C
0546A:  CLRF   x9D
0546C:  CLRF   x9E
0546E:  CLRF   x9F
05470:  CLRF   xA0
05472:  CLRF   xA1
05474:  CLRF   xA2
05476:  CLRF   xA3
05478:  CLRF   xA4
0547A:  CLRF   xA5
0547C:  CLRF   xA6
0547E:  CLRF   xA7
05480:  CLRF   xA8
05482:  CLRF   xA9
05484:  CLRF   xAA
05486:  CLRF   xAB
05488:  CLRF   xAC
0548A:  CLRF   xAD
0548C:  CLRF   xAE
0548E:  CLRF   xAF
05490:  CLRF   xB0
05492:  CLRF   xB1
05494:  CLRF   xB2
05496:  CLRF   xB3
05498:  CLRF   xB4
0549A:  CLRF   xB5
0549C:  CLRF   xB6
0549E:  CLRF   xB7
054A0:  CLRF   xB8
054A2:  CLRF   xB9
054A4:  CLRF   xBA
054A6:  CLRF   xBB
054A8:  CLRF   xBC
054AA:  CLRF   xBD
054AC:  CLRF   xBE
054AE:  CLRF   xBF
054B0:  CLRF   xC0
054B2:  CLRF   xC1
....................    
....................    write_data_bytes(mis_fm, ADDRESS_MANAGE_START, writedata, PACKET_SIZE);
054B4:  MOVFF  301,C56
054B8:  MOVFF  300,C55
054BC:  MOVFF  2FF,C54
054C0:  MOVFF  2FE,C53
054C4:  MOVLB  C
054C6:  CLRF   x5A
054C8:  CLRF   x59
054CA:  CLRF   x58
054CC:  CLRF   x57
054CE:  MOVLW  03
054D0:  MOVWF  x5C
054D2:  MOVLW  82
054D4:  MOVWF  x5B
054D6:  CLRF   x5E
054D8:  MOVLW  40
054DA:  MOVWF  x5D
054DC:  MOVLB  0
054DE:  CALL   3170
....................    misf_init(); // Update the address area after writing
054E2:  CALL   2AAC
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
054E6:  MOVLB  3
054E8:  MOVF   x80,W
054EA:  MOVWF  FE9
054EC:  MOVF   x81,W
054EE:  MOVWF  FEA
054F0:  MOVFF  FEF,3C2
054F4:  MOVFF  3C2,3D1
054F8:  MOVLW  02
054FA:  MOVWF  xD2
054FC:  MOVLB  0
054FE:  CALL   35F0
....................    fprintf(PC, "End Flash Address Reset\r\n");
05502:  MOVLW  44
05504:  MOVWF  FF6
05506:  MOVLW  19
05508:  MOVWF  FF7
0550A:  MOVLW  00
0550C:  MOVWF  FF8
0550E:  CALL   1C14
05512:  GOTO   555A (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
05920:  MOVLW  01
05922:  MOVLB  3
05924:  ADDWF  x7E,W
05926:  MOVWF  FE9
05928:  MOVLW  00
0592A:  ADDWFC x7F,W
0592C:  MOVWF  FEA
0592E:  MOVF   FEF,W
05930:  CLRF   xD0
05932:  CLRF   xCF
05934:  CLRF   xCE
05936:  MOVWF  xCD
05938:  MOVFF  3CD,3D0
0593C:  CLRF   xCD
0593E:  CLRF   xCE
05940:  CLRF   xCF
05942:  MOVLW  02
05944:  ADDWF  x7E,W
05946:  MOVWF  FE9
05948:  MOVLW  00
0594A:  ADDWFC x7F,W
0594C:  MOVWF  FEA
0594E:  MOVF   FEF,W
05950:  CLRF   xD5
05952:  CLRF   xD4
05954:  CLRF   xD3
05956:  MOVWF  xD2
05958:  MOVFF  3D3,03
0595C:  MOVFF  3D2,02
05960:  CLRF   00
05962:  CLRF   01
05964:  MOVF   00,W
05966:  IORWF  xCD,F
05968:  MOVF   01,W
0596A:  IORWF  xCE,F
0596C:  MOVF   02,W
0596E:  IORWF  xCF,F
05970:  MOVF   03,W
05972:  IORWF  xD0,F
05974:  MOVLW  03
05976:  ADDWF  x7E,W
05978:  MOVWF  FE9
0597A:  MOVLW  00
0597C:  ADDWFC x7F,W
0597E:  MOVWF  FEA
05980:  MOVF   FEF,W
05982:  CLRF   xD5
05984:  CLRF   xD4
05986:  CLRF   xD3
05988:  MOVWF  xD2
0598A:  MOVFF  3D4,03
0598E:  MOVFF  3D3,02
05992:  MOVFF  3D2,01
05996:  CLRF   00
05998:  MOVF   00,W
0599A:  IORWF  xCD,F
0599C:  MOVF   01,W
0599E:  IORWF  xCE,F
059A0:  MOVF   02,W
059A2:  IORWF  xCF,F
059A4:  MOVF   03,W
059A6:  IORWF  xD0,F
059A8:  MOVLW  04
059AA:  ADDWF  x7E,W
059AC:  MOVWF  FE9
059AE:  MOVLW  00
059B0:  ADDWFC x7F,W
059B2:  MOVWF  FEA
059B4:  MOVF   FEF,W
059B6:  MOVWF  00
059B8:  CLRF   01
059BA:  CLRF   02
059BC:  CLRF   03
059BE:  MOVF   00,W
059C0:  IORWF  xCD,W
059C2:  MOVWF  x80
059C4:  MOVF   01,W
059C6:  IORWF  xCE,W
059C8:  MOVWF  x81
059CA:  MOVF   02,W
059CC:  IORWF  xCF,W
059CE:  MOVWF  x82
059D0:  MOVF   03,W
059D2:  IORWF  xD0,W
059D4:  MOVWF  x83
059D6:  MOVLW  07
059D8:  ADDWF  x7E,W
059DA:  MOVWF  FE9
059DC:  MOVLW  00
059DE:  ADDWFC x7F,W
059E0:  MOVWF  FEA
059E2:  MOVF   FEF,W
059E4:  CLRF   xCE
059E6:  MOVWF  xCD
059E8:  MOVFF  3CD,3CE
059EC:  CLRF   xCD
059EE:  MOVLW  08
059F0:  ADDWF  x7E,W
059F2:  MOVWF  FE9
059F4:  MOVLW  00
059F6:  ADDWFC x7F,W
059F8:  MOVWF  FEA
059FA:  MOVF   FEF,W
059FC:  CLRF   03
059FE:  IORWF  xCD,W
05A00:  MOVWF  x84
05A02:  MOVF   03,W
05A04:  IORWF  xCE,W
05A06:  MOVWF  x85
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
05A08:  CLRF   x86
05A0A:  CLRF   x87
05A0C:  CLRF   x88
05A0E:  CLRF   x89
05A10:  CLRF   x8A
05A12:  CLRF   x8B
05A14:  CLRF   x8C
05A16:  CLRF   x8D
05A18:  CLRF   x8E
05A1A:  CLRF   x8F
05A1C:  CLRF   x90
05A1E:  CLRF   x91
05A20:  CLRF   x92
05A22:  CLRF   x93
05A24:  CLRF   x94
05A26:  CLRF   x95
05A28:  CLRF   x96
05A2A:  CLRF   x97
05A2C:  CLRF   x98
05A2E:  CLRF   x99
05A30:  CLRF   x9A
05A32:  CLRF   x9B
05A34:  CLRF   x9C
05A36:  CLRF   x9D
05A38:  CLRF   x9E
05A3A:  CLRF   x9F
05A3C:  CLRF   xA0
05A3E:  CLRF   xA1
05A40:  CLRF   xA2
05A42:  CLRF   xA3
05A44:  CLRF   xA4
05A46:  CLRF   xA5
05A48:  CLRF   xA6
05A4A:  CLRF   xA7
05A4C:  CLRF   xA8
05A4E:  CLRF   xA9
05A50:  CLRF   xAA
05A52:  CLRF   xAB
05A54:  CLRF   xAC
05A56:  CLRF   xAD
05A58:  CLRF   xAE
05A5A:  CLRF   xAF
05A5C:  CLRF   xB0
05A5E:  CLRF   xB1
05A60:  CLRF   xB2
05A62:  CLRF   xB3
05A64:  CLRF   xB4
05A66:  CLRF   xB5
05A68:  CLRF   xB6
05A6A:  CLRF   xB7
05A6C:  CLRF   xB8
05A6E:  CLRF   xB9
05A70:  CLRF   xBA
05A72:  CLRF   xBB
05A74:  CLRF   xBC
05A76:  CLRF   xBD
05A78:  CLRF   xBE
05A7A:  CLRF   xBF
05A7C:  CLRF   xC0
05A7E:  CLRF   xC1
05A80:  CLRF   xC2
05A82:  CLRF   xC3
05A84:  CLRF   xC4
05A86:  CLRF   xC5
....................    if(!is_connect(smf)) {
05A88:  MOVFF  305,430
05A8C:  MOVFF  304,42F
05A90:  MOVFF  303,42E
05A94:  MOVFF  302,42D
05A98:  MOVLB  0
05A9A:  CALL   272A
05A9E:  MOVF   01,F
05AA0:  BTFSS  FD8.2
05AA2:  GOTO   5ABA
....................       printf("SMF is not connected\r\n");
05AA6:  MOVLW  5E
05AA8:  MOVWF  FF6
05AAA:  MOVLW  19
05AAC:  MOVWF  FF7
05AAE:  MOVLW  00
05AB0:  MOVWF  FF8
05AB2:  CALL   1C14
....................       return;
05AB6:  GOTO   5D02
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
05ABA:  MOVLW  76
05ABC:  MOVWF  FF6
05ABE:  MOVLW  19
05AC0:  MOVWF  FF7
05AC2:  MOVLW  00
05AC4:  MOVWF  FF8
05AC6:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05ACA:  MOVLB  3
05ACC:  MOVF   x7E,W
05ACE:  MOVWF  FE9
05AD0:  MOVF   x7F,W
05AD2:  MOVWF  FEA
05AD4:  MOVFF  FEF,3CD
05AD8:  MOVFF  3CD,3D1
05ADC:  MOVLW  01
05ADE:  MOVWF  xD2
05AE0:  MOVLB  0
05AE2:  CALL   35F0
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
05AE6:  MOVLW  94
05AE8:  MOVWF  FF6
05AEA:  MOVLW  19
05AEC:  MOVWF  FF7
05AEE:  MOVLW  00
05AF0:  MOVWF  FF8
05AF2:  MOVLW  0E
05AF4:  MOVLB  B
05AF6:  MOVWF  xC1
05AF8:  MOVLB  0
05AFA:  CALL   1C44
05AFE:  MOVFF  383,BC1
05B02:  MOVLW  37
05B04:  MOVLB  B
05B06:  MOVWF  xC2
05B08:  MOVLB  0
05B0A:  CALL   1E98
05B0E:  MOVFF  382,BC1
05B12:  MOVLW  37
05B14:  MOVLB  B
05B16:  MOVWF  xC2
05B18:  MOVLB  0
05B1A:  CALL   1E98
05B1E:  MOVFF  381,BC1
05B22:  MOVLW  37
05B24:  MOVLB  B
05B26:  MOVWF  xC2
05B28:  MOVLB  0
05B2A:  CALL   1E98
05B2E:  MOVFF  380,BC1
05B32:  MOVLW  37
05B34:  MOVLB  B
05B36:  MOVWF  xC2
05B38:  MOVLB  0
05B3A:  CALL   1E98
05B3E:  MOVLW  0D
05B40:  MOVLB  C
05B42:  MOVWF  x14
05B44:  MOVLB  0
05B46:  CALL   1BC2
05B4A:  MOVLW  0A
05B4C:  MOVLB  C
05B4E:  MOVWF  x14
05B50:  MOVLB  0
05B52:  CALL   1BC2
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
05B56:  MOVLW  AA
05B58:  MOVWF  FF6
05B5A:  MOVLW  19
05B5C:  MOVWF  FF7
05B5E:  MOVLW  00
05B60:  MOVWF  FF8
05B62:  MOVLW  0E
05B64:  MOVLB  B
05B66:  MOVWF  xC1
05B68:  MOVLB  0
05B6A:  CALL   1C44
05B6E:  MOVFF  385,BC1
05B72:  MOVLW  37
05B74:  MOVLB  B
05B76:  MOVWF  xC2
05B78:  MOVLB  0
05B7A:  CALL   1E98
05B7E:  MOVFF  384,BC1
05B82:  MOVLW  37
05B84:  MOVLB  B
05B86:  MOVWF  xC2
05B88:  MOVLB  0
05B8A:  CALL   1E98
05B8E:  MOVLW  0D
05B90:  MOVLB  C
05B92:  MOVWF  x14
05B94:  MOVLB  0
05B96:  CALL   1BC2
05B9A:  MOVLW  0A
05B9C:  MOVLB  C
05B9E:  MOVWF  x14
05BA0:  MOVLB  0
05BA2:  CALL   1BC2
....................    printf("read data\r\n");
05BA6:  MOVLW  C0
05BA8:  MOVWF  FF6
05BAA:  MOVLW  19
05BAC:  MOVWF  FF7
05BAE:  MOVLW  00
05BB0:  MOVWF  FF8
05BB2:  CALL   1C14
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
05BB6:  MOVLB  3
05BB8:  CLRF   xC7
05BBA:  CLRF   xC6
05BBC:  MOVLB  0
05BBE:  MOVLB  3
05BC0:  MOVF   xC7,W
05BC2:  SUBWF  x85,W
05BC4:  BTFSC  FD8.0
05BC6:  BRA    5BCE
05BC8:  MOVLB  0
05BCA:  GOTO   5CD6
05BCE:  MOVLB  0
05BD0:  BTFSS  FD8.2
05BD2:  GOTO   5BE8
05BD6:  MOVLB  3
05BD8:  MOVF   x84,W
05BDA:  SUBWF  xC6,W
05BDC:  BTFSS  FD8.0
05BDE:  BRA    5BE6
05BE0:  MOVLB  0
05BE2:  GOTO   5CD6
05BE6:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
05BE8:  MOVLB  3
05BEA:  RLCF   xC6,W
05BEC:  MOVWF  02
05BEE:  RLCF   xC7,W
05BF0:  MOVWF  03
05BF2:  RLCF   02,F
05BF4:  RLCF   03,F
05BF6:  RLCF   02,F
05BF8:  RLCF   03,F
05BFA:  RLCF   02,F
05BFC:  RLCF   03,F
05BFE:  RLCF   02,F
05C00:  RLCF   03,F
05C02:  RLCF   02,F
05C04:  RLCF   03,F
05C06:  MOVLW  C0
05C08:  ANDWF  02,F
05C0A:  MOVF   02,W
05C0C:  ADDWF  x80,W
05C0E:  MOVWF  xC8
05C10:  MOVF   03,W
05C12:  ADDWFC x81,W
05C14:  MOVWF  xC9
05C16:  MOVLW  00
05C18:  ADDWFC x82,W
05C1A:  MOVWF  xCA
05C1C:  MOVLW  00
05C1E:  ADDWFC x83,W
05C20:  MOVWF  xCB
05C22:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
05C24:  MOVFF  305,48C
05C28:  MOVFF  304,48B
05C2C:  MOVFF  303,48A
05C30:  MOVFF  302,489
05C34:  MOVFF  3CB,490
05C38:  MOVFF  3CA,48F
05C3C:  MOVFF  3C9,48E
05C40:  MOVFF  3C8,48D
05C44:  MOVLW  03
05C46:  MOVLB  4
05C48:  MOVWF  x92
05C4A:  MOVLW  86
05C4C:  MOVWF  x91
05C4E:  CLRF   x96
05C50:  CLRF   x95
05C52:  CLRF   x94
05C54:  MOVLW  40
05C56:  MOVWF  x93
05C58:  MOVLB  0
05C5A:  CALL   27F2
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
05C5E:  MOVLB  3
05C60:  CLRF   xCC
05C62:  MOVLB  0
05C64:  MOVLB  3
05C66:  MOVF   xCC,W
05C68:  SUBLW  3F
05C6A:  BTFSC  FD8.0
05C6C:  BRA    5C74
05C6E:  MOVLB  0
05C70:  GOTO   5CB0
05C74:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
05C76:  CLRF   03
05C78:  MOVLB  3
05C7A:  MOVF   xCC,W
05C7C:  ADDLW  86
05C7E:  MOVWF  FE9
05C80:  MOVLW  03
05C82:  ADDWFC 03,W
05C84:  MOVWF  FEA
05C86:  MOVFF  FEF,3CD
05C8A:  MOVFF  3CD,BC1
05C8E:  MOVLW  37
05C90:  MOVLB  B
05C92:  MOVWF  xC2
05C94:  MOVLB  0
05C96:  CALL   1E98
05C9A:  MOVLW  20
05C9C:  MOVLB  C
05C9E:  MOVWF  x14
05CA0:  MOVLB  0
05CA2:  CALL   1BC2
05CA6:  MOVLB  3
05CA8:  INCF   xCC,F
05CAA:  MOVLB  0
05CAC:  GOTO   5C64
....................       }
....................       printf("\r\n");
05CB0:  MOVLW  0D
05CB2:  MOVLB  C
05CB4:  MOVWF  x14
05CB6:  MOVLB  0
05CB8:  CALL   1BC2
05CBC:  MOVLW  0A
05CBE:  MOVLB  C
05CC0:  MOVWF  x14
05CC2:  MOVLB  0
05CC4:  CALL   1BC2
05CC8:  MOVLB  3
05CCA:  INCF   xC6,F
05CCC:  BTFSC  FD8.2
05CCE:  INCF   xC7,F
05CD0:  MOVLB  0
05CD2:  GOTO   5BBE
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
05CD6:  MOVLW  CC
05CD8:  MOVWF  FF6
05CDA:  MOVLW  19
05CDC:  MOVWF  FF7
05CDE:  MOVLW  00
05CE0:  MOVWF  FF8
05CE2:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05CE6:  MOVLB  3
05CE8:  MOVF   x7E,W
05CEA:  MOVWF  FE9
05CEC:  MOVF   x7F,W
05CEE:  MOVWF  FEA
05CF0:  MOVFF  FEF,3CD
05CF4:  MOVFF  3CD,3D1
05CF8:  MOVLW  02
05CFA:  MOVWF  xD2
05CFC:  MOVLB  0
05CFE:  CALL   35F0
05D02:  GOTO   88EE (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
05D06:  MOVLW  EA
05D08:  MOVWF  FF6
05D0A:  MOVLW  19
05D0C:  MOVWF  FF7
05D0E:  MOVLW  00
05D10:  MOVWF  FF8
05D12:  CALL   1C14
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
05D16:  MOVLB  3
05D18:  MOVF   x7E,W
05D1A:  MOVWF  FE9
05D1C:  MOVF   x7F,W
05D1E:  MOVWF  FEA
05D20:  MOVFF  FEF,380
....................    piclog_make(cmd, 0x00); // Log the command execution
05D24:  MOVFF  380,3D1
05D28:  CLRF   xD2
05D2A:  MOVLB  0
05D2C:  CALL   35F0
....................    
.................... 
....................    
....................    for (int32 address = ADDRESS_MISF_START; address < ADDRESS_MISF_END; address += SECTOR_64K_BYTE) {
05D30:  MOVLB  3
05D32:  CLRF   x84
05D34:  CLRF   x83
05D36:  CLRF   x82
05D38:  CLRF   x81
05D3A:  MOVLB  0
05D3C:  MOVLB  3
05D3E:  MOVF   x84,F
05D40:  BTFSC  FD8.2
05D42:  BRA    5D4A
05D44:  MOVLB  0
05D46:  GOTO   5DAA
05D4A:  MOVLB  0
05D4C:  MOVLB  3
05D4E:  MOVF   x83,W
05D50:  SUBLW  F4
05D52:  BTFSC  FD8.0
05D54:  BRA    5D5C
05D56:  MOVLB  0
05D58:  GOTO   5DAA
05D5C:  MOVLB  0
05D5E:  BTFSS  FD8.2
05D60:  GOTO   5D76
05D64:  MOVLB  3
05D66:  MOVF   x82,W
05D68:  SUBLW  23
05D6A:  BTFSC  FD8.0
05D6C:  BRA    5D74
05D6E:  MOVLB  0
05D70:  GOTO   5DAA
05D74:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
05D76:  MOVFF  305,3C7
05D7A:  MOVFF  304,3C6
05D7E:  MOVFF  303,3C5
05D82:  MOVFF  302,3C4
05D86:  MOVFF  384,3CB
05D8A:  MOVFF  383,3CA
05D8E:  MOVFF  382,3C9
05D92:  MOVFF  381,3C8
05D96:  CALL   3DD2
05D9A:  MOVLW  01
05D9C:  MOVLB  3
05D9E:  ADDWF  x83,F
05DA0:  MOVLW  00
05DA2:  ADDWFC x84,F
05DA4:  MOVLB  0
05DA6:  GOTO   5D3C
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05DAA:  MOVFF  380,3D1
05DAE:  MOVLW  02
05DB0:  MOVLB  3
05DB2:  MOVWF  xD2
05DB4:  MOVLB  0
05DB6:  CALL   35F0
....................    printf("End SMF Erase All\r\n");
05DBA:  MOVLW  00
05DBC:  MOVWF  FF6
05DBE:  MOVLW  1A
05DC0:  MOVWF  FF7
05DC2:  MOVLW  00
05DC4:  MOVWF  FF8
05DC6:  CALL   1C14
05DCA:  GOTO   88FE (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
05772:  MOVLW  14
05774:  MOVWF  FF6
05776:  MOVLW  1A
05778:  MOVWF  FF7
0577A:  MOVLW  00
0577C:  MOVWF  FF8
0577E:  CALL   1C14
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05782:  MOVLB  3
05784:  MOVF   x7E,W
05786:  MOVWF  FE9
05788:  MOVF   x7F,W
0578A:  MOVWF  FEA
0578C:  MOVFF  FEF,3C4
05790:  MOVFF  3C4,3D1
05794:  MOVLW  01
05796:  MOVWF  xD2
05798:  MOVLB  0
0579A:  CALL   35F0
....................    int8 writedata[PACKET_SIZE] = {0x00}; // Initialize write data to zero
0579E:  MOVLB  3
057A0:  CLRF   x80
057A2:  CLRF   x81
057A4:  CLRF   x82
057A6:  CLRF   x83
057A8:  CLRF   x84
057AA:  CLRF   x85
057AC:  CLRF   x86
057AE:  CLRF   x87
057B0:  CLRF   x88
057B2:  CLRF   x89
057B4:  CLRF   x8A
057B6:  CLRF   x8B
057B8:  CLRF   x8C
057BA:  CLRF   x8D
057BC:  CLRF   x8E
057BE:  CLRF   x8F
057C0:  CLRF   x90
057C2:  CLRF   x91
057C4:  CLRF   x92
057C6:  CLRF   x93
057C8:  CLRF   x94
057CA:  CLRF   x95
057CC:  CLRF   x96
057CE:  CLRF   x97
057D0:  CLRF   x98
057D2:  CLRF   x99
057D4:  CLRF   x9A
057D6:  CLRF   x9B
057D8:  CLRF   x9C
057DA:  CLRF   x9D
057DC:  CLRF   x9E
057DE:  CLRF   x9F
057E0:  CLRF   xA0
057E2:  CLRF   xA1
057E4:  CLRF   xA2
057E6:  CLRF   xA3
057E8:  CLRF   xA4
057EA:  CLRF   xA5
057EC:  CLRF   xA6
057EE:  CLRF   xA7
057F0:  CLRF   xA8
057F2:  CLRF   xA9
057F4:  CLRF   xAA
057F6:  CLRF   xAB
057F8:  CLRF   xAC
057FA:  CLRF   xAD
057FC:  CLRF   xAE
057FE:  CLRF   xAF
05800:  CLRF   xB0
05802:  CLRF   xB1
05804:  CLRF   xB2
05806:  CLRF   xB3
05808:  CLRF   xB4
0580A:  CLRF   xB5
0580C:  CLRF   xB6
0580E:  CLRF   xB7
05810:  CLRF   xB8
05812:  CLRF   xB9
05814:  CLRF   xBA
05816:  CLRF   xBB
05818:  CLRF   xBC
0581A:  CLRF   xBD
0581C:  CLRF   xBE
0581E:  CLRF   xBF
....................    
....................    // 統合管理システムから初期化処理
....................    //init_misf_smf_manager(parameter[0], 0x04EC0000, 0x056BFFFF - 0x04EC0000, 0x04EC0000, PACKET_SIZE);
....................    
....................    for (int32 address = 0x04EC0000; address < 0x056BFFFF; address += SECTOR_64K_BYTE) {
05820:  MOVLW  04
05822:  MOVWF  xC3
05824:  MOVLW  EC
05826:  MOVWF  xC2
05828:  CLRF   xC1
0582A:  CLRF   xC0
0582C:  MOVLB  0
0582E:  MOVLB  3
05830:  MOVF   xC3,W
05832:  SUBLW  05
05834:  BTFSC  FD8.0
05836:  BRA    583E
05838:  MOVLB  0
0583A:  GOTO   58BC
0583E:  MOVLB  0
05840:  BTFSS  FD8.2
05842:  GOTO   5888
05846:  MOVLB  3
05848:  MOVF   xC2,W
0584A:  SUBLW  6B
0584C:  BTFSC  FD8.0
0584E:  BRA    5856
05850:  MOVLB  0
05852:  GOTO   58BC
05856:  MOVLB  0
05858:  BTFSS  FD8.2
0585A:  GOTO   5888
0585E:  MOVLB  3
05860:  MOVF   xC1,W
05862:  SUBLW  FF
05864:  BTFSC  FD8.0
05866:  BRA    586E
05868:  MOVLB  0
0586A:  GOTO   58BC
0586E:  MOVLB  0
05870:  BTFSS  FD8.2
05872:  GOTO   5888
05876:  MOVLB  3
05878:  MOVF   xC0,W
0587A:  SUBLW  FE
0587C:  BTFSC  FD8.0
0587E:  BRA    5886
05880:  MOVLB  0
05882:  GOTO   58BC
05886:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
05888:  MOVFF  305,3C7
0588C:  MOVFF  304,3C6
05890:  MOVFF  303,3C5
05894:  MOVFF  302,3C4
05898:  MOVFF  3C3,3CB
0589C:  MOVFF  3C2,3CA
058A0:  MOVFF  3C1,3C9
058A4:  MOVFF  3C0,3C8
058A8:  CALL   3DD2
058AC:  MOVLW  01
058AE:  MOVLB  3
058B0:  ADDWF  xC2,F
058B2:  MOVLW  00
058B4:  ADDWFC xC3,F
058B6:  MOVLB  0
058B8:  GOTO   582E
....................    }
.................... 
....................    write_data_bytes(smf, 0x04EC0000, writedata, PACKET_SIZE);
058BC:  MOVFF  305,C56
058C0:  MOVFF  304,C55
058C4:  MOVFF  303,C54
058C8:  MOVFF  302,C53
058CC:  MOVLW  04
058CE:  MOVLB  C
058D0:  MOVWF  x5A
058D2:  MOVLW  EC
058D4:  MOVWF  x59
058D6:  CLRF   x58
058D8:  CLRF   x57
058DA:  MOVLW  03
058DC:  MOVWF  x5C
058DE:  MOVLW  80
058E0:  MOVWF  x5B
058E2:  CLRF   x5E
058E4:  MOVLW  40
058E6:  MOVWF  x5D
058E8:  MOVLB  0
058EA:  CALL   3170
....................    smf_init(); // Update the address area after writing
058EE:  GOTO   576E
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
058F2:  MOVLB  3
058F4:  MOVF   x7E,W
058F6:  MOVWF  FE9
058F8:  MOVF   x7F,W
058FA:  MOVWF  FEA
058FC:  MOVFF  FEF,3C4
05900:  MOVFF  3C4,3D1
05904:  MOVLW  02
05906:  MOVWF  xD2
05908:  MOVLB  0
0590A:  CALL   35F0
....................    printf("End SMF Reset\r\n");
0590E:  MOVLW  26
05910:  MOVWF  FF6
05912:  MOVLW  1A
05914:  MOVWF  FF7
05916:  MOVLW  00
05918:  MOVWF  FF8
0591A:  CALL   1C14
0591E:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
08B32:  CLRF   FF8
08B34:  BCF    FD0.7
08B36:  BSF    07.7
08B38:  MOVLB  E
08B3A:  MOVLW  55
08B3C:  MOVWF  F7E
08B3E:  MOVLW  AA
08B40:  MOVWF  F7E
08B42:  BCF    F66.6
08B44:  MOVLW  F9
08B46:  MOVWF  x2C
08B48:  MOVLW  0F
08B4A:  MOVWF  x2E
08B4C:  MOVLW  40
08B4E:  MOVWF  x12
08B50:  MOVLW  30
08B52:  MOVWF  x13
08B54:  MOVLW  20
08B56:  MOVWF  x22
08B58:  MOVLW  55
08B5A:  MOVWF  F7E
08B5C:  MOVLW  AA
08B5E:  MOVWF  F7E
08B60:  BSF    F66.6
08B62:  CLRF   F9B
08B64:  CLRF   F64
08B66:  CLRF   F65
08B68:  CLRF   F66
08B6A:  MOVLW  02
08B6C:  MOVWF  FD3
08B6E:  CLRF   1B
08B70:  MOVLB  F
08B72:  BSF    x2D.3
08B74:  MOVLW  A0
08B76:  MOVWF  x2B
08B78:  MOVLW  01
08B7A:  MOVWF  x2C
08B7C:  MOVLW  A6
08B7E:  MOVWF  x2E
08B80:  MOVLW  90
08B82:  MOVWF  x2F
08B84:  BCF    F93.6
08B86:  BSF    F8A.6
08B88:  BSF    F92.1
08B8A:  BCF    F92.0
08B8C:  BCF    F92.3
08B8E:  BCF    F89.3
08B90:  BSF    F96.0
08B92:  BCF    F96.6
08B94:  BCF    F96.1
08B96:  BCF    F8D.1
08B98:  BSF    F93.4
08B9A:  BCF    F93.5
08B9C:  BCF    F93.2
08B9E:  BCF    F8A.2
08BA0:  CLRF   1F
08BA2:  CLRF   1E
08BA4:  CLRF   1D
08BA6:  CLRF   1C
08BA8:  CLRF   23
08BAA:  CLRF   22
08BAC:  CLRF   21
08BAE:  CLRF   20
08BB0:  CLRF   25
08BB2:  CLRF   24
08BB4:  CLRF   46
08BB6:  BCF    47.0
08BB8:  MOVLB  3
08BBA:  CLRF   x38
08BBC:  MOVLW  1E
08BBE:  MOVWF  x3D
08BC0:  CLRF   x3F
08BC2:  CLRF   x3E
08BC4:  MOVLB  E
08BC6:  CLRF   xD9
08BC8:  CLRF   xDA
08BCA:  CLRF   xCE
08BCC:  CLRF   xCF
08BCE:  CLRF   xD0
08BD0:  CLRF   xD1
08BD2:  CLRF   xD2
08BD4:  CLRF   xD3
08BD6:  CLRF   xD4
08BD8:  CLRF   xD5
08BDA:  CLRF   x45
08BDC:  CLRF   x46
08BDE:  CLRF   x47
08BE0:  BCF    x8D.7
08BE2:  BCF    x8D.6
08BE4:  BCF    x8D.5
08BE6:  MOVLB  F
08BE8:  CLRF   x53
08BEA:  CLRF   x38
08BEC:  CLRF   x37
08BEE:  MOVLB  0
08BF0:  CLRF   26
08BF2:  CLRF   27
08BF4:  CLRF   28
08BF6:  CLRF   29
08BF8:  CLRF   2A
08BFA:  CLRF   2B
08BFC:  CLRF   2C
08BFE:  CLRF   2D
08C00:  CLRF   2E
08C02:  CLRF   2F
08C04:  CLRF   30
08C06:  CLRF   31
08C08:  CLRF   32
08C0A:  CLRF   33
08C0C:  CLRF   34
08C0E:  CLRF   35
08C10:  CLRF   36
08C12:  CLRF   37
08C14:  CLRF   38
08C16:  CLRF   39
08C18:  CLRF   3A
08C1A:  CLRF   3B
08C1C:  CLRF   3C
08C1E:  CLRF   3D
08C20:  CLRF   3E
08C22:  CLRF   3F
08C24:  CLRF   40
08C26:  CLRF   41
08C28:  CLRF   42
08C2A:  CLRF   43
08C2C:  CLRF   44
08C2E:  CLRF   45
08C30:  MOVLW  03
08C32:  MOVWF  48
08C34:  CLRF   49
08C36:  CLRF   4A
08C38:  CLRF   4B
08C3A:  CLRF   4C
08C3C:  CLRF   4D
08C3E:  CLRF   4E
08C40:  CLRF   4F
08C42:  CLRF   50
08C44:  CLRF   51
08C46:  CLRF   52
08C48:  CLRF   53
08C4A:  CLRF   54
08C4C:  CLRF   55
08C4E:  CLRF   56
08C50:  CLRF   57
08C52:  CLRF   58
08C54:  CLRF   59
08C56:  CLRF   5A
08C58:  CLRF   5B
08C5A:  CLRF   5C
08C5C:  CLRF   5D
08C5E:  CLRF   5E
08C60:  CLRF   5F
08C62:  CLRF   x60
08C64:  CLRF   x61
08C66:  CLRF   x62
08C68:  CLRF   x63
08C6A:  CLRF   x64
08C6C:  CLRF   x65
08C6E:  CLRF   x66
08C70:  CLRF   x67
08C72:  CLRF   x68
08C74:  CLRF   x69
08C76:  CLRF   x6A
08C78:  CLRF   x6B
08C7A:  CLRF   x6C
08C7C:  CLRF   x6D
08C7E:  CLRF   x6E
08C80:  CLRF   x6F
08C82:  CLRF   x70
08C84:  CLRF   x71
08C86:  CLRF   x72
08C88:  CLRF   x73
08C8A:  CLRF   x74
08C8C:  CLRF   x75
08C8E:  CLRF   x76
08C90:  CLRF   x77
08C92:  CLRF   x78
08C94:  CLRF   x79
08C96:  CLRF   x7A
08C98:  CLRF   x7B
08C9A:  CLRF   x7C
08C9C:  CLRF   x7D
08C9E:  CLRF   x7E
08CA0:  CLRF   x7F
08CA2:  CLRF   x80
08CA4:  CLRF   x81
08CA6:  CLRF   x82
08CA8:  CLRF   x83
08CAA:  CLRF   x84
08CAC:  CLRF   x85
08CAE:  CLRF   x86
08CB0:  CLRF   x87
08CB2:  CLRF   x88
08CB4:  CLRF   x89
08CB6:  CLRF   x8A
08CB8:  CLRF   x8B
08CBA:  CLRF   x8C
08CBC:  CLRF   x8D
08CBE:  CLRF   x8E
08CC0:  CLRF   x8F
08CC2:  CLRF   x90
08CC4:  CLRF   x91
08CC6:  CLRF   x92
08CC8:  CLRF   x93
08CCA:  CLRF   x94
08CCC:  CLRF   x95
08CCE:  CLRF   x96
08CD0:  CLRF   x97
08CD2:  CLRF   x98
08CD4:  CLRF   x99
08CD6:  CLRF   x9A
08CD8:  CLRF   x9B
08CDA:  CLRF   x9C
08CDC:  CLRF   x9D
08CDE:  CLRF   x9E
08CE0:  CLRF   x9F
08CE2:  CLRF   xA0
08CE4:  CLRF   xA1
08CE6:  CLRF   xA2
08CE8:  CLRF   xA3
08CEA:  CLRF   xA4
08CEC:  CLRF   xA5
08CEE:  CLRF   xA6
08CF0:  CLRF   xA7
08CF2:  CLRF   xA8
08CF4:  CLRF   xA9
08CF6:  CLRF   xAA
08CF8:  CLRF   xAB
08CFA:  CLRF   xAC
08CFC:  CLRF   xAD
08CFE:  CLRF   xAE
08D00:  CLRF   xAF
08D02:  CLRF   xB0
08D04:  CLRF   xB1
08D06:  CLRF   xB2
08D08:  CLRF   xB3
08D0A:  CLRF   xB4
08D0C:  CLRF   xB5
08D0E:  CLRF   xB6
08D10:  CLRF   xB7
08D12:  CLRF   xB8
08D14:  CLRF   xB9
08D16:  CLRF   xBA
08D18:  CLRF   xBB
08D1A:  CLRF   xBC
08D1C:  CLRF   xBD
08D1E:  CLRF   xBE
08D20:  CLRF   xBF
08D22:  CLRF   xC0
08D24:  CLRF   xC1
08D26:  CLRF   xC2
08D28:  CLRF   xC3
08D2A:  CLRF   xC4
08D2C:  CLRF   xC5
08D2E:  CLRF   xC6
08D30:  CLRF   xC7
08D32:  CLRF   xC8
08D34:  CLRF   xC9
08D36:  CLRF   xCA
08D38:  CLRF   xCB
08D3A:  CLRF   xCC
08D3C:  CLRF   xCD
08D3E:  CLRF   xCE
08D40:  CLRF   xCF
08D42:  CLRF   xD0
08D44:  CLRF   xD1
08D46:  CLRF   xD2
08D48:  CLRF   xD3
08D4A:  CLRF   xD4
08D4C:  CLRF   xD5
08D4E:  CLRF   xD6
08D50:  CLRF   xD7
08D52:  CLRF   xD8
08D54:  CLRF   xD9
08D56:  CLRF   xDA
08D58:  CLRF   xDB
08D5A:  CLRF   xDC
08D5C:  CLRF   xDD
08D5E:  CLRF   xDE
08D60:  CLRF   xDF
08D62:  CLRF   xE0
08D64:  CLRF   xE1
08D66:  CLRF   xE2
08D68:  CLRF   xE3
08D6A:  CLRF   xE4
08D6C:  CLRF   xE5
08D6E:  CLRF   xE6
08D70:  CLRF   xE7
08D72:  CLRF   xE8
08D74:  CLRF   xE9
08D76:  CLRF   xEA
08D78:  CLRF   xEB
08D7A:  CLRF   xEC
08D7C:  CLRF   xED
08D7E:  CLRF   xEE
08D80:  CLRF   xEF
08D82:  CLRF   xF0
08D84:  CLRF   xF1
08D86:  CLRF   xF2
08D88:  CLRF   xF3
08D8A:  CLRF   xF4
08D8C:  CLRF   xF5
08D8E:  CLRF   xF6
08D90:  CLRF   xF7
08D92:  CLRF   xF8
08D94:  CLRF   xF9
08D96:  CLRF   xFA
08D98:  CLRF   xFB
08D9A:  CLRF   xFC
08D9C:  CLRF   xFD
08D9E:  CLRF   xFE
08DA0:  CLRF   xFF
08DA2:  MOVLB  1
08DA4:  CLRF   x00
08DA6:  CLRF   x01
08DA8:  CLRF   x02
08DAA:  CLRF   x03
08DAC:  CLRF   x04
08DAE:  CLRF   x05
08DB0:  CLRF   x06
08DB2:  CLRF   x07
08DB4:  CLRF   x08
08DB6:  CLRF   x09
08DB8:  CLRF   x0A
08DBA:  CLRF   x0B
08DBC:  CLRF   x0C
08DBE:  CLRF   x0D
08DC0:  CLRF   x0E
08DC2:  CLRF   x0F
08DC4:  CLRF   x10
08DC6:  CLRF   x11
08DC8:  CLRF   x12
08DCA:  CLRF   x13
08DCC:  CLRF   x14
08DCE:  CLRF   x15
08DD0:  CLRF   x16
08DD2:  CLRF   x17
08DD4:  CLRF   x18
08DD6:  CLRF   x19
08DD8:  CLRF   x1A
08DDA:  CLRF   x1B
08DDC:  CLRF   x1C
08DDE:  CLRF   x1D
08DE0:  CLRF   x1E
08DE2:  CLRF   x1F
08DE4:  CLRF   x20
08DE6:  CLRF   x21
08DE8:  CLRF   x22
08DEA:  CLRF   x23
08DEC:  CLRF   x24
08DEE:  CLRF   x25
08DF0:  CLRF   x26
08DF2:  CLRF   x27
08DF4:  CLRF   x28
08DF6:  CLRF   x29
08DF8:  CLRF   x2A
08DFA:  CLRF   x2B
08DFC:  CLRF   x2C
08DFE:  CLRF   x2D
08E00:  CLRF   x2E
08E02:  CLRF   x2F
08E04:  CLRF   x30
08E06:  CLRF   x31
08E08:  CLRF   x32
08E0A:  CLRF   x33
08E0C:  CLRF   x34
08E0E:  CLRF   x35
08E10:  CLRF   x36
08E12:  CLRF   x37
08E14:  CLRF   x38
08E16:  CLRF   x39
08E18:  CLRF   x3A
08E1A:  CLRF   x3B
08E1C:  CLRF   x3C
08E1E:  CLRF   x3D
08E20:  CLRF   x3E
08E22:  CLRF   x3F
08E24:  CLRF   x40
08E26:  CLRF   x41
08E28:  CLRF   x42
08E2A:  CLRF   x43
08E2C:  CLRF   x44
08E2E:  CLRF   x45
08E30:  CLRF   x46
08E32:  CLRF   x47
08E34:  CLRF   x48
08E36:  CLRF   x49
08E38:  CLRF   x4A
08E3A:  CLRF   x4B
08E3C:  CLRF   x4C
08E3E:  CLRF   x4D
08E40:  CLRF   x4E
08E42:  CLRF   x4F
08E44:  CLRF   x50
08E46:  CLRF   x51
08E48:  CLRF   x52
08E4A:  CLRF   x53
08E4C:  CLRF   x54
08E4E:  CLRF   x55
08E50:  CLRF   x56
08E52:  CLRF   x57
08E54:  CLRF   x58
08E56:  CLRF   x59
08E58:  CLRF   x5A
08E5A:  CLRF   x5B
08E5C:  CLRF   x5C
08E5E:  CLRF   x5D
08E60:  CLRF   x5E
08E62:  CLRF   x5F
08E64:  CLRF   x60
08E66:  CLRF   x61
08E68:  CLRF   x62
08E6A:  CLRF   x63
08E6C:  CLRF   x64
08E6E:  CLRF   x65
08E70:  CLRF   x66
08E72:  CLRF   x67
08E74:  CLRF   x68
08E76:  CLRF   x69
08E78:  CLRF   x6A
08E7A:  CLRF   x6B
08E7C:  CLRF   x6C
08E7E:  CLRF   x6D
08E80:  CLRF   x6E
08E82:  CLRF   x6F
08E84:  CLRF   x70
08E86:  CLRF   x71
08E88:  CLRF   x72
08E8A:  CLRF   x73
08E8C:  CLRF   x74
08E8E:  CLRF   x75
08E90:  CLRF   x76
08E92:  CLRF   x77
08E94:  CLRF   x78
08E96:  CLRF   x79
08E98:  CLRF   x7A
08E9A:  CLRF   x7B
08E9C:  CLRF   x7C
08E9E:  CLRF   x7D
08EA0:  CLRF   x7E
08EA2:  CLRF   x7F
08EA4:  CLRF   x80
08EA6:  CLRF   x81
08EA8:  CLRF   x82
08EAA:  CLRF   x83
08EAC:  CLRF   x84
08EAE:  CLRF   x85
08EB0:  CLRF   x86
08EB2:  CLRF   x87
08EB4:  CLRF   x88
08EB6:  CLRF   x89
08EB8:  CLRF   x8A
08EBA:  CLRF   x8B
08EBC:  CLRF   x8C
08EBE:  CLRF   x8D
08EC0:  CLRF   x8E
08EC2:  CLRF   x8F
08EC4:  CLRF   x90
08EC6:  CLRF   x91
08EC8:  CLRF   x92
08ECA:  CLRF   x93
08ECC:  CLRF   x94
08ECE:  CLRF   x95
08ED0:  CLRF   x96
08ED2:  CLRF   x97
08ED4:  CLRF   x98
08ED6:  CLRF   x99
08ED8:  CLRF   x9A
08EDA:  CLRF   x9B
08EDC:  CLRF   x9C
08EDE:  CLRF   x9D
08EE0:  CLRF   x9E
08EE2:  CLRF   x9F
08EE4:  CLRF   xA0
08EE6:  CLRF   xA1
08EE8:  CLRF   xA2
08EEA:  CLRF   xA3
08EEC:  CLRF   xA4
08EEE:  CLRF   xA5
08EF0:  CLRF   xA6
08EF2:  CLRF   xA7
08EF4:  CLRF   xA8
08EF6:  CLRF   xA9
08EF8:  CLRF   xAA
08EFA:  CLRF   xAB
08EFC:  CLRF   xAC
08EFE:  CLRF   xAD
08F00:  CLRF   xAE
08F02:  CLRF   xAF
08F04:  CLRF   xB0
08F06:  CLRF   xB1
08F08:  CLRF   xB2
08F0A:  CLRF   xB3
08F0C:  CLRF   xB4
08F0E:  CLRF   xB5
08F10:  CLRF   xB6
08F12:  CLRF   xB7
08F14:  CLRF   xB8
08F16:  CLRF   xB9
08F18:  CLRF   xBA
08F1A:  CLRF   xBB
08F1C:  CLRF   xBC
08F1E:  CLRF   xBD
08F20:  CLRF   xBE
08F22:  CLRF   xBF
08F24:  CLRF   xC0
08F26:  CLRF   xC1
08F28:  CLRF   xC2
08F2A:  CLRF   xC3
08F2C:  CLRF   xC4
08F2E:  CLRF   xC5
08F30:  CLRF   xC6
08F32:  CLRF   xC7
08F34:  CLRF   xC8
08F36:  CLRF   xC9
08F38:  CLRF   xCA
08F3A:  CLRF   xCB
08F3C:  CLRF   xCC
08F3E:  CLRF   xCD
08F40:  CLRF   xCE
08F42:  CLRF   xCF
08F44:  CLRF   xD0
08F46:  CLRF   xD1
08F48:  CLRF   xD2
08F4A:  CLRF   xD3
08F4C:  CLRF   xD4
08F4E:  CLRF   xD5
08F50:  CLRF   xD6
08F52:  CLRF   xD7
08F54:  CLRF   xD8
08F56:  CLRF   xD9
08F58:  CLRF   xDA
08F5A:  CLRF   xDB
08F5C:  CLRF   xDC
08F5E:  CLRF   xDD
08F60:  CLRF   xDE
08F62:  CLRF   xDF
08F64:  CLRF   xE0
08F66:  CLRF   xE1
08F68:  CLRF   xE2
08F6A:  CLRF   xE3
08F6C:  CLRF   xE4
08F6E:  CLRF   xE5
08F70:  CLRF   xE6
08F72:  CLRF   xE7
08F74:  CLRF   xE8
08F76:  CLRF   xE9
08F78:  CLRF   xEA
08F7A:  CLRF   xEB
08F7C:  CLRF   xEC
08F7E:  CLRF   xED
08F80:  CLRF   xEE
08F82:  CLRF   xEF
08F84:  CLRF   xF0
08F86:  CLRF   xF1
08F88:  CLRF   xF2
08F8A:  CLRF   xF3
08F8C:  CLRF   xF4
08F8E:  CLRF   xF5
08F90:  CLRF   xF6
08F92:  CLRF   xF7
08F94:  CLRF   xF8
08F96:  CLRF   xF9
08F98:  CLRF   xFA
08F9A:  CLRF   xFB
08F9C:  CLRF   xFC
08F9E:  CLRF   xFD
08FA0:  CLRF   xFE
08FA2:  CLRF   xFF
08FA4:  MOVLB  2
08FA6:  CLRF   x00
08FA8:  CLRF   x01
08FAA:  CLRF   x02
08FAC:  CLRF   x03
08FAE:  CLRF   x04
08FB0:  CLRF   x05
08FB2:  CLRF   x06
08FB4:  CLRF   x07
08FB6:  CLRF   x08
08FB8:  CLRF   x09
08FBA:  CLRF   x0A
08FBC:  CLRF   x0B
08FBE:  CLRF   x0C
08FC0:  CLRF   x0D
08FC2:  CLRF   x0E
08FC4:  CLRF   x0F
08FC6:  CLRF   x10
08FC8:  CLRF   x11
08FCA:  CLRF   x12
08FCC:  CLRF   x13
08FCE:  CLRF   x14
08FD0:  CLRF   x15
08FD2:  CLRF   x16
08FD4:  CLRF   x17
08FD6:  CLRF   x18
08FD8:  CLRF   x19
08FDA:  CLRF   x1A
08FDC:  CLRF   x1B
08FDE:  CLRF   x1C
08FE0:  CLRF   x1D
08FE2:  CLRF   x1E
08FE4:  CLRF   x1F
08FE6:  CLRF   x20
08FE8:  CLRF   x21
08FEA:  CLRF   x22
08FEC:  CLRF   x23
08FEE:  CLRF   x24
08FF0:  CLRF   x25
08FF2:  CLRF   x26
08FF4:  CLRF   x27
08FF6:  CLRF   x28
08FF8:  CLRF   x29
08FFA:  CLRF   x2A
08FFC:  CLRF   x2B
08FFE:  CLRF   x2C
09000:  CLRF   x2D
09002:  CLRF   x2E
09004:  CLRF   x2F
09006:  CLRF   x30
09008:  CLRF   x31
0900A:  CLRF   x32
0900C:  CLRF   x33
0900E:  CLRF   x34
09010:  CLRF   x35
09012:  CLRF   x36
09014:  CLRF   x37
09016:  CLRF   x38
09018:  CLRF   x39
0901A:  CLRF   x3A
0901C:  CLRF   x3B
0901E:  CLRF   x3C
09020:  CLRF   x3D
09022:  CLRF   x3E
09024:  CLRF   x3F
09026:  CLRF   x40
09028:  CLRF   x41
0902A:  CLRF   x42
0902C:  CLRF   x43
0902E:  CLRF   x44
09030:  CLRF   x45
09032:  CLRF   x46
09034:  CLRF   x47
09036:  CLRF   x48
09038:  CLRF   x49
0903A:  CLRF   x4A
0903C:  CLRF   x4B
0903E:  CLRF   x4C
09040:  CLRF   x4D
09042:  CLRF   x4E
09044:  CLRF   x4F
09046:  CLRF   x50
09048:  CLRF   x51
0904A:  CLRF   x52
0904C:  CLRF   x53
0904E:  CLRF   x54
09050:  CLRF   x55
09052:  CLRF   x56
09054:  CLRF   x57
09056:  CLRF   x58
09058:  CLRF   x59
0905A:  CLRF   x5A
0905C:  CLRF   x5B
0905E:  CLRF   x5C
09060:  CLRF   x5D
09062:  CLRF   x5E
09064:  CLRF   x5F
09066:  CLRF   x60
09068:  CLRF   x61
0906A:  CLRF   x62
0906C:  CLRF   x63
0906E:  CLRF   x64
09070:  CLRF   x65
09072:  CLRF   x66
09074:  CLRF   x67
09076:  CLRF   x68
09078:  CLRF   x69
0907A:  CLRF   x6A
0907C:  CLRF   x6B
0907E:  CLRF   x6C
09080:  CLRF   x6D
09082:  CLRF   x6E
09084:  CLRF   x6F
09086:  CLRF   x70
09088:  CLRF   x71
0908A:  CLRF   x72
0908C:  CLRF   x73
0908E:  CLRF   x74
09090:  CLRF   x75
09092:  CLRF   x76
09094:  CLRF   x77
09096:  CLRF   x78
09098:  CLRF   x79
0909A:  CLRF   x7A
0909C:  CLRF   x7B
0909E:  CLRF   x7C
090A0:  CLRF   x7D
090A2:  CLRF   x7E
090A4:  CLRF   x7F
090A6:  CLRF   x80
090A8:  CLRF   x81
090AA:  CLRF   x82
090AC:  CLRF   x83
090AE:  CLRF   x84
090B0:  CLRF   x85
090B2:  CLRF   x86
090B4:  CLRF   x87
090B6:  CLRF   x88
090B8:  CLRF   x89
090BA:  CLRF   x8A
090BC:  CLRF   x8B
090BE:  CLRF   x8C
090C0:  CLRF   x8D
090C2:  CLRF   x8E
090C4:  CLRF   x8F
090C6:  CLRF   x90
090C8:  CLRF   x91
090CA:  CLRF   x92
090CC:  CLRF   x93
090CE:  CLRF   x94
090D0:  CLRF   x95
090D2:  CLRF   x96
090D4:  CLRF   x97
090D6:  CLRF   x98
090D8:  CLRF   x99
090DA:  CLRF   x9A
090DC:  CLRF   x9B
090DE:  CLRF   x9C
090E0:  CLRF   x9D
090E2:  CLRF   x9E
090E4:  CLRF   x9F
090E6:  CLRF   xA0
090E8:  CLRF   xA1
090EA:  CLRF   xA2
090EC:  CLRF   xA3
090EE:  CLRF   xA4
090F0:  CLRF   xA5
090F2:  CLRF   xA6
090F4:  CLRF   xA7
090F6:  CLRF   xA8
090F8:  CLRF   xA9
090FA:  CLRF   xAA
090FC:  CLRF   xAB
090FE:  CLRF   xAC
09100:  CLRF   xAD
09102:  CLRF   xAE
09104:  CLRF   xAF
09106:  CLRF   xB0
09108:  CLRF   xB1
0910A:  CLRF   xB2
0910C:  CLRF   xB3
0910E:  CLRF   xB4
09110:  CLRF   xB5
09112:  CLRF   xB6
09114:  CLRF   xB7
09116:  CLRF   xB8
09118:  CLRF   xB9
0911A:  CLRF   xBA
0911C:  CLRF   xBB
0911E:  CLRF   xBC
09120:  CLRF   xBD
09122:  CLRF   xBE
09124:  CLRF   xBF
09126:  CLRF   xC0
09128:  CLRF   xC1
0912A:  CLRF   xC2
0912C:  CLRF   xC3
0912E:  CLRF   xC4
09130:  CLRF   xC5
09132:  CLRF   xC6
09134:  CLRF   xC7
09136:  CLRF   xC8
09138:  CLRF   xC9
0913A:  CLRF   xCA
0913C:  CLRF   xCB
0913E:  CLRF   xCC
09140:  CLRF   xCD
09142:  CLRF   xCE
09144:  CLRF   xCF
09146:  CLRF   xD0
09148:  CLRF   xD1
0914A:  CLRF   xD2
0914C:  CLRF   xD3
0914E:  CLRF   xD4
09150:  CLRF   xD5
09152:  CLRF   xD6
09154:  CLRF   xD7
09156:  CLRF   xD8
09158:  CLRF   xD9
0915A:  CLRF   xDA
0915C:  CLRF   xDB
0915E:  CLRF   xDC
09160:  CLRF   xDD
09162:  CLRF   xDE
09164:  CLRF   xDF
09166:  CLRF   xE0
09168:  CLRF   xE1
0916A:  CLRF   xE2
0916C:  CLRF   xE3
0916E:  CLRF   xE4
09170:  CLRF   xE5
09172:  CLRF   xE6
09174:  CLRF   xE7
09176:  CLRF   xE8
09178:  CLRF   xE9
0917A:  CLRF   xEA
0917C:  CLRF   xEB
0917E:  CLRF   xEC
09180:  CLRF   xED
09182:  CLRF   xEE
09184:  CLRF   xEF
09186:  CLRF   xF0
09188:  CLRF   xF1
0918A:  CLRF   xF2
0918C:  CLRF   xF3
0918E:  CLRF   xF4
09190:  CLRF   xF5
09192:  CLRF   xF6
09194:  CLRF   xF7
09196:  CLRF   xF8
09198:  CLRF   xF9
0919A:  CLRF   xFA
0919C:  CLRF   xFB
0919E:  CLRF   xFC
091A0:  CLRF   xFD
091A2:  CLRF   xFE
091A4:  CLRF   xFF
091A6:  MOVLW  05
091A8:  MOVLB  3
091AA:  MOVWF  x00
091AC:  MOVLW  7C
091AE:  MOVWF  x01
091B0:  MOVLW  01
091B2:  MOVWF  x02
091B4:  MOVLW  01
091B6:  MOVWF  x03
091B8:  MOVLW  02
091BA:  MOVWF  x04
091BC:  MOVLW  7C
091BE:  MOVWF  x05
091C0:  CLRF   x06
091C2:  MOVLW  09
091C4:  MOVWF  x07
091C6:  MOVLW  01
091C8:  MOVWF  x08
091CA:  CLRF   x09
091CC:  MOVLW  02
091CE:  MOVWF  x0A
091D0:  MOVLW  01
091D2:  MOVWF  x0B
091D4:  CLRF   x39
091D6:  CLRF   x3A
091D8:  CLRF   x3B
091DA:  CLRF   x3C
091DC:  CLRF   x40
091DE:  CLRF   x41
091E0:  CLRF   x42
091E2:  CLRF   x43
091E4:  CLRF   x44
091E6:  CLRF   x45
091E8:  CLRF   x46
091EA:  CLRF   x47
091EC:  CLRF   x48
091EE:  CLRF   x49
091F0:  CLRF   x4A
091F2:  CLRF   x4B
091F4:  CLRF   x4C
091F6:  CLRF   x4D
091F8:  CLRF   x4E
091FA:  CLRF   x4F
091FC:  CLRF   x50
091FE:  CLRF   x51
09200:  CLRF   x52
09202:  CLRF   x53
09204:  CLRF   x54
09206:  CLRF   x55
09208:  CLRF   x56
0920A:  CLRF   x57
0920C:  CLRF   x58
0920E:  CLRF   x59
09210:  CLRF   x5A
09212:  CLRF   x5B
09214:  CLRF   x5C
09216:  CLRF   x5D
09218:  CLRF   x5E
0921A:  CLRF   x5F
0921C:  CLRF   x60
0921E:  CLRF   x61
09220:  CLRF   x62
09222:  CLRF   x63
09224:  CLRF   x64
09226:  CLRF   x65
09228:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0922A:  MOVLW  64
0922C:  MOVLB  C
0922E:  MOVWF  x6B
09230:  MOVLB  0
09232:  CALL   1B94
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
09236:  MOVLW  36
09238:  MOVWF  FF6
0923A:  MOVLW  1A
0923C:  MOVWF  FF7
0923E:  MOVLW  00
09240:  MOVWF  FF8
09242:  CALL   1C14
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
09246:  MOVLW  7C
09248:  MOVWF  FF6
0924A:  MOVLW  1A
0924C:  MOVWF  FF7
0924E:  MOVLW  00
09250:  MOVWF  FF8
09252:  CALL   1C14
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
09256:  MOVLW  AA
09258:  MOVWF  FF6
0925A:  MOVLW  1A
0925C:  MOVWF  FF7
0925E:  MOVLW  00
09260:  MOVWF  FF8
09262:  MOVLW  10
09264:  MOVLB  B
09266:  MOVWF  xC1
09268:  MOVLB  0
0926A:  CALL   1C44
0926E:  MOVLW  D0
09270:  MOVWF  FF6
09272:  MOVLW  1A
09274:  MOVWF  FF7
09276:  MOVLW  00
09278:  MOVWF  FF8
0927A:  CALL   1C14
0927E:  MOVLW  20
09280:  MOVLB  C
09282:  MOVWF  x14
09284:  MOVLB  0
09286:  CALL   1BC2
0928A:  MOVLW  DA
0928C:  MOVWF  FF6
0928E:  MOVLW  1A
09290:  MOVWF  FF7
09292:  MOVLW  00
09294:  MOVWF  FF8
09296:  CALL   1C14
0929A:  MOVLW  BF
0929C:  MOVWF  FF6
0929E:  MOVLW  1A
092A0:  MOVWF  FF7
092A2:  MOVLW  00
092A4:  MOVWF  FF8
092A6:  MOVLW  0F
092A8:  MOVLB  B
092AA:  MOVWF  xC1
092AC:  MOVLB  0
092AE:  CALL   1C44
....................    
....................    io_init();
092B2:  GOTO   1C7A
....................    setup_uart_to_boss();
092B6:  GOTO   1CC8
....................    setup_timer();
092BA:  GOTO   1CF2
....................    ad7490_init();
092BE:  GOTO   1F08
....................    mcp4901_init();
092C2:  GOTO   21E6
....................    misf_init();
092C6:  CALL   2AAC
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
092CA:  MOVFF  338,3D1
092CE:  MOVLB  3
092D0:  CLRF   xD2
092D2:  MOVLB  0
092D4:  CALL   35F0
.................... 
....................    int1 is_finished = FALSE;
092D8:  MOVLB  3
092DA:  BCF    x68.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
092DC:  MOVLW  E4
092DE:  MOVWF  FF6
092E0:  MOVLW  1A
092E2:  MOVWF  FF7
092E4:  MOVLW  00
092E6:  MOVWF  FF8
092E8:  MOVLB  0
092EA:  CALL   1C14
....................    
....................    output_low(EN_NPWR);
092EE:  MOVLW  5E
092F0:  MOVWF  F94
092F2:  BCF    F8B.7
....................    
....................    
....................    fprintf(PC,"waiting for BOSS PIC command");
092F4:  MOVLW  0A
092F6:  MOVWF  FF6
092F8:  MOVLW  1B
092FA:  MOVWF  FF7
092FC:  MOVLW  00
092FE:  MOVWF  FF8
09300:  CALL   1C14
....................    
....................    //Start loop
....................    while(!is_finished)
09304:  MOVLB  3
09306:  BTFSS  x68.0
09308:  BRA    9310
0930A:  MOVLB  0
0930C:  GOTO   93DE
09310:  MOVLB  0
....................    {
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
09312:  MOVF   46,F
09314:  BTFSC  FD8.2
09316:  GOTO   939A
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0931A:  MOVLB  3
0931C:  CLRF   x7C
0931E:  MOVLW  26
09320:  MOVWF  x7B
09322:  MOVFF  46,37D
09326:  MOVLB  0
09328:  GOTO   3A04
0932C:  MOVFF  02,03
09330:  MOVF   01,W
09332:  MOVWF  FE1
09334:  MOVFF  03,FE2
09338:  MOVLW  03
0933A:  MOVWF  FEA
0933C:  MOVLW  69
0933E:  MOVWF  FE9
09340:  MOVLW  0C
09342:  MOVWF  01
09344:  MOVFF  FE6,FEE
09348:  DECFSZ 01,F
0934A:  GOTO   9344
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0934E:  MOVLB  3
09350:  CLRF   x76
09352:  MOVLW  26
09354:  MOVWF  x75
09356:  CLRF   x78
09358:  MOVLW  46
0935A:  MOVWF  x77
0935C:  MOVLB  0
0935E:  GOTO   3C24
....................          
....................          if(recieve_cmd.is_exist)
09362:  MOVLB  3
09364:  BTFSC  x6B.0
09366:  BRA    936E
09368:  MOVLB  0
0936A:  GOTO   938A
0936E:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
09370:  MOVLW  03
09372:  MOVLB  3
09374:  MOVWF  x76
09376:  MOVLW  69
09378:  MOVWF  x75
0937A:  MOVLB  0
0937C:  GOTO   8AB0
09380:  MOVLB  3
09382:  BCF    x68.1
09384:  BTFSC  01.0
09386:  BSF    x68.1
09388:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0938A:  MOVLW  28
0938C:  MOVWF  FF6
0938E:  MOVLW  1B
09390:  MOVWF  FF7
09392:  MOVLW  00
09394:  MOVWF  FF8
09396:  CALL   1C14
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0939A:  MOVLB  3
0939C:  BTFSC  x68.0
0939E:  BRA    93A6
093A0:  MOVLB  0
093A2:  GOTO   93AC
093A6:  MOVLB  0
....................          break;
093A8:  GOTO   93DE
....................          
....................       delay_ms(400);
093AC:  MOVLW  02
093AE:  MOVLB  3
093B0:  MOVWF  x75
093B2:  MOVLB  0
093B4:  MOVLW  C8
093B6:  MOVLB  C
093B8:  MOVWF  x6B
093BA:  MOVLB  0
093BC:  CALL   1B94
093C0:  MOVLB  3
093C2:  DECFSZ x75,F
093C4:  BRA    93CA
093C6:  BRA    93CE
093C8:  MOVLB  0
093CA:  MOVLB  0
093CC:  BRA    93B4
....................       fprintf(PC, ".");
093CE:  MOVLW  2E
093D0:  MOVLB  C
093D2:  MOVWF  x14
093D4:  MOVLB  0
093D6:  CALL   1BC2
093DA:  GOTO   9304
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
093DE:  MOVLW  48
093E0:  MOVWF  FF6
093E2:  MOVLW  1B
093E4:  MOVWF  FF7
093E6:  MOVLW  00
093E8:  MOVWF  FF8
093EA:  CALL   1C14
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
093EE:  MOVLW  2E
093F0:  MOVLB  C
093F2:  MOVWF  x14
093F4:  MOVLB  0
093F6:  CALL   1BC2
....................       delay_ms(1000);
093FA:  MOVLW  04
093FC:  MOVLB  3
093FE:  MOVWF  x75
09400:  MOVLB  0
09402:  MOVLW  FA
09404:  MOVLB  C
09406:  MOVWF  x6B
09408:  MOVLB  0
0940A:  CALL   1B94
0940E:  MOVLB  3
09410:  DECFSZ x75,F
09412:  BRA    9418
09414:  BRA    941C
09416:  MOVLB  0
09418:  MOVLB  0
0941A:  BRA    9402
0941C:  MOVLB  0
0941E:  GOTO   93EE
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
09422:  MOVLW  88
09424:  MOVWF  FF6
09426:  MOVLW  1B
09428:  MOVWF  FF7
0942A:  MOVLW  00
0942C:  MOVWF  FF8
0942E:  CALL   1C14
....................    
.................... }
.................... // Enf of files
09432:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
