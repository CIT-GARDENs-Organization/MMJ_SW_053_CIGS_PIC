CCS PCH C Compiler, Version 5.104, 57077               13-8-25 18:59

               Filename:   build\mmj_cigs_main.lst

               ROM used:   46850 bytes (36%)
                           Largest free fragment is 65520
               RAM used:   395 (11%) at main() level
                           2757 (77%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   B094
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "cigs/system/mmj_cigs_main.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 45,6E
0028C:  DATA 71,75
0028E:  DATA 65,75
00290:  DATA 65,20
00292:  DATA 46,6C
00294:  DATA 61,73
00296:  DATA 68,20
00298:  DATA 4F,70
0029A:  DATA 65,72
0029C:  DATA 61,74
0029E:  DATA 69,6F
002A0:  DATA 6E,0D
002A2:  DATA 0A,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,66
002B4:  DATA 75,6C
002B6:  DATA 6C,21
002B8:  DATA 21,21
002BA:  DATA 0D,0A
002BC:  DATA 00,00
002BE:  DATA 46,6C
002C0:  DATA 61,73
002C2:  DATA 68,20
002C4:  DATA 71,75
002C6:  DATA 65,75
002C8:  DATA 65,20
002CA:  DATA 69,73
002CC:  DATA 20,65
002CE:  DATA 6D,70
002D0:  DATA 74,79
002D2:  DATA 0D,0A
002D4:  DATA 00,00
002D6:  DATA 0D,0A
002D8:  DATA 53,74
002DA:  DATA 61,72
002DC:  DATA 74,20
002DE:  DATA 6D,61
002E0:  DATA 6B,65
002E2:  DATA 5F,72
002E4:  DATA 65,63
002E6:  DATA 65,69
002E8:  DATA 76,65
002EA:  DATA 5F,63
002EC:  DATA 6F,6D
002EE:  DATA 6D,61
002F0:  DATA 6E,64
002F2:  DATA 0D,0A
002F4:  DATA 00,00
002F6:  DATA 09,5B
002F8:  DATA 42,4F
002FA:  DATA 53,53
002FC:  DATA 5D,20
002FE:  DATA 3E,3E
00300:  DATA 3E,20
00302:  DATA 00,00
00304:  DATA 45,6E
00306:  DATA 64,20
00308:  DATA 6D,61
0030A:  DATA 6B,65
0030C:  DATA 5F,72
0030E:  DATA 65,63
00310:  DATA 69,76
00312:  DATA 65,5F
00314:  DATA 63,6F
00316:  DATA 6D,6D
00318:  DATA 61,6E
0031A:  DATA 64,0D
0031C:  DATA 0A,0D
0031E:  DATA 0A,00
00320:  DATA 73,69
00322:  DATA 67,6E
00324:  DATA 61,6C
00326:  DATA 20,65
00328:  DATA 6E,64
0032A:  DATA 20,77
0032C:  DATA 69,74
0032E:  DATA 68,20
00330:  DATA 53,46
00332:  DATA 44,0D
00334:  DATA 0A,00
00336:  DATA 64,6F
00338:  DATA 6E,27
0033A:  DATA 74,20
0033C:  DATA 66,69
0033E:  DATA 6E,64
00340:  DATA 20,53
00342:  DATA 46,44
00344:  DATA 0D,0A
00346:  DATA 00,00
00348:  DATA 09,2D
0034A:  DATA 3E,20
0034C:  DATA 49,6E
0034E:  DATA 76,61
00350:  DATA 6C,69
00352:  DATA 64,20
00354:  DATA 46,72
00356:  DATA 61,6D
00358:  DATA 65,20
0035A:  DATA 49,44
0035C:  DATA 20,72
0035E:  DATA 65,63
00360:  DATA 65,69
00362:  DATA 76,65
00364:  DATA 64,3A
00366:  DATA 20,25
00368:  DATA 58,0D
0036A:  DATA 0A,00
0036C:  DATA 09,2D
0036E:  DATA 3E,20
00370:  DATA 43,52
00372:  DATA 43,20
00374:  DATA 65,72
00376:  DATA 72,6F
00378:  DATA 72,21
0037A:  DATA 0D,0A
0037C:  DATA 00,00
0037E:  DATA 09,09
00380:  DATA 2D,3E
00382:  DATA 20,72
00384:  DATA 65,63
00386:  DATA 65,69
00388:  DATA 76,65
0038A:  DATA 64,20
0038C:  DATA 43,52
0038E:  DATA 43,3A
00390:  DATA 20,25
00392:  DATA 58,0D
00394:  DATA 0A,00
00396:  DATA 09,09
00398:  DATA 20,20
0039A:  DATA 20,63
0039C:  DATA 6F,6C
0039E:  DATA 6C,65
003A0:  DATA 63,74
003A2:  DATA 20,43
003A4:  DATA 52,43
003A6:  DATA 20,3A
003A8:  DATA 20,25
003AA:  DATA 58,0D
003AC:  DATA 0A,00
003AE:  DATA 09,2D
003B0:  DATA 3E,20
003B2:  DATA 49,6E
003B4:  DATA 76,61
003B6:  DATA 6C,69
003B8:  DATA 64,20
003BA:  DATA 64,65
003BC:  DATA 76,69
003BE:  DATA 63,65
003C0:  DATA 20,49
003C2:  DATA 44,20
003C4:  DATA 72,65
003C6:  DATA 63,65
003C8:  DATA 69,76
003CA:  DATA 65,64
003CC:  DATA 0D,0A
003CE:  DATA 00,00
003D0:  DATA 09,09
003D2:  DATA 2D,3E
003D4:  DATA 20,72
003D6:  DATA 65,63
003D8:  DATA 65,69
003DA:  DATA 76,65
003DC:  DATA 64,3A
003DE:  DATA 20,20
003E0:  DATA 20,20
003E2:  DATA 20,25
003E4:  DATA 58,0D
003E6:  DATA 0A,00
003E8:  DATA 09,09
003EA:  DATA 20,20
003EC:  DATA 20,4D
003EE:  DATA 79,20
003F0:  DATA 64,65
003F2:  DATA 76,69
003F4:  DATA 63,65
003F6:  DATA 20,49
003F8:  DATA 44,3A
003FA:  DATA 20,25
003FC:  DATA 58,0D
003FE:  DATA 0A,00
00400:  DATA 09,5B
00402:  DATA 42,4F
00404:  DATA 53,53
00406:  DATA 5D,20
00408:  DATA 3C,3C
0040A:  DATA 3C,20
0040C:  DATA 00,00
0040E:  DATA 53,74
00410:  DATA 61,72
00412:  DATA 74,20
00414:  DATA 53,4D
00416:  DATA 46,20
00418:  DATA 75,73
0041A:  DATA 69,6E
0041C:  DATA 67,20
0041E:  DATA 72,65
00420:  DATA 71,65
00422:  DATA 73,74
00424:  DATA 20,73
00426:  DATA 65,61
00428:  DATA 71,75
0042A:  DATA 65,6E
0042C:  DATA 63,65
0042E:  DATA 0D,0A
00430:  DATA 00,00
00432:  DATA 45,72
00434:  DATA 72,6F
00436:  DATA 72,21
00438:  DATA 20,52
0043A:  DATA 65,63
0043C:  DATA 65,69
0043E:  DATA 76,69
00440:  DATA 6E,67
00442:  DATA 20,63
00444:  DATA 6F,6D
00446:  DATA 6D,61
00448:  DATA 6E,64
0044A:  DATA 20,69
0044C:  DATA 6E,63
0044E:  DATA 6F,6E
00450:  DATA 73,69
00452:  DATA 73,74
00454:  DATA 65,6E
00456:  DATA 74,20
00458:  DATA 77,69
0045A:  DATA 74,68
0045C:  DATA 20,74
0045E:  DATA 68,65
00460:  DATA 20,64
00462:  DATA 65,73
00464:  DATA 69,67
00466:  DATA 6E,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 61,6C
0047C:  DATA 6C,6F
0047E:  DATA 77,65
00480:  DATA 64,0D
00482:  DATA 0A,00
00484:  DATA 53,4D
00486:  DATA 46,20
00488:  DATA 75,73
0048A:  DATA 65,20
0048C:  DATA 72,65
0048E:  DATA 71,75
00490:  DATA 65,73
00492:  DATA 74,20
00494:  DATA 64,65
00496:  DATA 6E,79
00498:  DATA 65,64
0049A:  DATA 0D,0A
0049C:  DATA 00,00
0049E:  DATA 52,65
004A0:  DATA 74,72
004A2:  DATA 79,20
004A4:  DATA 72,65
004A6:  DATA 71,75
004A8:  DATA 65,73
004AA:  DATA 74,20
004AC:  DATA 74,6F
004AE:  DATA 20,42
004B0:  DATA 4F,53
004B2:  DATA 53,20
004B4:  DATA 50,49
004B6:  DATA 43,0D
004B8:  DATA 0A,00
004BA:  DATA 45,72
004BC:  DATA 72,6F
004BE:  DATA 72,21
004C0:  DATA 20,52
004C2:  DATA 65,63
004C4:  DATA 65,69
004C6:  DATA 76,69
004C8:  DATA 6E,67
004CA:  DATA 20,63
004CC:  DATA 6F,6D
004CE:  DATA 6D,61
004D0:  DATA 6E,64
004D2:  DATA 20,69
004D4:  DATA 6E,63
004D6:  DATA 6F,6E
004D8:  DATA 73,69
004DA:  DATA 73,74
004DC:  DATA 65,6E
004DE:  DATA 74,20
004E0:  DATA 77,69
004E2:  DATA 74,68
004E4:  DATA 20,74
004E6:  DATA 68,65
004E8:  DATA 20,64
004EA:  DATA 65,73
004EC:  DATA 69,67
004EE:  DATA 6E,0D
004F0:  DATA 0A,00
004F2:  DATA 45,6E
004F4:  DATA 64,20
004F6:  DATA 53,4D
004F8:  DATA 46,20
004FA:  DATA 75,73
004FC:  DATA 69,6E
004FE:  DATA 67,20
00500:  DATA 72,65
00502:  DATA 71,65
00504:  DATA 73,74
00506:  DATA 20,73
00508:  DATA 65,61
0050A:  DATA 71,75
0050C:  DATA 65,6E
0050E:  DATA 63,65
00510:  DATA 0D,0A
00512:  DATA 00,00
00514:  DATA 49,4F
00516:  DATA 20,49
00518:  DATA 6E,69
0051A:  DATA 74,69
0051C:  DATA 61,6C
0051E:  DATA 69,7A
00520:  DATA 65,0D
00522:  DATA 0A,00
00524:  DATA 09,43
00526:  DATA 6F,6D
00528:  DATA 70,6C
0052A:  DATA 65,74
0052C:  DATA 65,0D
0052E:  DATA 0A,00
00530:  DATA 53,74
00532:  DATA 61,72
00534:  DATA 74,20
00536:  DATA 54,45
00538:  DATA 53,54
0053A:  DATA 20,53
0053C:  DATA 57,45
0053E:  DATA 45,50
00540:  DATA 0D,0A
00542:  DATA 00,00
00544:  DATA 73,74
00546:  DATA 65,70
00548:  DATA 2C,20
0054A:  DATA 76,6F
0054C:  DATA 6C,74
0054E:  DATA 61,67
00550:  DATA 65,2C
00552:  DATA 20,63
00554:  DATA 75,72
00556:  DATA 72,65
00558:  DATA 6E,74
0055A:  DATA 0D,0A
0055C:  DATA 00,00
0055E:  DATA 53,74
00560:  DATA 61,72
00562:  DATA 74,20
00564:  DATA 41,44
00566:  DATA 43,20
00568:  DATA 54,45
0056A:  DATA 53,54
0056C:  DATA 0D,0A
0056E:  DATA 00,00
00570:  DATA 41,44
00572:  DATA 43,20
00574:  DATA 56,6F
00576:  DATA 6C,74
00578:  DATA 61,67
0057A:  DATA 65,3A
0057C:  DATA 20,25
0057E:  DATA 30,34
00580:  DATA 4C,58
00582:  DATA 0D,0A
00584:  DATA 00,00
00586:  DATA 41,44
00588:  DATA 43,20
0058A:  DATA 43,75
0058C:  DATA 72,72
0058E:  DATA 65,6E
00590:  DATA 74,3A
00592:  DATA 20,25
00594:  DATA 30,34
00596:  DATA 4C,58
00598:  DATA 0D,0A
0059A:  DATA 00,00
0059C:  DATA 41,44
0059E:  DATA 43,20
005A0:  DATA 43,49
005A2:  DATA 47,53
005A4:  DATA 31,20
005A6:  DATA 41,6D
005A8:  DATA 70,3A
005AA:  DATA 20,25
005AC:  DATA 30,34
005AE:  DATA 4C,58
005B0:  DATA 0D,0A
005B2:  DATA 00,00
005B4:  DATA 41,44
005B6:  DATA 43,20
005B8:  DATA 43,49
005BA:  DATA 47,53
005BC:  DATA 31,20
005BE:  DATA 56,52
005C0:  DATA 45,46
005C2:  DATA 3A,20
005C4:  DATA 25,30
005C6:  DATA 34,4C
005C8:  DATA 58,0D
005CA:  DATA 0A,00
005CC:  DATA 53,74
005CE:  DATA 61,72
005D0:  DATA 74,20
005D2:  DATA 53,57
005D4:  DATA 45,45
005D6:  DATA 50,20
005D8:  DATA 32,70
005DA:  DATA 6F,72
005DC:  DATA 74,73
005DE:  DATA 0D,0A
005E0:  DATA 00,00
005E2:  DATA 09,53
005E4:  DATA 77,65
005E6:  DATA 65,70
005E8:  DATA 20,73
005EA:  DATA 74,65
005EC:  DATA 70,20
005EE:  DATA 3A,20
005F0:  DATA 25,75
005F2:  DATA 0D,0A
005F4:  DATA 00,00
005F6:  DATA 45,4E
005F8:  DATA 44,20
005FA:  DATA 53,57
005FC:  DATA 45,45
005FE:  DATA 50,20
00600:  DATA 32,70
00602:  DATA 6F,72
00604:  DATA 74,0D
00606:  DATA 0A,00
00608:  DATA 53,74
0060A:  DATA 61,72
0060C:  DATA 74,20
0060E:  DATA 43,49
00610:  DATA 47,53
00612:  DATA 20,64
00614:  DATA 61,74
00616:  DATA 61,20
00618:  DATA 63,6F
0061A:  DATA 6E,76
0061C:  DATA 65,72
0061E:  DATA 73,69
00620:  DATA 6F,6E
00622:  DATA 0D,0A
00624:  DATA 00,00
00626:  DATA 53,74
00628:  DATA 61,72
0062A:  DATA 74,20
0062C:  DATA 53,57
0062E:  DATA 45,45
00630:  DATA 50,20
00632:  DATA 77,69
00634:  DATA 74,68
00636:  DATA 20,74
00638:  DATA 68,72
0063A:  DATA 65,73
0063C:  DATA 68,6F
0063E:  DATA 6C,64
00640:  DATA 0D,0A
00642:  DATA 00,00
00644:  DATA 43,49
00646:  DATA 47,53
00648:  DATA 32,20
0064A:  DATA 64,61
0064C:  DATA 74,61
0064E:  DATA 3A,20
00650:  DATA 25,30
00652:  DATA 34,4C
00654:  DATA 58,2C
00656:  DATA 20,25
00658:  DATA 30,34
0065A:  DATA 4C,58
0065C:  DATA 0D,0A
0065E:  DATA 00,00
00660:  DATA 4D,61
00662:  DATA 78,69
00664:  DATA 6D,75
00666:  DATA 6D,20
00668:  DATA 73,74
0066A:  DATA 65,70
0066C:  DATA 20,63
0066E:  DATA 6F,75
00670:  DATA 6E,74
00672:  DATA 20,72
00674:  DATA 65,61
00676:  DATA 63,68
00678:  DATA 65,64
0067A:  DATA 3A,20
0067C:  DATA 25,6C
0067E:  DATA 64,0D
00680:  DATA 0A,00
00682:  DATA 43,49
00684:  DATA 47,53
00686:  DATA 31,20
00688:  DATA 63,75
0068A:  DATA 72,72
0068C:  DATA 65,6E
0068E:  DATA 74,20
00690:  DATA 6C,69
00692:  DATA 6D,69
00694:  DATA 74,20
00696:  DATA 72,65
00698:  DATA 61,63
0069A:  DATA 68,65
0069C:  DATA 64,3A
0069E:  DATA 00,00
006A0:  DATA 43,49
006A2:  DATA 47,53
006A4:  DATA 31,20
006A6:  DATA 63,75
006A8:  DATA 72,72
006AA:  DATA 65,6E
006AC:  DATA 74,20
006AE:  DATA 62,65
006B0:  DATA 6C,6F
006B2:  DATA 77,20
006B4:  DATA 74,68
006B6:  DATA 72,65
006B8:  DATA 73,68
006BA:  DATA 6F,6C
006BC:  DATA 64,00
006BE:  DATA 43,49
006C0:  DATA 47,53
006C2:  DATA 32,20
006C4:  DATA 63,75
006C6:  DATA 72,72
006C8:  DATA 65,6E
006CA:  DATA 74,20
006CC:  DATA 6C,69
006CE:  DATA 6D,69
006D0:  DATA 74,20
006D2:  DATA 72,65
006D4:  DATA 61,63
006D6:  DATA 68,65
006D8:  DATA 64,3A
006DA:  DATA 20,00
006DC:  DATA 43,49
006DE:  DATA 47,53
006E0:  DATA 32,20
006E2:  DATA 63,75
006E4:  DATA 72,72
006E6:  DATA 65,6E
006E8:  DATA 74,20
006EA:  DATA 62,65
006EC:  DATA 6C,6F
006EE:  DATA 77,20
006F0:  DATA 74,68
006F2:  DATA 72,65
006F4:  DATA 73,68
006F6:  DATA 6F,6C
006F8:  DATA 64,3A
006FA:  DATA 00,00
006FC:  DATA 45,6E
006FE:  DATA 64,20
00700:  DATA 53,57
00702:  DATA 45,45
00704:  DATA 50,20
00706:  DATA 77,69
00708:  DATA 74,68
0070A:  DATA 20,74
0070C:  DATA 68,72
0070E:  DATA 65,73
00710:  DATA 68,6F
00712:  DATA 6C,64
00714:  DATA 0D,0A
00716:  DATA 00,00
00718:  DATA 45,6E
0071A:  DATA 64,20
0071C:  DATA 43,49
0071E:  DATA 47,53
00720:  DATA 20,64
00722:  DATA 61,74
00724:  DATA 61,20
00726:  DATA 63,6F
00728:  DATA 6E,76
0072A:  DATA 65,72
0072C:  DATA 73,69
0072E:  DATA 6F,6E
00730:  DATA 0D,0A
00732:  DATA 00,00
00734:  DATA 09,5B
00736:  DATA 50,49
00738:  DATA 43,4C
0073A:  DATA 4F,47
0073C:  DATA 5D,20
0073E:  DATA 3A,20
00740:  DATA 00,00
00742:  DATA 43,52
00744:  DATA 43,20
00746:  DATA 76,65
00748:  DATA 72,69
0074A:  DATA 66,69
0074C:  DATA 63,61
0074E:  DATA 74,69
00750:  DATA 6F,6E
00752:  DATA 20,70
00754:  DATA 61,73
00756:  DATA 73,65
00758:  DATA 64,20
0075A:  DATA 6F,6E
0075C:  DATA 20,61
0075E:  DATA 74,74
00760:  DATA 65,6D
00762:  DATA 70,74
00764:  DATA 20,25
00766:  DATA 75,0D
00768:  DATA 0A,00
0076A:  DATA 43,52
0076C:  DATA 43,20
0076E:  DATA 76,65
00770:  DATA 72,69
00772:  DATA 66,69
00774:  DATA 63,61
00776:  DATA 74,69
00778:  DATA 6F,6E
0077A:  DATA 20,70
0077C:  DATA 61,73
0077E:  DATA 73,65
00780:  DATA 64,20
00782:  DATA 6F,6E
00784:  DATA 20,61
00786:  DATA 74,74
00788:  DATA 65,6D
0078A:  DATA 70,74
0078C:  DATA 20,25
0078E:  DATA 64,0D
00790:  DATA 0A,00
00792:  DATA 45,72
00794:  DATA 72,6F
00796:  DATA 72,3A
00798:  DATA 20,43
0079A:  DATA 52,43
0079C:  DATA 20,76
0079E:  DATA 65,72
007A0:  DATA 69,66
007A2:  DATA 69,63
007A4:  DATA 61,74
007A6:  DATA 69,6F
007A8:  DATA 6E,20
007AA:  DATA 66,61
007AC:  DATA 69,6C
007AE:  DATA 65,64
007B0:  DATA 20,61
007B2:  DATA 66,74
007B4:  DATA 65,72
007B6:  DATA 20,25
007B8:  DATA 64,20
007BA:  DATA 61,74
007BC:  DATA 74,65
007BE:  DATA 6D,70
007C0:  DATA 74,73
007C2:  DATA 0D,0A
007C4:  DATA 00,00
007C6:  DATA 0D,0A
007C8:  DATA 5F,5F
007CA:  DATA 5F,5F
007CC:  DATA 5F,5F
007CE:  DATA 5F,5F
007D0:  DATA 5F,5F
007D2:  DATA 5F,5F
007D4:  DATA 5F,5F
007D6:  DATA 5F,5F
007D8:  DATA 5F,5F
007DA:  DATA 5F,5F
007DC:  DATA 0D,0A
007DE:  DATA 00,00
007E0:  DATA 5F,5F
007E2:  DATA 5F,5F
007E4:  DATA 5F,53
007E6:  DATA 74,61
007E8:  DATA 72,74
007EA:  DATA 20,63
007EC:  DATA 6F,70
007EE:  DATA 79,5F
007F0:  DATA 64,61
007F2:  DATA 74,61
007F4:  DATA 5F,5F
007F6:  DATA 5F,5F
007F8:  DATA 0D,0A
007FA:  DATA 00,00
007FC:  DATA 45,72
007FE:  DATA 72,6F
00800:  DATA 72,3A
00802:  DATA 20,4D
00804:  DATA 49,53
00806:  DATA 20,46
00808:  DATA 4D,20
0080A:  DATA 69,73
0080C:  DATA 20,6E
0080E:  DATA 6F,74
00810:  DATA 20,63
00812:  DATA 6F,6E
00814:  DATA 6E,65
00816:  DATA 63,74
00818:  DATA 65,64
0081A:  DATA 0D,0A
0081C:  DATA 00,00
0081E:  DATA 45,72
00820:  DATA 72,6F
00822:  DATA 72,3A
00824:  DATA 20,53
00826:  DATA 4D,46
00828:  DATA 20,69
0082A:  DATA 73,20
0082C:  DATA 6E,6F
0082E:  DATA 74,20
00830:  DATA 63,6F
00832:  DATA 6E,6E
00834:  DATA 65,63
00836:  DATA 74,65
00838:  DATA 64,0D
0083A:  DATA 0A,00
0083C:  DATA 53,69
0083E:  DATA 7A,65
00840:  DATA 20,61
00842:  DATA 72,65
00844:  DATA 61,20
00846:  DATA 72,65
00848:  DATA 61,64
0084A:  DATA 0D,0A
0084C:  DATA 00,00
0084E:  DATA 75,73
00850:  DATA 65,64
00852:  DATA 5F,73
00854:  DATA 69,7A
00856:  DATA 65,20
00858:  DATA 3D,20
0085A:  DATA 25,6C
0085C:  DATA 64,20
0085E:  DATA 28,73
00860:  DATA 72,63
00862:  DATA 20,30
00864:  DATA 78,25
00866:  DATA 30,38
00868:  DATA 4C,58
0086A:  DATA 29,0D
0086C:  DATA 0A,00
0086E:  DATA 6C,6F
00870:  DATA 6F,70
00872:  DATA 20,63
00874:  DATA 6F,75
00876:  DATA 6E,74
00878:  DATA 3D,20
0087A:  DATA 25,64
0087C:  DATA 20,20
0087E:  DATA 28,73
00880:  DATA 72,63
00882:  DATA 20,30
00884:  DATA 78,25
00886:  DATA 30,38
00888:  DATA 4C,58
0088A:  DATA 29,0D
0088C:  DATA 0A,0D
0088E:  DATA 0A,00
00890:  DATA 57,72
00892:  DATA 61,70
00894:  DATA 20,74
00896:  DATA 72,69
00898:  DATA 67,67
0089A:  DATA 65,72
0089C:  DATA 65,64
0089E:  DATA 3A,20
008A0:  DATA 52,65
008A2:  DATA 73,65
008A4:  DATA 74,74
008A6:  DATA 69,6E
008A8:  DATA 67,20
008AA:  DATA 64,61
008AC:  DATA 74,61
008AE:  DATA 5F,77
008B0:  DATA 72,69
008B2:  DATA 74,65
008B4:  DATA 5F,61
008B6:  DATA 64,64
008B8:  DATA 72,20
008BA:  DATA 74,6F
008BC:  DATA 20,73
008BE:  DATA 74,61
008C0:  DATA 72,74
008C2:  DATA 0D,0A
008C4:  DATA 00,00
008C6:  DATA 75,73
008C8:  DATA 65,64
008CA:  DATA 5F,73
008CC:  DATA 69,7A
008CE:  DATA 65,20
008D0:  DATA 3D,20
008D2:  DATA 25,6C
008D4:  DATA 64,0D
008D6:  DATA 0A,00
008D8:  DATA 6C,6F
008DA:  DATA 6F,70
008DC:  DATA 5F,63
008DE:  DATA 6F,75
008E0:  DATA 6E,74
008E2:  DATA 20,3D
008E4:  DATA 20,25
008E6:  DATA 75,0D
008E8:  DATA 0A,0D
008EA:  DATA 0A,00
008EC:  DATA 0D,0A
008EE:  DATA 5F,5F
008F0:  DATA 5F,45
008F2:  DATA 6E,64
008F4:  DATA 20,63
008F6:  DATA 6F,70
008F8:  DATA 79,5F
008FA:  DATA 64,61
008FC:  DATA 74,61
008FE:  DATA 5F,5F
00900:  DATA 5F,5F
00902:  DATA 0D,0A
00904:  DATA 00,00
00906:  DATA 5F,5F
00908:  DATA 5F,5F
0090A:  DATA 5F,5F
0090C:  DATA 5F,5F
0090E:  DATA 5F,5F
00910:  DATA 5F,5F
00912:  DATA 5F,5F
00914:  DATA 5F,5F
00916:  DATA 5F,5F
00918:  DATA 5F,5F
0091A:  DATA 0D,0A
0091C:  DATA 0D,0A
0091E:  DATA 00,00
00920:  DATA 0D,0A
00922:  DATA 5F,5F
00924:  DATA 5F,5F
00926:  DATA 5F,5F
00928:  DATA 5F,5F
0092A:  DATA 5F,5F
0092C:  DATA 5F,5F
0092E:  DATA 5F,5F
00930:  DATA 5F,5F
00932:  DATA 5F,5F
00934:  DATA 5F,5F
00936:  DATA 0D,0A
00938:  DATA 00,00
0093A:  DATA 5F,5F
0093C:  DATA 5F,53
0093E:  DATA 74,61
00940:  DATA 72,74
00942:  DATA 20,53
00944:  DATA 4D,46
00946:  DATA 20,52
00948:  DATA 65,61
0094A:  DATA 64,5F
0094C:  DATA 5F,5F
0094E:  DATA 5F,0D
00950:  DATA 0A,00
00952:  DATA 49,6E
00954:  DATA 20,53
00956:  DATA 4D,46
00958:  DATA 20,52
0095A:  DATA 65,61
0095C:  DATA 64,20
0095E:  DATA 73,6F
00960:  DATA 75,72
00962:  DATA 63,65
00964:  DATA 20,64
00966:  DATA 61,74
00968:  DATA 61,20
0096A:  DATA 61,64
0096C:  DATA 64,72
0096E:  DATA 65,73
00970:  DATA 73,3A
00972:  DATA 20,25
00974:  DATA 4C,58
00976:  DATA 0D,0A
00978:  DATA 00,00
0097A:  DATA 49,6E
0097C:  DATA 20,53
0097E:  DATA 4D,46
00980:  DATA 20,52
00982:  DATA 65,61
00984:  DATA 64,20
00986:  DATA 64,61
00988:  DATA 74,61
0098A:  DATA 20,73
0098C:  DATA 69,7A
0098E:  DATA 65,20
00990:  DATA 20,20
00992:  DATA 20,20
00994:  DATA 20,20
00996:  DATA 20,20
00998:  DATA 20,3A
0099A:  DATA 20,25
0099C:  DATA 6C,75
0099E:  DATA 20,28
009A0:  DATA 30,78
009A2:  DATA 25,6C
009A4:  DATA 78,29
009A6:  DATA 0D,0A
009A8:  DATA 0D,0A
009AA:  DATA 00,00
009AC:  DATA 45,72
009AE:  DATA 72,6F
009B0:  DATA 72,3A
009B2:  DATA 20,53
009B4:  DATA 4D,46
009B6:  DATA 20,69
009B8:  DATA 73,20
009BA:  DATA 6E,6F
009BC:  DATA 74,20
009BE:  DATA 63,6F
009C0:  DATA 6E,6E
009C2:  DATA 65,63
009C4:  DATA 74,65
009C6:  DATA 64,0D
009C8:  DATA 0A,00
009CA:  DATA 52,45
009CC:  DATA 41,44
009CE:  DATA 20,44
009D0:  DATA 41,54
009D2:  DATA 41,20
009D4:  DATA 46,52
009D6:  DATA 4F,4D
009D8:  DATA 20,53
009DA:  DATA 4D,46
009DC:  DATA 2E,2E
009DE:  DATA 2E,0D
009E0:  DATA 0A,00
009E2:  DATA 0D,0A
009E4:  DATA 5F,5F
009E6:  DATA 5F,45
009E8:  DATA 6E,64
009EA:  DATA 20,53
009EC:  DATA 4D,46
009EE:  DATA 20,52
009F0:  DATA 65,61
009F2:  DATA 64,5F
009F4:  DATA 5F,5F
009F6:  DATA 5F,0D
009F8:  DATA 0A,00
009FA:  DATA 5F,5F
009FC:  DATA 5F,5F
009FE:  DATA 5F,5F
00A00:  DATA 5F,5F
00A02:  DATA 5F,5F
00A04:  DATA 5F,5F
00A06:  DATA 5F,5F
00A08:  DATA 5F,5F
00A0A:  DATA 5F,5F
00A0C:  DATA 5F,5F
00A0E:  DATA 0D,0A
00A10:  DATA 0D,0A
00A12:  DATA 00,00
00A14:  DATA 0D,0A
00A16:  DATA 5F,5F
00A18:  DATA 5F,5F
00A1A:  DATA 5F,5F
00A1C:  DATA 5F,5F
00A1E:  DATA 5F,5F
00A20:  DATA 5F,5F
00A22:  DATA 5F,5F
00A24:  DATA 5F,5F
00A26:  DATA 5F,5F
00A28:  DATA 5F,5F
00A2A:  DATA 0D,0A
00A2C:  DATA 00,00
00A2E:  DATA 5F,5F
00A30:  DATA 5F,53
00A32:  DATA 74,61
00A34:  DATA 72,74
00A36:  DATA 20,73
00A38:  DATA 6D,66
00A3A:  DATA 5F,65
00A3C:  DATA 72,61
00A3E:  DATA 73,65
00A40:  DATA 5F,5F
00A42:  DATA 5F,5F
00A44:  DATA 0D,0A
00A46:  DATA 00,00
00A48:  DATA 49,6E
00A4A:  DATA 20,53
00A4C:  DATA 4D,46
00A4E:  DATA 20,45
00A50:  DATA 72,61
00A52:  DATA 73,65
00A54:  DATA 20,73
00A56:  DATA 6F,75
00A58:  DATA 72,63
00A5A:  DATA 65,20
00A5C:  DATA 64,61
00A5E:  DATA 74,61
00A60:  DATA 20,61
00A62:  DATA 64,64
00A64:  DATA 72,65
00A66:  DATA 73,73
00A68:  DATA 3A,20
00A6A:  DATA 25,4C
00A6C:  DATA 58,0D
00A6E:  DATA 0A,00
00A70:  DATA 49,6E
00A72:  DATA 20,53
00A74:  DATA 4D,46
00A76:  DATA 20,45
00A78:  DATA 72,61
00A7A:  DATA 73,65
00A7C:  DATA 20,64
00A7E:  DATA 61,74
00A80:  DATA 61,20
00A82:  DATA 73,69
00A84:  DATA 7A,65
00A86:  DATA 20,20
00A88:  DATA 20,20
00A8A:  DATA 20,20
00A8C:  DATA 20,20
00A8E:  DATA 20,20
00A90:  DATA 3A,20
00A92:  DATA 25,6C
00A94:  DATA 75,20
00A96:  DATA 28,30
00A98:  DATA 78,25
00A9A:  DATA 6C,78
00A9C:  DATA 29,0D
00A9E:  DATA 0A,0D
00AA0:  DATA 0A,00
00AA2:  DATA 45,72
00AA4:  DATA 72,6F
00AA6:  DATA 72,3A
00AA8:  DATA 20,53
00AAA:  DATA 4D,46
00AAC:  DATA 20,69
00AAE:  DATA 73,20
00AB0:  DATA 6E,6F
00AB2:  DATA 74,20
00AB4:  DATA 63,6F
00AB6:  DATA 6E,6E
00AB8:  DATA 65,63
00ABA:  DATA 74,65
00ABC:  DATA 64,0D
00ABE:  DATA 0A,00
00AC0:  DATA 45,72
00AC2:  DATA 72,6F
00AC4:  DATA 72,3A
00AC6:  DATA 20,45
00AC8:  DATA 72,61
00ACA:  DATA 73,65
00ACC:  DATA 20,73
00ACE:  DATA 6F,75
00AD0:  DATA 72,63
00AD2:  DATA 65,20
00AD4:  DATA 61,64
00AD6:  DATA 64,72
00AD8:  DATA 65,73
00ADA:  DATA 73,20
00ADC:  DATA 30,78
00ADE:  DATA 25,4C
00AE0:  DATA 58,20
00AE2:  DATA 69,73
00AE4:  DATA 20,6F
00AE6:  DATA 75,74
00AE8:  DATA 73,69
00AEA:  DATA 64,65
00AEC:  DATA 20,6D
00AEE:  DATA 69,73
00AF0:  DATA 73,69
00AF2:  DATA 6F,6E
00AF4:  DATA 20,72
00AF6:  DATA 61,6E
00AF8:  DATA 67,65
00AFA:  DATA 20,5B
00AFC:  DATA 30,78
00AFE:  DATA 25,4C
00B00:  DATA 58,20
00B02:  DATA 2D,20
00B04:  DATA 30,78
00B06:  DATA 25,4C
00B08:  DATA 58,5D
00B0A:  DATA 0D,0A
00B0C:  DATA 00,00
00B0E:  DATA 45,72
00B10:  DATA 72,6F
00B12:  DATA 72,3A
00B14:  DATA 20,45
00B16:  DATA 72,61
00B18:  DATA 73,65
00B1A:  DATA 20,6F
00B1C:  DATA 70,65
00B1E:  DATA 72,61
00B20:  DATA 74,69
00B22:  DATA 6F,6E
00B24:  DATA 20,77
00B26:  DATA 6F,75
00B28:  DATA 6C,64
00B2A:  DATA 20,65
00B2C:  DATA 78,63
00B2E:  DATA 65,65
00B30:  DATA 64,20
00B32:  DATA 6D,69
00B34:  DATA 73,73
00B36:  DATA 69,6F
00B38:  DATA 6E,20
00B3A:  DATA 65,6E
00B3C:  DATA 64,20
00B3E:  DATA 61,64
00B40:  DATA 64,72
00B42:  DATA 65,73
00B44:  DATA 73,20
00B46:  DATA 30,78
00B48:  DATA 25,4C
00B4A:  DATA 58,0D
00B4C:  DATA 0A,00
00B4E:  DATA 4C,69
00B50:  DATA 6D,69
00B52:  DATA 74,69
00B54:  DATA 6E,67
00B56:  DATA 20,65
00B58:  DATA 72,61
00B5A:  DATA 73,65
00B5C:  DATA 20,73
00B5E:  DATA 69,7A
00B60:  DATA 65,20
00B62:  DATA 74,6F
00B64:  DATA 20,73
00B66:  DATA 74,61
00B68:  DATA 79,20
00B6A:  DATA 77,69
00B6C:  DATA 74,68
00B6E:  DATA 69,6E
00B70:  DATA 20,6D
00B72:  DATA 69,73
00B74:  DATA 73,69
00B76:  DATA 6F,6E
00B78:  DATA 20,62
00B7A:  DATA 6F,75
00B7C:  DATA 6E,64
00B7E:  DATA 73,0D
00B80:  DATA 0A,00
00B82:  DATA 45,72
00B84:  DATA 61,73
00B86:  DATA 65,20
00B88:  DATA 6F,70
00B8A:  DATA 65,72
00B8C:  DATA 61,74
00B8E:  DATA 69,6F
00B90:  DATA 6E,20
00B92:  DATA 76,61
00B94:  DATA 6C,69
00B96:  DATA 64,61
00B98:  DATA 74,65
00B9A:  DATA 64,20
00B9C:  DATA 77,69
00B9E:  DATA 74,68
00BA0:  DATA 69,6E
00BA2:  DATA 20,6D
00BA4:  DATA 69,73
00BA6:  DATA 73,69
00BA8:  DATA 6F,6E
00BAA:  DATA 20,72
00BAC:  DATA 61,6E
00BAE:  DATA 67,65
00BB0:  DATA 0D,0A
00BB2:  DATA 00,00
00BB4:  DATA 0D,0A
00BB6:  DATA 5F,5F
00BB8:  DATA 5F,45
00BBA:  DATA 6E,64
00BBC:  DATA 20,73
00BBE:  DATA 6D,66
00BC0:  DATA 5F,65
00BC2:  DATA 72,61
00BC4:  DATA 73,65
00BC6:  DATA 5F,5F
00BC8:  DATA 5F,5F
00BCA:  DATA 0D,0A
00BCC:  DATA 00,00
00BCE:  DATA 5F,5F
00BD0:  DATA 5F,5F
00BD2:  DATA 5F,5F
00BD4:  DATA 5F,5F
00BD6:  DATA 5F,5F
00BD8:  DATA 5F,5F
00BDA:  DATA 5F,5F
00BDC:  DATA 5F,5F
00BDE:  DATA 5F,5F
00BE0:  DATA 5F,5F
00BE2:  DATA 0D,0A
00BE4:  DATA 0D,0A
00BE6:  DATA 00,00
00BE8:  DATA 45,72
00BEA:  DATA 72,6F
00BEC:  DATA 72,3A
00BEE:  DATA 20,55
00BF0:  DATA 6E,6B
00BF2:  DATA 6E,6F
00BF4:  DATA 77,6E
00BF6:  DATA 20,6D
00BF8:  DATA 69,73
00BFA:  DATA 73,69
00BFC:  DATA 6F,6E
00BFE:  DATA 5F,69
00C00:  DATA 64,3A
00C02:  DATA 20,25
00C04:  DATA 30,32
00C06:  DATA 58,0D
00C08:  DATA 0A,00
00C0A:  DATA 55,70
00C0C:  DATA 64,61
00C0E:  DATA 74,65
00C10:  DATA 64,20
00C12:  DATA 70,61
00C14:  DATA 72,74
00C16:  DATA 69,74
00C18:  DATA 69,6F
00C1A:  DATA 6E,20
00C1C:  DATA 66,6F
00C1E:  DATA 72,20
00C20:  DATA 6D,69
00C22:  DATA 73,73
00C24:  DATA 69,6F
00C26:  DATA 6E,5F
00C28:  DATA 69,64
00C2A:  DATA 20,25
00C2C:  DATA 30,32
00C2E:  DATA 58,3A
00C30:  DATA 20,75
00C32:  DATA 73,65
00C34:  DATA 64,5F
00C36:  DATA 73,69
00C38:  DATA 7A,65
00C3A:  DATA 3D,25
00C3C:  DATA 6C,64
00C3E:  DATA 2C,20
00C40:  DATA 6C,6F
00C42:  DATA 6F,70
00C44:  DATA 5F,63
00C46:  DATA 6F,75
00C48:  DATA 6E,74
00C4A:  DATA 65,72
00C4C:  DATA 3D,25
00C4E:  DATA 6C,64
00C50:  DATA 0D,0A
00C52:  DATA 00,00
00C54:  DATA 4D,49
00C56:  DATA 53,53
00C58:  DATA 49,4F
00C5A:  DATA 4E,20
00C5C:  DATA 46,4C
00C5E:  DATA 41,53
00C60:  DATA 48,20
00C62:  DATA 49,6E
00C64:  DATA 69,74
00C66:  DATA 69,61
00C68:  DATA 6C,69
00C6A:  DATA 7A,65
00C6C:  DATA 0D,0A
00C6E:  DATA 00,00
00C70:  DATA 09,5B
00C72:  DATA 4D,49
00C74:  DATA 53,20
00C76:  DATA 46,4D
00C78:  DATA 5D,20
00C7A:  DATA 43,6F
00C7C:  DATA 6E,6E
00C7E:  DATA 65,63
00C80:  DATA 74,65
00C82:  DATA 64,0D
00C84:  DATA 0A,00
00C86:  DATA 09,5B
00C88:  DATA 4D,49
00C8A:  DATA 53,20
00C8C:  DATA 46,4D
00C8E:  DATA 5D,20
00C90:  DATA 4E,6F
00C92:  DATA 74,20
00C94:  DATA 43,6F
00C96:  DATA 6E,6E
00C98:  DATA 65,63
00C9A:  DATA 74,65
00C9C:  DATA 64,0D
00C9E:  DATA 0A,00
00CA0:  DATA 09,5B
00CA2:  DATA 53,4D
00CA4:  DATA 46,5D
00CA6:  DATA 20,43
00CA8:  DATA 6F,6E
00CAA:  DATA 6E,65
00CAC:  DATA 63,74
00CAE:  DATA 65,64
00CB0:  DATA 0D,0A
00CB2:  DATA 00,00
00CB4:  DATA 09,5B
00CB6:  DATA 53,4D
00CB8:  DATA 46,5D
00CBA:  DATA 20,4E
00CBC:  DATA 6F,74
00CBE:  DATA 20,43
00CC0:  DATA 6F,6E
00CC2:  DATA 6E,65
00CC4:  DATA 63,74
00CC6:  DATA 65,64
00CC8:  DATA 0D,0A
00CCA:  DATA 00,00
00CCC:  DATA 09,5B
00CCE:  DATA 4D,49
00CD0:  DATA 53,20
00CD2:  DATA 46,4D
00CD4:  DATA 5D,20
00CD6:  DATA 43,52
00CD8:  DATA 43,20
00CDA:  DATA 65,72
00CDC:  DATA 72,6F
00CDE:  DATA 72,20
00CE0:  DATA 2D,3E
00CE2:  DATA 20,69
00CE4:  DATA 6E,69
00CE6:  DATA 74,69
00CE8:  DATA 61,6C
00CEA:  DATA 69,7A
00CEC:  DATA 65,20
00CEE:  DATA 63,6F
00CF0:  DATA 75,6E
00CF2:  DATA 74,65
00CF4:  DATA 72,73
00CF6:  DATA 0D,0A
00CF8:  DATA 00,00
00CFA:  DATA 09,7C
00CFC:  DATA 20,4D
00CFE:  DATA 49,53
00D00:  DATA 46,20
00D02:  DATA 7C,20
00D04:  DATA 50,49
00D06:  DATA 43,4C
00D08:  DATA 4F,47
00D0A:  DATA 20,20
00D0C:  DATA 20,20
00D0E:  DATA 7C,20
00D10:  DATA 55,73
00D12:  DATA 65,20
00D14:  DATA 43,6F
00D16:  DATA 75,6E
00D18:  DATA 74,65
00D1A:  DATA 72,20
00D1C:  DATA 20,20
00D1E:  DATA 20,20
00D20:  DATA 20,3A
00D22:  DATA 20,30
00D24:  DATA 78,25
00D26:  DATA 30,38
00D28:  DATA 4C,58
00D2A:  DATA 0D,0A
00D2C:  DATA 00,00
00D2E:  DATA 09,7C
00D30:  DATA 20,4D
00D32:  DATA 49,53
00D34:  DATA 46,20
00D36:  DATA 7C,20
00D38:  DATA 50,49
00D3A:  DATA 43,4C
00D3C:  DATA 4F,47
00D3E:  DATA 20,20
00D40:  DATA 20,20
00D42:  DATA 7C,20
00D44:  DATA 55,6E
00D46:  DATA 63,6F
00D48:  DATA 70,79
00D4A:  DATA 65,64
00D4C:  DATA 20,43
00D4E:  DATA 6F,75
00D50:  DATA 6E,74
00D52:  DATA 65,72
00D54:  DATA 20,3A
00D56:  DATA 20,30
00D58:  DATA 78,25
00D5A:  DATA 30,38
00D5C:  DATA 4C,58
00D5E:  DATA 0D,0A
00D60:  DATA 00,00
00D62:  DATA 09,7C
00D64:  DATA 20,4D
00D66:  DATA 49,53
00D68:  DATA 46,20
00D6A:  DATA 7C,20
00D6C:  DATA 50,49
00D6E:  DATA 43,4C
00D70:  DATA 4F,47
00D72:  DATA 20,20
00D74:  DATA 20,20
00D76:  DATA 7C,20
00D78:  DATA 52,65
00D7A:  DATA 73,65
00D7C:  DATA 72,76
00D7E:  DATA 65,20
00D80:  DATA 43,6F
00D82:  DATA 75,6E
00D84:  DATA 74,65
00D86:  DATA 72,31
00D88:  DATA 20,3A
00D8A:  DATA 20,30
00D8C:  DATA 78,25
00D8E:  DATA 30,32
00D90:  DATA 58,0D
00D92:  DATA 0A,00
00D94:  DATA 09,7C
00D96:  DATA 20,4D
00D98:  DATA 49,53
00D9A:  DATA 46,20
00D9C:  DATA 7C,20
00D9E:  DATA 50,49
00DA0:  DATA 43,4C
00DA2:  DATA 4F,47
00DA4:  DATA 20,20
00DA6:  DATA 20,20
00DA8:  DATA 7C,20
00DAA:  DATA 52,65
00DAC:  DATA 73,65
00DAE:  DATA 72,76
00DB0:  DATA 65,20
00DB2:  DATA 43,6F
00DB4:  DATA 75,6E
00DB6:  DATA 74,65
00DB8:  DATA 72,32
00DBA:  DATA 20,3A
00DBC:  DATA 20,30
00DBE:  DATA 78,25
00DC0:  DATA 30,32
00DC2:  DATA 58,0D
00DC4:  DATA 0A,00
00DC6:  DATA 09,7C
00DC8:  DATA 20,4D
00DCA:  DATA 49,53
00DCC:  DATA 46,20
00DCE:  DATA 7C,20
00DD0:  DATA 45,4E
00DD2:  DATA 56,49
00DD4:  DATA 52,4F
00DD6:  DATA 20,20
00DD8:  DATA 20,20
00DDA:  DATA 7C,20
00DDC:  DATA 55,73
00DDE:  DATA 65,20
00DE0:  DATA 43,6F
00DE2:  DATA 75,6E
00DE4:  DATA 74,65
00DE6:  DATA 72,20
00DE8:  DATA 20,20
00DEA:  DATA 20,20
00DEC:  DATA 20,3A
00DEE:  DATA 20,30
00DF0:  DATA 78,25
00DF2:  DATA 30,38
00DF4:  DATA 4C,58
00DF6:  DATA 0D,0A
00DF8:  DATA 00,00
00DFA:  DATA 09,7C
00DFC:  DATA 20,4D
00DFE:  DATA 49,53
00E00:  DATA 46,20
00E02:  DATA 7C,20
00E04:  DATA 45,4E
00E06:  DATA 56,49
00E08:  DATA 52,4F
00E0A:  DATA 20,20
00E0C:  DATA 20,20
00E0E:  DATA 7C,20
00E10:  DATA 55,6E
00E12:  DATA 63,6F
00E14:  DATA 70,79
00E16:  DATA 65,64
00E18:  DATA 20,43
00E1A:  DATA 6F,75
00E1C:  DATA 6E,74
00E1E:  DATA 65,72
00E20:  DATA 20,3A
00E22:  DATA 20,30
00E24:  DATA 78,25
00E26:  DATA 30,38
00E28:  DATA 4C,58
00E2A:  DATA 0D,0A
00E2C:  DATA 00,00
00E2E:  DATA 09,7C
00E30:  DATA 20,4D
00E32:  DATA 49,53
00E34:  DATA 46,20
00E36:  DATA 7C,20
00E38:  DATA 45,4E
00E3A:  DATA 56,49
00E3C:  DATA 52,4F
00E3E:  DATA 20,20
00E40:  DATA 20,20
00E42:  DATA 7C,20
00E44:  DATA 52,65
00E46:  DATA 73,65
00E48:  DATA 72,76
00E4A:  DATA 65,20
00E4C:  DATA 43,6F
00E4E:  DATA 75,6E
00E50:  DATA 74,65
00E52:  DATA 72,31
00E54:  DATA 20,3A
00E56:  DATA 20,30
00E58:  DATA 78,25
00E5A:  DATA 30,32
00E5C:  DATA 58,0D
00E5E:  DATA 0A,00
00E60:  DATA 09,7C
00E62:  DATA 20,4D
00E64:  DATA 49,53
00E66:  DATA 46,20
00E68:  DATA 7C,20
00E6A:  DATA 45,4E
00E6C:  DATA 56,49
00E6E:  DATA 52,4F
00E70:  DATA 20,20
00E72:  DATA 20,20
00E74:  DATA 7C,20
00E76:  DATA 52,65
00E78:  DATA 73,65
00E7A:  DATA 72,76
00E7C:  DATA 65,20
00E7E:  DATA 43,6F
00E80:  DATA 75,6E
00E82:  DATA 74,65
00E84:  DATA 72,32
00E86:  DATA 20,3A
00E88:  DATA 20,30
00E8A:  DATA 78,25
00E8C:  DATA 30,32
00E8E:  DATA 58,0D
00E90:  DATA 0A,00
00E92:  DATA 09,7C
00E94:  DATA 20,4D
00E96:  DATA 49,53
00E98:  DATA 46,20
00E9A:  DATA 7C,20
00E9C:  DATA 49,56
00E9E:  DATA 20,48
00EA0:  DATA 45,41
00EA2:  DATA 44,45
00EA4:  DATA 52,20
00EA6:  DATA 7C,20
00EA8:  DATA 55,73
00EAA:  DATA 65,20
00EAC:  DATA 43,6F
00EAE:  DATA 75,6E
00EB0:  DATA 74,65
00EB2:  DATA 72,20
00EB4:  DATA 20,20
00EB6:  DATA 20,20
00EB8:  DATA 20,3A
00EBA:  DATA 20,30
00EBC:  DATA 78,25
00EBE:  DATA 30,38
00EC0:  DATA 4C,58
00EC2:  DATA 0D,0A
00EC4:  DATA 00,00
00EC6:  DATA 09,7C
00EC8:  DATA 20,4D
00ECA:  DATA 49,53
00ECC:  DATA 46,20
00ECE:  DATA 7C,20
00ED0:  DATA 49,56
00ED2:  DATA 20,48
00ED4:  DATA 45,41
00ED6:  DATA 44,45
00ED8:  DATA 52,20
00EDA:  DATA 7C,20
00EDC:  DATA 55,6E
00EDE:  DATA 63,6F
00EE0:  DATA 70,79
00EE2:  DATA 65,64
00EE4:  DATA 20,43
00EE6:  DATA 6F,75
00EE8:  DATA 6E,74
00EEA:  DATA 65,72
00EEC:  DATA 20,3A
00EEE:  DATA 20,30
00EF0:  DATA 78,25
00EF2:  DATA 30,38
00EF4:  DATA 4C,58
00EF6:  DATA 0D,0A
00EF8:  DATA 00,00
00EFA:  DATA 09,7C
00EFC:  DATA 20,4D
00EFE:  DATA 49,53
00F00:  DATA 46,20
00F02:  DATA 7C,20
00F04:  DATA 49,56
00F06:  DATA 20,48
00F08:  DATA 45,41
00F0A:  DATA 44,45
00F0C:  DATA 52,20
00F0E:  DATA 7C,20
00F10:  DATA 52,65
00F12:  DATA 73,65
00F14:  DATA 72,76
00F16:  DATA 65,20
00F18:  DATA 43,6F
00F1A:  DATA 75,6E
00F1C:  DATA 74,65
00F1E:  DATA 72,31
00F20:  DATA 20,3A
00F22:  DATA 20,30
00F24:  DATA 78,25
00F26:  DATA 30,32
00F28:  DATA 58,0D
00F2A:  DATA 0A,00
00F2C:  DATA 09,7C
00F2E:  DATA 20,4D
00F30:  DATA 49,53
00F32:  DATA 46,20
00F34:  DATA 7C,20
00F36:  DATA 49,56
00F38:  DATA 20,48
00F3A:  DATA 45,41
00F3C:  DATA 44,45
00F3E:  DATA 52,20
00F40:  DATA 7C,20
00F42:  DATA 52,65
00F44:  DATA 73,65
00F46:  DATA 72,76
00F48:  DATA 65,20
00F4A:  DATA 43,6F
00F4C:  DATA 75,6E
00F4E:  DATA 74,65
00F50:  DATA 72,32
00F52:  DATA 20,3A
00F54:  DATA 20,30
00F56:  DATA 78,25
00F58:  DATA 30,32
00F5A:  DATA 58,0D
00F5C:  DATA 0A,00
00F5E:  DATA 09,7C
00F60:  DATA 20,4D
00F62:  DATA 49,53
00F64:  DATA 46,20
00F66:  DATA 7C,20
00F68:  DATA 49,56
00F6A:  DATA 20,44
00F6C:  DATA 41,54
00F6E:  DATA 41,20
00F70:  DATA 20,20
00F72:  DATA 7C,20
00F74:  DATA 55,73
00F76:  DATA 65,20
00F78:  DATA 43,6F
00F7A:  DATA 75,6E
00F7C:  DATA 74,65
00F7E:  DATA 72,20
00F80:  DATA 20,20
00F82:  DATA 20,20
00F84:  DATA 20,3A
00F86:  DATA 20,30
00F88:  DATA 78,25
00F8A:  DATA 30,38
00F8C:  DATA 4C,58
00F8E:  DATA 0D,0A
00F90:  DATA 00,00
00F92:  DATA 09,7C
00F94:  DATA 20,4D
00F96:  DATA 49,53
00F98:  DATA 46,20
00F9A:  DATA 7C,20
00F9C:  DATA 49,56
00F9E:  DATA 20,44
00FA0:  DATA 41,54
00FA2:  DATA 41,20
00FA4:  DATA 20,20
00FA6:  DATA 7C,20
00FA8:  DATA 55,6E
00FAA:  DATA 63,6F
00FAC:  DATA 70,79
00FAE:  DATA 65,64
00FB0:  DATA 20,43
00FB2:  DATA 6F,75
00FB4:  DATA 6E,74
00FB6:  DATA 65,72
00FB8:  DATA 20,3A
00FBA:  DATA 20,30
00FBC:  DATA 78,25
00FBE:  DATA 30,38
00FC0:  DATA 4C,58
00FC2:  DATA 0D,0A
00FC4:  DATA 00,00
00FC6:  DATA 09,7C
00FC8:  DATA 20,4D
00FCA:  DATA 49,53
00FCC:  DATA 46,20
00FCE:  DATA 7C,20
00FD0:  DATA 49,56
00FD2:  DATA 20,44
00FD4:  DATA 41,54
00FD6:  DATA 41,20
00FD8:  DATA 20,20
00FDA:  DATA 7C,20
00FDC:  DATA 52,65
00FDE:  DATA 73,65
00FE0:  DATA 72,76
00FE2:  DATA 65,20
00FE4:  DATA 43,6F
00FE6:  DATA 75,6E
00FE8:  DATA 74,65
00FEA:  DATA 72,31
00FEC:  DATA 20,3A
00FEE:  DATA 20,30
00FF0:  DATA 78,25
00FF2:  DATA 30,32
00FF4:  DATA 58,0D
00FF6:  DATA 0A,00
00FF8:  DATA 09,7C
00FFA:  DATA 20,4D
00FFC:  DATA 49,53
00FFE:  DATA 46,20
01000:  DATA 7C,20
01002:  DATA 49,56
01004:  DATA 20,44
01006:  DATA 41,54
01008:  DATA 41,20
0100A:  DATA 20,20
0100C:  DATA 7C,20
0100E:  DATA 52,65
01010:  DATA 73,65
01012:  DATA 72,76
01014:  DATA 65,20
01016:  DATA 43,6F
01018:  DATA 75,6E
0101A:  DATA 74,65
0101C:  DATA 72,32
0101E:  DATA 20,3A
01020:  DATA 20,30
01022:  DATA 78,25
01024:  DATA 30,32
01026:  DATA 58,0D
01028:  DATA 0A,00
0102A:  DATA 09,43
0102C:  DATA 6F,6D
0102E:  DATA 70,6C
01030:  DATA 65,74
01032:  DATA 65,0D
01034:  DATA 0A,00
01036:  DATA 43,52
01038:  DATA 43,20
0103A:  DATA 76,65
0103C:  DATA 72,69
0103E:  DATA 66,69
01040:  DATA 63,61
01042:  DATA 74,69
01044:  DATA 6F,6E
01046:  DATA 20,70
01048:  DATA 61,73
0104A:  DATA 73,65
0104C:  DATA 64,20
0104E:  DATA 6F,6E
01050:  DATA 20,61
01052:  DATA 74,74
01054:  DATA 65,6D
01056:  DATA 70,74
01058:  DATA 20,25
0105A:  DATA 64,0D
0105C:  DATA 0A,00
0105E:  DATA 45,72
01060:  DATA 72,6F
01062:  DATA 72,3A
01064:  DATA 20,43
01066:  DATA 52,43
01068:  DATA 20,76
0106A:  DATA 65,72
0106C:  DATA 69,66
0106E:  DATA 69,63
01070:  DATA 61,74
01072:  DATA 69,6F
01074:  DATA 6E,20
01076:  DATA 66,61
01078:  DATA 69,6C
0107A:  DATA 65,64
0107C:  DATA 20,61
0107E:  DATA 66,74
01080:  DATA 65,72
01082:  DATA 20,25
01084:  DATA 64,20
01086:  DATA 61,74
01088:  DATA 74,65
0108A:  DATA 6D,70
0108C:  DATA 74,73
0108E:  DATA 0D,0A
01090:  DATA 00,00
01092:  DATA 0D,0A
01094:  DATA 5F,5F
01096:  DATA 5F,5F
01098:  DATA 5F,5F
0109A:  DATA 5F,5F
0109C:  DATA 5F,5F
0109E:  DATA 5F,5F
010A0:  DATA 5F,5F
010A2:  DATA 5F,5F
010A4:  DATA 5F,5F
010A6:  DATA 5F,5F
010A8:  DATA 5F,5F
010AA:  DATA 5F,5F
010AC:  DATA 5F,5F
010AE:  DATA 5F,5F
010B0:  DATA 5F,5F
010B2:  DATA 0D,0A
010B4:  DATA 5F,5F
010B6:  DATA 5F,5F
010B8:  DATA 5F,53
010BA:  DATA 74,61
010BC:  DATA 72,74
010BE:  DATA 20,65
010C0:  DATA 78,65
010C2:  DATA 63,75
010C4:  DATA 74,65
010C6:  DATA 5F,6D
010C8:  DATA 69,73
010CA:  DATA 73,69
010CC:  DATA 6F,6E
010CE:  DATA 5F,5F
010D0:  DATA 5F,5F
010D2:  DATA 5F,0D
010D4:  DATA 0A,0D
010D6:  DATA 0A,00
010D8:  DATA 43,6F
010DA:  DATA 6D,6D
010DC:  DATA 61,6E
010DE:  DATA 64,20
010E0:  DATA 49,44
010E2:  DATA 3A,20
010E4:  DATA 25,58
010E6:  DATA 0D,0A
010E8:  DATA 0D,0A
010EA:  DATA 00,00
010EC:  DATA 09,09
010EE:  DATA 2D,3E
010F0:  DATA 20,49
010F2:  DATA 6E,76
010F4:  DATA 61,6C
010F6:  DATA 69,64
010F8:  DATA 20,43
010FA:  DATA 4D,44
010FC:  DATA 20,49
010FE:  DATA 44,21
01100:  DATA 0D,0A
01102:  DATA 00,00
01104:  DATA 0D,0A
01106:  DATA 5F,5F
01108:  DATA 5F,5F
0110A:  DATA 5F,5F
0110C:  DATA 45,6E
0110E:  DATA 64,20
01110:  DATA 65,78
01112:  DATA 65,63
01114:  DATA 75,74
01116:  DATA 65,5F
01118:  DATA 6D,69
0111A:  DATA 73,73
0111C:  DATA 69,6F
0111E:  DATA 6E,5F
01120:  DATA 5F,5F
01122:  DATA 5F,5F
01124:  DATA 5F,0D
01126:  DATA 0A,5F
01128:  DATA 5F,5F
0112A:  DATA 5F,5F
0112C:  DATA 5F,5F
0112E:  DATA 5F,5F
01130:  DATA 5F,5F
01132:  DATA 5F,5F
01134:  DATA 5F,5F
01136:  DATA 5F,5F
01138:  DATA 5F,5F
0113A:  DATA 5F,5F
0113C:  DATA 5F,5F
0113E:  DATA 5F,5F
01140:  DATA 5F,5F
01142:  DATA 5F,5F
01144:  DATA 5F,5F
01146:  DATA 0D,0A
01148:  DATA 00,00
0114A:  DATA 53,74
0114C:  DATA 61,72
0114E:  DATA 74,20
01150:  DATA 65,78
01152:  DATA 65,63
01154:  DATA 75,74
01156:  DATA 65,5F
01158:  DATA 63,6F
0115A:  DATA 6D,6D
0115C:  DATA 61,6E
0115E:  DATA 64,0D
01160:  DATA 0A,00
01162:  DATA 09,2D
01164:  DATA 3E,20
01166:  DATA 55,70
01168:  DATA 6C,69
0116A:  DATA 6E,6B
0116C:  DATA 20,63
0116E:  DATA 6F,6D
01170:  DATA 6D,61
01172:  DATA 6E,64
01174:  DATA 0D,0A
01176:  DATA 00,00
01178:  DATA 09,20
0117A:  DATA 20,20
0117C:  DATA 54,72
0117E:  DATA 61,6E
01180:  DATA 73,6D
01182:  DATA 69,74
01184:  DATA 20,41
01186:  DATA 63,6B
01188:  DATA 6E,6F
0118A:  DATA 6C,65
0118C:  DATA 67,64
0118E:  DATA 65,0D
01190:  DATA 0A,00
01192:  DATA 09,2D
01194:  DATA 3E,20
01196:  DATA 53,74
01198:  DATA 61,74
0119A:  DATA 75,73
0119C:  DATA 20,63
0119E:  DATA 68,65
011A0:  DATA 63,6B
011A2:  DATA 0D,0A
011A4:  DATA 00,00
011A6:  DATA 09,20
011A8:  DATA 20,20
011AA:  DATA 54,72
011AC:  DATA 61,6E
011AE:  DATA 73,6D
011B0:  DATA 69,74
011B2:  DATA 20,4D
011B4:  DATA 49,53
011B6:  DATA 20,4D
011B8:  DATA 43,55
011BA:  DATA 20,53
011BC:  DATA 74,61
011BE:  DATA 74,75
011C0:  DATA 73,0D
011C2:  DATA 0A,00
011C4:  DATA 66,69
011C6:  DATA 6E,69
011C8:  DATA 73,68
011CA:  DATA 65,64
011CC:  DATA 20,69
011CE:  DATA 6E,20
011D0:  DATA 73,74
011D2:  DATA 61,74
011D4:  DATA 75,73
011D6:  DATA 5F,63
011D8:  DATA 68,65
011DA:  DATA 63,6B
011DC:  DATA 0D,0A
011DE:  DATA 00,00
011E0:  DATA 09,2D
011E2:  DATA 3E,20
011E4:  DATA 53,4D
011E6:  DATA 46,20
011E8:  DATA 61,76
011EA:  DATA 61,69
011EC:  DATA 6C,61
011EE:  DATA 62,6C
011F0:  DATA 65,20
011F2:  DATA 63,68
011F4:  DATA 65,63
011F6:  DATA 6B,0D
011F8:  DATA 0A,00
011FA:  DATA 09,20
011FC:  DATA 20,20
011FE:  DATA 54,72
01200:  DATA 61,6E
01202:  DATA 73,6D
01204:  DATA 69,74
01206:  DATA 20,41
01208:  DATA 63,6B
0120A:  DATA 6E,6F
0120C:  DATA 77,6C
0120E:  DATA 65,64
01210:  DATA 67,65
01212:  DATA 6D,65
01214:  DATA 6E,74
01216:  DATA 0D,0A
01218:  DATA 00,00
0121A:  DATA 09,09
0121C:  DATA 2D,3E
0121E:  DATA 20,64
01220:  DATA 65,6E
01222:  DATA 69,65
01224:  DATA 64,0D
01226:  DATA 0A,00
01228:  DATA 09,09
0122A:  DATA 2D,3E
0122C:  DATA 20,61
0122E:  DATA 6C,6C
01230:  DATA 6F,77
01232:  DATA 65,64
01234:  DATA 0D,0A
01236:  DATA 00,00
01238:  DATA 09,09
0123A:  DATA 2D,3E
0123C:  DATA 20,64
0123E:  DATA 65,71
01240:  DATA 75,65
01242:  DATA 75,65
01244:  DATA 20,4E
01246:  DATA 55,4C
01248:  DATA 4C,20
0124A:  DATA 28,62
0124C:  DATA 72,65
0124E:  DATA 61,6B
01250:  DATA 29,0D
01252:  DATA 0A,00
01254:  DATA 09,09
01256:  DATA 2D,3E
01258:  DATA 20,44
0125A:  DATA 65,71
0125C:  DATA 75,65
0125E:  DATA 75,65
01260:  DATA 64,3A
01262:  DATA 20,66
01264:  DATA 75,6E
01266:  DATA 63,3D
01268:  DATA 25,75
0126A:  DATA 20,6D
0126C:  DATA 69,73
0126E:  DATA 73,69
01270:  DATA 6F,6E
01272:  DATA 3D,25
01274:  DATA 75,20
01276:  DATA 73,69
01278:  DATA 7A,65
0127A:  DATA 3D,25
0127C:  DATA 6C,64
0127E:  DATA 20,61
01280:  DATA 64,64
01282:  DATA 72,3D
01284:  DATA 25,6C
01286:  DATA 64,0D
01288:  DATA 0A,00
0128A:  DATA 09,09
0128C:  DATA 20,20
0128E:  DATA 20,55
01290:  DATA 6E,6B
01292:  DATA 6E,6F
01294:  DATA 77,6E
01296:  DATA 20,66
01298:  DATA 75,6E
0129A:  DATA 63,5F
0129C:  DATA 74,79
0129E:  DATA 70,65
012A0:  DATA 3D,25
012A2:  DATA 75,0D
012A4:  DATA 0A,00
012A6:  DATA 09,09
012A8:  DATA 2D,3E
012AA:  DATA 20,43
012AC:  DATA 6F,6D
012AE:  DATA 70,6C
012B0:  DATA 65,74
012B2:  DATA 65,64
012B4:  DATA 20,25
012B6:  DATA 75,20
012B8:  DATA 6F,70
012BA:  DATA 65,72
012BC:  DATA 61,74
012BE:  DATA 69,6F
012C0:  DATA 6E,73
012C2:  DATA 0D,0A
012C4:  DATA 00,00
012C6:  DATA 53,74
012C8:  DATA 61,72
012CA:  DATA 74,20
012CC:  DATA 4D,4F
012CE:  DATA 44,45
012D0:  DATA 20,44
012D2:  DATA 55,4D
012D4:  DATA 4D,59
012D6:  DATA 0D,0A
012D8:  DATA 00,00
012DA:  DATA 09,4D
012DC:  DATA 4F,44
012DE:  DATA 45,20
012E0:  DATA 20,20
012E2:  DATA 20,20
012E4:  DATA 3A,20
012E6:  DATA 25,30
012E8:  DATA 32,58
012EA:  DATA 0D,0A
012EC:  DATA 00,00
012EE:  DATA 09,50
012F0:  DATA 61,72
012F2:  DATA 61,6D
012F4:  DATA 31,20
012F6:  DATA 20,20
012F8:  DATA 3A,20
012FA:  DATA 30,78
012FC:  DATA 25,30
012FE:  DATA 38,4C
01300:  DATA 58,0D
01302:  DATA 0A,00
01304:  DATA 09,50
01306:  DATA 61,72
01308:  DATA 61,6D
0130A:  DATA 32,20
0130C:  DATA 20,20
0130E:  DATA 3A,20
01310:  DATA 30,78
01312:  DATA 25,30
01314:  DATA 34,4C
01316:  DATA 58,0D
01318:  DATA 0A,00
0131A:  DATA 45,6E
0131C:  DATA 64,20
0131E:  DATA 4D,4F
01320:  DATA 44,45
01322:  DATA 20,44
01324:  DATA 55,4D
01326:  DATA 4D,59
01328:  DATA 0D,0A
0132A:  DATA 00,00
0132C:  DATA 53,74
0132E:  DATA 61,72
01330:  DATA 74,20
01332:  DATA 4D,4F
01334:  DATA 44,45
01336:  DATA 20,54
01338:  DATA 45,53
0133A:  DATA 54,20
0133C:  DATA 49,56
0133E:  DATA 0D,0A
01340:  DATA 00,00
01342:  DATA 09,53
01344:  DATA 77,65
01346:  DATA 65,70
01348:  DATA 20,73
0134A:  DATA 74,65
0134C:  DATA 70,20
0134E:  DATA 3A,20
01350:  DATA 25,75
01352:  DATA 0D,0A
01354:  DATA 00,00
01356:  DATA 45,6E
01358:  DATA 64,20
0135A:  DATA 4D,4F
0135C:  DATA 44,45
0135E:  DATA 20,54
01360:  DATA 45,53
01362:  DATA 54,20
01364:  DATA 49,56
01366:  DATA 0D,0A
01368:  DATA 00,00
0136A:  DATA 53,74
0136C:  DATA 61,72
0136E:  DATA 74,20
01370:  DATA 4D,4F
01372:  DATA 44,45
01374:  DATA 20,4D
01376:  DATA 45,41
01378:  DATA 53,20
0137A:  DATA 49,56
0137C:  DATA 0D,0A
0137E:  DATA 00,00
01380:  DATA 09,49
01382:  DATA 44,3A
01384:  DATA 20,25
01386:  DATA 30,32
01388:  DATA 58,0D
0138A:  DATA 0A,00
0138C:  DATA 09,53
0138E:  DATA 6C,65
01390:  DATA 65,70
01392:  DATA 20,54
01394:  DATA 69,6D
01396:  DATA 65,3A
01398:  DATA 20,25
0139A:  DATA 30,34
0139C:  DATA 4C,58
0139E:  DATA 20,6D
013A0:  DATA 73,0D
013A2:  DATA 0A,00
013A4:  DATA 09,43
013A6:  DATA 75,72
013A8:  DATA 72,65
013AA:  DATA 6E,74
013AC:  DATA 20,54
013AE:  DATA 68,72
013B0:  DATA 65,73
013B2:  DATA 68,6F
013B4:  DATA 6C,64
013B6:  DATA 3A,20
013B8:  DATA 25,30
013BA:  DATA 34,4C
013BC:  DATA 58,20
013BE:  DATA 6D,41
013C0:  DATA 0D,0A
013C2:  DATA 00,00
013C4:  DATA 09,50
013C6:  DATA 44,20
013C8:  DATA 54,68
013CA:  DATA 72,65
013CC:  DATA 73,68
013CE:  DATA 6F,6C
013D0:  DATA 64,3A
013D2:  DATA 20,25
013D4:  DATA 30,34
013D6:  DATA 4C,58
013D8:  DATA 20,6D
013DA:  DATA 41,0D
013DC:  DATA 0A,00
013DE:  DATA 09,43
013E0:  DATA 75,72
013E2:  DATA 72,65
013E4:  DATA 6E,74
013E6:  DATA 20,4C
013E8:  DATA 69,6D
013EA:  DATA 69,74
013EC:  DATA 3A,20
013EE:  DATA 25,30
013F0:  DATA 34,4C
013F2:  DATA 58,20
013F4:  DATA 6D,41
013F6:  DATA 0D,0A
013F8:  DATA 00,00
013FA:  DATA 09,4D
013FC:  DATA 65,61
013FE:  DATA 73,75
01400:  DATA 72,65
01402:  DATA 6D,65
01404:  DATA 6E,74
01406:  DATA 20,54
01408:  DATA 69,6D
0140A:  DATA 65,3A
0140C:  DATA 20,25
0140E:  DATA 30,34
01410:  DATA 4C,58
01412:  DATA 20,73
01414:  DATA 0D,0A
01416:  DATA 00,00
01418:  DATA 09,49
0141A:  DATA 73,20
0141C:  DATA 46,69
0141E:  DATA 6E,69
01420:  DATA 73,68
01422:  DATA 65,64
01424:  DATA 3A,20
01426:  DATA 25,75
01428:  DATA 0D,0A
0142A:  DATA 00,00
0142C:  DATA 45,6E
0142E:  DATA 71,75
01430:  DATA 65,75
01432:  DATA 65,20
01434:  DATA 46,6C
01436:  DATA 61,73
01438:  DATA 68,20
0143A:  DATA 4F,70
0143C:  DATA 65,72
0143E:  DATA 61,74
01440:  DATA 69,6F
01442:  DATA 6E,0D
01444:  DATA 0A,00
01446:  DATA 4D,69
01448:  DATA 73,73
0144A:  DATA 69,6F
0144C:  DATA 6E,20
0144E:  DATA 49,44
01450:  DATA 3A,20
01452:  DATA 25,30
01454:  DATA 32,58
01456:  DATA 0D,0A
01458:  DATA 00,00
0145A:  DATA 46,75
0145C:  DATA 6E,63
0145E:  DATA 74,69
01460:  DATA 6F,6E
01462:  DATA 20,54
01464:  DATA 79,70
01466:  DATA 65,3A
01468:  DATA 20,25
0146A:  DATA 30,32
0146C:  DATA 58,0D
0146E:  DATA 0A,00
01470:  DATA 57,72
01472:  DATA 69,74
01474:  DATA 65,20
01476:  DATA 4D,6F
01478:  DATA 64,65
0147A:  DATA 3A,20
0147C:  DATA 25,30
0147E:  DATA 32,58
01480:  DATA 0D,0A
01482:  DATA 00,00
01484:  DATA 53,6F
01486:  DATA 75,72
01488:  DATA 63,65
0148A:  DATA 20,54
0148C:  DATA 79,70
0148E:  DATA 65,3A
01490:  DATA 20,25
01492:  DATA 30,32
01494:  DATA 58,0D
01496:  DATA 0A,00
01498:  DATA 53,74
0149A:  DATA 61,72
0149C:  DATA 74,20
0149E:  DATA 41,64
014A0:  DATA 64,72
014A2:  DATA 65,73
014A4:  DATA 73,3A
014A6:  DATA 20,25
014A8:  DATA 30,34
014AA:  DATA 58,0D
014AC:  DATA 0A,00
014AE:  DATA 53,69
014B0:  DATA 7A,65
014B2:  DATA 3A,20
014B4:  DATA 25,30
014B6:  DATA 34,58
014B8:  DATA 0D,0A
014BA:  DATA 00,00
014BC:  DATA 45,6E
014BE:  DATA 64,20
014C0:  DATA 4D,4F
014C2:  DATA 44,45
014C4:  DATA 20,4D
014C6:  DATA 45,41
014C8:  DATA 53,20
014CA:  DATA 49,56
014CC:  DATA 20,6D
014CE:  DATA 69,73
014D0:  DATA 73,69
014D2:  DATA 6F,6E
014D4:  DATA 0D,0A
014D6:  DATA 00,00
014D8:  DATA 53,74
014DA:  DATA 61,72
014DC:  DATA 74,20
014DE:  DATA 46,6C
014E0:  DATA 61,73
014E2:  DATA 68,20
014E4:  DATA 45,72
014E6:  DATA 61,73
014E8:  DATA 65,20
014EA:  DATA 41,6C
014EC:  DATA 6C,0D
014EE:  DATA 0A,00
014F0:  DATA 45,6E
014F2:  DATA 64,20
014F4:  DATA 46,6C
014F6:  DATA 61,73
014F8:  DATA 68,20
014FA:  DATA 45,72
014FC:  DATA 61,73
014FE:  DATA 65,20
01500:  DATA 41,6C
01502:  DATA 6C,0D
01504:  DATA 0A,00
01506:  DATA 53,74
01508:  DATA 61,72
0150A:  DATA 74,20
0150C:  DATA 46,6C
0150E:  DATA 61,73
01510:  DATA 68,20
01512:  DATA 45,72
01514:  DATA 61,73
01516:  DATA 65,20
01518:  DATA 31,20
0151A:  DATA 53,65
0151C:  DATA 63,74
0151E:  DATA 6F,72
01520:  DATA 0D,0A
01522:  DATA 00,00
01524:  DATA 09,53
01526:  DATA 65,63
01528:  DATA 74,6F
0152A:  DATA 72,20
0152C:  DATA 41,64
0152E:  DATA 64,72
01530:  DATA 65,73
01532:  DATA 73,3A
01534:  DATA 20,30
01536:  DATA 78,25
01538:  DATA 30,38
0153A:  DATA 4C,58
0153C:  DATA 0D,0A
0153E:  DATA 00,00
01540:  DATA 45,6E
01542:  DATA 64,20
01544:  DATA 46,6C
01546:  DATA 61,73
01548:  DATA 68,20
0154A:  DATA 45,72
0154C:  DATA 61,73
0154E:  DATA 65,20
01550:  DATA 31,20
01552:  DATA 53,65
01554:  DATA 63,74
01556:  DATA 6F,72
01558:  DATA 0D,0A
0155A:  DATA 00,00
0155C:  DATA 53,74
0155E:  DATA 61,72
01560:  DATA 74,20
01562:  DATA 46,6C
01564:  DATA 61,73
01566:  DATA 68,20
01568:  DATA 43,6F
0156A:  DATA 70,79
0156C:  DATA 20,31
0156E:  DATA 20,53
01570:  DATA 65,63
01572:  DATA 74,6F
01574:  DATA 72,0D
01576:  DATA 0A,00
01578:  DATA 09,53
0157A:  DATA 75,62
0157C:  DATA 73,65
0157E:  DATA 63,74
01580:  DATA 6F,72
01582:  DATA 20,41
01584:  DATA 64,64
01586:  DATA 72,65
01588:  DATA 73,73
0158A:  DATA 3A,20
0158C:  DATA 30,78
0158E:  DATA 25,30
01590:  DATA 38,4C
01592:  DATA 58,0D
01594:  DATA 0A,00
01596:  DATA 45,6E
01598:  DATA 64,20
0159A:  DATA 46,6C
0159C:  DATA 61,73
0159E:  DATA 68,20
015A0:  DATA 43,6F
015A2:  DATA 70,79
015A4:  DATA 20,31
015A6:  DATA 20,53
015A8:  DATA 65,63
015AA:  DATA 74,6F
015AC:  DATA 72,0D
015AE:  DATA 0A,00
015B0:  DATA 53,74
015B2:  DATA 61,72
015B4:  DATA 74,20
015B6:  DATA 46,6C
015B8:  DATA 61,73
015BA:  DATA 68,20
015BC:  DATA 45,72
015BE:  DATA 61,73
015C0:  DATA 65,20
015C2:  DATA 36,34
015C4:  DATA 6B,42
015C6:  DATA 79,74
015C8:  DATA 65,20
015CA:  DATA 53,75
015CC:  DATA 62,73
015CE:  DATA 65,63
015D0:  DATA 74,6F
015D2:  DATA 72,0D
015D4:  DATA 0A,00
015D6:  DATA 09,53
015D8:  DATA 75,62
015DA:  DATA 73,65
015DC:  DATA 63,74
015DE:  DATA 6F,72
015E0:  DATA 20,41
015E2:  DATA 64,64
015E4:  DATA 72,65
015E6:  DATA 73,73
015E8:  DATA 3A,20
015EA:  DATA 30,78
015EC:  DATA 25,30
015EE:  DATA 38,4C
015F0:  DATA 58,0D
015F2:  DATA 0A,00
015F4:  DATA 45,6E
015F6:  DATA 64,20
015F8:  DATA 46,6C
015FA:  DATA 61,73
015FC:  DATA 68,20
015FE:  DATA 45,72
01600:  DATA 61,73
01602:  DATA 65,20
01604:  DATA 36,34
01606:  DATA 6B,42
01608:  DATA 79,74
0160A:  DATA 65,20
0160C:  DATA 53,75
0160E:  DATA 62,73
01610:  DATA 65,63
01612:  DATA 74,6F
01614:  DATA 72,0D
01616:  DATA 0A,00
01618:  DATA 53,74
0161A:  DATA 61,72
0161C:  DATA 74,20
0161E:  DATA 46,6C
01620:  DATA 61,73
01622:  DATA 68,20
01624:  DATA 57,72
01626:  DATA 69,74
01628:  DATA 65,20
0162A:  DATA 44,65
0162C:  DATA 6D,6F
0162E:  DATA 0D,0A
01630:  DATA 00,00
01632:  DATA 09,4D
01634:  DATA 4F,44
01636:  DATA 45,20
01638:  DATA 20,20
0163A:  DATA 20,20
0163C:  DATA 3A,20
0163E:  DATA 25,30
01640:  DATA 32,58
01642:  DATA 0D,0A
01644:  DATA 00,00
01646:  DATA 09,41
01648:  DATA 64,64
0164A:  DATA 72,65
0164C:  DATA 73,73
0164E:  DATA 20,20
01650:  DATA 3A,20
01652:  DATA 30,78
01654:  DATA 25,30
01656:  DATA 38,4C
01658:  DATA 58,0D
0165A:  DATA 0A,00
0165C:  DATA 09,50
0165E:  DATA 61,63
01660:  DATA 6B,65
01662:  DATA 74,4E
01664:  DATA 75,6D
01666:  DATA 3A,20
01668:  DATA 30,78
0166A:  DATA 25,30
0166C:  DATA 34,4C
0166E:  DATA 58,0D
01670:  DATA 0A,00
01672:  DATA 57,72
01674:  DATA 69,74
01676:  DATA 65,20
01678:  DATA 44,61
0167A:  DATA 74,61
0167C:  DATA 0D,0A
0167E:  DATA 00,00
01680:  DATA 45,6E
01682:  DATA 64,20
01684:  DATA 46,6C
01686:  DATA 61,73
01688:  DATA 68,20
0168A:  DATA 57,72
0168C:  DATA 69,74
0168E:  DATA 65,20
01690:  DATA 44,65
01692:  DATA 6D,6F
01694:  DATA 0D,0A
01696:  DATA 00,00
01698:  DATA 53,74
0169A:  DATA 61,72
0169C:  DATA 74,20
0169E:  DATA 46,6C
016A0:  DATA 61,73
016A2:  DATA 68,20
016A4:  DATA 57,72
016A6:  DATA 69,74
016A8:  DATA 65,20
016AA:  DATA 34,6B
016AC:  DATA 42,79
016AE:  DATA 74,65
016B0:  DATA 20,53
016B2:  DATA 75,62
016B4:  DATA 73,65
016B6:  DATA 63,74
016B8:  DATA 6F,72
016BA:  DATA 0D,0A
016BC:  DATA 00,00
016BE:  DATA 45,6E
016C0:  DATA 64,20
016C2:  DATA 46,6C
016C4:  DATA 61,73
016C6:  DATA 68,20
016C8:  DATA 57,72
016CA:  DATA 69,74
016CC:  DATA 65,20
016CE:  DATA 34,6B
016D0:  DATA 42,79
016D2:  DATA 74,65
016D4:  DATA 20,53
016D6:  DATA 75,62
016D8:  DATA 73,65
016DA:  DATA 63,74
016DC:  DATA 6F,72
016DE:  DATA 0D,0A
016E0:  DATA 00,00
016E2:  DATA 53,74
016E4:  DATA 61,72
016E6:  DATA 74,20
016E8:  DATA 46,6C
016EA:  DATA 61,73
016EC:  DATA 68,20
016EE:  DATA 52,65
016F0:  DATA 61,64
016F2:  DATA 0D,0A
016F4:  DATA 00,00
016F6:  DATA 09,4D
016F8:  DATA 4F,44
016FA:  DATA 45,20
016FC:  DATA 20,20
016FE:  DATA 20,20
01700:  DATA 3A,20
01702:  DATA 25,30
01704:  DATA 32,58
01706:  DATA 0D,0A
01708:  DATA 00,00
0170A:  DATA 09,41
0170C:  DATA 64,64
0170E:  DATA 72,65
01710:  DATA 73,73
01712:  DATA 20,20
01714:  DATA 3A,20
01716:  DATA 30,78
01718:  DATA 25,30
0171A:  DATA 38,4C
0171C:  DATA 58,0D
0171E:  DATA 0A,00
01720:  DATA 09,50
01722:  DATA 61,63
01724:  DATA 6B,65
01726:  DATA 74,4E
01728:  DATA 75,6D
0172A:  DATA 3A,20
0172C:  DATA 30,78
0172E:  DATA 25,30
01730:  DATA 34,4C
01732:  DATA 58,0D
01734:  DATA 0A,00
01736:  DATA 52,45
01738:  DATA 41,44
0173A:  DATA 20,44
0173C:  DATA 41,54
0173E:  DATA 41,0D
01740:  DATA 0A,00
01742:  DATA 4D,69
01744:  DATA 73,73
01746:  DATA 69,6F
01748:  DATA 6E,20
0174A:  DATA 46,6C
0174C:  DATA 61,73
0174E:  DATA 68,20
01750:  DATA 69,73
01752:  DATA 20,6E
01754:  DATA 6F,74
01756:  DATA 20,63
01758:  DATA 6F,6E
0175A:  DATA 6E,65
0175C:  DATA 63,74
0175E:  DATA 65,64
01760:  DATA 0D,0A
01762:  DATA 00,00
01764:  DATA 45,6E
01766:  DATA 64,20
01768:  DATA 46,6C
0176A:  DATA 61,73
0176C:  DATA 68,20
0176E:  DATA 52,65
01770:  DATA 61,64
01772:  DATA 0D,0A
01774:  DATA 00,00
01776:  DATA 53,74
01778:  DATA 61,72
0177A:  DATA 74,20
0177C:  DATA 46,6C
0177E:  DATA 61,73
01780:  DATA 68,20
01782:  DATA 52,65
01784:  DATA 61,64
01786:  DATA 20,41
01788:  DATA 64,64
0178A:  DATA 72,65
0178C:  DATA 73,73
0178E:  DATA 0D,0A
01790:  DATA 00,00
01792:  DATA 52,65
01794:  DATA 61,64
01796:  DATA 20,44
01798:  DATA 61,74
0179A:  DATA 61,3A
0179C:  DATA 20,25
0179E:  DATA 30,32
017A0:  DATA 58,20
017A2:  DATA 25,30
017A4:  DATA 32,58
017A6:  DATA 20,25
017A8:  DATA 30,32
017AA:  DATA 58,20
017AC:  DATA 25,30
017AE:  DATA 32,58
017B0:  DATA 0D,0A
017B2:  DATA 00,00
017B4:  DATA 45,6E
017B6:  DATA 64,20
017B8:  DATA 46,6C
017BA:  DATA 61,73
017BC:  DATA 68,20
017BE:  DATA 52,65
017C0:  DATA 61,64
017C2:  DATA 20,41
017C4:  DATA 64,64
017C6:  DATA 72,65
017C8:  DATA 73,73
017CA:  DATA 0D,0A
017CC:  DATA 00,00
017CE:  DATA 53,74
017D0:  DATA 61,72
017D2:  DATA 74,20
017D4:  DATA 46,6C
017D6:  DATA 61,73
017D8:  DATA 68,20
017DA:  DATA 45,72
017DC:  DATA 61,73
017DE:  DATA 65,20
017E0:  DATA 61,6E
017E2:  DATA 64,20
017E4:  DATA 52,65
017E6:  DATA 73,65
017E8:  DATA 74,0D
017EA:  DATA 0A,00
017EC:  DATA 45,6E
017EE:  DATA 64,20
017F0:  DATA 46,6C
017F2:  DATA 61,73
017F4:  DATA 68,20
017F6:  DATA 45,72
017F8:  DATA 61,73
017FA:  DATA 65,20
017FC:  DATA 61,6E
017FE:  DATA 64,20
01800:  DATA 52,65
01802:  DATA 73,65
01804:  DATA 74,0D
01806:  DATA 0A,00
01808:  DATA 53,74
0180A:  DATA 61,72
0180C:  DATA 74,20
0180E:  DATA 46,6C
01810:  DATA 61,73
01812:  DATA 68,20
01814:  DATA 53,4D
01816:  DATA 46,20
01818:  DATA 43,6F
0181A:  DATA 70,79
0181C:  DATA 0D,0A
0181E:  DATA 00,00
01820:  DATA 45,6E
01822:  DATA 64,20
01824:  DATA 46,6C
01826:  DATA 61,73
01828:  DATA 68,20
0182A:  DATA 53,4D
0182C:  DATA 46,20
0182E:  DATA 43,6F
01830:  DATA 70,79
01832:  DATA 0D,0A
01834:  DATA 00,00
01836:  DATA 53,74
01838:  DATA 61,72
0183A:  DATA 74,20
0183C:  DATA 46,6C
0183E:  DATA 61,73
01840:  DATA 68,20
01842:  DATA 53,4D
01844:  DATA 46,20
01846:  DATA 52,65
01848:  DATA 61,64
0184A:  DATA 0D,0A
0184C:  DATA 00,00
0184E:  DATA 52,65
01850:  DATA 61,64
01852:  DATA 20,44
01854:  DATA 61,74
01856:  DATA 61,3A
01858:  DATA 20,00
0185A:  DATA 0D,0A
0185C:  DATA 45,6E
0185E:  DATA 64,20
01860:  DATA 46,6C
01862:  DATA 61,73
01864:  DATA 68,20
01866:  DATA 53,4D
01868:  DATA 46,20
0186A:  DATA 52,65
0186C:  DATA 61,64
0186E:  DATA 0D,0A
01870:  DATA 00,00
01872:  DATA 53,74
01874:  DATA 61,72
01876:  DATA 74,20
01878:  DATA 46,6C
0187A:  DATA 61,73
0187C:  DATA 68,20
0187E:  DATA 53,4D
01880:  DATA 46,20
01882:  DATA 45,72
01884:  DATA 61,73
01886:  DATA 65,0D
01888:  DATA 0A,00
0188A:  DATA 45,6E
0188C:  DATA 64,20
0188E:  DATA 46,6C
01890:  DATA 61,73
01892:  DATA 68,20
01894:  DATA 53,4D
01896:  DATA 46,20
01898:  DATA 45,72
0189A:  DATA 61,73
0189C:  DATA 65,0D
0189E:  DATA 0A,00
018A0:  DATA 53,74
018A2:  DATA 61,72
018A4:  DATA 74,20
018A6:  DATA 46,6C
018A8:  DATA 61,73
018AA:  DATA 68,20
018AC:  DATA 41,64
018AE:  DATA 64,72
018B0:  DATA 65,73
018B2:  DATA 73,20
018B4:  DATA 52,65
018B6:  DATA 73,65
018B8:  DATA 74,0D
018BA:  DATA 0A,00
018BC:  DATA 45,6E
018BE:  DATA 64,20
018C0:  DATA 46,6C
018C2:  DATA 61,73
018C4:  DATA 68,20
018C6:  DATA 41,64
018C8:  DATA 64,72
018CA:  DATA 65,73
018CC:  DATA 73,20
018CE:  DATA 52,65
018D0:  DATA 73,65
018D2:  DATA 74,0D
018D4:  DATA 0A,00
018D6:  DATA 53,4D
018D8:  DATA 46,20
018DA:  DATA 69,73
018DC:  DATA 20,6E
018DE:  DATA 6F,74
018E0:  DATA 20,63
018E2:  DATA 6F,6E
018E4:  DATA 6E,65
018E6:  DATA 63,74
018E8:  DATA 65,64
018EA:  DATA 0D,0A
018EC:  DATA 00,00
018EE:  DATA 53,74
018F0:  DATA 61,72
018F2:  DATA 74,20
018F4:  DATA 46,6C
018F6:  DATA 61,73
018F8:  DATA 68,20
018FA:  DATA 53,4D
018FC:  DATA 46,20
018FE:  DATA 52,65
01900:  DATA 61,64
01902:  DATA 20,46
01904:  DATA 6F,72
01906:  DATA 63,65
01908:  DATA 0D,0A
0190A:  DATA 00,00
0190C:  DATA 09,41
0190E:  DATA 64,64
01910:  DATA 72,65
01912:  DATA 73,73
01914:  DATA 20,20
01916:  DATA 3A,20
01918:  DATA 30,78
0191A:  DATA 25,30
0191C:  DATA 38,4C
0191E:  DATA 58,0D
01920:  DATA 0A,00
01922:  DATA 09,50
01924:  DATA 61,63
01926:  DATA 6B,65
01928:  DATA 74,4E
0192A:  DATA 75,6D
0192C:  DATA 3A,20
0192E:  DATA 30,78
01930:  DATA 25,30
01932:  DATA 34,4C
01934:  DATA 58,0D
01936:  DATA 0A,00
01938:  DATA 72,65
0193A:  DATA 61,64
0193C:  DATA 20,64
0193E:  DATA 61,74
01940:  DATA 61,0D
01942:  DATA 0A,00
01944:  DATA 0D,0A
01946:  DATA 45,6E
01948:  DATA 64,20
0194A:  DATA 46,6C
0194C:  DATA 61,73
0194E:  DATA 68,20
01950:  DATA 53,4D
01952:  DATA 46,20
01954:  DATA 52,65
01956:  DATA 61,64
01958:  DATA 20,46
0195A:  DATA 6F,72
0195C:  DATA 63,65
0195E:  DATA 0D,0A
01960:  DATA 00,00
01962:  DATA 53,74
01964:  DATA 61,72
01966:  DATA 74,20
01968:  DATA 53,4D
0196A:  DATA 46,20
0196C:  DATA 45,72
0196E:  DATA 61,73
01970:  DATA 65,20
01972:  DATA 41,6C
01974:  DATA 6C,0D
01976:  DATA 0A,00
01978:  DATA 45,6E
0197A:  DATA 64,20
0197C:  DATA 53,4D
0197E:  DATA 46,20
01980:  DATA 45,72
01982:  DATA 61,73
01984:  DATA 65,20
01986:  DATA 41,6C
01988:  DATA 6C,0D
0198A:  DATA 0A,00
0198C:  DATA 53,74
0198E:  DATA 61,72
01990:  DATA 74,20
01992:  DATA 53,4D
01994:  DATA 46,20
01996:  DATA 52,65
01998:  DATA 73,65
0199A:  DATA 74,0D
0199C:  DATA 0A,00
0199E:  DATA 45,6E
019A0:  DATA 64,20
019A2:  DATA 53,4D
019A4:  DATA 46,20
019A6:  DATA 52,65
019A8:  DATA 73,65
019AA:  DATA 74,0D
019AC:  DATA 0A,00
019AE:  DATA 0D,0A
019B0:  DATA 0D,0A
019B2:  DATA 0D,0A
019B4:  DATA 3D,3D
019B6:  DATA 3D,3D
019B8:  DATA 3D,3D
019BA:  DATA 3D,3D
019BC:  DATA 3D,3D
019BE:  DATA 3D,3D
019C0:  DATA 3D,3D
019C2:  DATA 3D,3D
019C4:  DATA 3D,3D
019C6:  DATA 3D,3D
019C8:  DATA 3D,3D
019CA:  DATA 3D,3D
019CC:  DATA 3D,3D
019CE:  DATA 3D,3D
019D0:  DATA 3D,3D
019D2:  DATA 3D,3D
019D4:  DATA 3D,3D
019D6:  DATA 3D,3D
019D8:  DATA 3D,3D
019DA:  DATA 3D,3D
019DC:  DATA 3D,3D
019DE:  DATA 3D,3D
019E0:  DATA 3D,3D
019E2:  DATA 3D,3D
019E4:  DATA 3D,3D
019E6:  DATA 3D,3D
019E8:  DATA 3D,3D
019EA:  DATA 3D,3D
019EC:  DATA 3D,3D
019EE:  DATA 3D,3D
019F0:  DATA 0D,0A
019F2:  DATA 00,00
019F4:  DATA 54,68
019F6:  DATA 69,73
019F8:  DATA 20,69
019FA:  DATA 73,20
019FC:  DATA 4D,4F
019FE:  DATA 4D,49
01A00:  DATA 4A,49
01A02:  DATA 20,43
01A04:  DATA 49,47
01A06:  DATA 53,20
01A08:  DATA 50,49
01A0A:  DATA 43,20
01A0C:  DATA 42,42
01A0E:  DATA 4D,20
01A10:  DATA 66,6F
01A12:  DATA 72,20
01A14:  DATA 4D,49
01A16:  DATA 53,37
01A18:  DATA 5F,42
01A1A:  DATA 42,4D
01A1C:  DATA 34,2E
01A1E:  DATA 0D,0A
01A20:  DATA 00,00
01A22:  DATA 4C,61
01A24:  DATA 73,74
01A26:  DATA 20,75
01A28:  DATA 70,64
01A2A:  DATA 61,74
01A2C:  DATA 65,64
01A2E:  DATA 20,6F
01A30:  DATA 6E,20
01A32:  DATA 25,73
01A34:  DATA 20,25
01A36:  DATA 73,2C
01A38:  DATA 20,62
01A3A:  DATA 79,20
01A3C:  DATA 49,6E
01A3E:  DATA 6F,75
01A40:  DATA 65,2E
01A42:  DATA 0D,0A
01A44:  DATA 0D,0A
01A46:  DATA 00,00
01A48:  DATA 31,33
01A4A:  DATA 2D,41
01A4C:  DATA 75,67
01A4E:  DATA 2D,32
01A50:  DATA 35,00
01A52:  DATA 31,38
01A54:  DATA 3A,35
01A56:  DATA 39,3A
01A58:  DATA 34,33
01A5A:  DATA 00,00
01A5C:  DATA 5F,5F
01A5E:  DATA 5F,5F
01A60:  DATA 43,49
01A62:  DATA 47,53
01A64:  DATA 20,50
01A66:  DATA 49,43
01A68:  DATA 20,53
01A6A:  DATA 74,61
01A6C:  DATA 72,74
01A6E:  DATA 20,4F
01A70:  DATA 70,65
01A72:  DATA 72,61
01A74:  DATA 74,69
01A76:  DATA 6F,6E
01A78:  DATA 5F,5F
01A7A:  DATA 5F,5F
01A7C:  DATA 5F,0D
01A7E:  DATA 0A,0D
01A80:  DATA 0A,00
01A82:  DATA 77,61
01A84:  DATA 69,74
01A86:  DATA 69,6E
01A88:  DATA 67,20
01A8A:  DATA 66,6F
01A8C:  DATA 72,20
01A8E:  DATA 42,4F
01A90:  DATA 53,53
01A92:  DATA 20,50
01A94:  DATA 49,43
01A96:  DATA 20,63
01A98:  DATA 6F,6D
01A9A:  DATA 6D,61
01A9C:  DATA 6E,64
01A9E:  DATA 00,00
01AA0:  DATA 43,49
01AA2:  DATA 47,53
01AA4:  DATA 31,20
01AA6:  DATA 41,6D
01AA8:  DATA 70,3A
01AAA:  DATA 20,25
01AAC:  DATA 30,34
01AAE:  DATA 4C,58
01AB0:  DATA 2C,20
01AB2:  DATA 43,75
01AB4:  DATA 72,72
01AB6:  DATA 65,6E
01AB8:  DATA 74,3A
01ABA:  DATA 20,25
01ABC:  DATA 30,34
01ABE:  DATA 4C,58
01AC0:  DATA 2C,20
01AC2:  DATA 56,6F
01AC4:  DATA 6C,74
01AC6:  DATA 61,67
01AC8:  DATA 65,3A
01ACA:  DATA 20,25
01ACC:  DATA 30,34
01ACE:  DATA 4C,58
01AD0:  DATA 0D,0A
01AD2:  DATA 00,00
01AD4:  DATA 0D,0A
01AD6:  DATA 77,61
01AD8:  DATA 69,74
01ADA:  DATA 69,6E
01ADC:  DATA 67,20
01ADE:  DATA 66,6F
01AE0:  DATA 72,20
01AE2:  DATA 42,4F
01AE4:  DATA 53,53
01AE6:  DATA 20,50
01AE8:  DATA 49,43
01AEA:  DATA 20,63
01AEC:  DATA 6F,6D
01AEE:  DATA 6D,61
01AF0:  DATA 6E,64
01AF2:  DATA 00,00
01AF4:  DATA 0D,0A
01AF6:  DATA 0D,0A
01AF8:  DATA 3D,3D
01AFA:  DATA 3D,3D
01AFC:  DATA 3D,3D
01AFE:  DATA 0D,0A
01B00:  DATA 0D,0A
01B02:  DATA 46,69
01B04:  DATA 6E,69
01B06:  DATA 73,68
01B08:  DATA 65,64
01B0A:  DATA 20,70
01B0C:  DATA 72,6F
01B0E:  DATA 63,65
01B10:  DATA 73,73
01B12:  DATA 2E,0D
01B14:  DATA 0A,57
01B16:  DATA 61,69
01B18:  DATA 74,20
01B1A:  DATA 66,6F
01B1C:  DATA 72,20
01B1E:  DATA 42,4F
01B20:  DATA 53,53
01B22:  DATA 20,50
01B24:  DATA 49,43
01B26:  DATA 20,74
01B28:  DATA 75,72
01B2A:  DATA 6E,20
01B2C:  DATA 6F,66
01B2E:  DATA 66,20
01B30:  DATA 6D,65
01B32:  DATA 00,00
01B34:  DATA 45,6E
01B36:  DATA 64,20
01B38:  DATA 6D,61
01B3A:  DATA 69,6E
01B3C:  DATA 0D,0A
01B3E:  DATA 00,00
*
01BC0:  TBLRD*+
01BC2:  MOVF   FF5,F
01BC4:  BTFSC  FD8.2
01BC6:  GOTO   1BEE
01BCA:  MOVFF  FF6,A1C
01BCE:  MOVFF  FF7,A1D
01BD2:  MOVFF  FF8,A1E
01BD6:  MOVFF  FF5,AB3
01BDA:  CALL   1B6E
01BDE:  MOVFF  A1C,FF6
01BE2:  MOVFF  A1D,FF7
01BE6:  MOVFF  A1E,FF8
01BEA:  GOTO   1BC0
01BEE:  RETURN 0
01BF0:  TBLRD*+
01BF2:  MOVFF  FF6,9CD
01BF6:  MOVFF  FF7,9CE
01BFA:  MOVFF  FF8,9CF
01BFE:  MOVFF  FF5,AB3
01C02:  CALL   1B6E
01C06:  MOVFF  9CD,FF6
01C0A:  MOVFF  9CE,FF7
01C0E:  MOVFF  9CF,FF8
01C12:  MOVLB  9
01C14:  DECFSZ xCC,F
01C16:  BRA    1C1C
01C18:  BRA    1C22
01C1A:  MOVLB  0
01C1C:  MOVLB  0
01C1E:  GOTO   1BF0
01C22:  MOVLB  0
01C24:  RETURN 0
*
01E44:  MOVLB  9
01E46:  BTFSS  xCD.7
01E48:  BRA    1E50
01E4A:  MOVLB  0
01E4C:  GOTO   1E80
01E50:  MOVLW  0F
01E52:  MOVWF  00
01E54:  SWAPF  xCC,W
01E56:  ANDWF  00,F
01E58:  MOVLW  0A
01E5A:  SUBWF  00,W
01E5C:  BTFSS  FD8.0
01E5E:  BRA    1E66
01E60:  MOVLB  0
01E62:  GOTO   1E70
01E66:  MOVLW  30
01E68:  ADDWF  00,F
01E6A:  MOVLB  0
01E6C:  GOTO   1E78
01E70:  MOVLB  9
01E72:  MOVF   xCD,W
01E74:  ADDWF  00,F
01E76:  MOVLB  0
01E78:  MOVFF  00,AB3
01E7C:  CALL   1B6E
01E80:  MOVLW  0F
01E82:  MOVLB  9
01E84:  ANDWF  xCC,F
01E86:  MOVLW  0A
01E88:  SUBWF  xCC,W
01E8A:  BTFSS  FD8.0
01E8C:  BRA    1E94
01E8E:  MOVLB  0
01E90:  GOTO   1E9C
01E94:  MOVLW  30
01E96:  MOVLB  0
01E98:  GOTO   1EA4
01E9C:  MOVLB  9
01E9E:  BCF    xCD.7
01EA0:  MOVF   xCD,W
01EA2:  MOVLB  0
01EA4:  MOVLB  9
01EA6:  ADDWF  xCC,F
01EA8:  MOVFF  9CC,AB3
01EAC:  MOVLB  0
01EAE:  CALL   1B6E
01EB2:  RETURN 0
*
0235A:  MOVLB  A
0235C:  MOVF   x7A,W
0235E:  ANDLW  07
02360:  MOVWF  00
02362:  RRCF   x7A,W
02364:  MOVWF  01
02366:  RRCF   01,F
02368:  RRCF   01,F
0236A:  MOVLW  1F
0236C:  ANDWF  01,F
0236E:  MOVF   01,W
02370:  ADDWF  x7C,W
02372:  MOVWF  FE9
02374:  MOVLW  00
02376:  ADDWFC x7D,W
02378:  MOVWF  FEA
0237A:  CLRF   01
0237C:  INCF   01,F
0237E:  INCF   00,F
02380:  MOVLB  0
02382:  GOTO   2388
02386:  RLCF   01,F
02388:  DECFSZ 00,F
0238A:  GOTO   2386
0238E:  MOVLB  A
02390:  MOVF   x7B,F
02392:  BTFSS  FD8.2
02394:  BRA    239C
02396:  MOVLB  0
02398:  GOTO   23A6
0239C:  MOVF   01,W
0239E:  IORWF  FEF,F
023A0:  MOVLB  0
023A2:  GOTO   23AC
023A6:  COMF   01,F
023A8:  MOVF   01,W
023AA:  ANDWF  FEF,F
023AC:  RETURN 0
*
027A2:  TSTFSZ 01
027A4:  GOTO   27B2
027A8:  TSTFSZ 02
027AA:  GOTO   27B4
027AE:  GOTO   27C4
027B2:  INCF   02,F
027B4:  MOVFF  00,FEE
027B8:  DECFSZ 01,F
027BA:  GOTO   27B4
027BE:  DECFSZ 02,F
027C0:  GOTO   27B4
027C4:  RETURN 0
*
06688:  MOVLB  2
0668A:  MOVF   xF0,W
0668C:  CLRF   01
0668E:  SUBWF  xEF,W
06690:  BTFSS  FD8.0
06692:  BRA    669A
06694:  MOVLB  0
06696:  GOTO   66A4
0669A:  MOVF   xEF,W
0669C:  MOVWF  00
0669E:  MOVLB  0
066A0:  GOTO   66CE
066A4:  CLRF   00
066A6:  MOVLW  08
066A8:  MOVLB  2
066AA:  MOVWF  xF1
066AC:  MOVLB  0
066AE:  MOVLB  2
066B0:  RLCF   xEF,F
066B2:  RLCF   00,F
066B4:  MOVF   xF0,W
066B6:  SUBWF  00,W
066B8:  BTFSC  FD8.0
066BA:  MOVWF  00
066BC:  RLCF   01,F
066BE:  DECFSZ xF1,F
066C0:  BRA    66C6
066C2:  BRA    66CC
066C4:  MOVLB  0
066C6:  MOVLB  0
066C8:  GOTO   66AE
066CC:  MOVLB  0
066CE:  RETURN 0
066D0:  MOVF   01,W
066D2:  MOVFF  26A,2EF
066D6:  MOVLW  64
066D8:  MOVLB  2
066DA:  MOVWF  xF0
066DC:  MOVLB  0
066DE:  CALL   6688
066E2:  MOVFF  00,26A
066E6:  MOVF   01,W
066E8:  MOVLW  30
066EA:  BTFSS  FD8.2
066EC:  GOTO   6710
066F0:  MOVLB  2
066F2:  BTFSC  x6B.1
066F4:  BRA    66FC
066F6:  MOVLB  0
066F8:  GOTO   6724
066FC:  BTFSS  x6B.3
066FE:  BRA    6706
06700:  MOVLB  0
06702:  GOTO   6724
06706:  BTFSC  x6B.4
06708:  MOVLW  20
0670A:  MOVLB  0
0670C:  GOTO   671A
06710:  MOVLB  2
06712:  BCF    x6B.3
06714:  BCF    x6B.4
06716:  BSF    x6B.0
06718:  MOVLB  0
0671A:  ADDWF  01,F
0671C:  MOVFF  01,AB3
06720:  CALL   1B6E
06724:  MOVFF  26A,2EF
06728:  MOVLW  0A
0672A:  MOVLB  2
0672C:  MOVWF  xF0
0672E:  MOVLB  0
06730:  CALL   6688
06734:  MOVFF  00,26A
06738:  MOVF   01,W
0673A:  MOVLW  30
0673C:  BTFSS  FD8.2
0673E:  GOTO   675E
06742:  MOVLB  2
06744:  BTFSS  x6B.3
06746:  BRA    674E
06748:  MOVLB  0
0674A:  GOTO   6768
0674E:  BTFSC  x6B.0
06750:  BRA    6758
06752:  MOVLB  0
06754:  GOTO   6768
06758:  BTFSC  x6B.4
0675A:  MOVLW  20
0675C:  MOVLB  0
0675E:  ADDWF  01,F
06760:  MOVFF  01,AB3
06764:  CALL   1B6E
06768:  MOVLW  30
0676A:  MOVLB  2
0676C:  ADDWF  x6A,F
0676E:  MOVFF  26A,AB3
06772:  MOVLB  0
06774:  CALL   1B6E
06778:  RETURN 0
0677A:  BTFSC  FD8.1
0677C:  GOTO   6788
06780:  MOVLW  09
06782:  MOVWF  FEA
06784:  MOVLW  E5
06786:  MOVWF  FE9
06788:  CLRF   00
0678A:  CLRF   01
0678C:  CLRF   02
0678E:  CLRF   03
06790:  MOVLB  9
06792:  CLRF   xE5
06794:  CLRF   xE6
06796:  CLRF   xE7
06798:  CLRF   xE8
0679A:  MOVF   xE4,W
0679C:  IORWF  xE3,W
0679E:  IORWF  xE2,W
067A0:  IORWF  xE1,W
067A2:  BTFSS  FD8.2
067A4:  BRA    67AC
067A6:  MOVLB  0
067A8:  GOTO   683C
067AC:  MOVLB  0
067AE:  MOVLW  20
067B0:  MOVLB  9
067B2:  MOVWF  xE9
067B4:  MOVLB  0
067B6:  BCF    FD8.0
067B8:  MOVLB  9
067BA:  RLCF   xDD,F
067BC:  RLCF   xDE,F
067BE:  RLCF   xDF,F
067C0:  RLCF   xE0,F
067C2:  RLCF   xE5,F
067C4:  RLCF   xE6,F
067C6:  RLCF   xE7,F
067C8:  RLCF   xE8,F
067CA:  MOVF   xE4,W
067CC:  SUBWF  xE8,W
067CE:  BTFSC  FD8.2
067D0:  BRA    67D8
067D2:  MOVLB  0
067D4:  GOTO   67FA
067D8:  MOVF   xE3,W
067DA:  SUBWF  xE7,W
067DC:  BTFSC  FD8.2
067DE:  BRA    67E6
067E0:  MOVLB  0
067E2:  GOTO   67FA
067E6:  MOVF   xE2,W
067E8:  SUBWF  xE6,W
067EA:  BTFSC  FD8.2
067EC:  BRA    67F4
067EE:  MOVLB  0
067F0:  GOTO   67FA
067F4:  MOVF   xE1,W
067F6:  SUBWF  xE5,W
067F8:  MOVLB  0
067FA:  BTFSS  FD8.0
067FC:  GOTO   6822
06800:  MOVLB  9
06802:  MOVF   xE1,W
06804:  SUBWF  xE5,F
06806:  MOVF   xE2,W
06808:  BTFSS  FD8.0
0680A:  INCFSZ xE2,W
0680C:  SUBWF  xE6,F
0680E:  MOVF   xE3,W
06810:  BTFSS  FD8.0
06812:  INCFSZ xE3,W
06814:  SUBWF  xE7,F
06816:  MOVF   xE4,W
06818:  BTFSS  FD8.0
0681A:  INCFSZ xE4,W
0681C:  SUBWF  xE8,F
0681E:  BSF    FD8.0
06820:  MOVLB  0
06822:  RLCF   00,F
06824:  RLCF   01,F
06826:  RLCF   02,F
06828:  RLCF   03,F
0682A:  MOVLB  9
0682C:  DECFSZ xE9,F
0682E:  BRA    6834
06830:  BRA    683A
06832:  MOVLB  0
06834:  MOVLB  0
06836:  GOTO   67B6
0683A:  MOVLB  0
0683C:  MOVFF  9E5,FEF
06840:  MOVFF  9E6,FEC
06844:  MOVFF  9E7,FEC
06848:  MOVFF  9E8,FEC
0684C:  MOVF   FED,F
0684E:  MOVF   FED,F
06850:  MOVF   FED,F
06852:  RETURN 0
*
0690E:  MOVFF  FEA,9D0
06912:  MOVFF  FE9,9CF
06916:  MOVLB  9
06918:  BTFSC  xC9.7
0691A:  BRA    6922
0691C:  MOVLB  0
0691E:  GOTO   6934
06922:  BSF    xCF.7
06924:  BTFSS  xCF.4
06926:  INCF   xCF,F
06928:  COMF   xC8,F
0692A:  COMF   xC9,F
0692C:  INCF   xC8,F
0692E:  BTFSC  FD8.2
06930:  INCF   xC9,F
06932:  MOVLB  0
06934:  MOVLB  9
06936:  SWAPF  xC9,W
06938:  IORLW  F0
0693A:  MOVWF  xCB
0693C:  ADDWF  xCB,F
0693E:  ADDLW  E2
06940:  MOVWF  xCC
06942:  ADDLW  32
06944:  MOVWF  xCE
06946:  MOVF   xC9,W
06948:  ANDLW  0F
0694A:  ADDWF  xCC,F
0694C:  ADDWF  xCC,F
0694E:  ADDWF  xCE,F
06950:  ADDLW  E9
06952:  MOVWF  xCD
06954:  ADDWF  xCD,F
06956:  ADDWF  xCD,F
06958:  SWAPF  xC8,W
0695A:  ANDLW  0F
0695C:  ADDWF  xCD,F
0695E:  ADDWF  xCE,F
06960:  RLCF   xCD,F
06962:  RLCF   xCE,F
06964:  COMF   xCE,F
06966:  RLCF   xCE,F
06968:  MOVF   xC8,W
0696A:  ANDLW  0F
0696C:  ADDWF  xCE,F
0696E:  RLCF   xCB,F
06970:  MOVLW  07
06972:  MOVWF  xCA
06974:  MOVLW  0A
06976:  MOVLB  0
06978:  MOVLB  9
0697A:  DECF   xCD,F
0697C:  ADDWF  xCE,F
0697E:  BTFSC  FD8.0
06980:  BRA    6988
06982:  MOVLB  0
06984:  GOTO   6978
06988:  MOVLB  0
0698A:  MOVLB  9
0698C:  DECF   xCC,F
0698E:  ADDWF  xCD,F
06990:  BTFSC  FD8.0
06992:  BRA    699A
06994:  MOVLB  0
06996:  GOTO   698A
0699A:  MOVLB  0
0699C:  MOVLB  9
0699E:  DECF   xCB,F
069A0:  ADDWF  xCC,F
069A2:  BTFSC  FD8.0
069A4:  BRA    69AC
069A6:  MOVLB  0
069A8:  GOTO   699C
069AC:  MOVLB  0
069AE:  MOVLB  9
069B0:  DECF   xCA,F
069B2:  ADDWF  xCB,F
069B4:  BTFSC  FD8.0
069B6:  BRA    69BE
069B8:  MOVLB  0
069BA:  GOTO   69AE
069BE:  MOVLW  09
069C0:  MOVWF  FEA
069C2:  MOVLW  CA
069C4:  MOVWF  FE9
069C6:  MOVLW  07
069C8:  ANDWF  xCF,W
069CA:  BCF    xCF.6
069CC:  MOVF   FED,F
069CE:  ANDWF  xCF,W
069D0:  BTFSC  FD8.2
069D2:  BRA    69DA
069D4:  MOVLB  0
069D6:  GOTO   69F2
069DA:  BTFSC  xCF.4
069DC:  MOVF   FEE,F
069DE:  BTFSS  xCF.4
069E0:  BRA    69E8
069E2:  MOVLB  0
069E4:  GOTO   69F2
069E8:  MOVLW  20
069EA:  MOVWF  00
069EC:  MOVLB  0
069EE:  GOTO   6A6C
069F2:  ADDWF  FE9,F
069F4:  MOVLW  00
069F6:  ADDWFC FEA,F
069F8:  MOVF   FE9,W
069FA:  SUBLW  CE
069FC:  BTFSS  FD8.2
069FE:  GOTO   6A12
06A02:  MOVF   FEA,W
06A04:  SUBLW  09
06A06:  BTFSS  FD8.2
06A08:  GOTO   6A12
06A0C:  MOVLB  9
06A0E:  BSF    xCF.6
06A10:  MOVLB  0
06A12:  MOVF   FEF,W
06A14:  MOVWF  00
06A16:  BTFSS  FD8.2
06A18:  GOTO   6A44
06A1C:  MOVLB  9
06A1E:  BTFSS  xCF.6
06A20:  BRA    6A28
06A22:  MOVLB  0
06A24:  GOTO   6A44
06A28:  BTFSS  xCF.4
06A2A:  BRA    6A32
06A2C:  MOVLB  0
06A2E:  GOTO   6A84
06A32:  BTFSS  xCF.3
06A34:  BRA    6A3C
06A36:  MOVLB  0
06A38:  GOTO   6A44
06A3C:  MOVLW  20
06A3E:  MOVLB  0
06A40:  GOTO   6A6A
06A44:  MOVLB  9
06A46:  BTFSC  xCF.7
06A48:  BRA    6A50
06A4A:  MOVLB  0
06A4C:  GOTO   6A60
06A50:  MOVLW  2D
06A52:  MOVWF  00
06A54:  MOVF   FED,W
06A56:  BCF    xCF.6
06A58:  BCF    xCF.7
06A5A:  MOVLB  0
06A5C:  GOTO   6A6C
06A60:  MOVLB  9
06A62:  BSF    xCF.3
06A64:  BCF    xCF.4
06A66:  MOVLW  30
06A68:  MOVLB  0
06A6A:  ADDWF  00,F
06A6C:  MOVFF  FEA,9C9
06A70:  MOVFF  FE9,9C8
06A74:  MOVFF  00,AB3
06A78:  CALL   1B6E
06A7C:  MOVFF  9C9,FEA
06A80:  MOVFF  9C8,FE9
06A84:  MOVF   FEE,W
06A86:  MOVLB  9
06A88:  BTFSC  xCF.6
06A8A:  BRA    6A92
06A8C:  MOVLB  0
06A8E:  GOTO   69F8
06A92:  MOVLB  0
06A94:  GOTO   8412 (RETURN)
*
09242:  MOVF   FE9,W
09244:  MOVLB  2
09246:  MOVWF  x6A
09248:  BTFSC  x69.7
0924A:  BRA    9252
0924C:  MOVLB  0
0924E:  GOTO   926E
09252:  DECF   x6A,F
09254:  BSF    x6A.5
09256:  COMF   x66,F
09258:  COMF   x67,F
0925A:  COMF   x68,F
0925C:  COMF   x69,F
0925E:  INCF   x66,F
09260:  BTFSC  FD8.2
09262:  INCF   x67,F
09264:  BTFSC  FD8.2
09266:  INCF   x68,F
09268:  BTFSC  FD8.2
0926A:  INCF   x69,F
0926C:  MOVLB  0
0926E:  MOVLW  3B
09270:  MOVLB  2
09272:  MOVWF  x71
09274:  MOVLW  9A
09276:  MOVWF  x70
09278:  MOVLW  CA
0927A:  MOVWF  x6F
0927C:  CLRF   x6E
0927E:  MOVLW  0A
09280:  MOVWF  x6C
09282:  MOVLB  0
09284:  BSF    FD8.1
09286:  MOVLW  02
09288:  MOVWF  FEA
0928A:  MOVLW  66
0928C:  MOVWF  FE9
0928E:  MOVFF  269,9E0
09292:  MOVFF  268,9DF
09296:  MOVFF  267,9DE
0929A:  MOVFF  266,9DD
0929E:  MOVFF  271,9E4
092A2:  MOVFF  270,9E3
092A6:  MOVFF  26F,9E2
092AA:  MOVFF  26E,9E1
092AE:  CALL   677A
092B2:  MOVF   01,W
092B4:  MOVF   00,F
092B6:  BTFSS  FD8.2
092B8:  GOTO   9310
092BC:  MOVLB  2
092BE:  MOVF   x6C,W
092C0:  XORLW  01
092C2:  BTFSS  FD8.2
092C4:  BRA    92CC
092C6:  MOVLB  0
092C8:  GOTO   9310
092CC:  MOVF   x6A,W
092CE:  BTFSS  FD8.2
092D0:  BRA    92D8
092D2:  MOVLB  0
092D4:  GOTO   9318
092D8:  ANDLW  0F
092DA:  SUBWF  x6C,W
092DC:  BTFSS  FD8.2
092DE:  BRA    92E6
092E0:  MOVLB  0
092E2:  GOTO   92F2
092E6:  BTFSS  FD8.0
092E8:  BRA    92F0
092EA:  MOVLB  0
092EC:  GOTO   9376
092F0:  MOVLB  0
092F2:  MOVLB  2
092F4:  BTFSS  x6A.7
092F6:  BRA    92FE
092F8:  MOVLB  0
092FA:  GOTO   9376
092FE:  BTFSS  x6A.6
09300:  BRA    9308
09302:  MOVLB  0
09304:  GOTO   9318
09308:  MOVLW  20
0930A:  MOVLB  0
0930C:  GOTO   936C
09310:  MOVLW  20
09312:  MOVLB  2
09314:  ANDWF  x6A,F
09316:  MOVLB  0
09318:  MOVLB  2
0931A:  BTFSC  x6A.5
0931C:  BRA    9324
0931E:  MOVLB  0
09320:  GOTO   9340
09324:  BCF    x6A.5
09326:  MOVF   00,W
09328:  MOVWF  x6A
0932A:  MOVLW  2D
0932C:  MOVLB  A
0932E:  MOVWF  xB3
09330:  MOVLB  0
09332:  CALL   1B6E
09336:  MOVLB  2
09338:  MOVF   x6A,W
0933A:  MOVWF  00
0933C:  CLRF   x6A
0933E:  MOVLB  0
09340:  MOVLW  30
09342:  MOVLB  2
09344:  BTFSC  x6A.5
09346:  BRA    934E
09348:  MOVLB  0
0934A:  GOTO   936C
0934E:  BCF    x6A.5
09350:  MOVF   00,W
09352:  MOVWF  x6A
09354:  MOVLW  2D
09356:  MOVLB  A
09358:  MOVWF  xB3
0935A:  MOVLB  0
0935C:  CALL   1B6E
09360:  MOVLB  2
09362:  MOVF   x6A,W
09364:  MOVWF  00
09366:  CLRF   x6A
09368:  MOVLW  30
0936A:  MOVLB  0
0936C:  ADDWF  00,F
0936E:  MOVFF  00,AB3
09372:  CALL   1B6E
09376:  BCF    FD8.1
09378:  MOVFF  271,9E0
0937C:  MOVFF  270,9DF
09380:  MOVFF  26F,9DE
09384:  MOVFF  26E,9DD
09388:  MOVLB  9
0938A:  CLRF   xE4
0938C:  CLRF   xE3
0938E:  CLRF   xE2
09390:  MOVLW  0A
09392:  MOVWF  xE1
09394:  MOVLB  0
09396:  CALL   677A
0939A:  MOVFF  03,271
0939E:  MOVFF  02,270
093A2:  MOVFF  01,26F
093A6:  MOVFF  00,26E
093AA:  MOVLB  2
093AC:  DECFSZ x6C,F
093AE:  BRA    93B4
093B0:  BRA    93BA
093B2:  MOVLB  0
093B4:  MOVLB  0
093B6:  GOTO   9284
093BA:  MOVLB  0
093BC:  RETURN 0
*
0975E:  MOVLW  20
09760:  MOVLB  2
09762:  BTFSS  xEA.4
09764:  MOVLW  30
09766:  MOVWF  xEB
09768:  MOVFF  2E9,00
0976C:  BTFSC  00.7
0976E:  BRA    9776
09770:  MOVLB  0
09772:  GOTO   9788
09776:  COMF   00,F
09778:  INCF   00,F
0977A:  MOVFF  00,2E9
0977E:  MOVLW  2D
09780:  MOVWF  xEB
09782:  BSF    xEA.7
09784:  BSF    xEA.0
09786:  MOVLB  0
09788:  MOVF   01,W
0978A:  MOVFF  2E9,2EF
0978E:  MOVLW  64
09790:  MOVLB  2
09792:  MOVWF  xF0
09794:  MOVLB  0
09796:  CALL   6688
0979A:  MOVFF  00,2E9
0979E:  MOVLW  30
097A0:  ADDWF  01,W
097A2:  MOVLB  2
097A4:  MOVWF  xEC
097A6:  MOVFF  2E9,2EF
097AA:  MOVLW  0A
097AC:  MOVWF  xF0
097AE:  MOVLB  0
097B0:  CALL   6688
097B4:  MOVLW  30
097B6:  ADDWF  00,W
097B8:  MOVLB  2
097BA:  MOVWF  xEE
097BC:  MOVLW  30
097BE:  ADDWF  01,W
097C0:  MOVWF  xED
097C2:  MOVFF  2EB,00
097C6:  MOVLB  0
097C8:  MOVLW  30
097CA:  MOVLB  2
097CC:  SUBWF  xEC,W
097CE:  BTFSS  FD8.2
097D0:  BRA    97D8
097D2:  MOVLB  0
097D4:  GOTO   97E4
097D8:  BSF    xEA.1
097DA:  BTFSC  xEA.7
097DC:  BSF    xEA.2
097DE:  MOVLB  0
097E0:  GOTO   9824
097E4:  MOVFF  2EB,2EC
097E8:  MOVLW  20
097EA:  MOVLB  2
097EC:  MOVWF  xEB
097EE:  MOVLW  30
097F0:  SUBWF  xED,W
097F2:  BTFSS  FD8.2
097F4:  BRA    97FC
097F6:  MOVLB  0
097F8:  GOTO   9808
097FC:  BSF    xEA.0
097FE:  BTFSC  xEA.7
09800:  BSF    xEA.1
09802:  MOVLB  0
09804:  GOTO   9824
09808:  BTFSC  FD8.2
0980A:  BRA    9812
0980C:  MOVLB  2
0980E:  BSF    xEA.0
09810:  MOVLB  0
09812:  BTFSS  FD8.2
09814:  GOTO   9824
09818:  MOVFF  2EC,2ED
0981C:  MOVLW  20
0981E:  MOVLB  2
09820:  MOVWF  xEC
09822:  MOVLB  0
09824:  MOVLB  2
09826:  BTFSS  xEA.2
09828:  BRA    9830
0982A:  MOVLB  0
0982C:  GOTO   984A
09830:  BTFSS  xEA.1
09832:  BRA    983A
09834:  MOVLB  0
09836:  GOTO   9852
0983A:  BTFSS  xEA.0
0983C:  BRA    9844
0983E:  MOVLB  0
09840:  GOTO   985A
09844:  MOVLB  0
09846:  GOTO   9862
0984A:  MOVFF  2EB,AB3
0984E:  CALL   1B6E
09852:  MOVFF  2EC,AB3
09856:  CALL   1B6E
0985A:  MOVFF  2ED,AB3
0985E:  CALL   1B6E
09862:  MOVFF  2EE,AB3
09866:  CALL   1B6E
0986A:  RETURN 0
*
0A374:  MOVF   FE9,W
0A376:  MOVLB  1
0A378:  MOVWF  xEF
0A37A:  MOVLW  3B
0A37C:  MOVWF  xF6
0A37E:  MOVLW  9A
0A380:  MOVWF  xF5
0A382:  MOVLW  CA
0A384:  MOVWF  xF4
0A386:  CLRF   xF3
0A388:  MOVLW  0A
0A38A:  MOVWF  xF1
0A38C:  MOVLB  0
0A38E:  BSF    FD8.1
0A390:  MOVLW  01
0A392:  MOVWF  FEA
0A394:  MOVLW  EB
0A396:  MOVWF  FE9
0A398:  MOVFF  1EE,9E0
0A39C:  MOVFF  1ED,9DF
0A3A0:  MOVFF  1EC,9DE
0A3A4:  MOVFF  1EB,9DD
0A3A8:  MOVFF  1F6,9E4
0A3AC:  MOVFF  1F5,9E3
0A3B0:  MOVFF  1F4,9E2
0A3B4:  MOVFF  1F3,9E1
0A3B8:  CALL   677A
0A3BC:  MOVF   01,W
0A3BE:  MOVF   00,F
0A3C0:  BTFSS  FD8.2
0A3C2:  GOTO   A41A
0A3C6:  MOVLB  1
0A3C8:  MOVF   xF1,W
0A3CA:  XORLW  01
0A3CC:  BTFSS  FD8.2
0A3CE:  BRA    A3D6
0A3D0:  MOVLB  0
0A3D2:  GOTO   A41A
0A3D6:  MOVF   xEF,W
0A3D8:  BTFSS  FD8.2
0A3DA:  BRA    A3E2
0A3DC:  MOVLB  0
0A3DE:  GOTO   A420
0A3E2:  ANDLW  0F
0A3E4:  SUBWF  xF1,W
0A3E6:  BTFSS  FD8.2
0A3E8:  BRA    A3F0
0A3EA:  MOVLB  0
0A3EC:  GOTO   A3FC
0A3F0:  BTFSS  FD8.0
0A3F2:  BRA    A3FA
0A3F4:  MOVLB  0
0A3F6:  GOTO   A42C
0A3FA:  MOVLB  0
0A3FC:  MOVLB  1
0A3FE:  BTFSS  xEF.7
0A400:  BRA    A408
0A402:  MOVLB  0
0A404:  GOTO   A42C
0A408:  BTFSS  xEF.6
0A40A:  BRA    A412
0A40C:  MOVLB  0
0A40E:  GOTO   A420
0A412:  MOVLW  20
0A414:  MOVLB  0
0A416:  GOTO   A422
0A41A:  MOVLB  1
0A41C:  CLRF   xEF
0A41E:  MOVLB  0
0A420:  MOVLW  30
0A422:  ADDWF  00,F
0A424:  MOVFF  00,AB3
0A428:  CALL   1B6E
0A42C:  BCF    FD8.1
0A42E:  MOVFF  1F6,9E0
0A432:  MOVFF  1F5,9DF
0A436:  MOVFF  1F4,9DE
0A43A:  MOVFF  1F3,9DD
0A43E:  MOVLB  9
0A440:  CLRF   xE4
0A442:  CLRF   xE3
0A444:  CLRF   xE2
0A446:  MOVLW  0A
0A448:  MOVWF  xE1
0A44A:  MOVLB  0
0A44C:  CALL   677A
0A450:  MOVFF  03,1F6
0A454:  MOVFF  02,1F5
0A458:  MOVFF  01,1F4
0A45C:  MOVFF  00,1F3
0A460:  MOVLB  1
0A462:  DECFSZ xF1,F
0A464:  BRA    A46A
0A466:  BRA    A470
0A468:  MOVLB  0
0A46A:  MOVLB  0
0A46C:  GOTO   A38E
0A470:  MOVLB  0
0A472:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01B40:  MOVLW  0A
01B42:  MOVWF  FEA
01B44:  MOVLW  74
01B46:  MOVWF  FE9
01B48:  MOVF   FEF,W
01B4A:  BTFSC  FD8.2
01B4C:  GOTO   1B6C
01B50:  MOVLW  05
01B52:  MOVWF  01
01B54:  CLRF   00
01B56:  DECFSZ 00,F
01B58:  BRA    1B56
01B5A:  DECFSZ 01,F
01B5C:  BRA    1B54
01B5E:  MOVLW  2E
01B60:  MOVWF  00
01B62:  DECFSZ 00,F
01B64:  BRA    1B62
01B66:  BRA    1B68
01B68:  DECFSZ FEF,F
01B6A:  BRA    1B50
01B6C:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
04672:  BTFSS  FA6.4
04674:  GOTO   4672
04678:  MOVLB  F
0467A:  MOVWF  x29
0467C:  MOVLB  0
0467E:  GOTO   46B4 (RETURN)
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01B6E:  BCF    F93.6
01B70:  BCF    F8A.6
01B72:  MOVLW  08
01B74:  MOVWF  01
01B76:  BRA    1B78
01B78:  NOP   
01B7A:  BSF    01.7
01B7C:  GOTO   1BA4
01B80:  BCF    01.7
01B82:  MOVLB  A
01B84:  RRCF   xB3,F
01B86:  MOVLB  0
01B88:  BTFSC  FD8.0
01B8A:  BSF    F8A.6
01B8C:  BTFSS  FD8.0
01B8E:  BCF    F8A.6
01B90:  BSF    01.6
01B92:  GOTO   1BA4
01B96:  BCF    01.6
01B98:  DECFSZ 01,F
01B9A:  GOTO   1B82
01B9E:  BRA    1BA0
01BA0:  NOP   
01BA2:  BSF    F8A.6
01BA4:  MOVLW  84
01BA6:  MOVWF  FE9
01BA8:  DECFSZ FE9,F
01BAA:  GOTO   1BA8
01BAE:  BRA    1BB0
01BB0:  NOP   
01BB2:  BTFSC  01.7
01BB4:  GOTO   1B80
01BB8:  BTFSC  01.6
01BBA:  GOTO   1B96
01BBE:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
0242A:  MOVLB  A
0242C:  MOVF   x97,W
0242E:  SUBLW  08
02430:  BTFSS  FD8.2
02432:  BRA    243A
02434:  MOVLB  0
02436:  GOTO   2452
0243A:  MOVWF  x99
0243C:  MOVLB  0
0243E:  MOVLB  A
02440:  RLCF   x96,F
02442:  DECFSZ x99,F
02444:  BRA    244A
02446:  BRA    2450
02448:  MOVLB  0
0244A:  MOVLB  0
0244C:  GOTO   243E
02450:  MOVLB  0
02452:  BSF    F92.1
02454:  BCF    F92.0
02456:  BCF    F92.3
02458:  BCF    F89.3
0245A:  MOVFF  A97,A99
0245E:  MOVLB  A
02460:  BTFSS  x96.7
02462:  BCF    F89.0
02464:  BTFSC  x96.7
02466:  BSF    F89.0
02468:  RLCF   x96,F
0246A:  BSF    F89.3
0246C:  MOVLW  02
0246E:  MOVWF  x9A
02470:  MOVLB  0
02472:  MOVLB  A
02474:  DECFSZ x9A,F
02476:  BRA    247C
02478:  BRA    2482
0247A:  MOVLB  0
0247C:  MOVLB  0
0247E:  GOTO   2472
02482:  RLCF   01,F
02484:  BTFSS  F80.1
02486:  BCF    01.0
02488:  BTFSC  F80.1
0248A:  BSF    01.0
0248C:  BCF    F89.3
0248E:  MOVLB  0
02490:  BRA    2492
02492:  MOVLB  A
02494:  DECFSZ x99,F
02496:  BRA    249C
02498:  BRA    24A2
0249A:  MOVLB  0
0249C:  MOVLB  0
0249E:  GOTO   245E
024A2:  MOVLB  0
024A4:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
023AE:  MOVLB  A
023B0:  MOVF   x97,W
023B2:  SUBLW  08
023B4:  BTFSS  FD8.2
023B6:  BRA    23BE
023B8:  MOVLB  0
023BA:  GOTO   23D6
023BE:  MOVWF  x99
023C0:  MOVLB  0
023C2:  MOVLB  A
023C4:  RLCF   x96,F
023C6:  DECFSZ x99,F
023C8:  BRA    23CE
023CA:  BRA    23D4
023CC:  MOVLB  0
023CE:  MOVLB  0
023D0:  GOTO   23C2
023D4:  MOVLB  0
023D6:  BSF    F96.0
023D8:  BCF    F96.6
023DA:  BCF    F96.1
023DC:  BCF    F8D.1
023DE:  MOVFF  A97,A99
023E2:  MOVLB  A
023E4:  BTFSS  x96.7
023E6:  BCF    F8D.6
023E8:  BTFSC  x96.7
023EA:  BSF    F8D.6
023EC:  RLCF   x96,F
023EE:  BSF    F8D.1
023F0:  MOVLW  02
023F2:  MOVWF  x9A
023F4:  MOVLB  0
023F6:  MOVLB  A
023F8:  DECFSZ x9A,F
023FA:  BRA    2400
023FC:  BRA    2406
023FE:  MOVLB  0
02400:  MOVLB  0
02402:  GOTO   23F6
02406:  RLCF   01,F
02408:  BTFSS  F84.0
0240A:  BCF    01.0
0240C:  BTFSC  F84.0
0240E:  BSF    01.0
02410:  BCF    F8D.1
02412:  MOVLB  0
02414:  BRA    2416
02416:  MOVLB  A
02418:  DECFSZ x99,F
0241A:  BRA    2420
0241C:  BRA    2426
0241E:  MOVLB  0
02420:  MOVLB  0
02422:  GOTO   23E2
02426:  MOVLB  0
02428:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01D4A:  MOVLB  9
01D4C:  MOVF   xE6,W
01D4E:  SUBLW  10
01D50:  BTFSS  FD8.2
01D52:  BRA    1D5A
01D54:  MOVLB  0
01D56:  GOTO   1D74
01D5A:  MOVWF  xE8
01D5C:  MOVLB  0
01D5E:  MOVLB  9
01D60:  RLCF   xE4,F
01D62:  RLCF   xE5,F
01D64:  DECFSZ xE8,F
01D66:  BRA    1D6C
01D68:  BRA    1D72
01D6A:  MOVLB  0
01D6C:  MOVLB  0
01D6E:  GOTO   1D5E
01D72:  MOVLB  0
01D74:  BSF    F93.4
01D76:  BCF    F93.5
01D78:  BCF    F93.2
01D7A:  BSF    F8A.2
01D7C:  MOVFF  9E6,9E8
01D80:  MOVLB  9
01D82:  BTFSS  xE5.7
01D84:  BCF    F8A.5
01D86:  BTFSC  xE5.7
01D88:  BSF    F8A.5
01D8A:  RLCF   xE4,F
01D8C:  RLCF   xE5,F
01D8E:  BCF    F8A.2
01D90:  RLCF   01,F
01D92:  RLCF   02,F
01D94:  BTFSS  F81.4
01D96:  BCF    01.0
01D98:  BTFSC  F81.4
01D9A:  BSF    01.0
01D9C:  BSF    F8A.2
01D9E:  DECFSZ xE8,F
01DA0:  BRA    1DA6
01DA2:  BRA    1DAC
01DA4:  MOVLB  0
01DA6:  MOVLB  0
01DA8:  GOTO   1D80
01DAC:  MOVLB  0
01DAE:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/mcu/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/devices/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "../core/measurement/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/storage/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../../system/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "../application/mission/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... #include "../hardware/mcu/src/timer.c"
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
*
000CA:  MOVLW  80
000CC:  MOVWF  FCF
000CE:  MOVLW  12
000D0:  MOVWF  FCE
000D2:  NOP   
....................    sec++;
000D4:  MOVLW  01
000D6:  ADDWF  20,F
000D8:  BTFSC  FD8.0
000DA:  INCF   21,F
000DC:  BTFSC  FD8.2
000DE:  INCF   22,F
000E0:  BTFSC  FD8.2
000E2:  INCF   23,F
....................    /*
....................    if (++subsec >= 100)
....................    {
....................       subsec = 0;
....................       sec++;
.................... 
....................       if (sec >= SEC_IN_A_DAY)
....................       {
....................          day++;
....................       }
....................    }*/
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01C9E:  MOVLW  EA
01CA0:  MOVWF  FF6
01CA2:  MOVLW  00
01CA4:  MOVWF  FF7
01CA6:  MOVLW  00
01CA8:  MOVWF  FF8
01CAA:  CALL   1BC0
....................    clear_interrupt(INT_TIMER1);
01CAE:  BCF    F9E.0
....................    //sec = 0;
....................    // 外部クロックをT1CKIピンから入力、プリスケーラなし
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01CB0:  MOVLW  8F
01CB2:  MOVWF  FCD
01CB4:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01CB6:  MOVLW  80
01CB8:  MOVWF  FCF
01CBA:  MOVLW  12
01CBC:  MOVWF  FCE
01CBE:  NOP   
....................    //set_timer1(0);  // タイマーカウント初期値設定
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);   
01CC0:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01CC2:  MOVLW  C0
01CC4:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CC6:  MOVLW  FE
01CC8:  MOVWF  FF6
01CCA:  MOVLW  00
01CCC:  MOVWF  FF7
01CCE:  MOVLW  00
01CD0:  MOVWF  FF8
01CD2:  CALL   1BC0
01CD6:  GOTO   B494 (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
031C2:  MOVFF  20,00
031C6:  MOVFF  21,01
031CA:  MOVFF  22,02
031CE:  MOVFF  23,03
031D2:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
*
06854:  BCF    FD8.1
06856:  MOVFF  1F,9E0
0685A:  MOVFF  1E,9DF
0685E:  MOVFF  1D,9DE
06862:  MOVFF  1C,9DD
06866:  MOVLB  9
06868:  CLRF   xE4
0686A:  CLRF   xE3
0686C:  CLRF   xE2
0686E:  MOVLW  0A
06870:  MOVWF  xE1
06872:  MOVLB  0
06874:  CALL   677A
06878:  MOVF   01,W
0687A:  MOVWF  02
0687C:  MOVF   00,W
0687E:  MOVWF  01
06880:  GOTO   689C (RETURN)
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/mcu/src/uart.c"
.................... #INT_RDA3
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  47.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   46,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   46,W
0014C:  INCF   46,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  26
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,AC4
00160:  MOVFF  FE9,AC3
00164:  GOTO   010A
00168:  MOVFF  AC4,FEA
0016C:  MOVFF  AC3,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
.................... 
....................    // fprintf(PC, "RDA Interrupt: %d bytes received\r\n", boss_receive_buffer_size);
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01C74:  MOVLW  7A
01C76:  MOVWF  FF6
01C78:  MOVLW  01
01C7A:  MOVWF  FF7
01C7C:  MOVLW  00
01C7E:  MOVWF  FF8
01C80:  CALL   1BC0
....................    enable_interrupts(INT_RDA3);
01C84:  BSF    F61.5
....................    enable_interrupts(global);
01C86:  MOVLW  C0
01C88:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01C8A:  MOVLW  8C
01C8C:  MOVWF  FF6
01C8E:  MOVLW  01
01C90:  MOVWF  FF7
01C92:  MOVLW  00
01C94:  MOVWF  FF8
01C96:  CALL   1BC0
01C9A:  GOTO   B490 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
04634:  MOVFF  18D,03
04638:  MOVLB  1
0463A:  MOVF   x8C,W
0463C:  MOVWF  FE9
0463E:  MOVFF  03,FEA
04642:  MOVFF  FEF,18E
04646:  MOVFF  18B,FEA
0464A:  MOVFF  18A,FE9
0464E:  CLRF   00
04650:  CLRF   02
04652:  MOVFF  18E,01
04656:  MOVLB  0
04658:  CALL   27A2
....................    *receive_signal_size = 0;
0465C:  MOVFF  18D,03
04660:  MOVLB  1
04662:  MOVF   x8C,W
04664:  MOVWF  FE9
04666:  MOVFF  03,FEA
0466A:  CLRF   FEF
0466C:  MOVLB  0
0466E:  GOTO   B632 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/ad7490_driver.c"
.................... #include "../ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01EB4:  MOVLW  98
01EB6:  MOVWF  FF6
01EB8:  MOVLW  01
01EBA:  MOVWF  FF7
01EBC:  MOVLW  00
01EBE:  MOVWF  FF8
01EC0:  CALL   1BC0
....................     output_high(ADC_CS); // Set CS pin high to deselect the ADC
01EC4:  MOVLW  F4
01EC6:  MOVWF  F93
01EC8:  BSF    F8A.1
....................     delay_ms(10); // Wait for the ADC to stabilize
01ECA:  MOVLW  0A
01ECC:  MOVLB  A
01ECE:  MOVWF  x74
01ED0:  MOVLB  0
01ED2:  CALL   1B40
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR); // Read a dummy value to initialize the ADC
01ED6:  MOVLW  05
01ED8:  MOVLB  9
01EDA:  MOVWF  xDD
01EDC:  MOVLB  0
01EDE:  CALL   1DB0
01EE2:  MOVFF  02,18B
01EE6:  MOVFF  01,18A
....................     delay_ms(1); // Wait for the ADC to stabilize after reading
01EEA:  MOVLW  01
01EEC:  MOVLB  A
01EEE:  MOVWF  x74
01EF0:  MOVLB  0
01EF2:  CALL   1B40
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01EF6:  MOVLW  09
01EF8:  MOVLB  A
01EFA:  MOVWF  xB3
01EFC:  MOVLB  0
01EFE:  CALL   1B6E
01F02:  MOVFF  18B,9CC
01F06:  MOVLW  37
01F08:  MOVLB  9
01F0A:  MOVWF  xCD
01F0C:  MOVLB  0
01F0E:  CALL   1E44
01F12:  MOVFF  18A,9CC
01F16:  MOVLW  37
01F18:  MOVLB  9
01F1A:  MOVWF  xCD
01F1C:  MOVLB  0
01F1E:  CALL   1E44
01F22:  MOVLW  0D
01F24:  MOVLB  A
01F26:  MOVWF  xB3
01F28:  MOVLB  0
01F2A:  CALL   1B6E
01F2E:  MOVLW  0A
01F30:  MOVLB  A
01F32:  MOVWF  xB3
01F34:  MOVLB  0
01F36:  CALL   1B6E
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F3A:  MOVLB  1
01F3C:  INCFSZ x8A,W
01F3E:  BRA    1F44
01F40:  BRA    1F4A
01F42:  MOVLB  0
01F44:  MOVLB  0
01F46:  GOTO   1F62
01F4A:  MOVLB  0
01F4C:  MOVLB  1
01F4E:  INCFSZ x8B,W
01F50:  BRA    1F56
01F52:  BRA    1F5C
01F54:  MOVLB  0
01F56:  MOVLB  0
01F58:  GOTO   1F62
01F5C:  MOVLB  0
01F5E:  GOTO   1F82
01F62:  MOVLB  1
01F64:  MOVF   x8A,F
01F66:  BTFSC  FD8.2
01F68:  BRA    1F70
01F6A:  MOVLB  0
01F6C:  GOTO   1F96
01F70:  MOVLB  0
01F72:  MOVLB  1
01F74:  MOVF   x8B,F
01F76:  BTFSC  FD8.2
01F78:  BRA    1F80
01F7A:  MOVLB  0
01F7C:  GOTO   1F96
01F80:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01F82:  MOVLW  AC
01F84:  MOVWF  FF6
01F86:  MOVLW  01
01F88:  MOVWF  FF7
01F8A:  MOVLW  00
01F8C:  MOVWF  FF8
01F8E:  CALL   1BC0
....................     } else {
01F92:  GOTO   1FA6
....................         fprintf(PC, "\tConnect successful\r\n");
01F96:  MOVLW  BE
01F98:  MOVWF  FF6
01F9A:  MOVLW  01
01F9C:  MOVWF  FF7
01F9E:  MOVLW  00
01FA0:  MOVWF  FF8
01FA2:  CALL   1BC0
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01FA6:  MOVLW  D4
01FA8:  MOVWF  FF6
01FAA:  MOVLW  01
01FAC:  MOVWF  FF7
01FAE:  MOVLW  00
01FB0:  MOVWF  FF8
01FB2:  CALL   1BC0
01FB6:  GOTO   B498 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01DB0:  MOVFF  9DD,9E4
01DB4:  GOTO   1CDA
01DB8:  MOVFF  02,9DF
01DBC:  MOVFF  01,9DE
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     // Send the command to the ADC
....................     output_low(ADC_CS); // Set CS pin low to select the ADC
01DC0:  MOVLW  F4
01DC2:  MOVWF  F93
01DC4:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01DC6:  MOVLW  0D
01DC8:  MOVWF  00
01DCA:  DECFSZ 00,F
01DCC:  BRA    1DCA
....................     spi_xfer(ADC_STREAM, cmd); // Dummy transfer to start communication
01DCE:  MOVFF  9DF,9E5
01DD2:  MOVFF  9DE,9E4
01DD6:  MOVLW  10
01DD8:  MOVLB  9
01DDA:  MOVWF  xE6
01DDC:  MOVLW  01
01DDE:  MOVWF  xE7
01DE0:  MOVLB  0
01DE2:  CALL   1D4A
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     delay_us(10); // Wait for the ADC to process the command
01DE6:  MOVLW  0D
01DE8:  MOVWF  00
01DEA:  DECFSZ 00,F
01DEC:  BRA    1DEA
....................     output_high(ADC_CS); // Set CS pin high to end communication
01DEE:  MOVLW  F4
01DF0:  MOVWF  F93
01DF2:  BSF    F8A.1
....................     delay_us(10); // Wait for the ADC to process the command
01DF4:  MOVLW  0D
01DF6:  MOVWF  00
01DF8:  DECFSZ 00,F
01DFA:  BRA    1DF8
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01DFC:  MOVLW  F4
01DFE:  MOVWF  F93
01E00:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01E02:  MOVLW  0D
01E04:  MOVWF  00
01E06:  DECFSZ 00,F
01E08:  BRA    1E06
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000); // Read data from ADC
01E0A:  MOVLB  9
01E0C:  CLRF   xE5
01E0E:  CLRF   xE4
01E10:  MOVLW  10
01E12:  MOVWF  xE6
01E14:  MOVLW  01
01E16:  MOVWF  xE7
01E18:  MOVLB  0
01E1A:  CALL   1D4A
01E1E:  MOVFF  02,9E1
01E22:  MOVFF  01,9E0
....................     output_high(ADC_CS); 
01E26:  MOVLW  F4
01E28:  MOVWF  F93
01E2A:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E2C:  MOVLB  9
01E2E:  MOVF   xE0,W
01E30:  MOVWF  xE2
01E32:  MOVF   xE1,W
01E34:  ANDLW  0F
01E36:  MOVWF  xE3
....................     
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E38:  MOVF   xE2,W
01E3A:  MOVWF  01
01E3C:  MOVF   xE3,W
01E3E:  MOVWF  02
01E40:  MOVLB  0
01E42:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/mcp4901_driver.c"
.................... #include "../mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
02192:  MOVLW  E0
02194:  MOVWF  FF6
02196:  MOVLW  01
02198:  MOVWF  FF7
0219A:  MOVLW  00
0219C:  MOVWF  FF8
0219E:  CALL   1BC0
....................     output_high(DAC1_CS); 
021A2:  MOVLW  F4
021A4:  MOVWF  F93
021A6:  BSF    F8A.3
....................     output_high(DAC2_CS); 
021A8:  MOVLW  F4
021AA:  MOVWF  F93
021AC:  BSF    F8A.0
....................     delay_ms(10); 
021AE:  MOVLW  0A
021B0:  MOVLB  A
021B2:  MOVWF  x74
021B4:  MOVLB  0
021B6:  CALL   1B40
....................     mcp4901_1_write(10); 
021BA:  MOVLB  9
021BC:  CLRF   xC9
021BE:  MOVLW  0A
021C0:  MOVWF  xC8
021C2:  MOVLB  0
021C4:  CALL   210E
....................     mcp4901_2_write(10); 
021C8:  MOVLB  9
021CA:  CLRF   xC9
021CC:  MOVLW  0A
021CE:  MOVWF  xC8
021D0:  MOVLB  0
021D2:  CALL   2150
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
021D6:  MOVLW  08
021D8:  MOVLB  9
021DA:  MOVWF  xDD
021DC:  MOVLB  0
021DE:  CALL   1DB0
021E2:  MOVFF  02,18B
021E6:  MOVFF  01,18A
....................     fprintf(PC, "%04LX\r\n", readdata);
021EA:  MOVFF  18B,9CC
021EE:  MOVLW  37
021F0:  MOVLB  9
021F2:  MOVWF  xCD
021F4:  MOVLB  0
021F6:  CALL   1E44
021FA:  MOVFF  18A,9CC
021FE:  MOVLW  37
02200:  MOVLB  9
02202:  MOVWF  xCD
02204:  MOVLB  0
02206:  CALL   1E44
0220A:  MOVLW  0D
0220C:  MOVLB  A
0220E:  MOVWF  xB3
02210:  MOVLB  0
02212:  CALL   1B6E
02216:  MOVLW  0A
02218:  MOVLB  A
0221A:  MOVWF  xB3
0221C:  MOVLB  0
0221E:  CALL   1B6E
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
02222:  MOVLB  1
02224:  INCFSZ x8A,W
02226:  BRA    222C
02228:  BRA    2232
0222A:  MOVLB  0
0222C:  MOVLB  0
0222E:  GOTO   224A
02232:  MOVLB  0
02234:  MOVLB  1
02236:  INCFSZ x8B,W
02238:  BRA    223E
0223A:  BRA    2244
0223C:  MOVLB  0
0223E:  MOVLB  0
02240:  GOTO   224A
02244:  MOVLB  0
02246:  GOTO   226A
0224A:  MOVLB  1
0224C:  MOVF   x8A,F
0224E:  BTFSC  FD8.2
02250:  BRA    2258
02252:  MOVLB  0
02254:  GOTO   227E
02258:  MOVLB  0
0225A:  MOVLB  1
0225C:  MOVF   x8B,F
0225E:  BTFSC  FD8.2
02260:  BRA    2268
02262:  MOVLB  0
02264:  GOTO   227E
02268:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
0226A:  MOVLW  F6
0226C:  MOVWF  FF6
0226E:  MOVLW  01
02270:  MOVWF  FF7
02272:  MOVLW  00
02274:  MOVWF  FF8
02276:  CALL   1BC0
....................     } else {
0227A:  GOTO   228E
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
0227E:  MOVLW  16
02280:  MOVWF  FF6
02282:  MOVLW  02
02284:  MOVWF  FF7
02286:  MOVLW  00
02288:  MOVWF  FF8
0228A:  CALL   1BC0
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
0228E:  MOVFF  18B,9CC
02292:  MOVLW  37
02294:  MOVLB  9
02296:  MOVWF  xCD
02298:  MOVLB  0
0229A:  CALL   1E44
0229E:  MOVFF  18A,9CC
022A2:  MOVLW  37
022A4:  MOVLB  9
022A6:  MOVWF  xCD
022A8:  MOVLB  0
022AA:  CALL   1E44
022AE:  MOVLW  0D
022B0:  MOVLB  A
022B2:  MOVWF  xB3
022B4:  MOVLB  0
022B6:  CALL   1B6E
022BA:  MOVLW  0A
022BC:  MOVLB  A
022BE:  MOVWF  xB3
022C0:  MOVLB  0
022C2:  CALL   1B6E
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
022C6:  MOVLW  09
022C8:  MOVLB  9
022CA:  MOVWF  xDD
022CC:  MOVLB  0
022CE:  CALL   1DB0
022D2:  MOVFF  02,18B
022D6:  MOVFF  01,18A
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
022DA:  MOVLB  1
022DC:  INCFSZ x8A,W
022DE:  BRA    22E4
022E0:  BRA    22EA
022E2:  MOVLB  0
022E4:  MOVLB  0
022E6:  GOTO   2302
022EA:  MOVLB  0
022EC:  MOVLB  1
022EE:  INCFSZ x8B,W
022F0:  BRA    22F6
022F2:  BRA    22FC
022F4:  MOVLB  0
022F6:  MOVLB  0
022F8:  GOTO   2302
022FC:  MOVLB  0
022FE:  GOTO   2322
02302:  MOVLB  1
02304:  MOVF   x8A,F
02306:  BTFSC  FD8.2
02308:  BRA    2310
0230A:  MOVLB  0
0230C:  GOTO   2336
02310:  MOVLB  0
02312:  MOVLB  1
02314:  MOVF   x8B,F
02316:  BTFSC  FD8.2
02318:  BRA    2320
0231A:  MOVLB  0
0231C:  GOTO   2336
02320:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
02322:  MOVLW  3A
02324:  MOVWF  FF6
02326:  MOVLW  02
02328:  MOVWF  FF7
0232A:  MOVLW  00
0232C:  MOVWF  FF8
0232E:  CALL   1BC0
....................     } else {
02332:  GOTO   2346
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02336:  MOVLW  5A
02338:  MOVWF  FF6
0233A:  MOVLW  02
0233C:  MOVWF  FF7
0233E:  MOVLW  00
02340:  MOVWF  FF8
02342:  CALL   1BC0
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02346:  MOVLW  7E
02348:  MOVWF  FF6
0234A:  MOVLW  02
0234C:  MOVWF  FF7
0234E:  MOVLW  00
02350:  MOVWF  FF8
02352:  CALL   1BC0
02356:  GOTO   B49C (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
0210E:  MOVFF  9C9,9CD
02112:  MOVFF  9C8,9CC
02116:  CALL   1FBA
0211A:  MOVFF  02,9CB
0211E:  MOVFF  01,9CA
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
02122:  MOVLW  F4
02124:  MOVWF  F93
02126:  BCF    F8A.3
....................    delay_us(10); 
02128:  MOVLW  0D
0212A:  MOVWF  00
0212C:  DECFSZ 00,F
0212E:  BRA    212C
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02130:  MOVFF  9CB,9E5
02134:  MOVFF  9CA,9E4
02138:  MOVLW  10
0213A:  MOVLB  9
0213C:  MOVWF  xE6
0213E:  MOVLW  01
02140:  MOVWF  xE7
02142:  MOVLB  0
02144:  CALL   1D4A
....................    output_high(DAC1_CS); 
02148:  MOVLW  F4
0214A:  MOVWF  F93
0214C:  BSF    F8A.3
0214E:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
02150:  MOVFF  9C9,9CD
02154:  MOVFF  9C8,9CC
02158:  CALL   1FBA
0215C:  MOVFF  02,9CB
02160:  MOVFF  01,9CA
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
02164:  MOVLW  F4
02166:  MOVWF  F93
02168:  BCF    F8A.0
....................    delay_us(10); 
0216A:  MOVLW  0D
0216C:  MOVWF  00
0216E:  DECFSZ 00,F
02170:  BRA    216E
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02172:  MOVFF  9CB,9E5
02176:  MOVFF  9CA,9E4
0217A:  MOVLW  10
0217C:  MOVLB  9
0217E:  MOVWF  xE6
02180:  MOVLW  01
02182:  MOVWF  xE7
02184:  MOVLB  0
02186:  CALL   1D4A
....................    output_high(DAC2_CS); 
0218A:  MOVLW  F4
0218C:  MOVWF  F93
0218E:  BSF    F8A.0
02190:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01CDA:  MOVLB  9
01CDC:  BCF    xE5.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01CDE:  BCF    xE5.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01CE0:  BCF    xE5.2
....................     cmd.fields.reserved3 = 0;
01CE2:  BCF    xE5.3
....................     cmd.fields.coding = 1; // Two's complement
01CE4:  BSF    xE5.4
....................     cmd.fields.range = 0; // Normal mode
01CE6:  BCF    xE5.5
....................     cmd.fields.weak_tri = 0; // Strong trigger
01CE8:  BCF    xE5.6
....................     cmd.fields.shadow = 0; // Direct access
01CEA:  BCF    xE5.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01CEC:  BSF    xE6.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01CEE:  BSF    xE6.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01CF0:  MOVF   xE4,W
01CF2:  ANDLW  01
01CF4:  MOVWF  01
01CF6:  BCF    xE6.2
01CF8:  BTFSC  01.0
01CFA:  BSF    xE6.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01CFC:  BCF    FD8.0
01CFE:  RRCF   xE4,W
01D00:  ANDLW  01
01D02:  MOVWF  01
01D04:  BCF    xE6.3
01D06:  BTFSC  01.0
01D08:  BSF    xE6.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01D0A:  RRCF   xE4,W
01D0C:  MOVWF  00
01D0E:  RRCF   00,F
01D10:  MOVLW  3F
01D12:  ANDWF  00,F
01D14:  MOVF   00,W
01D16:  ANDLW  01
01D18:  MOVWF  01
01D1A:  BCF    xE6.4
01D1C:  BTFSC  01.0
01D1E:  BSF    xE6.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D20:  RRCF   xE4,W
01D22:  MOVWF  00
01D24:  RRCF   00,F
01D26:  RRCF   00,F
01D28:  MOVLW  1F
01D2A:  ANDWF  00,F
01D2C:  MOVF   00,W
01D2E:  ANDLW  01
01D30:  MOVWF  01
01D32:  BCF    xE6.5
01D34:  BTFSC  01.0
01D36:  BSF    xE6.5
....................     cmd.fields.seq = 0; // Random mode
01D38:  BCF    xE6.6
....................     cmd.fields.write = 1; // Read operation
01D3A:  BSF    xE6.7
.................... 
.................... 
....................     return cmd.value;
01D3C:  MOVF   xE5,W
01D3E:  MOVWF  01
01D40:  MOVF   xE6,W
01D42:  MOVWF  02
01D44:  MOVLB  0
01D46:  GOTO   1DB8 (RETURN)
.................... }
.................... 
.................... #include "../../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
01FBA:  MOVLB  9
01FBC:  BCF    xCF.7
....................    cmd.fields.buffer = 1; // Buffer used
01FBE:  BSF    xCF.6
....................    cmd.fields.gain = 1; // Gain 1x
01FC0:  BSF    xCF.5
....................    cmd.fields.shutdown = 1; // Normal operation
01FC2:  BSF    xCF.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
01FC4:  RRCF   xCD,W
01FC6:  MOVWF  xD1
01FC8:  RRCF   xCC,W
01FCA:  MOVWF  xD0
01FCC:  RRCF   xD1,F
01FCE:  RRCF   xD0,F
01FD0:  RRCF   xD1,F
01FD2:  RRCF   xD0,F
01FD4:  RRCF   xD1,F
01FD6:  RRCF   xD0,F
01FD8:  RRCF   xD1,F
01FDA:  RRCF   xD0,F
01FDC:  RRCF   xD1,F
01FDE:  RRCF   xD0,F
01FE0:  RRCF   xD1,F
01FE2:  RRCF   xD0,F
01FE4:  MOVLW  01
01FE6:  ANDWF  xD1,F
01FE8:  MOVF   xD0,W
01FEA:  ANDLW  01
01FEC:  MOVWF  00
01FEE:  CLRF   03
01FF0:  MOVF   00,W
01FF2:  MOVWF  01
01FF4:  BCF    xCF.3
01FF6:  BTFSC  01.0
01FF8:  BSF    xCF.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
01FFA:  RRCF   xCD,W
01FFC:  MOVWF  xD1
01FFE:  RRCF   xCC,W
02000:  MOVWF  xD0
02002:  RRCF   xD1,F
02004:  RRCF   xD0,F
02006:  RRCF   xD1,F
02008:  RRCF   xD0,F
0200A:  RRCF   xD1,F
0200C:  RRCF   xD0,F
0200E:  RRCF   xD1,F
02010:  RRCF   xD0,F
02012:  RRCF   xD1,F
02014:  RRCF   xD0,F
02016:  MOVLW  03
02018:  ANDWF  xD1,F
0201A:  MOVF   xD0,W
0201C:  ANDLW  01
0201E:  MOVWF  00
02020:  CLRF   03
02022:  MOVF   00,W
02024:  MOVWF  01
02026:  BCF    xCF.2
02028:  BTFSC  01.0
0202A:  BSF    xCF.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
0202C:  RRCF   xCD,W
0202E:  MOVWF  xD1
02030:  RRCF   xCC,W
02032:  MOVWF  xD0
02034:  RRCF   xD1,F
02036:  RRCF   xD0,F
02038:  RRCF   xD1,F
0203A:  RRCF   xD0,F
0203C:  RRCF   xD1,F
0203E:  RRCF   xD0,F
02040:  RRCF   xD1,F
02042:  RRCF   xD0,F
02044:  MOVLW  07
02046:  ANDWF  xD1,F
02048:  MOVF   xD0,W
0204A:  ANDLW  01
0204C:  MOVWF  00
0204E:  CLRF   03
02050:  MOVF   00,W
02052:  MOVWF  01
02054:  BCF    xCF.1
02056:  BTFSC  01.0
02058:  BSF    xCF.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
0205A:  RRCF   xCD,W
0205C:  MOVWF  xD1
0205E:  RRCF   xCC,W
02060:  MOVWF  xD0
02062:  RRCF   xD1,F
02064:  RRCF   xD0,F
02066:  RRCF   xD1,F
02068:  RRCF   xD0,F
0206A:  RRCF   xD1,F
0206C:  RRCF   xD0,F
0206E:  MOVLW  0F
02070:  ANDWF  xD1,F
02072:  MOVF   xD0,W
02074:  ANDLW  01
02076:  MOVWF  00
02078:  CLRF   03
0207A:  MOVF   00,W
0207C:  MOVWF  01
0207E:  BCF    xCF.0
02080:  BTFSC  01.0
02082:  BSF    xCF.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
02084:  RRCF   xCD,W
02086:  MOVWF  xD1
02088:  RRCF   xCC,W
0208A:  MOVWF  xD0
0208C:  RRCF   xD1,F
0208E:  RRCF   xD0,F
02090:  RRCF   xD1,F
02092:  RRCF   xD0,F
02094:  MOVLW  1F
02096:  ANDWF  xD1,F
02098:  MOVF   xD0,W
0209A:  ANDLW  01
0209C:  MOVWF  00
0209E:  CLRF   03
020A0:  MOVF   00,W
020A2:  MOVWF  01
020A4:  BCF    xCE.7
020A6:  BTFSC  01.0
020A8:  BSF    xCE.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
020AA:  RRCF   xCD,W
020AC:  MOVWF  xD1
020AE:  RRCF   xCC,W
020B0:  MOVWF  xD0
020B2:  RRCF   xD1,F
020B4:  RRCF   xD0,F
020B6:  MOVLW  3F
020B8:  ANDWF  xD1,F
020BA:  MOVF   xD0,W
020BC:  ANDLW  01
020BE:  MOVWF  00
020C0:  CLRF   03
020C2:  MOVF   00,W
020C4:  MOVWF  01
020C6:  BCF    xCE.6
020C8:  BTFSC  01.0
020CA:  BSF    xCE.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
020CC:  BCF    FD8.0
020CE:  RRCF   xCD,W
020D0:  MOVWF  xD1
020D2:  RRCF   xCC,W
020D4:  MOVWF  xD0
020D6:  MOVF   xD0,W
020D8:  ANDLW  01
020DA:  MOVWF  00
020DC:  CLRF   03
020DE:  MOVF   00,W
020E0:  MOVWF  01
020E2:  BCF    xCE.5
020E4:  BTFSC  01.0
020E6:  BSF    xCE.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
020E8:  MOVF   xCC,W
020EA:  ANDLW  01
020EC:  MOVWF  00
020EE:  CLRF   03
020F0:  MOVF   00,W
020F2:  MOVWF  01
020F4:  BCF    xCE.4
020F6:  BTFSC  01.0
020F8:  BSF    xCE.4
....................    cmd.fields.reserved = 0; // Reserved bits
020FA:  BCF    xCE.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
020FC:  BCF    xCE.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
020FE:  BCF    xCE.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
02100:  BCF    xCE.0
.................... 
....................    return cmd.value;
02102:  MOVF   xCE,W
02104:  MOVWF  01
02106:  MOVF   xCF,W
02108:  MOVWF  02
0210A:  MOVLB  0
0210C:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
031D4:  MOVLB  A
031D6:  MOVF   x74,W
031D8:  XORLW  00
031DA:  MOVLB  0
031DC:  BTFSC  FD8.2
031DE:  GOTO   31EE
031E2:  XORLW  01
031E4:  BTFSC  FD8.2
031E6:  GOTO   3256
031EA:  GOTO   32BE
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
031EE:  MOVLB  A
031F0:  CLRF   x7D
031F2:  CLRF   x7C
031F4:  MOVLB  0
031F6:  MOVLB  A
031F8:  MOVF   x7D,W
031FA:  SUBWF  x7B,W
031FC:  BTFSC  FD8.0
031FE:  BRA    3206
03200:  MOVLB  0
03202:  GOTO   3252
03206:  MOVLB  0
03208:  BTFSS  FD8.2
0320A:  GOTO   3220
0320E:  MOVLB  A
03210:  MOVF   x7A,W
03212:  SUBWF  x7C,W
03214:  BTFSS  FD8.0
03216:  BRA    321E
03218:  MOVLB  0
0321A:  GOTO   3252
0321E:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
03220:  MOVLB  A
03222:  MOVF   x78,W
03224:  ADDWF  x7C,W
03226:  MOVWF  FE9
03228:  MOVF   x79,W
0322A:  ADDWFC x7D,W
0322C:  MOVWF  FEA
0322E:  MOVFF  FEF,A80
03232:  MOVFF  A80,A96
03236:  MOVLW  08
03238:  MOVWF  x97
0323A:  MOVLW  01
0323C:  MOVWF  x98
0323E:  MOVLB  0
03240:  CALL   23AE
03244:  MOVLB  A
03246:  INCF   x7C,F
03248:  BTFSC  FD8.2
0324A:  INCF   x7D,F
0324C:  MOVLB  0
0324E:  GOTO   31F6
....................          break;
03252:  GOTO   32C2
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03256:  MOVLB  A
03258:  CLRF   x7F
0325A:  CLRF   x7E
0325C:  MOVLB  0
0325E:  MOVLB  A
03260:  MOVF   x7F,W
03262:  SUBWF  x7B,W
03264:  BTFSC  FD8.0
03266:  BRA    326E
03268:  MOVLB  0
0326A:  GOTO   32BA
0326E:  MOVLB  0
03270:  BTFSS  FD8.2
03272:  GOTO   3288
03276:  MOVLB  A
03278:  MOVF   x7A,W
0327A:  SUBWF  x7E,W
0327C:  BTFSS  FD8.0
0327E:  BRA    3286
03280:  MOVLB  0
03282:  GOTO   32BA
03286:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
03288:  MOVLB  A
0328A:  MOVF   x78,W
0328C:  ADDWF  x7E,W
0328E:  MOVWF  FE9
03290:  MOVF   x79,W
03292:  ADDWFC x7F,W
03294:  MOVWF  FEA
03296:  MOVFF  FEF,A80
0329A:  MOVFF  A80,A96
0329E:  MOVLW  08
032A0:  MOVWF  x97
032A2:  MOVLW  01
032A4:  MOVWF  x98
032A6:  MOVLB  0
032A8:  CALL   242A
032AC:  MOVLB  A
032AE:  INCF   x7E,F
032B0:  BTFSC  FD8.2
032B2:  INCF   x7F,F
032B4:  MOVLB  0
032B6:  GOTO   325E
....................          break;
032BA:  GOTO   32C2
....................          
....................       default:
....................          break;
032BE:  GOTO   32C2
....................    }
....................    return;
032C2:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
024A6:  MOVLB  A
024A8:  MOVF   x7A,W
024AA:  XORLW  00
024AC:  MOVLB  0
024AE:  BTFSC  FD8.2
024B0:  GOTO   24C0
024B4:  XORLW  01
024B6:  BTFSC  FD8.2
024B8:  GOTO   25CA
024BC:  GOTO   26D4
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
024C0:  MOVLB  A
024C2:  CLRF   x89
024C4:  CLRF   x88
024C6:  MOVLB  0
024C8:  MOVLB  A
024CA:  MOVF   x89,W
024CC:  SUBWF  x81,W
024CE:  BTFSC  FD8.0
024D0:  BRA    24D8
024D2:  MOVLB  0
024D4:  GOTO   2524
024D8:  MOVLB  0
024DA:  BTFSS  FD8.2
024DC:  GOTO   24F2
024E0:  MOVLB  A
024E2:  MOVF   x80,W
024E4:  SUBWF  x88,W
024E6:  BTFSS  FD8.0
024E8:  BRA    24F0
024EA:  MOVLB  0
024EC:  GOTO   2524
024F0:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
024F2:  MOVLB  A
024F4:  MOVF   x7E,W
024F6:  ADDWF  x88,W
024F8:  MOVWF  FE9
024FA:  MOVF   x7F,W
024FC:  ADDWFC x89,W
024FE:  MOVWF  FEA
02500:  MOVFF  FEF,A94
02504:  MOVFF  A94,A96
02508:  MOVLW  08
0250A:  MOVWF  x97
0250C:  MOVLW  01
0250E:  MOVWF  x98
02510:  MOVLB  0
02512:  CALL   23AE
02516:  MOVLB  A
02518:  INCF   x88,F
0251A:  BTFSC  FD8.2
0251C:  INCF   x89,F
0251E:  MOVLB  0
02520:  GOTO   24C8
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02524:  MOVLB  A
02526:  CLRF   x8D
02528:  CLRF   x8C
0252A:  CLRF   x8B
0252C:  CLRF   x8A
0252E:  MOVLB  0
02530:  MOVLB  A
02532:  MOVF   x8D,W
02534:  SUBWF  x87,W
02536:  BTFSC  FD8.0
02538:  BRA    2540
0253A:  MOVLB  0
0253C:  GOTO   25C6
02540:  MOVLB  0
02542:  BTFSS  FD8.2
02544:  GOTO   258A
02548:  MOVLB  A
0254A:  MOVF   x8C,W
0254C:  SUBWF  x86,W
0254E:  BTFSC  FD8.0
02550:  BRA    2558
02552:  MOVLB  0
02554:  GOTO   25C6
02558:  MOVLB  0
0255A:  BTFSS  FD8.2
0255C:  GOTO   258A
02560:  MOVLB  A
02562:  MOVF   x8B,W
02564:  SUBWF  x85,W
02566:  BTFSC  FD8.0
02568:  BRA    2570
0256A:  MOVLB  0
0256C:  GOTO   25C6
02570:  MOVLB  0
02572:  BTFSS  FD8.2
02574:  GOTO   258A
02578:  MOVLB  A
0257A:  MOVF   x84,W
0257C:  SUBWF  x8A,W
0257E:  BTFSS  FD8.0
02580:  BRA    2588
02582:  MOVLB  0
02584:  GOTO   25C6
02588:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
0258A:  MOVLB  A
0258C:  MOVF   x82,W
0258E:  ADDWF  x8A,W
02590:  MOVWF  FE9
02592:  MOVF   x83,W
02594:  ADDWFC x8B,W
02596:  MOVWF  FEA
02598:  MOVLW  02
0259A:  MOVWF  x96
0259C:  MOVLW  08
0259E:  MOVWF  x97
025A0:  MOVLW  01
025A2:  MOVWF  x98
025A4:  MOVLB  0
025A6:  CALL   23AE
025AA:  MOVFF  01,FEF
025AE:  MOVLW  01
025B0:  MOVLB  A
025B2:  ADDWF  x8A,F
025B4:  BTFSC  FD8.0
025B6:  INCF   x8B,F
025B8:  BTFSC  FD8.2
025BA:  INCF   x8C,F
025BC:  BTFSC  FD8.2
025BE:  INCF   x8D,F
025C0:  MOVLB  0
025C2:  GOTO   2530
....................          break;
025C6:  GOTO   26D8
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025CA:  MOVLB  A
025CC:  CLRF   x8F
025CE:  CLRF   x8E
025D0:  MOVLB  0
025D2:  MOVLB  A
025D4:  MOVF   x8F,W
025D6:  SUBWF  x81,W
025D8:  BTFSC  FD8.0
025DA:  BRA    25E2
025DC:  MOVLB  0
025DE:  GOTO   262E
025E2:  MOVLB  0
025E4:  BTFSS  FD8.2
025E6:  GOTO   25FC
025EA:  MOVLB  A
025EC:  MOVF   x80,W
025EE:  SUBWF  x8E,W
025F0:  BTFSS  FD8.0
025F2:  BRA    25FA
025F4:  MOVLB  0
025F6:  GOTO   262E
025FA:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
025FC:  MOVLB  A
025FE:  MOVF   x7E,W
02600:  ADDWF  x8E,W
02602:  MOVWF  FE9
02604:  MOVF   x7F,W
02606:  ADDWFC x8F,W
02608:  MOVWF  FEA
0260A:  MOVFF  FEF,A94
0260E:  MOVFF  A94,A96
02612:  MOVLW  08
02614:  MOVWF  x97
02616:  MOVLW  01
02618:  MOVWF  x98
0261A:  MOVLB  0
0261C:  CALL   242A
02620:  MOVLB  A
02622:  INCF   x8E,F
02624:  BTFSC  FD8.2
02626:  INCF   x8F,F
02628:  MOVLB  0
0262A:  GOTO   25D2
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0262E:  MOVLB  A
02630:  CLRF   x93
02632:  CLRF   x92
02634:  CLRF   x91
02636:  CLRF   x90
02638:  MOVLB  0
0263A:  MOVLB  A
0263C:  MOVF   x93,W
0263E:  SUBWF  x87,W
02640:  BTFSC  FD8.0
02642:  BRA    264A
02644:  MOVLB  0
02646:  GOTO   26D0
0264A:  MOVLB  0
0264C:  BTFSS  FD8.2
0264E:  GOTO   2694
02652:  MOVLB  A
02654:  MOVF   x92,W
02656:  SUBWF  x86,W
02658:  BTFSC  FD8.0
0265A:  BRA    2662
0265C:  MOVLB  0
0265E:  GOTO   26D0
02662:  MOVLB  0
02664:  BTFSS  FD8.2
02666:  GOTO   2694
0266A:  MOVLB  A
0266C:  MOVF   x91,W
0266E:  SUBWF  x85,W
02670:  BTFSC  FD8.0
02672:  BRA    267A
02674:  MOVLB  0
02676:  GOTO   26D0
0267A:  MOVLB  0
0267C:  BTFSS  FD8.2
0267E:  GOTO   2694
02682:  MOVLB  A
02684:  MOVF   x84,W
02686:  SUBWF  x90,W
02688:  BTFSS  FD8.0
0268A:  BRA    2692
0268C:  MOVLB  0
0268E:  GOTO   26D0
02692:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
02694:  MOVLB  A
02696:  MOVF   x82,W
02698:  ADDWF  x90,W
0269A:  MOVWF  FE9
0269C:  MOVF   x83,W
0269E:  ADDWFC x91,W
026A0:  MOVWF  FEA
026A2:  MOVLW  01
026A4:  MOVWF  x96
026A6:  MOVLW  08
026A8:  MOVWF  x97
026AA:  MOVLW  01
026AC:  MOVWF  x98
026AE:  MOVLB  0
026B0:  CALL   242A
026B4:  MOVFF  01,FEF
026B8:  MOVLW  01
026BA:  MOVLB  A
026BC:  ADDWF  x90,F
026BE:  BTFSC  FD8.0
026C0:  INCF   x91,F
026C2:  BTFSC  FD8.2
026C4:  INCF   x92,F
026C6:  BTFSC  FD8.2
026C8:  INCF   x93,F
026CA:  MOVLB  0
026CC:  GOTO   263A
....................          break;
026D0:  GOTO   26D8
....................    
....................          
....................       default:
....................          break;
026D4:  GOTO   26D8
....................    }
....................    return;
026D8:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
032C4:  MOVLB  A
032C6:  MOVF   x74,W
032C8:  XORLW  00
032CA:  MOVLB  0
032CC:  BTFSC  FD8.2
032CE:  GOTO   32DE
032D2:  XORLW  01
032D4:  BTFSC  FD8.2
032D6:  GOTO   338C
032DA:  GOTO   343A
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
032DE:  MOVLB  A
032E0:  CLRF   x7F
032E2:  MOVLB  0
032E4:  MOVLB  A
032E6:  MOVF   x7A,W
032E8:  SUBWF  x7F,W
032EA:  BTFSS  FD8.0
032EC:  BRA    32F4
032EE:  MOVLB  0
032F0:  GOTO   3324
032F4:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
032F6:  MOVLB  A
032F8:  MOVF   x7F,W
032FA:  ADDWF  x78,W
032FC:  MOVWF  FE9
032FE:  MOVLW  00
03300:  ADDWFC x79,W
03302:  MOVWF  FEA
03304:  MOVFF  FEF,A85
03308:  MOVFF  A85,A96
0330C:  MOVLW  08
0330E:  MOVWF  x97
03310:  MOVLW  01
03312:  MOVWF  x98
03314:  MOVLB  0
03316:  CALL   23AE
0331A:  MOVLB  A
0331C:  INCF   x7F,F
0331E:  MOVLB  0
03320:  GOTO   32E4
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03324:  MOVLB  A
03326:  CLRF   x81
03328:  CLRF   x80
0332A:  MOVLB  0
0332C:  MOVLB  A
0332E:  MOVF   x81,W
03330:  SUBWF  x7E,W
03332:  BTFSC  FD8.0
03334:  BRA    333C
03336:  MOVLB  0
03338:  GOTO   3388
0333C:  MOVLB  0
0333E:  BTFSS  FD8.2
03340:  GOTO   3356
03344:  MOVLB  A
03346:  MOVF   x7D,W
03348:  SUBWF  x80,W
0334A:  BTFSS  FD8.0
0334C:  BRA    3354
0334E:  MOVLB  0
03350:  GOTO   3388
03354:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
03356:  MOVLB  A
03358:  MOVF   x7B,W
0335A:  ADDWF  x80,W
0335C:  MOVWF  FE9
0335E:  MOVF   x7C,W
03360:  ADDWFC x81,W
03362:  MOVWF  FEA
03364:  MOVFF  FEF,A85
03368:  MOVFF  A85,A96
0336C:  MOVLW  08
0336E:  MOVWF  x97
03370:  MOVLW  01
03372:  MOVWF  x98
03374:  MOVLB  0
03376:  CALL   23AE
0337A:  MOVLB  A
0337C:  INCF   x80,F
0337E:  BTFSC  FD8.2
03380:  INCF   x81,F
03382:  MOVLB  0
03384:  GOTO   332C
....................          break;
03388:  GOTO   343E
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
0338C:  MOVLB  A
0338E:  CLRF   x82
03390:  MOVLB  0
03392:  MOVLB  A
03394:  MOVF   x7A,W
03396:  SUBWF  x82,W
03398:  BTFSS  FD8.0
0339A:  BRA    33A2
0339C:  MOVLB  0
0339E:  GOTO   33D2
033A2:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
033A4:  MOVLB  A
033A6:  MOVF   x82,W
033A8:  ADDWF  x78,W
033AA:  MOVWF  FE9
033AC:  MOVLW  00
033AE:  ADDWFC x79,W
033B0:  MOVWF  FEA
033B2:  MOVFF  FEF,A85
033B6:  MOVFF  A85,A96
033BA:  MOVLW  08
033BC:  MOVWF  x97
033BE:  MOVLW  01
033C0:  MOVWF  x98
033C2:  MOVLB  0
033C4:  CALL   242A
033C8:  MOVLB  A
033CA:  INCF   x82,F
033CC:  MOVLB  0
033CE:  GOTO   3392
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
033D2:  MOVLB  A
033D4:  CLRF   x84
033D6:  CLRF   x83
033D8:  MOVLB  0
033DA:  MOVLB  A
033DC:  MOVF   x84,W
033DE:  SUBWF  x7E,W
033E0:  BTFSC  FD8.0
033E2:  BRA    33EA
033E4:  MOVLB  0
033E6:  GOTO   3436
033EA:  MOVLB  0
033EC:  BTFSS  FD8.2
033EE:  GOTO   3404
033F2:  MOVLB  A
033F4:  MOVF   x7D,W
033F6:  SUBWF  x83,W
033F8:  BTFSS  FD8.0
033FA:  BRA    3402
033FC:  MOVLB  0
033FE:  GOTO   3436
03402:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
03404:  MOVLB  A
03406:  MOVF   x7B,W
03408:  ADDWF  x83,W
0340A:  MOVWF  FE9
0340C:  MOVF   x7C,W
0340E:  ADDWFC x84,W
03410:  MOVWF  FEA
03412:  MOVFF  FEF,A85
03416:  MOVFF  A85,A96
0341A:  MOVLW  08
0341C:  MOVWF  x97
0341E:  MOVLW  01
03420:  MOVWF  x98
03422:  MOVLB  0
03424:  CALL   242A
03428:  MOVLB  A
0342A:  INCF   x83,F
0342C:  BTFSC  FD8.2
0342E:  INCF   x84,F
03430:  MOVLB  0
03432:  GOTO   33DA
....................          break;
03436:  GOTO   343E
....................          
....................       default:
....................          break;
0343A:  GOTO   343E
....................    }
....................    return;
0343E:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
05492:  MOVFF  2A0,A7A
05496:  MOVLW  01
05498:  MOVLB  A
0549A:  MOVWF  x7B
0549C:  MOVLW  0F
0549E:  MOVWF  x7D
054A0:  MOVLW  89
054A2:  MOVWF  x7C
054A4:  MOVLB  0
054A6:  CALL   235A
054AA:  MOVFF  2A0,A7A
054AE:  MOVLB  A
054B0:  CLRF   x7B
054B2:  MOVLW  0F
054B4:  MOVWF  x7D
054B6:  MOVLW  92
054B8:  MOVWF  x7C
054BA:  MOVLB  0
054BC:  CALL   235A
054C0:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
03440:  MOVLW  05
03442:  MOVLB  A
03444:  MOVWF  x78
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
03446:  MOVFF  A76,A7A
0344A:  CLRF   x7B
0344C:  MOVLW  0F
0344E:  MOVWF  x7D
03450:  MOVLW  89
03452:  MOVWF  x7C
03454:  MOVLB  0
03456:  CALL   235A
0345A:  MOVFF  A76,A7A
0345E:  MOVLB  A
03460:  CLRF   x7B
03462:  MOVLW  0F
03464:  MOVWF  x7D
03466:  MOVLW  92
03468:  MOVWF  x7C
0346A:  MOVLB  0
0346C:  CALL   235A
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
03470:  MOVFF  A77,A7D
03474:  MOVFF  A76,A7C
03478:  MOVFF  A75,A7B
0347C:  MOVFF  A74,A7A
03480:  MOVLW  0A
03482:  MOVLB  A
03484:  MOVWF  x7F
03486:  MOVLW  78
03488:  MOVWF  x7E
0348A:  CLRF   x81
0348C:  MOVLW  01
0348E:  MOVWF  x80
03490:  MOVLW  0A
03492:  MOVWF  x83
03494:  MOVLW  79
03496:  MOVWF  x82
03498:  CLRF   x87
0349A:  CLRF   x86
0349C:  CLRF   x85
0349E:  MOVLW  01
034A0:  MOVWF  x84
034A2:  MOVLB  0
034A4:  CALL   24A6
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
034A8:  MOVFF  A76,A7A
034AC:  MOVLW  01
034AE:  MOVLB  A
034B0:  MOVWF  x7B
034B2:  MOVLW  0F
034B4:  MOVWF  x7D
034B6:  MOVLW  89
034B8:  MOVWF  x7C
034BA:  MOVLB  0
034BC:  CALL   235A
034C0:  MOVFF  A76,A7A
034C4:  MOVLB  A
034C6:  CLRF   x7B
034C8:  MOVLW  0F
034CA:  MOVWF  x7D
034CC:  MOVLW  92
034CE:  MOVWF  x7C
034D0:  MOVLB  0
034D2:  CALL   235A
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
034D6:  MOVLB  A
034D8:  MOVF   x79,W
034DA:  MOVWF  01
034DC:  MOVLB  0
034DE:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
03BBC:  MOVLB  A
03BBE:  MOVF   x5D,F
03BC0:  BTFSC  FD8.2
03BC2:  BRA    3BCA
03BC4:  MOVLB  0
03BC6:  GOTO   3D20
03BCA:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
03BCC:  MOVLW  06
03BCE:  MOVLB  A
03BD0:  MOVWF  x64
03BD2:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
03BD4:  MOVLW  D8
03BD6:  MOVLB  A
03BD8:  MOVWF  x65
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03BDA:  MOVFF  A62,A71
03BDE:  MOVFF  A63,A72
03BE2:  CLRF   x73
03BE4:  CLRF   x74
03BE6:  MOVF   x71,W
03BE8:  MOVWF  00
03BEA:  CLRF   01
03BEC:  CLRF   02
03BEE:  CLRF   03
03BF0:  MOVFF  00,A66
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03BF4:  MOVFF  A61,A71
03BF8:  MOVFF  A62,A72
03BFC:  MOVFF  A63,A73
03C00:  CLRF   x74
03C02:  MOVF   x71,W
03C04:  MOVWF  00
03C06:  CLRF   01
03C08:  CLRF   02
03C0A:  CLRF   03
03C0C:  MOVFF  00,A67
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
03C10:  MOVF   x60,W
03C12:  MOVWF  00
03C14:  CLRF   01
03C16:  CLRF   02
03C18:  CLRF   03
03C1A:  MOVFF  00,A68
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03C1E:  MOVFF  A5E,A7A
03C22:  CLRF   x7B
03C24:  MOVLW  0F
03C26:  MOVWF  x7D
03C28:  MOVLW  89
03C2A:  MOVWF  x7C
03C2C:  MOVLB  0
03C2E:  CALL   235A
03C32:  MOVFF  A5E,A7A
03C36:  MOVLB  A
03C38:  CLRF   x7B
03C3A:  MOVLW  0F
03C3C:  MOVWF  x7D
03C3E:  MOVLW  92
03C40:  MOVWF  x7C
03C42:  MOVLB  0
03C44:  CALL   235A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03C48:  MOVFF  A5F,A77
03C4C:  MOVFF  A5E,A76
03C50:  MOVFF  A5D,A75
03C54:  MOVFF  A5C,A74
03C58:  MOVLW  0A
03C5A:  MOVLB  A
03C5C:  MOVWF  x79
03C5E:  MOVLW  64
03C60:  MOVWF  x78
03C62:  CLRF   x7B
03C64:  MOVLW  01
03C66:  MOVWF  x7A
03C68:  MOVLB  0
03C6A:  CALL   31D4
....................       output_high(flash_stream.cs_pin);
03C6E:  MOVFF  A5E,A7A
03C72:  MOVLW  01
03C74:  MOVLB  A
03C76:  MOVWF  x7B
03C78:  MOVLW  0F
03C7A:  MOVWF  x7D
03C7C:  MOVLW  89
03C7E:  MOVWF  x7C
03C80:  MOVLB  0
03C82:  CALL   235A
03C86:  MOVFF  A5E,A7A
03C8A:  MOVLB  A
03C8C:  CLRF   x7B
03C8E:  MOVLW  0F
03C90:  MOVWF  x7D
03C92:  MOVLW  92
03C94:  MOVWF  x7C
03C96:  MOVLB  0
03C98:  CALL   235A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03C9C:  MOVFF  A5E,A7A
03CA0:  MOVLB  A
03CA2:  CLRF   x7B
03CA4:  MOVLW  0F
03CA6:  MOVWF  x7D
03CA8:  MOVLW  89
03CAA:  MOVWF  x7C
03CAC:  MOVLB  0
03CAE:  CALL   235A
03CB2:  MOVFF  A5E,A7A
03CB6:  MOVLB  A
03CB8:  CLRF   x7B
03CBA:  MOVLW  0F
03CBC:  MOVWF  x7D
03CBE:  MOVLW  92
03CC0:  MOVWF  x7C
03CC2:  MOVLB  0
03CC4:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
03CC8:  MOVFF  A5F,A77
03CCC:  MOVFF  A5E,A76
03CD0:  MOVFF  A5D,A75
03CD4:  MOVFF  A5C,A74
03CD8:  MOVLW  0A
03CDA:  MOVLB  A
03CDC:  MOVWF  x79
03CDE:  MOVLW  65
03CE0:  MOVWF  x78
03CE2:  CLRF   x7B
03CE4:  MOVLW  04
03CE6:  MOVWF  x7A
03CE8:  MOVLB  0
03CEA:  CALL   31D4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03CEE:  MOVFF  A5E,A7A
03CF2:  MOVLW  01
03CF4:  MOVLB  A
03CF6:  MOVWF  x7B
03CF8:  MOVLW  0F
03CFA:  MOVWF  x7D
03CFC:  MOVLW  89
03CFE:  MOVWF  x7C
03D00:  MOVLB  0
03D02:  CALL   235A
03D06:  MOVFF  A5E,A7A
03D0A:  MOVLB  A
03D0C:  CLRF   x7B
03D0E:  MOVLW  0F
03D10:  MOVWF  x7D
03D12:  MOVLW  92
03D14:  MOVWF  x7C
03D16:  MOVLB  0
03D18:  CALL   235A
....................    }
03D1C:  GOTO   3E9E
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
03D20:  MOVLB  A
03D22:  DECFSZ x5D,W
03D24:  BRA    3D2A
03D26:  BRA    3D30
03D28:  MOVLB  0
03D2A:  MOVLB  0
03D2C:  GOTO   3E9E
03D30:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
03D32:  MOVLW  06
03D34:  MOVLB  A
03D36:  MOVWF  x69
03D38:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
03D3A:  MOVLW  DC
03D3C:  MOVLB  A
03D3E:  MOVWF  x6A
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
03D40:  MOVFF  A63,A71
03D44:  CLRF   x72
03D46:  CLRF   x73
03D48:  CLRF   x74
03D4A:  MOVF   x71,W
03D4C:  MOVWF  00
03D4E:  CLRF   01
03D50:  CLRF   02
03D52:  CLRF   03
03D54:  MOVFF  00,A6B
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03D58:  MOVFF  A62,A71
03D5C:  MOVFF  A63,A72
03D60:  CLRF   x73
03D62:  CLRF   x74
03D64:  MOVF   x71,W
03D66:  MOVWF  00
03D68:  CLRF   01
03D6A:  CLRF   02
03D6C:  CLRF   03
03D6E:  MOVFF  00,A6C
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03D72:  MOVFF  A61,A71
03D76:  MOVFF  A62,A72
03D7A:  MOVFF  A63,A73
03D7E:  CLRF   x74
03D80:  MOVF   x71,W
03D82:  MOVWF  00
03D84:  CLRF   01
03D86:  CLRF   02
03D88:  CLRF   03
03D8A:  MOVFF  00,A6D
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
03D8E:  MOVF   x60,W
03D90:  MOVWF  00
03D92:  CLRF   01
03D94:  CLRF   02
03D96:  CLRF   03
03D98:  MOVFF  00,A6E
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03D9C:  MOVFF  A5E,A7A
03DA0:  CLRF   x7B
03DA2:  MOVLW  0F
03DA4:  MOVWF  x7D
03DA6:  MOVLW  89
03DA8:  MOVWF  x7C
03DAA:  MOVLB  0
03DAC:  CALL   235A
03DB0:  MOVFF  A5E,A7A
03DB4:  MOVLB  A
03DB6:  CLRF   x7B
03DB8:  MOVLW  0F
03DBA:  MOVWF  x7D
03DBC:  MOVLW  92
03DBE:  MOVWF  x7C
03DC0:  MOVLB  0
03DC2:  CALL   235A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03DC6:  MOVFF  A5F,A77
03DCA:  MOVFF  A5E,A76
03DCE:  MOVFF  A5D,A75
03DD2:  MOVFF  A5C,A74
03DD6:  MOVLW  0A
03DD8:  MOVLB  A
03DDA:  MOVWF  x79
03DDC:  MOVLW  69
03DDE:  MOVWF  x78
03DE0:  CLRF   x7B
03DE2:  MOVLW  01
03DE4:  MOVWF  x7A
03DE6:  MOVLB  0
03DE8:  CALL   31D4
....................       output_high(flash_stream.cs_pin);
03DEC:  MOVFF  A5E,A7A
03DF0:  MOVLW  01
03DF2:  MOVLB  A
03DF4:  MOVWF  x7B
03DF6:  MOVLW  0F
03DF8:  MOVWF  x7D
03DFA:  MOVLW  89
03DFC:  MOVWF  x7C
03DFE:  MOVLB  0
03E00:  CALL   235A
03E04:  MOVFF  A5E,A7A
03E08:  MOVLB  A
03E0A:  CLRF   x7B
03E0C:  MOVLW  0F
03E0E:  MOVWF  x7D
03E10:  MOVLW  92
03E12:  MOVWF  x7C
03E14:  MOVLB  0
03E16:  CALL   235A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03E1A:  MOVFF  A5E,A7A
03E1E:  MOVLB  A
03E20:  CLRF   x7B
03E22:  MOVLW  0F
03E24:  MOVWF  x7D
03E26:  MOVLW  89
03E28:  MOVWF  x7C
03E2A:  MOVLB  0
03E2C:  CALL   235A
03E30:  MOVFF  A5E,A7A
03E34:  MOVLB  A
03E36:  CLRF   x7B
03E38:  MOVLW  0F
03E3A:  MOVWF  x7D
03E3C:  MOVLW  92
03E3E:  MOVWF  x7C
03E40:  MOVLB  0
03E42:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
03E46:  MOVFF  A5F,A77
03E4A:  MOVFF  A5E,A76
03E4E:  MOVFF  A5D,A75
03E52:  MOVFF  A5C,A74
03E56:  MOVLW  0A
03E58:  MOVLB  A
03E5A:  MOVWF  x79
03E5C:  MOVLW  6A
03E5E:  MOVWF  x78
03E60:  CLRF   x7B
03E62:  MOVLW  05
03E64:  MOVWF  x7A
03E66:  MOVLB  0
03E68:  CALL   31D4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03E6C:  MOVFF  A5E,A7A
03E70:  MOVLW  01
03E72:  MOVLB  A
03E74:  MOVWF  x7B
03E76:  MOVLW  0F
03E78:  MOVWF  x7D
03E7A:  MOVLW  89
03E7C:  MOVWF  x7C
03E7E:  MOVLB  0
03E80:  CALL   235A
03E84:  MOVFF  A5E,A7A
03E88:  MOVLB  A
03E8A:  CLRF   x7B
03E8C:  MOVLW  0F
03E8E:  MOVWF  x7D
03E90:  MOVLW  92
03E92:  MOVWF  x7C
03E94:  MOVLB  0
03E96:  CALL   235A
....................    }
03E9A:  GOTO   3E9E
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
03E9E:  MOVLB  A
03EA0:  CLRF   x6F
03EA2:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
03EA4:  MOVFF  A5F,A77
03EA8:  MOVFF  A5E,A76
03EAC:  MOVFF  A5D,A75
03EB0:  MOVFF  A5C,A74
03EB4:  CALL   3440
03EB8:  MOVF   01,W
03EBA:  ANDLW  01
03EBC:  SUBLW  01
03EBE:  BTFSS  FD8.2
03EC0:  GOTO   3F12
....................       if(timeout_counter > 10)
03EC4:  MOVLB  A
03EC6:  MOVF   x6F,W
03EC8:  SUBLW  0A
03ECA:  BTFSS  FD8.0
03ECC:  BRA    3ED4
03ECE:  MOVLB  0
03ED0:  GOTO   3EE6
03ED4:  MOVLB  0
....................          delay_ms(200);
03ED6:  MOVLW  C8
03ED8:  MOVLB  A
03EDA:  MOVWF  x74
03EDC:  MOVLB  0
03EDE:  CALL   1B40
03EE2:  GOTO   3EF2
....................       else
....................          delay_ms(10);   
03EE6:  MOVLW  0A
03EE8:  MOVLB  A
03EEA:  MOVWF  x74
03EEC:  MOVLB  0
03EEE:  CALL   1B40
....................       
....................       if(timeout_counter > 100){
03EF2:  MOVLB  A
03EF4:  MOVF   x6F,W
03EF6:  SUBLW  64
03EF8:  BTFSS  FD8.0
03EFA:  BRA    3F02
03EFC:  MOVLB  0
03EFE:  GOTO   3F08
03F02:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
03F04:  GOTO   3F12
....................       }  
....................       timeout_counter++;
03F08:  MOVLB  A
03F0A:  INCF   x6F,F
03F0C:  MOVLB  0
03F0E:  GOTO   3EA4
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
03F12:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
04A54:  MOVLB  2
04A56:  MOVF   xE9,F
04A58:  BTFSC  FD8.2
04A5A:  BRA    4A62
04A5C:  MOVLB  0
04A5E:  GOTO   4BC2
04A62:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
04A64:  MOVLW  06
04A66:  MOVLB  2
04A68:  MOVWF  xF0
04A6A:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
04A6C:  MOVLW  20
04A6E:  MOVLB  2
04A70:  MOVWF  xF1
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04A72:  MOVFF  2EE,2FD
04A76:  MOVFF  2EF,2FE
04A7A:  CLRF   xFF
04A7C:  MOVLB  3
04A7E:  CLRF   x00
04A80:  MOVLB  2
04A82:  MOVF   xFD,W
04A84:  MOVWF  00
04A86:  CLRF   01
04A88:  CLRF   02
04A8A:  CLRF   03
04A8C:  MOVFF  00,2F2
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04A90:  MOVFF  2ED,2FD
04A94:  MOVFF  2EE,2FE
04A98:  MOVFF  2EF,2FF
04A9C:  MOVLB  3
04A9E:  CLRF   x00
04AA0:  MOVLB  2
04AA2:  MOVF   xFD,W
04AA4:  MOVWF  00
04AA6:  CLRF   01
04AA8:  CLRF   02
04AAA:  CLRF   03
04AAC:  MOVFF  00,2F3
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04AB0:  MOVF   xEC,W
04AB2:  MOVWF  00
04AB4:  CLRF   01
04AB6:  CLRF   02
04AB8:  CLRF   03
04ABA:  MOVFF  00,2F4
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04ABE:  MOVFF  2EA,A7A
04AC2:  MOVLB  A
04AC4:  CLRF   x7B
04AC6:  MOVLW  0F
04AC8:  MOVWF  x7D
04ACA:  MOVLW  89
04ACC:  MOVWF  x7C
04ACE:  MOVLB  0
04AD0:  CALL   235A
04AD4:  MOVFF  2EA,A7A
04AD8:  MOVLB  A
04ADA:  CLRF   x7B
04ADC:  MOVLW  0F
04ADE:  MOVWF  x7D
04AE0:  MOVLW  92
04AE2:  MOVWF  x7C
04AE4:  MOVLB  0
04AE6:  CALL   235A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04AEA:  MOVFF  2EB,A77
04AEE:  MOVFF  2EA,A76
04AF2:  MOVFF  2E9,A75
04AF6:  MOVFF  2E8,A74
04AFA:  MOVLW  02
04AFC:  MOVLB  A
04AFE:  MOVWF  x79
04B00:  MOVLW  F0
04B02:  MOVWF  x78
04B04:  CLRF   x7B
04B06:  MOVLW  01
04B08:  MOVWF  x7A
04B0A:  MOVLB  0
04B0C:  CALL   31D4
....................       output_high(flash_stream.cs_pin);
04B10:  MOVFF  2EA,A7A
04B14:  MOVLW  01
04B16:  MOVLB  A
04B18:  MOVWF  x7B
04B1A:  MOVLW  0F
04B1C:  MOVWF  x7D
04B1E:  MOVLW  89
04B20:  MOVWF  x7C
04B22:  MOVLB  0
04B24:  CALL   235A
04B28:  MOVFF  2EA,A7A
04B2C:  MOVLB  A
04B2E:  CLRF   x7B
04B30:  MOVLW  0F
04B32:  MOVWF  x7D
04B34:  MOVLW  92
04B36:  MOVWF  x7C
04B38:  MOVLB  0
04B3A:  CALL   235A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04B3E:  MOVFF  2EA,A7A
04B42:  MOVLB  A
04B44:  CLRF   x7B
04B46:  MOVLW  0F
04B48:  MOVWF  x7D
04B4A:  MOVLW  89
04B4C:  MOVWF  x7C
04B4E:  MOVLB  0
04B50:  CALL   235A
04B54:  MOVFF  2EA,A7A
04B58:  MOVLB  A
04B5A:  CLRF   x7B
04B5C:  MOVLW  0F
04B5E:  MOVWF  x7D
04B60:  MOVLW  92
04B62:  MOVWF  x7C
04B64:  MOVLB  0
04B66:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
04B6A:  MOVFF  2EB,A77
04B6E:  MOVFF  2EA,A76
04B72:  MOVFF  2E9,A75
04B76:  MOVFF  2E8,A74
04B7A:  MOVLW  02
04B7C:  MOVLB  A
04B7E:  MOVWF  x79
04B80:  MOVLW  F1
04B82:  MOVWF  x78
04B84:  CLRF   x7B
04B86:  MOVLW  04
04B88:  MOVWF  x7A
04B8A:  MOVLB  0
04B8C:  CALL   31D4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04B90:  MOVFF  2EA,A7A
04B94:  MOVLW  01
04B96:  MOVLB  A
04B98:  MOVWF  x7B
04B9A:  MOVLW  0F
04B9C:  MOVWF  x7D
04B9E:  MOVLW  89
04BA0:  MOVWF  x7C
04BA2:  MOVLB  0
04BA4:  CALL   235A
04BA8:  MOVFF  2EA,A7A
04BAC:  MOVLB  A
04BAE:  CLRF   x7B
04BB0:  MOVLW  0F
04BB2:  MOVWF  x7D
04BB4:  MOVLW  92
04BB6:  MOVWF  x7C
04BB8:  MOVLB  0
04BBA:  CALL   235A
....................    }
04BBE:  GOTO   4D4E
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04BC2:  MOVLB  2
04BC4:  DECFSZ xE9,W
04BC6:  BRA    4BCC
04BC8:  BRA    4BD2
04BCA:  MOVLB  0
04BCC:  MOVLB  0
04BCE:  GOTO   4D4E
04BD2:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04BD4:  MOVLW  06
04BD6:  MOVLB  2
04BD8:  MOVWF  xF5
04BDA:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
04BDC:  MOVLW  21
04BDE:  MOVLB  2
04BE0:  MOVWF  xF6
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04BE2:  MOVFF  2EF,2FD
04BE6:  CLRF   xFE
04BE8:  CLRF   xFF
04BEA:  MOVLB  3
04BEC:  CLRF   x00
04BEE:  MOVLB  2
04BF0:  MOVF   xFD,W
04BF2:  MOVWF  00
04BF4:  CLRF   01
04BF6:  CLRF   02
04BF8:  CLRF   03
04BFA:  MOVFF  00,2F7
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04BFE:  MOVFF  2EE,2FD
04C02:  MOVFF  2EF,2FE
04C06:  CLRF   xFF
04C08:  MOVLB  3
04C0A:  CLRF   x00
04C0C:  MOVLB  2
04C0E:  MOVF   xFD,W
04C10:  MOVWF  00
04C12:  CLRF   01
04C14:  CLRF   02
04C16:  CLRF   03
04C18:  MOVFF  00,2F8
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04C1C:  MOVFF  2ED,2FD
04C20:  MOVFF  2EE,2FE
04C24:  MOVFF  2EF,2FF
04C28:  MOVLB  3
04C2A:  CLRF   x00
04C2C:  MOVLB  2
04C2E:  MOVF   xFD,W
04C30:  MOVWF  00
04C32:  CLRF   01
04C34:  CLRF   02
04C36:  CLRF   03
04C38:  MOVFF  00,2F9
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04C3C:  MOVF   xEC,W
04C3E:  MOVWF  00
04C40:  CLRF   01
04C42:  CLRF   02
04C44:  CLRF   03
04C46:  MOVFF  00,2FA
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04C4A:  MOVFF  2EA,A7A
04C4E:  MOVLB  A
04C50:  CLRF   x7B
04C52:  MOVLW  0F
04C54:  MOVWF  x7D
04C56:  MOVLW  89
04C58:  MOVWF  x7C
04C5A:  MOVLB  0
04C5C:  CALL   235A
04C60:  MOVFF  2EA,A7A
04C64:  MOVLB  A
04C66:  CLRF   x7B
04C68:  MOVLW  0F
04C6A:  MOVWF  x7D
04C6C:  MOVLW  92
04C6E:  MOVWF  x7C
04C70:  MOVLB  0
04C72:  CALL   235A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04C76:  MOVFF  2EB,A77
04C7A:  MOVFF  2EA,A76
04C7E:  MOVFF  2E9,A75
04C82:  MOVFF  2E8,A74
04C86:  MOVLW  02
04C88:  MOVLB  A
04C8A:  MOVWF  x79
04C8C:  MOVLW  F5
04C8E:  MOVWF  x78
04C90:  CLRF   x7B
04C92:  MOVLW  01
04C94:  MOVWF  x7A
04C96:  MOVLB  0
04C98:  CALL   31D4
....................       output_high(flash_stream.cs_pin);
04C9C:  MOVFF  2EA,A7A
04CA0:  MOVLW  01
04CA2:  MOVLB  A
04CA4:  MOVWF  x7B
04CA6:  MOVLW  0F
04CA8:  MOVWF  x7D
04CAA:  MOVLW  89
04CAC:  MOVWF  x7C
04CAE:  MOVLB  0
04CB0:  CALL   235A
04CB4:  MOVFF  2EA,A7A
04CB8:  MOVLB  A
04CBA:  CLRF   x7B
04CBC:  MOVLW  0F
04CBE:  MOVWF  x7D
04CC0:  MOVLW  92
04CC2:  MOVWF  x7C
04CC4:  MOVLB  0
04CC6:  CALL   235A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04CCA:  MOVFF  2EA,A7A
04CCE:  MOVLB  A
04CD0:  CLRF   x7B
04CD2:  MOVLW  0F
04CD4:  MOVWF  x7D
04CD6:  MOVLW  89
04CD8:  MOVWF  x7C
04CDA:  MOVLB  0
04CDC:  CALL   235A
04CE0:  MOVFF  2EA,A7A
04CE4:  MOVLB  A
04CE6:  CLRF   x7B
04CE8:  MOVLW  0F
04CEA:  MOVWF  x7D
04CEC:  MOVLW  92
04CEE:  MOVWF  x7C
04CF0:  MOVLB  0
04CF2:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04CF6:  MOVFF  2EB,A77
04CFA:  MOVFF  2EA,A76
04CFE:  MOVFF  2E9,A75
04D02:  MOVFF  2E8,A74
04D06:  MOVLW  02
04D08:  MOVLB  A
04D0A:  MOVWF  x79
04D0C:  MOVLW  F6
04D0E:  MOVWF  x78
04D10:  CLRF   x7B
04D12:  MOVLW  05
04D14:  MOVWF  x7A
04D16:  MOVLB  0
04D18:  CALL   31D4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04D1C:  MOVFF  2EA,A7A
04D20:  MOVLW  01
04D22:  MOVLB  A
04D24:  MOVWF  x7B
04D26:  MOVLW  0F
04D28:  MOVWF  x7D
04D2A:  MOVLW  89
04D2C:  MOVWF  x7C
04D2E:  MOVLB  0
04D30:  CALL   235A
04D34:  MOVFF  2EA,A7A
04D38:  MOVLB  A
04D3A:  CLRF   x7B
04D3C:  MOVLW  0F
04D3E:  MOVWF  x7D
04D40:  MOVLW  92
04D42:  MOVWF  x7C
04D44:  MOVLB  0
04D46:  CALL   235A
....................    }
04D4A:  GOTO   4D4E
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04D4E:  MOVLB  2
04D50:  CLRF   xFB
04D52:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
04D54:  MOVFF  2EB,A77
04D58:  MOVFF  2EA,A76
04D5C:  MOVFF  2E9,A75
04D60:  MOVFF  2E8,A74
04D64:  CALL   3440
04D68:  MOVF   01,W
04D6A:  ANDLW  01
04D6C:  SUBLW  01
04D6E:  BTFSS  FD8.2
04D70:  GOTO   4DC2
....................       if(timeout_counter > 10)
04D74:  MOVLB  2
04D76:  MOVF   xFB,W
04D78:  SUBLW  0A
04D7A:  BTFSS  FD8.0
04D7C:  BRA    4D84
04D7E:  MOVLB  0
04D80:  GOTO   4D96
04D84:  MOVLB  0
....................          delay_ms(200);
04D86:  MOVLW  C8
04D88:  MOVLB  A
04D8A:  MOVWF  x74
04D8C:  MOVLB  0
04D8E:  CALL   1B40
04D92:  GOTO   4DA2
....................       else
....................          delay_ms(10);   
04D96:  MOVLW  0A
04D98:  MOVLB  A
04D9A:  MOVWF  x74
04D9C:  MOVLB  0
04D9E:  CALL   1B40
....................       
....................       if(timeout_counter > 100){
04DA2:  MOVLB  2
04DA4:  MOVF   xFB,W
04DA6:  SUBLW  64
04DA8:  BTFSS  FD8.0
04DAA:  BRA    4DB2
04DAC:  MOVLB  0
04DAE:  GOTO   4DB8
04DB2:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
04DB4:  GOTO   4DC2
....................       }  
....................       timeout_counter++;
04DB8:  MOVLB  2
04DBA:  INCF   xFB,F
04DBC:  MOVLB  0
04DBE:  GOTO   4D54
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
04DC2:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
027C6:  MOVLB  2
027C8:  MOVF   xE9,F
027CA:  BTFSC  FD8.2
027CC:  BRA    27D4
027CE:  MOVLB  0
027D0:  GOTO   28CA
027D4:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
027D6:  MOVLW  03
027D8:  MOVLB  2
027DA:  MOVWF  xF6
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
027DC:  MOVFF  2EE,300
027E0:  MOVFF  2EF,301
027E4:  MOVLB  3
027E6:  CLRF   x02
027E8:  CLRF   x03
027EA:  MOVF   x00,W
027EC:  MOVWF  00
027EE:  CLRF   01
027F0:  CLRF   02
027F2:  CLRF   03
027F4:  MOVFF  00,2F7
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
027F8:  MOVFF  2ED,300
027FC:  MOVFF  2EE,301
02800:  MOVFF  2EF,302
02804:  CLRF   x03
02806:  MOVF   x00,W
02808:  MOVWF  00
0280A:  CLRF   01
0280C:  CLRF   02
0280E:  CLRF   03
02810:  MOVFF  00,2F8
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02814:  MOVLB  2
02816:  MOVF   xEC,W
02818:  MOVWF  00
0281A:  CLRF   01
0281C:  CLRF   02
0281E:  CLRF   03
02820:  MOVFF  00,2F9
....................             
....................       output_low(flash_stream.cs_pin);
02824:  MOVFF  2EA,A7A
02828:  MOVLB  A
0282A:  CLRF   x7B
0282C:  MOVLW  0F
0282E:  MOVWF  x7D
02830:  MOVLW  89
02832:  MOVWF  x7C
02834:  MOVLB  0
02836:  CALL   235A
0283A:  MOVFF  2EA,A7A
0283E:  MOVLB  A
02840:  CLRF   x7B
02842:  MOVLW  0F
02844:  MOVWF  x7D
02846:  MOVLW  92
02848:  MOVWF  x7C
0284A:  MOVLB  0
0284C:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
02850:  MOVFF  2EB,A7D
02854:  MOVFF  2EA,A7C
02858:  MOVFF  2E9,A7B
0285C:  MOVFF  2E8,A7A
02860:  MOVLW  02
02862:  MOVLB  A
02864:  MOVWF  x7F
02866:  MOVLW  F6
02868:  MOVWF  x7E
0286A:  CLRF   x81
0286C:  MOVLW  04
0286E:  MOVWF  x80
02870:  MOVFF  2F1,A83
02874:  MOVFF  2F0,A82
02878:  MOVFF  2F5,A87
0287C:  MOVFF  2F4,A86
02880:  MOVFF  2F3,A85
02884:  MOVFF  2F2,A84
02888:  MOVLB  0
0288A:  CALL   24A6
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
0288E:  MOVLW  02
02890:  MOVWF  00
02892:  DECFSZ 00,F
02894:  BRA    2892
02896:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
02898:  MOVFF  2EA,A7A
0289C:  MOVLW  01
0289E:  MOVLB  A
028A0:  MOVWF  x7B
028A2:  MOVLW  0F
028A4:  MOVWF  x7D
028A6:  MOVLW  89
028A8:  MOVWF  x7C
028AA:  MOVLB  0
028AC:  CALL   235A
028B0:  MOVFF  2EA,A7A
028B4:  MOVLB  A
028B6:  CLRF   x7B
028B8:  MOVLW  0F
028BA:  MOVWF  x7D
028BC:  MOVLW  92
028BE:  MOVWF  x7C
028C0:  MOVLB  0
028C2:  CALL   235A
....................    }
028C6:  GOTO   29E4
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
028CA:  MOVLB  2
028CC:  DECFSZ xE9,W
028CE:  BRA    28D4
028D0:  BRA    28DA
028D2:  MOVLB  0
028D4:  MOVLB  0
028D6:  GOTO   29E4
028DA:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
028DC:  MOVLW  13
028DE:  MOVLB  2
028E0:  MOVWF  xFA
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
028E2:  MOVFF  2EF,300
028E6:  MOVLB  3
028E8:  CLRF   x01
028EA:  CLRF   x02
028EC:  CLRF   x03
028EE:  MOVF   x00,W
028F0:  MOVWF  00
028F2:  CLRF   01
028F4:  CLRF   02
028F6:  CLRF   03
028F8:  MOVFF  00,2FB
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
028FC:  MOVFF  2EE,300
02900:  MOVFF  2EF,301
02904:  CLRF   x02
02906:  CLRF   x03
02908:  MOVF   x00,W
0290A:  MOVWF  00
0290C:  CLRF   01
0290E:  CLRF   02
02910:  CLRF   03
02912:  MOVFF  00,2FC
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
02916:  MOVFF  2ED,300
0291A:  MOVFF  2EE,301
0291E:  MOVFF  2EF,302
02922:  CLRF   x03
02924:  MOVF   x00,W
02926:  MOVWF  00
02928:  CLRF   01
0292A:  CLRF   02
0292C:  CLRF   03
0292E:  MOVFF  00,2FD
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02932:  MOVLB  2
02934:  MOVF   xEC,W
02936:  MOVWF  00
02938:  CLRF   01
0293A:  CLRF   02
0293C:  CLRF   03
0293E:  MOVFF  00,2FE
....................    
....................       output_low(flash_stream.cs_pin);
02942:  MOVFF  2EA,A7A
02946:  MOVLB  A
02948:  CLRF   x7B
0294A:  MOVLW  0F
0294C:  MOVWF  x7D
0294E:  MOVLW  89
02950:  MOVWF  x7C
02952:  MOVLB  0
02954:  CALL   235A
02958:  MOVFF  2EA,A7A
0295C:  MOVLB  A
0295E:  CLRF   x7B
02960:  MOVLW  0F
02962:  MOVWF  x7D
02964:  MOVLW  92
02966:  MOVWF  x7C
02968:  MOVLB  0
0296A:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
0296E:  MOVFF  2EB,A7D
02972:  MOVFF  2EA,A7C
02976:  MOVFF  2E9,A7B
0297A:  MOVFF  2E8,A7A
0297E:  MOVLW  02
02980:  MOVLB  A
02982:  MOVWF  x7F
02984:  MOVLW  FA
02986:  MOVWF  x7E
02988:  CLRF   x81
0298A:  MOVLW  05
0298C:  MOVWF  x80
0298E:  MOVFF  2F1,A83
02992:  MOVFF  2F0,A82
02996:  MOVFF  2F5,A87
0299A:  MOVFF  2F4,A86
0299E:  MOVFF  2F3,A85
029A2:  MOVFF  2F2,A84
029A6:  MOVLB  0
029A8:  CALL   24A6
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029AC:  MOVLW  02
029AE:  MOVWF  00
029B0:  DECFSZ 00,F
029B2:  BRA    29B0
029B4:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029B6:  MOVFF  2EA,A7A
029BA:  MOVLW  01
029BC:  MOVLB  A
029BE:  MOVWF  x7B
029C0:  MOVLW  0F
029C2:  MOVWF  x7D
029C4:  MOVLW  89
029C6:  MOVWF  x7C
029C8:  MOVLB  0
029CA:  CALL   235A
029CE:  MOVFF  2EA,A7A
029D2:  MOVLB  A
029D4:  CLRF   x7B
029D6:  MOVLW  0F
029D8:  MOVWF  x7D
029DA:  MOVLW  92
029DC:  MOVWF  x7C
029DE:  MOVLB  0
029E0:  CALL   235A
....................    }
....................    return;
029E4:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
034E0:  MOVLB  A
034E2:  MOVF   x5D,F
034E4:  BTFSC  FD8.2
034E6:  BRA    34EE
034E8:  MOVLB  0
034EA:  GOTO   365C
034EE:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
034F0:  MOVLW  06
034F2:  MOVLB  A
034F4:  MOVWF  x68
034F6:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
034F8:  MOVLW  02
034FA:  MOVLB  A
034FC:  MOVWF  x69
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
034FE:  MOVFF  A62,A75
03502:  MOVFF  A63,A76
03506:  CLRF   x77
03508:  CLRF   x78
0350A:  MOVF   x75,W
0350C:  MOVWF  00
0350E:  CLRF   01
03510:  CLRF   02
03512:  CLRF   03
03514:  MOVFF  00,A6A
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03518:  MOVFF  A61,A75
0351C:  MOVFF  A62,A76
03520:  MOVFF  A63,A77
03524:  CLRF   x78
03526:  MOVF   x75,W
03528:  MOVWF  00
0352A:  CLRF   01
0352C:  CLRF   02
0352E:  CLRF   03
03530:  MOVFF  00,A6B
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
03534:  MOVF   x60,W
03536:  MOVWF  00
03538:  CLRF   01
0353A:  CLRF   02
0353C:  CLRF   03
0353E:  MOVFF  00,A6C
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03542:  MOVFF  A5E,A7A
03546:  CLRF   x7B
03548:  MOVLW  0F
0354A:  MOVWF  x7D
0354C:  MOVLW  89
0354E:  MOVWF  x7C
03550:  MOVLB  0
03552:  CALL   235A
03556:  MOVFF  A5E,A7A
0355A:  MOVLB  A
0355C:  CLRF   x7B
0355E:  MOVLW  0F
03560:  MOVWF  x7D
03562:  MOVLW  92
03564:  MOVWF  x7C
03566:  MOVLB  0
03568:  CALL   235A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0356C:  MOVFF  A5F,A77
03570:  MOVFF  A5E,A76
03574:  MOVFF  A5D,A75
03578:  MOVFF  A5C,A74
0357C:  MOVLW  0A
0357E:  MOVLB  A
03580:  MOVWF  x79
03582:  MOVLW  68
03584:  MOVWF  x78
03586:  CLRF   x7B
03588:  MOVLW  01
0358A:  MOVWF  x7A
0358C:  MOVLB  0
0358E:  CALL   31D4
....................       output_high(flash_stream.cs_pin);
03592:  MOVFF  A5E,A7A
03596:  MOVLW  01
03598:  MOVLB  A
0359A:  MOVWF  x7B
0359C:  MOVLW  0F
0359E:  MOVWF  x7D
035A0:  MOVLW  89
035A2:  MOVWF  x7C
035A4:  MOVLB  0
035A6:  CALL   235A
035AA:  MOVFF  A5E,A7A
035AE:  MOVLB  A
035B0:  CLRF   x7B
035B2:  MOVLW  0F
035B4:  MOVWF  x7D
035B6:  MOVLW  92
035B8:  MOVWF  x7C
035BA:  MOVLB  0
035BC:  CALL   235A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
035C0:  MOVFF  A5E,A7A
035C4:  MOVLB  A
035C6:  CLRF   x7B
035C8:  MOVLW  0F
035CA:  MOVWF  x7D
035CC:  MOVLW  89
035CE:  MOVWF  x7C
035D0:  MOVLB  0
035D2:  CALL   235A
035D6:  MOVFF  A5E,A7A
035DA:  MOVLB  A
035DC:  CLRF   x7B
035DE:  MOVLW  0F
035E0:  MOVWF  x7D
035E2:  MOVLW  92
035E4:  MOVWF  x7C
035E6:  MOVLB  0
035E8:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
035EC:  MOVFF  A5F,A77
035F0:  MOVFF  A5E,A76
035F4:  MOVFF  A5D,A75
035F8:  MOVFF  A5C,A74
035FC:  MOVLW  0A
035FE:  MOVLB  A
03600:  MOVWF  x79
03602:  MOVLW  69
03604:  MOVWF  x78
03606:  MOVLW  04
03608:  MOVWF  x7A
0360A:  MOVFF  A65,A7C
0360E:  MOVFF  A64,A7B
03612:  MOVFF  A67,A7E
03616:  MOVFF  A66,A7D
0361A:  MOVLB  0
0361C:  CALL   32C4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
03620:  MOVLW  02
03622:  MOVWF  00
03624:  DECFSZ 00,F
03626:  BRA    3624
03628:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0362A:  MOVFF  A5E,A7A
0362E:  MOVLW  01
03630:  MOVLB  A
03632:  MOVWF  x7B
03634:  MOVLW  0F
03636:  MOVWF  x7D
03638:  MOVLW  89
0363A:  MOVWF  x7C
0363C:  MOVLB  0
0363E:  CALL   235A
03642:  MOVFF  A5E,A7A
03646:  MOVLB  A
03648:  CLRF   x7B
0364A:  MOVLW  0F
0364C:  MOVWF  x7D
0364E:  MOVLW  92
03650:  MOVWF  x7C
03652:  MOVLB  0
03654:  CALL   235A
....................    }
03658:  GOTO   37EE
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
0365C:  MOVLB  A
0365E:  DECFSZ x5D,W
03660:  BRA    3666
03662:  BRA    366C
03664:  MOVLB  0
03666:  MOVLB  0
03668:  GOTO   37EE
0366C:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
0366E:  MOVLW  06
03670:  MOVLB  A
03672:  MOVWF  x6D
03674:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
03676:  MOVLW  12
03678:  MOVLB  A
0367A:  MOVWF  x6E
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
0367C:  MOVFF  A63,A75
03680:  CLRF   x76
03682:  CLRF   x77
03684:  CLRF   x78
03686:  MOVF   x75,W
03688:  MOVWF  00
0368A:  CLRF   01
0368C:  CLRF   02
0368E:  CLRF   03
03690:  MOVFF  00,A6F
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03694:  MOVFF  A62,A75
03698:  MOVFF  A63,A76
0369C:  CLRF   x77
0369E:  CLRF   x78
036A0:  MOVF   x75,W
036A2:  MOVWF  00
036A4:  CLRF   01
036A6:  CLRF   02
036A8:  CLRF   03
036AA:  MOVFF  00,A70
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
036AE:  MOVFF  A61,A75
036B2:  MOVFF  A62,A76
036B6:  MOVFF  A63,A77
036BA:  CLRF   x78
036BC:  MOVF   x75,W
036BE:  MOVWF  00
036C0:  CLRF   01
036C2:  CLRF   02
036C4:  CLRF   03
036C6:  MOVFF  00,A71
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
036CA:  MOVF   x60,W
036CC:  MOVWF  00
036CE:  CLRF   01
036D0:  CLRF   02
036D2:  CLRF   03
036D4:  MOVFF  00,A72
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
036D8:  MOVFF  A5E,A7A
036DC:  CLRF   x7B
036DE:  MOVLW  0F
036E0:  MOVWF  x7D
036E2:  MOVLW  89
036E4:  MOVWF  x7C
036E6:  MOVLB  0
036E8:  CALL   235A
036EC:  MOVFF  A5E,A7A
036F0:  MOVLB  A
036F2:  CLRF   x7B
036F4:  MOVLW  0F
036F6:  MOVWF  x7D
036F8:  MOVLW  92
036FA:  MOVWF  x7C
036FC:  MOVLB  0
036FE:  CALL   235A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03702:  MOVFF  A5F,A77
03706:  MOVFF  A5E,A76
0370A:  MOVFF  A5D,A75
0370E:  MOVFF  A5C,A74
03712:  MOVLW  0A
03714:  MOVLB  A
03716:  MOVWF  x79
03718:  MOVLW  6D
0371A:  MOVWF  x78
0371C:  CLRF   x7B
0371E:  MOVLW  01
03720:  MOVWF  x7A
03722:  MOVLB  0
03724:  CALL   31D4
....................       output_high(flash_stream.cs_pin);
03728:  MOVFF  A5E,A7A
0372C:  MOVLW  01
0372E:  MOVLB  A
03730:  MOVWF  x7B
03732:  MOVLW  0F
03734:  MOVWF  x7D
03736:  MOVLW  89
03738:  MOVWF  x7C
0373A:  MOVLB  0
0373C:  CALL   235A
03740:  MOVFF  A5E,A7A
03744:  MOVLB  A
03746:  CLRF   x7B
03748:  MOVLW  0F
0374A:  MOVWF  x7D
0374C:  MOVLW  92
0374E:  MOVWF  x7C
03750:  MOVLB  0
03752:  CALL   235A
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
03756:  MOVFF  A5E,A7A
0375A:  MOVLB  A
0375C:  CLRF   x7B
0375E:  MOVLW  0F
03760:  MOVWF  x7D
03762:  MOVLW  89
03764:  MOVWF  x7C
03766:  MOVLB  0
03768:  CALL   235A
0376C:  MOVFF  A5E,A7A
03770:  MOVLB  A
03772:  CLRF   x7B
03774:  MOVLW  0F
03776:  MOVWF  x7D
03778:  MOVLW  92
0377A:  MOVWF  x7C
0377C:  MOVLB  0
0377E:  CALL   235A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
03782:  MOVFF  A5F,A77
03786:  MOVFF  A5E,A76
0378A:  MOVFF  A5D,A75
0378E:  MOVFF  A5C,A74
03792:  MOVLW  0A
03794:  MOVLB  A
03796:  MOVWF  x79
03798:  MOVLW  6E
0379A:  MOVWF  x78
0379C:  MOVLW  05
0379E:  MOVWF  x7A
037A0:  MOVFF  A65,A7C
037A4:  MOVFF  A64,A7B
037A8:  MOVFF  A67,A7E
037AC:  MOVFF  A66,A7D
037B0:  MOVLB  0
037B2:  CALL   32C4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
037B6:  MOVLW  02
037B8:  MOVWF  00
037BA:  DECFSZ 00,F
037BC:  BRA    37BA
037BE:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
037C0:  MOVFF  A5E,A7A
037C4:  MOVLW  01
037C6:  MOVLB  A
037C8:  MOVWF  x7B
037CA:  MOVLW  0F
037CC:  MOVWF  x7D
037CE:  MOVLW  89
037D0:  MOVWF  x7C
037D2:  MOVLB  0
037D4:  CALL   235A
037D8:  MOVFF  A5E,A7A
037DC:  MOVLB  A
037DE:  CLRF   x7B
037E0:  MOVLW  0F
037E2:  MOVWF  x7D
037E4:  MOVLW  92
037E6:  MOVWF  x7C
037E8:  MOVLB  0
037EA:  CALL   235A
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
037EE:  MOVLB  A
037F0:  CLRF   x73
037F2:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
037F4:  MOVFF  A5F,A77
037F8:  MOVFF  A5E,A76
037FC:  MOVFF  A5D,A75
03800:  MOVFF  A5C,A74
03804:  CALL   3440
03808:  MOVF   01,W
0380A:  ANDLW  01
0380C:  SUBLW  01
0380E:  BTFSS  FD8.2
03810:  GOTO   3862
....................       if(timeout_counter > 10)
03814:  MOVLB  A
03816:  MOVF   x73,W
03818:  SUBLW  0A
0381A:  BTFSS  FD8.0
0381C:  BRA    3824
0381E:  MOVLB  0
03820:  GOTO   3836
03824:  MOVLB  0
....................          delay_ms(200);
03826:  MOVLW  C8
03828:  MOVLB  A
0382A:  MOVWF  x74
0382C:  MOVLB  0
0382E:  CALL   1B40
03832:  GOTO   3842
....................       else
....................          delay_ms(10);   
03836:  MOVLW  0A
03838:  MOVLB  A
0383A:  MOVWF  x74
0383C:  MOVLB  0
0383E:  CALL   1B40
....................       
....................       if(timeout_counter > 100){
03842:  MOVLB  A
03844:  MOVF   x73,W
03846:  SUBLW  64
03848:  BTFSS  FD8.0
0384A:  BRA    3852
0384C:  MOVLB  0
0384E:  GOTO   3858
03852:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
03854:  GOTO   3862
....................       }  
....................       timeout_counter++;
03858:  MOVLB  A
0385A:  INCF   x73,F
0385C:  MOVLB  0
0385E:  GOTO   37F4
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
03862:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
026DA:  MOVLW  9F
026DC:  MOVLB  2
026DE:  MOVWF  x7E
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
026E0:  MOVFF  268,A7A
026E4:  MOVLB  A
026E6:  CLRF   x7B
026E8:  MOVLW  0F
026EA:  MOVWF  x7D
026EC:  MOVLW  89
026EE:  MOVWF  x7C
026F0:  MOVLB  0
026F2:  CALL   235A
026F6:  MOVFF  268,A7A
026FA:  MOVLB  A
026FC:  CLRF   x7B
026FE:  MOVLW  0F
02700:  MOVWF  x7D
02702:  MOVLW  92
02704:  MOVWF  x7C
02706:  MOVLB  0
02708:  CALL   235A
....................    delay_us(10);  
0270C:  MOVLW  0D
0270E:  MOVWF  00
02710:  DECFSZ 00,F
02712:  BRA    2710
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
02714:  MOVFF  269,A7D
02718:  MOVFF  268,A7C
0271C:  MOVFF  267,A7B
02720:  MOVFF  266,A7A
02724:  MOVLW  02
02726:  MOVLB  A
02728:  MOVWF  x7F
0272A:  MOVLW  7E
0272C:  MOVWF  x7E
0272E:  CLRF   x81
02730:  MOVLW  01
02732:  MOVWF  x80
02734:  MOVLW  02
02736:  MOVWF  x83
02738:  MOVLW  6A
0273A:  MOVWF  x82
0273C:  CLRF   x87
0273E:  CLRF   x86
02740:  CLRF   x85
02742:  MOVLW  14
02744:  MOVWF  x84
02746:  MOVLB  0
02748:  CALL   24A6
....................    output_high(flash_stream.cs_pin);
0274C:  MOVFF  268,A7A
02750:  MOVLW  01
02752:  MOVLB  A
02754:  MOVWF  x7B
02756:  MOVLW  0F
02758:  MOVWF  x7D
0275A:  MOVLW  89
0275C:  MOVWF  x7C
0275E:  MOVLB  0
02760:  CALL   235A
02764:  MOVFF  268,A7A
02768:  MOVLB  A
0276A:  CLRF   x7B
0276C:  MOVLW  0F
0276E:  MOVWF  x7D
02770:  MOVLW  92
02772:  MOVWF  x7C
02774:  MOVLB  0
02776:  CALL   235A
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
0277A:  MOVLB  2
0277C:  MOVF   x6A,W
0277E:  SUBLW  20
02780:  BTFSC  FD8.2
02782:  BRA    278A
02784:  MOVLB  0
02786:  GOTO   2798
0278A:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
0278C:  MOVLW  01
0278E:  MOVWF  01
02790:  GOTO   27A0
....................    }
02794:  GOTO   27A0
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
02798:  MOVLW  00
0279A:  MOVWF  01
0279C:  GOTO   27A0
....................    }
027A0:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
029E6:  MOVLB  A
029E8:  MOVF   xB5,F
029EA:  BTFSC  FD8.2
029EC:  BRA    29F4
029EE:  MOVLB  0
029F0:  GOTO   29FE
029F4:  MOVLB  0
029F6:  MOVLW  00
029F8:  MOVWF  01
029FA:  GOTO   2A50
.................... 
....................    unsigned int8 crc = *frame++;
029FE:  MOVLB  A
02A00:  MOVF   xB4,W
02A02:  MOVWF  03
02A04:  MOVF   xB3,W
02A06:  INCF   xB3,F
02A08:  BTFSC  FD8.2
02A0A:  INCF   xB4,F
02A0C:  MOVWF  FE9
02A0E:  MOVFF  03,FEA
02A12:  MOVFF  FEF,AB6
02A16:  MOVLB  0
....................    while (--payload_size > 0)
02A18:  MOVLB  A
02A1A:  DECF   xB5,F
02A1C:  MOVF   xB5,F
02A1E:  BTFSS  FD8.2
02A20:  BRA    2A28
02A22:  MOVLB  0
02A24:  GOTO   2A48
02A28:  MOVLB  0
....................       crc ^= *frame++;
02A2A:  MOVLB  A
02A2C:  MOVF   xB4,W
02A2E:  MOVWF  03
02A30:  MOVF   xB3,W
02A32:  INCF   xB3,F
02A34:  BTFSC  FD8.2
02A36:  INCF   xB4,F
02A38:  MOVWF  FE9
02A3A:  MOVFF  03,FEA
02A3E:  MOVF   FEF,W
02A40:  XORWF  xB6,F
02A42:  MOVLB  0
02A44:  GOTO   2A18
.................... 
....................    return crc;
02A48:  MOVLB  A
02A4A:  MOVF   xB6,W
02A4C:  MOVWF  01
02A4E:  MOVLB  0
02A50:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
095E6:  MOVLW  01
095E8:  MOVLB  2
095EA:  SUBWF  xEA,W
095EC:  ADDWF  xE8,W
095EE:  MOVWF  FE9
095F0:  MOVLW  00
095F2:  ADDWFC xE9,W
095F4:  MOVWF  FEA
095F6:  MOVFF  FEF,2EB
095FA:  MOVLW  01
095FC:  SUBWF  xEA,W
095FE:  MOVWF  xED
09600:  MOVFF  2E9,AB4
09604:  MOVFF  2E8,AB3
09608:  MOVFF  2ED,AB5
0960C:  MOVLB  0
0960E:  CALL   29E6
09612:  MOVFF  01,2EC
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
09616:  MOVLB  2
09618:  MOVF   xEC,W
0961A:  SUBWF  xEB,W
0961C:  BTFSS  FD8.2
0961E:  BRA    9626
09620:  MOVLB  0
09622:  GOTO   962E
09626:  MOVLB  0
09628:  MOVLW  00
0962A:  GOTO   9630
0962E:  MOVLW  01
09630:  MOVWF  01
09632:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
.................... {   
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
*
0867E:  MOVLW  8A
08680:  MOVWF  FF6
08682:  MOVLW  02
08684:  MOVWF  FF7
08686:  MOVLW  00
08688:  MOVWF  FF8
0868A:  CALL   1BC0
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
0868E:  MOVLW  01
08690:  MOVLB  1
08692:  ADDWF  x0D,W
08694:  ANDLW  0F
08696:  MOVWF  xB3
.................... 
....................    if(next_tail == flash_queue.head_index)
08698:  MOVF   x0C,W
0869A:  SUBWF  xB3,W
0869C:  BTFSC  FD8.2
0869E:  BRA    86A6
086A0:  MOVLB  0
086A2:  GOTO   86BC
086A6:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
086A8:  MOVLW  A4
086AA:  MOVWF  FF6
086AC:  MOVLW  02
086AE:  MOVWF  FF7
086B0:  MOVLW  00
086B2:  MOVWF  FF8
086B4:  CALL   1BC0
086B8:  GOTO   88DA
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
086BC:  MOVLB  1
086BE:  MOVF   x0D,W
086C0:  MULLW  0C
086C2:  MOVF   FF3,W
086C4:  CLRF   xB5
086C6:  MOVWF  xB4
086C8:  MOVLW  4C
086CA:  ADDWF  xB4,W
086CC:  MOVWF  01
086CE:  MOVLW  00
086D0:  ADDWFC xB5,W
086D2:  MOVWF  03
086D4:  MOVF   01,W
086D6:  MOVWF  xB6
086D8:  MOVFF  03,1B7
086DC:  MOVF   xB1,W
086DE:  MOVWF  FE9
086E0:  MOVF   xB2,W
086E2:  MOVWF  FEA
086E4:  MOVF   FEF,W
086E6:  MOVWF  xB8
086E8:  MOVFF  1B7,FEA
086EC:  MOVFF  1B6,FE9
086F0:  MOVFF  1B8,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
086F4:  MOVF   x0D,W
086F6:  MULLW  0C
086F8:  MOVF   FF3,W
086FA:  CLRF   xB5
086FC:  MOVWF  xB4
086FE:  MOVLW  01
08700:  ADDWF  xB4,W
08702:  MOVWF  01
08704:  MOVLW  00
08706:  ADDWFC xB5,W
08708:  MOVWF  03
0870A:  MOVF   01,W
0870C:  ADDLW  4C
0870E:  MOVWF  01
08710:  MOVLW  00
08712:  ADDWFC 03,F
08714:  MOVF   01,W
08716:  MOVWF  xB4
08718:  MOVFF  03,1B5
0871C:  MOVLW  01
0871E:  ADDWF  xB1,W
08720:  MOVWF  FE9
08722:  MOVLW  00
08724:  ADDWFC xB2,W
08726:  MOVWF  FEA
08728:  MOVF   FEF,W
0872A:  MOVWF  xB6
0872C:  MOVFF  1B5,FEA
08730:  MOVFF  1B4,FE9
08734:  MOVFF  1B6,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
08738:  MOVF   x0D,W
0873A:  MULLW  0C
0873C:  MOVF   FF3,W
0873E:  CLRF   xB5
08740:  MOVWF  xB4
08742:  MOVLW  02
08744:  ADDWF  xB4,W
08746:  MOVWF  01
08748:  MOVLW  00
0874A:  ADDWFC xB5,W
0874C:  MOVWF  03
0874E:  MOVF   01,W
08750:  ADDLW  4C
08752:  MOVWF  01
08754:  MOVLW  00
08756:  ADDWFC 03,F
08758:  MOVF   01,W
0875A:  MOVWF  xB4
0875C:  MOVFF  03,1B5
08760:  MOVLW  02
08762:  ADDWF  xB1,W
08764:  MOVWF  FE9
08766:  MOVLW  00
08768:  ADDWFC xB2,W
0876A:  MOVWF  FEA
0876C:  MOVF   FEF,W
0876E:  MOVWF  xB6
08770:  MOVFF  1B5,FEA
08774:  MOVFF  1B4,FE9
08778:  MOVFF  1B6,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
0877C:  MOVF   x0D,W
0877E:  MULLW  0C
08780:  MOVF   FF3,W
08782:  CLRF   xB5
08784:  MOVWF  xB4
08786:  MOVLW  03
08788:  ADDWF  xB4,W
0878A:  MOVWF  01
0878C:  MOVLW  00
0878E:  ADDWFC xB5,W
08790:  MOVWF  03
08792:  MOVF   01,W
08794:  ADDLW  4C
08796:  MOVWF  01
08798:  MOVLW  00
0879A:  ADDWFC 03,F
0879C:  MOVF   01,W
0879E:  MOVWF  xB4
087A0:  MOVFF  03,1B5
087A4:  MOVLW  03
087A6:  ADDWF  xB1,W
087A8:  MOVWF  01
087AA:  MOVLW  00
087AC:  ADDWFC xB2,W
087AE:  MOVWF  03
087B0:  MOVF   01,W
087B2:  MOVWF  FE9
087B4:  MOVFF  03,FEA
087B8:  MOVLW  00
087BA:  BTFSC  FEF.0
087BC:  MOVLW  01
087BE:  MOVWF  01
087C0:  BTFSS  01.0
087C2:  BRA    87CA
087C4:  MOVLB  0
087C6:  GOTO   87DA
087CA:  MOVLB  0
087CC:  MOVFF  1B5,FEA
087D0:  MOVFF  1B4,FE9
087D4:  BCF    FEF.0
087D6:  GOTO   87E4
087DA:  MOVFF  1B5,FEA
087DE:  MOVFF  1B4,FE9
087E2:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
087E4:  MOVLB  1
087E6:  MOVF   x0D,W
087E8:  MULLW  0C
087EA:  MOVF   FF3,W
087EC:  CLRF   xB5
087EE:  MOVWF  xB4
087F0:  MOVLW  04
087F2:  ADDWF  xB4,W
087F4:  MOVWF  01
087F6:  MOVLW  00
087F8:  ADDWFC xB5,W
087FA:  MOVWF  03
087FC:  MOVF   01,W
087FE:  ADDLW  4C
08800:  MOVWF  01
08802:  MOVLW  00
08804:  ADDWFC 03,F
08806:  MOVF   01,W
08808:  MOVWF  xB4
0880A:  MOVFF  03,1B5
0880E:  MOVLW  04
08810:  ADDWF  xB1,W
08812:  MOVWF  FE9
08814:  MOVLW  00
08816:  ADDWFC xB2,W
08818:  MOVWF  FEA
0881A:  MOVFF  FEF,00
0881E:  MOVFF  FEC,01
08822:  MOVFF  FEC,02
08826:  MOVFF  FEC,03
0882A:  MOVF   FED,F
0882C:  MOVF   FED,F
0882E:  MOVF   FED,F
08830:  MOVFF  03,1B9
08834:  MOVFF  02,1B8
08838:  MOVFF  01,1B7
0883C:  MOVFF  00,1B6
08840:  MOVFF  1B5,FEA
08844:  MOVFF  1B4,FE9
08848:  MOVFF  1B6,FEF
0884C:  MOVFF  1B7,FEC
08850:  MOVFF  1B8,FEC
08854:  MOVFF  1B9,FEC
08858:  MOVF   FED,F
0885A:  MOVF   FED,F
0885C:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
0885E:  MOVF   x0D,W
08860:  MULLW  0C
08862:  MOVF   FF3,W
08864:  CLRF   xB5
08866:  MOVWF  xB4
08868:  MOVLW  08
0886A:  ADDWF  xB4,W
0886C:  MOVWF  01
0886E:  MOVLW  00
08870:  ADDWFC xB5,W
08872:  MOVWF  03
08874:  MOVF   01,W
08876:  ADDLW  4C
08878:  MOVWF  01
0887A:  MOVLW  00
0887C:  ADDWFC 03,F
0887E:  MOVF   01,W
08880:  MOVWF  xB4
08882:  MOVFF  03,1B5
08886:  MOVLW  08
08888:  ADDWF  xB1,W
0888A:  MOVWF  FE9
0888C:  MOVLW  00
0888E:  ADDWFC xB2,W
08890:  MOVWF  FEA
08892:  MOVFF  FEF,00
08896:  MOVFF  FEC,01
0889A:  MOVFF  FEC,02
0889E:  MOVFF  FEC,03
088A2:  MOVF   FED,F
088A4:  MOVF   FED,F
088A6:  MOVF   FED,F
088A8:  MOVFF  03,1B9
088AC:  MOVFF  02,1B8
088B0:  MOVFF  01,1B7
088B4:  MOVFF  00,1B6
088B8:  MOVFF  1B5,FEA
088BC:  MOVFF  1B4,FE9
088C0:  MOVFF  1B6,FEF
088C4:  MOVFF  1B7,FEC
088C8:  MOVFF  1B8,FEC
088CC:  MOVFF  1B9,FEC
088D0:  MOVF   FED,F
088D2:  MOVF   FED,F
088D4:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
088D6:  MOVFF  1B3,10D
088DA:  MOVLB  0
....................    }
088DC:  GOTO   8E74 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
091E0:  MOVLB  1
091E2:  MOVF   x0D,W
091E4:  SUBWF  x0C,W
091E6:  BTFSC  FD8.2
091E8:  BRA    91F0
091EA:  MOVLB  0
091EC:  GOTO   9212
091F0:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
091F2:  MOVLW  BE
091F4:  MOVWF  FF6
091F6:  MOVLW  02
091F8:  MOVWF  FF7
091FA:  MOVLW  00
091FC:  MOVWF  FF8
091FE:  CALL   1BC0
....................       return 0x00;
09202:  MOVLW  00
09204:  MOVWF  01
09206:  MOVLW  00
09208:  MOVWF  02
0920A:  GOTO   923E
....................    }
0920E:  GOTO   923E
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
09212:  MOVFF  10C,191
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
09216:  MOVLW  01
09218:  MOVLB  1
0921A:  ADDWF  x0C,W
0921C:  ANDLW  0F
0921E:  MOVWF  x0C
.................... 
.................... 
....................       return &flash_queue.entries[current_head];
09220:  MOVF   x91,W
09222:  MULLW  0C
09224:  MOVF   FF3,W
09226:  CLRF   03
09228:  ADDLW  4C
0922A:  MOVWF  01
0922C:  MOVLW  00
0922E:  ADDWFC 03,F
09230:  MOVF   01,W
09232:  MOVWF  01
09234:  MOVF   03,W
09236:  MOVWF  02
09238:  MOVLB  0
0923A:  GOTO   923E
....................    }
0923E:  GOTO   ADA6 (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
090EA:  MOVLB  1
090EC:  MOVF   x0D,W
090EE:  SUBWF  x0C,W
090F0:  BTFSS  FD8.2
090F2:  BRA    90FA
090F4:  MOVLB  0
090F6:  GOTO   9102
090FA:  MOVLB  0
090FC:  MOVLW  00
090FE:  GOTO   9104
09102:  MOVLW  01
09104:  MOVWF  01
09106:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
093BE:  MOVLB  2
093C0:  CLRF   x6E
093C2:  CLRF   x6F
093C4:  CLRF   x70
093C6:  CLRF   x71
093C8:  CLRF   x72
093CA:  CLRF   x73
093CC:  CLRF   x74
093CE:  CLRF   x75
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
093D0:  MOVF   x6D,F
093D2:  BTFSC  FD8.2
093D4:  BRA    93DC
093D6:  MOVLB  0
093D8:  GOTO   9400
093DC:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
093DE:  MOVLW  06
093E0:  MOVLB  2
093E2:  MOVWF  x71
093E4:  MOVLW  AA
093E6:  MOVWF  x70
093E8:  CLRF   x6F
093EA:  CLRF   x6E
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
093EC:  MOVLW  06
093EE:  MOVWF  x75
093F0:  MOVLW  AA
093F2:  MOVWF  x74
093F4:  MOVLW  0F
093F6:  MOVWF  x73
093F8:  SETF   x72
093FA:  MOVLB  0
....................    }
093FC:  GOTO   94D4
....................    else if (mission_id == CIGS_PICLOG_DATA)
09400:  MOVLB  2
09402:  DECFSZ x6D,W
09404:  BRA    940A
09406:  BRA    9410
09408:  MOVLB  0
0940A:  MOVLB  0
0940C:  GOTO   9436
09410:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
09412:  MOVLW  06
09414:  MOVLB  2
09416:  MOVWF  x71
09418:  MOVLW  AA
0941A:  MOVWF  x70
0941C:  MOVLW  10
0941E:  MOVWF  x6F
09420:  CLRF   x6E
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
09422:  MOVLW  06
09424:  MOVWF  x75
09426:  MOVLW  AA
09428:  MOVWF  x74
0942A:  MOVLW  1F
0942C:  MOVWF  x73
0942E:  SETF   x72
09430:  MOVLB  0
....................    }
09432:  GOTO   94D4
....................    else if (mission_id == CIGS_ENVIRO_DATA)
09436:  MOVLB  2
09438:  MOVF   x6D,W
0943A:  SUBLW  02
0943C:  BTFSC  FD8.2
0943E:  BRA    9446
09440:  MOVLB  0
09442:  GOTO   946C
09446:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
09448:  MOVLW  06
0944A:  MOVLB  2
0944C:  MOVWF  x71
0944E:  MOVLW  AA
09450:  MOVWF  x70
09452:  MOVLW  10
09454:  MOVWF  x6F
09456:  CLRF   x6E
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
09458:  MOVLW  06
0945A:  MOVWF  x75
0945C:  MOVLW  AA
0945E:  MOVWF  x74
09460:  MOVLW  1F
09462:  MOVWF  x73
09464:  SETF   x72
09466:  MOVLB  0
....................    }
09468:  GOTO   94D4
....................    else if (mission_id == CIGS_IV_HEADER)
0946C:  MOVLB  2
0946E:  MOVF   x6D,W
09470:  SUBLW  03
09472:  BTFSC  FD8.2
09474:  BRA    947C
09476:  MOVLB  0
09478:  GOTO   94A2
0947C:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_HEADER_START_ADDRESS;
0947E:  MOVLW  06
09480:  MOVLB  2
09482:  MOVWF  x71
09484:  MOVLW  B4
09486:  MOVWF  x70
09488:  MOVLW  20
0948A:  MOVWF  x6F
0948C:  CLRF   x6E
....................       mis_struct.end_address   = CIGS_IV1_HEADER_END_ADDRESS;
0948E:  MOVLW  06
09490:  MOVWF  x75
09492:  MOVLW  BE
09494:  MOVWF  x74
09496:  MOVLW  1F
09498:  MOVWF  x73
0949A:  SETF   x72
0949C:  MOVLB  0
....................    }
0949E:  GOTO   94D4
....................    else if (mission_id == CIGS_IV_DATA)
094A2:  MOVLB  2
094A4:  MOVF   x6D,W
094A6:  SUBLW  04
094A8:  BTFSC  FD8.2
094AA:  BRA    94B2
094AC:  MOVLB  0
094AE:  GOTO   94D4
094B2:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_DATA_START_ADDRESS;
094B4:  MOVLW  06
094B6:  MOVLB  2
094B8:  MOVWF  x71
094BA:  MOVLW  BE
094BC:  MOVWF  x70
094BE:  MOVLW  20
094C0:  MOVWF  x6F
094C2:  CLRF   x6E
....................       mis_struct.end_address   = CIGS_IV1_DATA_END_ADDRESS;
094C4:  MOVLW  06
094C6:  MOVWF  x75
094C8:  MOVLW  FE
094CA:  MOVWF  x74
094CC:  MOVLW  2F
094CE:  MOVWF  x73
094D0:  SETF   x72
094D2:  MOVLB  0
....................    }
....................    return mis_struct;
094D4:  MOVLW  6E
094D6:  MOVWF  01
094D8:  MOVLW  02
094DA:  MOVWF  02
094DC:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
04438:  MOVLB  1
0443A:  CLRF   x93
0443C:  CLRF   x94
0443E:  CLRF   x95
04440:  CLRF   x96
04442:  CLRF   x97
04444:  CLRF   x98
04446:  CLRF   x99
04448:  CLRF   x9A
0444A:  CLRF   x9B
0444C:  CLRF   x9C
0444E:  CLRF   x9D
04450:  CLRF   x9E
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
04452:  MOVLW  D6
04454:  MOVWF  FF6
04456:  MOVLW  02
04458:  MOVWF  FF7
0445A:  MOVLW  00
0445C:  MOVWF  FF8
0445E:  MOVLB  0
04460:  CALL   1BC0
....................    fprintf(PC, "\t[BOSS] >>> ");
04464:  MOVLW  F6
04466:  MOVWF  FF6
04468:  MOVLW  02
0446A:  MOVWF  FF7
0446C:  MOVLW  00
0446E:  MOVWF  FF8
04470:  CALL   1BC0
....................    for (int8 i = 0; i < receive_signal_size; i++)
04474:  MOVLB  1
04476:  CLRF   x9F
04478:  MOVLB  0
0447A:  MOVLB  1
0447C:  MOVF   x92,W
0447E:  SUBWF  x9F,W
04480:  BTFSS  FD8.0
04482:  BRA    448A
04484:  MOVLB  0
04486:  GOTO   44C4
0448A:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
0448C:  MOVLB  1
0448E:  MOVF   x9F,W
04490:  ADDWF  x90,W
04492:  MOVWF  FE9
04494:  MOVLW  00
04496:  ADDWFC x91,W
04498:  MOVWF  FEA
0449A:  MOVFF  FEF,1A6
0449E:  MOVFF  1A6,9CC
044A2:  MOVLW  37
044A4:  MOVLB  9
044A6:  MOVWF  xCD
044A8:  MOVLB  0
044AA:  CALL   1E44
044AE:  MOVLW  20
044B0:  MOVLB  A
044B2:  MOVWF  xB3
044B4:  MOVLB  0
044B6:  CALL   1B6E
044BA:  MOVLB  1
044BC:  INCF   x9F,F
044BE:  MOVLB  0
044C0:  GOTO   447A
....................    fprintf(PC, "\r\n");
044C4:  MOVLW  0D
044C6:  MOVLB  A
044C8:  MOVWF  xB3
044CA:  MOVLB  0
044CC:  CALL   1B6E
044D0:  MOVLW  0A
044D2:  MOVLB  A
044D4:  MOVWF  xB3
044D6:  MOVLB  0
044D8:  CALL   1B6E
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
044DC:  MOVFF  191,1A7
044E0:  MOVFF  190,1A6
044E4:  MOVFF  192,1A8
044E8:  GOTO   4130
044EC:  MOVFF  01,1A0
....................    if (frame_start_position == -1)
044F0:  MOVLB  1
044F2:  MOVF   xA0,W
044F4:  SUBLW  FF
044F6:  BTFSC  FD8.2
044F8:  BRA    4500
044FA:  MOVLB  0
044FC:  GOTO   450E
04500:  MOVLB  0
....................       return command;
04502:  MOVLW  93
04504:  MOVWF  01
04506:  MOVLW  01
04508:  MOVWF  02
0450A:  GOTO   4630
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
0450E:  MOVLB  1
04510:  MOVF   xA0,W
04512:  ADDWF  x90,W
04514:  MOVWF  01
04516:  MOVLW  00
04518:  ADDWFC x91,W
0451A:  MOVWF  03
0451C:  MOVF   01,W
0451E:  MOVWF  xA1
04520:  MOVFF  03,1A2
04524:  MOVF   xA1,W
04526:  MOVWF  FE9
04528:  MOVF   xA2,W
0452A:  MOVWF  FEA
0452C:  MOVF   FEF,W
0452E:  ANDLW  0F
04530:  MOVWF  xA3
04532:  MOVFF  1A3,1A6
04536:  MOVLB  0
04538:  GOTO   41D8
0453C:  MOVFF  01,1A4
....................    if (content_size == -1)
04540:  MOVLB  1
04542:  MOVF   xA4,W
04544:  SUBLW  FF
04546:  BTFSC  FD8.2
04548:  BRA    4550
0454A:  MOVLB  0
0454C:  GOTO   455E
04550:  MOVLB  0
....................       return command;
04552:  MOVLW  93
04554:  MOVWF  01
04556:  MOVLW  01
04558:  MOVWF  02
0455A:  GOTO   4630
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
0455E:  MOVLB  1
04560:  MOVF   xA0,W
04562:  SUBWF  x92,W
04564:  MOVWF  xA5
....................    
....................    if (!check_crc(frame, receive_frame_size))
04566:  MOVFF  1A2,1A7
0456A:  MOVFF  1A1,1A6
0456E:  MOVFF  1A5,1A8
04572:  MOVLB  0
04574:  GOTO   4294
04578:  MOVF   01,F
0457A:  BTFSS  FD8.2
0457C:  GOTO   458C
....................       return command;
04580:  MOVLW  93
04582:  MOVWF  01
04584:  MOVLW  01
04586:  MOVWF  02
04588:  GOTO   4630
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
0458C:  MOVLB  1
0458E:  MOVF   xA1,W
04590:  MOVWF  FE9
04592:  MOVF   xA2,W
04594:  MOVWF  FEA
04596:  MOVF   FEF,W
04598:  ANDLW  F0
0459A:  MOVWF  00
0459C:  SWAPF  00,W
0459E:  MOVWF  xA6
045A0:  MOVLW  0F
045A2:  ANDWF  xA6,F
045A4:  MOVFF  1A6,1A7
045A8:  MOVLB  0
045AA:  GOTO   437E
045AE:  MOVF   01,F
045B0:  BTFSS  FD8.2
045B2:  GOTO   45C2
....................       return command;
045B6:  MOVLW  93
045B8:  MOVWF  01
045BA:  MOVLW  01
045BC:  MOVWF  02
045BE:  GOTO   4630
.................... 
....................    command.frame_id = frame_id;
045C2:  MOVFF  1A3,193
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
045C6:  MOVLW  01
045C8:  MOVLB  1
045CA:  ADDWF  xA1,W
045CC:  MOVWF  01
045CE:  MOVLW  00
045D0:  ADDWFC xA2,W
045D2:  MOVWF  03
045D4:  MOVF   01,W
045D6:  MOVWF  xA6
045D8:  MOVFF  03,1A7
045DC:  MOVLW  02
045DE:  SUBWF  xA5,W
045E0:  MOVWF  xA8
045E2:  MOVLW  01
045E4:  MOVWF  FEA
045E6:  MOVLW  96
045E8:  MOVWF  FE9
045EA:  MOVFF  1A7,FE2
045EE:  MOVFF  1A6,FE1
045F2:  MOVF   xA8,W
045F4:  MOVWF  01
045F6:  BTFSS  FD8.2
045F8:  BRA    4600
045FA:  MOVLB  0
045FC:  GOTO   460C
04600:  MOVLB  0
04602:  MOVFF  FE6,FEE
04606:  DECFSZ 01,F
04608:  GOTO   4602
....................    command.size = receive_frame_size-2;
0460C:  MOVLW  02
0460E:  MOVLB  1
04610:  SUBWF  xA5,W
04612:  MOVWF  x94
....................    command.is_exist = TRUE;
04614:  BSF    x95.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
04616:  MOVLW  04
04618:  MOVWF  FF6
0461A:  MOVLW  03
0461C:  MOVWF  FF7
0461E:  MOVLW  00
04620:  MOVWF  FF8
04622:  MOVLB  0
04624:  CALL   1BC0
....................    return command;
04628:  MOVLW  93
0462A:  MOVWF  01
0462C:  MOVLW  01
0462E:  MOVWF  02
04630:  GOTO   B5FC (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
04130:  MOVLB  1
04132:  CLRF   xA9
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
04134:  CLRF   xA9
04136:  MOVLB  0
04138:  MOVLW  01
0413A:  MOVLB  1
0413C:  SUBWF  xA8,W
0413E:  SUBWF  xA9,W
04140:  BTFSS  FD8.0
04142:  BRA    414A
04144:  MOVLB  0
04146:  GOTO   4182
0414A:  MOVLB  0
....................       if(receive_signal[i] == SFD)
0414C:  MOVLB  1
0414E:  MOVF   xA9,W
04150:  ADDWF  xA6,W
04152:  MOVWF  FE9
04154:  MOVLW  00
04156:  ADDWFC xA7,W
04158:  MOVWF  FEA
0415A:  MOVF   FEF,W
0415C:  SUBLW  AA
0415E:  BTFSC  FD8.2
04160:  BRA    4168
04162:  MOVLB  0
04164:  GOTO   4178
04168:  MOVLB  0
....................          return i+1;
0416A:  MOVLW  01
0416C:  MOVLB  1
0416E:  ADDWF  xA9,W
04170:  MOVWF  01
04172:  MOVLB  0
04174:  GOTO   41D4
04178:  MOVLB  1
0417A:  INCF   xA9,F
0417C:  MOVLB  0
0417E:  GOTO   4138
....................    if (receive_signal[i] == SFD)
04182:  MOVLB  1
04184:  MOVF   xA9,W
04186:  ADDWF  xA6,W
04188:  MOVWF  FE9
0418A:  MOVLW  00
0418C:  ADDWFC xA7,W
0418E:  MOVWF  FEA
04190:  MOVF   FEF,W
04192:  SUBLW  AA
04194:  BTFSC  FD8.2
04196:  BRA    419E
04198:  MOVLB  0
0419A:  GOTO   41BC
0419E:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
041A0:  MOVLW  20
041A2:  MOVWF  FF6
041A4:  MOVLW  03
041A6:  MOVWF  FF7
041A8:  MOVLW  00
041AA:  MOVWF  FF8
041AC:  CALL   1BC0
....................       return -1;
041B0:  MOVLW  FF
041B2:  MOVWF  01
041B4:  GOTO   41D4
....................    }
041B8:  GOTO   41D4
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
041BC:  MOVLW  36
041BE:  MOVWF  FF6
041C0:  MOVLW  03
041C2:  MOVWF  FF7
041C4:  MOVLW  00
041C6:  MOVWF  FF8
041C8:  CALL   1BC0
....................       return -1;
041CC:  MOVLW  FF
041CE:  MOVWF  01
041D0:  GOTO   41D4
....................    }
041D4:  GOTO   44EC (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
041D8:  MOVLB  1
041DA:  CLRF   xA7
041DC:  MOVLB  0
041DE:  MOVLB  1
041E0:  MOVF   xA7,W
041E2:  SUBLW  02
041E4:  BTFSC  FD8.0
041E6:  BRA    41EE
041E8:  MOVLB  0
041EA:  GOTO   424C
041EE:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
041F0:  BCF    FD8.0
041F2:  MOVLB  1
041F4:  RLCF   xA7,W
041F6:  CLRF   xA9
041F8:  MOVWF  xA8
041FA:  MOVLW  16
041FC:  ADDWF  xA8,W
041FE:  MOVWF  FE9
04200:  MOVLW  01
04202:  ADDWFC xA9,W
04204:  MOVWF  FEA
04206:  MOVF   FEF,W
04208:  SUBWF  xA6,W
0420A:  BTFSC  FD8.2
0420C:  BRA    4214
0420E:  MOVLB  0
04210:  GOTO   4242
04214:  MOVLB  0
....................          return frame_ids[i].length;
04216:  BCF    FD8.0
04218:  MOVLB  1
0421A:  RLCF   xA7,W
0421C:  CLRF   xA9
0421E:  MOVWF  xA8
04220:  MOVLW  01
04222:  ADDWF  xA8,W
04224:  MOVWF  01
04226:  MOVLW  00
04228:  ADDWFC xA9,W
0422A:  MOVWF  03
0422C:  MOVF   01,W
0422E:  ADDLW  16
04230:  MOVWF  FE9
04232:  MOVLW  01
04234:  ADDWFC 03,W
04236:  MOVWF  FEA
04238:  MOVF   FEF,W
0423A:  MOVWF  01
0423C:  MOVLB  0
0423E:  GOTO   4290
04242:  MOVLB  1
04244:  INCF   xA7,F
04246:  MOVLB  0
04248:  GOTO   41DE
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
0424C:  MOVLW  48
0424E:  MOVWF  FF6
04250:  MOVLW  03
04252:  MOVWF  FF7
04254:  MOVLW  00
04256:  MOVWF  FF8
04258:  MOVLW  1F
0425A:  MOVLB  9
0425C:  MOVWF  xCC
0425E:  MOVLB  0
04260:  CALL   1BF0
04264:  MOVFF  1A6,9CC
04268:  MOVLW  37
0426A:  MOVLB  9
0426C:  MOVWF  xCD
0426E:  MOVLB  0
04270:  CALL   1E44
04274:  MOVLW  0D
04276:  MOVLB  A
04278:  MOVWF  xB3
0427A:  MOVLB  0
0427C:  CALL   1B6E
04280:  MOVLW  0A
04282:  MOVLB  A
04284:  MOVWF  xB3
04286:  MOVLB  0
04288:  CALL   1B6E
....................    return -1;
0428C:  MOVLW  FF
0428E:  MOVWF  01
04290:  GOTO   453C (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
04294:  MOVLW  01
04296:  MOVLB  1
04298:  SUBWF  xA8,W
0429A:  ADDWF  xA6,W
0429C:  MOVWF  FE9
0429E:  MOVLW  00
042A0:  ADDWFC xA7,W
042A2:  MOVWF  FEA
042A4:  MOVFF  FEF,1A9
042A8:  MOVLW  01
042AA:  SUBWF  xA8,W
042AC:  MOVWF  xAB
042AE:  MOVFF  1A7,AB4
042B2:  MOVFF  1A6,AB3
042B6:  MOVFF  1AB,AB5
042BA:  MOVLB  0
042BC:  CALL   29E6
042C0:  MOVFF  01,1AA
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
042C4:  MOVLB  1
042C6:  MOVF   xAA,W
042C8:  SUBWF  xA9,W
042CA:  BTFSC  FD8.2
042CC:  BRA    42D4
042CE:  MOVLB  0
042D0:  GOTO   42E2
042D4:  MOVLB  0
....................       return TRUE;
042D6:  MOVLW  01
042D8:  MOVWF  01
042DA:  GOTO   437A
042DE:  GOTO   437A
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
042E2:  MOVLW  6C
042E4:  MOVWF  FF6
042E6:  MOVLW  03
042E8:  MOVWF  FF7
042EA:  MOVLW  00
042EC:  MOVWF  FF8
042EE:  CALL   1BC0
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
042F2:  MOVLW  7E
042F4:  MOVWF  FF6
042F6:  MOVLW  03
042F8:  MOVWF  FF7
042FA:  MOVLW  00
042FC:  MOVWF  FF8
042FE:  MOVLW  13
04300:  MOVLB  9
04302:  MOVWF  xCC
04304:  MOVLB  0
04306:  CALL   1BF0
0430A:  MOVFF  1A9,9CC
0430E:  MOVLW  37
04310:  MOVLB  9
04312:  MOVWF  xCD
04314:  MOVLB  0
04316:  CALL   1E44
0431A:  MOVLW  0D
0431C:  MOVLB  A
0431E:  MOVWF  xB3
04320:  MOVLB  0
04322:  CALL   1B6E
04326:  MOVLW  0A
04328:  MOVLB  A
0432A:  MOVWF  xB3
0432C:  MOVLB  0
0432E:  CALL   1B6E
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
04332:  MOVLW  96
04334:  MOVWF  FF6
04336:  MOVLW  03
04338:  MOVWF  FF7
0433A:  MOVLW  00
0433C:  MOVWF  FF8
0433E:  MOVLW  13
04340:  MOVLB  9
04342:  MOVWF  xCC
04344:  MOVLB  0
04346:  CALL   1BF0
0434A:  MOVFF  1AA,9CC
0434E:  MOVLW  37
04350:  MOVLB  9
04352:  MOVWF  xCD
04354:  MOVLB  0
04356:  CALL   1E44
0435A:  MOVLW  0D
0435C:  MOVLB  A
0435E:  MOVWF  xB3
04360:  MOVLB  0
04362:  CALL   1B6E
04366:  MOVLW  0A
04368:  MOVLB  A
0436A:  MOVWF  xB3
0436C:  MOVLB  0
0436E:  CALL   1B6E
....................       return FALSE;
04372:  MOVLW  00
04374:  MOVWF  01
04376:  GOTO   437A
....................    }
0437A:  GOTO   4578 (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
0437E:  MOVLB  1
04380:  MOVF   xA7,W
04382:  SUBLW  0C
04384:  BTFSC  FD8.2
04386:  BRA    438E
04388:  MOVLB  0
0438A:  GOTO   439C
0438E:  MOVLB  0
....................       return TRUE;
04390:  MOVLW  01
04392:  MOVWF  01
04394:  GOTO   4434
04398:  GOTO   4434
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
0439C:  MOVLW  AE
0439E:  MOVWF  FF6
043A0:  MOVLW  03
043A2:  MOVWF  FF7
043A4:  MOVLW  00
043A6:  MOVWF  FF8
043A8:  CALL   1BC0
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
043AC:  MOVLW  D0
043AE:  MOVWF  FF6
043B0:  MOVLW  03
043B2:  MOVWF  FF7
043B4:  MOVLW  00
043B6:  MOVWF  FF8
043B8:  MOVLW  13
043BA:  MOVLB  9
043BC:  MOVWF  xCC
043BE:  MOVLB  0
043C0:  CALL   1BF0
043C4:  MOVFF  1A7,9CC
043C8:  MOVLW  37
043CA:  MOVLB  9
043CC:  MOVWF  xCD
043CE:  MOVLB  0
043D0:  CALL   1E44
043D4:  MOVLW  0D
043D6:  MOVLB  A
043D8:  MOVWF  xB3
043DA:  MOVLB  0
043DC:  CALL   1B6E
043E0:  MOVLW  0A
043E2:  MOVLB  A
043E4:  MOVWF  xB3
043E6:  MOVLB  0
043E8:  CALL   1B6E
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
043EC:  MOVLW  E8
043EE:  MOVWF  FF6
043F0:  MOVLW  03
043F2:  MOVWF  FF7
043F4:  MOVLW  00
043F6:  MOVWF  FF8
043F8:  MOVLW  13
043FA:  MOVLB  9
043FC:  MOVWF  xCC
043FE:  MOVLB  0
04400:  CALL   1BF0
04404:  MOVLW  0C
04406:  MOVLB  9
04408:  MOVWF  xCC
0440A:  MOVLW  37
0440C:  MOVWF  xCD
0440E:  MOVLB  0
04410:  CALL   1E44
04414:  MOVLW  0D
04416:  MOVLB  A
04418:  MOVWF  xB3
0441A:  MOVLB  0
0441C:  CALL   1B6E
04420:  MOVLW  0A
04422:  MOVLB  A
04424:  MOVWF  xB3
04426:  MOVLB  0
04428:  CALL   1B6E
....................       return FALSE;  
0442C:  MOVLW  00
0442E:  MOVWF  01
04430:  GOTO   4434
....................    }
04434:  GOTO   45AE (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
0473A:  MOVLW  AA
0473C:  MOVLB  1
0473E:  MOVWF  x95
....................    data[1] = (BOSS_PIC << 4) | frame_id;
04740:  MOVF   x91,W
04742:  IORLW  50
04744:  MOVWF  x96
....................    memcpy(&data[2], content, size);
04746:  MOVLW  01
04748:  MOVWF  FEA
0474A:  MOVLW  97
0474C:  MOVWF  FE9
0474E:  MOVFF  193,FE2
04752:  MOVFF  192,FE1
04756:  MOVF   x94,W
04758:  MOVWF  01
0475A:  BTFSS  FD8.2
0475C:  BRA    4764
0475E:  MOVLB  0
04760:  GOTO   4770
04764:  MOVLB  0
04766:  MOVFF  FE6,FEE
0476A:  DECFSZ 01,F
0476C:  GOTO   4766
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
04770:  MOVLW  02
04772:  MOVLB  1
04774:  ADDWF  x94,W
04776:  MOVWF  xA5
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
04778:  CLRF   03
0477A:  MOVF   xA5,W
0477C:  ADDLW  95
0477E:  MOVWF  01
04780:  MOVLW  01
04782:  ADDWFC 03,F
04784:  MOVF   01,W
04786:  MOVWF  xA7
04788:  MOVFF  03,1A8
0478C:  MOVLW  01
0478E:  SUBWF  xA5,W
04790:  MOVWF  xA9
04792:  MOVLW  01
04794:  MOVLB  A
04796:  MOVWF  xB4
04798:  MOVLW  96
0479A:  MOVWF  xB3
0479C:  MOVFF  1A9,AB5
047A0:  MOVLB  0
047A2:  CALL   29E6
047A6:  MOVFF  1A8,FEA
047AA:  MOVFF  1A7,FE9
047AE:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
047B2:  MOVLW  01
047B4:  MOVLB  1
047B6:  ADDWF  xA5,W
047B8:  MOVWF  xA6
....................    
....................    transmit(data, data_size);
047BA:  MOVLW  01
047BC:  MOVWF  xA8
047BE:  MOVLW  95
047C0:  MOVWF  xA7
047C2:  MOVFF  1A6,1A9
047C6:  MOVLB  0
047C8:  GOTO   4682
047CC:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
04682:  MOVLB  1
04684:  CLRF   xAA
04686:  MOVLB  0
04688:  MOVLB  1
0468A:  MOVF   xA9,W
0468C:  SUBWF  xAA,W
0468E:  BTFSS  FD8.0
04690:  BRA    4698
04692:  MOVLB  0
04694:  GOTO   46BE
04698:  MOVLB  0
....................       fputc(data[i], BOSS);
0469A:  MOVLB  1
0469C:  MOVF   xAA,W
0469E:  ADDWF  xA7,W
046A0:  MOVWF  FE9
046A2:  MOVLW  00
046A4:  ADDWFC xA8,W
046A6:  MOVWF  FEA
046A8:  MOVFF  FEF,1AC
046AC:  MOVF   xAC,W
046AE:  MOVLB  0
046B0:  GOTO   4672
046B4:  MOVLB  1
046B6:  INCF   xAA,F
046B8:  MOVLB  0
046BA:  GOTO   4688
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
046BE:  MOVLW  00
046C0:  MOVWF  FF6
046C2:  MOVLW  04
046C4:  MOVWF  FF7
046C6:  MOVLW  00
046C8:  MOVWF  FF8
046CA:  CALL   1BC0
....................    for(int i = 0; i < data_size; i++)
046CE:  MOVLB  1
046D0:  CLRF   xAB
046D2:  MOVLB  0
046D4:  MOVLB  1
046D6:  MOVF   xA9,W
046D8:  SUBWF  xAB,W
046DA:  BTFSS  FD8.0
046DC:  BRA    46E4
046DE:  MOVLB  0
046E0:  GOTO   471E
046E4:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
046E6:  MOVLB  1
046E8:  MOVF   xAB,W
046EA:  ADDWF  xA7,W
046EC:  MOVWF  FE9
046EE:  MOVLW  00
046F0:  ADDWFC xA8,W
046F2:  MOVWF  FEA
046F4:  MOVFF  FEF,1AC
046F8:  MOVFF  1AC,9CC
046FC:  MOVLW  37
046FE:  MOVLB  9
04700:  MOVWF  xCD
04702:  MOVLB  0
04704:  CALL   1E44
04708:  MOVLW  20
0470A:  MOVLB  A
0470C:  MOVWF  xB3
0470E:  MOVLB  0
04710:  CALL   1B6E
04714:  MOVLB  1
04716:  INCF   xAB,F
04718:  MOVLB  0
0471A:  GOTO   46D4
....................    fprintf(PC, "\r\n");
0471E:  MOVLW  0D
04720:  MOVLB  A
04722:  MOVWF  xB3
04724:  MOVLB  0
04726:  CALL   1B6E
0472A:  MOVLW  0A
0472C:  MOVLB  A
0472E:  MOVWF  xB3
04730:  MOVLB  0
04732:  CALL   1B6E
04736:  GOTO   47CC (RETURN)
.................... }
.................... 
.................... #include "../../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
047CE:  MOVLW  0F
047D0:  MOVLB  1
047D2:  MOVWF  x91
047D4:  CLRF   x93
047D6:  CLRF   x92
047D8:  CLRF   x94
047DA:  MOVLB  0
047DC:  CALL   473A
047E0:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
09170:  MOVLW  03
09172:  MOVLB  1
09174:  MOVWF  x91
09176:  CLRF   x93
09178:  MOVLW  48
0917A:  MOVWF  x92
0917C:  MOVLW  04
0917E:  MOVWF  x94
09180:  MOVLB  0
09182:  CALL   473A
09186:  GOTO   91AE (RETURN)
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "../core/measurement/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../storage/mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
01C26:  MOVLW  14
01C28:  MOVWF  FF6
01C2A:  MOVLW  05
01C2C:  MOVWF  FF7
01C2E:  MOVLW  00
01C30:  MOVWF  FF8
01C32:  CALL   1BC0
....................     // output_high(ADC_CS); // ADC Chip Select
....................     output_high(MIS_FM_CS); // DAC Chip Select
01C36:  MOVLW  DB
01C38:  MOVWF  F92
01C3A:  BSF    F89.5
....................     output_high(SMF_CS); // SMF Chip Select
01C3C:  MOVLW  DB
01C3E:  MOVWF  F92
01C40:  BSF    F89.2
....................     output_low(CONNECT_CIGS1);
01C42:  MOVLW  5E
01C44:  MOVWF  F94
01C46:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
01C48:  MOVLW  5E
01C4A:  MOVWF  F94
01C4C:  BCF    F8B.5
....................     output_high(EN_NPWR);
01C4E:  MOVLW  5E
01C50:  MOVWF  F94
01C52:  BSF    F8B.7
....................     delay_ms(1);
01C54:  MOVLW  01
01C56:  MOVLB  A
01C58:  MOVWF  x74
01C5A:  MOVLB  0
01C5C:  CALL   1B40
....................     fprintf(PC, "\tComplete\r\n");
01C60:  MOVLW  24
01C62:  MOVWF  FF6
01C64:  MOVLW  05
01C66:  MOVWF  FF7
01C68:  MOVLW  00
01C6A:  MOVWF  FF8
01C6C:  CALL   1BC0
01C70:  GOTO   B48C (RETURN)
.................... }
.................... 
.................... 
.................... void test_sweep(unsigned int8 sweep_step)
.................... {
....................     fprintf(PC, "Start TEST SWEEP\r\n");
....................     output_high(CONNECT_CIGS1);
....................     output_low(EN_NPWR); // Enable power to CIGS
....................     delay_us(100); // wait for the CIGS to stabilize
....................     fprintf(PC, "step, voltage, current\r\n");
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     delay_ms(100); // wait for the DAC to stabilize
.................... 
.................... 
....................     unsigned int16 volt;
....................     unsigned int16 curr;
....................     for (unsigned int8 count = 0; count < sweep_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
.................... 
....................         volt = ad7490_read(ADC_CIGS1_AMP); // read CIGS voltage
....................         curr = ad7490_read(ADC_CIGS1_CURR); // read CIGS current
....................         
....................         fprintf(PC, "%u, %lu, %lu\r\n", count, volt, curr);
....................         delay_ms(1); // wait for the ADC to stabilize
....................     }
.................... }
.................... 
.................... void test_adc()
.................... {
....................     unsigned int16 ans;
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     fprintf(PC, "Start ADC TEST\r\n");
....................     ans = ad7490_read(ADC_CIGS1_VOLT);
....................     fprintf(PC, "ADC Voltage: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_CURR);
....................     fprintf(PC, "ADC Current: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_AMP);
....................     fprintf(PC, "ADC CIGS1 Amp: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_VREF);
....................     fprintf(PC, "ADC CIGS1 VREF: %04LX\r\n", ans);
.................... }
.................... 
.................... void sweep_2ports(unsigned int8 measurement_step)
.................... { 
....................     fprintf(PC, "Start SWEEP 2ports\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1 and CIGS2
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
....................     unsigned int16 cigs2_buffer[2][0xFF];
.................... 
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_VOLT);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP 2port\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... 
.................... 
.................... /*
.................... void add_smf_queue_data()
.................... {
....................     SmfDataStruct smf_data;
....................     smf_data.type = SMF_DATA_TYPE_CIGS;
....................     smf_data.length = PACKET_SIZE;
....................     memcpy(smf_data.data, packetdata, PACKET_SIZE);
....................     enqueue_smf_data(&smf_data);
.................... }
.................... */
.................... void add_smf_queue_piclog()
.................... {}
.................... 
.................... void convert_datas(MEASUREMENT_DATA measured_data, )
.................... {
....................     
.................... }
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, "Start SWEEP with threshold\r\n");
*
070BE:  MOVLW  26
070C0:  MOVWF  FF6
070C2:  MOVLW  06
070C4:  MOVWF  FF7
070C6:  MOVLW  00
070C8:  MOVWF  FF8
070CA:  CALL   1BC0
....................    
....................     // Enable both CIGS ports
....................     output_high(CONNECT_CIGS1);
070CE:  MOVLW  5E
070D0:  MOVWF  F94
070D2:  BSF    F8B.0
....................     output_high(CONNECT_CIGS2);
070D4:  MOVLW  5E
070D6:  MOVWF  F94
070D8:  BSF    F8B.5
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     SWEEP_CONFIG port1 = {0};
070DA:  MOVLB  1
070DC:  CLRF   xB7
070DE:  CLRF   xB8
070E0:  CLRF   xB9
070E2:  CLRF   xBA
070E4:  CLRF   xBB
070E6:  CLRF   xBC
070E8:  CLRF   xBD
070EA:  CLRF   xBE
070EC:  CLRF   xBF
070EE:  CLRF   xC0
070F0:  CLRF   xC1
070F2:  CLRF   xC2
070F4:  CLRF   xC3
070F6:  CLRF   xC4
070F8:  CLRF   xC5
070FA:  CLRF   xC6
070FC:  CLRF   xC7
070FE:  CLRF   xC8
07100:  CLRF   xC9
07102:  CLRF   xCA
07104:  CLRF   xCB
07106:  CLRF   xCC
07108:  CLRF   xCD
0710A:  CLRF   xCE
0710C:  CLRF   xCF
0710E:  CLRF   xD0
07110:  CLRF   xD1
07112:  CLRF   xD2
07114:  CLRF   xD3
07116:  CLRF   xD4
07118:  CLRF   xD5
0711A:  CLRF   xD6
0711C:  CLRF   xD7
0711E:  CLRF   xD8
07120:  CLRF   xD9
07122:  CLRF   xDA
07124:  CLRF   xDB
07126:  CLRF   xDC
07128:  CLRF   xDD
0712A:  CLRF   xDE
0712C:  CLRF   xDF
0712E:  CLRF   xE0
07130:  CLRF   xE1
07132:  CLRF   xE2
07134:  CLRF   xE3
07136:  CLRF   xE4
07138:  CLRF   xE5
0713A:  CLRF   xE6
0713C:  CLRF   xE7
0713E:  CLRF   xE8
07140:  CLRF   xE9
07142:  CLRF   xEA
07144:  CLRF   xEB
07146:  CLRF   xEC
07148:  CLRF   xED
0714A:  CLRF   xEE
0714C:  CLRF   xEF
0714E:  CLRF   xF0
07150:  CLRF   xF1
07152:  CLRF   xF2
07154:  CLRF   xF3
07156:  CLRF   xF4
07158:  CLRF   xF5
0715A:  CLRF   xF6
0715C:  CLRF   xF7
0715E:  CLRF   xF8
07160:  CLRF   xF9
07162:  CLRF   xFA
07164:  CLRF   xFB
07166:  CLRF   xFC
07168:  CLRF   xFD
0716A:  CLRF   xFE
0716C:  CLRF   xFF
0716E:  MOVLB  2
07170:  CLRF   x00
07172:  CLRF   x01
07174:  CLRF   x02
07176:  CLRF   x03
07178:  CLRF   x04
0717A:  CLRF   x05
0717C:  CLRF   x06
0717E:  CLRF   x07
07180:  CLRF   x08
07182:  CLRF   x09
07184:  CLRF   x0A
07186:  CLRF   x0B
07188:  CLRF   x0C
0718A:  CLRF   x0D
0718C:  CLRF   x0E
0718E:  CLRF   x0F
07190:  CLRF   x10
07192:  CLRF   x11
07194:  CLRF   x12
07196:  CLRF   x13
07198:  CLRF   x14
0719A:  CLRF   x15
0719C:  CLRF   x16
0719E:  CLRF   x17
071A0:  CLRF   x18
071A2:  CLRF   x19
071A4:  CLRF   x1A
071A6:  CLRF   x1B
071A8:  CLRF   x1C
071AA:  CLRF   x1D
071AC:  CLRF   x1E
071AE:  CLRF   x1F
071B0:  CLRF   x20
071B2:  CLRF   x21
071B4:  CLRF   x22
071B6:  CLRF   x23
071B8:  CLRF   x24
071BA:  CLRF   x25
071BC:  CLRF   x26
071BE:  CLRF   x27
071C0:  CLRF   x28
071C2:  CLRF   x29
071C4:  CLRF   x2A
071C6:  CLRF   x2B
071C8:  CLRF   x2C
071CA:  CLRF   x2D
071CC:  CLRF   x2E
071CE:  CLRF   x2F
071D0:  CLRF   x30
071D2:  CLRF   x31
071D4:  CLRF   x32
071D6:  CLRF   x33
071D8:  CLRF   x34
071DA:  CLRF   x35
071DC:  CLRF   x36
071DE:  CLRF   x37
071E0:  CLRF   x38
071E2:  CLRF   x39
071E4:  CLRF   x3A
071E6:  CLRF   x3B
071E8:  CLRF   x3C
071EA:  CLRF   x3D
071EC:  CLRF   x3E
071EE:  CLRF   x3F
071F0:  CLRF   x40
071F2:  CLRF   x41
071F4:  CLRF   x42
071F6:  CLRF   x43
071F8:  CLRF   x44
071FA:  CLRF   x45
071FC:  CLRF   x46
071FE:  CLRF   x47
07200:  CLRF   x48
07202:  CLRF   x49
07204:  CLRF   x4A
07206:  CLRF   x4B
07208:  CLRF   x4C
0720A:  CLRF   x4D
0720C:  CLRF   x4E
0720E:  CLRF   x4F
07210:  CLRF   x50
07212:  CLRF   x51
07214:  CLRF   x52
07216:  CLRF   x53
07218:  CLRF   x54
0721A:  CLRF   x55
0721C:  CLRF   x56
0721E:  CLRF   x57
07220:  CLRF   x58
07222:  CLRF   x59
07224:  CLRF   x5A
07226:  CLRF   x5B
07228:  CLRF   x5C
0722A:  CLRF   x5D
0722C:  CLRF   x5E
0722E:  CLRF   x5F
07230:  CLRF   x60
07232:  CLRF   x61
07234:  CLRF   x62
07236:  CLRF   x63
07238:  CLRF   x64
0723A:  CLRF   x65
0723C:  CLRF   x66
0723E:  CLRF   x67
07240:  CLRF   x68
07242:  CLRF   x69
07244:  CLRF   x6A
07246:  CLRF   x6B
07248:  CLRF   x6C
0724A:  CLRF   x6D
0724C:  CLRF   x6E
0724E:  CLRF   x6F
07250:  CLRF   x70
07252:  CLRF   x71
07254:  CLRF   x72
07256:  CLRF   x73
07258:  CLRF   x74
0725A:  CLRF   x75
0725C:  CLRF   x76
0725E:  CLRF   x77
07260:  CLRF   x78
07262:  CLRF   x79
07264:  CLRF   x7A
07266:  CLRF   x7B
07268:  CLRF   x7C
0726A:  CLRF   x7D
0726C:  CLRF   x7E
0726E:  CLRF   x7F
07270:  CLRF   x80
07272:  CLRF   x81
07274:  CLRF   x82
07276:  CLRF   x83
07278:  CLRF   x84
0727A:  CLRF   x85
0727C:  CLRF   x86
0727E:  CLRF   x87
07280:  CLRF   x88
07282:  CLRF   x89
07284:  CLRF   x8A
07286:  CLRF   x8B
07288:  CLRF   x8C
0728A:  CLRF   x8D
0728C:  CLRF   x8E
0728E:  CLRF   x8F
07290:  CLRF   x90
07292:  CLRF   x91
07294:  CLRF   x92
07296:  CLRF   x93
07298:  CLRF   x94
0729A:  CLRF   x95
0729C:  CLRF   x96
0729E:  CLRF   x97
072A0:  CLRF   x98
072A2:  CLRF   x99
072A4:  CLRF   x9A
072A6:  CLRF   x9B
072A8:  CLRF   x9C
072AA:  CLRF   x9D
072AC:  CLRF   x9E
072AE:  CLRF   x9F
072B0:  CLRF   xA0
072B2:  CLRF   xA1
072B4:  CLRF   xA2
072B6:  CLRF   xA3
072B8:  CLRF   xA4
072BA:  CLRF   xA5
072BC:  CLRF   xA6
072BE:  CLRF   xA7
072C0:  CLRF   xA8
072C2:  CLRF   xA9
072C4:  CLRF   xAA
072C6:  CLRF   xAB
072C8:  CLRF   xAC
072CA:  CLRF   xAD
072CC:  CLRF   xAE
072CE:  CLRF   xAF
072D0:  CLRF   xB0
072D2:  CLRF   xB1
072D4:  CLRF   xB2
072D6:  CLRF   xB3
072D8:  CLRF   xB4
072DA:  CLRF   xB5
072DC:  CLRF   xB6
072DE:  CLRF   xB7
072E0:  CLRF   xB8
072E2:  CLRF   xB9
072E4:  CLRF   xBA
072E6:  CLRF   xBB
072E8:  CLRF   xBC
072EA:  CLRF   xBD
072EC:  CLRF   xBE
072EE:  CLRF   xBF
072F0:  CLRF   xC0
072F2:  CLRF   xC1
072F4:  CLRF   xC2
072F6:  CLRF   xC3
072F8:  CLRF   xC4
072FA:  CLRF   xC5
072FC:  CLRF   xC6
072FE:  CLRF   xC7
07300:  CLRF   xC8
07302:  CLRF   xC9
07304:  CLRF   xCA
07306:  CLRF   xCB
07308:  CLRF   xCC
0730A:  CLRF   xCD
0730C:  CLRF   xCE
0730E:  CLRF   xCF
07310:  CLRF   xD0
07312:  CLRF   xD1
07314:  CLRF   xD2
07316:  CLRF   xD3
07318:  CLRF   xD4
0731A:  CLRF   xD5
0731C:  CLRF   xD6
0731E:  CLRF   xD7
07320:  CLRF   xD8
07322:  CLRF   xD9
07324:  CLRF   xDA
07326:  CLRF   xDB
07328:  CLRF   xDC
0732A:  CLRF   xDD
0732C:  CLRF   xDE
0732E:  CLRF   xDF
07330:  CLRF   xE0
07332:  CLRF   xE1
07334:  CLRF   xE2
07336:  CLRF   xE3
07338:  CLRF   xE4
0733A:  CLRF   xE5
0733C:  CLRF   xE6
0733E:  CLRF   xE7
07340:  CLRF   xE8
07342:  CLRF   xE9
07344:  CLRF   xEA
07346:  CLRF   xEB
07348:  CLRF   xEC
0734A:  CLRF   xED
0734C:  CLRF   xEE
0734E:  CLRF   xEF
07350:  CLRF   xF0
07352:  CLRF   xF1
07354:  CLRF   xF2
07356:  CLRF   xF3
07358:  CLRF   xF4
0735A:  CLRF   xF5
0735C:  CLRF   xF6
0735E:  CLRF   xF7
07360:  CLRF   xF8
07362:  CLRF   xF9
07364:  CLRF   xFA
07366:  CLRF   xFB
07368:  CLRF   xFC
0736A:  CLRF   xFD
0736C:  CLRF   xFE
0736E:  CLRF   xFF
07370:  MOVLB  3
07372:  CLRF   x00
07374:  CLRF   x01
07376:  CLRF   x02
07378:  CLRF   x03
0737A:  CLRF   x04
0737C:  CLRF   x05
0737E:  CLRF   x06
07380:  CLRF   x07
07382:  CLRF   x08
07384:  CLRF   x09
07386:  CLRF   x0A
07388:  CLRF   x0B
0738A:  CLRF   x0C
0738C:  CLRF   x0D
0738E:  CLRF   x0E
07390:  CLRF   x0F
07392:  CLRF   x10
07394:  CLRF   x11
07396:  CLRF   x12
07398:  CLRF   x13
0739A:  CLRF   x14
0739C:  CLRF   x15
0739E:  CLRF   x16
073A0:  CLRF   x17
073A2:  CLRF   x18
073A4:  CLRF   x19
073A6:  CLRF   x1A
073A8:  CLRF   x1B
073AA:  CLRF   x1C
073AC:  CLRF   x1D
073AE:  CLRF   x1E
073B0:  CLRF   x1F
073B2:  CLRF   x20
073B4:  CLRF   x21
073B6:  CLRF   x22
073B8:  CLRF   x23
073BA:  CLRF   x24
073BC:  CLRF   x25
073BE:  CLRF   x26
073C0:  CLRF   x27
073C2:  CLRF   x28
073C4:  CLRF   x29
073C6:  CLRF   x2A
073C8:  CLRF   x2B
073CA:  CLRF   x2C
073CC:  CLRF   x2D
073CE:  CLRF   x2E
073D0:  CLRF   x2F
073D2:  CLRF   x30
073D4:  CLRF   x31
073D6:  CLRF   x32
073D8:  CLRF   x33
073DA:  CLRF   x34
073DC:  CLRF   x35
073DE:  CLRF   x36
073E0:  CLRF   x37
073E2:  CLRF   x38
073E4:  CLRF   x39
073E6:  CLRF   x3A
073E8:  CLRF   x3B
073EA:  CLRF   x3C
073EC:  CLRF   x3D
073EE:  CLRF   x3E
073F0:  CLRF   x3F
073F2:  CLRF   x40
073F4:  CLRF   x41
073F6:  CLRF   x42
073F8:  CLRF   x43
073FA:  CLRF   x44
073FC:  CLRF   x45
073FE:  CLRF   x46
07400:  CLRF   x47
07402:  CLRF   x48
07404:  CLRF   x49
07406:  CLRF   x4A
07408:  CLRF   x4B
0740A:  CLRF   x4C
0740C:  CLRF   x4D
0740E:  CLRF   x4E
07410:  CLRF   x4F
07412:  CLRF   x50
07414:  CLRF   x51
07416:  CLRF   x52
07418:  CLRF   x53
0741A:  CLRF   x54
0741C:  CLRF   x55
0741E:  CLRF   x56
07420:  CLRF   x57
07422:  CLRF   x58
07424:  CLRF   x59
07426:  CLRF   x5A
07428:  CLRF   x5B
0742A:  CLRF   x5C
0742C:  CLRF   x5D
0742E:  CLRF   x5E
07430:  CLRF   x5F
07432:  CLRF   x60
07434:  CLRF   x61
07436:  CLRF   x62
07438:  CLRF   x63
0743A:  CLRF   x64
0743C:  CLRF   x65
0743E:  CLRF   x66
07440:  CLRF   x67
07442:  CLRF   x68
07444:  CLRF   x69
07446:  CLRF   x6A
07448:  CLRF   x6B
0744A:  CLRF   x6C
0744C:  CLRF   x6D
0744E:  CLRF   x6E
07450:  CLRF   x6F
07452:  CLRF   x70
07454:  CLRF   x71
07456:  CLRF   x72
07458:  CLRF   x73
0745A:  CLRF   x74
0745C:  CLRF   x75
0745E:  CLRF   x76
07460:  CLRF   x77
07462:  CLRF   x78
07464:  CLRF   x79
07466:  CLRF   x7A
07468:  CLRF   x7B
0746A:  CLRF   x7C
0746C:  CLRF   x7D
0746E:  CLRF   x7E
07470:  CLRF   x7F
07472:  CLRF   x80
07474:  CLRF   x81
07476:  CLRF   x82
07478:  CLRF   x83
0747A:  CLRF   x84
0747C:  CLRF   x85
0747E:  CLRF   x86
07480:  CLRF   x87
07482:  CLRF   x88
07484:  CLRF   x89
07486:  CLRF   x8A
07488:  CLRF   x8B
0748A:  CLRF   x8C
0748C:  CLRF   x8D
0748E:  CLRF   x8E
07490:  CLRF   x8F
07492:  CLRF   x90
07494:  CLRF   x91
07496:  CLRF   x92
07498:  CLRF   x93
0749A:  CLRF   x94
0749C:  CLRF   x95
0749E:  CLRF   x96
074A0:  CLRF   x97
074A2:  CLRF   x98
074A4:  CLRF   x99
074A6:  CLRF   x9A
074A8:  CLRF   x9B
074AA:  CLRF   x9C
074AC:  CLRF   x9D
074AE:  CLRF   x9E
074B0:  CLRF   x9F
074B2:  CLRF   xA0
074B4:  CLRF   xA1
074B6:  CLRF   xA2
074B8:  CLRF   xA3
074BA:  CLRF   xA4
074BC:  CLRF   xA5
074BE:  CLRF   xA6
074C0:  CLRF   xA7
074C2:  CLRF   xA8
074C4:  CLRF   xA9
074C6:  CLRF   xAA
074C8:  CLRF   xAB
074CA:  CLRF   xAC
074CC:  CLRF   xAD
074CE:  CLRF   xAE
074D0:  CLRF   xAF
074D2:  CLRF   xB0
074D4:  CLRF   xB1
074D6:  CLRF   xB2
074D8:  CLRF   xB3
074DA:  CLRF   xB4
074DC:  CLRF   xB5
074DE:  CLRF   xB6
074E0:  CLRF   xB7
074E2:  CLRF   xB8
074E4:  CLRF   xB9
074E6:  CLRF   xBA
074E8:  CLRF   xBB
074EA:  CLRF   xBC
074EC:  CLRF   xBD
074EE:  CLRF   xBE
074F0:  CLRF   xBF
074F2:  CLRF   xC0
074F4:  CLRF   xC1
074F6:  CLRF   xC2
074F8:  CLRF   xC3
074FA:  CLRF   xC4
074FC:  CLRF   xC5
074FE:  CLRF   xC6
07500:  CLRF   xC7
07502:  CLRF   xC8
07504:  CLRF   xC9
07506:  CLRF   xCA
07508:  CLRF   xCB
0750A:  CLRF   xCC
0750C:  CLRF   xCD
0750E:  CLRF   xCE
07510:  CLRF   xCF
07512:  CLRF   xD0
07514:  CLRF   xD1
07516:  CLRF   xD2
07518:  CLRF   xD3
0751A:  CLRF   xD4
0751C:  CLRF   xD5
0751E:  CLRF   xD6
07520:  CLRF   xD7
07522:  CLRF   xD8
07524:  CLRF   xD9
07526:  CLRF   xDA
07528:  CLRF   xDB
0752A:  CLRF   xDC
0752C:  CLRF   xDD
0752E:  CLRF   xDE
07530:  CLRF   xDF
07532:  CLRF   xE0
07534:  CLRF   xE1
07536:  CLRF   xE2
07538:  CLRF   xE3
0753A:  CLRF   xE4
0753C:  CLRF   xE5
0753E:  CLRF   xE6
07540:  CLRF   xE7
07542:  CLRF   xE8
07544:  CLRF   xE9
07546:  CLRF   xEA
07548:  CLRF   xEB
0754A:  CLRF   xEC
0754C:  CLRF   xED
0754E:  CLRF   xEE
07550:  CLRF   xEF
07552:  CLRF   xF0
07554:  CLRF   xF1
07556:  CLRF   xF2
07558:  CLRF   xF3
0755A:  CLRF   xF4
0755C:  CLRF   xF5
0755E:  CLRF   xF6
07560:  CLRF   xF7
07562:  CLRF   xF8
07564:  CLRF   xF9
07566:  CLRF   xFA
07568:  CLRF   xFB
0756A:  CLRF   xFC
0756C:  CLRF   xFD
0756E:  CLRF   xFE
07570:  CLRF   xFF
07572:  MOVLB  4
07574:  CLRF   x00
07576:  CLRF   x01
07578:  CLRF   x02
0757A:  CLRF   x03
0757C:  CLRF   x04
0757E:  CLRF   x05
07580:  CLRF   x06
07582:  CLRF   x07
07584:  CLRF   x08
07586:  CLRF   x09
07588:  CLRF   x0A
0758A:  CLRF   x0B
0758C:  CLRF   x0C
0758E:  CLRF   x0D
07590:  CLRF   x0E
07592:  CLRF   x0F
07594:  CLRF   x10
07596:  CLRF   x11
07598:  CLRF   x12
0759A:  CLRF   x13
0759C:  CLRF   x14
0759E:  CLRF   x15
075A0:  CLRF   x16
075A2:  CLRF   x17
075A4:  CLRF   x18
075A6:  CLRF   x19
075A8:  CLRF   x1A
075AA:  CLRF   x1B
075AC:  CLRF   x1C
075AE:  CLRF   x1D
075B0:  CLRF   x1E
075B2:  CLRF   x1F
075B4:  CLRF   x20
075B6:  CLRF   x21
075B8:  CLRF   x22
075BA:  CLRF   x23
075BC:  CLRF   x24
075BE:  CLRF   x25
075C0:  CLRF   x26
075C2:  CLRF   x27
075C4:  CLRF   x28
075C6:  CLRF   x29
075C8:  CLRF   x2A
075CA:  CLRF   x2B
075CC:  CLRF   x2C
075CE:  CLRF   x2D
075D0:  CLRF   x2E
075D2:  CLRF   x2F
075D4:  CLRF   x30
075D6:  CLRF   x31
075D8:  CLRF   x32
075DA:  CLRF   x33
075DC:  CLRF   x34
075DE:  CLRF   x35
075E0:  CLRF   x36
075E2:  CLRF   x37
075E4:  CLRF   x38
075E6:  CLRF   x39
075E8:  CLRF   x3A
075EA:  CLRF   x3B
075EC:  CLRF   x3C
075EE:  CLRF   x3D
075F0:  CLRF   x3E
075F2:  CLRF   x3F
075F4:  CLRF   x40
075F6:  CLRF   x41
075F8:  CLRF   x42
075FA:  CLRF   x43
075FC:  CLRF   x44
075FE:  CLRF   x45
07600:  CLRF   x46
07602:  CLRF   x47
07604:  CLRF   x48
07606:  CLRF   x49
07608:  CLRF   x4A
0760A:  CLRF   x4B
0760C:  CLRF   x4C
0760E:  CLRF   x4D
07610:  CLRF   x4E
07612:  CLRF   x4F
07614:  CLRF   x50
07616:  CLRF   x51
07618:  CLRF   x52
0761A:  CLRF   x53
0761C:  CLRF   x54
0761E:  CLRF   x55
07620:  CLRF   x56
07622:  CLRF   x57
07624:  CLRF   x58
07626:  CLRF   x59
07628:  CLRF   x5A
0762A:  CLRF   x5B
0762C:  CLRF   x5C
0762E:  CLRF   x5D
07630:  CLRF   x5E
07632:  CLRF   x5F
07634:  CLRF   x60
07636:  CLRF   x61
07638:  CLRF   x62
0763A:  CLRF   x63
0763C:  CLRF   x64
0763E:  CLRF   x65
07640:  CLRF   x66
07642:  CLRF   x67
07644:  CLRF   x68
07646:  CLRF   x69
07648:  CLRF   x6A
0764A:  CLRF   x6B
0764C:  CLRF   x6C
0764E:  CLRF   x6D
07650:  CLRF   x6E
07652:  CLRF   x6F
07654:  CLRF   x70
07656:  CLRF   x71
07658:  CLRF   x72
0765A:  CLRF   x73
0765C:  CLRF   x74
0765E:  CLRF   x75
07660:  CLRF   x76
07662:  CLRF   x77
07664:  CLRF   x78
07666:  CLRF   x79
07668:  CLRF   x7A
0766A:  CLRF   x7B
0766C:  CLRF   x7C
0766E:  CLRF   x7D
07670:  CLRF   x7E
07672:  CLRF   x7F
07674:  CLRF   x80
07676:  CLRF   x81
07678:  CLRF   x82
0767A:  CLRF   x83
0767C:  CLRF   x84
0767E:  CLRF   x85
07680:  CLRF   x86
07682:  CLRF   x87
07684:  CLRF   x88
07686:  CLRF   x89
07688:  CLRF   x8A
0768A:  CLRF   x8B
0768C:  CLRF   x8C
0768E:  CLRF   x8D
07690:  CLRF   x8E
07692:  CLRF   x8F
07694:  CLRF   x90
07696:  CLRF   x91
07698:  CLRF   x92
0769A:  CLRF   x93
0769C:  CLRF   x94
0769E:  CLRF   x95
076A0:  CLRF   x96
076A2:  CLRF   x97
076A4:  CLRF   x98
076A6:  CLRF   x99
076A8:  CLRF   x9A
076AA:  CLRF   x9B
076AC:  CLRF   x9C
076AE:  CLRF   x9D
076B0:  CLRF   x9E
076B2:  CLRF   x9F
076B4:  CLRF   xA0
076B6:  CLRF   xA1
076B8:  CLRF   xA2
076BA:  CLRF   xA3
076BC:  CLRF   xA4
076BE:  CLRF   xA5
076C0:  CLRF   xA6
076C2:  CLRF   xA7
076C4:  CLRF   xA8
076C6:  CLRF   xA9
076C8:  CLRF   xAA
076CA:  CLRF   xAB
076CC:  CLRF   xAC
076CE:  CLRF   xAD
076D0:  CLRF   xAE
076D2:  CLRF   xAF
076D4:  CLRF   xB0
076D6:  CLRF   xB1
076D8:  CLRF   xB2
076DA:  CLRF   xB3
076DC:  CLRF   xB4
076DE:  CLRF   xB5
076E0:  CLRF   xB6
076E2:  CLRF   xB7
076E4:  CLRF   xB8
076E6:  CLRF   xB9
076E8:  CLRF   xBA
076EA:  CLRF   xBB
076EC:  CLRF   xBC
076EE:  CLRF   xBD
076F0:  CLRF   xBE
076F2:  CLRF   xBF
076F4:  CLRF   xC0
076F6:  CLRF   xC1
076F8:  CLRF   xC2
076FA:  CLRF   xC3
076FC:  CLRF   xC4
076FE:  CLRF   xC5
07700:  CLRF   xC6
07702:  CLRF   xC7
07704:  CLRF   xC8
07706:  CLRF   xC9
07708:  CLRF   xCA
0770A:  CLRF   xCB
0770C:  CLRF   xCC
0770E:  CLRF   xCD
07710:  CLRF   xCE
07712:  CLRF   xCF
07714:  CLRF   xD0
07716:  CLRF   xD1
07718:  CLRF   xD2
0771A:  CLRF   xD3
0771C:  CLRF   xD4
0771E:  CLRF   xD5
07720:  CLRF   xD6
07722:  CLRF   xD7
07724:  CLRF   xD8
07726:  CLRF   xD9
07728:  CLRF   xDA
0772A:  CLRF   xDB
0772C:  CLRF   xDC
0772E:  CLRF   xDD
07730:  CLRF   xDE
07732:  CLRF   xDF
07734:  CLRF   xE0
07736:  CLRF   xE1
07738:  CLRF   xE2
0773A:  CLRF   xE3
0773C:  CLRF   xE4
0773E:  CLRF   xE5
07740:  CLRF   xE6
07742:  CLRF   xE7
07744:  CLRF   xE8
07746:  CLRF   xE9
07748:  CLRF   xEA
0774A:  CLRF   xEB
0774C:  CLRF   xEC
0774E:  CLRF   xED
07750:  CLRF   xEE
07752:  CLRF   xEF
07754:  CLRF   xF0
07756:  CLRF   xF1
07758:  CLRF   xF2
0775A:  CLRF   xF3
0775C:  CLRF   xF4
0775E:  CLRF   xF5
07760:  CLRF   xF6
07762:  CLRF   xF7
07764:  CLRF   xF8
07766:  CLRF   xF9
07768:  CLRF   xFA
0776A:  CLRF   xFB
0776C:  CLRF   xFC
0776E:  CLRF   xFD
07770:  CLRF   xFE
07772:  CLRF   xFF
07774:  MOVLB  5
07776:  CLRF   x00
07778:  CLRF   x01
0777A:  CLRF   x02
0777C:  CLRF   x03
0777E:  CLRF   x04
07780:  CLRF   x05
07782:  CLRF   x06
07784:  CLRF   x07
07786:  CLRF   x08
07788:  CLRF   x09
0778A:  CLRF   x0A
0778C:  CLRF   x0B
0778E:  CLRF   x0C
07790:  CLRF   x0D
07792:  CLRF   x0E
07794:  CLRF   x0F
07796:  CLRF   x10
07798:  CLRF   x11
0779A:  CLRF   x12
0779C:  CLRF   x13
0779E:  CLRF   x14
077A0:  CLRF   x15
077A2:  CLRF   x16
077A4:  CLRF   x17
077A6:  CLRF   x18
077A8:  CLRF   x19
077AA:  CLRF   x1A
077AC:  CLRF   x1B
077AE:  CLRF   x1C
077B0:  CLRF   x1D
077B2:  CLRF   x1E
077B4:  CLRF   x1F
077B6:  CLRF   x20
077B8:  CLRF   x21
077BA:  CLRF   x22
077BC:  CLRF   x23
077BE:  CLRF   x24
077C0:  CLRF   x25
077C2:  CLRF   x26
077C4:  CLRF   x27
077C6:  CLRF   x28
077C8:  CLRF   x29
077CA:  CLRF   x2A
077CC:  CLRF   x2B
077CE:  CLRF   x2C
077D0:  CLRF   x2D
077D2:  CLRF   x2E
077D4:  CLRF   x2F
077D6:  CLRF   x30
077D8:  CLRF   x31
077DA:  CLRF   x32
077DC:  CLRF   x33
077DE:  CLRF   x34
077E0:  CLRF   x35
077E2:  CLRF   x36
077E4:  CLRF   x37
077E6:  CLRF   x38
077E8:  CLRF   x39
077EA:  CLRF   x3A
077EC:  CLRF   x3B
077EE:  CLRF   x3C
077F0:  CLRF   x3D
077F2:  CLRF   x3E
077F4:  CLRF   x3F
077F6:  CLRF   x40
077F8:  CLRF   x41
077FA:  CLRF   x42
077FC:  CLRF   x43
077FE:  CLRF   x44
07800:  CLRF   x45
07802:  CLRF   x46
07804:  CLRF   x47
07806:  CLRF   x48
07808:  CLRF   x49
0780A:  CLRF   x4A
0780C:  CLRF   x4B
0780E:  CLRF   x4C
07810:  CLRF   x4D
07812:  CLRF   x4E
07814:  CLRF   x4F
07816:  CLRF   x50
07818:  CLRF   x51
0781A:  CLRF   x52
0781C:  CLRF   x53
0781E:  CLRF   x54
07820:  CLRF   x55
07822:  CLRF   x56
07824:  CLRF   x57
07826:  CLRF   x58
07828:  CLRF   x59
0782A:  CLRF   x5A
0782C:  CLRF   x5B
0782E:  CLRF   x5C
07830:  CLRF   x5D
07832:  CLRF   x5E
07834:  CLRF   x5F
07836:  CLRF   x60
07838:  CLRF   x61
0783A:  CLRF   x62
0783C:  CLRF   x63
0783E:  CLRF   x64
07840:  CLRF   x65
07842:  CLRF   x66
07844:  CLRF   x67
07846:  CLRF   x68
07848:  CLRF   x69
0784A:  CLRF   x6A
0784C:  CLRF   x6B
0784E:  CLRF   x6C
07850:  CLRF   x6D
07852:  CLRF   x6E
07854:  CLRF   x6F
07856:  CLRF   x70
07858:  CLRF   x71
0785A:  CLRF   x72
0785C:  CLRF   x73
0785E:  CLRF   x74
07860:  CLRF   x75
07862:  CLRF   x76
07864:  CLRF   x77
07866:  CLRF   x78
07868:  CLRF   x79
0786A:  CLRF   x7A
0786C:  CLRF   x7B
0786E:  CLRF   x7C
07870:  CLRF   x7D
07872:  CLRF   x7E
07874:  CLRF   x7F
07876:  CLRF   x80
07878:  CLRF   x81
0787A:  CLRF   x82
0787C:  CLRF   x83
0787E:  CLRF   x84
07880:  CLRF   x85
07882:  CLRF   x86
07884:  CLRF   x87
07886:  CLRF   x88
07888:  CLRF   x89
0788A:  CLRF   x8A
0788C:  CLRF   x8B
0788E:  CLRF   x8C
07890:  CLRF   x8D
07892:  CLRF   x8E
07894:  CLRF   x8F
07896:  CLRF   x90
07898:  CLRF   x91
0789A:  CLRF   x92
0789C:  CLRF   x93
0789E:  CLRF   x94
078A0:  CLRF   x95
078A2:  CLRF   x96
078A4:  CLRF   x97
078A6:  CLRF   x98
078A8:  CLRF   x99
078AA:  CLRF   x9A
078AC:  CLRF   x9B
078AE:  CLRF   x9C
078B0:  CLRF   x9D
078B2:  CLRF   x9E
078B4:  CLRF   x9F
078B6:  CLRF   xA0
078B8:  CLRF   xA1
078BA:  CLRF   xA2
078BC:  CLRF   xA3
078BE:  CLRF   xA4
078C0:  CLRF   xA5
078C2:  CLRF   xA6
078C4:  CLRF   xA7
078C6:  CLRF   xA8
078C8:  CLRF   xA9
078CA:  CLRF   xAA
078CC:  CLRF   xAB
078CE:  CLRF   xAC
078D0:  CLRF   xAD
078D2:  CLRF   xAE
078D4:  CLRF   xAF
078D6:  CLRF   xB0
078D8:  CLRF   xB1
078DA:  CLRF   xB2
078DC:  CLRF   xB3
078DE:  CLRF   xB4
078E0:  CLRF   xB5
078E2:  CLRF   xB6
....................     port1.port_num = 1;
078E4:  MOVLW  01
078E6:  MOVLB  1
078E8:  MOVWF  xB7
....................     port1.sweep_step = 0;
078EA:  CLRF   xB9
078EC:  CLRF   xB8
....................     port1.active = 1;
078EE:  MOVLB  5
078F0:  BSF    xB6.0
.................... 
....................     // Init Port2
....................     SWEEP_CONFIG port2 = {0};
078F2:  CLRF   xB7
078F4:  CLRF   xB8
078F6:  CLRF   xB9
078F8:  CLRF   xBA
078FA:  CLRF   xBB
078FC:  CLRF   xBC
078FE:  CLRF   xBD
07900:  CLRF   xBE
07902:  CLRF   xBF
07904:  CLRF   xC0
07906:  CLRF   xC1
07908:  CLRF   xC2
0790A:  CLRF   xC3
0790C:  CLRF   xC4
0790E:  CLRF   xC5
07910:  CLRF   xC6
07912:  CLRF   xC7
07914:  CLRF   xC8
07916:  CLRF   xC9
07918:  CLRF   xCA
0791A:  CLRF   xCB
0791C:  CLRF   xCC
0791E:  CLRF   xCD
07920:  CLRF   xCE
07922:  CLRF   xCF
07924:  CLRF   xD0
07926:  CLRF   xD1
07928:  CLRF   xD2
0792A:  CLRF   xD3
0792C:  CLRF   xD4
0792E:  CLRF   xD5
07930:  CLRF   xD6
07932:  CLRF   xD7
07934:  CLRF   xD8
07936:  CLRF   xD9
07938:  CLRF   xDA
0793A:  CLRF   xDB
0793C:  CLRF   xDC
0793E:  CLRF   xDD
07940:  CLRF   xDE
07942:  CLRF   xDF
07944:  CLRF   xE0
07946:  CLRF   xE1
07948:  CLRF   xE2
0794A:  CLRF   xE3
0794C:  CLRF   xE4
0794E:  CLRF   xE5
07950:  CLRF   xE6
07952:  CLRF   xE7
07954:  CLRF   xE8
07956:  CLRF   xE9
07958:  CLRF   xEA
0795A:  CLRF   xEB
0795C:  CLRF   xEC
0795E:  CLRF   xED
07960:  CLRF   xEE
07962:  CLRF   xEF
07964:  CLRF   xF0
07966:  CLRF   xF1
07968:  CLRF   xF2
0796A:  CLRF   xF3
0796C:  CLRF   xF4
0796E:  CLRF   xF5
07970:  CLRF   xF6
07972:  CLRF   xF7
07974:  CLRF   xF8
07976:  CLRF   xF9
07978:  CLRF   xFA
0797A:  CLRF   xFB
0797C:  CLRF   xFC
0797E:  CLRF   xFD
07980:  CLRF   xFE
07982:  CLRF   xFF
07984:  MOVLB  6
07986:  CLRF   x00
07988:  CLRF   x01
0798A:  CLRF   x02
0798C:  CLRF   x03
0798E:  CLRF   x04
07990:  CLRF   x05
07992:  CLRF   x06
07994:  CLRF   x07
07996:  CLRF   x08
07998:  CLRF   x09
0799A:  CLRF   x0A
0799C:  CLRF   x0B
0799E:  CLRF   x0C
079A0:  CLRF   x0D
079A2:  CLRF   x0E
079A4:  CLRF   x0F
079A6:  CLRF   x10
079A8:  CLRF   x11
079AA:  CLRF   x12
079AC:  CLRF   x13
079AE:  CLRF   x14
079B0:  CLRF   x15
079B2:  CLRF   x16
079B4:  CLRF   x17
079B6:  CLRF   x18
079B8:  CLRF   x19
079BA:  CLRF   x1A
079BC:  CLRF   x1B
079BE:  CLRF   x1C
079C0:  CLRF   x1D
079C2:  CLRF   x1E
079C4:  CLRF   x1F
079C6:  CLRF   x20
079C8:  CLRF   x21
079CA:  CLRF   x22
079CC:  CLRF   x23
079CE:  CLRF   x24
079D0:  CLRF   x25
079D2:  CLRF   x26
079D4:  CLRF   x27
079D6:  CLRF   x28
079D8:  CLRF   x29
079DA:  CLRF   x2A
079DC:  CLRF   x2B
079DE:  CLRF   x2C
079E0:  CLRF   x2D
079E2:  CLRF   x2E
079E4:  CLRF   x2F
079E6:  CLRF   x30
079E8:  CLRF   x31
079EA:  CLRF   x32
079EC:  CLRF   x33
079EE:  CLRF   x34
079F0:  CLRF   x35
079F2:  CLRF   x36
079F4:  CLRF   x37
079F6:  CLRF   x38
079F8:  CLRF   x39
079FA:  CLRF   x3A
079FC:  CLRF   x3B
079FE:  CLRF   x3C
07A00:  CLRF   x3D
07A02:  CLRF   x3E
07A04:  CLRF   x3F
07A06:  CLRF   x40
07A08:  CLRF   x41
07A0A:  CLRF   x42
07A0C:  CLRF   x43
07A0E:  CLRF   x44
07A10:  CLRF   x45
07A12:  CLRF   x46
07A14:  CLRF   x47
07A16:  CLRF   x48
07A18:  CLRF   x49
07A1A:  CLRF   x4A
07A1C:  CLRF   x4B
07A1E:  CLRF   x4C
07A20:  CLRF   x4D
07A22:  CLRF   x4E
07A24:  CLRF   x4F
07A26:  CLRF   x50
07A28:  CLRF   x51
07A2A:  CLRF   x52
07A2C:  CLRF   x53
07A2E:  CLRF   x54
07A30:  CLRF   x55
07A32:  CLRF   x56
07A34:  CLRF   x57
07A36:  CLRF   x58
07A38:  CLRF   x59
07A3A:  CLRF   x5A
07A3C:  CLRF   x5B
07A3E:  CLRF   x5C
07A40:  CLRF   x5D
07A42:  CLRF   x5E
07A44:  CLRF   x5F
07A46:  CLRF   x60
07A48:  CLRF   x61
07A4A:  CLRF   x62
07A4C:  CLRF   x63
07A4E:  CLRF   x64
07A50:  CLRF   x65
07A52:  CLRF   x66
07A54:  CLRF   x67
07A56:  CLRF   x68
07A58:  CLRF   x69
07A5A:  CLRF   x6A
07A5C:  CLRF   x6B
07A5E:  CLRF   x6C
07A60:  CLRF   x6D
07A62:  CLRF   x6E
07A64:  CLRF   x6F
07A66:  CLRF   x70
07A68:  CLRF   x71
07A6A:  CLRF   x72
07A6C:  CLRF   x73
07A6E:  CLRF   x74
07A70:  CLRF   x75
07A72:  CLRF   x76
07A74:  CLRF   x77
07A76:  CLRF   x78
07A78:  CLRF   x79
07A7A:  CLRF   x7A
07A7C:  CLRF   x7B
07A7E:  CLRF   x7C
07A80:  CLRF   x7D
07A82:  CLRF   x7E
07A84:  CLRF   x7F
07A86:  CLRF   x80
07A88:  CLRF   x81
07A8A:  CLRF   x82
07A8C:  CLRF   x83
07A8E:  CLRF   x84
07A90:  CLRF   x85
07A92:  CLRF   x86
07A94:  CLRF   x87
07A96:  CLRF   x88
07A98:  CLRF   x89
07A9A:  CLRF   x8A
07A9C:  CLRF   x8B
07A9E:  CLRF   x8C
07AA0:  CLRF   x8D
07AA2:  CLRF   x8E
07AA4:  CLRF   x8F
07AA6:  CLRF   x90
07AA8:  CLRF   x91
07AAA:  CLRF   x92
07AAC:  CLRF   x93
07AAE:  CLRF   x94
07AB0:  CLRF   x95
07AB2:  CLRF   x96
07AB4:  CLRF   x97
07AB6:  CLRF   x98
07AB8:  CLRF   x99
07ABA:  CLRF   x9A
07ABC:  CLRF   x9B
07ABE:  CLRF   x9C
07AC0:  CLRF   x9D
07AC2:  CLRF   x9E
07AC4:  CLRF   x9F
07AC6:  CLRF   xA0
07AC8:  CLRF   xA1
07ACA:  CLRF   xA2
07ACC:  CLRF   xA3
07ACE:  CLRF   xA4
07AD0:  CLRF   xA5
07AD2:  CLRF   xA6
07AD4:  CLRF   xA7
07AD6:  CLRF   xA8
07AD8:  CLRF   xA9
07ADA:  CLRF   xAA
07ADC:  CLRF   xAB
07ADE:  CLRF   xAC
07AE0:  CLRF   xAD
07AE2:  CLRF   xAE
07AE4:  CLRF   xAF
07AE6:  CLRF   xB0
07AE8:  CLRF   xB1
07AEA:  CLRF   xB2
07AEC:  CLRF   xB3
07AEE:  CLRF   xB4
07AF0:  CLRF   xB5
07AF2:  CLRF   xB6
07AF4:  CLRF   xB7
07AF6:  CLRF   xB8
07AF8:  CLRF   xB9
07AFA:  CLRF   xBA
07AFC:  CLRF   xBB
07AFE:  CLRF   xBC
07B00:  CLRF   xBD
07B02:  CLRF   xBE
07B04:  CLRF   xBF
07B06:  CLRF   xC0
07B08:  CLRF   xC1
07B0A:  CLRF   xC2
07B0C:  CLRF   xC3
07B0E:  CLRF   xC4
07B10:  CLRF   xC5
07B12:  CLRF   xC6
07B14:  CLRF   xC7
07B16:  CLRF   xC8
07B18:  CLRF   xC9
07B1A:  CLRF   xCA
07B1C:  CLRF   xCB
07B1E:  CLRF   xCC
07B20:  CLRF   xCD
07B22:  CLRF   xCE
07B24:  CLRF   xCF
07B26:  CLRF   xD0
07B28:  CLRF   xD1
07B2A:  CLRF   xD2
07B2C:  CLRF   xD3
07B2E:  CLRF   xD4
07B30:  CLRF   xD5
07B32:  CLRF   xD6
07B34:  CLRF   xD7
07B36:  CLRF   xD8
07B38:  CLRF   xD9
07B3A:  CLRF   xDA
07B3C:  CLRF   xDB
07B3E:  CLRF   xDC
07B40:  CLRF   xDD
07B42:  CLRF   xDE
07B44:  CLRF   xDF
07B46:  CLRF   xE0
07B48:  CLRF   xE1
07B4A:  CLRF   xE2
07B4C:  CLRF   xE3
07B4E:  CLRF   xE4
07B50:  CLRF   xE5
07B52:  CLRF   xE6
07B54:  CLRF   xE7
07B56:  CLRF   xE8
07B58:  CLRF   xE9
07B5A:  CLRF   xEA
07B5C:  CLRF   xEB
07B5E:  CLRF   xEC
07B60:  CLRF   xED
07B62:  CLRF   xEE
07B64:  CLRF   xEF
07B66:  CLRF   xF0
07B68:  CLRF   xF1
07B6A:  CLRF   xF2
07B6C:  CLRF   xF3
07B6E:  CLRF   xF4
07B70:  CLRF   xF5
07B72:  CLRF   xF6
07B74:  CLRF   xF7
07B76:  CLRF   xF8
07B78:  CLRF   xF9
07B7A:  CLRF   xFA
07B7C:  CLRF   xFB
07B7E:  CLRF   xFC
07B80:  CLRF   xFD
07B82:  CLRF   xFE
07B84:  CLRF   xFF
07B86:  MOVLB  7
07B88:  CLRF   x00
07B8A:  CLRF   x01
07B8C:  CLRF   x02
07B8E:  CLRF   x03
07B90:  CLRF   x04
07B92:  CLRF   x05
07B94:  CLRF   x06
07B96:  CLRF   x07
07B98:  CLRF   x08
07B9A:  CLRF   x09
07B9C:  CLRF   x0A
07B9E:  CLRF   x0B
07BA0:  CLRF   x0C
07BA2:  CLRF   x0D
07BA4:  CLRF   x0E
07BA6:  CLRF   x0F
07BA8:  CLRF   x10
07BAA:  CLRF   x11
07BAC:  CLRF   x12
07BAE:  CLRF   x13
07BB0:  CLRF   x14
07BB2:  CLRF   x15
07BB4:  CLRF   x16
07BB6:  CLRF   x17
07BB8:  CLRF   x18
07BBA:  CLRF   x19
07BBC:  CLRF   x1A
07BBE:  CLRF   x1B
07BC0:  CLRF   x1C
07BC2:  CLRF   x1D
07BC4:  CLRF   x1E
07BC6:  CLRF   x1F
07BC8:  CLRF   x20
07BCA:  CLRF   x21
07BCC:  CLRF   x22
07BCE:  CLRF   x23
07BD0:  CLRF   x24
07BD2:  CLRF   x25
07BD4:  CLRF   x26
07BD6:  CLRF   x27
07BD8:  CLRF   x28
07BDA:  CLRF   x29
07BDC:  CLRF   x2A
07BDE:  CLRF   x2B
07BE0:  CLRF   x2C
07BE2:  CLRF   x2D
07BE4:  CLRF   x2E
07BE6:  CLRF   x2F
07BE8:  CLRF   x30
07BEA:  CLRF   x31
07BEC:  CLRF   x32
07BEE:  CLRF   x33
07BF0:  CLRF   x34
07BF2:  CLRF   x35
07BF4:  CLRF   x36
07BF6:  CLRF   x37
07BF8:  CLRF   x38
07BFA:  CLRF   x39
07BFC:  CLRF   x3A
07BFE:  CLRF   x3B
07C00:  CLRF   x3C
07C02:  CLRF   x3D
07C04:  CLRF   x3E
07C06:  CLRF   x3F
07C08:  CLRF   x40
07C0A:  CLRF   x41
07C0C:  CLRF   x42
07C0E:  CLRF   x43
07C10:  CLRF   x44
07C12:  CLRF   x45
07C14:  CLRF   x46
07C16:  CLRF   x47
07C18:  CLRF   x48
07C1A:  CLRF   x49
07C1C:  CLRF   x4A
07C1E:  CLRF   x4B
07C20:  CLRF   x4C
07C22:  CLRF   x4D
07C24:  CLRF   x4E
07C26:  CLRF   x4F
07C28:  CLRF   x50
07C2A:  CLRF   x51
07C2C:  CLRF   x52
07C2E:  CLRF   x53
07C30:  CLRF   x54
07C32:  CLRF   x55
07C34:  CLRF   x56
07C36:  CLRF   x57
07C38:  CLRF   x58
07C3A:  CLRF   x59
07C3C:  CLRF   x5A
07C3E:  CLRF   x5B
07C40:  CLRF   x5C
07C42:  CLRF   x5D
07C44:  CLRF   x5E
07C46:  CLRF   x5F
07C48:  CLRF   x60
07C4A:  CLRF   x61
07C4C:  CLRF   x62
07C4E:  CLRF   x63
07C50:  CLRF   x64
07C52:  CLRF   x65
07C54:  CLRF   x66
07C56:  CLRF   x67
07C58:  CLRF   x68
07C5A:  CLRF   x69
07C5C:  CLRF   x6A
07C5E:  CLRF   x6B
07C60:  CLRF   x6C
07C62:  CLRF   x6D
07C64:  CLRF   x6E
07C66:  CLRF   x6F
07C68:  CLRF   x70
07C6A:  CLRF   x71
07C6C:  CLRF   x72
07C6E:  CLRF   x73
07C70:  CLRF   x74
07C72:  CLRF   x75
07C74:  CLRF   x76
07C76:  CLRF   x77
07C78:  CLRF   x78
07C7A:  CLRF   x79
07C7C:  CLRF   x7A
07C7E:  CLRF   x7B
07C80:  CLRF   x7C
07C82:  CLRF   x7D
07C84:  CLRF   x7E
07C86:  CLRF   x7F
07C88:  CLRF   x80
07C8A:  CLRF   x81
07C8C:  CLRF   x82
07C8E:  CLRF   x83
07C90:  CLRF   x84
07C92:  CLRF   x85
07C94:  CLRF   x86
07C96:  CLRF   x87
07C98:  CLRF   x88
07C9A:  CLRF   x89
07C9C:  CLRF   x8A
07C9E:  CLRF   x8B
07CA0:  CLRF   x8C
07CA2:  CLRF   x8D
07CA4:  CLRF   x8E
07CA6:  CLRF   x8F
07CA8:  CLRF   x90
07CAA:  CLRF   x91
07CAC:  CLRF   x92
07CAE:  CLRF   x93
07CB0:  CLRF   x94
07CB2:  CLRF   x95
07CB4:  CLRF   x96
07CB6:  CLRF   x97
07CB8:  CLRF   x98
07CBA:  CLRF   x99
07CBC:  CLRF   x9A
07CBE:  CLRF   x9B
07CC0:  CLRF   x9C
07CC2:  CLRF   x9D
07CC4:  CLRF   x9E
07CC6:  CLRF   x9F
07CC8:  CLRF   xA0
07CCA:  CLRF   xA1
07CCC:  CLRF   xA2
07CCE:  CLRF   xA3
07CD0:  CLRF   xA4
07CD2:  CLRF   xA5
07CD4:  CLRF   xA6
07CD6:  CLRF   xA7
07CD8:  CLRF   xA8
07CDA:  CLRF   xA9
07CDC:  CLRF   xAA
07CDE:  CLRF   xAB
07CE0:  CLRF   xAC
07CE2:  CLRF   xAD
07CE4:  CLRF   xAE
07CE6:  CLRF   xAF
07CE8:  CLRF   xB0
07CEA:  CLRF   xB1
07CEC:  CLRF   xB2
07CEE:  CLRF   xB3
07CF0:  CLRF   xB4
07CF2:  CLRF   xB5
07CF4:  CLRF   xB6
07CF6:  CLRF   xB7
07CF8:  CLRF   xB8
07CFA:  CLRF   xB9
07CFC:  CLRF   xBA
07CFE:  CLRF   xBB
07D00:  CLRF   xBC
07D02:  CLRF   xBD
07D04:  CLRF   xBE
07D06:  CLRF   xBF
07D08:  CLRF   xC0
07D0A:  CLRF   xC1
07D0C:  CLRF   xC2
07D0E:  CLRF   xC3
07D10:  CLRF   xC4
07D12:  CLRF   xC5
07D14:  CLRF   xC6
07D16:  CLRF   xC7
07D18:  CLRF   xC8
07D1A:  CLRF   xC9
07D1C:  CLRF   xCA
07D1E:  CLRF   xCB
07D20:  CLRF   xCC
07D22:  CLRF   xCD
07D24:  CLRF   xCE
07D26:  CLRF   xCF
07D28:  CLRF   xD0
07D2A:  CLRF   xD1
07D2C:  CLRF   xD2
07D2E:  CLRF   xD3
07D30:  CLRF   xD4
07D32:  CLRF   xD5
07D34:  CLRF   xD6
07D36:  CLRF   xD7
07D38:  CLRF   xD8
07D3A:  CLRF   xD9
07D3C:  CLRF   xDA
07D3E:  CLRF   xDB
07D40:  CLRF   xDC
07D42:  CLRF   xDD
07D44:  CLRF   xDE
07D46:  CLRF   xDF
07D48:  CLRF   xE0
07D4A:  CLRF   xE1
07D4C:  CLRF   xE2
07D4E:  CLRF   xE3
07D50:  CLRF   xE4
07D52:  CLRF   xE5
07D54:  CLRF   xE6
07D56:  CLRF   xE7
07D58:  CLRF   xE8
07D5A:  CLRF   xE9
07D5C:  CLRF   xEA
07D5E:  CLRF   xEB
07D60:  CLRF   xEC
07D62:  CLRF   xED
07D64:  CLRF   xEE
07D66:  CLRF   xEF
07D68:  CLRF   xF0
07D6A:  CLRF   xF1
07D6C:  CLRF   xF2
07D6E:  CLRF   xF3
07D70:  CLRF   xF4
07D72:  CLRF   xF5
07D74:  CLRF   xF6
07D76:  CLRF   xF7
07D78:  CLRF   xF8
07D7A:  CLRF   xF9
07D7C:  CLRF   xFA
07D7E:  CLRF   xFB
07D80:  CLRF   xFC
07D82:  CLRF   xFD
07D84:  CLRF   xFE
07D86:  CLRF   xFF
07D88:  MOVLB  8
07D8A:  CLRF   x00
07D8C:  CLRF   x01
07D8E:  CLRF   x02
07D90:  CLRF   x03
07D92:  CLRF   x04
07D94:  CLRF   x05
07D96:  CLRF   x06
07D98:  CLRF   x07
07D9A:  CLRF   x08
07D9C:  CLRF   x09
07D9E:  CLRF   x0A
07DA0:  CLRF   x0B
07DA2:  CLRF   x0C
07DA4:  CLRF   x0D
07DA6:  CLRF   x0E
07DA8:  CLRF   x0F
07DAA:  CLRF   x10
07DAC:  CLRF   x11
07DAE:  CLRF   x12
07DB0:  CLRF   x13
07DB2:  CLRF   x14
07DB4:  CLRF   x15
07DB6:  CLRF   x16
07DB8:  CLRF   x17
07DBA:  CLRF   x18
07DBC:  CLRF   x19
07DBE:  CLRF   x1A
07DC0:  CLRF   x1B
07DC2:  CLRF   x1C
07DC4:  CLRF   x1D
07DC6:  CLRF   x1E
07DC8:  CLRF   x1F
07DCA:  CLRF   x20
07DCC:  CLRF   x21
07DCE:  CLRF   x22
07DD0:  CLRF   x23
07DD2:  CLRF   x24
07DD4:  CLRF   x25
07DD6:  CLRF   x26
07DD8:  CLRF   x27
07DDA:  CLRF   x28
07DDC:  CLRF   x29
07DDE:  CLRF   x2A
07DE0:  CLRF   x2B
07DE2:  CLRF   x2C
07DE4:  CLRF   x2D
07DE6:  CLRF   x2E
07DE8:  CLRF   x2F
07DEA:  CLRF   x30
07DEC:  CLRF   x31
07DEE:  CLRF   x32
07DF0:  CLRF   x33
07DF2:  CLRF   x34
07DF4:  CLRF   x35
07DF6:  CLRF   x36
07DF8:  CLRF   x37
07DFA:  CLRF   x38
07DFC:  CLRF   x39
07DFE:  CLRF   x3A
07E00:  CLRF   x3B
07E02:  CLRF   x3C
07E04:  CLRF   x3D
07E06:  CLRF   x3E
07E08:  CLRF   x3F
07E0A:  CLRF   x40
07E0C:  CLRF   x41
07E0E:  CLRF   x42
07E10:  CLRF   x43
07E12:  CLRF   x44
07E14:  CLRF   x45
07E16:  CLRF   x46
07E18:  CLRF   x47
07E1A:  CLRF   x48
07E1C:  CLRF   x49
07E1E:  CLRF   x4A
07E20:  CLRF   x4B
07E22:  CLRF   x4C
07E24:  CLRF   x4D
07E26:  CLRF   x4E
07E28:  CLRF   x4F
07E2A:  CLRF   x50
07E2C:  CLRF   x51
07E2E:  CLRF   x52
07E30:  CLRF   x53
07E32:  CLRF   x54
07E34:  CLRF   x55
07E36:  CLRF   x56
07E38:  CLRF   x57
07E3A:  CLRF   x58
07E3C:  CLRF   x59
07E3E:  CLRF   x5A
07E40:  CLRF   x5B
07E42:  CLRF   x5C
07E44:  CLRF   x5D
07E46:  CLRF   x5E
07E48:  CLRF   x5F
07E4A:  CLRF   x60
07E4C:  CLRF   x61
07E4E:  CLRF   x62
07E50:  CLRF   x63
07E52:  CLRF   x64
07E54:  CLRF   x65
07E56:  CLRF   x66
07E58:  CLRF   x67
07E5A:  CLRF   x68
07E5C:  CLRF   x69
07E5E:  CLRF   x6A
07E60:  CLRF   x6B
07E62:  CLRF   x6C
07E64:  CLRF   x6D
07E66:  CLRF   x6E
07E68:  CLRF   x6F
07E6A:  CLRF   x70
07E6C:  CLRF   x71
07E6E:  CLRF   x72
07E70:  CLRF   x73
07E72:  CLRF   x74
07E74:  CLRF   x75
07E76:  CLRF   x76
07E78:  CLRF   x77
07E7A:  CLRF   x78
07E7C:  CLRF   x79
07E7E:  CLRF   x7A
07E80:  CLRF   x7B
07E82:  CLRF   x7C
07E84:  CLRF   x7D
07E86:  CLRF   x7E
07E88:  CLRF   x7F
07E8A:  CLRF   x80
07E8C:  CLRF   x81
07E8E:  CLRF   x82
07E90:  CLRF   x83
07E92:  CLRF   x84
07E94:  CLRF   x85
07E96:  CLRF   x86
07E98:  CLRF   x87
07E9A:  CLRF   x88
07E9C:  CLRF   x89
07E9E:  CLRF   x8A
07EA0:  CLRF   x8B
07EA2:  CLRF   x8C
07EA4:  CLRF   x8D
07EA6:  CLRF   x8E
07EA8:  CLRF   x8F
07EAA:  CLRF   x90
07EAC:  CLRF   x91
07EAE:  CLRF   x92
07EB0:  CLRF   x93
07EB2:  CLRF   x94
07EB4:  CLRF   x95
07EB6:  CLRF   x96
07EB8:  CLRF   x97
07EBA:  CLRF   x98
07EBC:  CLRF   x99
07EBE:  CLRF   x9A
07EC0:  CLRF   x9B
07EC2:  CLRF   x9C
07EC4:  CLRF   x9D
07EC6:  CLRF   x9E
07EC8:  CLRF   x9F
07ECA:  CLRF   xA0
07ECC:  CLRF   xA1
07ECE:  CLRF   xA2
07ED0:  CLRF   xA3
07ED2:  CLRF   xA4
07ED4:  CLRF   xA5
07ED6:  CLRF   xA6
07ED8:  CLRF   xA7
07EDA:  CLRF   xA8
07EDC:  CLRF   xA9
07EDE:  CLRF   xAA
07EE0:  CLRF   xAB
07EE2:  CLRF   xAC
07EE4:  CLRF   xAD
07EE6:  CLRF   xAE
07EE8:  CLRF   xAF
07EEA:  CLRF   xB0
07EEC:  CLRF   xB1
07EEE:  CLRF   xB2
07EF0:  CLRF   xB3
07EF2:  CLRF   xB4
07EF4:  CLRF   xB5
07EF6:  CLRF   xB6
07EF8:  CLRF   xB7
07EFA:  CLRF   xB8
07EFC:  CLRF   xB9
07EFE:  CLRF   xBA
07F00:  CLRF   xBB
07F02:  CLRF   xBC
07F04:  CLRF   xBD
07F06:  CLRF   xBE
07F08:  CLRF   xBF
07F0A:  CLRF   xC0
07F0C:  CLRF   xC1
07F0E:  CLRF   xC2
07F10:  CLRF   xC3
07F12:  CLRF   xC4
07F14:  CLRF   xC5
07F16:  CLRF   xC6
07F18:  CLRF   xC7
07F1A:  CLRF   xC8
07F1C:  CLRF   xC9
07F1E:  CLRF   xCA
07F20:  CLRF   xCB
07F22:  CLRF   xCC
07F24:  CLRF   xCD
07F26:  CLRF   xCE
07F28:  CLRF   xCF
07F2A:  CLRF   xD0
07F2C:  CLRF   xD1
07F2E:  CLRF   xD2
07F30:  CLRF   xD3
07F32:  CLRF   xD4
07F34:  CLRF   xD5
07F36:  CLRF   xD6
07F38:  CLRF   xD7
07F3A:  CLRF   xD8
07F3C:  CLRF   xD9
07F3E:  CLRF   xDA
07F40:  CLRF   xDB
07F42:  CLRF   xDC
07F44:  CLRF   xDD
07F46:  CLRF   xDE
07F48:  CLRF   xDF
07F4A:  CLRF   xE0
07F4C:  CLRF   xE1
07F4E:  CLRF   xE2
07F50:  CLRF   xE3
07F52:  CLRF   xE4
07F54:  CLRF   xE5
07F56:  CLRF   xE6
07F58:  CLRF   xE7
07F5A:  CLRF   xE8
07F5C:  CLRF   xE9
07F5E:  CLRF   xEA
07F60:  CLRF   xEB
07F62:  CLRF   xEC
07F64:  CLRF   xED
07F66:  CLRF   xEE
07F68:  CLRF   xEF
07F6A:  CLRF   xF0
07F6C:  CLRF   xF1
07F6E:  CLRF   xF2
07F70:  CLRF   xF3
07F72:  CLRF   xF4
07F74:  CLRF   xF5
07F76:  CLRF   xF6
07F78:  CLRF   xF7
07F7A:  CLRF   xF8
07F7C:  CLRF   xF9
07F7E:  CLRF   xFA
07F80:  CLRF   xFB
07F82:  CLRF   xFC
07F84:  CLRF   xFD
07F86:  CLRF   xFE
07F88:  CLRF   xFF
07F8A:  MOVLB  9
07F8C:  CLRF   x00
07F8E:  CLRF   x01
07F90:  CLRF   x02
07F92:  CLRF   x03
07F94:  CLRF   x04
07F96:  CLRF   x05
07F98:  CLRF   x06
07F9A:  CLRF   x07
07F9C:  CLRF   x08
07F9E:  CLRF   x09
07FA0:  CLRF   x0A
07FA2:  CLRF   x0B
07FA4:  CLRF   x0C
07FA6:  CLRF   x0D
07FA8:  CLRF   x0E
07FAA:  CLRF   x0F
07FAC:  CLRF   x10
07FAE:  CLRF   x11
07FB0:  CLRF   x12
07FB2:  CLRF   x13
07FB4:  CLRF   x14
07FB6:  CLRF   x15
07FB8:  CLRF   x16
07FBA:  CLRF   x17
07FBC:  CLRF   x18
07FBE:  CLRF   x19
07FC0:  CLRF   x1A
07FC2:  CLRF   x1B
07FC4:  CLRF   x1C
07FC6:  CLRF   x1D
07FC8:  CLRF   x1E
07FCA:  CLRF   x1F
07FCC:  CLRF   x20
07FCE:  CLRF   x21
07FD0:  CLRF   x22
07FD2:  CLRF   x23
07FD4:  CLRF   x24
07FD6:  CLRF   x25
07FD8:  CLRF   x26
07FDA:  CLRF   x27
07FDC:  CLRF   x28
07FDE:  CLRF   x29
07FE0:  CLRF   x2A
07FE2:  CLRF   x2B
07FE4:  CLRF   x2C
07FE6:  CLRF   x2D
07FE8:  CLRF   x2E
07FEA:  CLRF   x2F
07FEC:  CLRF   x30
07FEE:  CLRF   x31
07FF0:  CLRF   x32
07FF2:  CLRF   x33
07FF4:  CLRF   x34
07FF6:  CLRF   x35
07FF8:  CLRF   x36
07FFA:  CLRF   x37
07FFC:  CLRF   x38
07FFE:  CLRF   x39
08000:  CLRF   x3A
08002:  CLRF   x3B
08004:  CLRF   x3C
08006:  CLRF   x3D
08008:  CLRF   x3E
0800A:  CLRF   x3F
0800C:  CLRF   x40
0800E:  CLRF   x41
08010:  CLRF   x42
08012:  CLRF   x43
08014:  CLRF   x44
08016:  CLRF   x45
08018:  CLRF   x46
0801A:  CLRF   x47
0801C:  CLRF   x48
0801E:  CLRF   x49
08020:  CLRF   x4A
08022:  CLRF   x4B
08024:  CLRF   x4C
08026:  CLRF   x4D
08028:  CLRF   x4E
0802A:  CLRF   x4F
0802C:  CLRF   x50
0802E:  CLRF   x51
08030:  CLRF   x52
08032:  CLRF   x53
08034:  CLRF   x54
08036:  CLRF   x55
08038:  CLRF   x56
0803A:  CLRF   x57
0803C:  CLRF   x58
0803E:  CLRF   x59
08040:  CLRF   x5A
08042:  CLRF   x5B
08044:  CLRF   x5C
08046:  CLRF   x5D
08048:  CLRF   x5E
0804A:  CLRF   x5F
0804C:  CLRF   x60
0804E:  CLRF   x61
08050:  CLRF   x62
08052:  CLRF   x63
08054:  CLRF   x64
08056:  CLRF   x65
08058:  CLRF   x66
0805A:  CLRF   x67
0805C:  CLRF   x68
0805E:  CLRF   x69
08060:  CLRF   x6A
08062:  CLRF   x6B
08064:  CLRF   x6C
08066:  CLRF   x6D
08068:  CLRF   x6E
0806A:  CLRF   x6F
0806C:  CLRF   x70
0806E:  CLRF   x71
08070:  CLRF   x72
08072:  CLRF   x73
08074:  CLRF   x74
08076:  CLRF   x75
08078:  CLRF   x76
0807A:  CLRF   x77
0807C:  CLRF   x78
0807E:  CLRF   x79
08080:  CLRF   x7A
08082:  CLRF   x7B
08084:  CLRF   x7C
08086:  CLRF   x7D
08088:  CLRF   x7E
0808A:  CLRF   x7F
0808C:  CLRF   x80
0808E:  CLRF   x81
08090:  CLRF   x82
08092:  CLRF   x83
08094:  CLRF   x84
08096:  CLRF   x85
08098:  CLRF   x86
0809A:  CLRF   x87
0809C:  CLRF   x88
0809E:  CLRF   x89
080A0:  CLRF   x8A
080A2:  CLRF   x8B
080A4:  CLRF   x8C
080A6:  CLRF   x8D
080A8:  CLRF   x8E
080AA:  CLRF   x8F
080AC:  CLRF   x90
080AE:  CLRF   x91
080B0:  CLRF   x92
080B2:  CLRF   x93
080B4:  CLRF   x94
080B6:  CLRF   x95
080B8:  CLRF   x96
080BA:  CLRF   x97
080BC:  CLRF   x98
080BE:  CLRF   x99
080C0:  CLRF   x9A
080C2:  CLRF   x9B
080C4:  CLRF   x9C
080C6:  CLRF   x9D
080C8:  CLRF   x9E
080CA:  CLRF   x9F
080CC:  CLRF   xA0
080CE:  CLRF   xA1
080D0:  CLRF   xA2
080D2:  CLRF   xA3
080D4:  CLRF   xA4
080D6:  CLRF   xA5
080D8:  CLRF   xA6
080DA:  CLRF   xA7
080DC:  CLRF   xA8
080DE:  CLRF   xA9
080E0:  CLRF   xAA
080E2:  CLRF   xAB
080E4:  CLRF   xAC
080E6:  CLRF   xAD
080E8:  CLRF   xAE
080EA:  CLRF   xAF
080EC:  CLRF   xB0
080EE:  CLRF   xB1
080F0:  CLRF   xB2
080F2:  CLRF   xB3
080F4:  CLRF   xB4
080F6:  CLRF   xB5
080F8:  CLRF   xB6
....................     port2.port_num = 2;
080FA:  MOVLW  02
080FC:  MOVLB  5
080FE:  MOVWF  xB7
....................     port2.sweep_step = 0;
08100:  CLRF   xB9
08102:  CLRF   xB8
....................     port2.active = 1;
08104:  MOVLB  9
08106:  BSF    xB6.0
.................... 
....................     int16 count = 1;
08108:  CLRF   xB8
0810A:  MOVLW  01
0810C:  MOVWF  xB7
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
0810E:  CLRF   xC9
08110:  MOVLW  01
08112:  MOVWF  xC8
08114:  MOVLB  0
08116:  CALL   210E
....................     mcp4901_2_write(1);
0811A:  MOVLB  9
0811C:  CLRF   xC9
0811E:  MOVLW  01
08120:  MOVWF  xC8
08122:  MOVLB  0
08124:  CALL   2150
....................     ad7490_read(ADC_CIGS1_CURR);
08128:  MOVLW  01
0812A:  MOVLB  9
0812C:  MOVWF  xDD
0812E:  MOVLB  0
08130:  CALL   1DB0
....................     ad7490_read(ADC_CIGS1_CURR);
08134:  MOVLW  01
08136:  MOVLB  9
08138:  MOVWF  xDD
0813A:  MOVLB  0
0813C:  CALL   1DB0
....................     ad7490_read(ADC_CIGS2_CURR);
08140:  MOVLW  05
08142:  MOVLB  9
08144:  MOVWF  xDD
08146:  MOVLB  0
08148:  CALL   1DB0
....................     ad7490_read(ADC_CIGS2_CURR);
0814C:  MOVLW  05
0814E:  MOVLB  9
08150:  MOVWF  xDD
08152:  MOVLB  0
08154:  CALL   1DB0
....................     delay_ms(200);
08158:  MOVLW  C8
0815A:  MOVLB  A
0815C:  MOVWF  x74
0815E:  MOVLB  0
08160:  CALL   1B40
.................... 
....................     // Read initial PD value
....................     MEASUREMENT_DATA measured_data = create_meas_data();
08164:  GOTO   6884
08168:  MOVFF  02,03
0816C:  MOVF   01,W
0816E:  MOVWF  FE1
08170:  MOVFF  03,FE2
08174:  MOVLW  09
08176:  MOVWF  FEA
08178:  MOVLW  B9
0817A:  MOVWF  FE9
0817C:  MOVLW  0F
0817E:  MOVWF  01
08180:  MOVFF  FE6,FEE
08184:  DECFSZ 01,F
08186:  GOTO   8180
....................     // Continue measurement while at least one port is active
....................     while (port1.active || port2.active)
0818A:  MOVLB  5
0818C:  BTFSS  xB6.0
0818E:  BRA    8196
08190:  MOVLB  0
08192:  GOTO   81A6
08196:  MOVLB  0
08198:  MOVLB  9
0819A:  BTFSC  xB6.0
0819C:  BRA    81A4
0819E:  MOVLB  0
081A0:  GOTO   862E
081A4:  MOVLB  0
....................     {
....................         // Set DAC values for both ports (synchronized timing)
....................         mcp4901_1_write(count);
081A6:  MOVFF  9B8,9C9
081AA:  MOVFF  9B7,9C8
081AE:  CALL   210E
....................         mcp4901_2_write(count);
081B2:  MOVFF  9B8,9C9
081B6:  MOVFF  9B7,9C8
081BA:  CALL   2150
....................         delay_ms(10); // wait for DAC to stabilize
081BE:  MOVLW  0A
081C0:  MOVLB  A
081C2:  MOVWF  x74
081C4:  MOVLB  0
081C6:  CALL   1B40
.................... 
....................         // Read CIGS1 data (port1) only if still active
....................         if (port1.active) {
081CA:  MOVLB  5
081CC:  BTFSC  xB6.0
081CE:  BRA    81D6
081D0:  MOVLB  0
081D2:  GOTO   8262
081D6:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
081D8:  BCF    FD8.0
081DA:  MOVLB  9
081DC:  RLCF   xB7,W
081DE:  MOVWF  02
081E0:  RLCF   xB8,W
081E2:  MOVWF  03
081E4:  MOVF   02,W
081E6:  ADDLW  BA
081E8:  MOVWF  01
081EA:  MOVLW  01
081EC:  ADDWFC 03,F
081EE:  MOVF   01,W
081F0:  MOVWF  xC8
081F2:  MOVFF  03,9C9
081F6:  MOVLW  02
081F8:  MOVWF  xDD
081FA:  MOVLB  0
081FC:  CALL   1DB0
08200:  MOVFF  9C9,FEA
08204:  MOVFF  9C8,FE9
08208:  MOVFF  02,FEC
0820C:  MOVF   FED,F
0820E:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
08212:  BCF    FD8.0
08214:  MOVLB  9
08216:  RLCF   xB7,W
08218:  MOVWF  02
0821A:  RLCF   xB8,W
0821C:  MOVWF  03
0821E:  MOVF   02,W
08220:  ADDLW  B8
08222:  MOVWF  01
08224:  MOVLW  03
08226:  ADDWFC 03,F
08228:  MOVF   01,W
0822A:  MOVWF  xC8
0822C:  MOVFF  03,9C9
08230:  MOVLW  01
08232:  MOVWF  xDD
08234:  MOVLB  0
08236:  CALL   1DB0
0823A:  MOVFF  9C9,FEA
0823E:  MOVFF  9C8,FE9
08242:  MOVFF  02,FEC
08246:  MOVF   FED,F
08248:  MOVFF  01,FEF
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
0824C:  MOVLW  01
0824E:  MOVLB  9
08250:  ADDWF  xB7,W
08252:  MOVLB  1
08254:  MOVWF  xB8
08256:  MOVLW  00
08258:  MOVLB  9
0825A:  ADDWFC xB8,W
0825C:  MOVLB  1
0825E:  MOVWF  xB9
08260:  MOVLB  0
....................         }
....................         
....................         // Read CIGS2 data (port2) only if still active
....................         if (port2.active) {
08262:  MOVLB  9
08264:  BTFSC  xB6.0
08266:  BRA    826E
08268:  MOVLB  0
0826A:  GOTO   83C2
0826E:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
08270:  BCF    FD8.0
08272:  MOVLB  9
08274:  RLCF   xB7,W
08276:  MOVWF  02
08278:  RLCF   xB8,W
0827A:  MOVWF  03
0827C:  MOVF   02,W
0827E:  ADDLW  BA
08280:  MOVWF  01
08282:  MOVLW  05
08284:  ADDWFC 03,F
08286:  MOVF   01,W
08288:  MOVWF  xC8
0828A:  MOVFF  03,9C9
0828E:  MOVLW  06
08290:  MOVWF  xDD
08292:  MOVLB  0
08294:  CALL   1DB0
08298:  MOVFF  9C9,FEA
0829C:  MOVFF  9C8,FE9
082A0:  MOVFF  02,FEC
082A4:  MOVF   FED,F
082A6:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
082AA:  BCF    FD8.0
082AC:  MOVLB  9
082AE:  RLCF   xB7,W
082B0:  MOVWF  02
082B2:  RLCF   xB8,W
082B4:  MOVWF  03
082B6:  MOVF   02,W
082B8:  ADDLW  B8
082BA:  MOVWF  01
082BC:  MOVLW  07
082BE:  ADDWFC 03,F
082C0:  MOVF   01,W
082C2:  MOVWF  xC8
082C4:  MOVFF  03,9C9
082C8:  MOVLW  05
082CA:  MOVWF  xDD
082CC:  MOVLB  0
082CE:  CALL   1DB0
082D2:  MOVFF  9C9,FEA
082D6:  MOVFF  9C8,FE9
082DA:  MOVFF  02,FEC
082DE:  MOVF   FED,F
082E0:  MOVFF  01,FEF
....................             fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
082E4:  BCF    FD8.0
082E6:  MOVLB  9
082E8:  RLCF   xB7,W
082EA:  MOVWF  02
082EC:  RLCF   xB8,W
082EE:  MOVWF  03
082F0:  MOVF   02,W
082F2:  ADDLW  BA
082F4:  MOVWF  FE9
082F6:  MOVLW  05
082F8:  ADDWFC 03,W
082FA:  MOVWF  FEA
082FC:  MOVFF  FEC,9C9
08300:  MOVF   FED,F
08302:  MOVFF  FEF,9C8
08306:  BCF    FD8.0
08308:  RLCF   xB7,W
0830A:  MOVWF  02
0830C:  RLCF   xB8,W
0830E:  MOVWF  03
08310:  MOVF   02,W
08312:  ADDLW  B8
08314:  MOVWF  FE9
08316:  MOVLW  07
08318:  ADDWFC 03,W
0831A:  MOVWF  FEA
0831C:  MOVFF  FEC,9CB
08320:  MOVF   FED,F
08322:  MOVFF  FEF,9CA
08326:  MOVLW  44
08328:  MOVWF  FF6
0832A:  MOVLW  06
0832C:  MOVWF  FF7
0832E:  MOVLW  00
08330:  MOVWF  FF8
08332:  MOVLW  0C
08334:  MOVWF  xCC
08336:  MOVLB  0
08338:  CALL   1BF0
0833C:  MOVFF  9C9,9CC
08340:  MOVLW  37
08342:  MOVLB  9
08344:  MOVWF  xCD
08346:  MOVLB  0
08348:  CALL   1E44
0834C:  MOVFF  9C8,9CC
08350:  MOVLW  37
08352:  MOVLB  9
08354:  MOVWF  xCD
08356:  MOVLB  0
08358:  CALL   1E44
0835C:  MOVLW  2C
0835E:  MOVLB  A
08360:  MOVWF  xB3
08362:  MOVLB  0
08364:  CALL   1B6E
08368:  MOVLW  20
0836A:  MOVLB  A
0836C:  MOVWF  xB3
0836E:  MOVLB  0
08370:  CALL   1B6E
08374:  MOVFF  9CB,9CC
08378:  MOVLW  37
0837A:  MOVLB  9
0837C:  MOVWF  xCD
0837E:  MOVLB  0
08380:  CALL   1E44
08384:  MOVFF  9CA,9CC
08388:  MOVLW  37
0838A:  MOVLB  9
0838C:  MOVWF  xCD
0838E:  MOVLB  0
08390:  CALL   1E44
08394:  MOVLW  0D
08396:  MOVLB  A
08398:  MOVWF  xB3
0839A:  MOVLB  0
0839C:  CALL   1B6E
083A0:  MOVLW  0A
083A2:  MOVLB  A
083A4:  MOVWF  xB3
083A6:  MOVLB  0
083A8:  CALL   1B6E
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
083AC:  MOVLW  01
083AE:  MOVLB  9
083B0:  ADDWF  xB7,W
083B2:  MOVLB  5
083B4:  MOVWF  xB8
083B6:  MOVLW  00
083B8:  MOVLB  9
083BA:  ADDWFC xB8,W
083BC:  MOVLB  5
083BE:  MOVWF  xB9
083C0:  MOVLB  0
....................         }
.................... 
....................         count++;
083C2:  MOVLB  9
083C4:  INCF   xB7,F
083C6:  BTFSC  FD8.2
083C8:  INCF   xB8,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
083CA:  MOVF   xB8,F
083CC:  BTFSC  FD8.2
083CE:  BRA    83D6
083D0:  MOVLB  0
083D2:  GOTO   83EA
083D6:  MOVLB  0
083D8:  MOVLB  9
083DA:  MOVF   xB7,W
083DC:  SUBLW  FE
083DE:  BTFSS  FD8.0
083E0:  BRA    83E8
083E2:  MOVLB  0
083E4:  GOTO   842E
083E8:  MOVLB  0
....................             fprintf(PC, "Maximum step count reached: %ld\r\n", count);
083EA:  MOVLW  60
083EC:  MOVWF  FF6
083EE:  MOVLW  06
083F0:  MOVWF  FF7
083F2:  MOVLW  00
083F4:  MOVWF  FF8
083F6:  MOVLW  1C
083F8:  MOVLB  9
083FA:  MOVWF  xCC
083FC:  MOVLB  0
083FE:  CALL   1BF0
08402:  MOVLW  10
08404:  MOVWF  FE9
08406:  MOVFF  9B8,9C9
0840A:  MOVFF  9B7,9C8
0840E:  GOTO   690E
08412:  MOVLW  0D
08414:  MOVLB  A
08416:  MOVWF  xB3
08418:  MOVLB  0
0841A:  CALL   1B6E
0841E:  MOVLW  0A
08420:  MOVLB  A
08422:  MOVWF  xB3
08424:  MOVLB  0
08426:  CALL   1B6E
....................             break;
0842A:  GOTO   862E
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
0842E:  MOVLB  5
08430:  BTFSC  xB6.0
08432:  BRA    843A
08434:  MOVLB  0
08436:  GOTO   852C
0843A:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
0843C:  MOVLW  01
0843E:  MOVLB  9
08440:  SUBWF  xB7,W
08442:  MOVWF  xC8
08444:  MOVLW  00
08446:  SUBWFB xB8,W
08448:  MOVWF  xC9
0844A:  BCF    FD8.0
0844C:  RLCF   xC8,W
0844E:  MOVWF  02
08450:  RLCF   xC9,W
08452:  MOVWF  03
08454:  MOVF   02,W
08456:  ADDLW  B8
08458:  MOVWF  FE9
0845A:  MOVLW  03
0845C:  ADDWFC 03,W
0845E:  MOVWF  FEA
08460:  MOVFF  FEC,9C9
08464:  MOVF   FED,F
08466:  MOVFF  FEF,9C8
0846A:  MOVF   xC9,W
0846C:  MOVLB  1
0846E:  SUBWF  xB6,W
08470:  BTFSC  FD8.0
08472:  BRA    847A
08474:  MOVLB  0
08476:  GOTO   84B6
0847A:  MOVLB  0
0847C:  BTFSS  FD8.2
0847E:  GOTO   8496
08482:  MOVLB  1
08484:  MOVF   xB5,W
08486:  MOVLB  9
08488:  SUBWF  xC8,W
0848A:  BTFSS  FD8.0
0848C:  BRA    8494
0848E:  MOVLB  0
08490:  GOTO   84B6
08494:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current limit reached:");
08496:  MOVLW  82
08498:  MOVWF  FF6
0849A:  MOVLW  06
0849C:  MOVWF  FF7
0849E:  MOVLW  00
084A0:  MOVWF  FF8
084A2:  CALL   1BC0
....................                 port1.active = 0;
084A6:  MOVLB  5
084A8:  BCF    xB6.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
084AA:  MOVLW  5E
084AC:  MOVWF  F94
084AE:  BCF    F8B.0
084B0:  MOVLB  0
....................             }
084B2:  GOTO   852C
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
084B6:  MOVLW  01
084B8:  MOVLB  9
084BA:  SUBWF  xB7,W
084BC:  MOVWF  xC8
084BE:  MOVLW  00
084C0:  SUBWFB xB8,W
084C2:  MOVWF  xC9
084C4:  BCF    FD8.0
084C6:  RLCF   xC8,W
084C8:  MOVWF  02
084CA:  RLCF   xC9,W
084CC:  MOVWF  03
084CE:  MOVF   02,W
084D0:  ADDLW  B8
084D2:  MOVWF  FE9
084D4:  MOVLW  03
084D6:  ADDWFC 03,W
084D8:  MOVWF  FEA
084DA:  MOVFF  FEC,9C9
084DE:  MOVF   FED,F
084E0:  MOVFF  FEF,9C8
084E4:  MOVF   xC9,W
084E6:  MOVLB  1
084E8:  SUBWF  xB2,W
084EA:  BTFSC  FD8.0
084EC:  BRA    84F4
084EE:  MOVLB  0
084F0:  GOTO   852C
084F4:  MOVLB  0
084F6:  BTFSS  FD8.2
084F8:  GOTO   8510
084FC:  MOVLB  1
084FE:  MOVF   xB1,W
08500:  MOVLB  9
08502:  SUBWF  xC8,W
08504:  BTFSS  FD8.0
08506:  BRA    850E
08508:  MOVLB  0
0850A:  GOTO   852C
0850E:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current below threshold");
08510:  MOVLW  A0
08512:  MOVWF  FF6
08514:  MOVLW  06
08516:  MOVWF  FF7
08518:  MOVLW  00
0851A:  MOVWF  FF8
0851C:  CALL   1BC0
....................                 port1.active = 0;
08520:  MOVLB  5
08522:  BCF    xB6.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
08524:  MOVLW  5E
08526:  MOVWF  F94
08528:  BCF    F8B.0
0852A:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
0852C:  MOVLB  9
0852E:  BTFSC  xB6.0
08530:  BRA    8538
08532:  MOVLB  0
08534:  GOTO   862A
08538:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
0853A:  MOVLW  01
0853C:  MOVLB  9
0853E:  SUBWF  xB7,W
08540:  MOVWF  xC8
08542:  MOVLW  00
08544:  SUBWFB xB8,W
08546:  MOVWF  xC9
08548:  BCF    FD8.0
0854A:  RLCF   xC8,W
0854C:  MOVWF  02
0854E:  RLCF   xC9,W
08550:  MOVWF  03
08552:  MOVF   02,W
08554:  ADDLW  B8
08556:  MOVWF  FE9
08558:  MOVLW  07
0855A:  ADDWFC 03,W
0855C:  MOVWF  FEA
0855E:  MOVFF  FEC,9C9
08562:  MOVF   FED,F
08564:  MOVFF  FEF,9C8
08568:  MOVF   xC9,W
0856A:  MOVLB  1
0856C:  SUBWF  xB6,W
0856E:  BTFSC  FD8.0
08570:  BRA    8578
08572:  MOVLB  0
08574:  GOTO   85B4
08578:  MOVLB  0
0857A:  BTFSS  FD8.2
0857C:  GOTO   8594
08580:  MOVLB  1
08582:  MOVF   xB5,W
08584:  MOVLB  9
08586:  SUBWF  xC8,W
08588:  BTFSS  FD8.0
0858A:  BRA    8592
0858C:  MOVLB  0
0858E:  GOTO   85B4
08592:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current limit reached: ");
08594:  MOVLW  BE
08596:  MOVWF  FF6
08598:  MOVLW  06
0859A:  MOVWF  FF7
0859C:  MOVLW  00
0859E:  MOVWF  FF8
085A0:  CALL   1BC0
....................                 port2.active = 0;
085A4:  MOVLB  9
085A6:  BCF    xB6.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
085A8:  MOVLW  5E
085AA:  MOVWF  F94
085AC:  BCF    F8B.5
085AE:  MOVLB  0
....................             }
085B0:  GOTO   862A
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
085B4:  MOVLW  01
085B6:  MOVLB  9
085B8:  SUBWF  xB7,W
085BA:  MOVWF  xC8
085BC:  MOVLW  00
085BE:  SUBWFB xB8,W
085C0:  MOVWF  xC9
085C2:  BCF    FD8.0
085C4:  RLCF   xC8,W
085C6:  MOVWF  02
085C8:  RLCF   xC9,W
085CA:  MOVWF  03
085CC:  MOVF   02,W
085CE:  ADDLW  B8
085D0:  MOVWF  FE9
085D2:  MOVLW  07
085D4:  ADDWFC 03,W
085D6:  MOVWF  FEA
085D8:  MOVFF  FEC,9C9
085DC:  MOVF   FED,F
085DE:  MOVFF  FEF,9C8
085E2:  MOVF   xC9,W
085E4:  MOVLB  1
085E6:  SUBWF  xB2,W
085E8:  BTFSC  FD8.0
085EA:  BRA    85F2
085EC:  MOVLB  0
085EE:  GOTO   862A
085F2:  MOVLB  0
085F4:  BTFSS  FD8.2
085F6:  GOTO   860E
085FA:  MOVLB  1
085FC:  MOVF   xB1,W
085FE:  MOVLB  9
08600:  SUBWF  xC8,W
08602:  BTFSS  FD8.0
08604:  BRA    860C
08606:  MOVLB  0
08608:  GOTO   862A
0860C:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current below threshold:");
0860E:  MOVLW  DC
08610:  MOVWF  FF6
08612:  MOVLW  06
08614:  MOVWF  FF7
08616:  MOVLW  00
08618:  MOVWF  FF8
0861A:  CALL   1BC0
....................                 port2.active = 0;
0861E:  MOVLB  9
08620:  BCF    xB6.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08622:  MOVLW  5E
08624:  MOVWF  F94
08626:  BCF    F8B.5
08628:  MOVLB  0
....................             }
....................         }
0862A:  GOTO   818A
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
0862E:  MOVLW  5E
08630:  MOVWF  F94
08632:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
08634:  MOVLW  5E
08636:  MOVWF  F94
08638:  BCF    F8B.5
....................     // output_high(EN_NPWR);
.................... 
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
0863A:  MOVLW  09
0863C:  MOVLB  9
0863E:  MOVWF  xC9
08640:  MOVLW  B9
08642:  MOVWF  xC8
08644:  MOVLW  01
08646:  MOVWF  xCB
08648:  MOVLW  B7
0864A:  MOVWF  xCA
0864C:  MOVLB  0
0864E:  CALL   6A98
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
08652:  MOVLW  09
08654:  MOVLB  9
08656:  MOVWF  xC9
08658:  MOVLW  B9
0865A:  MOVWF  xC8
0865C:  MOVLW  05
0865E:  MOVWF  xCB
08660:  MOVLW  B7
08662:  MOVWF  xCA
08664:  MOVLB  0
08666:  CALL   6A98
.................... 
....................     fprintf(PC, "End SWEEP with threshold\r\n");
0866A:  MOVLW  FC
0866C:  MOVWF  FF6
0866E:  MOVLW  06
08670:  MOVWF  FF7
08672:  MOVLW  00
08674:  MOVWF  FF8
08676:  CALL   1BC0
0867A:  GOTO   8C20 (RETURN)
.................... }
.................... 
.................... 
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data)
*
06B1C:  CLRF   x0C
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
*
06A98:  MOVLB  9
06A9A:  CLRF   xCC
06A9C:  CLRF   xCD
06A9E:  CLRF   xCE
06AA0:  CLRF   xCF
06AA2:  CLRF   xD0
06AA4:  CLRF   xD1
06AA6:  CLRF   xD2
06AA8:  CLRF   xD3
06AAA:  CLRF   xD4
06AAC:  CLRF   xD5
06AAE:  CLRF   xD6
06AB0:  CLRF   xD7
06AB2:  CLRF   xD8
06AB4:  CLRF   xD9
06AB6:  CLRF   xDA
06AB8:  CLRF   xDB
06ABA:  CLRF   xDC
06ABC:  CLRF   xDD
06ABE:  CLRF   xDE
06AC0:  CLRF   xDF
06AC2:  CLRF   xE0
06AC4:  CLRF   xE1
06AC6:  CLRF   xE2
06AC8:  CLRF   xE3
06ACA:  CLRF   xE4
06ACC:  CLRF   xE5
06ACE:  CLRF   xE6
06AD0:  CLRF   xE7
06AD2:  CLRF   xE8
06AD4:  CLRF   xE9
06AD6:  CLRF   xEA
06AD8:  CLRF   xEB
06ADA:  CLRF   xEC
06ADC:  CLRF   xED
06ADE:  CLRF   xEE
06AE0:  CLRF   xEF
06AE2:  CLRF   xF0
06AE4:  CLRF   xF1
06AE6:  CLRF   xF2
06AE8:  CLRF   xF3
06AEA:  CLRF   xF4
06AEC:  CLRF   xF5
06AEE:  CLRF   xF6
06AF0:  CLRF   xF7
06AF2:  CLRF   xF8
06AF4:  CLRF   xF9
06AF6:  CLRF   xFA
06AF8:  CLRF   xFB
06AFA:  CLRF   xFC
06AFC:  CLRF   xFD
06AFE:  CLRF   xFE
06B00:  CLRF   xFF
06B02:  MOVLB  A
06B04:  CLRF   x00
06B06:  CLRF   x01
06B08:  CLRF   x02
06B0A:  CLRF   x03
06B0C:  CLRF   x04
06B0E:  CLRF   x05
06B10:  CLRF   x06
06B12:  CLRF   x07
06B14:  CLRF   x08
06B16:  CLRF   x09
06B18:  CLRF   x0A
06B1A:  CLRF   x0B
....................     unsigned int8 packetdata_index = 0; // Index for packet data
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
06B1E:  MOVLB  9
06B20:  SETF   xCC
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data->port_num & 0x0F);
06B22:  MOVF   xCA,W
06B24:  MOVWF  FE9
06B26:  MOVF   xCB,W
06B28:  MOVWF  FEA
06B2A:  MOVF   FEF,W
06B2C:  ANDLW  0F
06B2E:  IORLW  F0
06B30:  MOVWF  xCD
....................     packetdata[2] = measured_data->time_sec >> 24 & 0xFF;
06B32:  MOVF   xC8,W
06B34:  MOVWF  FE9
06B36:  MOVF   xC9,W
06B38:  MOVWF  FEA
06B3A:  MOVFF  FEF,A1C
06B3E:  MOVFF  FEC,A1D
06B42:  MOVFF  FEC,A1E
06B46:  MOVFF  FEC,A1F
06B4A:  MOVF   FED,F
06B4C:  MOVF   FED,F
06B4E:  MOVF   FED,F
06B50:  MOVFF  A1F,A1C
06B54:  MOVLB  A
06B56:  CLRF   x1D
06B58:  CLRF   x1E
06B5A:  CLRF   x1F
06B5C:  MOVF   x1C,W
06B5E:  MOVLB  9
06B60:  MOVWF  xCE
....................     packetdata[3] = measured_data->time_sec >> 16 & 0xFF;
06B62:  MOVF   xC8,W
06B64:  MOVWF  FE9
06B66:  MOVF   xC9,W
06B68:  MOVWF  FEA
06B6A:  MOVFF  FEF,A1C
06B6E:  MOVFF  FEC,A1D
06B72:  MOVFF  FEC,A1E
06B76:  MOVFF  FEC,A1F
06B7A:  MOVF   FED,F
06B7C:  MOVF   FED,F
06B7E:  MOVF   FED,F
06B80:  MOVFF  A1E,A1C
06B84:  MOVFF  A1F,A1D
06B88:  MOVLB  A
06B8A:  CLRF   x1E
06B8C:  CLRF   x1F
06B8E:  MOVF   x1C,W
06B90:  MOVLB  9
06B92:  MOVWF  xCF
....................     packetdata[4] = measured_data->time_sec >> 8 & 0xFF;
06B94:  MOVF   xC8,W
06B96:  MOVWF  FE9
06B98:  MOVF   xC9,W
06B9A:  MOVWF  FEA
06B9C:  MOVFF  FEF,A1C
06BA0:  MOVFF  FEC,A1D
06BA4:  MOVFF  FEC,A1E
06BA8:  MOVFF  FEC,A1F
06BAC:  MOVF   FED,F
06BAE:  MOVF   FED,F
06BB0:  MOVF   FED,F
06BB2:  MOVFF  A1D,A1C
06BB6:  MOVFF  A1E,A1D
06BBA:  MOVFF  A1F,A1E
06BBE:  MOVLB  A
06BC0:  CLRF   x1F
06BC2:  MOVF   x1C,W
06BC4:  MOVLB  9
06BC6:  MOVWF  xD0
....................     packetdata[5] = measured_data->time_sec & 0xFF;
06BC8:  MOVF   xC8,W
06BCA:  MOVWF  FE9
06BCC:  MOVF   xC9,W
06BCE:  MOVWF  FEA
06BD0:  MOVFF  FEF,A1C
06BD4:  MOVFF  FEC,A1D
06BD8:  MOVFF  FEC,A1E
06BDC:  MOVFF  FEC,A1F
06BE0:  MOVF   FED,F
06BE2:  MOVF   FED,F
06BE4:  MOVF   FED,F
06BE6:  MOVLB  A
06BE8:  MOVF   x1C,W
06BEA:  MOVLB  9
06BEC:  MOVWF  xD1
....................     packetdata[6] = (measured_data->time_msec & 0x0F) >>4 | measured_data->pd >> 8 & 0x0F;
06BEE:  MOVLW  04
06BF0:  ADDWF  xC8,W
06BF2:  MOVWF  FE9
06BF4:  MOVLW  00
06BF6:  ADDWFC xC9,W
06BF8:  MOVWF  FEA
06BFA:  MOVF   FEF,W
06BFC:  ANDLW  0F
06BFE:  MOVWF  00
06C00:  SWAPF  00,W
06C02:  MOVLB  A
06C04:  MOVWF  x1C
06C06:  MOVLW  0F
06C08:  ANDWF  x1C,F
06C0A:  MOVLW  0D
06C0C:  MOVLB  9
06C0E:  ADDWF  xC8,W
06C10:  MOVWF  FE9
06C12:  MOVLW  00
06C14:  ADDWFC xC9,W
06C16:  MOVWF  FEA
06C18:  MOVFF  FEC,A1E
06C1C:  MOVF   FED,F
06C1E:  MOVFF  FEF,A1D
06C22:  MOVFF  A1E,A1D
06C26:  MOVLB  A
06C28:  CLRF   x1E
06C2A:  MOVF   x1D,W
06C2C:  ANDLW  0F
06C2E:  MOVWF  00
06C30:  CLRF   03
06C32:  MOVF   00,W
06C34:  IORWF  x1C,W
06C36:  MOVLB  9
06C38:  MOVWF  xD2
....................     packetdata[7] = measured_data->pd & 0xFF;
06C3A:  MOVLW  0D
06C3C:  ADDWF  xC8,W
06C3E:  MOVWF  FE9
06C40:  MOVLW  00
06C42:  ADDWFC xC9,W
06C44:  MOVWF  FEA
06C46:  MOVFF  FEC,A1D
06C4A:  MOVF   FED,F
06C4C:  MOVFF  FEF,A1C
06C50:  MOVLB  A
06C52:  MOVF   x1C,W
06C54:  MOVLB  9
06C56:  MOVWF  xD3
....................     packetdata[8] = (measured_data->open_voltage >> 4) & 0xFF; // PD start low byte
06C58:  MOVLW  05
06C5A:  ADDWF  xC8,W
06C5C:  MOVWF  FE9
06C5E:  MOVLW  00
06C60:  ADDWFC xC9,W
06C62:  MOVWF  FEA
06C64:  MOVFF  FEC,A1D
06C68:  MOVF   FED,F
06C6A:  MOVFF  FEF,A1C
06C6E:  MOVLB  A
06C70:  RRCF   x1D,F
06C72:  RRCF   x1C,F
06C74:  RRCF   x1D,F
06C76:  RRCF   x1C,F
06C78:  RRCF   x1D,F
06C7A:  RRCF   x1C,F
06C7C:  RRCF   x1D,F
06C7E:  RRCF   x1C,F
06C80:  MOVLW  0F
06C82:  ANDWF  x1D,F
06C84:  MOVF   x1C,W
06C86:  MOVLB  9
06C88:  MOVWF  xD4
....................     packetdata[9] = (measured_data->open_voltage & 0x0F) << 4 | (measured_data->temp_py_top >> 8) & 0x0F;
06C8A:  MOVLW  05
06C8C:  ADDWF  xC8,W
06C8E:  MOVWF  FE9
06C90:  MOVLW  00
06C92:  ADDWFC xC9,W
06C94:  MOVWF  FEA
06C96:  MOVFF  FEC,A1D
06C9A:  MOVF   FED,F
06C9C:  MOVFF  FEF,A1C
06CA0:  MOVLW  0F
06CA2:  MOVLB  A
06CA4:  ANDWF  x1C,F
06CA6:  CLRF   x1D
06CA8:  RLCF   x1C,F
06CAA:  RLCF   x1D,F
06CAC:  RLCF   x1C,F
06CAE:  RLCF   x1D,F
06CB0:  RLCF   x1C,F
06CB2:  RLCF   x1D,F
06CB4:  RLCF   x1C,F
06CB6:  RLCF   x1D,F
06CB8:  MOVLW  F0
06CBA:  ANDWF  x1C,F
06CBC:  MOVLW  07
06CBE:  MOVLB  9
06CC0:  ADDWF  xC8,W
06CC2:  MOVWF  FE9
06CC4:  MOVLW  00
06CC6:  ADDWFC xC9,W
06CC8:  MOVWF  FEA
06CCA:  MOVFF  FEC,A1F
06CCE:  MOVF   FED,F
06CD0:  MOVFF  FEF,A1E
06CD4:  MOVFF  A1F,A1E
06CD8:  MOVLB  A
06CDA:  CLRF   x1F
06CDC:  MOVF   x1E,W
06CDE:  ANDLW  0F
06CE0:  MOVWF  00
06CE2:  CLRF   03
06CE4:  MOVF   00,W
06CE6:  IORWF  x1C,W
06CE8:  MOVLB  9
06CEA:  MOVWF  xD5
....................     packetdata[10] = measured_data->temp_py_top & 0xFF;
06CEC:  MOVLW  07
06CEE:  ADDWF  xC8,W
06CF0:  MOVWF  FE9
06CF2:  MOVLW  00
06CF4:  ADDWFC xC9,W
06CF6:  MOVWF  FEA
06CF8:  MOVFF  FEC,A1D
06CFC:  MOVF   FED,F
06CFE:  MOVFF  FEF,A1C
06D02:  MOVLB  A
06D04:  MOVF   x1C,W
06D06:  MOVLB  9
06D08:  MOVWF  xD6
....................     packetdata[11] = (measured_data->temp_py_bot >> 4) & 0xFF; // PD start low byte
06D0A:  MOVLW  09
06D0C:  ADDWF  xC8,W
06D0E:  MOVWF  FE9
06D10:  MOVLW  00
06D12:  ADDWFC xC9,W
06D14:  MOVWF  FEA
06D16:  MOVFF  FEC,A1D
06D1A:  MOVF   FED,F
06D1C:  MOVFF  FEF,A1C
06D20:  MOVLB  A
06D22:  RRCF   x1D,F
06D24:  RRCF   x1C,F
06D26:  RRCF   x1D,F
06D28:  RRCF   x1C,F
06D2A:  RRCF   x1D,F
06D2C:  RRCF   x1C,F
06D2E:  RRCF   x1D,F
06D30:  RRCF   x1C,F
06D32:  MOVLW  0F
06D34:  ANDWF  x1D,F
06D36:  MOVF   x1C,W
06D38:  MOVLB  9
06D3A:  MOVWF  xD7
....................     packetdata[12] = (measured_data->temp_py_bot & 0x0F) << 4 | (measured_data->temp_mis7 >> 8) & 0x0F;
06D3C:  MOVLW  09
06D3E:  ADDWF  xC8,W
06D40:  MOVWF  FE9
06D42:  MOVLW  00
06D44:  ADDWFC xC9,W
06D46:  MOVWF  FEA
06D48:  MOVFF  FEC,A1D
06D4C:  MOVF   FED,F
06D4E:  MOVFF  FEF,A1C
06D52:  MOVLW  0F
06D54:  MOVLB  A
06D56:  ANDWF  x1C,F
06D58:  CLRF   x1D
06D5A:  RLCF   x1C,F
06D5C:  RLCF   x1D,F
06D5E:  RLCF   x1C,F
06D60:  RLCF   x1D,F
06D62:  RLCF   x1C,F
06D64:  RLCF   x1D,F
06D66:  RLCF   x1C,F
06D68:  RLCF   x1D,F
06D6A:  MOVLW  F0
06D6C:  ANDWF  x1C,F
06D6E:  MOVLW  0B
06D70:  MOVLB  9
06D72:  ADDWF  xC8,W
06D74:  MOVWF  FE9
06D76:  MOVLW  00
06D78:  ADDWFC xC9,W
06D7A:  MOVWF  FEA
06D7C:  MOVFF  FEC,A1F
06D80:  MOVF   FED,F
06D82:  MOVFF  FEF,A1E
06D86:  MOVFF  A1F,A1E
06D8A:  MOVLB  A
06D8C:  CLRF   x1F
06D8E:  MOVF   x1E,W
06D90:  ANDLW  0F
06D92:  MOVWF  00
06D94:  CLRF   03
06D96:  MOVF   00,W
06D98:  IORWF  x1C,W
06D9A:  MOVLB  9
06D9C:  MOVWF  xD8
....................     packetdata[13] = measured_data->temp_mis7 & 0xFF;
06D9E:  MOVLW  0B
06DA0:  ADDWF  xC8,W
06DA2:  MOVWF  FE9
06DA4:  MOVLW  00
06DA6:  ADDWFC xC9,W
06DA8:  MOVWF  FEA
06DAA:  MOVFF  FEC,A1D
06DAE:  MOVF   FED,F
06DB0:  MOVFF  FEF,A1C
06DB4:  MOVLB  A
06DB6:  MOVF   x1C,W
06DB8:  MOVLB  9
06DBA:  MOVWF  xD9
.................... 
....................     packetdata_index = 14; // Start index for data
06DBC:  MOVLW  0E
06DBE:  MOVLB  A
06DC0:  MOVWF  x0C
.................... 
....................     for (unsigned int16 i = 0; i < port_data->sweep_step ; i++) {
06DC2:  CLRF   x0E
06DC4:  CLRF   x0D
06DC6:  MOVLB  0
06DC8:  MOVLW  01
06DCA:  MOVLB  9
06DCC:  ADDWF  xCA,W
06DCE:  MOVWF  FE9
06DD0:  MOVLW  00
06DD2:  ADDWFC xCB,W
06DD4:  MOVWF  FEA
06DD6:  MOVFF  FEC,03
06DDA:  MOVF   FED,F
06DDC:  MOVF   FEF,W
06DDE:  MOVWF  01
06DE0:  MOVLB  A
06DE2:  MOVF   x0E,W
06DE4:  SUBWF  03,W
06DE6:  BTFSC  FD8.0
06DE8:  BRA    6DF0
06DEA:  MOVLB  0
06DEC:  GOTO   6FCE
06DF0:  MOVLB  0
06DF2:  BTFSS  FD8.2
06DF4:  GOTO   6E0A
06DF8:  MOVF   01,W
06DFA:  MOVLB  A
06DFC:  SUBWF  x0D,W
06DFE:  BTFSS  FD8.0
06E00:  BRA    6E08
06E02:  MOVLB  0
06E04:  GOTO   6FCE
06E08:  MOVLB  0
....................         unsigned int16 data0 = port_data->data_buffer[0][i];
....................         unsigned int16 data1 = port_data->data_buffer[1][i];
06E0A:  BCF    FD8.0
06E0C:  MOVLB  A
06E0E:  RLCF   x0D,W
06E10:  MOVWF  02
06E12:  RLCF   x0E,W
06E14:  MOVWF  03
06E16:  MOVF   02,W
06E18:  ADDLW  03
06E1A:  MOVWF  01
06E1C:  MOVLW  00
06E1E:  ADDWFC 03,F
06E20:  MOVF   01,W
06E22:  MOVLB  9
06E24:  ADDWF  xCA,W
06E26:  MOVWF  FE9
06E28:  MOVF   xCB,W
06E2A:  ADDWFC 03,W
06E2C:  MOVWF  FEA
06E2E:  MOVFF  FEC,A10
06E32:  MOVF   FED,F
06E34:  MOVFF  FEF,A0F
06E38:  BCF    FD8.0
06E3A:  MOVLB  A
06E3C:  RLCF   x0D,W
06E3E:  MOVWF  02
06E40:  RLCF   x0E,W
06E42:  MOVWF  03
06E44:  MOVF   02,W
06E46:  ADDLW  01
06E48:  MOVWF  01
06E4A:  MOVLW  02
06E4C:  ADDWFC 03,F
06E4E:  MOVF   01,W
06E50:  MOVLB  9
06E52:  ADDWF  xCA,W
06E54:  MOVWF  FE9
06E56:  MOVF   xCB,W
06E58:  ADDWFC 03,W
06E5A:  MOVWF  FEA
06E5C:  MOVFF  FEC,A12
06E60:  MOVF   FED,F
06E62:  MOVFF  FEF,A11
06E66:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
06E68:  MOVLB  A
06E6A:  MOVF   x0C,W
06E6C:  INCF   x0C,F
06E6E:  CLRF   03
06E70:  ADDLW  CC
06E72:  MOVWF  FE9
06E74:  MOVLW  09
06E76:  ADDWFC 03,W
06E78:  MOVWF  FEA
06E7A:  RRCF   x10,W
06E7C:  MOVWF  x1F
06E7E:  RRCF   x0F,W
06E80:  MOVWF  x1E
06E82:  RRCF   x1F,F
06E84:  RRCF   x1E,F
06E86:  RRCF   x1F,F
06E88:  RRCF   x1E,F
06E8A:  RRCF   x1F,F
06E8C:  RRCF   x1E,F
06E8E:  MOVLW  0F
06E90:  ANDWF  x1F,F
06E92:  MOVF   x1E,W
06E94:  MOVWF  00
06E96:  CLRF   03
06E98:  MOVF   00,W
06E9A:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
06E9C:  MOVF   x0C,W
06E9E:  INCF   x0C,F
06EA0:  CLRF   03
06EA2:  ADDLW  CC
06EA4:  MOVWF  FE9
06EA6:  MOVLW  09
06EA8:  ADDWFC 03,W
06EAA:  MOVWF  FEA
06EAC:  MOVF   x0F,W
06EAE:  ANDLW  0F
06EB0:  MOVWF  x1E
06EB2:  CLRF   x1F
06EB4:  RLCF   x1E,F
06EB6:  RLCF   x1F,F
06EB8:  RLCF   x1E,F
06EBA:  RLCF   x1F,F
06EBC:  RLCF   x1E,F
06EBE:  RLCF   x1F,F
06EC0:  RLCF   x1E,F
06EC2:  RLCF   x1F,F
06EC4:  MOVLW  F0
06EC6:  ANDWF  x1E,F
06EC8:  MOVFF  A12,A20
06ECC:  CLRF   x21
06ECE:  MOVF   x20,W
06ED0:  ANDLW  0F
06ED2:  MOVWF  00
06ED4:  CLRF   03
06ED6:  MOVF   00,W
06ED8:  IORWF  x1E,W
06EDA:  MOVWF  00
06EDC:  MOVF   03,W
06EDE:  IORWF  x1F,W
06EE0:  MOVWF  03
06EE2:  MOVF   00,W
06EE4:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
06EE6:  MOVF   x0C,W
06EE8:  INCF   x0C,F
06EEA:  CLRF   03
06EEC:  ADDLW  CC
06EEE:  MOVWF  FE9
06EF0:  MOVLW  09
06EF2:  ADDWFC 03,W
06EF4:  MOVWF  FEA
06EF6:  MOVF   x11,W
06EF8:  MOVWF  00
06EFA:  CLRF   03
06EFC:  MOVF   00,W
06EFE:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
06F00:  MOVLW  03
06F02:  ADDWF  x0C,W
06F04:  SUBLW  3E
06F06:  BTFSS  FD8.0
06F08:  BRA    6F10
06F0A:  MOVLB  0
06F0C:  GOTO   6FC0
06F10:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
06F12:  MOVLW  09
06F14:  MOVLB  A
06F16:  MOVWF  xB4
06F18:  MOVLW  CC
06F1A:  MOVWF  xB3
06F1C:  MOVLW  3F
06F1E:  MOVWF  xB5
06F20:  MOVLB  0
06F22:  CALL   29E6
06F26:  MOVFF  01,A0B
....................             unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
06F2A:  MOVLB  1
06F2C:  MOVF   x40,W
06F2E:  MOVLB  A
06F30:  MOVWF  x13
06F32:  MOVLW  10
06F34:  MOVLB  1
06F36:  ADDWF  x41,W
06F38:  MOVLB  A
06F3A:  MOVWF  x14
06F3C:  MOVLW  72
06F3E:  MOVLB  1
06F40:  ADDWFC x42,W
06F42:  MOVLB  A
06F44:  MOVWF  x15
06F46:  MOVLW  00
06F48:  MOVLB  1
06F4A:  ADDWFC x43,W
06F4C:  MOVLB  A
06F4E:  MOVWF  x16
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
06F50:  MOVFF  111,A5F
06F54:  MOVFF  110,A5E
06F58:  MOVFF  10F,A5D
06F5C:  MOVFF  10E,A5C
06F60:  MOVFF  A16,A63
06F64:  MOVFF  A15,A62
06F68:  MOVFF  A14,A61
06F6C:  MOVFF  A13,A60
06F70:  MOVLW  09
06F72:  MOVWF  x65
06F74:  MOVLW  CC
06F76:  MOVWF  x64
06F78:  CLRF   x67
06F7A:  MOVLW  40
06F7C:  MOVWF  x66
06F7E:  MOVLB  0
06F80:  CALL   34E0
....................             iv_data.used_counter += PACKET_SIZE;
06F84:  MOVLW  40
06F86:  MOVLB  1
06F88:  ADDWF  x40,F
06F8A:  MOVLW  00
06F8C:  ADDWFC x41,F
06F8E:  MOVLW  00
06F90:  ADDWFC x42,F
06F92:  MOVLW  00
06F94:  ADDWFC x43,F
....................             iv_data.uncopied_counter += PACKET_SIZE;
06F96:  MOVLW  40
06F98:  ADDWF  x44,F
06F9A:  MOVLW  00
06F9C:  ADDWFC x45,F
06F9E:  MOVLW  00
06FA0:  ADDWFC x46,F
06FA2:  MOVLW  00
06FA4:  ADDWFC x47,F
....................             packetdata_index = 0;
06FA6:  MOVLB  A
06FA8:  CLRF   x0C
....................             memset(packetdata, 0x00, PACKET_SIZE);
06FAA:  MOVLW  09
06FAC:  MOVWF  FEA
06FAE:  MOVLW  CC
06FB0:  MOVWF  FE9
06FB2:  CLRF   00
06FB4:  CLRF   02
06FB6:  MOVLW  40
06FB8:  MOVWF  01
06FBA:  MOVLB  0
06FBC:  CALL   27A2
....................         }
06FC0:  MOVLB  A
06FC2:  INCF   x0D,F
06FC4:  BTFSC  FD8.2
06FC6:  INCF   x0E,F
06FC8:  MOVLB  0
06FCA:  GOTO   6DC8
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
06FCE:  MOVLB  A
06FD0:  MOVF   x0C,F
06FD2:  BTFSS  FD8.2
06FD4:  BRA    6FDC
06FD6:  MOVLB  0
06FD8:  GOTO   70A8
06FDC:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
06FDE:  MOVFF  A0C,A17
06FE2:  MOVLB  A
06FE4:  MOVF   x17,W
06FE6:  SUBLW  3E
06FE8:  BTFSC  FD8.0
06FEA:  BRA    6FF2
06FEC:  MOVLB  0
06FEE:  GOTO   7012
06FF2:  MOVLB  0
....................             packetdata[j] = 0x00;
06FF4:  CLRF   03
06FF6:  MOVLB  A
06FF8:  MOVF   x17,W
06FFA:  ADDLW  CC
06FFC:  MOVWF  FE9
06FFE:  MOVLW  09
07000:  ADDWFC 03,W
07002:  MOVWF  FEA
07004:  CLRF   FEF
07006:  MOVLB  0
07008:  MOVLB  A
0700A:  INCF   x17,F
0700C:  MOVLB  0
0700E:  GOTO   6FE2
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
07012:  MOVLW  09
07014:  MOVLB  A
07016:  MOVWF  xB4
07018:  MOVLW  CC
0701A:  MOVWF  xB3
0701C:  MOVLW  3F
0701E:  MOVWF  xB5
07020:  MOVLB  0
07022:  CALL   29E6
07026:  MOVFF  01,A0B
....................         unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
0702A:  MOVLB  1
0702C:  MOVF   x40,W
0702E:  MOVLB  A
07030:  MOVWF  x18
07032:  MOVLW  10
07034:  MOVLB  1
07036:  ADDWF  x41,W
07038:  MOVLB  A
0703A:  MOVWF  x19
0703C:  MOVLW  72
0703E:  MOVLB  1
07040:  ADDWFC x42,W
07042:  MOVLB  A
07044:  MOVWF  x1A
07046:  MOVLW  00
07048:  MOVLB  1
0704A:  ADDWFC x43,W
0704C:  MOVLB  A
0704E:  MOVWF  x1B
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
07050:  MOVFF  111,A5F
07054:  MOVFF  110,A5E
07058:  MOVFF  10F,A5D
0705C:  MOVFF  10E,A5C
07060:  MOVFF  A1B,A63
07064:  MOVFF  A1A,A62
07068:  MOVFF  A19,A61
0706C:  MOVFF  A18,A60
07070:  MOVLW  09
07072:  MOVWF  x65
07074:  MOVLW  CC
07076:  MOVWF  x64
07078:  CLRF   x67
0707A:  MOVLW  40
0707C:  MOVWF  x66
0707E:  MOVLB  0
07080:  CALL   34E0
....................         iv_data.used_counter += PACKET_SIZE;
07084:  MOVLW  40
07086:  MOVLB  1
07088:  ADDWF  x40,F
0708A:  MOVLW  00
0708C:  ADDWFC x41,F
0708E:  MOVLW  00
07090:  ADDWFC x42,F
07092:  MOVLW  00
07094:  ADDWFC x43,F
....................         iv_data.uncopied_counter += PACKET_SIZE;
07096:  MOVLW  40
07098:  ADDWF  x44,F
0709A:  MOVLW  00
0709C:  ADDWFC x45,F
0709E:  MOVLW  00
070A0:  ADDWFC x46,F
070A2:  MOVLW  00
070A4:  ADDWFC x47,F
070A6:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "End CIGS data conversion\r\n");
070A8:  MOVLW  18
070AA:  MOVWF  FF6
070AC:  MOVLW  07
070AE:  MOVWF  FF7
070B0:  MOVLW  00
070B2:  MOVWF  FF8
070B4:  CALL   1BC0
....................     write_misf_address_area(); // Write the mission flash address area
070B8:  CALL   3F14
070BC:  RETURN 0
.................... }
.................... 
.................... MEASUREMENT_DATA create_meas_data()
.................... {
....................     MEASUREMENT_DATA data;
....................     data.time_sec = get_current_sec();
*
06884:  CALL   31C2
06888:  MOVFF  03,9D1
0688C:  MOVFF  02,9D0
06890:  MOVFF  01,9CF
06894:  MOVFF  00,9CE
....................     data.time_msec = get_current_msec();
06898:  GOTO   6854
0689C:  MOVFF  01,9D2
....................     data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
068A0:  MOVLW  0D
068A2:  MOVLB  9
068A4:  MOVWF  xDD
068A6:  MOVLB  0
068A8:  CALL   1DB0
068AC:  MOVFF  02,9D6
068B0:  MOVFF  01,9D5
....................     data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
068B4:  MOVLW  0E
068B6:  MOVLB  9
068B8:  MOVWF  xDD
068BA:  MOVLB  0
068BC:  CALL   1DB0
068C0:  MOVFF  02,9D8
068C4:  MOVFF  01,9D7
....................     data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
068C8:  MOVLW  0C
068CA:  MOVLB  9
068CC:  MOVWF  xDD
068CE:  MOVLB  0
068D0:  CALL   1DB0
068D4:  MOVFF  02,9DA
068D8:  MOVFF  01,9D9
....................     data.pd = ad7490_read(ADC_PD);
068DC:  MOVLW  0F
068DE:  MOVLB  9
068E0:  MOVWF  xDD
068E2:  MOVLB  0
068E4:  CALL   1DB0
068E8:  MOVFF  02,9DC
068EC:  MOVFF  01,9DB
....................     data.open_voltage = ad7490_read(ADC_CIGS1_VOLT); // Assuming this is the correct ADC channel for open voltage
068F0:  MOVLB  9
068F2:  CLRF   xDD
068F4:  MOVLB  0
068F6:  CALL   1DB0
068FA:  MOVFF  02,9D4
068FE:  MOVFF  01,9D3
....................     return data;
06902:  MOVLW  CE
06904:  MOVWF  01
06906:  MOVLW  09
06908:  MOVWF  02
0690A:  GOTO   8168 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/mcu/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../storage/mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
.................... {
....................     PICLOG_t piclog;
....................     memset(piclog.bytes, 0, PICLOG_PACKET_SIZE);
*
03F8A:  MOVLW  01
03F8C:  MOVWF  FEA
03F8E:  MOVLW  E8
03F90:  MOVWF  FE9
03F92:  CLRF   00
03F94:  CLRF   02
03F96:  MOVLW  06
03F98:  MOVWF  01
03F9A:  CALL   27A2
....................     piclog.fields.time = get_current_sec();
03F9E:  CALL   31C2
03FA2:  MOVFF  03,1EB
03FA6:  MOVFF  02,1EA
03FAA:  MOVFF  01,1E9
03FAE:  MOVFF  00,1E8
....................     piclog.fields.function = function;
03FB2:  MOVFF  1E6,1EC
....................     piclog.fields.parameter = parameter;
03FB6:  MOVFF  1E7,1ED
.................... 
....................     printf("\t[PICLOG] : ");
03FBA:  MOVLW  34
03FBC:  MOVWF  FF6
03FBE:  MOVLW  07
03FC0:  MOVWF  FF7
03FC2:  MOVLW  00
03FC4:  MOVWF  FF8
03FC6:  CALL   1BC0
....................     for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
03FCA:  MOVLB  1
03FCC:  CLRF   xEE
03FCE:  MOVLB  0
03FD0:  MOVLB  1
03FD2:  MOVF   xEE,W
03FD4:  SUBLW  05
03FD6:  BTFSC  FD8.0
03FD8:  BRA    3FE0
03FDA:  MOVLB  0
03FDC:  GOTO   401C
03FE0:  MOVLB  0
....................         printf("%02X ", piclog.bytes[i]);
03FE2:  CLRF   03
03FE4:  MOVLB  1
03FE6:  MOVF   xEE,W
03FE8:  ADDLW  E8
03FEA:  MOVWF  FE9
03FEC:  MOVLW  01
03FEE:  ADDWFC 03,W
03FF0:  MOVWF  FEA
03FF2:  MOVFF  FEF,1F3
03FF6:  MOVFF  1F3,9CC
03FFA:  MOVLW  37
03FFC:  MOVLB  9
03FFE:  MOVWF  xCD
04000:  MOVLB  0
04002:  CALL   1E44
04006:  MOVLW  20
04008:  MOVLB  A
0400A:  MOVWF  xB3
0400C:  MOVLB  0
0400E:  CALL   1B6E
04012:  MOVLB  1
04014:  INCF   xEE,F
04016:  MOVLB  0
04018:  GOTO   3FD0
....................     }
....................     printf("\r\n");
0401C:  MOVLW  0D
0401E:  MOVLB  A
04020:  MOVWF  xB3
04022:  MOVLB  0
04024:  CALL   1B6E
04028:  MOVLW  0A
0402A:  MOVLB  A
0402C:  MOVWF  xB3
0402E:  MOVLB  0
04030:  CALL   1B6E
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
04034:  MOVLB  1
04036:  MOVF   x1F,W
04038:  MOVWF  xEF
0403A:  MOVF   x20,W
0403C:  MOVWF  xF0
0403E:  MOVLW  01
04040:  ADDWF  x21,W
04042:  MOVWF  xF1
04044:  MOVLW  00
04046:  ADDWFC x22,W
04048:  MOVWF  xF2
....................     write_data_bytes(mis_fm, write_address, piclog.bytes, PICLOG_PACKET_SIZE);
0404A:  MOVFF  111,A5F
0404E:  MOVFF  110,A5E
04052:  MOVFF  10F,A5D
04056:  MOVFF  10E,A5C
0405A:  MOVFF  1F2,A63
0405E:  MOVFF  1F1,A62
04062:  MOVFF  1F0,A61
04066:  MOVFF  1EF,A60
0406A:  MOVLW  01
0406C:  MOVLB  A
0406E:  MOVWF  x65
04070:  MOVLW  E8
04072:  MOVWF  x64
04074:  CLRF   x67
04076:  MOVLW  06
04078:  MOVWF  x66
0407A:  MOVLB  0
0407C:  CALL   34E0
.................... 
....................     piclog_data.used_counter += PICLOG_PACKET_SIZE;
04080:  MOVLW  06
04082:  MOVLB  1
04084:  ADDWF  x1F,F
04086:  MOVLW  00
04088:  ADDWFC x20,F
0408A:  MOVLW  00
0408C:  ADDWFC x21,F
0408E:  MOVLW  00
04090:  ADDWFC x22,F
....................     piclog_data.uncopied_counter += PICLOG_PACKET_SIZE;
04092:  MOVLW  06
04094:  ADDWF  x23,F
04096:  MOVLW  00
04098:  ADDWFC x24,F
0409A:  MOVLW  00
0409C:  ADDWFC x25,F
0409E:  MOVLW  00
040A0:  ADDWFC x26,F
....................     piclog_data.reserve_counter1 += PICLOG_PACKET_SIZE;
040A2:  MOVLW  06
040A4:  ADDWF  x27,F
.................... 
....................     // Next Packet
....................     if (piclog_data.reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
040A6:  MOVLW  06
040A8:  ADDWF  x27,W
040AA:  SUBLW  3F
040AC:  BTFSS  FD8.0
040AE:  BRA    40B6
040B0:  MOVLB  0
040B2:  GOTO   412A
040B6:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
040B8:  MOVLB  1
040BA:  MOVF   x1F,W
040BC:  MOVWF  xEF
040BE:  MOVF   x20,W
040C0:  MOVWF  xF0
040C2:  MOVLW  01
040C4:  ADDWF  x21,W
040C6:  MOVWF  xF1
040C8:  MOVLW  00
040CA:  ADDWFC x22,W
040CC:  MOVWF  xF2
....................         write_data_bytes(mis_fm, write_address, PICLOG_BLANK_DATA, sizeof(PICLOG_BLANK_DATA));
040CE:  MOVFF  111,A5F
040D2:  MOVFF  110,A5E
040D6:  MOVFF  10F,A5D
040DA:  MOVFF  10E,A5C
040DE:  MOVFF  1F2,A63
040E2:  MOVFF  1F1,A62
040E6:  MOVFF  1F0,A61
040EA:  MOVFF  1EF,A60
040EE:  MOVLW  01
040F0:  MOVLB  A
040F2:  MOVWF  x65
040F4:  MOVLW  4A
040F6:  MOVWF  x64
040F8:  CLRF   x67
040FA:  MOVLW  04
040FC:  MOVWF  x66
040FE:  MOVLB  0
04100:  CALL   34E0
....................         piclog_data.used_counter += sizeof(PICLOG_BLANK_DATA);
04104:  MOVLW  04
04106:  MOVLB  1
04108:  ADDWF  x1F,F
0410A:  MOVLW  00
0410C:  ADDWFC x20,F
0410E:  MOVLW  00
04110:  ADDWFC x21,F
04112:  MOVLW  00
04114:  ADDWFC x22,F
....................         piclog_data.uncopied_counter += sizeof(PICLOG_BLANK_DATA);
04116:  MOVLW  04
04118:  ADDWF  x23,F
0411A:  MOVLW  00
0411C:  ADDWFC x24,F
0411E:  MOVLW  00
04120:  ADDWFC x25,F
04122:  MOVLW  00
04124:  ADDWFC x26,F
....................         piclog_data.reserve_counter1 = 0;
04126:  CLRF   x27
04128:  MOVLB  0
....................     }
.................... 
....................     write_misf_address_area(); // Update the address area after writing
0412A:  CALL   3F14
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
....................     #ifdef PICLOG_DEBUG
0412E:  RETURN 0
....................         //fprintf(PC, "PICLOG written: %02X %02X %02X %02X %02X %02X\r\n", piclog_data.bytes[0], data[1], data[2], data[3], data[4], data[5]);
....................     #endif
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
09634:  MOVLB  2
09636:  MOVF   x66,W
09638:  MOVWF  01
0963A:  MOVF   x67,W
0963C:  MOVWF  03
0963E:  MOVF   01,W
09640:  MOVWF  x69
09642:  MOVFF  03,26A
09646:  MOVFF  115,2EB
0964A:  MOVFF  114,2EA
0964E:  MOVFF  113,2E9
09652:  MOVFF  112,2E8
09656:  MOVLW  06
09658:  MOVWF  xEF
0965A:  MOVLW  AA
0965C:  MOVWF  xEE
0965E:  CLRF   xED
09660:  CLRF   xEC
09662:  MOVFF  26A,2F1
09666:  MOVFF  269,2F0
0966A:  CLRF   xF5
0966C:  CLRF   xF4
0966E:  CLRF   xF3
09670:  MOVLW  40
09672:  MOVWF  xF2
09674:  MOVLB  0
09676:  CALL   27C6
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0967A:  MOVLB  2
0967C:  CLRF   x68
0967E:  MOVLB  0
09680:  MOVLB  2
09682:  MOVF   x68,W
09684:  SUBLW  04
09686:  BTFSC  FD8.0
09688:  BRA    9690
0968A:  MOVLB  0
0968C:  GOTO   975A
09690:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
09692:  MOVLB  2
09694:  MOVF   x66,W
09696:  MOVWF  01
09698:  MOVF   x67,W
0969A:  MOVWF  03
0969C:  MOVF   01,W
0969E:  MOVWF  x69
096A0:  MOVFF  03,26A
096A4:  MOVFF  115,2EB
096A8:  MOVFF  114,2EA
096AC:  MOVFF  113,2E9
096B0:  MOVFF  112,2E8
096B4:  MOVLW  06
096B6:  MOVWF  xEF
096B8:  MOVLW  AA
096BA:  MOVWF  xEE
096BC:  CLRF   xED
096BE:  CLRF   xEC
096C0:  MOVFF  26A,2F1
096C4:  MOVFF  269,2F0
096C8:  CLRF   xF5
096CA:  CLRF   xF4
096CC:  CLRF   xF3
096CE:  MOVLW  40
096D0:  MOVWF  xF2
096D2:  MOVLB  0
096D4:  CALL   27C6
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
096D8:  MOVLB  2
096DA:  MOVF   x66,W
096DC:  MOVWF  01
096DE:  MOVF   x67,W
096E0:  MOVWF  03
096E2:  MOVF   01,W
096E4:  MOVWF  x69
096E6:  MOVFF  03,26A
096EA:  MOVFF  26A,2E9
096EE:  MOVFF  269,2E8
096F2:  MOVLW  3F
096F4:  MOVWF  xEA
096F6:  MOVLB  0
096F8:  CALL   95E6
096FC:  MOVF   01,F
096FE:  BTFSC  FD8.2
09700:  GOTO   9750
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
09704:  MOVLW  01
09706:  MOVLB  2
09708:  ADDWF  x68,W
0970A:  MOVWF  x69
0970C:  MOVLW  42
0970E:  MOVWF  FF6
09710:  MOVLW  07
09712:  MOVWF  FF7
09714:  MOVLW  00
09716:  MOVWF  FF8
09718:  MOVLW  23
0971A:  MOVLB  9
0971C:  MOVWF  xCC
0971E:  MOVLB  0
09720:  CALL   1BF0
09724:  MOVFF  269,26A
09728:  MOVLW  1B
0972A:  MOVLB  2
0972C:  MOVWF  x6B
0972E:  MOVLB  0
09730:  CALL   66D0
09734:  MOVLW  0D
09736:  MOVLB  A
09738:  MOVWF  xB3
0973A:  MOVLB  0
0973C:  CALL   1B6E
09740:  MOVLW  0A
09742:  MOVLB  A
09744:  MOVWF  xB3
09746:  MOVLB  0
09748:  CALL   1B6E
....................             break;
0974C:  GOTO   975A
....................         }
09750:  MOVLB  2
09752:  INCF   x68,F
09754:  MOVLB  0
09756:  GOTO   9680
....................     }
0975A:  GOTO   9BC0 (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
09870:  CALL   3864
09874:  MOVFF  02,03
09878:  MOVF   01,W
0987A:  MOVWF  FE1
0987C:  MOVFF  03,FE2
09880:  MOVLW  02
09882:  MOVWF  FEA
09884:  MOVLW  66
09886:  MOVWF  FE9
09888:  MOVLW  40
0988A:  MOVWF  01
0988C:  MOVFF  FE6,FEE
09890:  DECFSZ 01,F
09892:  GOTO   988C
09896:  MOVLB  2
09898:  BCF    xE6.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0989A:  CLRF   xE7
0989C:  MOVLB  0
0989E:  MOVLB  2
098A0:  MOVF   xE7,W
098A2:  SUBLW  04
098A4:  BTFSC  FD8.0
098A6:  BRA    98AE
098A8:  MOVLB  0
098AA:  GOTO   99AE
098AE:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
098B0:  MOVFF  115,2EB
098B4:  MOVFF  114,2EA
098B8:  MOVFF  113,2E9
098BC:  MOVFF  112,2E8
098C0:  MOVLW  06
098C2:  MOVLB  2
098C4:  MOVWF  xEF
098C6:  MOVLW  AA
098C8:  MOVWF  xEE
098CA:  CLRF   xED
098CC:  CLRF   xEC
098CE:  MOVLB  0
098D0:  CALL   4A54
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
098D4:  MOVFF  115,A5F
098D8:  MOVFF  114,A5E
098DC:  MOVFF  113,A5D
098E0:  MOVFF  112,A5C
098E4:  MOVLW  06
098E6:  MOVLB  A
098E8:  MOVWF  x63
098EA:  MOVLW  AA
098EC:  MOVWF  x62
098EE:  CLRF   x61
098F0:  CLRF   x60
098F2:  MOVLW  02
098F4:  MOVWF  x65
098F6:  MOVLW  66
098F8:  MOVWF  x64
098FA:  CLRF   x67
098FC:  MOVLW  40
098FE:  MOVWF  x66
09900:  MOVLB  0
09902:  CALL   34E0
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
09906:  MOVFF  115,2EB
0990A:  MOVFF  114,2EA
0990E:  MOVFF  113,2E9
09912:  MOVFF  112,2E8
09916:  MOVLW  06
09918:  MOVLB  2
0991A:  MOVWF  xEF
0991C:  MOVLW  AA
0991E:  MOVWF  xEE
09920:  CLRF   xED
09922:  CLRF   xEC
09924:  MOVLW  02
09926:  MOVWF  xF1
09928:  MOVLW  A6
0992A:  MOVWF  xF0
0992C:  CLRF   xF5
0992E:  CLRF   xF4
09930:  CLRF   xF3
09932:  MOVLW  40
09934:  MOVWF  xF2
09936:  MOVLB  0
09938:  CALL   27C6
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
0993C:  MOVLW  02
0993E:  MOVLB  2
09940:  MOVWF  xE9
09942:  MOVLW  A6
09944:  MOVWF  xE8
09946:  MOVLW  3F
09948:  MOVWF  xEA
0994A:  MOVLB  0
0994C:  CALL   95E6
09950:  MOVF   01,F
09952:  BTFSC  FD8.2
09954:  GOTO   99A4
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
09958:  MOVLW  01
0995A:  MOVLB  2
0995C:  ADDWF  xE7,W
0995E:  MOVWF  xE8
09960:  MOVLW  6A
09962:  MOVWF  FF6
09964:  MOVLW  07
09966:  MOVWF  FF7
09968:  MOVLW  00
0996A:  MOVWF  FF8
0996C:  MOVLW  23
0996E:  MOVLB  9
09970:  MOVWF  xCC
09972:  MOVLB  0
09974:  CALL   1BF0
09978:  MOVFF  2E8,2E9
0997C:  MOVLW  18
0997E:  MOVLB  2
09980:  MOVWF  xEA
09982:  MOVLB  0
09984:  CALL   975E
09988:  MOVLW  0D
0998A:  MOVLB  A
0998C:  MOVWF  xB3
0998E:  MOVLB  0
09990:  CALL   1B6E
09994:  MOVLW  0A
09996:  MOVLB  A
09998:  MOVWF  xB3
0999A:  MOVLB  0
0999C:  CALL   1B6E
....................             break;
099A0:  GOTO   99AE
....................         }
099A4:  MOVLB  2
099A6:  INCF   xE7,F
099A8:  MOVLB  0
099AA:  GOTO   989E
....................     }
....................     if (!crc_valid)
099AE:  MOVLB  2
099B0:  BTFSS  xE6.0
099B2:  BRA    99BA
099B4:  MOVLB  0
099B6:  GOTO   99FC
099BA:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
099BC:  MOVLW  92
099BE:  MOVWF  FF6
099C0:  MOVLW  07
099C2:  MOVWF  FF7
099C4:  MOVLW  00
099C6:  MOVWF  FF8
099C8:  MOVLW  25
099CA:  MOVLB  9
099CC:  MOVWF  xCC
099CE:  MOVLB  0
099D0:  CALL   1BF0
099D4:  MOVLW  05
099D6:  MOVLB  2
099D8:  MOVWF  xE9
099DA:  MOVLW  18
099DC:  MOVWF  xEA
099DE:  MOVLB  0
099E0:  CALL   975E
099E4:  MOVLW  B9
099E6:  MOVWF  FF6
099E8:  MOVLW  07
099EA:  MOVWF  FF7
099EC:  MOVLW  00
099EE:  MOVWF  FF8
099F0:  MOVLW  0B
099F2:  MOVLB  9
099F4:  MOVWF  xCC
099F6:  MOVLB  0
099F8:  CALL   1BF0
....................         // return; 
....................     }
099FC:  GOTO   A2A0 (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
09A04:  MOVLW  C6
09A06:  MOVWF  FF6
09A08:  MOVLW  07
09A0A:  MOVWF  FF7
09A0C:  MOVLW  00
09A0E:  MOVWF  FF8
09A10:  CALL   1BC0
....................     fprintf(PC, "_____Start copy_data____\r\n");
09A14:  MOVLW  E0
09A16:  MOVWF  FF6
09A18:  MOVLW  07
09A1A:  MOVWF  FF7
09A1C:  MOVLW  00
09A1E:  MOVWF  FF8
09A20:  CALL   1BC0
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
09A24:  MOVLB  1
09A26:  MOVF   x91,W
09A28:  MOVWF  FE9
09A2A:  MOVF   x92,W
09A2C:  MOVWF  FEA
09A2E:  MOVFF  FEF,266
09A32:  MOVFF  266,26D
09A36:  MOVLB  0
09A38:  CALL   93BE
09A3C:  MOVFF  02,03
09A40:  MOVF   01,W
09A42:  MOVWF  FE1
09A44:  MOVFF  03,FE2
09A48:  MOVLW  01
09A4A:  MOVWF  FEA
09A4C:  MOVLW  D3
09A4E:  MOVWF  FE9
09A50:  MOVLW  08
09A52:  MOVWF  01
09A54:  MOVFF  FE6,FEE
09A58:  DECFSZ 01,F
09A5A:  GOTO   9A54
09A5E:  MOVFF  1D6,1DE
09A62:  MOVFF  1D5,1DD
09A66:  MOVFF  1D4,1DC
09A6A:  MOVFF  1D3,1DB
09A6E:  MOVFF  1DA,1E2
09A72:  MOVFF  1D9,1E1
09A76:  MOVFF  1D8,1E0
09A7A:  MOVFF  1D7,1DF
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
09A7E:  MOVLW  03
09A80:  MOVLB  1
09A82:  ADDWF  x91,W
09A84:  MOVWF  01
09A86:  MOVLW  00
09A88:  ADDWFC x92,W
09A8A:  MOVWF  03
09A8C:  MOVF   01,W
09A8E:  MOVWF  FE9
09A90:  MOVFF  03,FEA
09A94:  BTFSS  FEF.0
09A96:  BRA    9A9E
09A98:  MOVLB  0
09A9A:  GOTO   9AEE
09A9E:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
09AA0:  MOVLB  1
09AA2:  MOVF   x91,W
09AA4:  MOVWF  FE9
09AA6:  MOVF   x92,W
09AA8:  MOVWF  FEA
09AAA:  MOVFF  FEF,266
09AAE:  MOVFF  266,26D
09AB2:  MOVLB  0
09AB4:  GOTO   94DE
09AB8:  MOVFF  02,03
09ABC:  MOVF   01,W
09ABE:  MOVWF  FE1
09AC0:  MOVFF  03,FE2
09AC4:  MOVLW  01
09AC6:  MOVWF  FEA
09AC8:  MOVLW  EB
09ACA:  MOVWF  FE9
09ACC:  MOVLW  08
09ACE:  MOVWF  01
09AD0:  MOVFF  FE6,FEE
09AD4:  DECFSZ 01,F
09AD6:  GOTO   9AD0
....................         write_src = misf_address.start_address;
09ADA:  MOVFF  1EE,1E6
09ADE:  MOVFF  1ED,1E5
09AE2:  MOVFF  1EC,1E4
09AE6:  MOVFF  1EB,1E3
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
09AEA:  GOTO   9B58
09AEE:  MOVLW  03
09AF0:  MOVLB  1
09AF2:  ADDWF  x91,W
09AF4:  MOVWF  01
09AF6:  MOVLW  00
09AF8:  ADDWFC x92,W
09AFA:  MOVWF  03
09AFC:  MOVF   01,W
09AFE:  MOVWF  FE9
09B00:  MOVFF  03,FEA
09B04:  BTFSC  FEF.0
09B06:  BRA    9B0E
09B08:  MOVLB  0
09B0A:  GOTO   9B58
09B0E:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
09B10:  MOVLW  04
09B12:  MOVLB  1
09B14:  ADDWF  x91,W
09B16:  MOVWF  FE9
09B18:  MOVLW  00
09B1A:  ADDWFC x92,W
09B1C:  MOVWF  FEA
09B1E:  MOVFF  FEF,1E3
09B22:  MOVFF  FEC,1E4
09B26:  MOVFF  FEC,1E5
09B2A:  MOVFF  FEC,1E6
09B2E:  MOVF   FED,F
09B30:  MOVF   FED,F
09B32:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
09B34:  MOVLW  08
09B36:  ADDWF  x91,W
09B38:  MOVWF  FE9
09B3A:  MOVLW  00
09B3C:  ADDWFC x92,W
09B3E:  MOVWF  FEA
09B40:  MOVFF  FEF,1E7
09B44:  MOVFF  FEC,1E8
09B48:  MOVFF  FEC,1E9
09B4C:  MOVFF  FEC,1EA
09B50:  MOVF   FED,F
09B52:  MOVF   FED,F
09B54:  MOVF   FED,F
09B56:  MOVLB  0
....................     }
.................... 
....................     if (!is_connect(mis_fm))
09B58:  MOVFF  111,269
09B5C:  MOVFF  110,268
09B60:  MOVFF  10F,267
09B64:  MOVFF  10E,266
09B68:  CALL   26DA
09B6C:  MOVF   01,F
09B6E:  BTFSS  FD8.2
09B70:  GOTO   9B84
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
09B74:  MOVLW  FC
09B76:  MOVWF  FF6
09B78:  MOVLW  07
09B7A:  MOVWF  FF7
09B7C:  MOVLW  00
09B7E:  MOVWF  FF8
09B80:  CALL   1BC0
....................     }    
....................     if (!is_connect(smf))
09B84:  MOVFF  115,269
09B88:  MOVFF  114,268
09B8C:  MOVFF  113,267
09B90:  MOVFF  112,266
09B94:  CALL   26DA
09B98:  MOVF   01,F
09B9A:  BTFSS  FD8.2
09B9C:  GOTO   9BB0
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
09BA0:  MOVLW  1E
09BA2:  MOVWF  FF6
09BA4:  MOVLW  08
09BA6:  MOVWF  FF7
09BA8:  MOVLW  00
09BAA:  MOVWF  FF8
09BAC:  CALL   1BC0
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
09BB0:  MOVLW  01
09BB2:  MOVLB  2
09BB4:  MOVWF  x67
09BB6:  MOVLW  93
09BB8:  MOVWF  x66
09BBA:  MOVLB  0
09BBC:  GOTO   9634
.................... 
....................     // PartitionParamから値を取得
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
09BC0:  MOVFF  154,1F6
09BC4:  MOVFF  153,1F5
09BC8:  MOVFF  152,1F4
09BCC:  MOVFF  151,1F3
09BD0:  MOVFF  155,1F7
....................     fprintf(PC, "Size area read\r\n");
09BD4:  MOVLW  3C
09BD6:  MOVWF  FF6
09BD8:  MOVLW  08
09BDA:  MOVWF  FF7
09BDC:  MOVLW  00
09BDE:  MOVWF  FF8
09BE0:  CALL   1BC0
....................     fprintf(PC, "used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
09BE4:  MOVLW  4E
09BE6:  MOVWF  FF6
09BE8:  MOVLW  08
09BEA:  MOVWF  FF7
09BEC:  MOVLW  00
09BEE:  MOVWF  FF8
09BF0:  MOVLW  0C
09BF2:  MOVLB  9
09BF4:  MOVWF  xCC
09BF6:  MOVLB  0
09BF8:  CALL   1BF0
09BFC:  MOVLW  41
09BFE:  MOVWF  FE9
09C00:  MOVFF  1F6,269
09C04:  MOVFF  1F5,268
09C08:  MOVFF  1F4,267
09C0C:  MOVFF  1F3,266
09C10:  CALL   9242
09C14:  MOVLW  5D
09C16:  MOVWF  FF6
09C18:  MOVLW  08
09C1A:  MOVWF  FF7
09C1C:  MOVLW  00
09C1E:  MOVWF  FF8
09C20:  MOVLW  08
09C22:  MOVLB  9
09C24:  MOVWF  xCC
09C26:  MOVLB  0
09C28:  CALL   1BF0
09C2C:  MOVFF  1DE,9CC
09C30:  MOVLW  37
09C32:  MOVLB  9
09C34:  MOVWF  xCD
09C36:  MOVLB  0
09C38:  CALL   1E44
09C3C:  MOVFF  1DD,9CC
09C40:  MOVLW  37
09C42:  MOVLB  9
09C44:  MOVWF  xCD
09C46:  MOVLB  0
09C48:  CALL   1E44
09C4C:  MOVFF  1DC,9CC
09C50:  MOVLW  37
09C52:  MOVLB  9
09C54:  MOVWF  xCD
09C56:  MOVLB  0
09C58:  CALL   1E44
09C5C:  MOVFF  1DB,9CC
09C60:  MOVLW  37
09C62:  MOVLB  9
09C64:  MOVWF  xCD
09C66:  MOVLB  0
09C68:  CALL   1E44
09C6C:  MOVLW  6A
09C6E:  MOVWF  FF6
09C70:  MOVLW  08
09C72:  MOVWF  FF7
09C74:  MOVLW  00
09C76:  MOVWF  FF8
09C78:  MOVLW  03
09C7A:  MOVLB  9
09C7C:  MOVWF  xCC
09C7E:  MOVLB  0
09C80:  CALL   1BF0
....................     fprintf(PC, "loop count= %d  (src 0x%08LX)\r\n\r\n", loop_count, mis_start_address + 4);
09C84:  MOVLW  04
09C86:  MOVLB  1
09C88:  ADDWF  xDB,W
09C8A:  MOVLB  2
09C8C:  MOVWF  x66
09C8E:  MOVLW  00
09C90:  MOVLB  1
09C92:  ADDWFC xDC,W
09C94:  MOVLB  2
09C96:  MOVWF  x67
09C98:  MOVLW  00
09C9A:  MOVLB  1
09C9C:  ADDWFC xDD,W
09C9E:  MOVLB  2
09CA0:  MOVWF  x68
09CA2:  MOVLW  00
09CA4:  MOVLB  1
09CA6:  ADDWFC xDE,W
09CA8:  MOVLB  2
09CAA:  MOVWF  x69
09CAC:  MOVLW  6E
09CAE:  MOVWF  FF6
09CB0:  MOVLW  08
09CB2:  MOVWF  FF7
09CB4:  MOVLW  00
09CB6:  MOVWF  FF8
09CB8:  MOVLW  0C
09CBA:  MOVLB  9
09CBC:  MOVWF  xCC
09CBE:  MOVLB  0
09CC0:  CALL   1BF0
09CC4:  MOVFF  1F7,2E9
09CC8:  MOVLW  18
09CCA:  MOVLB  2
09CCC:  MOVWF  xEA
09CCE:  MOVLB  0
09CD0:  CALL   975E
09CD4:  MOVLW  7C
09CD6:  MOVWF  FF6
09CD8:  MOVLW  08
09CDA:  MOVWF  FF7
09CDC:  MOVLW  00
09CDE:  MOVWF  FF8
09CE0:  MOVLW  09
09CE2:  MOVLB  9
09CE4:  MOVWF  xCC
09CE6:  MOVLB  0
09CE8:  CALL   1BF0
09CEC:  MOVFF  269,9CC
09CF0:  MOVLW  37
09CF2:  MOVLB  9
09CF4:  MOVWF  xCD
09CF6:  MOVLB  0
09CF8:  CALL   1E44
09CFC:  MOVFF  268,9CC
09D00:  MOVLW  37
09D02:  MOVLB  9
09D04:  MOVWF  xCD
09D06:  MOVLB  0
09D08:  CALL   1E44
09D0C:  MOVFF  267,9CC
09D10:  MOVLW  37
09D12:  MOVLB  9
09D14:  MOVWF  xCD
09D16:  MOVLB  0
09D18:  CALL   1E44
09D1C:  MOVFF  266,9CC
09D20:  MOVLW  37
09D22:  MOVLB  9
09D24:  MOVWF  xCD
09D26:  MOVLB  0
09D28:  CALL   1E44
09D2C:  MOVLW  8A
09D2E:  MOVWF  FF6
09D30:  MOVLW  08
09D32:  MOVWF  FF7
09D34:  MOVLW  00
09D36:  MOVWF  FF8
09D38:  MOVLW  05
09D3A:  MOVLB  9
09D3C:  MOVWF  xCC
09D3E:  MOVLB  0
09D40:  CALL   1BF0
....................     
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
09D44:  MOVLB  1
09D46:  MOVF   xDB,W
09D48:  MOVWF  xF8
09D4A:  MOVLW  10
09D4C:  ADDWF  xDC,W
09D4E:  MOVWF  xF9
09D50:  MOVLW  00
09D52:  ADDWFC xDD,W
09D54:  MOVWF  xFA
09D56:  MOVLW  00
09D58:  ADDWFC xDE,W
09D5A:  MOVWF  xFB
09D5C:  MOVFF  1E2,1FF
09D60:  MOVFF  1E1,1FE
09D64:  MOVFF  1E0,1FD
09D68:  MOVFF  1DF,1FC
09D6C:  MOVF   xF8,W
09D6E:  SUBWF  xFC,W
09D70:  MOVLB  2
09D72:  MOVWF  x00
09D74:  MOVLB  1
09D76:  MOVF   xF9,W
09D78:  SUBWFB xFD,W
09D7A:  MOVLB  2
09D7C:  MOVWF  x01
09D7E:  MOVLB  1
09D80:  MOVF   xFA,W
09D82:  SUBWFB xFE,W
09D84:  MOVLB  2
09D86:  MOVWF  x02
09D88:  MOVLB  1
09D8A:  MOVF   xFB,W
09D8C:  SUBWFB xFF,W
09D8E:  MOVLB  2
09D90:  MOVWF  x03
09D92:  MOVLB  1
09D94:  MOVF   xF3,W
09D96:  ADDWF  xF8,W
09D98:  MOVLB  2
09D9A:  MOVWF  x04
09D9C:  MOVLB  1
09D9E:  MOVF   xF4,W
09DA0:  ADDWFC xF9,W
09DA2:  MOVLB  2
09DA4:  MOVWF  x05
09DA6:  MOVLB  1
09DA8:  MOVF   xF5,W
09DAA:  ADDWFC xFA,W
09DAC:  MOVLB  2
09DAE:  MOVWF  x06
09DB0:  MOVLB  1
09DB2:  MOVF   xF6,W
09DB4:  ADDWFC xFB,W
09DB6:  MOVLB  2
09DB8:  MOVWF  x07
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
09DBA:  MOVLB  1
09DBC:  MOVF   xE7,W
09DBE:  ADDWF  xF3,W
09DC0:  MOVLB  2
09DC2:  MOVWF  x66
09DC4:  MOVLB  1
09DC6:  MOVF   xE8,W
09DC8:  ADDWFC xF4,W
09DCA:  MOVLB  2
09DCC:  MOVWF  x67
09DCE:  MOVLB  1
09DD0:  MOVF   xE9,W
09DD2:  ADDWFC xF5,W
09DD4:  MOVLB  2
09DD6:  MOVWF  x68
09DD8:  MOVLB  1
09DDA:  MOVF   xEA,W
09DDC:  ADDWFC xF6,W
09DDE:  MOVLB  2
09DE0:  MOVWF  x69
09DE2:  MOVF   x03,W
09DE4:  SUBWF  x69,W
09DE6:  BTFSC  FD8.0
09DE8:  BRA    9DF0
09DEA:  MOVLB  0
09DEC:  GOTO   9F26
09DF0:  MOVLB  0
09DF2:  BTFSS  FD8.2
09DF4:  GOTO   9E3A
09DF8:  MOVLB  2
09DFA:  MOVF   x02,W
09DFC:  SUBWF  x68,W
09DFE:  BTFSC  FD8.0
09E00:  BRA    9E08
09E02:  MOVLB  0
09E04:  GOTO   9F26
09E08:  MOVLB  0
09E0A:  BTFSS  FD8.2
09E0C:  GOTO   9E3A
09E10:  MOVLB  2
09E12:  MOVF   x01,W
09E14:  SUBWF  x67,W
09E16:  BTFSC  FD8.0
09E18:  BRA    9E20
09E1A:  MOVLB  0
09E1C:  GOTO   9F26
09E20:  MOVLB  0
09E22:  BTFSS  FD8.2
09E24:  GOTO   9E3A
09E28:  MOVLB  2
09E2A:  MOVF   x66,W
09E2C:  SUBWF  x00,W
09E2E:  BTFSS  FD8.0
09E30:  BRA    9E38
09E32:  MOVLB  0
09E34:  GOTO   9F26
09E38:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
09E3A:  MOVLW  90
09E3C:  MOVWF  FF6
09E3E:  MOVLW  08
09E40:  MOVWF  FF7
09E42:  MOVLW  00
09E44:  MOVWF  FF8
09E46:  CALL   1BC0
....................         loop_count++;
09E4A:  MOVLB  1
09E4C:  INCF   xF7,F
....................         used_size = 0;
09E4E:  CLRF   xF6
09E50:  CLRF   xF5
09E52:  CLRF   xF4
09E54:  CLRF   xF3
....................         data_write_addr = data_region_start;
09E56:  MOVFF  1FB,207
09E5A:  MOVFF  1FA,206
09E5E:  MOVFF  1F9,205
09E62:  MOVFF  1F8,204
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
09E66:  MOVF   x91,W
09E68:  MOVWF  FE9
09E6A:  MOVF   x92,W
09E6C:  MOVWF  FEA
09E6E:  MOVFF  FEF,266
09E72:  MOVFF  266,267
09E76:  MOVLB  0
09E78:  GOTO   986C
....................         
....................         unsigned int32 erase_ptr = data_region_start;
09E7C:  MOVFF  1FB,20B
09E80:  MOVFF  1FA,20A
09E84:  MOVFF  1F9,209
09E88:  MOVFF  1F8,208
....................         while (erase_ptr < data_region_end)
09E8C:  MOVLB  2
09E8E:  MOVF   x0B,W
09E90:  MOVLB  1
09E92:  SUBWF  xFF,W
09E94:  BTFSC  FD8.0
09E96:  BRA    9E9E
09E98:  MOVLB  0
09E9A:  GOTO   9F26
09E9E:  MOVLB  0
09EA0:  BTFSS  FD8.2
09EA2:  GOTO   9EEE
09EA6:  MOVLB  2
09EA8:  MOVF   x0A,W
09EAA:  MOVLB  1
09EAC:  SUBWF  xFE,W
09EAE:  BTFSC  FD8.0
09EB0:  BRA    9EB8
09EB2:  MOVLB  0
09EB4:  GOTO   9F26
09EB8:  MOVLB  0
09EBA:  BTFSS  FD8.2
09EBC:  GOTO   9EEE
09EC0:  MOVLB  2
09EC2:  MOVF   x09,W
09EC4:  MOVLB  1
09EC6:  SUBWF  xFD,W
09EC8:  BTFSC  FD8.0
09ECA:  BRA    9ED2
09ECC:  MOVLB  0
09ECE:  GOTO   9F26
09ED2:  MOVLB  0
09ED4:  BTFSS  FD8.2
09ED6:  GOTO   9EEE
09EDA:  MOVLB  1
09EDC:  MOVF   xFC,W
09EDE:  MOVLB  2
09EE0:  SUBWF  x08,W
09EE2:  BTFSS  FD8.0
09EE4:  BRA    9EEC
09EE6:  MOVLB  0
09EE8:  GOTO   9F26
09EEC:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
09EEE:  MOVFF  115,2EB
09EF2:  MOVFF  114,2EA
09EF6:  MOVFF  113,2E9
09EFA:  MOVFF  112,2E8
09EFE:  MOVFF  20B,2EF
09F02:  MOVFF  20A,2EE
09F06:  MOVFF  209,2ED
09F0A:  MOVFF  208,2EC
09F0E:  CALL   4A54
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
09F12:  MOVLW  10
09F14:  MOVLB  2
09F16:  ADDWF  x09,F
09F18:  MOVLW  00
09F1A:  ADDWFC x0A,F
09F1C:  MOVLW  00
09F1E:  ADDWFC x0B,F
09F20:  MOVLB  0
09F22:  GOTO   9E8C
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
09F26:  MOVLB  2
09F28:  CLRF   x0C
09F2A:  MOVF   x05,W
09F2C:  ANDLW  F0
09F2E:  MOVWF  x0D
09F30:  CLRF   x0E
09F32:  CLRF   x0F
09F34:  MOVLB  1
09F36:  MOVF   xE7,W
09F38:  MOVLB  2
09F3A:  ADDWF  x04,W
09F3C:  MOVWF  x66
09F3E:  MOVLB  1
09F40:  MOVF   xE8,W
09F42:  MOVLB  2
09F44:  ADDWFC x05,W
09F46:  MOVWF  x67
09F48:  MOVLB  1
09F4A:  MOVF   xE9,W
09F4C:  MOVLB  2
09F4E:  ADDWFC x06,W
09F50:  MOVWF  x68
09F52:  MOVLB  1
09F54:  MOVF   xEA,W
09F56:  MOVLB  2
09F58:  ADDWFC x07,W
09F5A:  MOVWF  x69
09F5C:  MOVLW  FF
09F5E:  ADDWF  x66,F
09F60:  MOVLW  0F
09F62:  ADDWFC x67,F
09F64:  MOVLW  00
09F66:  ADDWFC x68,F
09F68:  MOVLW  00
09F6A:  ADDWFC x69,F
09F6C:  CLRF   x10
09F6E:  MOVF   x67,W
09F70:  ANDLW  F0
09F72:  MOVWF  x11
09F74:  CLRF   x12
09F76:  CLRF   x13
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
09F78:  MOVFF  20F,217
09F7C:  MOVFF  20E,216
09F80:  MOVFF  20D,215
09F84:  MOVFF  20C,214
09F88:  MOVLB  0
09F8A:  MOVLB  2
09F8C:  MOVF   x17,W
09F8E:  SUBWF  x13,W
09F90:  BTFSC  FD8.0
09F92:  BRA    9F9A
09F94:  MOVLB  0
09F96:  GOTO   A07E
09F9A:  MOVLB  0
09F9C:  BTFSS  FD8.2
09F9E:  GOTO   9FE4
09FA2:  MOVLB  2
09FA4:  MOVF   x16,W
09FA6:  SUBWF  x12,W
09FA8:  BTFSC  FD8.0
09FAA:  BRA    9FB2
09FAC:  MOVLB  0
09FAE:  GOTO   A07E
09FB2:  MOVLB  0
09FB4:  BTFSS  FD8.2
09FB6:  GOTO   9FE4
09FBA:  MOVLB  2
09FBC:  MOVF   x15,W
09FBE:  SUBWF  x11,W
09FC0:  BTFSC  FD8.0
09FC2:  BRA    9FCA
09FC4:  MOVLB  0
09FC6:  GOTO   A07E
09FCA:  MOVLB  0
09FCC:  BTFSS  FD8.2
09FCE:  GOTO   9FE4
09FD2:  MOVLB  2
09FD4:  MOVF   x10,W
09FD6:  SUBWF  x14,W
09FD8:  BTFSS  FD8.0
09FDA:  BRA    9FE2
09FDC:  MOVLB  0
09FDE:  GOTO   A07E
09FE2:  MOVLB  0
09FE4:  MOVLB  2
09FE6:  MOVF   x17,W
09FE8:  MOVLB  1
09FEA:  SUBWF  xE2,W
09FEC:  BTFSC  FD8.0
09FEE:  BRA    9FF6
09FF0:  MOVLB  0
09FF2:  GOTO   A07E
09FF6:  MOVLB  0
09FF8:  BTFSS  FD8.2
09FFA:  GOTO   A046
09FFE:  MOVLB  2
0A000:  MOVF   x16,W
0A002:  MOVLB  1
0A004:  SUBWF  xE1,W
0A006:  BTFSC  FD8.0
0A008:  BRA    A010
0A00A:  MOVLB  0
0A00C:  GOTO   A07E
0A010:  MOVLB  0
0A012:  BTFSS  FD8.2
0A014:  GOTO   A046
0A018:  MOVLB  2
0A01A:  MOVF   x15,W
0A01C:  MOVLB  1
0A01E:  SUBWF  xE0,W
0A020:  BTFSC  FD8.0
0A022:  BRA    A02A
0A024:  MOVLB  0
0A026:  GOTO   A07E
0A02A:  MOVLB  0
0A02C:  BTFSS  FD8.2
0A02E:  GOTO   A046
0A032:  MOVLB  1
0A034:  MOVF   xDF,W
0A036:  MOVLB  2
0A038:  SUBWF  x14,W
0A03A:  BTFSS  FD8.0
0A03C:  BRA    A044
0A03E:  MOVLB  0
0A040:  GOTO   A07E
0A044:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
0A046:  MOVFF  115,2EB
0A04A:  MOVFF  114,2EA
0A04E:  MOVFF  113,2E9
0A052:  MOVFF  112,2E8
0A056:  MOVFF  217,2EF
0A05A:  MOVFF  216,2EE
0A05E:  MOVFF  215,2ED
0A062:  MOVFF  214,2EC
0A066:  CALL   4A54
0A06A:  MOVLW  10
0A06C:  MOVLB  2
0A06E:  ADDWF  x15,F
0A070:  MOVLW  00
0A072:  ADDWFC x16,F
0A074:  MOVLW  00
0A076:  ADDWFC x17,F
0A078:  MOVLB  0
0A07A:  GOTO   9F8A
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
0A07E:  MOVFF  1EA,21B
0A082:  MOVFF  1E9,21A
0A086:  MOVFF  1E8,219
0A08A:  MOVFF  1E7,218
0A08E:  MOVFF  1E6,21F
0A092:  MOVFF  1E5,21E
0A096:  MOVFF  1E4,21D
0A09A:  MOVFF  1E3,21C
....................     while (remaining > 0)
0A09E:  MOVLB  2
0A0A0:  MOVF   x18,F
0A0A2:  BTFSC  FD8.2
0A0A4:  BRA    A0AC
0A0A6:  MOVLB  0
0A0A8:  GOTO   A0DE
0A0AC:  MOVLB  0
0A0AE:  MOVLB  2
0A0B0:  MOVF   x19,F
0A0B2:  BTFSC  FD8.2
0A0B4:  BRA    A0BC
0A0B6:  MOVLB  0
0A0B8:  GOTO   A0DE
0A0BC:  MOVLB  0
0A0BE:  MOVLB  2
0A0C0:  MOVF   x1A,F
0A0C2:  BTFSC  FD8.2
0A0C4:  BRA    A0CC
0A0C6:  MOVLB  0
0A0C8:  GOTO   A0DE
0A0CC:  MOVLB  0
0A0CE:  MOVLB  2
0A0D0:  MOVF   x1B,F
0A0D2:  BTFSS  FD8.2
0A0D4:  BRA    A0DC
0A0D6:  MOVLB  0
0A0D8:  GOTO   A29C
0A0DC:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
0A0DE:  MOVLB  2
0A0E0:  MOVF   x1B,F
0A0E2:  BTFSC  FD8.2
0A0E4:  BRA    A0EC
0A0E6:  MOVLB  0
0A0E8:  GOTO   A120
0A0EC:  MOVLB  0
0A0EE:  MOVLB  2
0A0F0:  MOVF   x1A,F
0A0F2:  BTFSC  FD8.2
0A0F4:  BRA    A0FC
0A0F6:  MOVLB  0
0A0F8:  GOTO   A120
0A0FC:  MOVLB  0
0A0FE:  MOVLB  2
0A100:  MOVF   x19,F
0A102:  BTFSC  FD8.2
0A104:  BRA    A10C
0A106:  MOVLB  0
0A108:  GOTO   A120
0A10C:  MOVLB  0
0A10E:  MOVLB  2
0A110:  MOVF   x18,W
0A112:  SUBLW  40
0A114:  BTFSS  FD8.0
0A116:  BRA    A11E
0A118:  MOVLB  0
0A11A:  GOTO   A128
0A11E:  MOVLB  0
0A120:  CLRF   03
0A122:  MOVLW  40
0A124:  GOTO   A132
0A128:  MOVFF  219,03
0A12C:  MOVLB  2
0A12E:  MOVF   x18,W
0A130:  MOVLB  0
0A132:  MOVLB  2
0A134:  MOVWF  x60
0A136:  MOVFF  03,261
0A13A:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
0A13C:  MOVFF  111,2EB
0A140:  MOVFF  110,2EA
0A144:  MOVFF  10F,2E9
0A148:  MOVFF  10E,2E8
0A14C:  MOVFF  21F,2EF
0A150:  MOVFF  21E,2EE
0A154:  MOVFF  21D,2ED
0A158:  MOVFF  21C,2EC
0A15C:  MOVLW  02
0A15E:  MOVLB  2
0A160:  MOVWF  xF1
0A162:  MOVLW  20
0A164:  MOVWF  xF0
0A166:  CLRF   xF5
0A168:  CLRF   xF4
0A16A:  MOVFF  261,2F3
0A16E:  MOVFF  260,2F2
0A172:  MOVLB  0
0A174:  CALL   27C6
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
0A178:  MOVFF  115,A5F
0A17C:  MOVFF  114,A5E
0A180:  MOVFF  113,A5D
0A184:  MOVFF  112,A5C
0A188:  MOVFF  207,A63
0A18C:  MOVFF  206,A62
0A190:  MOVFF  205,A61
0A194:  MOVFF  204,A60
0A198:  MOVLW  02
0A19A:  MOVLB  A
0A19C:  MOVWF  x65
0A19E:  MOVLW  20
0A1A0:  MOVWF  x64
0A1A2:  MOVFF  261,A67
0A1A6:  MOVFF  260,A66
0A1AA:  MOVLB  0
0A1AC:  CALL   34E0
....................         for (unsigned int32 i = 0; i < chunk; i++)
0A1B0:  MOVLB  2
0A1B2:  CLRF   x65
0A1B4:  CLRF   x64
0A1B6:  CLRF   x63
0A1B8:  CLRF   x62
0A1BA:  MOVLB  0
0A1BC:  MOVLB  2
0A1BE:  MOVF   x65,F
0A1C0:  BTFSC  FD8.2
0A1C2:  BRA    A1CA
0A1C4:  MOVLB  0
0A1C6:  GOTO   A24C
0A1CA:  MOVLB  0
0A1CC:  MOVLB  2
0A1CE:  MOVF   x64,F
0A1D0:  BTFSC  FD8.2
0A1D2:  BRA    A1DA
0A1D4:  MOVLB  0
0A1D6:  GOTO   A24C
0A1DA:  MOVLB  0
0A1DC:  MOVLB  2
0A1DE:  MOVF   x63,W
0A1E0:  SUBWF  x61,W
0A1E2:  BTFSC  FD8.0
0A1E4:  BRA    A1EC
0A1E6:  MOVLB  0
0A1E8:  GOTO   A24C
0A1EC:  MOVLB  0
0A1EE:  BTFSS  FD8.2
0A1F0:  GOTO   A206
0A1F4:  MOVLB  2
0A1F6:  MOVF   x60,W
0A1F8:  SUBWF  x62,W
0A1FA:  BTFSS  FD8.0
0A1FC:  BRA    A204
0A1FE:  MOVLB  0
0A200:  GOTO   A24C
0A204:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A206:  MOVLW  20
0A208:  MOVLB  2
0A20A:  ADDWF  x62,W
0A20C:  MOVWF  FE9
0A20E:  MOVLW  02
0A210:  ADDWFC x63,W
0A212:  MOVWF  FEA
0A214:  MOVFF  FEF,266
0A218:  MOVFF  266,9CC
0A21C:  MOVLW  37
0A21E:  MOVLB  9
0A220:  MOVWF  xCD
0A222:  MOVLB  0
0A224:  CALL   1E44
0A228:  MOVLW  20
0A22A:  MOVLB  A
0A22C:  MOVWF  xB3
0A22E:  MOVLB  0
0A230:  CALL   1B6E
0A234:  MOVLW  01
0A236:  MOVLB  2
0A238:  ADDWF  x62,F
0A23A:  BTFSC  FD8.0
0A23C:  INCF   x63,F
0A23E:  BTFSC  FD8.2
0A240:  INCF   x64,F
0A242:  BTFSC  FD8.2
0A244:  INCF   x65,F
0A246:  MOVLB  0
0A248:  GOTO   A1BC
....................         }
....................         src_addr += chunk;
0A24C:  MOVLB  2
0A24E:  MOVF   x60,W
0A250:  ADDWF  x1C,F
0A252:  MOVF   x61,W
0A254:  ADDWFC x1D,F
0A256:  MOVLW  00
0A258:  ADDWFC x1E,F
0A25A:  MOVLW  00
0A25C:  ADDWFC x1F,F
....................         data_write_addr += chunk;
0A25E:  MOVF   x60,W
0A260:  ADDWF  x04,F
0A262:  MOVF   x61,W
0A264:  ADDWFC x05,F
0A266:  MOVLW  00
0A268:  ADDWFC x06,F
0A26A:  MOVLW  00
0A26C:  ADDWFC x07,F
....................         used_size += chunk;
0A26E:  MOVF   x60,W
0A270:  MOVLB  1
0A272:  ADDWF  xF3,F
0A274:  MOVLB  2
0A276:  MOVF   x61,W
0A278:  MOVLB  1
0A27A:  ADDWFC xF4,F
0A27C:  MOVLW  00
0A27E:  ADDWFC xF5,F
0A280:  MOVLW  00
0A282:  ADDWFC xF6,F
....................         remaining -= chunk;
0A284:  MOVLB  2
0A286:  MOVF   x60,W
0A288:  SUBWF  x18,F
0A28A:  MOVF   x61,W
0A28C:  SUBWFB x19,F
0A28E:  MOVLW  00
0A290:  SUBWFB x1A,F
0A292:  MOVLW  00
0A294:  SUBWFB x1B,F
0A296:  MOVLB  0
0A298:  GOTO   A09E
....................     }
....................     // write size area
....................     write_smf_header();
0A29C:  GOTO   9870
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0A2A0:  MOVLB  1
0A2A2:  MOVF   x91,W
0A2A4:  MOVWF  FE9
0A2A6:  MOVF   x92,W
0A2A8:  MOVWF  FEA
0A2AA:  MOVFF  FEF,266
0A2AE:  MOVFF  266,267
0A2B2:  MOVFF  1EA,26B
0A2B6:  MOVFF  1E9,26A
0A2BA:  MOVFF  1E8,269
0A2BE:  MOVFF  1E7,268
0A2C2:  MOVLB  0
0A2C4:  GOTO   9A00
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0A2C8:  MOVLW  C6
0A2CA:  MOVWF  FF6
0A2CC:  MOVLW  08
0A2CE:  MOVWF  FF7
0A2D0:  MOVLW  00
0A2D2:  MOVWF  FF8
0A2D4:  MOVLW  0C
0A2D6:  MOVLB  9
0A2D8:  MOVWF  xCC
0A2DA:  MOVLB  0
0A2DC:  CALL   1BF0
0A2E0:  MOVLW  41
0A2E2:  MOVWF  FE9
0A2E4:  MOVFF  1F6,269
0A2E8:  MOVFF  1F5,268
0A2EC:  MOVFF  1F4,267
0A2F0:  MOVFF  1F3,266
0A2F4:  CALL   9242
0A2F8:  MOVLW  0D
0A2FA:  MOVLB  A
0A2FC:  MOVWF  xB3
0A2FE:  MOVLB  0
0A300:  CALL   1B6E
0A304:  MOVLW  0A
0A306:  MOVLB  A
0A308:  MOVWF  xB3
0A30A:  MOVLB  0
0A30C:  CALL   1B6E
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0A310:  MOVLW  D8
0A312:  MOVWF  FF6
0A314:  MOVLW  08
0A316:  MOVWF  FF7
0A318:  MOVLW  00
0A31A:  MOVWF  FF8
0A31C:  MOVLW  0D
0A31E:  MOVLB  9
0A320:  MOVWF  xCC
0A322:  MOVLB  0
0A324:  CALL   1BF0
0A328:  MOVFF  1F7,26A
0A32C:  MOVLW  1B
0A32E:  MOVLB  2
0A330:  MOVWF  x6B
0A332:  MOVLB  0
0A334:  CALL   66D0
0A338:  MOVLW  E7
0A33A:  MOVWF  FF6
0A33C:  MOVLW  08
0A33E:  MOVWF  FF7
0A340:  MOVLW  00
0A342:  MOVWF  FF8
0A344:  MOVLW  04
0A346:  MOVLB  9
0A348:  MOVWF  xCC
0A34A:  MOVLB  0
0A34C:  CALL   1BF0
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0A350:  MOVLW  EC
0A352:  MOVWF  FF6
0A354:  MOVLW  08
0A356:  MOVWF  FF7
0A358:  MOVLW  00
0A35A:  MOVWF  FF8
0A35C:  CALL   1BC0
....................     fprintf(PC, "____________________\r\n\r\n");
0A360:  MOVLW  06
0A362:  MOVWF  FF6
0A364:  MOVLW  09
0A366:  MOVWF  FF7
0A368:  MOVLW  00
0A36A:  MOVWF  FF8
0A36C:  CALL   1BC0
0A370:  GOTO   AF46 (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0A474:  MOVLW  20
0A476:  MOVWF  FF6
0A478:  MOVLW  09
0A47A:  MOVWF  FF7
0A47C:  MOVLW  00
0A47E:  MOVWF  FF8
0A480:  CALL   1BC0
....................     fprintf(PC, "___Start SMF Read____\r\n");
0A484:  MOVLW  3A
0A486:  MOVWF  FF6
0A488:  MOVLW  09
0A48A:  MOVWF  FF7
0A48C:  MOVLW  00
0A48E:  MOVWF  FF8
0A490:  CALL   1BC0
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0A494:  MOVLB  1
0A496:  MOVF   x91,W
0A498:  MOVWF  FE9
0A49A:  MOVF   x92,W
0A49C:  MOVWF  FEA
0A49E:  MOVFF  FEF,1EB
0A4A2:  MOVFF  1EB,26D
0A4A6:  MOVLB  0
0A4A8:  CALL   93BE
0A4AC:  MOVFF  02,03
0A4B0:  MOVF   01,W
0A4B2:  MOVWF  FE1
0A4B4:  MOVFF  03,FE2
0A4B8:  MOVLW  01
0A4BA:  MOVWF  FEA
0A4BC:  MOVLW  D3
0A4BE:  MOVWF  FE9
0A4C0:  MOVLW  08
0A4C2:  MOVWF  01
0A4C4:  MOVFF  FE6,FEE
0A4C8:  DECFSZ 01,F
0A4CA:  GOTO   A4C4
0A4CE:  MOVLW  04
0A4D0:  MOVLB  1
0A4D2:  ADDWF  x91,W
0A4D4:  MOVWF  FE9
0A4D6:  MOVLW  00
0A4D8:  ADDWFC x92,W
0A4DA:  MOVWF  FEA
0A4DC:  MOVFF  FEF,1DB
0A4E0:  MOVFF  FEC,1DC
0A4E4:  MOVFF  FEC,1DD
0A4E8:  MOVFF  FEC,1DE
0A4EC:  MOVF   FED,F
0A4EE:  MOVF   FED,F
0A4F0:  MOVF   FED,F
0A4F2:  MOVLW  08
0A4F4:  ADDWF  x91,W
0A4F6:  MOVWF  FE9
0A4F8:  MOVLW  00
0A4FA:  ADDWFC x92,W
0A4FC:  MOVWF  FEA
0A4FE:  MOVFF  FEF,1DF
0A502:  MOVFF  FEC,1E0
0A506:  MOVFF  FEC,1E1
0A50A:  MOVFF  FEC,1E2
0A50E:  MOVF   FED,F
0A510:  MOVF   FED,F
0A512:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0A514:  MOVLW  52
0A516:  MOVWF  FF6
0A518:  MOVLW  09
0A51A:  MOVWF  FF7
0A51C:  MOVLW  00
0A51E:  MOVWF  FF8
0A520:  MOVLW  21
0A522:  MOVLB  9
0A524:  MOVWF  xCC
0A526:  MOVLB  0
0A528:  CALL   1BF0
0A52C:  MOVFF  1DE,9CC
0A530:  MOVLW  37
0A532:  MOVLB  9
0A534:  MOVWF  xCD
0A536:  MOVLB  0
0A538:  CALL   1E44
0A53C:  MOVFF  1DD,9CC
0A540:  MOVLW  37
0A542:  MOVLB  9
0A544:  MOVWF  xCD
0A546:  MOVLB  0
0A548:  CALL   1E44
0A54C:  MOVFF  1DC,9CC
0A550:  MOVLW  37
0A552:  MOVLB  9
0A554:  MOVWF  xCD
0A556:  MOVLB  0
0A558:  CALL   1E44
0A55C:  MOVFF  1DB,9CC
0A560:  MOVLW  37
0A562:  MOVLB  9
0A564:  MOVWF  xCD
0A566:  MOVLB  0
0A568:  CALL   1E44
0A56C:  MOVLW  0D
0A56E:  MOVLB  A
0A570:  MOVWF  xB3
0A572:  MOVLB  0
0A574:  CALL   1B6E
0A578:  MOVLW  0A
0A57A:  MOVLB  A
0A57C:  MOVWF  xB3
0A57E:  MOVLB  0
0A580:  CALL   1B6E
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0A584:  MOVLW  7A
0A586:  MOVWF  FF6
0A588:  MOVLW  09
0A58A:  MOVWF  FF7
0A58C:  MOVLW  00
0A58E:  MOVWF  FF8
0A590:  MOVLW  21
0A592:  MOVLB  9
0A594:  MOVWF  xCC
0A596:  MOVLB  0
0A598:  CALL   1BF0
0A59C:  MOVLW  41
0A59E:  MOVWF  FE9
0A5A0:  MOVFF  1E2,1EE
0A5A4:  MOVFF  1E1,1ED
0A5A8:  MOVFF  1E0,1EC
0A5AC:  MOVFF  1DF,1EB
0A5B0:  CALL   A374
0A5B4:  MOVLW  9E
0A5B6:  MOVWF  FF6
0A5B8:  MOVLW  09
0A5BA:  MOVWF  FF7
0A5BC:  MOVLW  00
0A5BE:  MOVWF  FF8
0A5C0:  MOVLW  04
0A5C2:  MOVLB  9
0A5C4:  MOVWF  xCC
0A5C6:  MOVLB  0
0A5C8:  CALL   1BF0
0A5CC:  MOVFF  1E2,9CC
0A5D0:  MOVLW  57
0A5D2:  MOVLB  9
0A5D4:  MOVWF  xCD
0A5D6:  MOVLB  0
0A5D8:  CALL   1E44
0A5DC:  MOVFF  1E1,9CC
0A5E0:  MOVLW  57
0A5E2:  MOVLB  9
0A5E4:  MOVWF  xCD
0A5E6:  MOVLB  0
0A5E8:  CALL   1E44
0A5EC:  MOVFF  1E0,9CC
0A5F0:  MOVLW  57
0A5F2:  MOVLB  9
0A5F4:  MOVWF  xCD
0A5F6:  MOVLB  0
0A5F8:  CALL   1E44
0A5FC:  MOVFF  1DF,9CC
0A600:  MOVLW  57
0A602:  MOVLB  9
0A604:  MOVWF  xCD
0A606:  MOVLB  0
0A608:  CALL   1E44
0A60C:  MOVLW  A5
0A60E:  MOVWF  FF6
0A610:  MOVLW  09
0A612:  MOVWF  FF7
0A614:  MOVLW  00
0A616:  MOVWF  FF8
0A618:  MOVLW  05
0A61A:  MOVLB  9
0A61C:  MOVWF  xCC
0A61E:  MOVLB  0
0A620:  CALL   1BF0
.................... 
....................     if (!is_connect(smf)){
0A624:  MOVFF  115,269
0A628:  MOVFF  114,268
0A62C:  MOVFF  113,267
0A630:  MOVFF  112,266
0A634:  CALL   26DA
0A638:  MOVF   01,F
0A63A:  BTFSS  FD8.2
0A63C:  GOTO   A650
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A640:  MOVLW  AC
0A642:  MOVWF  FF6
0A644:  MOVLW  09
0A646:  MOVWF  FF7
0A648:  MOVLW  00
0A64A:  MOVWF  FF8
0A64C:  CALL   1BC0
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0A650:  MOVLW  CA
0A652:  MOVWF  FF6
0A654:  MOVLW  09
0A656:  MOVWF  FF7
0A658:  MOVLW  00
0A65A:  MOVWF  FF8
0A65C:  CALL   1BC0
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0A660:  MOVFF  1DE,1E6
0A664:  MOVFF  1DD,1E5
0A668:  MOVFF  1DC,1E4
0A66C:  MOVFF  1DB,1E3
0A670:  MOVLB  1
0A672:  MOVF   xDF,W
0A674:  ADDWF  xDB,W
0A676:  MOVWF  00
0A678:  MOVF   xE0,W
0A67A:  ADDWFC xDC,W
0A67C:  MOVWF  01
0A67E:  MOVF   xE1,W
0A680:  ADDWFC xDD,W
0A682:  MOVWF  02
0A684:  MOVF   xE2,W
0A686:  ADDWFC xDE,W
0A688:  MOVWF  03
0A68A:  MOVF   xE6,W
0A68C:  SUBWF  03,W
0A68E:  BTFSC  FD8.0
0A690:  BRA    A698
0A692:  MOVLB  0
0A694:  GOTO   A7E0
0A698:  MOVLB  0
0A69A:  BTFSS  FD8.2
0A69C:  GOTO   A6E2
0A6A0:  MOVLB  1
0A6A2:  MOVF   xE5,W
0A6A4:  SUBWF  02,W
0A6A6:  BTFSC  FD8.0
0A6A8:  BRA    A6B0
0A6AA:  MOVLB  0
0A6AC:  GOTO   A7E0
0A6B0:  MOVLB  0
0A6B2:  BTFSS  FD8.2
0A6B4:  GOTO   A6E2
0A6B8:  MOVLB  1
0A6BA:  MOVF   xE4,W
0A6BC:  SUBWF  01,W
0A6BE:  BTFSC  FD8.0
0A6C0:  BRA    A6C8
0A6C2:  MOVLB  0
0A6C4:  GOTO   A7E0
0A6C8:  MOVLB  0
0A6CA:  BTFSS  FD8.2
0A6CC:  GOTO   A6E2
0A6D0:  MOVF   00,W
0A6D2:  MOVLB  1
0A6D4:  SUBWF  xE3,W
0A6D6:  BTFSS  FD8.0
0A6D8:  BRA    A6E0
0A6DA:  MOVLB  0
0A6DC:  GOTO   A7E0
0A6E0:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0A6E2:  MOVFF  115,2EB
0A6E6:  MOVFF  114,2EA
0A6EA:  MOVFF  113,2E9
0A6EE:  MOVFF  112,2E8
0A6F2:  MOVFF  1E6,2EF
0A6F6:  MOVFF  1E5,2EE
0A6FA:  MOVFF  1E4,2ED
0A6FE:  MOVFF  1E3,2EC
0A702:  MOVLW  01
0A704:  MOVLB  2
0A706:  MOVWF  xF1
0A708:  MOVLW  93
0A70A:  MOVWF  xF0
0A70C:  CLRF   xF5
0A70E:  CLRF   xF4
0A710:  CLRF   xF3
0A712:  MOVLW  40
0A714:  MOVWF  xF2
0A716:  MOVLB  0
0A718:  CALL   27C6
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0A71C:  MOVLB  1
0A71E:  CLRF   xEA
0A720:  CLRF   xE9
0A722:  CLRF   xE8
0A724:  CLRF   xE7
0A726:  MOVLB  0
0A728:  MOVLB  1
0A72A:  MOVF   xEA,F
0A72C:  BTFSC  FD8.2
0A72E:  BRA    A736
0A730:  MOVLB  0
0A732:  GOTO   A7B0
0A736:  MOVLB  0
0A738:  MOVLB  1
0A73A:  MOVF   xE9,F
0A73C:  BTFSC  FD8.2
0A73E:  BRA    A746
0A740:  MOVLB  0
0A742:  GOTO   A7B0
0A746:  MOVLB  0
0A748:  MOVLB  1
0A74A:  MOVF   xE8,F
0A74C:  BTFSC  FD8.2
0A74E:  BRA    A756
0A750:  MOVLB  0
0A752:  GOTO   A7B0
0A756:  MOVLB  0
0A758:  MOVLB  1
0A75A:  MOVF   xE7,W
0A75C:  SUBLW  3F
0A75E:  BTFSC  FD8.0
0A760:  BRA    A768
0A762:  MOVLB  0
0A764:  GOTO   A7B0
0A768:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A76A:  MOVLW  93
0A76C:  MOVLB  1
0A76E:  ADDWF  xE7,W
0A770:  MOVWF  FE9
0A772:  MOVLW  01
0A774:  ADDWFC xE8,W
0A776:  MOVWF  FEA
0A778:  MOVFF  FEF,1EB
0A77C:  MOVFF  1EB,9CC
0A780:  MOVLW  37
0A782:  MOVLB  9
0A784:  MOVWF  xCD
0A786:  MOVLB  0
0A788:  CALL   1E44
0A78C:  MOVLW  20
0A78E:  MOVLB  A
0A790:  MOVWF  xB3
0A792:  MOVLB  0
0A794:  CALL   1B6E
0A798:  MOVLW  01
0A79A:  MOVLB  1
0A79C:  ADDWF  xE7,F
0A79E:  BTFSC  FD8.0
0A7A0:  INCF   xE8,F
0A7A2:  BTFSC  FD8.2
0A7A4:  INCF   xE9,F
0A7A6:  BTFSC  FD8.2
0A7A8:  INCF   xEA,F
0A7AA:  MOVLB  0
0A7AC:  GOTO   A728
....................         }
....................         fprintf(PC, "\r\n");
0A7B0:  MOVLW  0D
0A7B2:  MOVLB  A
0A7B4:  MOVWF  xB3
0A7B6:  MOVLB  0
0A7B8:  CALL   1B6E
0A7BC:  MOVLW  0A
0A7BE:  MOVLB  A
0A7C0:  MOVWF  xB3
0A7C2:  MOVLB  0
0A7C4:  CALL   1B6E
0A7C8:  MOVLW  40
0A7CA:  MOVLB  1
0A7CC:  ADDWF  xE3,F
0A7CE:  MOVLW  00
0A7D0:  ADDWFC xE4,F
0A7D2:  MOVLW  00
0A7D4:  ADDWFC xE5,F
0A7D6:  MOVLW  00
0A7D8:  ADDWFC xE6,F
0A7DA:  MOVLB  0
0A7DC:  GOTO   A670
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0A7E0:  MOVLW  E2
0A7E2:  MOVWF  FF6
0A7E4:  MOVLW  09
0A7E6:  MOVWF  FF7
0A7E8:  MOVLW  00
0A7EA:  MOVWF  FF8
0A7EC:  CALL   1BC0
....................     fprintf(PC, "____________________\r\n\r\n");
0A7F0:  MOVLW  FA
0A7F2:  MOVWF  FF6
0A7F4:  MOVLW  09
0A7F6:  MOVWF  FF7
0A7F8:  MOVLW  00
0A7FA:  MOVWF  FF8
0A7FC:  CALL   1BC0
0A800:  GOTO   AF56 (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0A804:  MOVLW  14
0A806:  MOVWF  FF6
0A808:  MOVLW  0A
0A80A:  MOVWF  FF7
0A80C:  MOVLW  00
0A80E:  MOVWF  FF8
0A810:  CALL   1BC0
....................     fprintf(PC, "___Start smf_erase____\r\n");
0A814:  MOVLW  2E
0A816:  MOVWF  FF6
0A818:  MOVLW  0A
0A81A:  MOVWF  FF7
0A81C:  MOVLW  00
0A81E:  MOVWF  FF8
0A820:  CALL   1BC0
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0A824:  MOVLB  1
0A826:  MOVF   x91,W
0A828:  MOVWF  FE9
0A82A:  MOVF   x92,W
0A82C:  MOVWF  FEA
0A82E:  MOVFF  FEF,1A3
0A832:  MOVFF  1A3,26D
0A836:  MOVLB  0
0A838:  CALL   93BE
0A83C:  MOVFF  02,03
0A840:  MOVF   01,W
0A842:  MOVWF  FE1
0A844:  MOVFF  03,FE2
0A848:  MOVLW  01
0A84A:  MOVWF  FEA
0A84C:  MOVLW  93
0A84E:  MOVWF  FE9
0A850:  MOVLW  08
0A852:  MOVWF  01
0A854:  MOVFF  FE6,FEE
0A858:  DECFSZ 01,F
0A85A:  GOTO   A854
0A85E:  MOVLW  04
0A860:  MOVLB  1
0A862:  ADDWF  x91,W
0A864:  MOVWF  FE9
0A866:  MOVLW  00
0A868:  ADDWFC x92,W
0A86A:  MOVWF  FEA
0A86C:  MOVFF  FEF,19B
0A870:  MOVFF  FEC,19C
0A874:  MOVFF  FEC,19D
0A878:  MOVFF  FEC,19E
0A87C:  MOVF   FED,F
0A87E:  MOVF   FED,F
0A880:  MOVF   FED,F
0A882:  MOVLW  08
0A884:  ADDWF  x91,W
0A886:  MOVWF  FE9
0A888:  MOVLW  00
0A88A:  ADDWFC x92,W
0A88C:  MOVWF  FEA
0A88E:  MOVFF  FEF,19F
0A892:  MOVFF  FEC,1A0
0A896:  MOVFF  FEC,1A1
0A89A:  MOVFF  FEC,1A2
0A89E:  MOVF   FED,F
0A8A0:  MOVF   FED,F
0A8A2:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0A8A4:  MOVLW  48
0A8A6:  MOVWF  FF6
0A8A8:  MOVLW  0A
0A8AA:  MOVWF  FF7
0A8AC:  MOVLW  00
0A8AE:  MOVWF  FF8
0A8B0:  MOVLW  22
0A8B2:  MOVLB  9
0A8B4:  MOVWF  xCC
0A8B6:  MOVLB  0
0A8B8:  CALL   1BF0
0A8BC:  MOVFF  19E,9CC
0A8C0:  MOVLW  37
0A8C2:  MOVLB  9
0A8C4:  MOVWF  xCD
0A8C6:  MOVLB  0
0A8C8:  CALL   1E44
0A8CC:  MOVFF  19D,9CC
0A8D0:  MOVLW  37
0A8D2:  MOVLB  9
0A8D4:  MOVWF  xCD
0A8D6:  MOVLB  0
0A8D8:  CALL   1E44
0A8DC:  MOVFF  19C,9CC
0A8E0:  MOVLW  37
0A8E2:  MOVLB  9
0A8E4:  MOVWF  xCD
0A8E6:  MOVLB  0
0A8E8:  CALL   1E44
0A8EC:  MOVFF  19B,9CC
0A8F0:  MOVLW  37
0A8F2:  MOVLB  9
0A8F4:  MOVWF  xCD
0A8F6:  MOVLB  0
0A8F8:  CALL   1E44
0A8FC:  MOVLW  0D
0A8FE:  MOVLB  A
0A900:  MOVWF  xB3
0A902:  MOVLB  0
0A904:  CALL   1B6E
0A908:  MOVLW  0A
0A90A:  MOVLB  A
0A90C:  MOVWF  xB3
0A90E:  MOVLB  0
0A910:  CALL   1B6E
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0A914:  MOVLW  70
0A916:  MOVWF  FF6
0A918:  MOVLW  0A
0A91A:  MOVWF  FF7
0A91C:  MOVLW  00
0A91E:  MOVWF  FF8
0A920:  MOVLW  22
0A922:  MOVLB  9
0A924:  MOVWF  xCC
0A926:  MOVLB  0
0A928:  CALL   1BF0
0A92C:  MOVLW  41
0A92E:  MOVWF  FE9
0A930:  MOVFF  1A2,1EE
0A934:  MOVFF  1A1,1ED
0A938:  MOVFF  1A0,1EC
0A93C:  MOVFF  19F,1EB
0A940:  CALL   A374
0A944:  MOVLW  95
0A946:  MOVWF  FF6
0A948:  MOVLW  0A
0A94A:  MOVWF  FF7
0A94C:  MOVLW  00
0A94E:  MOVWF  FF8
0A950:  MOVLW  04
0A952:  MOVLB  9
0A954:  MOVWF  xCC
0A956:  MOVLB  0
0A958:  CALL   1BF0
0A95C:  MOVFF  1A2,9CC
0A960:  MOVLW  57
0A962:  MOVLB  9
0A964:  MOVWF  xCD
0A966:  MOVLB  0
0A968:  CALL   1E44
0A96C:  MOVFF  1A1,9CC
0A970:  MOVLW  57
0A972:  MOVLB  9
0A974:  MOVWF  xCD
0A976:  MOVLB  0
0A978:  CALL   1E44
0A97C:  MOVFF  1A0,9CC
0A980:  MOVLW  57
0A982:  MOVLB  9
0A984:  MOVWF  xCD
0A986:  MOVLB  0
0A988:  CALL   1E44
0A98C:  MOVFF  19F,9CC
0A990:  MOVLW  57
0A992:  MOVLB  9
0A994:  MOVWF  xCD
0A996:  MOVLB  0
0A998:  CALL   1E44
0A99C:  MOVLW  9C
0A99E:  MOVWF  FF6
0A9A0:  MOVLW  0A
0A9A2:  MOVWF  FF7
0A9A4:  MOVLW  00
0A9A6:  MOVWF  FF8
0A9A8:  MOVLW  05
0A9AA:  MOVLB  9
0A9AC:  MOVWF  xCC
0A9AE:  MOVLB  0
0A9B0:  CALL   1BF0
.................... 
....................     if (!is_connect(smf)){
0A9B4:  MOVFF  115,269
0A9B8:  MOVFF  114,268
0A9BC:  MOVFF  113,267
0A9C0:  MOVFF  112,266
0A9C4:  CALL   26DA
0A9C8:  MOVF   01,F
0A9CA:  BTFSS  FD8.2
0A9CC:  GOTO   A9E4
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A9D0:  MOVLW  A2
0A9D2:  MOVWF  FF6
0A9D4:  MOVLW  0A
0A9D6:  MOVWF  FF7
0A9D8:  MOVLW  00
0A9DA:  MOVWF  FF8
0A9DC:  CALL   1BC0
....................         return;
0A9E0:  GOTO   AD1E
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0A9E4:  MOVLB  1
0A9E6:  MOVF   x9E,W
0A9E8:  SUBWF  x96,W
0A9EA:  BTFSC  FD8.0
0A9EC:  BRA    A9F4
0A9EE:  MOVLB  0
0A9F0:  GOTO   AA3E
0A9F4:  MOVLB  0
0A9F6:  BTFSS  FD8.2
0A9F8:  GOTO   AA98
0A9FC:  MOVLB  1
0A9FE:  MOVF   x9D,W
0AA00:  SUBWF  x95,W
0AA02:  BTFSC  FD8.0
0AA04:  BRA    AA0C
0AA06:  MOVLB  0
0AA08:  GOTO   AA3E
0AA0C:  MOVLB  0
0AA0E:  BTFSS  FD8.2
0AA10:  GOTO   AA98
0AA14:  MOVLB  1
0AA16:  MOVF   x9C,W
0AA18:  SUBWF  x94,W
0AA1A:  BTFSC  FD8.0
0AA1C:  BRA    AA24
0AA1E:  MOVLB  0
0AA20:  GOTO   AA3E
0AA24:  MOVLB  0
0AA26:  BTFSS  FD8.2
0AA28:  GOTO   AA98
0AA2C:  MOVLB  1
0AA2E:  MOVF   x93,W
0AA30:  SUBWF  x9B,W
0AA32:  BTFSC  FD8.0
0AA34:  BRA    AA3C
0AA36:  MOVLB  0
0AA38:  GOTO   AA98
0AA3C:  MOVLB  0
0AA3E:  MOVLB  1
0AA40:  MOVF   x9A,W
0AA42:  SUBWF  x9E,W
0AA44:  BTFSC  FD8.0
0AA46:  BRA    AA4E
0AA48:  MOVLB  0
0AA4A:  GOTO   ABBC
0AA4E:  MOVLB  0
0AA50:  BTFSS  FD8.2
0AA52:  GOTO   AA98
0AA56:  MOVLB  1
0AA58:  MOVF   x99,W
0AA5A:  SUBWF  x9D,W
0AA5C:  BTFSC  FD8.0
0AA5E:  BRA    AA66
0AA60:  MOVLB  0
0AA62:  GOTO   ABBC
0AA66:  MOVLB  0
0AA68:  BTFSS  FD8.2
0AA6A:  GOTO   AA98
0AA6E:  MOVLB  1
0AA70:  MOVF   x98,W
0AA72:  SUBWF  x9C,W
0AA74:  BTFSC  FD8.0
0AA76:  BRA    AA7E
0AA78:  MOVLB  0
0AA7A:  GOTO   ABBC
0AA7E:  MOVLB  0
0AA80:  BTFSS  FD8.2
0AA82:  GOTO   AA98
0AA86:  MOVLB  1
0AA88:  MOVF   x97,W
0AA8A:  SUBWF  x9B,W
0AA8C:  BTFSC  FD8.0
0AA8E:  BRA    AA96
0AA90:  MOVLB  0
0AA92:  GOTO   ABBC
0AA96:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0AA98:  MOVLW  C0
0AA9A:  MOVWF  FF6
0AA9C:  MOVLW  0A
0AA9E:  MOVWF  FF7
0AAA0:  MOVLW  00
0AAA2:  MOVWF  FF8
0AAA4:  MOVLW  1E
0AAA6:  MOVLB  9
0AAA8:  MOVWF  xCC
0AAAA:  MOVLB  0
0AAAC:  CALL   1BF0
0AAB0:  MOVFF  19E,9CC
0AAB4:  MOVLW  37
0AAB6:  MOVLB  9
0AAB8:  MOVWF  xCD
0AABA:  MOVLB  0
0AABC:  CALL   1E44
0AAC0:  MOVFF  19D,9CC
0AAC4:  MOVLW  37
0AAC6:  MOVLB  9
0AAC8:  MOVWF  xCD
0AACA:  MOVLB  0
0AACC:  CALL   1E44
0AAD0:  MOVFF  19C,9CC
0AAD4:  MOVLW  37
0AAD6:  MOVLB  9
0AAD8:  MOVWF  xCD
0AADA:  MOVLB  0
0AADC:  CALL   1E44
0AAE0:  MOVFF  19B,9CC
0AAE4:  MOVLW  37
0AAE6:  MOVLB  9
0AAE8:  MOVWF  xCD
0AAEA:  MOVLB  0
0AAEC:  CALL   1E44
0AAF0:  MOVLW  E1
0AAF2:  MOVWF  FF6
0AAF4:  MOVLW  0A
0AAF6:  MOVWF  FF7
0AAF8:  MOVLW  00
0AAFA:  MOVWF  FF8
0AAFC:  MOVLW  1D
0AAFE:  MOVLB  9
0AB00:  MOVWF  xCC
0AB02:  MOVLB  0
0AB04:  CALL   1BF0
0AB08:  MOVFF  196,9CC
0AB0C:  MOVLW  37
0AB0E:  MOVLB  9
0AB10:  MOVWF  xCD
0AB12:  MOVLB  0
0AB14:  CALL   1E44
0AB18:  MOVFF  195,9CC
0AB1C:  MOVLW  37
0AB1E:  MOVLB  9
0AB20:  MOVWF  xCD
0AB22:  MOVLB  0
0AB24:  CALL   1E44
0AB28:  MOVFF  194,9CC
0AB2C:  MOVLW  37
0AB2E:  MOVLB  9
0AB30:  MOVWF  xCD
0AB32:  MOVLB  0
0AB34:  CALL   1E44
0AB38:  MOVFF  193,9CC
0AB3C:  MOVLW  37
0AB3E:  MOVLB  9
0AB40:  MOVWF  xCD
0AB42:  MOVLB  0
0AB44:  CALL   1E44
0AB48:  MOVLW  01
0AB4A:  MOVWF  FF6
0AB4C:  MOVLW  0B
0AB4E:  MOVWF  FF7
0AB50:  MOVLW  00
0AB52:  MOVWF  FF8
0AB54:  MOVLW  05
0AB56:  MOVLB  9
0AB58:  MOVWF  xCC
0AB5A:  MOVLB  0
0AB5C:  CALL   1BF0
0AB60:  MOVFF  19A,9CC
0AB64:  MOVLW  37
0AB66:  MOVLB  9
0AB68:  MOVWF  xCD
0AB6A:  MOVLB  0
0AB6C:  CALL   1E44
0AB70:  MOVFF  199,9CC
0AB74:  MOVLW  37
0AB76:  MOVLB  9
0AB78:  MOVWF  xCD
0AB7A:  MOVLB  0
0AB7C:  CALL   1E44
0AB80:  MOVFF  198,9CC
0AB84:  MOVLW  37
0AB86:  MOVLB  9
0AB88:  MOVWF  xCD
0AB8A:  MOVLB  0
0AB8C:  CALL   1E44
0AB90:  MOVFF  197,9CC
0AB94:  MOVLW  37
0AB96:  MOVLB  9
0AB98:  MOVWF  xCD
0AB9A:  MOVLB  0
0AB9C:  CALL   1E44
0ABA0:  MOVLW  09
0ABA2:  MOVWF  FF6
0ABA4:  MOVLW  0B
0ABA6:  MOVWF  FF7
0ABA8:  MOVLW  00
0ABAA:  MOVWF  FF8
0ABAC:  MOVLW  03
0ABAE:  MOVLB  9
0ABB0:  MOVWF  xCC
0ABB2:  MOVLB  0
0ABB4:  CALL   1BF0
....................         return;
0ABB8:  GOTO   AD1E
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0ABBC:  MOVLB  1
0ABBE:  MOVF   x9F,W
0ABC0:  ADDWF  x9B,W
0ABC2:  MOVWF  xA3
0ABC4:  MOVF   xA0,W
0ABC6:  ADDWFC x9C,W
0ABC8:  MOVWF  xA4
0ABCA:  MOVF   xA1,W
0ABCC:  ADDWFC x9D,W
0ABCE:  MOVWF  xA5
0ABD0:  MOVF   xA2,W
0ABD2:  ADDWFC x9E,W
0ABD4:  MOVWF  xA6
0ABD6:  MOVF   x9A,W
0ABD8:  SUBWF  xA6,W
0ABDA:  BTFSC  FD8.0
0ABDC:  BRA    ABE4
0ABDE:  MOVLB  0
0ABE0:  GOTO   ACCA
0ABE4:  MOVLB  0
0ABE6:  BTFSS  FD8.2
0ABE8:  GOTO   AC2E
0ABEC:  MOVLB  1
0ABEE:  MOVF   x99,W
0ABF0:  SUBWF  xA5,W
0ABF2:  BTFSC  FD8.0
0ABF4:  BRA    ABFC
0ABF6:  MOVLB  0
0ABF8:  GOTO   ACCA
0ABFC:  MOVLB  0
0ABFE:  BTFSS  FD8.2
0AC00:  GOTO   AC2E
0AC04:  MOVLB  1
0AC06:  MOVF   x98,W
0AC08:  SUBWF  xA4,W
0AC0A:  BTFSC  FD8.0
0AC0C:  BRA    AC14
0AC0E:  MOVLB  0
0AC10:  GOTO   ACCA
0AC14:  MOVLB  0
0AC16:  BTFSS  FD8.2
0AC18:  GOTO   AC2E
0AC1C:  MOVLB  1
0AC1E:  MOVF   xA3,W
0AC20:  SUBWF  x97,W
0AC22:  BTFSS  FD8.0
0AC24:  BRA    AC2C
0AC26:  MOVLB  0
0AC28:  GOTO   ACCA
0AC2C:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0AC2E:  MOVLW  0E
0AC30:  MOVWF  FF6
0AC32:  MOVLW  0B
0AC34:  MOVWF  FF7
0AC36:  MOVLW  00
0AC38:  MOVWF  FF8
0AC3A:  MOVLW  3A
0AC3C:  MOVLB  9
0AC3E:  MOVWF  xCC
0AC40:  MOVLB  0
0AC42:  CALL   1BF0
0AC46:  MOVFF  19A,9CC
0AC4A:  MOVLW  37
0AC4C:  MOVLB  9
0AC4E:  MOVWF  xCD
0AC50:  MOVLB  0
0AC52:  CALL   1E44
0AC56:  MOVFF  199,9CC
0AC5A:  MOVLW  37
0AC5C:  MOVLB  9
0AC5E:  MOVWF  xCD
0AC60:  MOVLB  0
0AC62:  CALL   1E44
0AC66:  MOVFF  198,9CC
0AC6A:  MOVLW  37
0AC6C:  MOVLB  9
0AC6E:  MOVWF  xCD
0AC70:  MOVLB  0
0AC72:  CALL   1E44
0AC76:  MOVFF  197,9CC
0AC7A:  MOVLW  37
0AC7C:  MOVLB  9
0AC7E:  MOVWF  xCD
0AC80:  MOVLB  0
0AC82:  CALL   1E44
0AC86:  MOVLW  0D
0AC88:  MOVLB  A
0AC8A:  MOVWF  xB3
0AC8C:  MOVLB  0
0AC8E:  CALL   1B6E
0AC92:  MOVLW  0A
0AC94:  MOVLB  A
0AC96:  MOVWF  xB3
0AC98:  MOVLB  0
0AC9A:  CALL   1B6E
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0AC9E:  MOVLW  4E
0ACA0:  MOVWF  FF6
0ACA2:  MOVLW  0B
0ACA4:  MOVWF  FF7
0ACA6:  MOVLW  00
0ACA8:  MOVWF  FF8
0ACAA:  CALL   1BC0
....................         erase_size = mission_type.end_address - erase_address;
0ACAE:  MOVLB  1
0ACB0:  MOVF   x9B,W
0ACB2:  SUBWF  x97,W
0ACB4:  MOVWF  x9F
0ACB6:  MOVF   x9C,W
0ACB8:  SUBWFB x98,W
0ACBA:  MOVWF  xA0
0ACBC:  MOVF   x9D,W
0ACBE:  SUBWFB x99,W
0ACC0:  MOVWF  xA1
0ACC2:  MOVF   x9E,W
0ACC4:  SUBWFB x9A,W
0ACC6:  MOVWF  xA2
0ACC8:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0ACCA:  MOVLW  82
0ACCC:  MOVWF  FF6
0ACCE:  MOVLW  0B
0ACD0:  MOVWF  FF7
0ACD2:  MOVLW  00
0ACD4:  MOVWF  FF8
0ACD6:  CALL   1BC0
....................     subsector_4kByte_erase(smf, erase_address);
0ACDA:  MOVFF  115,2EB
0ACDE:  MOVFF  114,2EA
0ACE2:  MOVFF  113,2E9
0ACE6:  MOVFF  112,2E8
0ACEA:  MOVFF  19E,2EF
0ACEE:  MOVFF  19D,2EE
0ACF2:  MOVFF  19C,2ED
0ACF6:  MOVFF  19B,2EC
0ACFA:  CALL   4A54
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0ACFE:  MOVLW  B4
0AD00:  MOVWF  FF6
0AD02:  MOVLW  0B
0AD04:  MOVWF  FF7
0AD06:  MOVLW  00
0AD08:  MOVWF  FF8
0AD0A:  CALL   1BC0
....................     fprintf(PC, "____________________\r\n\r\n");
0AD0E:  MOVLW  CE
0AD10:  MOVWF  FF6
0AD12:  MOVLW  0B
0AD14:  MOVWF  FF7
0AD16:  MOVLW  00
0AD18:  MOVWF  FF8
0AD1A:  CALL   1BC0
0AD1E:  GOTO   AF66 (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
09A00:  GOTO   A2C8 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
0986C:  GOTO   9E7C (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"                // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"             // ツールライブラリ
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/smf_queue.h"              // SMFキュー管理
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
02FE6:  MOVLW  54
02FE8:  MOVWF  FF6
02FEA:  MOVLW  0C
02FEC:  MOVWF  FF7
02FEE:  MOVLW  00
02FF0:  MOVWF  FF8
02FF2:  CALL   1BC0
....................     output_high(MIS_FM_CS);
02FF6:  MOVLW  DB
02FF8:  MOVWF  F92
02FFA:  BSF    F89.5
....................     output_high(SMF_CS);
02FFC:  MOVLW  DB
02FFE:  MOVWF  F92
03000:  BSF    F89.2
....................     delay_ms(100);
03002:  MOVLW  64
03004:  MOVLB  A
03006:  MOVWF  x74
03008:  MOVLB  0
0300A:  CALL   1B40
.................... 
....................     // 読み込みID処理 ・・・(既存そのまま)
....................     if (is_connect(mis_fm)) {
0300E:  MOVFF  111,269
03012:  MOVFF  110,268
03016:  MOVFF  10F,267
0301A:  MOVFF  10E,266
0301E:  CALL   26DA
03022:  MOVF   01,F
03024:  BTFSC  FD8.2
03026:  GOTO   303E
....................         fprintf(PC, "\t[MIS FM] Connected\r\n");
0302A:  MOVLW  70
0302C:  MOVWF  FF6
0302E:  MOVLW  0C
03030:  MOVWF  FF7
03032:  MOVLW  00
03034:  MOVWF  FF8
03036:  CALL   1BC0
....................     } else {
0303A:  GOTO   304E
....................         fprintf(PC, "\t[MIS FM] Not Connected\r\n");
0303E:  MOVLW  86
03040:  MOVWF  FF6
03042:  MOVLW  0C
03044:  MOVWF  FF7
03046:  MOVLW  00
03048:  MOVWF  FF8
0304A:  CALL   1BC0
....................     }
.................... 
....................     if (is_connect(smf)) {
0304E:  MOVFF  115,269
03052:  MOVFF  114,268
03056:  MOVFF  113,267
0305A:  MOVFF  112,266
0305E:  CALL   26DA
03062:  MOVF   01,F
03064:  BTFSC  FD8.2
03066:  GOTO   307E
....................         fprintf(PC, "\t[SMF] Connected\r\n");
0306A:  MOVLW  A0
0306C:  MOVWF  FF6
0306E:  MOVLW  0C
03070:  MOVWF  FF7
03072:  MOVLW  00
03074:  MOVWF  FF8
03076:  CALL   1BC0
....................     } else {
0307A:  GOTO   308E
....................         fprintf(PC, "\t[SMF] Not Connected\r\n");
0307E:  MOVLW  B4
03080:  MOVWF  FF6
03082:  MOVLW  0C
03084:  MOVWF  FF7
03086:  MOVLW  00
03088:  MOVWF  FF8
0308A:  CALL   1BC0
....................     }
.................... 
....................     //=== MIS_FM カウンタテーブル読出し ===//
....................     FlashData_t flash_data;
....................     memset(flash_data.bytes, 0, PACKET_SIZE);
0308E:  MOVLW  01
03090:  MOVWF  FEA
03092:  MOVLW  D9
03094:  MOVWF  FE9
03096:  CLRF   00
03098:  CLRF   02
0309A:  MOVLW  40
0309C:  MOVWF  01
0309E:  CALL   27A2
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
030A2:  MOVFF  111,2EB
030A6:  MOVFF  110,2EA
030AA:  MOVFF  10F,2E9
030AE:  MOVFF  10E,2E8
030B2:  MOVLB  2
030B4:  CLRF   xEF
030B6:  CLRF   xEE
030B8:  CLRF   xED
030BA:  CLRF   xEC
030BC:  MOVLW  01
030BE:  MOVWF  xF1
030C0:  MOVLW  D9
030C2:  MOVWF  xF0
030C4:  CLRF   xF5
030C6:  CLRF   xF4
030C8:  CLRF   xF3
030CA:  MOVLW  40
030CC:  MOVWF  xF2
030CE:  MOVLB  0
030D0:  CALL   27C6
.................... 
....................     // CRC 検証
....................     if (flash_data.packet.crc != calc_crc8(flash_data.bytes, PACKET_SIZE - 1)) {
030D4:  MOVLW  01
030D6:  MOVLB  A
030D8:  MOVWF  xB4
030DA:  MOVLW  D9
030DC:  MOVWF  xB3
030DE:  MOVLW  3F
030E0:  MOVWF  xB5
030E2:  MOVLB  0
030E4:  CALL   29E6
030E8:  MOVF   01,W
030EA:  MOVLB  2
030EC:  SUBWF  x18,W
030EE:  BTFSS  FD8.2
030F0:  BRA    30F8
030F2:  MOVLB  0
030F4:  GOTO   310A
030F8:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error -> initialize counters\r\n");
030FA:  MOVLW  CC
030FC:  MOVWF  FF6
030FE:  MOVLW  0C
03100:  MOVWF  FF7
03102:  MOVLW  00
03104:  MOVWF  FF8
03106:  CALL   1BC0
....................         // デフォルト初期化
....................         /*
....................         piclog_data.id        = FLASH_ID_PICLOG;
....................         environment_data.id   = FLASH_ID_ENVIRONMENT;
....................         iv_header.id          = FLASH_ID_IV_HEADER;
....................         iv_data.id            = FLASH_ID_IV_DATA;
....................         piclog_data.used_counter = 0;
....................         piclog_data.uncopied_counter = 0;
....................         environment_data.used_counter = 0;
....................         environment_data.uncopied_counter = 0;
....................         iv_header.used_counter = 0;
....................         iv_header.uncopied_counter = 0;
....................         iv_data.used_counter = 0;
....................         iv_data.uncopied_counter = 0;
....................         write_misf_address_area();   // 初期テーブル書込み
....................         print_flash_status();
....................         return;
....................         */
....................     }
.................... 
....................     //=== 個別コピー (キャスト禁止) ===//
....................     piclog_data.id        = FLASH_ID_PICLOG;
0310A:  MOVLB  1
0310C:  CLRF   x1E
....................     piclog_data.used_counter     = flash_data.packet.payload.logdata.piclog.used_counter;
0310E:  MOVFF  1DC,122
03112:  MOVFF  1DB,121
03116:  MOVFF  1DA,120
0311A:  MOVFF  1D9,11F
....................     piclog_data.uncopied_counter = flash_data.packet.payload.logdata.piclog.uncopied_counter;
0311E:  MOVFF  1E0,126
03122:  MOVFF  1DF,125
03126:  MOVFF  1DE,124
0312A:  MOVFF  1DD,123
....................     piclog_data.reserve_counter1 = flash_data.packet.payload.logdata.piclog.reserve_counter1;
0312E:  MOVFF  1E1,127
....................     piclog_data.reserve_counter2 = flash_data.packet.payload.logdata.piclog.reserve_counter2;
03132:  MOVFF  1E2,128
.................... 
....................     environment_data.id        = FLASH_ID_ENVIRONMENT;
03136:  MOVLW  01
03138:  MOVWF  x29
....................     environment_data.used_counter     = flash_data.packet.payload.logdata.environment.used_counter;
0313A:  MOVFF  1E6,12D
0313E:  MOVFF  1E5,12C
03142:  MOVFF  1E4,12B
03146:  MOVFF  1E3,12A
....................     environment_data.uncopied_counter = flash_data.packet.payload.logdata.environment.uncopied_counter;
0314A:  MOVFF  1EA,131
0314E:  MOVFF  1E9,130
03152:  MOVFF  1E8,12F
03156:  MOVFF  1E7,12E
....................     environment_data.reserve_counter1 = flash_data.packet.payload.logdata.environment.reserve_counter1;
0315A:  MOVFF  1EB,132
....................     environment_data.reserve_counter2 = flash_data.packet.payload.logdata.environment.reserve_counter2;
0315E:  MOVFF  1EC,133
.................... 
....................     iv_header.id        = FLASH_ID_IV_HEADER;
03162:  MOVLW  02
03164:  MOVWF  x34
....................     iv_header.used_counter     = flash_data.packet.payload.logdata.iv_header.used_counter;
03166:  MOVFF  1F0,138
0316A:  MOVFF  1EF,137
0316E:  MOVFF  1EE,136
03172:  MOVFF  1ED,135
....................     iv_header.uncopied_counter = flash_data.packet.payload.logdata.iv_header.uncopied_counter;
03176:  MOVFF  1F4,13C
0317A:  MOVFF  1F3,13B
0317E:  MOVFF  1F2,13A
03182:  MOVFF  1F1,139
....................     iv_header.reserve_counter1 = flash_data.packet.payload.logdata.iv_header.reserve_counter1;
03186:  MOVFF  1F5,13D
....................     iv_header.reserve_counter2 = flash_data.packet.payload.logdata.iv_header.reserve_counter2;
0318A:  MOVFF  1F6,13E
.................... 
....................     iv_data.id        = FLASH_ID_IV_DATA;
0318E:  MOVLW  03
03190:  MOVWF  x3F
....................     iv_data.used_counter     = flash_data.packet.payload.logdata.iv_data.used_counter;
03192:  MOVFF  1FA,143
03196:  MOVFF  1F9,142
0319A:  MOVFF  1F8,141
0319E:  MOVFF  1F7,140
....................     iv_data.uncopied_counter = flash_data.packet.payload.logdata.iv_data.uncopied_counter;
031A2:  MOVFF  1FE,147
031A6:  MOVFF  1FD,146
031AA:  MOVFF  1FC,145
031AE:  MOVFF  1FB,144
....................     iv_data.reserve_counter1 = flash_data.packet.payload.logdata.iv_data.reserve_counter1;
031B2:  MOVFF  1FF,148
....................     iv_data.reserve_counter2 = flash_data.packet.payload.logdata.iv_data.reserve_counter2;
031B6:  MOVFF  200,149
.................... 
....................     print_flash_status();
031BA:  MOVLB  0
031BC:  GOTO   2A52
031C0:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table()
.................... {
....................     FlashData_t flash_data;
....................     memset(&flash_data.bytes, 0, sizeof(flash_data.bytes));
*
03864:  MOVLW  0A
03866:  MOVWF  FEA
03868:  MOVLW  62
0386A:  MOVWF  FE9
0386C:  CLRF   00
0386E:  CLRF   02
03870:  MOVLW  40
03872:  MOVWF  01
03874:  CALL   27A2
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv_header,
....................         &flash_data.packet.payload.logdata.iv_data
....................     };
03878:  MOVLW  0A
0387A:  MOVLB  A
0387C:  MOVWF  xA3
0387E:  MOVLW  62
03880:  MOVWF  xA2
03882:  MOVLW  0A
03884:  MOVWF  xA5
03886:  MOVLW  6C
03888:  MOVWF  xA4
0388A:  MOVLW  0A
0388C:  MOVWF  xA7
0388E:  MOVLW  76
03890:  MOVWF  xA6
03892:  MOVLW  0A
03894:  MOVWF  xA9
03896:  MOVLW  80
03898:  MOVWF  xA8
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv_header,
....................         &iv_data
....................     };
0389A:  MOVLW  01
0389C:  MOVWF  xAB
0389E:  MOVLW  1E
038A0:  MOVWF  xAA
038A2:  MOVLW  01
038A4:  MOVWF  xAD
038A6:  MOVLW  29
038A8:  MOVWF  xAC
038AA:  MOVLW  01
038AC:  MOVWF  xAF
038AE:  MOVLW  34
038B0:  MOVWF  xAE
038B2:  MOVLW  01
038B4:  MOVWF  xB1
038B6:  MOVLW  3F
038B8:  MOVWF  xB0
.................... 
....................     for (int i = 0; i < 4; i++) {
038BA:  CLRF   xB2
038BC:  MOVLB  0
038BE:  MOVLB  A
038C0:  MOVF   xB2,W
038C2:  SUBLW  03
038C4:  BTFSC  FD8.0
038C6:  BRA    38CE
038C8:  MOVLB  0
038CA:  GOTO   3B82
038CE:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
038D0:  CLRF   03
038D2:  MOVLB  A
038D4:  MOVF   xB2,W
038D6:  MOVWF  02
038D8:  BCF    FD8.0
038DA:  RLCF   02,F
038DC:  RLCF   03,F
038DE:  MOVF   02,W
038E0:  ADDLW  A2
038E2:  MOVWF  01
038E4:  MOVLW  0A
038E6:  ADDWFC 03,F
038E8:  MOVF   01,W
038EA:  MOVWF  xB3
038EC:  MOVFF  03,AB4
038F0:  MOVFF  AB4,FEA
038F4:  MOVFF  AB3,FE9
038F8:  MOVFF  FEC,AB6
038FC:  MOVF   FED,F
038FE:  MOVFF  FEF,AB5
03902:  MOVF   xB5,W
03904:  MOVWF  01
03906:  MOVF   xB6,W
03908:  MOVWF  03
0390A:  MOVF   01,W
0390C:  MOVWF  xB7
0390E:  MOVFF  03,AB8
03912:  CLRF   03
03914:  MOVF   xB2,W
03916:  MOVWF  02
03918:  BCF    FD8.0
0391A:  RLCF   02,F
0391C:  RLCF   03,F
0391E:  MOVF   02,W
03920:  ADDLW  AA
03922:  MOVWF  01
03924:  MOVLW  0A
03926:  ADDWFC 03,F
03928:  MOVF   01,W
0392A:  MOVWF  xB9
0392C:  MOVFF  03,ABA
03930:  MOVFF  ABA,FEA
03934:  MOVFF  AB9,FE9
03938:  MOVFF  FEC,ABC
0393C:  MOVF   FED,F
0393E:  MOVFF  FEF,ABB
03942:  MOVLW  01
03944:  ADDWF  xBB,W
03946:  MOVWF  FE9
03948:  MOVLW  00
0394A:  ADDWFC xBC,W
0394C:  MOVWF  FEA
0394E:  MOVFF  FEF,00
03952:  MOVFF  FEC,01
03956:  MOVFF  FEC,02
0395A:  MOVFF  FEC,03
0395E:  MOVF   FED,F
03960:  MOVF   FED,F
03962:  MOVF   FED,F
03964:  MOVFF  03,AC0
03968:  MOVFF  02,ABF
0396C:  MOVFF  01,ABE
03970:  MOVFF  00,ABD
03974:  MOVFF  AB8,FEA
03978:  MOVFF  AB7,FE9
0397C:  MOVFF  ABD,FEF
03980:  MOVFF  ABE,FEC
03984:  MOVFF  ABF,FEC
03988:  MOVFF  AC0,FEC
0398C:  MOVF   FED,F
0398E:  MOVF   FED,F
03990:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
03992:  CLRF   03
03994:  MOVF   xB2,W
03996:  MOVWF  02
03998:  BCF    FD8.0
0399A:  RLCF   02,F
0399C:  RLCF   03,F
0399E:  MOVF   02,W
039A0:  ADDLW  A2
039A2:  MOVWF  01
039A4:  MOVLW  0A
039A6:  ADDWFC 03,F
039A8:  MOVF   01,W
039AA:  MOVWF  xB3
039AC:  MOVFF  03,AB4
039B0:  MOVFF  AB4,FEA
039B4:  MOVFF  AB3,FE9
039B8:  MOVFF  FEC,AB6
039BC:  MOVF   FED,F
039BE:  MOVFF  FEF,AB5
039C2:  MOVLW  04
039C4:  ADDWF  xB5,W
039C6:  MOVWF  01
039C8:  MOVLW  00
039CA:  ADDWFC xB6,W
039CC:  MOVWF  03
039CE:  MOVF   01,W
039D0:  MOVWF  xB7
039D2:  MOVFF  03,AB8
039D6:  CLRF   03
039D8:  MOVF   xB2,W
039DA:  MOVWF  02
039DC:  BCF    FD8.0
039DE:  RLCF   02,F
039E0:  RLCF   03,F
039E2:  MOVF   02,W
039E4:  ADDLW  AA
039E6:  MOVWF  01
039E8:  MOVLW  0A
039EA:  ADDWFC 03,F
039EC:  MOVF   01,W
039EE:  MOVWF  xB9
039F0:  MOVFF  03,ABA
039F4:  MOVFF  ABA,FEA
039F8:  MOVFF  AB9,FE9
039FC:  MOVFF  FEC,ABC
03A00:  MOVF   FED,F
03A02:  MOVFF  FEF,ABB
03A06:  MOVLW  05
03A08:  ADDWF  xBB,W
03A0A:  MOVWF  FE9
03A0C:  MOVLW  00
03A0E:  ADDWFC xBC,W
03A10:  MOVWF  FEA
03A12:  MOVFF  FEF,00
03A16:  MOVFF  FEC,01
03A1A:  MOVFF  FEC,02
03A1E:  MOVFF  FEC,03
03A22:  MOVF   FED,F
03A24:  MOVF   FED,F
03A26:  MOVF   FED,F
03A28:  MOVFF  03,AC0
03A2C:  MOVFF  02,ABF
03A30:  MOVFF  01,ABE
03A34:  MOVFF  00,ABD
03A38:  MOVFF  AB8,FEA
03A3C:  MOVFF  AB7,FE9
03A40:  MOVFF  ABD,FEF
03A44:  MOVFF  ABE,FEC
03A48:  MOVFF  ABF,FEC
03A4C:  MOVFF  AC0,FEC
03A50:  MOVF   FED,F
03A52:  MOVF   FED,F
03A54:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
03A56:  CLRF   03
03A58:  MOVF   xB2,W
03A5A:  MOVWF  02
03A5C:  BCF    FD8.0
03A5E:  RLCF   02,F
03A60:  RLCF   03,F
03A62:  MOVF   02,W
03A64:  ADDLW  A2
03A66:  MOVWF  01
03A68:  MOVLW  0A
03A6A:  ADDWFC 03,F
03A6C:  MOVF   01,W
03A6E:  MOVWF  xB3
03A70:  MOVFF  03,AB4
03A74:  MOVFF  AB4,FEA
03A78:  MOVFF  AB3,FE9
03A7C:  MOVFF  FEC,AB6
03A80:  MOVF   FED,F
03A82:  MOVFF  FEF,AB5
03A86:  MOVLW  08
03A88:  ADDWF  xB5,W
03A8A:  MOVWF  01
03A8C:  MOVLW  00
03A8E:  ADDWFC xB6,W
03A90:  MOVWF  03
03A92:  MOVF   01,W
03A94:  MOVWF  xB7
03A96:  MOVFF  03,AB8
03A9A:  CLRF   03
03A9C:  MOVF   xB2,W
03A9E:  MOVWF  02
03AA0:  BCF    FD8.0
03AA2:  RLCF   02,F
03AA4:  RLCF   03,F
03AA6:  MOVF   02,W
03AA8:  ADDLW  AA
03AAA:  MOVWF  01
03AAC:  MOVLW  0A
03AAE:  ADDWFC 03,F
03AB0:  MOVF   01,W
03AB2:  MOVWF  xB9
03AB4:  MOVFF  03,ABA
03AB8:  MOVFF  ABA,FEA
03ABC:  MOVFF  AB9,FE9
03AC0:  MOVFF  FEC,ABC
03AC4:  MOVF   FED,F
03AC6:  MOVFF  FEF,ABB
03ACA:  MOVLW  09
03ACC:  ADDWF  xBB,W
03ACE:  MOVWF  FE9
03AD0:  MOVLW  00
03AD2:  ADDWFC xBC,W
03AD4:  MOVWF  FEA
03AD6:  MOVF   FEF,W
03AD8:  MOVWF  xBD
03ADA:  MOVFF  AB8,FEA
03ADE:  MOVFF  AB7,FE9
03AE2:  MOVFF  ABD,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
03AE6:  CLRF   03
03AE8:  MOVF   xB2,W
03AEA:  MOVWF  02
03AEC:  BCF    FD8.0
03AEE:  RLCF   02,F
03AF0:  RLCF   03,F
03AF2:  MOVF   02,W
03AF4:  ADDLW  A2
03AF6:  MOVWF  01
03AF8:  MOVLW  0A
03AFA:  ADDWFC 03,F
03AFC:  MOVF   01,W
03AFE:  MOVWF  xB3
03B00:  MOVFF  03,AB4
03B04:  MOVFF  AB4,FEA
03B08:  MOVFF  AB3,FE9
03B0C:  MOVFF  FEC,AB6
03B10:  MOVF   FED,F
03B12:  MOVFF  FEF,AB5
03B16:  MOVLW  09
03B18:  ADDWF  xB5,W
03B1A:  MOVWF  01
03B1C:  MOVLW  00
03B1E:  ADDWFC xB6,W
03B20:  MOVWF  03
03B22:  MOVF   01,W
03B24:  MOVWF  xB7
03B26:  MOVFF  03,AB8
03B2A:  CLRF   03
03B2C:  MOVF   xB2,W
03B2E:  MOVWF  02
03B30:  BCF    FD8.0
03B32:  RLCF   02,F
03B34:  RLCF   03,F
03B36:  MOVF   02,W
03B38:  ADDLW  AA
03B3A:  MOVWF  01
03B3C:  MOVLW  0A
03B3E:  ADDWFC 03,F
03B40:  MOVF   01,W
03B42:  MOVWF  xB9
03B44:  MOVFF  03,ABA
03B48:  MOVFF  ABA,FEA
03B4C:  MOVFF  AB9,FE9
03B50:  MOVFF  FEC,ABC
03B54:  MOVF   FED,F
03B56:  MOVFF  FEF,ABB
03B5A:  MOVLW  0A
03B5C:  ADDWF  xBB,W
03B5E:  MOVWF  FE9
03B60:  MOVLW  00
03B62:  ADDWFC xBC,W
03B64:  MOVWF  FEA
03B66:  MOVF   FEF,W
03B68:  MOVWF  xBD
03B6A:  MOVFF  AB8,FEA
03B6E:  MOVFF  AB7,FE9
03B72:  MOVFF  ABD,FEF
03B76:  MOVLB  0
03B78:  MOVLB  A
03B7A:  INCF   xB2,F
03B7C:  MOVLB  0
03B7E:  GOTO   38BE
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
03B82:  MOVLW  0A
03B84:  MOVLB  A
03B86:  MOVWF  xB4
03B88:  MOVLW  62
03B8A:  MOVWF  xB3
03B8C:  MOVLW  3F
03B8E:  MOVWF  xB5
03B90:  MOVLB  0
03B92:  CALL   29E6
03B96:  MOVFF  01,AA1
....................     // fprintf(PC, "make table\r\n");
....................     // for (int i = 0; i < PACKET_SIZE; i++) {
....................         // fprintf(PC, "%02X ", flash_data.bytes[i]);
....................     // }
....................     fprintf(PC, "\r\n");
03B9A:  MOVLW  0D
03B9C:  MOVLB  A
03B9E:  MOVWF  xB3
03BA0:  MOVLB  0
03BA2:  CALL   1B6E
03BA6:  MOVLW  0A
03BA8:  MOVLB  A
03BAA:  MOVWF  xB3
03BAC:  MOVLB  0
03BAE:  CALL   1B6E
....................     return flash_data;
03BB2:  MOVLW  62
03BB4:  MOVWF  01
03BB6:  MOVLW  0A
03BB8:  MOVWF  02
03BBA:  RETURN 0
.................... }
.................... 
.................... 
.................... void write_misf_address_area(void)
*
03F14:  CALL   3864
03F18:  MOVFF  02,03
03F1C:  MOVF   01,W
03F1E:  MOVWF  FE1
03F20:  MOVFF  03,FE2
03F24:  MOVLW  0A
03F26:  MOVWF  FEA
03F28:  MOVLW  1C
03F2A:  MOVWF  FE9
03F2C:  MOVLW  40
03F2E:  MOVWF  01
03F30:  MOVFF  FE6,FEE
03F34:  DECFSZ 01,F
03F36:  GOTO   3F30
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
....................     sector_erase(mis_fm, MISF_CIGS_DATA_TABLE_START);
03F3A:  MOVFF  111,A5F
03F3E:  MOVFF  110,A5E
03F42:  MOVFF  10F,A5D
03F46:  MOVFF  10E,A5C
03F4A:  MOVLB  A
03F4C:  CLRF   x63
03F4E:  CLRF   x62
03F50:  CLRF   x61
03F52:  CLRF   x60
03F54:  MOVLB  0
03F56:  CALL   3BBC
....................     // START に書く (以前 END だった)
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
03F5A:  MOVFF  111,A5F
03F5E:  MOVFF  110,A5E
03F62:  MOVFF  10F,A5D
03F66:  MOVFF  10E,A5C
03F6A:  MOVLB  A
03F6C:  CLRF   x63
03F6E:  CLRF   x62
03F70:  CLRF   x61
03F72:  CLRF   x60
03F74:  MOVLW  0A
03F76:  MOVWF  x65
03F78:  MOVLW  1C
03F7A:  MOVWF  x64
03F7C:  CLRF   x67
03F7E:  MOVLW  40
03F80:  MOVWF  x66
03F82:  MOVLB  0
03F84:  CALL   34E0
03F88:  RETURN 0
.................... }
.................... 
.................... // PICLOG 更新後に呼ばれる関数例 (piclog_write 内で既に write_misf_address_area 呼んでいる場合は不要)
.................... static void update_piclog_counters_after_write(unsigned int16 wrote_size)
.................... {
....................     piclog_data.used_counter     += wrote_size;
....................     piclog_data.uncopied_counter += wrote_size;
....................     // 必要なら wrap 処理追加
....................     write_misf_address_area();
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG    | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02A52:  MOVLW  FA
02A54:  MOVWF  FF6
02A56:  MOVLW  0C
02A58:  MOVWF  FF7
02A5A:  MOVLW  00
02A5C:  MOVWF  FF8
02A5E:  MOVLW  2B
02A60:  MOVLB  9
02A62:  MOVWF  xCC
02A64:  MOVLB  0
02A66:  CALL   1BF0
02A6A:  MOVFF  122,9CC
02A6E:  MOVLW  37
02A70:  MOVLB  9
02A72:  MOVWF  xCD
02A74:  MOVLB  0
02A76:  CALL   1E44
02A7A:  MOVFF  121,9CC
02A7E:  MOVLW  37
02A80:  MOVLB  9
02A82:  MOVWF  xCD
02A84:  MOVLB  0
02A86:  CALL   1E44
02A8A:  MOVFF  120,9CC
02A8E:  MOVLW  37
02A90:  MOVLB  9
02A92:  MOVWF  xCD
02A94:  MOVLB  0
02A96:  CALL   1E44
02A9A:  MOVFF  11F,9CC
02A9E:  MOVLW  37
02AA0:  MOVLB  9
02AA2:  MOVWF  xCD
02AA4:  MOVLB  0
02AA6:  CALL   1E44
02AAA:  MOVLW  0D
02AAC:  MOVLB  A
02AAE:  MOVWF  xB3
02AB0:  MOVLB  0
02AB2:  CALL   1B6E
02AB6:  MOVLW  0A
02AB8:  MOVLB  A
02ABA:  MOVWF  xB3
02ABC:  MOVLB  0
02ABE:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | PICLOG    | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02AC2:  MOVLW  2E
02AC4:  MOVWF  FF6
02AC6:  MOVLW  0D
02AC8:  MOVWF  FF7
02ACA:  MOVLW  00
02ACC:  MOVWF  FF8
02ACE:  MOVLW  2B
02AD0:  MOVLB  9
02AD2:  MOVWF  xCC
02AD4:  MOVLB  0
02AD6:  CALL   1BF0
02ADA:  MOVFF  126,9CC
02ADE:  MOVLW  37
02AE0:  MOVLB  9
02AE2:  MOVWF  xCD
02AE4:  MOVLB  0
02AE6:  CALL   1E44
02AEA:  MOVFF  125,9CC
02AEE:  MOVLW  37
02AF0:  MOVLB  9
02AF2:  MOVWF  xCD
02AF4:  MOVLB  0
02AF6:  CALL   1E44
02AFA:  MOVFF  124,9CC
02AFE:  MOVLW  37
02B00:  MOVLB  9
02B02:  MOVWF  xCD
02B04:  MOVLB  0
02B06:  CALL   1E44
02B0A:  MOVFF  123,9CC
02B0E:  MOVLW  37
02B10:  MOVLB  9
02B12:  MOVWF  xCD
02B14:  MOVLB  0
02B16:  CALL   1E44
02B1A:  MOVLW  0D
02B1C:  MOVLB  A
02B1E:  MOVWF  xB3
02B20:  MOVLB  0
02B22:  CALL   1B6E
02B26:  MOVLW  0A
02B28:  MOVLB  A
02B2A:  MOVWF  xB3
02B2C:  MOVLB  0
02B2E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02B32:  MOVLW  62
02B34:  MOVWF  FF6
02B36:  MOVLW  0D
02B38:  MOVWF  FF7
02B3A:  MOVLW  00
02B3C:  MOVWF  FF8
02B3E:  MOVLW  2B
02B40:  MOVLB  9
02B42:  MOVWF  xCC
02B44:  MOVLB  0
02B46:  CALL   1BF0
02B4A:  MOVFF  127,9CC
02B4E:  MOVLW  37
02B50:  MOVLB  9
02B52:  MOVWF  xCD
02B54:  MOVLB  0
02B56:  CALL   1E44
02B5A:  MOVLW  0D
02B5C:  MOVLB  A
02B5E:  MOVWF  xB3
02B60:  MOVLB  0
02B62:  CALL   1B6E
02B66:  MOVLW  0A
02B68:  MOVLB  A
02B6A:  MOVWF  xB3
02B6C:  MOVLB  0
02B6E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02B72:  MOVLW  94
02B74:  MOVWF  FF6
02B76:  MOVLW  0D
02B78:  MOVWF  FF7
02B7A:  MOVLW  00
02B7C:  MOVWF  FF8
02B7E:  MOVLW  2B
02B80:  MOVLB  9
02B82:  MOVWF  xCC
02B84:  MOVLB  0
02B86:  CALL   1BF0
02B8A:  MOVFF  128,9CC
02B8E:  MOVLW  37
02B90:  MOVLB  9
02B92:  MOVWF  xCD
02B94:  MOVLB  0
02B96:  CALL   1E44
02B9A:  MOVLW  0D
02B9C:  MOVLB  A
02B9E:  MOVWF  xB3
02BA0:  MOVLB  0
02BA2:  CALL   1B6E
02BA6:  MOVLW  0A
02BA8:  MOVLB  A
02BAA:  MOVWF  xB3
02BAC:  MOVLB  0
02BAE:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02BB2:  MOVLW  C6
02BB4:  MOVWF  FF6
02BB6:  MOVLW  0D
02BB8:  MOVWF  FF7
02BBA:  MOVLW  00
02BBC:  MOVWF  FF8
02BBE:  MOVLW  2B
02BC0:  MOVLB  9
02BC2:  MOVWF  xCC
02BC4:  MOVLB  0
02BC6:  CALL   1BF0
02BCA:  MOVFF  12D,9CC
02BCE:  MOVLW  37
02BD0:  MOVLB  9
02BD2:  MOVWF  xCD
02BD4:  MOVLB  0
02BD6:  CALL   1E44
02BDA:  MOVFF  12C,9CC
02BDE:  MOVLW  37
02BE0:  MOVLB  9
02BE2:  MOVWF  xCD
02BE4:  MOVLB  0
02BE6:  CALL   1E44
02BEA:  MOVFF  12B,9CC
02BEE:  MOVLW  37
02BF0:  MOVLB  9
02BF2:  MOVWF  xCD
02BF4:  MOVLB  0
02BF6:  CALL   1E44
02BFA:  MOVFF  12A,9CC
02BFE:  MOVLW  37
02C00:  MOVLB  9
02C02:  MOVWF  xCD
02C04:  MOVLB  0
02C06:  CALL   1E44
02C0A:  MOVLW  0D
02C0C:  MOVLB  A
02C0E:  MOVWF  xB3
02C10:  MOVLB  0
02C12:  CALL   1B6E
02C16:  MOVLW  0A
02C18:  MOVLB  A
02C1A:  MOVWF  xB3
02C1C:  MOVLB  0
02C1E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02C22:  MOVLW  FA
02C24:  MOVWF  FF6
02C26:  MOVLW  0D
02C28:  MOVWF  FF7
02C2A:  MOVLW  00
02C2C:  MOVWF  FF8
02C2E:  MOVLW  2B
02C30:  MOVLB  9
02C32:  MOVWF  xCC
02C34:  MOVLB  0
02C36:  CALL   1BF0
02C3A:  MOVFF  131,9CC
02C3E:  MOVLW  37
02C40:  MOVLB  9
02C42:  MOVWF  xCD
02C44:  MOVLB  0
02C46:  CALL   1E44
02C4A:  MOVFF  130,9CC
02C4E:  MOVLW  37
02C50:  MOVLB  9
02C52:  MOVWF  xCD
02C54:  MOVLB  0
02C56:  CALL   1E44
02C5A:  MOVFF  12F,9CC
02C5E:  MOVLW  37
02C60:  MOVLB  9
02C62:  MOVWF  xCD
02C64:  MOVLB  0
02C66:  CALL   1E44
02C6A:  MOVFF  12E,9CC
02C6E:  MOVLW  37
02C70:  MOVLB  9
02C72:  MOVWF  xCD
02C74:  MOVLB  0
02C76:  CALL   1E44
02C7A:  MOVLW  0D
02C7C:  MOVLB  A
02C7E:  MOVWF  xB3
02C80:  MOVLB  0
02C82:  CALL   1B6E
02C86:  MOVLW  0A
02C88:  MOVLB  A
02C8A:  MOVWF  xB3
02C8C:  MOVLB  0
02C8E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02C92:  MOVLW  2E
02C94:  MOVWF  FF6
02C96:  MOVLW  0E
02C98:  MOVWF  FF7
02C9A:  MOVLW  00
02C9C:  MOVWF  FF8
02C9E:  MOVLW  2B
02CA0:  MOVLB  9
02CA2:  MOVWF  xCC
02CA4:  MOVLB  0
02CA6:  CALL   1BF0
02CAA:  MOVFF  132,9CC
02CAE:  MOVLW  37
02CB0:  MOVLB  9
02CB2:  MOVWF  xCD
02CB4:  MOVLB  0
02CB6:  CALL   1E44
02CBA:  MOVLW  0D
02CBC:  MOVLB  A
02CBE:  MOVWF  xB3
02CC0:  MOVLB  0
02CC2:  CALL   1B6E
02CC6:  MOVLW  0A
02CC8:  MOVLB  A
02CCA:  MOVWF  xB3
02CCC:  MOVLB  0
02CCE:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02CD2:  MOVLW  60
02CD4:  MOVWF  FF6
02CD6:  MOVLW  0E
02CD8:  MOVWF  FF7
02CDA:  MOVLW  00
02CDC:  MOVWF  FF8
02CDE:  MOVLW  2B
02CE0:  MOVLB  9
02CE2:  MOVWF  xCC
02CE4:  MOVLB  0
02CE6:  CALL   1BF0
02CEA:  MOVFF  133,9CC
02CEE:  MOVLW  37
02CF0:  MOVLB  9
02CF2:  MOVWF  xCD
02CF4:  MOVLB  0
02CF6:  CALL   1E44
02CFA:  MOVLW  0D
02CFC:  MOVLB  A
02CFE:  MOVWF  xB3
02D00:  MOVLB  0
02D02:  CALL   1B6E
02D06:  MOVLW  0A
02D08:  MOVLB  A
02D0A:  MOVWF  xB3
02D0C:  MOVLB  0
02D0E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV HEADER | Use Counter      : 0x%08LX\r\n", iv_header.used_counter);
02D12:  MOVLW  92
02D14:  MOVWF  FF6
02D16:  MOVLW  0E
02D18:  MOVWF  FF7
02D1A:  MOVLW  00
02D1C:  MOVWF  FF8
02D1E:  MOVLW  2B
02D20:  MOVLB  9
02D22:  MOVWF  xCC
02D24:  MOVLB  0
02D26:  CALL   1BF0
02D2A:  MOVFF  138,9CC
02D2E:  MOVLW  37
02D30:  MOVLB  9
02D32:  MOVWF  xCD
02D34:  MOVLB  0
02D36:  CALL   1E44
02D3A:  MOVFF  137,9CC
02D3E:  MOVLW  37
02D40:  MOVLB  9
02D42:  MOVWF  xCD
02D44:  MOVLB  0
02D46:  CALL   1E44
02D4A:  MOVFF  136,9CC
02D4E:  MOVLW  37
02D50:  MOVLB  9
02D52:  MOVWF  xCD
02D54:  MOVLB  0
02D56:  CALL   1E44
02D5A:  MOVFF  135,9CC
02D5E:  MOVLW  37
02D60:  MOVLB  9
02D62:  MOVWF  xCD
02D64:  MOVLB  0
02D66:  CALL   1E44
02D6A:  MOVLW  0D
02D6C:  MOVLB  A
02D6E:  MOVWF  xB3
02D70:  MOVLB  0
02D72:  CALL   1B6E
02D76:  MOVLW  0A
02D78:  MOVLB  A
02D7A:  MOVWF  xB3
02D7C:  MOVLB  0
02D7E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV HEADER | Uncopyed Counter : 0x%08LX\r\n", iv_header.uncopied_counter);
02D82:  MOVLW  C6
02D84:  MOVWF  FF6
02D86:  MOVLW  0E
02D88:  MOVWF  FF7
02D8A:  MOVLW  00
02D8C:  MOVWF  FF8
02D8E:  MOVLW  2B
02D90:  MOVLB  9
02D92:  MOVWF  xCC
02D94:  MOVLB  0
02D96:  CALL   1BF0
02D9A:  MOVFF  13C,9CC
02D9E:  MOVLW  37
02DA0:  MOVLB  9
02DA2:  MOVWF  xCD
02DA4:  MOVLB  0
02DA6:  CALL   1E44
02DAA:  MOVFF  13B,9CC
02DAE:  MOVLW  37
02DB0:  MOVLB  9
02DB2:  MOVWF  xCD
02DB4:  MOVLB  0
02DB6:  CALL   1E44
02DBA:  MOVFF  13A,9CC
02DBE:  MOVLW  37
02DC0:  MOVLB  9
02DC2:  MOVWF  xCD
02DC4:  MOVLB  0
02DC6:  CALL   1E44
02DCA:  MOVFF  139,9CC
02DCE:  MOVLW  37
02DD0:  MOVLB  9
02DD2:  MOVWF  xCD
02DD4:  MOVLB  0
02DD6:  CALL   1E44
02DDA:  MOVLW  0D
02DDC:  MOVLB  A
02DDE:  MOVWF  xB3
02DE0:  MOVLB  0
02DE2:  CALL   1B6E
02DE6:  MOVLW  0A
02DE8:  MOVLB  A
02DEA:  MOVWF  xB3
02DEC:  MOVLB  0
02DEE:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter1 : 0x%02X\r\n", iv_header.reserve_counter1);
02DF2:  MOVLW  FA
02DF4:  MOVWF  FF6
02DF6:  MOVLW  0E
02DF8:  MOVWF  FF7
02DFA:  MOVLW  00
02DFC:  MOVWF  FF8
02DFE:  MOVLW  2B
02E00:  MOVLB  9
02E02:  MOVWF  xCC
02E04:  MOVLB  0
02E06:  CALL   1BF0
02E0A:  MOVFF  13D,9CC
02E0E:  MOVLW  37
02E10:  MOVLB  9
02E12:  MOVWF  xCD
02E14:  MOVLB  0
02E16:  CALL   1E44
02E1A:  MOVLW  0D
02E1C:  MOVLB  A
02E1E:  MOVWF  xB3
02E20:  MOVLB  0
02E22:  CALL   1B6E
02E26:  MOVLW  0A
02E28:  MOVLB  A
02E2A:  MOVWF  xB3
02E2C:  MOVLB  0
02E2E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter2 : 0x%02X\r\n", iv_header.reserve_counter2);
02E32:  MOVLW  2C
02E34:  MOVWF  FF6
02E36:  MOVLW  0F
02E38:  MOVWF  FF7
02E3A:  MOVLW  00
02E3C:  MOVWF  FF8
02E3E:  MOVLW  2B
02E40:  MOVLB  9
02E42:  MOVWF  xCC
02E44:  MOVLB  0
02E46:  CALL   1BF0
02E4A:  MOVFF  13E,9CC
02E4E:  MOVLW  37
02E50:  MOVLB  9
02E52:  MOVWF  xCD
02E54:  MOVLB  0
02E56:  CALL   1E44
02E5A:  MOVLW  0D
02E5C:  MOVLB  A
02E5E:  MOVWF  xB3
02E60:  MOVLB  0
02E62:  CALL   1B6E
02E66:  MOVLW  0A
02E68:  MOVLB  A
02E6A:  MOVWF  xB3
02E6C:  MOVLB  0
02E6E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV DATA   | Use Counter      : 0x%08LX\r\n", iv_data.used_counter);
02E72:  MOVLW  5E
02E74:  MOVWF  FF6
02E76:  MOVLW  0F
02E78:  MOVWF  FF7
02E7A:  MOVLW  00
02E7C:  MOVWF  FF8
02E7E:  MOVLW  2B
02E80:  MOVLB  9
02E82:  MOVWF  xCC
02E84:  MOVLB  0
02E86:  CALL   1BF0
02E8A:  MOVFF  143,9CC
02E8E:  MOVLW  37
02E90:  MOVLB  9
02E92:  MOVWF  xCD
02E94:  MOVLB  0
02E96:  CALL   1E44
02E9A:  MOVFF  142,9CC
02E9E:  MOVLW  37
02EA0:  MOVLB  9
02EA2:  MOVWF  xCD
02EA4:  MOVLB  0
02EA6:  CALL   1E44
02EAA:  MOVFF  141,9CC
02EAE:  MOVLW  37
02EB0:  MOVLB  9
02EB2:  MOVWF  xCD
02EB4:  MOVLB  0
02EB6:  CALL   1E44
02EBA:  MOVFF  140,9CC
02EBE:  MOVLW  37
02EC0:  MOVLB  9
02EC2:  MOVWF  xCD
02EC4:  MOVLB  0
02EC6:  CALL   1E44
02ECA:  MOVLW  0D
02ECC:  MOVLB  A
02ECE:  MOVWF  xB3
02ED0:  MOVLB  0
02ED2:  CALL   1B6E
02ED6:  MOVLW  0A
02ED8:  MOVLB  A
02EDA:  MOVWF  xB3
02EDC:  MOVLB  0
02EDE:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV DATA   | Uncopyed Counter : 0x%08LX\r\n", iv_data.uncopied_counter);
02EE2:  MOVLW  92
02EE4:  MOVWF  FF6
02EE6:  MOVLW  0F
02EE8:  MOVWF  FF7
02EEA:  MOVLW  00
02EEC:  MOVWF  FF8
02EEE:  MOVLW  2B
02EF0:  MOVLB  9
02EF2:  MOVWF  xCC
02EF4:  MOVLB  0
02EF6:  CALL   1BF0
02EFA:  MOVFF  147,9CC
02EFE:  MOVLW  37
02F00:  MOVLB  9
02F02:  MOVWF  xCD
02F04:  MOVLB  0
02F06:  CALL   1E44
02F0A:  MOVFF  146,9CC
02F0E:  MOVLW  37
02F10:  MOVLB  9
02F12:  MOVWF  xCD
02F14:  MOVLB  0
02F16:  CALL   1E44
02F1A:  MOVFF  145,9CC
02F1E:  MOVLW  37
02F20:  MOVLB  9
02F22:  MOVWF  xCD
02F24:  MOVLB  0
02F26:  CALL   1E44
02F2A:  MOVFF  144,9CC
02F2E:  MOVLW  37
02F30:  MOVLB  9
02F32:  MOVWF  xCD
02F34:  MOVLB  0
02F36:  CALL   1E44
02F3A:  MOVLW  0D
02F3C:  MOVLB  A
02F3E:  MOVWF  xB3
02F40:  MOVLB  0
02F42:  CALL   1B6E
02F46:  MOVLW  0A
02F48:  MOVLB  A
02F4A:  MOVWF  xB3
02F4C:  MOVLB  0
02F4E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter1 : 0x%02X\r\n", iv_data.reserve_counter1);
02F52:  MOVLW  C6
02F54:  MOVWF  FF6
02F56:  MOVLW  0F
02F58:  MOVWF  FF7
02F5A:  MOVLW  00
02F5C:  MOVWF  FF8
02F5E:  MOVLW  2B
02F60:  MOVLB  9
02F62:  MOVWF  xCC
02F64:  MOVLB  0
02F66:  CALL   1BF0
02F6A:  MOVFF  148,9CC
02F6E:  MOVLW  37
02F70:  MOVLB  9
02F72:  MOVWF  xCD
02F74:  MOVLB  0
02F76:  CALL   1E44
02F7A:  MOVLW  0D
02F7C:  MOVLB  A
02F7E:  MOVWF  xB3
02F80:  MOVLB  0
02F82:  CALL   1B6E
02F86:  MOVLW  0A
02F88:  MOVLB  A
02F8A:  MOVWF  xB3
02F8C:  MOVLB  0
02F8E:  CALL   1B6E
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter2 : 0x%02X\r\n", iv_data.reserve_counter2);
02F92:  MOVLW  F8
02F94:  MOVWF  FF6
02F96:  MOVLW  0F
02F98:  MOVWF  FF7
02F9A:  MOVLW  00
02F9C:  MOVWF  FF8
02F9E:  MOVLW  2B
02FA0:  MOVLB  9
02FA2:  MOVWF  xCC
02FA4:  MOVLB  0
02FA6:  CALL   1BF0
02FAA:  MOVFF  149,9CC
02FAE:  MOVLW  37
02FB0:  MOVLB  9
02FB2:  MOVWF  xCD
02FB4:  MOVLB  0
02FB6:  CALL   1E44
02FBA:  MOVLW  0D
02FBC:  MOVLB  A
02FBE:  MOVWF  xB3
02FC0:  MOVLB  0
02FC2:  CALL   1B6E
02FC6:  MOVLW  0A
02FC8:  MOVLB  A
02FCA:  MOVWF  xB3
02FCC:  MOVLB  0
02FCE:  CALL   1B6E
....................     fprintf(PC, "\tComplete\r\n");
02FD2:  MOVLW  2A
02FD4:  MOVWF  FF6
02FD6:  MOVLW  10
02FD8:  MOVWF  FF7
02FDA:  MOVLW  00
02FDC:  MOVWF  FF8
02FDE:  CALL   1BC0
02FE2:  GOTO   31C0 (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
094DE:  MOVLB  2
094E0:  CLRF   x6E
094E2:  CLRF   x6F
094E4:  CLRF   x70
094E6:  CLRF   x71
094E8:  CLRF   x72
094EA:  CLRF   x73
094EC:  CLRF   x74
094EE:  CLRF   x75
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
094F0:  MOVF   x6D,F
094F2:  BTFSC  FD8.2
094F4:  BRA    94FC
094F6:  MOVLB  0
094F8:  GOTO   9518
094FC:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
094FE:  MOVLB  2
09500:  CLRF   x71
09502:  CLRF   x70
09504:  CLRF   x6F
09506:  CLRF   x6E
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
09508:  CLRF   x75
0950A:  CLRF   x74
0950C:  MOVLW  0F
0950E:  MOVWF  x73
09510:  SETF   x72
09512:  MOVLB  0
....................    }
09514:  GOTO   95DA
....................    else if (mission_id == CIGS_PICLOG_DATA)
09518:  MOVLB  2
0951A:  DECFSZ x6D,W
0951C:  BRA    9522
0951E:  BRA    9528
09520:  MOVLB  0
09522:  MOVLB  0
09524:  GOTO   9548
09528:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
0952A:  MOVLB  2
0952C:  CLRF   x71
0952E:  MOVLW  01
09530:  MOVWF  x70
09532:  CLRF   x6F
09534:  CLRF   x6E
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
09536:  CLRF   x75
09538:  MOVLW  14
0953A:  MOVWF  x74
0953C:  MOVLW  0F
0953E:  MOVWF  x73
09540:  SETF   x72
09542:  MOVLB  0
....................    }
09544:  GOTO   95DA
....................    else if (mission_id == CIGS_ENVIRO_DATA)
09548:  MOVLB  2
0954A:  MOVF   x6D,W
0954C:  SUBLW  02
0954E:  BTFSC  FD8.2
09550:  BRA    9558
09552:  MOVLB  0
09554:  GOTO   957A
09558:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
0955A:  MOVLB  2
0955C:  CLRF   x71
0955E:  MOVLW  28
09560:  MOVWF  x70
09562:  MOVLW  10
09564:  MOVWF  x6F
09566:  CLRF   x6E
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
09568:  CLRF   x75
0956A:  MOVLW  32
0956C:  MOVWF  x74
0956E:  MOVLW  0F
09570:  MOVWF  x73
09572:  SETF   x72
09574:  MOVLB  0
....................    }
09576:  GOTO   95DA
....................    else if (mission_id == CIGS_IV_HEADER)
0957A:  MOVLB  2
0957C:  MOVF   x6D,W
0957E:  SUBLW  03
09580:  BTFSC  FD8.2
09582:  BRA    958A
09584:  MOVLB  0
09586:  GOTO   95AC
0958A:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
0958C:  MOVLB  2
0958E:  CLRF   x71
09590:  MOVLW  32
09592:  MOVWF  x70
09594:  MOVLW  10
09596:  MOVWF  x6F
09598:  CLRF   x6E
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
0959A:  CLRF   x75
0959C:  MOVLW  72
0959E:  MOVWF  x74
095A0:  MOVLW  0F
095A2:  MOVWF  x73
095A4:  SETF   x72
095A6:  MOVLB  0
....................    }
095A8:  GOTO   95DA
....................    else if (mission_id == CIGS_IV_DATA)
095AC:  MOVLB  2
095AE:  MOVF   x6D,W
095B0:  SUBLW  04
095B2:  BTFSC  FD8.2
095B4:  BRA    95BC
095B6:  MOVLB  0
095B8:  GOTO   95DA
095BC:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
095BE:  MOVLB  2
095C0:  CLRF   x71
095C2:  MOVLW  72
095C4:  MOVWF  x70
095C6:  MOVLW  10
095C8:  MOVWF  x6F
095CA:  CLRF   x6E
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
095CC:  CLRF   x75
095CE:  MOVLW  7C
095D0:  MOVWF  x74
095D2:  MOVLW  10
095D4:  MOVWF  x73
095D6:  CLRF   x72
095D8:  MOVLB  0
....................    }
....................    return mis_struct;
095DA:  MOVLW  6E
095DC:  MOVWF  01
095DE:  MOVLW  02
095E0:  MOVWF  02
095E2:  GOTO   9AB8 (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv_header.used_counter - iv_header.uncopied_counter;
....................         mis_write_struct.size = iv_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter - iv_data.uncopied_counter;
....................         mis_write_struct.size = iv_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... // End of file
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "../application/mission/mmj_cigs_excute_mission.c"
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
08E88:  MOVLB  1
08E8A:  MOVF   x90,W
08E8C:  MOVWF  FE9
08E8E:  MOVF   x91,W
08E90:  MOVWF  FEA
08E92:  MOVFF  FEF,192
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
08E96:  MOVLW  92
08E98:  MOVWF  FF6
08E9A:  MOVLW  10
08E9C:  MOVWF  FF7
08E9E:  MOVLW  00
08EA0:  MOVWF  FF8
08EA2:  MOVLB  0
08EA4:  CALL   1BC0
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
08EA8:  MOVLW  D8
08EAA:  MOVWF  FF6
08EAC:  MOVLW  10
08EAE:  MOVWF  FF7
08EB0:  MOVLW  00
08EB2:  MOVWF  FF8
08EB4:  MOVLW  0C
08EB6:  MOVLB  9
08EB8:  MOVWF  xCC
08EBA:  MOVLB  0
08EBC:  CALL   1BF0
08EC0:  MOVFF  192,9CC
08EC4:  MOVLW  37
08EC6:  MOVLB  9
08EC8:  MOVWF  xCD
08ECA:  MOVLB  0
08ECC:  CALL   1E44
08ED0:  MOVLW  E6
08ED2:  MOVWF  FF6
08ED4:  MOVLW  10
08ED6:  MOVWF  FF7
08ED8:  MOVLW  00
08EDA:  MOVWF  FF8
08EDC:  MOVLW  04
08EDE:  MOVLB  9
08EE0:  MOVWF  xCC
08EE2:  MOVLB  0
08EE4:  CALL   1BF0
....................    switch(command_id)
08EE8:  MOVLB  1
08EEA:  MOVF   x92,W
08EEC:  XORLW  10
08EEE:  MOVLB  0
08EF0:  BTFSC  FD8.2
08EF2:  GOTO   8FA2
08EF6:  XORLW  01
08EF8:  BTFSC  FD8.2
08EFA:  GOTO   8FA6
08EFE:  XORLW  03
08F00:  BTFSC  FD8.2
08F02:  GOTO   8FAA
08F06:  XORLW  13
08F08:  BTFSC  FD8.2
08F0A:  GOTO   8FAE
08F0E:  XORLW  12
08F10:  BTFSC  FD8.2
08F12:  GOTO   8FB2
08F16:  XORLW  93
08F18:  BTFSC  FD8.2
08F1A:  GOTO   8FB6
08F1E:  XORLW  01
08F20:  BTFSC  FD8.2
08F22:  GOTO   8FC6
08F26:  XORLW  03
08F28:  BTFSC  FD8.2
08F2A:  GOTO   8FD6
08F2E:  XORLW  01
08F30:  BTFSC  FD8.2
08F32:  GOTO   8FE6
08F36:  XORLW  07
08F38:  BTFSC  FD8.2
08F3A:  GOTO   8FF6
08F3E:  XORLW  01
08F40:  BTFSC  FD8.2
08F42:  GOTO   9006
08F46:  XORLW  03
08F48:  BTFSC  FD8.2
08F4A:  GOTO   9016
08F4E:  XORLW  01
08F50:  BTFSC  FD8.2
08F52:  GOTO   9026
08F56:  XORLW  0F
08F58:  BTFSC  FD8.2
08F5A:  GOTO   9036
08F5E:  XORLW  18
08F60:  BTFSC  FD8.2
08F62:  GOTO   9046
08F66:  XORLW  01
08F68:  BTFSC  FD8.2
08F6A:  GOTO   9056
08F6E:  XORLW  03
08F70:  BTFSC  FD8.2
08F72:  GOTO   9066
08F76:  XORLW  01
08F78:  BTFSC  FD8.2
08F7A:  GOTO   9076
08F7E:  XORLW  07
08F80:  BTFSC  FD8.2
08F82:  GOTO   9086
08F86:  XORLW  01
08F88:  BTFSC  FD8.2
08F8A:  GOTO   9096
08F8E:  XORLW  03
08F90:  BTFSC  FD8.2
08F92:  GOTO   90A6
08F96:  XORLW  36
08F98:  BTFSC  FD8.2
08F9A:  GOTO   90B6
08F9E:  GOTO   90C6
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
08FA2:  GOTO   90D6
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
08FA6:  GOTO   90D6
....................       case 0x12:
....................          // test_adc();
....................          break;
08FAA:  GOTO   90D6
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
08FAE:  GOTO   90D6
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
08FB2:  GOTO   90D6
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
08FB6:  MOVFF  191,196
08FBA:  MOVFF  190,195
08FBE:  CALL   47E2
....................          break;
08FC2:  GOTO   90D6
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
08FC6:  MOVFF  191,194
08FCA:  MOVFF  190,193
08FCE:  GOTO   48BE
....................          break;
08FD2:  GOTO   90D6
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
08FD6:  MOVFF  191,194
08FDA:  MOVFF  190,193
08FDE:  GOTO   4DC4
....................          break;
08FE2:  GOTO   90D6
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
08FE6:  MOVFF  191,194
08FEA:  MOVFF  190,193
08FEE:  GOTO   4F56
....................          break;
08FF2:  GOTO   90D6
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
08FF6:  MOVFF  191,194
08FFA:  MOVFF  190,193
08FFE:  GOTO   50C8
....................          break;
09002:  GOTO   90D6
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
09006:  MOVFF  191,194
0900A:  MOVFF  190,193
0900E:  GOTO   54C2
....................          break;
09012:  GOTO   90D6
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
09016:  MOVFF  191,194
0901A:  MOVFF  190,193
0901E:  GOTO   5536
....................          break;
09022:  GOTO   90D6
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
09026:  MOVFF  191,194
0902A:  MOVFF  190,193
0902E:  GOTO   59BA
....................          break;
09032:  GOTO   90D6
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
09036:  MOVFF  191,194
0903A:  MOVFF  190,193
0903E:  GOTO   5CB2
....................          break;
09042:  GOTO   90D6
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
09046:  MOVFF  191,194
0904A:  MOVFF  190,193
0904E:  GOTO   5D08
....................          break;
09052:  GOTO   90D6
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
09056:  MOVFF  191,194
0905A:  MOVFF  190,193
0905E:  GOTO   5DE4
....................          break;
09062:  GOTO   90D6
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
09066:  MOVFF  191,194
0906A:  MOVFF  190,193
0906E:  GOTO   5EA0
....................          break;
09072:  GOTO   90D6
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
09076:  MOVFF  191,194
0907A:  MOVFF  190,193
0907E:  CALL   5F08
....................          break;
09082:  GOTO   90D6
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
09086:  MOVFF  191,194
0908A:  MOVFF  190,193
0908E:  GOTO   60AE
....................          break;
09092:  GOTO   90D6
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
09096:  MOVFF  191,194
0909A:  MOVFF  190,193
0909E:  GOTO   6490
....................          break;
090A2:  GOTO   90D6
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
090A6:  MOVFF  191,194
090AA:  MOVFF  190,193
090AE:  CALL   5F08
....................          break;
090B2:  GOTO   90D6
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
090B6:  MOVFF  191,194
090BA:  MOVFF  190,193
090BE:  GOTO   88E0
....................          break;
090C2:  GOTO   90D6
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
090C6:  MOVLW  EC
090C8:  MOVWF  FF6
090CA:  MOVLW  10
090CC:  MOVWF  FF7
090CE:  MOVLW  00
090D0:  MOVWF  FF8
090D2:  CALL   1BC0
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
090D6:  MOVLW  04
090D8:  MOVWF  FF6
090DA:  MOVLW  11
090DC:  MOVWF  FF7
090DE:  MOVLW  00
090E0:  MOVWF  FF8
090E2:  CALL   1BC0
090E6:  GOTO   9154 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0B012:  MOVLW  4A
0B014:  MOVWF  FF6
0B016:  MOVLW  11
0B018:  MOVWF  FF7
0B01A:  MOVLW  00
0B01C:  MOVWF  FF8
0B01E:  CALL   1BC0
....................    
....................    switch(command->frame_id)
0B022:  MOVLB  1
0B024:  MOVF   x8A,W
0B026:  MOVWF  FE9
0B028:  MOVF   x8B,W
0B02A:  MOVWF  FEA
0B02C:  MOVF   FEF,W
0B02E:  XORLW  00
0B030:  MOVLB  0
0B032:  BTFSC  FD8.2
0B034:  GOTO   B04C
0B038:  XORLW  01
0B03A:  BTFSC  FD8.2
0B03C:  GOTO   B05C
0B040:  XORLW  03
0B042:  BTFSC  FD8.2
0B044:  GOTO   B07C
0B048:  GOTO   B08C
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0B04C:  MOVFF  18B,18D
0B050:  MOVFF  18A,18C
0B054:  GOTO   9108
....................          break;
0B058:  GOTO   B08C
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0B05C:  MOVFF  18B,18D
0B060:  MOVFF  18A,18C
0B064:  GOTO   918A
0B068:  MOVF   01,F
0B06A:  BTFSC  FD8.2
0B06C:  GOTO   B078
....................             return TRUE; // if status is finished, return TRUE
0B070:  MOVLW  01
0B072:  MOVWF  01
0B074:  GOTO   B090
....................          }        
....................          break;
0B078:  GOTO   B08C
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0B07C:  MOVFF  18B,18D
0B080:  MOVFF  18A,18C
0B084:  GOTO   AD22
....................          break;
0B088:  GOTO   B08C
....................    }
....................    return FALSE;
0B08C:  MOVLW  00
0B08E:  MOVWF  01
0B090:  GOTO   B650 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
09108:  MOVLW  62
0910A:  MOVWF  FF6
0910C:  MOVLW  11
0910E:  MOVWF  FF7
09110:  MOVLW  00
09112:  MOVWF  FF8
09114:  CALL   1BC0
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
09118:  MOVLW  78
0911A:  MOVWF  FF6
0911C:  MOVLW  11
0911E:  MOVWF  FF7
09120:  MOVLW  00
09122:  MOVWF  FF8
09124:  CALL   1BC0
....................    transmit_ack();
09128:  CALL   47CE
.................... 
....................    status[0] = EXECUTING_MISSION;
0912C:  MOVLW  02
0912E:  MOVWF  48
....................    execute_mission(command->content);
09130:  MOVLW  03
09132:  MOVLB  1
09134:  ADDWF  x8C,W
09136:  MOVWF  01
09138:  MOVLW  00
0913A:  ADDWFC x8D,W
0913C:  MOVWF  03
0913E:  MOVF   01,W
09140:  MOVWF  x8E
09142:  MOVFF  03,18F
09146:  MOVFF  18F,191
0914A:  MOVFF  18E,190
0914E:  MOVLB  0
09150:  GOTO   8E88
....................    if (is_empty_flash_queue())
09154:  CALL   90EA
09158:  MOVF   01,F
0915A:  BTFSC  FD8.2
0915C:  GOTO   9168
....................       status[0] = FINISHED;
09160:  MOVLW  06
09162:  MOVWF  48
09164:  GOTO   916C
....................    else
....................       status[0] = SMF_USE_REQ;
09168:  MOVLW  04
0916A:  MOVWF  48
0916C:  GOTO   B058 (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
0918A:  MOVLW  92
0918C:  MOVWF  FF6
0918E:  MOVLW  11
09190:  MOVWF  FF7
09192:  MOVLW  00
09194:  MOVWF  FF8
09196:  CALL   1BC0
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
0919A:  MOVLW  A6
0919C:  MOVWF  FF6
0919E:  MOVLW  11
091A0:  MOVWF  FF7
091A2:  MOVLW  00
091A4:  MOVWF  FF8
091A6:  CALL   1BC0
....................    transmit_status();
091AA:  GOTO   9170
....................    if (status[0] == FINISHED)
091AE:  MOVF   48,W
091B0:  SUBLW  06
091B2:  BTFSS  FD8.2
091B4:  GOTO   91D4
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
091B8:  MOVLW  C4
091BA:  MOVWF  FF6
091BC:  MOVLW  11
091BE:  MOVWF  FF7
091C0:  MOVLW  00
091C2:  MOVWF  FF8
091C4:  CALL   1BC0
....................       return TRUE;
091C8:  MOVLW  01
091CA:  MOVWF  01
091CC:  GOTO   91DC
....................    }
091D0:  GOTO   91DC
....................    else{
....................       return FALSE;
091D4:  MOVLW  00
091D6:  MOVWF  01
091D8:  GOTO   91DC
....................    }
091DC:  GOTO   B068 (RETURN)
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command)
.................... {
....................     fprintf(PC, "\t-> SMF available check\r\n");
*
0AD22:  MOVLW  E0
0AD24:  MOVWF  FF6
0AD26:  MOVLW  11
0AD28:  MOVWF  FF7
0AD2A:  MOVLW  00
0AD2C:  MOVWF  FF8
0AD2E:  CALL   1BC0
....................     fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0AD32:  MOVLW  FA
0AD34:  MOVWF  FF6
0AD36:  MOVLW  11
0AD38:  MOVWF  FF7
0AD3A:  MOVLW  00
0AD3C:  MOVWF  FF8
0AD3E:  CALL   1BC0
....................     transmit_ack();
0AD42:  CALL   47CE
.................... 
....................     if (command->content[0] != ALLOW) {
0AD46:  MOVLW  03
0AD48:  MOVLB  1
0AD4A:  ADDWF  x8C,W
0AD4C:  MOVWF  FE9
0AD4E:  MOVLW  00
0AD50:  ADDWFC x8D,W
0AD52:  MOVWF  FEA
0AD54:  DECFSZ FEF,W
0AD56:  BRA    AD5C
0AD58:  BRA    AD62
0AD5A:  MOVLB  0
0AD5C:  MOVLB  0
0AD5E:  GOTO   AD68
0AD62:  MOVLB  0
0AD64:  GOTO   AD7C
....................         fprintf(PC, "\t\t-> denied\r\n");
0AD68:  MOVLW  1A
0AD6A:  MOVWF  FF6
0AD6C:  MOVLW  12
0AD6E:  MOVWF  FF7
0AD70:  MOVLW  00
0AD72:  MOVWF  FF8
0AD74:  CALL   1BC0
....................         return;
0AD78:  GOTO   B00E
....................     }
.................... 
....................     fprintf(PC, "\t\t-> allowed\r\n");
0AD7C:  MOVLW  28
0AD7E:  MOVWF  FF6
0AD80:  MOVLW  12
0AD82:  MOVWF  FF7
0AD84:  MOVLW  00
0AD86:  MOVWF  FF8
0AD88:  CALL   1BC0
....................     status[0] = COPYING;
0AD8C:  MOVLW  05
0AD8E:  MOVWF  48
.................... 
....................     int8 processed_count = 0;
0AD90:  MOVLB  1
0AD92:  CLRF   x8E
0AD94:  MOVLB  0
.................... 
....................     while (!is_empty_flash_queue()) {
0AD96:  CALL   90EA
0AD9A:  MOVF   01,F
0AD9C:  BTFSS  FD8.2
0AD9E:  GOTO   AFCA
....................         FlashOperationStruct *smf_data = dequeue_flash_operation();
0ADA2:  GOTO   91E0
0ADA6:  MOVFF  02,190
0ADAA:  MOVFF  01,18F
....................         if (smf_data == NULL) {
0ADAE:  MOVLB  1
0ADB0:  MOVF   x8F,F
0ADB2:  BTFSC  FD8.2
0ADB4:  BRA    ADBC
0ADB6:  MOVLB  0
0ADB8:  GOTO   ADE2
0ADBC:  MOVLB  0
0ADBE:  MOVLB  1
0ADC0:  MOVF   x90,F
0ADC2:  BTFSC  FD8.2
0ADC4:  BRA    ADCC
0ADC6:  MOVLB  0
0ADC8:  GOTO   ADE2
0ADCC:  MOVLB  0
....................             fprintf(PC, "\t\t-> dequeue NULL (break)\r\n");
0ADCE:  MOVLW  38
0ADD0:  MOVWF  FF6
0ADD2:  MOVLW  12
0ADD4:  MOVWF  FF7
0ADD6:  MOVLW  00
0ADD8:  MOVWF  FF8
0ADDA:  CALL   1BC0
....................             break;
0ADDE:  GOTO   AFCA
....................         }
.................... 
....................         fprintf(PC, "\t\t-> Dequeued: func=%u mission=%u size=%ld addr=%ld\r\n",
....................                 (unsigned int)smf_data->func_type,
....................                 (unsigned int)smf_data->mission_id,
....................                 smf_data->misf_size,
....................                 smf_data->misf_start_addr);
0ADE2:  MOVLW  01
0ADE4:  MOVLB  1
0ADE6:  ADDWF  x8F,W
0ADE8:  MOVWF  FE9
0ADEA:  MOVLW  00
0ADEC:  ADDWFC x90,W
0ADEE:  MOVWF  FEA
0ADF0:  MOVFF  FEF,191
0ADF4:  MOVF   x8F,W
0ADF6:  MOVWF  FE9
0ADF8:  MOVF   x90,W
0ADFA:  MOVWF  FEA
0ADFC:  MOVFF  FEF,192
0AE00:  MOVLW  08
0AE02:  ADDWF  x8F,W
0AE04:  MOVWF  FE9
0AE06:  MOVLW  00
0AE08:  ADDWFC x90,W
0AE0A:  MOVWF  FEA
0AE0C:  MOVFF  FEF,193
0AE10:  MOVFF  FEC,194
0AE14:  MOVFF  FEC,195
0AE18:  MOVFF  FEC,196
0AE1C:  MOVF   FED,F
0AE1E:  MOVF   FED,F
0AE20:  MOVF   FED,F
0AE22:  MOVLW  04
0AE24:  ADDWF  x8F,W
0AE26:  MOVWF  FE9
0AE28:  MOVLW  00
0AE2A:  ADDWFC x90,W
0AE2C:  MOVWF  FEA
0AE2E:  MOVFF  FEF,197
0AE32:  MOVFF  FEC,198
0AE36:  MOVFF  FEC,199
0AE3A:  MOVFF  FEC,19A
0AE3E:  MOVF   FED,F
0AE40:  MOVF   FED,F
0AE42:  MOVF   FED,F
0AE44:  MOVLW  54
0AE46:  MOVWF  FF6
0AE48:  MOVLW  12
0AE4A:  MOVWF  FF7
0AE4C:  MOVLW  00
0AE4E:  MOVWF  FF8
0AE50:  MOVLW  14
0AE52:  MOVLB  9
0AE54:  MOVWF  xCC
0AE56:  MOVLB  0
0AE58:  CALL   1BF0
0AE5C:  MOVFF  191,26A
0AE60:  MOVLW  1B
0AE62:  MOVLB  2
0AE64:  MOVWF  x6B
0AE66:  MOVLB  0
0AE68:  CALL   66D0
0AE6C:  MOVLW  6A
0AE6E:  MOVWF  FF6
0AE70:  MOVLW  12
0AE72:  MOVWF  FF7
0AE74:  MOVLW  00
0AE76:  MOVWF  FF8
0AE78:  MOVLW  09
0AE7A:  MOVLB  9
0AE7C:  MOVWF  xCC
0AE7E:  MOVLB  0
0AE80:  CALL   1BF0
0AE84:  MOVFF  192,26A
0AE88:  MOVLW  1B
0AE8A:  MOVLB  2
0AE8C:  MOVWF  x6B
0AE8E:  MOVLB  0
0AE90:  CALL   66D0
0AE94:  MOVLW  75
0AE96:  MOVWF  FF6
0AE98:  MOVLW  12
0AE9A:  MOVWF  FF7
0AE9C:  MOVLW  00
0AE9E:  MOVWF  FF8
0AEA0:  MOVLW  06
0AEA2:  MOVLB  9
0AEA4:  MOVWF  xCC
0AEA6:  MOVLB  0
0AEA8:  CALL   1BF0
0AEAC:  MOVLW  41
0AEAE:  MOVWF  FE9
0AEB0:  MOVFF  196,269
0AEB4:  MOVFF  195,268
0AEB8:  MOVFF  194,267
0AEBC:  MOVFF  193,266
0AEC0:  CALL   9242
0AEC4:  MOVLW  7E
0AEC6:  MOVWF  FF6
0AEC8:  MOVLW  12
0AECA:  MOVWF  FF7
0AECC:  MOVLW  00
0AECE:  MOVWF  FF8
0AED0:  MOVLW  06
0AED2:  MOVLB  9
0AED4:  MOVWF  xCC
0AED6:  MOVLB  0
0AED8:  CALL   1BF0
0AEDC:  MOVLW  41
0AEDE:  MOVWF  FE9
0AEE0:  MOVFF  19A,269
0AEE4:  MOVFF  199,268
0AEE8:  MOVFF  198,267
0AEEC:  MOVFF  197,266
0AEF0:  CALL   9242
0AEF4:  MOVLW  0D
0AEF6:  MOVLB  A
0AEF8:  MOVWF  xB3
0AEFA:  MOVLB  0
0AEFC:  CALL   1B6E
0AF00:  MOVLW  0A
0AF02:  MOVLB  A
0AF04:  MOVWF  xB3
0AF06:  MOVLB  0
0AF08:  CALL   1B6E
.................... 
....................         switch (smf_data->func_type) {
0AF0C:  MOVLW  01
0AF0E:  MOVLB  1
0AF10:  ADDWF  x8F,W
0AF12:  MOVWF  FE9
0AF14:  MOVLW  00
0AF16:  ADDWFC x90,W
0AF18:  MOVWF  FEA
0AF1A:  MOVF   FEF,W
0AF1C:  XORLW  00
0AF1E:  MOVLB  0
0AF20:  BTFSC  FD8.2
0AF22:  GOTO   AF3A
0AF26:  XORLW  01
0AF28:  BTFSC  FD8.2
0AF2A:  GOTO   AF4A
0AF2E:  XORLW  03
0AF30:  BTFSC  FD8.2
0AF32:  GOTO   AF5A
0AF36:  GOTO   AF6A
....................             case ENUM_SMF_WRITE:
....................                 smf_write(smf_data);
0AF3A:  MOVFF  190,192
0AF3E:  MOVFF  18F,191
0AF42:  GOTO   9A04
....................                 break;
0AF46:  GOTO   AFC0
....................             case ENUM_SMF_READ:
....................                 smf_read(smf_data);
0AF4A:  MOVFF  190,192
0AF4E:  MOVFF  18F,191
0AF52:  GOTO   A474
....................                 break;
0AF56:  GOTO   AFC0
....................             case ENUM_SMF_ERASE:
....................                 smf_erase(smf_data);
0AF5A:  MOVFF  190,192
0AF5E:  MOVFF  18F,191
0AF62:  GOTO   A804
....................                 break;
0AF66:  GOTO   AFC0
....................             default:
....................                 fprintf(PC, "\t\t   Unknown func_type=%u\r\n",
....................                         (unsigned int)smf_data->func_type);
0AF6A:  MOVLW  01
0AF6C:  MOVLB  1
0AF6E:  ADDWF  x8F,W
0AF70:  MOVWF  FE9
0AF72:  MOVLW  00
0AF74:  ADDWFC x90,W
0AF76:  MOVWF  FEA
0AF78:  MOVFF  FEF,191
0AF7C:  MOVLW  8A
0AF7E:  MOVWF  FF6
0AF80:  MOVLW  12
0AF82:  MOVWF  FF7
0AF84:  MOVLW  00
0AF86:  MOVWF  FF8
0AF88:  MOVLW  17
0AF8A:  MOVLB  9
0AF8C:  MOVWF  xCC
0AF8E:  MOVLB  0
0AF90:  CALL   1BF0
0AF94:  MOVFF  191,26A
0AF98:  MOVLW  1B
0AF9A:  MOVLB  2
0AF9C:  MOVWF  x6B
0AF9E:  MOVLB  0
0AFA0:  CALL   66D0
0AFA4:  MOVLW  0D
0AFA6:  MOVLB  A
0AFA8:  MOVWF  xB3
0AFAA:  MOVLB  0
0AFAC:  CALL   1B6E
0AFB0:  MOVLW  0A
0AFB2:  MOVLB  A
0AFB4:  MOVWF  xB3
0AFB6:  MOVLB  0
0AFB8:  CALL   1B6E
....................                 break;
0AFBC:  GOTO   AFC0
....................         }
....................         processed_count++;
0AFC0:  MOVLB  1
0AFC2:  INCF   x8E,F
0AFC4:  MOVLB  0
0AFC6:  GOTO   AD96
....................     }
.................... 
....................     fprintf(PC, "\t\t-> Completed %u operations\r\n",
....................             (unsigned int)processed_count);
0AFCA:  MOVLW  A6
0AFCC:  MOVWF  FF6
0AFCE:  MOVLW  12
0AFD0:  MOVWF  FF7
0AFD2:  MOVLW  00
0AFD4:  MOVWF  FF8
0AFD6:  MOVLW  0F
0AFD8:  MOVLB  9
0AFDA:  MOVWF  xCC
0AFDC:  MOVLB  0
0AFDE:  CALL   1BF0
0AFE2:  MOVFF  18E,26A
0AFE6:  MOVLW  1B
0AFE8:  MOVLB  2
0AFEA:  MOVWF  x6B
0AFEC:  MOVLB  0
0AFEE:  CALL   66D0
0AFF2:  MOVLW  B7
0AFF4:  MOVWF  FF6
0AFF6:  MOVLW  12
0AFF8:  MOVWF  FF7
0AFFA:  MOVLW  00
0AFFC:  MOVWF  FF8
0AFFE:  MOVLW  0D
0B000:  MOVLB  9
0B002:  MOVWF  xCC
0B004:  MOVLB  0
0B006:  CALL   1BF0
.................... 
....................     status[0] = FINISHED;
0B00A:  MOVLW  06
0B00C:  MOVWF  48
0B00E:  GOTO   B088 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[])
.................... {
....................    unsigned int8 measurement_step = uplinkcmd[1]; // Get the measurement step from the parameter array
....................    fprintf(PC, "Start MODE TEST IV\r\n");
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(uplinkcmd); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
.................... //!   sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = ENUM_SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
088E0:  MOVLW  6A
088E2:  MOVWF  FF6
088E4:  MOVLW  13
088E6:  MOVWF  FF7
088E8:  MOVLW  00
088EA:  MOVWF  FF8
088EC:  CALL   1BC0
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
088F0:  MOVFF  194,1B8
088F4:  MOVFF  193,1B7
088F8:  GOTO   657A
088FC:  MOVFF  02,03
08900:  MOVF   01,W
08902:  MOVWF  FE1
08904:  MOVFF  03,FE2
08908:  MOVLW  01
0890A:  MOVWF  FEA
0890C:  MOVLW  95
0890E:  MOVWF  FE9
08910:  MOVLW  0C
08912:  MOVWF  01
08914:  MOVFF  FE6,FEE
08918:  DECFSZ 01,F
0891A:  GOTO   8914
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
0891E:  MOVLW  80
08920:  MOVWF  FF6
08922:  MOVLW  13
08924:  MOVWF  FF7
08926:  MOVLW  00
08928:  MOVWF  FF8
0892A:  MOVLW  05
0892C:  MOVLB  9
0892E:  MOVWF  xCC
08930:  MOVLB  0
08932:  CALL   1BF0
08936:  MOVFF  195,9CC
0893A:  MOVLW  37
0893C:  MOVLB  9
0893E:  MOVWF  xCD
08940:  MOVLB  0
08942:  CALL   1E44
08946:  MOVLW  0D
08948:  MOVLB  A
0894A:  MOVWF  xB3
0894C:  MOVLB  0
0894E:  CALL   1B6E
08952:  MOVLW  0A
08954:  MOVLB  A
08956:  MOVWF  xB3
08958:  MOVLB  0
0895A:  CALL   1B6E
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
0895E:  MOVLW  8C
08960:  MOVWF  FF6
08962:  MOVLW  13
08964:  MOVWF  FF7
08966:  MOVLW  00
08968:  MOVWF  FF8
0896A:  MOVLW  0D
0896C:  MOVLB  9
0896E:  MOVWF  xCC
08970:  MOVLB  0
08972:  CALL   1BF0
08976:  MOVFF  197,9CC
0897A:  MOVLW  37
0897C:  MOVLB  9
0897E:  MOVWF  xCD
08980:  MOVLB  0
08982:  CALL   1E44
08986:  MOVFF  196,9CC
0898A:  MOVLW  37
0898C:  MOVLB  9
0898E:  MOVWF  xCD
08990:  MOVLB  0
08992:  CALL   1E44
08996:  MOVLW  9E
08998:  MOVWF  FF6
0899A:  MOVLW  13
0899C:  MOVWF  FF7
0899E:  MOVLW  00
089A0:  MOVWF  FF8
089A2:  MOVLW  05
089A4:  MOVLB  9
089A6:  MOVWF  xCC
089A8:  MOVLB  0
089AA:  CALL   1BF0
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
089AE:  MOVLW  A4
089B0:  MOVWF  FF6
089B2:  MOVLW  13
089B4:  MOVWF  FF7
089B6:  MOVLW  00
089B8:  MOVWF  FF8
089BA:  MOVLW  14
089BC:  MOVLB  9
089BE:  MOVWF  xCC
089C0:  MOVLB  0
089C2:  CALL   1BF0
089C6:  MOVFF  199,9CC
089CA:  MOVLW  37
089CC:  MOVLB  9
089CE:  MOVWF  xCD
089D0:  MOVLB  0
089D2:  CALL   1E44
089D6:  MOVFF  198,9CC
089DA:  MOVLW  37
089DC:  MOVLB  9
089DE:  MOVWF  xCD
089E0:  MOVLB  0
089E2:  CALL   1E44
089E6:  MOVLW  BD
089E8:  MOVWF  FF6
089EA:  MOVLW  13
089EC:  MOVWF  FF7
089EE:  MOVLW  00
089F0:  MOVWF  FF8
089F2:  MOVLW  05
089F4:  MOVLB  9
089F6:  MOVWF  xCC
089F8:  MOVLB  0
089FA:  CALL   1BF0
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
089FE:  MOVLW  C4
08A00:  MOVWF  FF6
08A02:  MOVLW  13
08A04:  MOVWF  FF7
08A06:  MOVLW  00
08A08:  MOVWF  FF8
08A0A:  MOVLW  0F
08A0C:  MOVLB  9
08A0E:  MOVWF  xCC
08A10:  MOVLB  0
08A12:  CALL   1BF0
08A16:  MOVFF  19B,9CC
08A1A:  MOVLW  37
08A1C:  MOVLB  9
08A1E:  MOVWF  xCD
08A20:  MOVLB  0
08A22:  CALL   1E44
08A26:  MOVFF  19A,9CC
08A2A:  MOVLW  37
08A2C:  MOVLB  9
08A2E:  MOVWF  xCD
08A30:  MOVLB  0
08A32:  CALL   1E44
08A36:  MOVLW  D8
08A38:  MOVWF  FF6
08A3A:  MOVLW  13
08A3C:  MOVWF  FF7
08A3E:  MOVLW  00
08A40:  MOVWF  FF8
08A42:  MOVLW  05
08A44:  MOVLB  9
08A46:  MOVWF  xCC
08A48:  MOVLB  0
08A4A:  CALL   1BF0
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
08A4E:  MOVLW  DE
08A50:  MOVWF  FF6
08A52:  MOVLW  13
08A54:  MOVWF  FF7
08A56:  MOVLW  00
08A58:  MOVWF  FF8
08A5A:  MOVLW  10
08A5C:  MOVLB  9
08A5E:  MOVWF  xCC
08A60:  MOVLB  0
08A62:  CALL   1BF0
08A66:  MOVFF  19D,9CC
08A6A:  MOVLW  37
08A6C:  MOVLB  9
08A6E:  MOVWF  xCD
08A70:  MOVLB  0
08A72:  CALL   1E44
08A76:  MOVFF  19C,9CC
08A7A:  MOVLW  37
08A7C:  MOVLB  9
08A7E:  MOVWF  xCD
08A80:  MOVLB  0
08A82:  CALL   1E44
08A86:  MOVLW  F3
08A88:  MOVWF  FF6
08A8A:  MOVLW  13
08A8C:  MOVWF  FF7
08A8E:  MOVLW  00
08A90:  MOVWF  FF8
08A92:  MOVLW  05
08A94:  MOVLB  9
08A96:  MOVWF  xCC
08A98:  MOVLB  0
08A9A:  CALL   1BF0
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
08A9E:  MOVLW  FA
08AA0:  MOVWF  FF6
08AA2:  MOVLW  13
08AA4:  MOVWF  FF7
08AA6:  MOVLW  00
08AA8:  MOVWF  FF8
08AAA:  MOVLW  13
08AAC:  MOVLB  9
08AAE:  MOVWF  xCC
08AB0:  MOVLB  0
08AB2:  CALL   1BF0
08AB6:  MOVFF  19F,9CC
08ABA:  MOVLW  37
08ABC:  MOVLB  9
08ABE:  MOVWF  xCD
08AC0:  MOVLB  0
08AC2:  CALL   1E44
08AC6:  MOVFF  19E,9CC
08ACA:  MOVLW  37
08ACC:  MOVLB  9
08ACE:  MOVWF  xCD
08AD0:  MOVLB  0
08AD2:  CALL   1E44
08AD6:  MOVLW  12
08AD8:  MOVWF  FF6
08ADA:  MOVLW  14
08ADC:  MOVWF  FF7
08ADE:  MOVLW  00
08AE0:  MOVWF  FF8
08AE2:  MOVLW  04
08AE4:  MOVLB  9
08AE6:  MOVWF  xCC
08AE8:  MOVLB  0
08AEA:  CALL   1BF0
....................    fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
08AEE:  MOVLW  18
08AF0:  MOVWF  FF6
08AF2:  MOVLW  14
08AF4:  MOVWF  FF7
08AF6:  MOVLW  00
08AF8:  MOVWF  FF8
08AFA:  MOVLW  0E
08AFC:  MOVLB  9
08AFE:  MOVWF  xCC
08B00:  MOVLB  0
08B02:  CALL   1BF0
08B06:  MOVFF  1A0,26A
08B0A:  MOVLW  1B
08B0C:  MOVLB  2
08B0E:  MOVWF  x6B
08B10:  MOVLB  0
08B12:  CALL   66D0
08B16:  MOVLW  0D
08B18:  MOVLB  A
08B1A:  MOVWF  xB3
08B1C:  MOVLB  0
08B1E:  CALL   1B6E
08B22:  MOVLW  0A
08B24:  MOVLB  A
08B26:  MOVWF  xB3
08B28:  MOVLB  0
08B2A:  CALL   1B6E
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
08B2E:  MOVFF  195,1E6
08B32:  MOVLB  1
08B34:  CLRF   xE7
08B36:  MOVLB  0
08B38:  CALL   3F8A
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
08B3C:  CALL   31C2
08B40:  MOVFF  01,1A2
08B44:  MOVFF  00,1A1
08B48:  MOVLB  1
08B4A:  CLRF   xA4
08B4C:  CLRF   xA3
08B4E:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
08B50:  CALL   31C2
08B54:  MOVFF  03,1B4
08B58:  MOVFF  02,1B3
08B5C:  MOVFF  01,1B2
08B60:  MOVFF  00,1B1
08B64:  MOVLB  1
08B66:  MOVF   xA1,W
08B68:  SUBWF  xB1,F
08B6A:  MOVF   xA2,W
08B6C:  SUBWFB xB2,F
08B6E:  MOVLW  00
08B70:  SUBWFB xB3,F
08B72:  MOVLW  00
08B74:  SUBWFB xB4,F
08B76:  MOVF   xB4,F
08B78:  BTFSC  FD8.2
08B7A:  BRA    8B82
08B7C:  MOVLB  0
08B7E:  GOTO   8C4C
08B82:  MOVLB  0
08B84:  MOVLB  1
08B86:  MOVF   xB3,F
08B88:  BTFSC  FD8.2
08B8A:  BRA    8B92
08B8C:  MOVLB  0
08B8E:  GOTO   8C4C
08B92:  MOVLB  0
08B94:  MOVLB  1
08B96:  MOVF   xB2,W
08B98:  SUBWF  x9F,W
08B9A:  BTFSC  FD8.0
08B9C:  BRA    8BA4
08B9E:  MOVLB  0
08BA0:  GOTO   8C4C
08BA4:  MOVLB  0
08BA6:  BTFSS  FD8.2
08BA8:  GOTO   8BBE
08BAC:  MOVLB  1
08BAE:  MOVF   x9E,W
08BB0:  SUBWF  xB1,W
08BB2:  BTFSS  FD8.0
08BB4:  BRA    8BBC
08BB6:  MOVLB  0
08BB8:  GOTO   8C4C
08BBC:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
08BBE:  CALL   31C2
08BC2:  MOVFF  01,1A4
08BC6:  MOVFF  00,1A3
....................       if (current_sec - start_time >= cmd.meas_time) {
08BCA:  MOVLB  1
08BCC:  MOVF   xA1,W
08BCE:  SUBWF  xA3,W
08BD0:  MOVWF  xB1
08BD2:  MOVF   xA2,W
08BD4:  SUBWFB xA4,W
08BD6:  MOVWF  xB2
08BD8:  MOVF   x9F,W
08BDA:  SUBWF  xB2,W
08BDC:  BTFSC  FD8.0
08BDE:  BRA    8BE6
08BE0:  MOVLB  0
08BE2:  GOTO   8C04
08BE6:  MOVLB  0
08BE8:  BTFSS  FD8.2
08BEA:  GOTO   8C00
08BEE:  MOVLB  1
08BF0:  MOVF   x9E,W
08BF2:  SUBWF  xB1,W
08BF4:  BTFSC  FD8.0
08BF6:  BRA    8BFE
08BF8:  MOVLB  0
08BFA:  GOTO   8C04
08BFE:  MOVLB  0
....................           break;
08C00:  GOTO   8C4C
....................       }
....................       sweep_with_threshold(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
08C04:  MOVFF  199,1B2
08C08:  MOVFF  198,1B1
08C0C:  MOVFF  19B,1B4
08C10:  MOVFF  19A,1B3
08C14:  MOVFF  19D,1B6
08C18:  MOVFF  19C,1B5
08C1C:  GOTO   70BE
....................       // Sleep for the specified time
....................       delay_ms(cmd.sleep_time);
08C20:  MOVFF  197,1B1
08C24:  MOVLB  1
08C26:  INCF   xB1,F
08C28:  MOVLB  0
08C2A:  MOVLB  1
08C2C:  DECFSZ xB1,F
08C2E:  BRA    8C34
08C30:  MOVLB  0
08C32:  BRA    8C40
08C34:  MOVLB  A
08C36:  SETF   x74
08C38:  MOVLB  0
08C3A:  CALL   1B40
08C3E:  BRA    8C2A
08C40:  MOVFF  196,A74
08C44:  CALL   1B40
08C48:  GOTO   8B50
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
08C4C:  MOVFF  195,1E6
08C50:  MOVLB  1
08C52:  SETF   xE7
08C54:  MOVLB  0
08C56:  CALL   3F8A
.................... 
....................    FlashOperationStruct data = {0};
08C5A:  MOVLB  1
08C5C:  CLRF   xA5
08C5E:  CLRF   xA6
08C60:  CLRF   xA7
08C62:  CLRF   xA8
08C64:  CLRF   xA9
08C66:  CLRF   xAA
08C68:  CLRF   xAB
08C6A:  CLRF   xAC
08C6C:  CLRF   xAD
08C6E:  CLRF   xAE
08C70:  CLRF   xAF
08C72:  CLRF   xB0
....................    data.func_type = ENUM_SMF_WRITE;
08C74:  CLRF   xA6
....................    data.mission_id = CIGS_IV_DATA; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
08C76:  MOVLW  04
08C78:  MOVWF  xA5
....................    data.write_mode = SMF_WRITE_CIRCULAR;
08C7A:  MOVLW  02
08C7C:  MOVWF  xA7
....................    data.source_type = SOURCE_MISF_UNCOPIED;
08C7E:  BCF    xA8.0
....................    // data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    // data.size = 0; // コピーするデータのサイズ
.................... 
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
08C80:  MOVLW  2C
08C82:  MOVWF  FF6
08C84:  MOVLW  14
08C86:  MOVWF  FF7
08C88:  MOVLW  00
08C8A:  MOVWF  FF8
08C8C:  MOVLB  0
08C8E:  CALL   1BC0
....................    fprintf(PC, "Mission ID: %02X\r\n", data.mission_id);
08C92:  MOVLW  46
08C94:  MOVWF  FF6
08C96:  MOVLW  14
08C98:  MOVWF  FF7
08C9A:  MOVLW  00
08C9C:  MOVWF  FF8
08C9E:  MOVLW  0C
08CA0:  MOVLB  9
08CA2:  MOVWF  xCC
08CA4:  MOVLB  0
08CA6:  CALL   1BF0
08CAA:  MOVFF  1A5,9CC
08CAE:  MOVLW  37
08CB0:  MOVLB  9
08CB2:  MOVWF  xCD
08CB4:  MOVLB  0
08CB6:  CALL   1E44
08CBA:  MOVLW  0D
08CBC:  MOVLB  A
08CBE:  MOVWF  xB3
08CC0:  MOVLB  0
08CC2:  CALL   1B6E
08CC6:  MOVLW  0A
08CC8:  MOVLB  A
08CCA:  MOVWF  xB3
08CCC:  MOVLB  0
08CCE:  CALL   1B6E
....................    fprintf(PC, "Function Type: %02X\r\n", data.func_type);
08CD2:  MOVLW  5A
08CD4:  MOVWF  FF6
08CD6:  MOVLW  14
08CD8:  MOVWF  FF7
08CDA:  MOVLW  00
08CDC:  MOVWF  FF8
08CDE:  MOVLW  0F
08CE0:  MOVLB  9
08CE2:  MOVWF  xCC
08CE4:  MOVLB  0
08CE6:  CALL   1BF0
08CEA:  MOVFF  1A6,9CC
08CEE:  MOVLW  37
08CF0:  MOVLB  9
08CF2:  MOVWF  xCD
08CF4:  MOVLB  0
08CF6:  CALL   1E44
08CFA:  MOVLW  0D
08CFC:  MOVLB  A
08CFE:  MOVWF  xB3
08D00:  MOVLB  0
08D02:  CALL   1B6E
08D06:  MOVLW  0A
08D08:  MOVLB  A
08D0A:  MOVWF  xB3
08D0C:  MOVLB  0
08D0E:  CALL   1B6E
....................    fprintf(PC, "Write Mode: %02X\r\n", data.write_mode);
08D12:  MOVLW  70
08D14:  MOVWF  FF6
08D16:  MOVLW  14
08D18:  MOVWF  FF7
08D1A:  MOVLW  00
08D1C:  MOVWF  FF8
08D1E:  MOVLW  0C
08D20:  MOVLB  9
08D22:  MOVWF  xCC
08D24:  MOVLB  0
08D26:  CALL   1BF0
08D2A:  MOVFF  1A7,9CC
08D2E:  MOVLW  37
08D30:  MOVLB  9
08D32:  MOVWF  xCD
08D34:  MOVLB  0
08D36:  CALL   1E44
08D3A:  MOVLW  0D
08D3C:  MOVLB  A
08D3E:  MOVWF  xB3
08D40:  MOVLB  0
08D42:  CALL   1B6E
08D46:  MOVLW  0A
08D48:  MOVLB  A
08D4A:  MOVWF  xB3
08D4C:  MOVLB  0
08D4E:  CALL   1B6E
....................    fprintf(PC, "Source Type: %02X\r\n", data.source_type);
08D52:  MOVLW  00
08D54:  MOVLB  1
08D56:  BTFSC  xA8.0
08D58:  MOVLW  01
08D5A:  MOVWF  xB1
08D5C:  MOVLW  84
08D5E:  MOVWF  FF6
08D60:  MOVLW  14
08D62:  MOVWF  FF7
08D64:  MOVLW  00
08D66:  MOVWF  FF8
08D68:  MOVLW  0D
08D6A:  MOVLB  9
08D6C:  MOVWF  xCC
08D6E:  MOVLB  0
08D70:  CALL   1BF0
08D74:  MOVFF  1B1,9CC
08D78:  MOVLW  37
08D7A:  MOVLB  9
08D7C:  MOVWF  xCD
08D7E:  MOVLB  0
08D80:  CALL   1E44
08D84:  MOVLW  0D
08D86:  MOVLB  A
08D88:  MOVWF  xB3
08D8A:  MOVLB  0
08D8C:  CALL   1B6E
08D90:  MOVLW  0A
08D92:  MOVLB  A
08D94:  MOVWF  xB3
08D96:  MOVLB  0
08D98:  CALL   1B6E
....................    fprintf(PC, "Start Address: %04X\r\n", data.misf_start_addr);
08D9C:  MOVLW  98
08D9E:  MOVWF  FF6
08DA0:  MOVLW  14
08DA2:  MOVWF  FF7
08DA4:  MOVLW  00
08DA6:  MOVWF  FF8
08DA8:  MOVLW  0F
08DAA:  MOVLB  9
08DAC:  MOVWF  xCC
08DAE:  MOVLB  0
08DB0:  CALL   1BF0
08DB4:  MOVLW  02
08DB6:  MOVLB  1
08DB8:  MOVWF  xB1
08DBA:  MOVLB  0
08DBC:  MOVLW  30
08DBE:  MOVLB  A
08DC0:  MOVWF  xB3
08DC2:  MOVLB  0
08DC4:  CALL   1B6E
08DC8:  MOVLB  1
08DCA:  DECFSZ xB1,F
08DCC:  BRA    8DD2
08DCE:  BRA    8DD8
08DD0:  MOVLB  0
08DD2:  MOVLB  0
08DD4:  GOTO   8DBC
08DD8:  MOVFF  1A9,9CC
08DDC:  MOVLW  37
08DDE:  MOVLB  9
08DE0:  MOVWF  xCD
08DE2:  MOVLB  0
08DE4:  CALL   1E44
08DE8:  MOVLW  0D
08DEA:  MOVLB  A
08DEC:  MOVWF  xB3
08DEE:  MOVLB  0
08DF0:  CALL   1B6E
08DF4:  MOVLW  0A
08DF6:  MOVLB  A
08DF8:  MOVWF  xB3
08DFA:  MOVLB  0
08DFC:  CALL   1B6E
....................    fprintf(PC, "Size: %04X\r\n", data.misf_size);
08E00:  MOVLW  AE
08E02:  MOVWF  FF6
08E04:  MOVLW  14
08E06:  MOVWF  FF7
08E08:  MOVLW  00
08E0A:  MOVWF  FF8
08E0C:  MOVLW  06
08E0E:  MOVLB  9
08E10:  MOVWF  xCC
08E12:  MOVLB  0
08E14:  CALL   1BF0
08E18:  MOVLW  02
08E1A:  MOVLB  1
08E1C:  MOVWF  xB1
08E1E:  MOVLB  0
08E20:  MOVLW  30
08E22:  MOVLB  A
08E24:  MOVWF  xB3
08E26:  MOVLB  0
08E28:  CALL   1B6E
08E2C:  MOVLB  1
08E2E:  DECFSZ xB1,F
08E30:  BRA    8E36
08E32:  BRA    8E3C
08E34:  MOVLB  0
08E36:  MOVLB  0
08E38:  GOTO   8E20
08E3C:  MOVFF  1AD,9CC
08E40:  MOVLW  37
08E42:  MOVLB  9
08E44:  MOVWF  xCD
08E46:  MOVLB  0
08E48:  CALL   1E44
08E4C:  MOVLW  0D
08E4E:  MOVLB  A
08E50:  MOVWF  xB3
08E52:  MOVLB  0
08E54:  CALL   1B6E
08E58:  MOVLW  0A
08E5A:  MOVLB  A
08E5C:  MOVWF  xB3
08E5E:  MOVLB  0
08E60:  CALL   1B6E
.................... 
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
08E64:  MOVLW  01
08E66:  MOVLB  1
08E68:  MOVWF  xB2
08E6A:  MOVLW  A5
08E6C:  MOVWF  xB1
08E6E:  MOVLB  0
08E70:  GOTO   867E
.................... 
....................    fprintf(PC, "End MODE MEAS IV mission\r\n");
08E74:  MOVLW  BC
08E76:  MOVWF  FF6
08E78:  MOVLW  14
08E7A:  MOVWF  FF7
08E7C:  MOVLW  00
08E7E:  MOVWF  FF8
08E80:  CALL   1BC0
08E84:  GOTO   90C2 (RETURN)
.................... }
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
0657A:  MOVLB  1
0657C:  MOVF   xB7,W
0657E:  MOVWF  FE9
06580:  MOVF   xB8,W
06582:  MOVWF  FEA
06584:  MOVFF  FEF,1B9
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
06588:  MOVLW  01
0658A:  ADDWF  xB7,W
0658C:  MOVWF  FE9
0658E:  MOVLW  00
06590:  ADDWFC xB8,W
06592:  MOVWF  FEA
06594:  MOVF   FEF,W
06596:  CLRF   xC6
06598:  MOVWF  xC5
0659A:  MOVFF  1C5,1C6
0659E:  CLRF   xC5
065A0:  MOVLW  02
065A2:  ADDWF  xB7,W
065A4:  MOVWF  FE9
065A6:  MOVLW  00
065A8:  ADDWFC xB8,W
065AA:  MOVWF  FEA
065AC:  MOVF   FEF,W
065AE:  CLRF   03
065B0:  IORWF  xC5,W
065B2:  MOVWF  xBA
065B4:  MOVF   03,W
065B6:  IORWF  xC6,W
065B8:  MOVWF  xBB
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
065BA:  MOVLW  03
065BC:  ADDWF  xB7,W
065BE:  MOVWF  FE9
065C0:  MOVLW  00
065C2:  ADDWFC xB8,W
065C4:  MOVWF  FEA
065C6:  MOVF   FEF,W
065C8:  CLRF   xC6
065CA:  MOVWF  xC5
065CC:  RLCF   xC5,W
065CE:  MOVWF  xBC
065D0:  RLCF   xC6,W
065D2:  MOVWF  xBD
065D4:  RLCF   xBC,F
065D6:  RLCF   xBD,F
065D8:  RLCF   xBC,F
065DA:  RLCF   xBD,F
065DC:  RLCF   xBC,F
065DE:  RLCF   xBD,F
065E0:  MOVLW  F0
065E2:  ANDWF  xBC,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
065E4:  MOVLW  04
065E6:  ADDWF  xB7,W
065E8:  MOVWF  FE9
065EA:  MOVLW  00
065EC:  ADDWFC xB8,W
065EE:  MOVWF  FEA
065F0:  MOVF   FEF,W
065F2:  CLRF   xC6
065F4:  MOVWF  xC5
065F6:  RLCF   xC5,W
065F8:  MOVWF  xBE
065FA:  RLCF   xC6,W
065FC:  MOVWF  xBF
065FE:  RLCF   xBE,F
06600:  RLCF   xBF,F
06602:  RLCF   xBE,F
06604:  RLCF   xBF,F
06606:  RLCF   xBE,F
06608:  RLCF   xBF,F
0660A:  MOVLW  F0
0660C:  ANDWF  xBE,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
0660E:  MOVLW  05
06610:  ADDWF  xB7,W
06612:  MOVWF  FE9
06614:  MOVLW  00
06616:  ADDWFC xB8,W
06618:  MOVWF  FEA
0661A:  MOVF   FEF,W
0661C:  CLRF   xC6
0661E:  MOVWF  xC5
06620:  RLCF   xC5,W
06622:  MOVWF  xC0
06624:  RLCF   xC6,W
06626:  MOVWF  xC1
06628:  RLCF   xC0,F
0662A:  RLCF   xC1,F
0662C:  RLCF   xC0,F
0662E:  RLCF   xC1,F
06630:  RLCF   xC0,F
06632:  RLCF   xC1,F
06634:  MOVLW  F0
06636:  ANDWF  xC0,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
06638:  MOVLW  06
0663A:  ADDWF  xB7,W
0663C:  MOVWF  FE9
0663E:  MOVLW  00
06640:  ADDWFC xB8,W
06642:  MOVWF  FEA
06644:  MOVF   FEF,W
06646:  CLRF   xC6
06648:  MOVWF  xC5
0664A:  MOVFF  1C5,1C6
0664E:  CLRF   xC5
06650:  MOVLW  07
06652:  ADDWF  xB7,W
06654:  MOVWF  FE9
06656:  MOVLW  00
06658:  ADDWFC xB8,W
0665A:  MOVWF  FEA
0665C:  MOVF   FEF,W
0665E:  CLRF   03
06660:  IORWF  xC5,W
06662:  MOVWF  xC2
06664:  MOVF   03,W
06666:  IORWF  xC6,W
06668:  MOVWF  xC3
....................    cmd.is_finished = uplinkcmd[8];
0666A:  MOVLW  08
0666C:  ADDWF  xB7,W
0666E:  MOVWF  FE9
06670:  MOVLW  00
06672:  ADDWFC xB8,W
06674:  MOVWF  FEA
06676:  MOVFF  FEF,1C4
....................    return cmd;
0667A:  MOVLW  B9
0667C:  MOVWF  01
0667E:  MOVLW  01
06680:  MOVWF  02
06682:  MOVLB  0
06684:  GOTO   88FC (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00321000
.................... #define MISF_CIGS_IV_HEADER_END   0x00720FFF
.................... #define MISF_CIGS_IV_DATA_START   0x00721000
.................... #define MISF_CIGS_IV_DATA_END     0x007C1000
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
047E2:  MOVLW  D8
047E4:  MOVWF  FF6
047E6:  MOVLW  14
047E8:  MOVWF  FF7
047EA:  MOVLW  00
047EC:  MOVWF  FF8
047EE:  CALL   1BC0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
047F2:  MOVLB  1
047F4:  MOVF   x95,W
047F6:  MOVWF  FE9
047F8:  MOVF   x96,W
047FA:  MOVWF  FEA
047FC:  MOVFF  FEF,197
....................    piclog_make(cmd, 0x00); // Log the command execution
04800:  MOVFF  197,1E6
04804:  CLRF   xE7
04806:  MOVLB  0
04808:  CALL   3F8A
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
0480C:  MOVLB  1
0480E:  CLRF   x9B
04810:  CLRF   x9A
04812:  CLRF   x99
04814:  CLRF   x98
04816:  MOVLB  0
04818:  MOVLB  1
0481A:  MOVF   x9B,F
0481C:  BTFSC  FD8.2
0481E:  BRA    4826
04820:  MOVLB  0
04822:  GOTO   489E
04826:  MOVLB  0
04828:  MOVLB  1
0482A:  MOVF   x9A,W
0482C:  SUBLW  0F
0482E:  BTFSC  FD8.0
04830:  BRA    4838
04832:  MOVLB  0
04834:  GOTO   489E
04838:  MOVLB  0
0483A:  BTFSS  FD8.2
0483C:  GOTO   486A
04840:  MOVLB  1
04842:  MOVF   x99,W
04844:  SUBLW  FF
04846:  BTFSC  FD8.0
04848:  BRA    4850
0484A:  MOVLB  0
0484C:  GOTO   489E
04850:  MOVLB  0
04852:  BTFSS  FD8.2
04854:  GOTO   486A
04858:  MOVLB  1
0485A:  MOVF   x98,W
0485C:  SUBLW  FE
0485E:  BTFSC  FD8.0
04860:  BRA    4868
04862:  MOVLB  0
04864:  GOTO   489E
04868:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
0486A:  MOVFF  111,A5F
0486E:  MOVFF  110,A5E
04872:  MOVFF  10F,A5D
04876:  MOVFF  10E,A5C
0487A:  MOVFF  19B,A63
0487E:  MOVFF  19A,A62
04882:  MOVFF  199,A61
04886:  MOVFF  198,A60
0488A:  CALL   3BBC
0488E:  MOVLW  01
04890:  MOVLB  1
04892:  ADDWF  x9A,F
04894:  MOVLW  00
04896:  ADDWFC x9B,F
04898:  MOVLB  0
0489A:  GOTO   4818
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0489E:  MOVFF  197,1E6
048A2:  MOVLB  1
048A4:  SETF   xE7
048A6:  MOVLB  0
048A8:  CALL   3F8A
....................    printf("End Flash Erase All\r\n");
048AC:  MOVLW  F0
048AE:  MOVWF  FF6
048B0:  MOVLW  14
048B2:  MOVWF  FF7
048B4:  MOVLW  00
048B6:  MOVWF  FF8
048B8:  CALL   1BC0
048BC:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
048BE:  MOVLW  06
048C0:  MOVWF  FF6
048C2:  MOVLW  15
048C4:  MOVWF  FF7
048C6:  MOVLW  00
048C8:  MOVWF  FF8
048CA:  CALL   1BC0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
048CE:  MOVLB  1
048D0:  MOVF   x93,W
048D2:  MOVWF  FE9
048D4:  MOVF   x94,W
048D6:  MOVWF  FEA
048D8:  MOVFF  FEF,195
048DC:  MOVLW  01
048DE:  ADDWF  x93,W
048E0:  MOVWF  FE9
048E2:  MOVLW  00
048E4:  ADDWFC x94,W
048E6:  MOVWF  FEA
048E8:  MOVF   FEF,W
048EA:  CLRF   x9D
048EC:  CLRF   x9C
048EE:  CLRF   x9B
048F0:  MOVWF  x9A
048F2:  MOVFF  19A,19D
048F6:  CLRF   x9A
048F8:  CLRF   x9B
048FA:  CLRF   x9C
048FC:  MOVLW  02
048FE:  ADDWF  x93,W
04900:  MOVWF  FE9
04902:  MOVLW  00
04904:  ADDWFC x94,W
04906:  MOVWF  FEA
04908:  MOVF   FEF,W
0490A:  CLRF   xA2
0490C:  CLRF   xA1
0490E:  CLRF   xA0
04910:  MOVWF  x9F
04912:  MOVFF  1A0,03
04916:  MOVFF  19F,02
0491A:  CLRF   00
0491C:  CLRF   01
0491E:  MOVF   00,W
04920:  IORWF  x9A,F
04922:  MOVF   01,W
04924:  IORWF  x9B,F
04926:  MOVF   02,W
04928:  IORWF  x9C,F
0492A:  MOVF   03,W
0492C:  IORWF  x9D,F
0492E:  MOVLW  03
04930:  ADDWF  x93,W
04932:  MOVWF  FE9
04934:  MOVLW  00
04936:  ADDWFC x94,W
04938:  MOVWF  FEA
0493A:  MOVF   FEF,W
0493C:  CLRF   xA2
0493E:  CLRF   xA1
04940:  CLRF   xA0
04942:  MOVWF  x9F
04944:  MOVFF  1A1,03
04948:  MOVFF  1A0,02
0494C:  MOVFF  19F,01
04950:  CLRF   00
04952:  MOVF   00,W
04954:  IORWF  x9A,F
04956:  MOVF   01,W
04958:  IORWF  x9B,F
0495A:  MOVF   02,W
0495C:  IORWF  x9C,F
0495E:  MOVF   03,W
04960:  IORWF  x9D,F
04962:  MOVLW  04
04964:  ADDWF  x93,W
04966:  MOVWF  FE9
04968:  MOVLW  00
0496A:  ADDWFC x94,W
0496C:  MOVWF  FEA
0496E:  MOVF   FEF,W
04970:  MOVWF  00
04972:  CLRF   01
04974:  CLRF   02
04976:  CLRF   03
04978:  MOVF   00,W
0497A:  IORWF  x9A,W
0497C:  MOVWF  x96
0497E:  MOVF   01,W
04980:  IORWF  x9B,W
04982:  MOVWF  x97
04984:  MOVF   02,W
04986:  IORWF  x9C,W
04988:  MOVWF  x98
0498A:  MOVF   03,W
0498C:  IORWF  x9D,W
0498E:  MOVWF  x99
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
04990:  MOVLW  24
04992:  MOVWF  FF6
04994:  MOVLW  15
04996:  MOVWF  FF7
04998:  MOVLW  00
0499A:  MOVWF  FF8
0499C:  MOVLW  13
0499E:  MOVLB  9
049A0:  MOVWF  xCC
049A2:  MOVLB  0
049A4:  CALL   1BF0
049A8:  MOVFF  199,9CC
049AC:  MOVLW  37
049AE:  MOVLB  9
049B0:  MOVWF  xCD
049B2:  MOVLB  0
049B4:  CALL   1E44
049B8:  MOVFF  198,9CC
049BC:  MOVLW  37
049BE:  MOVLB  9
049C0:  MOVWF  xCD
049C2:  MOVLB  0
049C4:  CALL   1E44
049C8:  MOVFF  197,9CC
049CC:  MOVLW  37
049CE:  MOVLB  9
049D0:  MOVWF  xCD
049D2:  MOVLB  0
049D4:  CALL   1E44
049D8:  MOVFF  196,9CC
049DC:  MOVLW  37
049DE:  MOVLB  9
049E0:  MOVWF  xCD
049E2:  MOVLB  0
049E4:  CALL   1E44
049E8:  MOVLW  0D
049EA:  MOVLB  A
049EC:  MOVWF  xB3
049EE:  MOVLB  0
049F0:  CALL   1B6E
049F4:  MOVLW  0A
049F6:  MOVLB  A
049F8:  MOVWF  xB3
049FA:  MOVLB  0
049FC:  CALL   1B6E
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04A00:  MOVFF  195,1E6
04A04:  MOVLB  1
04A06:  CLRF   xE7
04A08:  MOVLB  0
04A0A:  CALL   3F8A
....................    
....................    sector_erase(mis_fm, sector_address);
04A0E:  MOVFF  111,A5F
04A12:  MOVFF  110,A5E
04A16:  MOVFF  10F,A5D
04A1A:  MOVFF  10E,A5C
04A1E:  MOVFF  199,A63
04A22:  MOVFF  198,A62
04A26:  MOVFF  197,A61
04A2A:  MOVFF  196,A60
04A2E:  CALL   3BBC
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04A32:  MOVFF  195,1E6
04A36:  MOVLB  1
04A38:  SETF   xE7
04A3A:  MOVLB  0
04A3C:  CALL   3F8A
....................    printf("End Flash Erase 1 Sector\r\n");
04A40:  MOVLW  40
04A42:  MOVWF  FF6
04A44:  MOVLW  15
04A46:  MOVWF  FF7
04A48:  MOVLW  00
04A4A:  MOVWF  FF8
04A4C:  CALL   1BC0
04A50:  GOTO   8FD2 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
04DC4:  MOVLW  5C
04DC6:  MOVWF  FF6
04DC8:  MOVLW  15
04DCA:  MOVWF  FF7
04DCC:  MOVLW  00
04DCE:  MOVWF  FF8
04DD0:  CALL   1BC0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
04DD4:  MOVLB  1
04DD6:  MOVF   x93,W
04DD8:  MOVWF  FE9
04DDA:  MOVF   x94,W
04DDC:  MOVWF  FEA
04DDE:  MOVFF  FEF,195
04DE2:  MOVLW  01
04DE4:  ADDWF  x93,W
04DE6:  MOVWF  FE9
04DE8:  MOVLW  00
04DEA:  ADDWFC x94,W
04DEC:  MOVWF  FEA
04DEE:  MOVF   FEF,W
04DF0:  CLRF   x9D
04DF2:  CLRF   x9C
04DF4:  CLRF   x9B
04DF6:  MOVWF  x9A
04DF8:  MOVFF  19A,19D
04DFC:  CLRF   x9A
04DFE:  CLRF   x9B
04E00:  CLRF   x9C
04E02:  MOVLW  02
04E04:  ADDWF  x93,W
04E06:  MOVWF  FE9
04E08:  MOVLW  00
04E0A:  ADDWFC x94,W
04E0C:  MOVWF  FEA
04E0E:  MOVF   FEF,W
04E10:  CLRF   xA2
04E12:  CLRF   xA1
04E14:  CLRF   xA0
04E16:  MOVWF  x9F
04E18:  MOVFF  1A0,03
04E1C:  MOVFF  19F,02
04E20:  CLRF   00
04E22:  CLRF   01
04E24:  MOVF   00,W
04E26:  IORWF  x9A,F
04E28:  MOVF   01,W
04E2A:  IORWF  x9B,F
04E2C:  MOVF   02,W
04E2E:  IORWF  x9C,F
04E30:  MOVF   03,W
04E32:  IORWF  x9D,F
04E34:  MOVLW  03
04E36:  ADDWF  x93,W
04E38:  MOVWF  FE9
04E3A:  MOVLW  00
04E3C:  ADDWFC x94,W
04E3E:  MOVWF  FEA
04E40:  MOVF   FEF,W
04E42:  CLRF   xA2
04E44:  CLRF   xA1
04E46:  CLRF   xA0
04E48:  MOVWF  x9F
04E4A:  MOVFF  1A1,03
04E4E:  MOVFF  1A0,02
04E52:  MOVFF  19F,01
04E56:  CLRF   00
04E58:  MOVF   00,W
04E5A:  IORWF  x9A,F
04E5C:  MOVF   01,W
04E5E:  IORWF  x9B,F
04E60:  MOVF   02,W
04E62:  IORWF  x9C,F
04E64:  MOVF   03,W
04E66:  IORWF  x9D,F
04E68:  MOVLW  04
04E6A:  ADDWF  x93,W
04E6C:  MOVWF  FE9
04E6E:  MOVLW  00
04E70:  ADDWFC x94,W
04E72:  MOVWF  FEA
04E74:  MOVF   FEF,W
04E76:  MOVWF  00
04E78:  CLRF   01
04E7A:  CLRF   02
04E7C:  CLRF   03
04E7E:  MOVF   00,W
04E80:  IORWF  x9A,W
04E82:  MOVWF  x96
04E84:  MOVF   01,W
04E86:  IORWF  x9B,W
04E88:  MOVWF  x97
04E8A:  MOVF   02,W
04E8C:  IORWF  x9C,W
04E8E:  MOVWF  x98
04E90:  MOVF   03,W
04E92:  IORWF  x9D,W
04E94:  MOVWF  x99
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
04E96:  MOVLW  78
04E98:  MOVWF  FF6
04E9A:  MOVLW  15
04E9C:  MOVWF  FF7
04E9E:  MOVLW  00
04EA0:  MOVWF  FF8
04EA2:  MOVLW  16
04EA4:  MOVLB  9
04EA6:  MOVWF  xCC
04EA8:  MOVLB  0
04EAA:  CALL   1BF0
04EAE:  MOVFF  199,9CC
04EB2:  MOVLW  37
04EB4:  MOVLB  9
04EB6:  MOVWF  xCD
04EB8:  MOVLB  0
04EBA:  CALL   1E44
04EBE:  MOVFF  198,9CC
04EC2:  MOVLW  37
04EC4:  MOVLB  9
04EC6:  MOVWF  xCD
04EC8:  MOVLB  0
04ECA:  CALL   1E44
04ECE:  MOVFF  197,9CC
04ED2:  MOVLW  37
04ED4:  MOVLB  9
04ED6:  MOVWF  xCD
04ED8:  MOVLB  0
04EDA:  CALL   1E44
04EDE:  MOVFF  196,9CC
04EE2:  MOVLW  37
04EE4:  MOVLB  9
04EE6:  MOVWF  xCD
04EE8:  MOVLB  0
04EEA:  CALL   1E44
04EEE:  MOVLW  0D
04EF0:  MOVLB  A
04EF2:  MOVWF  xB3
04EF4:  MOVLB  0
04EF6:  CALL   1B6E
04EFA:  MOVLW  0A
04EFC:  MOVLB  A
04EFE:  MOVWF  xB3
04F00:  MOVLB  0
04F02:  CALL   1B6E
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04F06:  MOVFF  195,1E6
04F0A:  MOVLB  1
04F0C:  CLRF   xE7
04F0E:  MOVLB  0
04F10:  CALL   3F8A
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
04F14:  MOVFF  111,2EB
04F18:  MOVFF  110,2EA
04F1C:  MOVFF  10F,2E9
04F20:  MOVFF  10E,2E8
04F24:  MOVLB  2
04F26:  CLRF   xEF
04F28:  CLRF   xEE
04F2A:  CLRF   xED
04F2C:  CLRF   xEC
04F2E:  MOVLB  0
04F30:  CALL   4A54
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04F34:  MOVFF  195,1E6
04F38:  MOVLB  1
04F3A:  SETF   xE7
04F3C:  MOVLB  0
04F3E:  CALL   3F8A
....................    printf("End Flash Copy 1 Sector\r\n");
04F42:  MOVLW  96
04F44:  MOVWF  FF6
04F46:  MOVLW  15
04F48:  MOVWF  FF7
04F4A:  MOVLW  00
04F4C:  MOVWF  FF8
04F4E:  CALL   1BC0
04F52:  GOTO   8FE2 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
04F56:  MOVLW  B0
04F58:  MOVWF  FF6
04F5A:  MOVLW  15
04F5C:  MOVWF  FF7
04F5E:  MOVLW  00
04F60:  MOVWF  FF8
04F62:  CALL   1BC0
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
04F66:  MOVLB  1
04F68:  MOVF   x93,W
04F6A:  MOVWF  FE9
04F6C:  MOVF   x94,W
04F6E:  MOVWF  FEA
04F70:  MOVFF  FEF,195
04F74:  MOVLW  01
04F76:  ADDWF  x93,W
04F78:  MOVWF  FE9
04F7A:  MOVLW  00
04F7C:  ADDWFC x94,W
04F7E:  MOVWF  FEA
04F80:  MOVF   FEF,W
04F82:  CLRF   x9D
04F84:  CLRF   x9C
04F86:  CLRF   x9B
04F88:  MOVWF  x9A
04F8A:  MOVFF  19A,19D
04F8E:  CLRF   x9A
04F90:  CLRF   x9B
04F92:  CLRF   x9C
04F94:  MOVLW  02
04F96:  ADDWF  x93,W
04F98:  MOVWF  FE9
04F9A:  MOVLW  00
04F9C:  ADDWFC x94,W
04F9E:  MOVWF  FEA
04FA0:  MOVF   FEF,W
04FA2:  CLRF   xA2
04FA4:  CLRF   xA1
04FA6:  CLRF   xA0
04FA8:  MOVWF  x9F
04FAA:  MOVFF  1A0,03
04FAE:  MOVFF  19F,02
04FB2:  CLRF   00
04FB4:  CLRF   01
04FB6:  MOVF   00,W
04FB8:  IORWF  x9A,F
04FBA:  MOVF   01,W
04FBC:  IORWF  x9B,F
04FBE:  MOVF   02,W
04FC0:  IORWF  x9C,F
04FC2:  MOVF   03,W
04FC4:  IORWF  x9D,F
04FC6:  MOVLW  03
04FC8:  ADDWF  x93,W
04FCA:  MOVWF  FE9
04FCC:  MOVLW  00
04FCE:  ADDWFC x94,W
04FD0:  MOVWF  FEA
04FD2:  MOVF   FEF,W
04FD4:  CLRF   xA2
04FD6:  CLRF   xA1
04FD8:  CLRF   xA0
04FDA:  MOVWF  x9F
04FDC:  MOVFF  1A1,03
04FE0:  MOVFF  1A0,02
04FE4:  MOVFF  19F,01
04FE8:  CLRF   00
04FEA:  MOVF   00,W
04FEC:  IORWF  x9A,F
04FEE:  MOVF   01,W
04FF0:  IORWF  x9B,F
04FF2:  MOVF   02,W
04FF4:  IORWF  x9C,F
04FF6:  MOVF   03,W
04FF8:  IORWF  x9D,F
04FFA:  MOVLW  04
04FFC:  ADDWF  x93,W
04FFE:  MOVWF  FE9
05000:  MOVLW  00
05002:  ADDWFC x94,W
05004:  MOVWF  FEA
05006:  MOVF   FEF,W
05008:  MOVWF  00
0500A:  CLRF   01
0500C:  CLRF   02
0500E:  CLRF   03
05010:  MOVF   00,W
05012:  IORWF  x9A,W
05014:  MOVWF  x96
05016:  MOVF   01,W
05018:  IORWF  x9B,W
0501A:  MOVWF  x97
0501C:  MOVF   02,W
0501E:  IORWF  x9C,W
05020:  MOVWF  x98
05022:  MOVF   03,W
05024:  IORWF  x9D,W
05026:  MOVWF  x99
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
05028:  MOVLW  D6
0502A:  MOVWF  FF6
0502C:  MOVLW  15
0502E:  MOVWF  FF7
05030:  MOVLW  00
05032:  MOVWF  FF8
05034:  MOVLW  16
05036:  MOVLB  9
05038:  MOVWF  xCC
0503A:  MOVLB  0
0503C:  CALL   1BF0
05040:  MOVFF  199,9CC
05044:  MOVLW  37
05046:  MOVLB  9
05048:  MOVWF  xCD
0504A:  MOVLB  0
0504C:  CALL   1E44
05050:  MOVFF  198,9CC
05054:  MOVLW  37
05056:  MOVLB  9
05058:  MOVWF  xCD
0505A:  MOVLB  0
0505C:  CALL   1E44
05060:  MOVFF  197,9CC
05064:  MOVLW  37
05066:  MOVLB  9
05068:  MOVWF  xCD
0506A:  MOVLB  0
0506C:  CALL   1E44
05070:  MOVFF  196,9CC
05074:  MOVLW  37
05076:  MOVLB  9
05078:  MOVWF  xCD
0507A:  MOVLB  0
0507C:  CALL   1E44
05080:  MOVLW  0D
05082:  MOVLB  A
05084:  MOVWF  xB3
05086:  MOVLB  0
05088:  CALL   1B6E
0508C:  MOVLW  0A
0508E:  MOVLB  A
05090:  MOVWF  xB3
05092:  MOVLB  0
05094:  CALL   1B6E
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05098:  MOVFF  195,1E6
0509C:  MOVLB  1
0509E:  CLRF   xE7
050A0:  MOVLB  0
050A2:  CALL   3F8A
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
050A6:  MOVFF  195,1E6
050AA:  MOVLB  1
050AC:  SETF   xE7
050AE:  MOVLB  0
050B0:  CALL   3F8A
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
050B4:  MOVLW  F4
050B6:  MOVWF  FF6
050B8:  MOVLW  15
050BA:  MOVWF  FF7
050BC:  MOVLW  00
050BE:  MOVWF  FF8
050C0:  CALL   1BC0
050C4:  GOTO   8FF2 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
050C8:  MOVLW  18
050CA:  MOVWF  FF6
050CC:  MOVLW  16
050CE:  MOVWF  FF7
050D0:  MOVLW  00
050D2:  MOVWF  FF8
050D4:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
050D8:  MOVLB  1
050DA:  MOVF   x93,W
050DC:  MOVWF  FE9
050DE:  MOVF   x94,W
050E0:  MOVWF  FEA
050E2:  MOVFF  FEF,1E5
050E6:  MOVFF  1E5,1E6
050EA:  CLRF   xE7
050EC:  MOVLB  0
050EE:  CALL   3F8A
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
050F2:  MOVLB  1
050F4:  CLRF   x95
050F6:  CLRF   x96
050F8:  CLRF   x97
050FA:  CLRF   x98
050FC:  CLRF   x99
050FE:  CLRF   x9A
05100:  CLRF   x9B
....................    
....................    flash_write_param.id = parameter[0];
05102:  MOVF   x93,W
05104:  MOVWF  FE9
05106:  MOVF   x94,W
05108:  MOVWF  FEA
0510A:  MOVFF  FEF,195
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
0510E:  MOVLW  01
05110:  ADDWF  x93,W
05112:  MOVWF  FE9
05114:  MOVLW  00
05116:  ADDWFC x94,W
05118:  MOVWF  FEA
0511A:  MOVF   FEF,W
0511C:  CLRF   xE8
0511E:  CLRF   xE7
05120:  CLRF   xE6
05122:  MOVWF  xE5
05124:  MOVFF  1E5,1E8
05128:  CLRF   xE5
0512A:  CLRF   xE6
0512C:  CLRF   xE7
0512E:  MOVLW  02
05130:  ADDWF  x93,W
05132:  MOVWF  FE9
05134:  MOVLW  00
05136:  ADDWFC x94,W
05138:  MOVWF  FEA
0513A:  MOVF   FEF,W
0513C:  CLRF   xED
0513E:  CLRF   xEC
05140:  CLRF   xEB
05142:  MOVWF  xEA
05144:  MOVFF  1EB,03
05148:  MOVFF  1EA,02
0514C:  CLRF   00
0514E:  CLRF   01
05150:  MOVF   00,W
05152:  IORWF  xE5,F
05154:  MOVF   01,W
05156:  IORWF  xE6,F
05158:  MOVF   02,W
0515A:  IORWF  xE7,F
0515C:  MOVF   03,W
0515E:  IORWF  xE8,F
05160:  MOVLW  03
05162:  ADDWF  x93,W
05164:  MOVWF  FE9
05166:  MOVLW  00
05168:  ADDWFC x94,W
0516A:  MOVWF  FEA
0516C:  MOVF   FEF,W
0516E:  CLRF   xED
05170:  CLRF   xEC
05172:  CLRF   xEB
05174:  MOVWF  xEA
05176:  MOVFF  1EC,03
0517A:  MOVFF  1EB,02
0517E:  MOVFF  1EA,01
05182:  CLRF   00
05184:  MOVF   00,W
05186:  IORWF  xE5,F
05188:  MOVF   01,W
0518A:  IORWF  xE6,F
0518C:  MOVF   02,W
0518E:  IORWF  xE7,F
05190:  MOVF   03,W
05192:  IORWF  xE8,F
05194:  MOVLW  04
05196:  ADDWF  x93,W
05198:  MOVWF  FE9
0519A:  MOVLW  00
0519C:  ADDWFC x94,W
0519E:  MOVWF  FEA
051A0:  MOVF   FEF,W
051A2:  MOVWF  00
051A4:  CLRF   01
051A6:  CLRF   02
051A8:  CLRF   03
051AA:  MOVF   00,W
051AC:  IORWF  xE5,W
051AE:  MOVWF  x96
051B0:  MOVF   01,W
051B2:  IORWF  xE6,W
051B4:  MOVWF  x97
051B6:  MOVF   02,W
051B8:  IORWF  xE7,W
051BA:  MOVWF  x98
051BC:  MOVF   03,W
051BE:  IORWF  xE8,W
051C0:  MOVWF  x99
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
051C2:  MOVLW  07
051C4:  ADDWF  x93,W
051C6:  MOVWF  FE9
051C8:  MOVLW  00
051CA:  ADDWFC x94,W
051CC:  MOVWF  FEA
051CE:  MOVF   FEF,W
051D0:  CLRF   xE6
051D2:  MOVWF  xE5
051D4:  MOVFF  1E5,1E6
051D8:  CLRF   xE5
051DA:  MOVLW  08
051DC:  ADDWF  x93,W
051DE:  MOVWF  FE9
051E0:  MOVLW  00
051E2:  ADDWFC x94,W
051E4:  MOVWF  FEA
051E6:  MOVF   FEF,W
051E8:  CLRF   03
051EA:  IORWF  xE5,W
051EC:  MOVWF  x9A
051EE:  MOVF   03,W
051F0:  IORWF  xE6,W
051F2:  MOVWF  x9B
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
051F4:  MOVLW  32
051F6:  MOVWF  FF6
051F8:  MOVLW  16
051FA:  MOVWF  FF7
051FC:  MOVLW  00
051FE:  MOVWF  FF8
05200:  MOVLW  0C
05202:  MOVLB  9
05204:  MOVWF  xCC
05206:  MOVLB  0
05208:  CALL   1BF0
0520C:  MOVFF  195,9CC
05210:  MOVLW  37
05212:  MOVLB  9
05214:  MOVWF  xCD
05216:  MOVLB  0
05218:  CALL   1E44
0521C:  MOVLW  0D
0521E:  MOVLB  A
05220:  MOVWF  xB3
05222:  MOVLB  0
05224:  CALL   1B6E
05228:  MOVLW  0A
0522A:  MOVLB  A
0522C:  MOVWF  xB3
0522E:  MOVLB  0
05230:  CALL   1B6E
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
05234:  MOVLW  46
05236:  MOVWF  FF6
05238:  MOVLW  16
0523A:  MOVWF  FF7
0523C:  MOVLW  00
0523E:  MOVWF  FF8
05240:  MOVLW  0E
05242:  MOVLB  9
05244:  MOVWF  xCC
05246:  MOVLB  0
05248:  CALL   1BF0
0524C:  MOVFF  199,9CC
05250:  MOVLW  37
05252:  MOVLB  9
05254:  MOVWF  xCD
05256:  MOVLB  0
05258:  CALL   1E44
0525C:  MOVFF  198,9CC
05260:  MOVLW  37
05262:  MOVLB  9
05264:  MOVWF  xCD
05266:  MOVLB  0
05268:  CALL   1E44
0526C:  MOVFF  197,9CC
05270:  MOVLW  37
05272:  MOVLB  9
05274:  MOVWF  xCD
05276:  MOVLB  0
05278:  CALL   1E44
0527C:  MOVFF  196,9CC
05280:  MOVLW  37
05282:  MOVLB  9
05284:  MOVWF  xCD
05286:  MOVLB  0
05288:  CALL   1E44
0528C:  MOVLW  0D
0528E:  MOVLB  A
05290:  MOVWF  xB3
05292:  MOVLB  0
05294:  CALL   1B6E
05298:  MOVLW  0A
0529A:  MOVLB  A
0529C:  MOVWF  xB3
0529E:  MOVLB  0
052A0:  CALL   1B6E
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
052A4:  MOVLW  5C
052A6:  MOVWF  FF6
052A8:  MOVLW  16
052AA:  MOVWF  FF7
052AC:  MOVLW  00
052AE:  MOVWF  FF8
052B0:  MOVLW  0E
052B2:  MOVLB  9
052B4:  MOVWF  xCC
052B6:  MOVLB  0
052B8:  CALL   1BF0
052BC:  MOVFF  19B,9CC
052C0:  MOVLW  37
052C2:  MOVLB  9
052C4:  MOVWF  xCD
052C6:  MOVLB  0
052C8:  CALL   1E44
052CC:  MOVFF  19A,9CC
052D0:  MOVLW  37
052D2:  MOVLB  9
052D4:  MOVWF  xCD
052D6:  MOVLB  0
052D8:  CALL   1E44
052DC:  MOVLW  0D
052DE:  MOVLB  A
052E0:  MOVWF  xB3
052E2:  MOVLB  0
052E4:  CALL   1B6E
052E8:  MOVLW  0A
052EA:  MOVLB  A
052EC:  MOVWF  xB3
052EE:  MOVLB  0
052F0:  CALL   1B6E
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
052F4:  MOVFF  195,1E6
052F8:  MOVLB  1
052FA:  CLRF   xE7
052FC:  MOVLB  0
052FE:  CALL   3F8A
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
05302:  MOVLW  72
05304:  MOVWF  FF6
05306:  MOVLW  16
05308:  MOVWF  FF7
0530A:  MOVLW  00
0530C:  MOVWF  FF8
0530E:  CALL   1BC0
....................    for (p = 0; p < flash_write_param.packetnum; p++)
05312:  MOVLB  1
05314:  CLRF   xDD
05316:  CLRF   xDC
05318:  MOVLB  0
0531A:  MOVLB  1
0531C:  MOVF   xDD,W
0531E:  SUBWF  x9B,W
05320:  BTFSC  FD8.0
05322:  BRA    532A
05324:  MOVLB  0
05326:  GOTO   5458
0532A:  MOVLB  0
0532C:  BTFSS  FD8.2
0532E:  GOTO   5344
05332:  MOVLB  1
05334:  MOVF   x9A,W
05336:  SUBWF  xDC,W
05338:  BTFSS  FD8.0
0533A:  BRA    5342
0533C:  MOVLB  0
0533E:  GOTO   5458
05342:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
05344:  MOVLB  1
05346:  RLCF   xDC,W
05348:  MOVWF  xDE
0534A:  RLCF   xDD,W
0534C:  MOVWF  xDF
0534E:  RLCF   xDE,F
05350:  RLCF   xDF,F
05352:  RLCF   xDE,F
05354:  RLCF   xDF,F
05356:  RLCF   xDE,F
05358:  RLCF   xDF,F
0535A:  RLCF   xDE,F
0535C:  RLCF   xDF,F
0535E:  RLCF   xDE,F
05360:  RLCF   xDF,F
05362:  MOVLW  C0
05364:  ANDWF  xDE,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
05366:  CLRF   xE0
05368:  MOVLB  0
0536A:  MOVLB  1
0536C:  MOVF   xE0,W
0536E:  SUBLW  3F
05370:  BTFSC  FD8.0
05372:  BRA    537A
05374:  MOVLB  0
05376:  GOTO   53DA
0537A:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
0537C:  CLRF   03
0537E:  MOVLB  1
05380:  MOVF   xE0,W
05382:  ADDLW  9C
05384:  MOVWF  FE9
05386:  MOVLW  01
05388:  ADDWFC 03,W
0538A:  MOVWF  FEA
0538C:  MOVF   xE0,W
0538E:  ADDWF  xDE,W
05390:  MOVWF  xE7
05392:  MOVLW  00
05394:  ADDWFC xDF,W
05396:  MOVWF  xE8
05398:  MOVF   xE7,W
0539A:  MOVWF  00
0539C:  CLRF   03
0539E:  MOVF   00,W
053A0:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
053A2:  CLRF   03
053A4:  MOVF   xE0,W
053A6:  ADDLW  9C
053A8:  MOVWF  FE9
053AA:  MOVLW  01
053AC:  ADDWFC 03,W
053AE:  MOVWF  FEA
053B0:  MOVFF  FEF,1E5
053B4:  MOVFF  1E5,9CC
053B8:  MOVLW  37
053BA:  MOVLB  9
053BC:  MOVWF  xCD
053BE:  MOVLB  0
053C0:  CALL   1E44
053C4:  MOVLW  20
053C6:  MOVLB  A
053C8:  MOVWF  xB3
053CA:  MOVLB  0
053CC:  CALL   1B6E
053D0:  MOVLB  1
053D2:  INCF   xE0,F
053D4:  MOVLB  0
053D6:  GOTO   536A
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
053DA:  MOVLB  1
053DC:  RLCF   xDC,W
053DE:  MOVWF  02
053E0:  RLCF   xDD,W
053E2:  MOVWF  03
053E4:  RLCF   02,F
053E6:  RLCF   03,F
053E8:  RLCF   02,F
053EA:  RLCF   03,F
053EC:  RLCF   02,F
053EE:  RLCF   03,F
053F0:  RLCF   02,F
053F2:  RLCF   03,F
053F4:  RLCF   02,F
053F6:  RLCF   03,F
053F8:  MOVLW  C0
053FA:  ANDWF  02,F
053FC:  MOVF   02,W
053FE:  ADDWF  x96,W
05400:  MOVWF  xE1
05402:  MOVF   03,W
05404:  ADDWFC x97,W
05406:  MOVWF  xE2
05408:  MOVLW  00
0540A:  ADDWFC x98,W
0540C:  MOVWF  xE3
0540E:  MOVLW  00
05410:  ADDWFC x99,W
05412:  MOVWF  xE4
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
05414:  MOVFF  111,A5F
05418:  MOVFF  110,A5E
0541C:  MOVFF  10F,A5D
05420:  MOVFF  10E,A5C
05424:  MOVFF  1E4,A63
05428:  MOVFF  1E3,A62
0542C:  MOVFF  1E2,A61
05430:  MOVFF  1E1,A60
05434:  MOVLW  01
05436:  MOVLB  A
05438:  MOVWF  x65
0543A:  MOVLW  9C
0543C:  MOVWF  x64
0543E:  CLRF   x67
05440:  MOVLW  40
05442:  MOVWF  x66
05444:  MOVLB  0
05446:  CALL   34E0
0544A:  MOVLB  1
0544C:  INCF   xDC,F
0544E:  BTFSC  FD8.2
05450:  INCF   xDD,F
05452:  MOVLB  0
05454:  GOTO   531A
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
05458:  MOVFF  195,1E6
0545C:  MOVLB  1
0545E:  SETF   xE7
05460:  MOVLB  0
05462:  CALL   3F8A
....................    fprintf(PC, "\r\n");
05466:  MOVLW  0D
05468:  MOVLB  A
0546A:  MOVWF  xB3
0546C:  MOVLB  0
0546E:  CALL   1B6E
05472:  MOVLW  0A
05474:  MOVLB  A
05476:  MOVWF  xB3
05478:  MOVLB  0
0547A:  CALL   1B6E
....................    fprintf(PC, "End Flash Write Demo\r\n");
0547E:  MOVLW  80
05480:  MOVWF  FF6
05482:  MOVLW  16
05484:  MOVWF  FF7
05486:  MOVLW  00
05488:  MOVWF  FF8
0548A:  CALL   1BC0
0548E:  GOTO   9002 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
054C2:  MOVLW  98
054C4:  MOVWF  FF6
054C6:  MOVLW  16
054C8:  MOVWF  FF7
054CA:  MOVLW  00
054CC:  MOVWF  FF8
054CE:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
054D2:  MOVLB  1
054D4:  MOVF   x93,W
054D6:  MOVWF  FE9
054D8:  MOVF   x94,W
054DA:  MOVWF  FEA
054DC:  MOVFF  FEF,199
054E0:  MOVFF  199,1E6
054E4:  CLRF   xE7
054E6:  MOVLB  0
054E8:  CALL   3F8A
....................    flash_setting(mis_fm);
054EC:  MOVFF  111,2A1
054F0:  MOVFF  110,2A0
054F4:  MOVFF  10F,29F
054F8:  MOVFF  10E,29E
054FC:  CALL   5492
....................    unsigned int32 write_address = 0x00000000;
05500:  MOVLB  1
05502:  CLRF   x98
05504:  CLRF   x97
05506:  CLRF   x96
05508:  CLRF   x95
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
0550A:  MOVF   x93,W
0550C:  MOVWF  FE9
0550E:  MOVF   x94,W
05510:  MOVWF  FEA
05512:  MOVFF  FEF,199
05516:  MOVFF  199,1E6
0551A:  SETF   xE7
0551C:  MOVLB  0
0551E:  CALL   3F8A
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
05522:  MOVLW  BE
05524:  MOVWF  FF6
05526:  MOVLW  16
05528:  MOVWF  FF7
0552A:  MOVLW  00
0552C:  MOVWF  FF8
0552E:  CALL   1BC0
05532:  GOTO   9012 (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
05536:  MOVLW  E2
05538:  MOVWF  FF6
0553A:  MOVLW  16
0553C:  MOVWF  FF7
0553E:  MOVLW  00
05540:  MOVWF  FF8
05542:  CALL   1BC0
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
05546:  MOVLB  1
05548:  MOVF   x93,W
0554A:  MOVWF  FE9
0554C:  MOVF   x94,W
0554E:  MOVWF  FEA
05550:  MOVFF  FEF,1E5
05554:  MOVFF  1E5,1E6
05558:  CLRF   xE7
0555A:  MOVLB  0
0555C:  CALL   3F8A
....................    FLASH_PARAM flash_param = {0};
05560:  MOVLB  1
05562:  CLRF   x95
05564:  CLRF   x96
05566:  CLRF   x97
05568:  CLRF   x98
0556A:  CLRF   x99
0556C:  CLRF   x9A
0556E:  CLRF   x9B
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
05570:  MOVF   x93,W
05572:  MOVWF  FE9
05574:  MOVF   x94,W
05576:  MOVWF  FEA
05578:  MOVFF  FEF,195
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
0557C:  MOVLW  01
0557E:  ADDWF  x93,W
05580:  MOVWF  FE9
05582:  MOVLW  00
05584:  ADDWFC x94,W
05586:  MOVWF  FEA
05588:  MOVF   FEF,W
0558A:  CLRF   xE8
0558C:  CLRF   xE7
0558E:  CLRF   xE6
05590:  MOVWF  xE5
05592:  MOVFF  1E5,1E8
05596:  CLRF   xE5
05598:  CLRF   xE6
0559A:  CLRF   xE7
0559C:  MOVLW  02
0559E:  ADDWF  x93,W
055A0:  MOVWF  FE9
055A2:  MOVLW  00
055A4:  ADDWFC x94,W
055A6:  MOVWF  FEA
055A8:  MOVF   FEF,W
055AA:  CLRF   xED
055AC:  CLRF   xEC
055AE:  CLRF   xEB
055B0:  MOVWF  xEA
055B2:  MOVFF  1EB,03
055B6:  MOVFF  1EA,02
055BA:  CLRF   00
055BC:  CLRF   01
055BE:  MOVF   00,W
055C0:  IORWF  xE5,F
055C2:  MOVF   01,W
055C4:  IORWF  xE6,F
055C6:  MOVF   02,W
055C8:  IORWF  xE7,F
055CA:  MOVF   03,W
055CC:  IORWF  xE8,F
055CE:  MOVLW  03
055D0:  ADDWF  x93,W
055D2:  MOVWF  FE9
055D4:  MOVLW  00
055D6:  ADDWFC x94,W
055D8:  MOVWF  FEA
055DA:  MOVF   FEF,W
055DC:  CLRF   xED
055DE:  CLRF   xEC
055E0:  CLRF   xEB
055E2:  MOVWF  xEA
055E4:  MOVFF  1EC,03
055E8:  MOVFF  1EB,02
055EC:  MOVFF  1EA,01
055F0:  CLRF   00
055F2:  MOVF   00,W
055F4:  IORWF  xE5,F
055F6:  MOVF   01,W
055F8:  IORWF  xE6,F
055FA:  MOVF   02,W
055FC:  IORWF  xE7,F
055FE:  MOVF   03,W
05600:  IORWF  xE8,F
05602:  MOVLW  04
05604:  ADDWF  x93,W
05606:  MOVWF  FE9
05608:  MOVLW  00
0560A:  ADDWFC x94,W
0560C:  MOVWF  FEA
0560E:  MOVF   FEF,W
05610:  MOVWF  00
05612:  CLRF   01
05614:  CLRF   02
05616:  CLRF   03
05618:  MOVF   00,W
0561A:  IORWF  xE5,W
0561C:  MOVWF  x98
0561E:  MOVF   01,W
05620:  IORWF  xE6,W
05622:  MOVWF  x99
05624:  MOVF   02,W
05626:  IORWF  xE7,W
05628:  MOVWF  x9A
0562A:  MOVF   03,W
0562C:  IORWF  xE8,W
0562E:  MOVWF  x9B
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
05630:  MOVLW  07
05632:  ADDWF  x93,W
05634:  MOVWF  FE9
05636:  MOVLW  00
05638:  ADDWFC x94,W
0563A:  MOVWF  FEA
0563C:  MOVF   FEF,W
0563E:  CLRF   xE6
05640:  MOVWF  xE5
05642:  MOVFF  1E5,1E6
05646:  CLRF   xE5
05648:  MOVLW  08
0564A:  ADDWF  x93,W
0564C:  MOVWF  FE9
0564E:  MOVLW  00
05650:  ADDWFC x94,W
05652:  MOVWF  FEA
05654:  MOVF   FEF,W
05656:  CLRF   03
05658:  IORWF  xE5,W
0565A:  MOVWF  x96
0565C:  MOVF   03,W
0565E:  IORWF  xE6,W
05660:  MOVWF  x97
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
05662:  MOVLW  F6
05664:  MOVWF  FF6
05666:  MOVLW  16
05668:  MOVWF  FF7
0566A:  MOVLW  00
0566C:  MOVWF  FF8
0566E:  MOVLW  0C
05670:  MOVLB  9
05672:  MOVWF  xCC
05674:  MOVLB  0
05676:  CALL   1BF0
0567A:  MOVFF  195,9CC
0567E:  MOVLW  37
05680:  MOVLB  9
05682:  MOVWF  xCD
05684:  MOVLB  0
05686:  CALL   1E44
0568A:  MOVLW  0D
0568C:  MOVLB  A
0568E:  MOVWF  xB3
05690:  MOVLB  0
05692:  CALL   1B6E
05696:  MOVLW  0A
05698:  MOVLB  A
0569A:  MOVWF  xB3
0569C:  MOVLB  0
0569E:  CALL   1B6E
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
056A2:  MOVLW  0A
056A4:  MOVWF  FF6
056A6:  MOVLW  17
056A8:  MOVWF  FF7
056AA:  MOVLW  00
056AC:  MOVWF  FF8
056AE:  MOVLW  0E
056B0:  MOVLB  9
056B2:  MOVWF  xCC
056B4:  MOVLB  0
056B6:  CALL   1BF0
056BA:  MOVFF  19B,9CC
056BE:  MOVLW  37
056C0:  MOVLB  9
056C2:  MOVWF  xCD
056C4:  MOVLB  0
056C6:  CALL   1E44
056CA:  MOVFF  19A,9CC
056CE:  MOVLW  37
056D0:  MOVLB  9
056D2:  MOVWF  xCD
056D4:  MOVLB  0
056D6:  CALL   1E44
056DA:  MOVFF  199,9CC
056DE:  MOVLW  37
056E0:  MOVLB  9
056E2:  MOVWF  xCD
056E4:  MOVLB  0
056E6:  CALL   1E44
056EA:  MOVFF  198,9CC
056EE:  MOVLW  37
056F0:  MOVLB  9
056F2:  MOVWF  xCD
056F4:  MOVLB  0
056F6:  CALL   1E44
056FA:  MOVLW  0D
056FC:  MOVLB  A
056FE:  MOVWF  xB3
05700:  MOVLB  0
05702:  CALL   1B6E
05706:  MOVLW  0A
05708:  MOVLB  A
0570A:  MOVWF  xB3
0570C:  MOVLB  0
0570E:  CALL   1B6E
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
05712:  MOVLW  20
05714:  MOVWF  FF6
05716:  MOVLW  17
05718:  MOVWF  FF7
0571A:  MOVLW  00
0571C:  MOVWF  FF8
0571E:  MOVLW  0E
05720:  MOVLB  9
05722:  MOVWF  xCC
05724:  MOVLB  0
05726:  CALL   1BF0
0572A:  MOVFF  197,9CC
0572E:  MOVLW  37
05730:  MOVLB  9
05732:  MOVWF  xCD
05734:  MOVLB  0
05736:  CALL   1E44
0573A:  MOVFF  196,9CC
0573E:  MOVLW  37
05740:  MOVLB  9
05742:  MOVWF  xCD
05744:  MOVLB  0
05746:  CALL   1E44
0574A:  MOVLW  0D
0574C:  MOVLB  A
0574E:  MOVWF  xB3
05750:  MOVLB  0
05752:  CALL   1B6E
05756:  MOVLW  0A
05758:  MOVLB  A
0575A:  MOVWF  xB3
0575C:  MOVLB  0
0575E:  CALL   1B6E
....................    
....................    piclog_make(flash_param.id, 0x00);
05762:  MOVFF  195,1E6
05766:  MOVLB  1
05768:  CLRF   xE7
0576A:  MOVLB  0
0576C:  CALL   3F8A
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
05770:  MOVLB  1
05772:  CLRF   x9C
05774:  CLRF   x9D
05776:  CLRF   x9E
05778:  CLRF   x9F
0577A:  CLRF   xA0
0577C:  CLRF   xA1
0577E:  CLRF   xA2
05780:  CLRF   xA3
05782:  CLRF   xA4
05784:  CLRF   xA5
05786:  CLRF   xA6
05788:  CLRF   xA7
0578A:  CLRF   xA8
0578C:  CLRF   xA9
0578E:  CLRF   xAA
05790:  CLRF   xAB
05792:  CLRF   xAC
05794:  CLRF   xAD
05796:  CLRF   xAE
05798:  CLRF   xAF
0579A:  CLRF   xB0
0579C:  CLRF   xB1
0579E:  CLRF   xB2
057A0:  CLRF   xB3
057A2:  CLRF   xB4
057A4:  CLRF   xB5
057A6:  CLRF   xB6
057A8:  CLRF   xB7
057AA:  CLRF   xB8
057AC:  CLRF   xB9
057AE:  CLRF   xBA
057B0:  CLRF   xBB
057B2:  CLRF   xBC
057B4:  CLRF   xBD
057B6:  CLRF   xBE
057B8:  CLRF   xBF
057BA:  CLRF   xC0
057BC:  CLRF   xC1
057BE:  CLRF   xC2
057C0:  CLRF   xC3
057C2:  CLRF   xC4
057C4:  CLRF   xC5
057C6:  CLRF   xC6
057C8:  CLRF   xC7
057CA:  CLRF   xC8
057CC:  CLRF   xC9
057CE:  CLRF   xCA
057D0:  CLRF   xCB
057D2:  CLRF   xCC
057D4:  CLRF   xCD
057D6:  CLRF   xCE
057D8:  CLRF   xCF
057DA:  CLRF   xD0
057DC:  CLRF   xD1
057DE:  CLRF   xD2
057E0:  CLRF   xD3
057E2:  CLRF   xD4
057E4:  CLRF   xD5
057E6:  CLRF   xD6
057E8:  CLRF   xD7
057EA:  CLRF   xD8
057EC:  CLRF   xD9
057EE:  CLRF   xDA
057F0:  CLRF   xDB
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
057F2:  MOVLW  36
057F4:  MOVWF  FF6
057F6:  MOVLW  17
057F8:  MOVWF  FF7
057FA:  MOVLW  00
057FC:  MOVWF  FF8
057FE:  MOVLB  0
05800:  CALL   1BC0
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
05804:  MOVFF  111,269
05808:  MOVFF  110,268
0580C:  MOVFF  10F,267
05810:  MOVFF  10E,266
05814:  CALL   26DA
05818:  MOVF   01,F
0581A:  BTFSS  FD8.2
0581C:  GOTO   5830
....................       fprintf(PC, "Mission Flash is not connected\r\n");
05820:  MOVLW  42
05822:  MOVWF  FF6
05824:  MOVLW  17
05826:  MOVWF  FF7
05828:  MOVLW  00
0582A:  MOVWF  FF8
0582C:  CALL   1BC0
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
05830:  MOVLB  1
05832:  CLRF   xE3
05834:  CLRF   xE2
05836:  CLRF   xE1
05838:  CLRF   xE0
0583A:  MOVLB  0
0583C:  MOVLB  1
0583E:  MOVF   xE3,F
05840:  BTFSC  FD8.2
05842:  BRA    584A
05844:  MOVLB  0
05846:  GOTO   5998
0584A:  MOVLB  0
0584C:  MOVLB  1
0584E:  MOVF   xE2,F
05850:  BTFSC  FD8.2
05852:  BRA    585A
05854:  MOVLB  0
05856:  GOTO   5998
0585A:  MOVLB  0
0585C:  MOVLB  1
0585E:  MOVF   xE1,W
05860:  SUBWF  x97,W
05862:  BTFSC  FD8.0
05864:  BRA    586C
05866:  MOVLB  0
05868:  GOTO   5998
0586C:  MOVLB  0
0586E:  BTFSS  FD8.2
05870:  GOTO   5886
05874:  MOVLB  1
05876:  MOVF   x96,W
05878:  SUBWF  xE0,W
0587A:  BTFSS  FD8.0
0587C:  BRA    5884
0587E:  MOVLB  0
05880:  GOTO   5998
05884:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
05886:  MOVLB  1
05888:  RLCF   xE0,W
0588A:  MOVWF  00
0588C:  RLCF   xE1,W
0588E:  MOVWF  01
05890:  RLCF   xE2,W
05892:  MOVWF  02
05894:  RLCF   xE3,W
05896:  MOVWF  03
05898:  RLCF   00,F
0589A:  RLCF   01,F
0589C:  RLCF   02,F
0589E:  RLCF   03,F
058A0:  RLCF   00,F
058A2:  RLCF   01,F
058A4:  RLCF   02,F
058A6:  RLCF   03,F
058A8:  RLCF   00,F
058AA:  RLCF   01,F
058AC:  RLCF   02,F
058AE:  RLCF   03,F
058B0:  RLCF   00,F
058B2:  RLCF   01,F
058B4:  RLCF   02,F
058B6:  RLCF   03,F
058B8:  RLCF   00,F
058BA:  RLCF   01,F
058BC:  RLCF   02,F
058BE:  RLCF   03,F
058C0:  MOVLW  C0
058C2:  ANDWF  00,F
058C4:  MOVF   00,W
058C6:  ADDWF  x98,W
058C8:  MOVWF  xDC
058CA:  MOVF   01,W
058CC:  ADDWFC x99,W
058CE:  MOVWF  xDD
058D0:  MOVF   02,W
058D2:  ADDWFC x9A,W
058D4:  MOVWF  xDE
058D6:  MOVF   03,W
058D8:  ADDWFC x9B,W
058DA:  MOVWF  xDF
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
058DC:  MOVFF  111,2EB
058E0:  MOVFF  110,2EA
058E4:  MOVFF  10F,2E9
058E8:  MOVFF  10E,2E8
058EC:  MOVFF  1DF,2EF
058F0:  MOVFF  1DE,2EE
058F4:  MOVFF  1DD,2ED
058F8:  MOVFF  1DC,2EC
058FC:  MOVLW  01
058FE:  MOVLB  2
05900:  MOVWF  xF1
05902:  MOVLW  9C
05904:  MOVWF  xF0
05906:  CLRF   xF5
05908:  CLRF   xF4
0590A:  CLRF   xF3
0590C:  MOVLW  40
0590E:  MOVWF  xF2
05910:  MOVLB  0
05912:  CALL   27C6
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
05916:  MOVLB  1
05918:  CLRF   xE4
0591A:  MOVLB  0
0591C:  MOVLB  1
0591E:  MOVF   xE4,W
05920:  SUBLW  3F
05922:  BTFSC  FD8.0
05924:  BRA    592C
05926:  MOVLB  0
05928:  GOTO   5968
0592C:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
0592E:  CLRF   03
05930:  MOVLB  1
05932:  MOVF   xE4,W
05934:  ADDLW  9C
05936:  MOVWF  FE9
05938:  MOVLW  01
0593A:  ADDWFC 03,W
0593C:  MOVWF  FEA
0593E:  MOVFF  FEF,1E5
05942:  MOVFF  1E5,9CC
05946:  MOVLW  37
05948:  MOVLB  9
0594A:  MOVWF  xCD
0594C:  MOVLB  0
0594E:  CALL   1E44
05952:  MOVLW  20
05954:  MOVLB  A
05956:  MOVWF  xB3
05958:  MOVLB  0
0595A:  CALL   1B6E
0595E:  MOVLB  1
05960:  INCF   xE4,F
05962:  MOVLB  0
05964:  GOTO   591C
....................       }
....................       fprintf(PC,"\r\n");
05968:  MOVLW  0D
0596A:  MOVLB  A
0596C:  MOVWF  xB3
0596E:  MOVLB  0
05970:  CALL   1B6E
05974:  MOVLW  0A
05976:  MOVLB  A
05978:  MOVWF  xB3
0597A:  MOVLB  0
0597C:  CALL   1B6E
05980:  MOVLW  01
05982:  MOVLB  1
05984:  ADDWF  xE0,F
05986:  BTFSC  FD8.0
05988:  INCF   xE1,F
0598A:  BTFSC  FD8.2
0598C:  INCF   xE2,F
0598E:  BTFSC  FD8.2
05990:  INCF   xE3,F
05992:  MOVLB  0
05994:  GOTO   583C
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
05998:  MOVFF  195,1E6
0599C:  MOVLB  1
0599E:  SETF   xE7
059A0:  MOVLB  0
059A2:  CALL   3F8A
....................    fprintf(PC, "End Flash Read\r\n");
059A6:  MOVLW  64
059A8:  MOVWF  FF6
059AA:  MOVLW  17
059AC:  MOVWF  FF7
059AE:  MOVLW  00
059B0:  MOVWF  FF8
059B2:  CALL   1BC0
059B6:  GOTO   9022 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
059BA:  MOVLW  76
059BC:  MOVWF  FF6
059BE:  MOVLW  17
059C0:  MOVWF  FF7
059C2:  MOVLW  00
059C4:  MOVWF  FF8
059C6:  CALL   1BC0
....................    flash_setting(mis_fm);
059CA:  MOVFF  111,2A1
059CE:  MOVFF  110,2A0
059D2:  MOVFF  10F,29F
059D6:  MOVFF  10E,29E
059DA:  CALL   5492
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
059DE:  MOVLB  1
059E0:  CLRF   x98
059E2:  CLRF   x97
059E4:  CLRF   x96
059E6:  CLRF   x95
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
059E8:  MOVFF  111,2EB
059EC:  MOVFF  110,2EA
059F0:  MOVFF  10F,2E9
059F4:  MOVFF  10E,2E8
059F8:  MOVFF  198,2EF
059FC:  MOVFF  197,2EE
05A00:  MOVFF  196,2ED
05A04:  MOVFF  195,2EC
05A08:  MOVLW  01
05A0A:  MOVLB  2
05A0C:  MOVWF  xF1
05A0E:  MOVLW  99
05A10:  MOVWF  xF0
05A12:  CLRF   xF5
05A14:  CLRF   xF4
05A16:  CLRF   xF3
05A18:  MOVLW  04
05A1A:  MOVWF  xF2
05A1C:  MOVLB  0
05A1E:  CALL   27C6
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
05A22:  MOVLW  92
05A24:  MOVWF  FF6
05A26:  MOVLW  17
05A28:  MOVWF  FF7
05A2A:  MOVLW  00
05A2C:  MOVWF  FF8
05A2E:  MOVLW  0B
05A30:  MOVLB  9
05A32:  MOVWF  xCC
05A34:  MOVLB  0
05A36:  CALL   1BF0
05A3A:  MOVFF  199,9CC
05A3E:  MOVLW  37
05A40:  MOVLB  9
05A42:  MOVWF  xCD
05A44:  MOVLB  0
05A46:  CALL   1E44
05A4A:  MOVLW  20
05A4C:  MOVLB  A
05A4E:  MOVWF  xB3
05A50:  MOVLB  0
05A52:  CALL   1B6E
05A56:  MOVFF  19A,9CC
05A5A:  MOVLW  37
05A5C:  MOVLB  9
05A5E:  MOVWF  xCD
05A60:  MOVLB  0
05A62:  CALL   1E44
05A66:  MOVLW  20
05A68:  MOVLB  A
05A6A:  MOVWF  xB3
05A6C:  MOVLB  0
05A6E:  CALL   1B6E
05A72:  MOVFF  19B,9CC
05A76:  MOVLW  37
05A78:  MOVLB  9
05A7A:  MOVWF  xCD
05A7C:  MOVLB  0
05A7E:  CALL   1E44
05A82:  MOVLW  20
05A84:  MOVLB  A
05A86:  MOVWF  xB3
05A88:  MOVLB  0
05A8A:  CALL   1B6E
05A8E:  MOVFF  19C,9CC
05A92:  MOVLW  37
05A94:  MOVLB  9
05A96:  MOVWF  xCD
05A98:  MOVLB  0
05A9A:  CALL   1E44
05A9E:  MOVLW  0D
05AA0:  MOVLB  A
05AA2:  MOVWF  xB3
05AA4:  MOVLB  0
05AA6:  CALL   1B6E
05AAA:  MOVLW  0A
05AAC:  MOVLB  A
05AAE:  MOVWF  xB3
05AB0:  MOVLB  0
05AB2:  CALL   1B6E
....................    fprintf(PC, "End Flash Read Address\r\n");
05AB6:  MOVLW  B4
05AB8:  MOVWF  FF6
05ABA:  MOVLW  17
05ABC:  MOVWF  FF7
05ABE:  MOVLW  00
05AC0:  MOVWF  FF8
05AC2:  CALL   1BC0
05AC6:  GOTO   9032 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
05CB2:  MOVLW  CE
05CB4:  MOVWF  FF6
05CB6:  MOVLW  17
05CB8:  MOVWF  FF7
05CBA:  MOVLW  00
05CBC:  MOVWF  FF8
05CBE:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05CC2:  MOVLB  1
05CC4:  MOVF   x93,W
05CC6:  MOVWF  FE9
05CC8:  MOVF   x94,W
05CCA:  MOVWF  FEA
05CCC:  MOVFF  FEF,195
05CD0:  MOVFF  195,1E6
05CD4:  CLRF   xE7
05CD6:  MOVLB  0
05CD8:  CALL   3F8A
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
05CDC:  MOVFF  194,196
05CE0:  MOVFF  193,195
05CE4:  CALL   47E2
....................    mode_misf_address_reset(parameter); // Reset the address area
05CE8:  MOVFF  194,196
05CEC:  MOVFF  193,195
05CF0:  GOTO   5ACA
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
05CF4:  MOVLW  EC
05CF6:  MOVWF  FF6
05CF8:  MOVLW  17
05CFA:  MOVWF  FF7
05CFC:  MOVLW  00
05CFE:  MOVWF  FF8
05D00:  CALL   1BC0
05D04:  GOTO   9042 (RETURN)
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
05D08:  MOVLW  08
05D0A:  MOVWF  FF6
05D0C:  MOVLW  18
05D0E:  MOVWF  FF7
05D10:  MOVLW  00
05D12:  MOVWF  FF8
05D14:  CALL   1BC0
....................    flash_setting(mis_fm);
05D18:  MOVFF  111,2A1
05D1C:  MOVFF  110,2A0
05D20:  MOVFF  10F,29F
05D24:  MOVFF  10E,29E
05D28:  CALL   5492
....................    flash_setting(smf);
05D2C:  MOVFF  115,2A1
05D30:  MOVFF  114,2A0
05D34:  MOVFF  113,29F
05D38:  MOVFF  112,29E
05D3C:  CALL   5492
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
05D40:  MOVLB  1
05D42:  MOVF   x93,W
05D44:  MOVWF  FE9
05D46:  MOVF   x94,W
05D48:  MOVWF  FEA
05D4A:  MOVFF  FEF,195
05D4E:  CLRF   x99
05D50:  CLRF   x98
05D52:  CLRF   x97
05D54:  CLRF   x96
05D56:  CLRF   x9D
05D58:  CLRF   x9C
05D5A:  MOVLW  10
05D5C:  MOVWF  x9B
05D5E:  CLRF   x9A
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
05D60:  MOVFF  111,2EB
05D64:  MOVFF  110,2EA
05D68:  MOVFF  10F,2E9
05D6C:  MOVFF  10E,2E8
05D70:  MOVFF  199,2EF
05D74:  MOVFF  198,2EE
05D78:  MOVFF  197,2ED
05D7C:  MOVFF  196,2EC
05D80:  MOVLW  01
05D82:  MOVLB  2
05D84:  MOVWF  xF1
05D86:  MOVLW  9E
05D88:  MOVWF  xF0
05D8A:  CLRF   xF5
05D8C:  CLRF   xF4
05D8E:  MOVLW  01
05D90:  MOVWF  xF3
05D92:  CLRF   xF2
05D94:  MOVLB  0
05D96:  CALL   27C6
....................    write_data_bytes(smf, dest_address, read_data, 256);
05D9A:  MOVFF  115,A5F
05D9E:  MOVFF  114,A5E
05DA2:  MOVFF  113,A5D
05DA6:  MOVFF  112,A5C
05DAA:  MOVFF  19D,A63
05DAE:  MOVFF  19C,A62
05DB2:  MOVFF  19B,A61
05DB6:  MOVFF  19A,A60
05DBA:  MOVLW  01
05DBC:  MOVLB  A
05DBE:  MOVWF  x65
05DC0:  MOVLW  9E
05DC2:  MOVWF  x64
05DC4:  MOVLW  01
05DC6:  MOVWF  x67
05DC8:  CLRF   x66
05DCA:  MOVLB  0
05DCC:  CALL   34E0
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
05DD0:  MOVLW  20
05DD2:  MOVWF  FF6
05DD4:  MOVLW  18
05DD6:  MOVWF  FF7
05DD8:  MOVLW  00
05DDA:  MOVWF  FF8
05DDC:  CALL   1BC0
05DE0:  GOTO   9052 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
05DE4:  MOVLW  36
05DE6:  MOVWF  FF6
05DE8:  MOVLW  18
05DEA:  MOVWF  FF7
05DEC:  MOVLW  00
05DEE:  MOVWF  FF8
05DF0:  CALL   1BC0
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
05DF4:  MOVFF  115,2EB
05DF8:  MOVFF  114,2EA
05DFC:  MOVFF  113,2E9
05E00:  MOVFF  112,2E8
05E04:  MOVLB  2
05E06:  CLRF   xEF
05E08:  CLRF   xEE
05E0A:  MOVLW  01
05E0C:  MOVWF  xED
05E0E:  MOVLW  95
05E10:  MOVWF  xEC
05E12:  MOVLW  01
05E14:  MOVWF  xF1
05E16:  MOVLW  95
05E18:  MOVWF  xF0
05E1A:  CLRF   xF5
05E1C:  CLRF   xF4
05E1E:  CLRF   xF3
05E20:  MOVLW  40
05E22:  MOVWF  xF2
05E24:  MOVLB  0
05E26:  CALL   27C6
....................    fprintf(PC, "Read Data: ");
05E2A:  MOVLW  4E
05E2C:  MOVWF  FF6
05E2E:  MOVLW  18
05E30:  MOVWF  FF7
05E32:  MOVLW  00
05E34:  MOVWF  FF8
05E36:  CALL   1BC0
....................    for (int i = 0; i < PACKET_SIZE; i++)
05E3A:  MOVLB  1
05E3C:  CLRF   xD5
05E3E:  MOVLB  0
05E40:  MOVLB  1
05E42:  MOVF   xD5,W
05E44:  SUBLW  3F
05E46:  BTFSC  FD8.0
05E48:  BRA    5E50
05E4A:  MOVLB  0
05E4C:  GOTO   5E8C
05E50:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
05E52:  CLRF   03
05E54:  MOVLB  1
05E56:  MOVF   xD5,W
05E58:  ADDLW  95
05E5A:  MOVWF  FE9
05E5C:  MOVLW  01
05E5E:  ADDWFC 03,W
05E60:  MOVWF  FEA
05E62:  MOVFF  FEF,1D6
05E66:  MOVFF  1D6,9CC
05E6A:  MOVLW  37
05E6C:  MOVLB  9
05E6E:  MOVWF  xCD
05E70:  MOVLB  0
05E72:  CALL   1E44
05E76:  MOVLW  20
05E78:  MOVLB  A
05E7A:  MOVWF  xB3
05E7C:  MOVLB  0
05E7E:  CALL   1B6E
05E82:  MOVLB  1
05E84:  INCF   xD5,F
05E86:  MOVLB  0
05E88:  GOTO   5E40
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
05E8C:  MOVLW  5A
05E8E:  MOVWF  FF6
05E90:  MOVLW  18
05E92:  MOVWF  FF7
05E94:  MOVLW  00
05E96:  MOVWF  FF8
05E98:  CALL   1BC0
05E9C:  GOTO   9062 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
05EA0:  MOVLW  72
05EA2:  MOVWF  FF6
05EA4:  MOVLW  18
05EA6:  MOVWF  FF7
05EA8:  MOVLW  00
05EAA:  MOVWF  FF8
05EAC:  CALL   1BC0
....................    flash_setting(smf);
05EB0:  MOVFF  115,2A1
05EB4:  MOVFF  114,2A0
05EB8:  MOVFF  113,29F
05EBC:  MOVFF  112,29E
05EC0:  CALL   5492
....................    unsigned int32 erase_address = 0x00000000; // Example address
05EC4:  MOVLB  1
05EC6:  CLRF   x98
05EC8:  CLRF   x97
05ECA:  CLRF   x96
05ECC:  CLRF   x95
....................    sector_erase(smf, erase_address); // Erase the sector
05ECE:  MOVFF  115,A5F
05ED2:  MOVFF  114,A5E
05ED6:  MOVFF  113,A5D
05EDA:  MOVFF  112,A5C
05EDE:  MOVFF  198,A63
05EE2:  MOVFF  197,A62
05EE6:  MOVFF  196,A61
05EEA:  MOVFF  195,A60
05EEE:  MOVLB  0
05EF0:  CALL   3BBC
....................    fprintf(PC, "End Flash SMF Erase\r\n");
05EF4:  MOVLW  8A
05EF6:  MOVWF  FF6
05EF8:  MOVLW  18
05EFA:  MOVWF  FF7
05EFC:  MOVLW  00
05EFE:  MOVWF  FF8
05F00:  CALL   1BC0
05F04:  GOTO   9072 (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
05ACA:  MOVLW  A0
05ACC:  MOVWF  FF6
05ACE:  MOVLW  18
05AD0:  MOVWF  FF7
05AD2:  MOVLW  00
05AD4:  MOVWF  FF8
05AD6:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); 
05ADA:  MOVLB  1
05ADC:  MOVF   x95,W
05ADE:  MOVWF  FE9
05AE0:  MOVF   x96,W
05AE2:  MOVWF  FEA
05AE4:  MOVFF  FEF,1D9
05AE8:  MOVFF  1D9,1E6
05AEC:  CLRF   xE7
05AEE:  MOVLB  0
05AF0:  CALL   3F8A
....................    FlashData_t flash_data;
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
05AF4:  MOVLW  01
05AF6:  MOVWF  FEA
05AF8:  MOVLW  97
05AFA:  MOVWF  FE9
05AFC:  CLRF   00
05AFE:  CLRF   02
05B00:  MOVLW  40
05B02:  MOVWF  01
05B04:  CALL   27A2
....................    /*
....................    for (int i = 0; i < PACKET_SIZE; i++) {
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
....................    }
....................    */
....................    fprintf(PC, "\r\n");
05B08:  MOVLW  0D
05B0A:  MOVLB  A
05B0C:  MOVWF  xB3
05B0E:  MOVLB  0
05B10:  CALL   1B6E
05B14:  MOVLW  0A
05B16:  MOVLB  A
05B18:  MOVWF  xB3
05B1A:  MOVLB  0
05B1C:  CALL   1B6E
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
05B20:  MOVLW  01
05B22:  MOVLB  A
05B24:  MOVWF  xB4
05B26:  MOVLW  97
05B28:  MOVWF  xB3
05B2A:  MOVLW  3F
05B2C:  MOVWF  xB5
05B2E:  MOVLB  0
05B30:  CALL   29E6
05B34:  MOVFF  01,1D6
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05B38:  MOVLB  1
05B3A:  CLRF   xD7
05B3C:  MOVLB  0
05B3E:  MOVLB  1
05B40:  MOVF   xD7,W
05B42:  SUBLW  3F
05B44:  BTFSC  FD8.0
05B46:  BRA    5B4E
05B48:  MOVLB  0
05B4A:  GOTO   5B8A
05B4E:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
05B50:  CLRF   03
05B52:  MOVLB  1
05B54:  MOVF   xD7,W
05B56:  ADDLW  97
05B58:  MOVWF  FE9
05B5A:  MOVLW  01
05B5C:  ADDWFC 03,W
05B5E:  MOVWF  FEA
05B60:  MOVFF  FEF,1D9
05B64:  MOVFF  1D9,9CC
05B68:  MOVLW  37
05B6A:  MOVLB  9
05B6C:  MOVWF  xCD
05B6E:  MOVLB  0
05B70:  CALL   1E44
05B74:  MOVLW  20
05B76:  MOVLB  A
05B78:  MOVWF  xB3
05B7A:  MOVLB  0
05B7C:  CALL   1B6E
05B80:  MOVLB  1
05B82:  INCF   xD7,F
05B84:  MOVLB  0
05B86:  GOTO   5B3E
....................    }
....................    fprintf(PC, "\r\n");
05B8A:  MOVLW  0D
05B8C:  MOVLB  A
05B8E:  MOVWF  xB3
05B90:  MOVLB  0
05B92:  CALL   1B6E
05B96:  MOVLW  0A
05B98:  MOVLB  A
05B9A:  MOVWF  xB3
05B9C:  MOVLB  0
05B9E:  CALL   1B6E
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
05BA2:  MOVFF  111,A5F
05BA6:  MOVFF  110,A5E
05BAA:  MOVFF  10F,A5D
05BAE:  MOVFF  10E,A5C
05BB2:  MOVLB  A
05BB4:  CLRF   x63
05BB6:  CLRF   x62
05BB8:  CLRF   x61
05BBA:  CLRF   x60
05BBC:  MOVLW  01
05BBE:  MOVWF  x65
05BC0:  MOVLW  97
05BC2:  MOVWF  x64
05BC4:  CLRF   x67
05BC6:  MOVLW  40
05BC8:  MOVWF  x66
05BCA:  MOVLB  0
05BCC:  CALL   34E0
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
05BD0:  MOVLW  01
05BD2:  MOVWF  FEA
05BD4:  MOVLW  97
05BD6:  MOVWF  FE9
05BD8:  CLRF   00
05BDA:  CLRF   02
05BDC:  MOVLW  40
05BDE:  MOVWF  01
05BE0:  CALL   27A2
....................    read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
05BE4:  MOVFF  111,2EB
05BE8:  MOVFF  110,2EA
05BEC:  MOVFF  10F,2E9
05BF0:  MOVFF  10E,2E8
05BF4:  MOVLB  2
05BF6:  CLRF   xEF
05BF8:  CLRF   xEE
05BFA:  CLRF   xED
05BFC:  CLRF   xEC
05BFE:  MOVLW  01
05C00:  MOVWF  xF1
05C02:  MOVLW  97
05C04:  MOVWF  xF0
05C06:  CLRF   xF5
05C08:  CLRF   xF4
05C0A:  CLRF   xF3
05C0C:  MOVLW  40
05C0E:  MOVWF  xF2
05C10:  MOVLB  0
05C12:  CALL   27C6
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
05C16:  MOVLW  01
05C18:  MOVLB  A
05C1A:  MOVWF  xB4
05C1C:  MOVLW  97
05C1E:  MOVWF  xB3
05C20:  MOVLW  3F
05C22:  MOVWF  xB5
05C24:  MOVLB  0
05C26:  CALL   29E6
05C2A:  MOVFF  01,1D6
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05C2E:  MOVLB  1
05C30:  CLRF   xD8
05C32:  MOVLB  0
05C34:  MOVLB  1
05C36:  MOVF   xD8,W
05C38:  SUBLW  3F
05C3A:  BTFSC  FD8.0
05C3C:  BRA    5C44
05C3E:  MOVLB  0
05C40:  GOTO   5C80
05C44:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
05C46:  CLRF   03
05C48:  MOVLB  1
05C4A:  MOVF   xD8,W
05C4C:  ADDLW  97
05C4E:  MOVWF  FE9
05C50:  MOVLW  01
05C52:  ADDWFC 03,W
05C54:  MOVWF  FEA
05C56:  MOVFF  FEF,1D9
05C5A:  MOVFF  1D9,9CC
05C5E:  MOVLW  37
05C60:  MOVLB  9
05C62:  MOVWF  xCD
05C64:  MOVLB  0
05C66:  CALL   1E44
05C6A:  MOVLW  20
05C6C:  MOVLB  A
05C6E:  MOVWF  xB3
05C70:  MOVLB  0
05C72:  CALL   1B6E
05C76:  MOVLB  1
05C78:  INCF   xD8,F
05C7A:  MOVLB  0
05C7C:  GOTO   5C34
....................    }
....................    misf_init(); // Update the address area after writing
05C80:  CALL   2FE6
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05C84:  MOVLB  1
05C86:  MOVF   x95,W
05C88:  MOVWF  FE9
05C8A:  MOVF   x96,W
05C8C:  MOVWF  FEA
05C8E:  MOVFF  FEF,1D9
05C92:  MOVFF  1D9,1E6
05C96:  SETF   xE7
05C98:  MOVLB  0
05C9A:  CALL   3F8A
....................    fprintf(PC, "End Flash Address Reset\r\n");
05C9E:  MOVLW  BC
05CA0:  MOVWF  FF6
05CA2:  MOVLW  18
05CA4:  MOVWF  FF7
05CA6:  MOVLW  00
05CA8:  MOVWF  FF8
05CAA:  CALL   1BC0
05CAE:  GOTO   5CF4 (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
060AE:  MOVLW  01
060B0:  MOVLB  1
060B2:  ADDWF  x93,W
060B4:  MOVWF  FE9
060B6:  MOVLW  00
060B8:  ADDWFC x94,W
060BA:  MOVWF  FEA
060BC:  MOVF   FEF,W
060BE:  CLRF   xE5
060C0:  CLRF   xE4
060C2:  CLRF   xE3
060C4:  MOVWF  xE2
060C6:  MOVFF  1E2,1E5
060CA:  CLRF   xE2
060CC:  CLRF   xE3
060CE:  CLRF   xE4
060D0:  MOVLW  02
060D2:  ADDWF  x93,W
060D4:  MOVWF  FE9
060D6:  MOVLW  00
060D8:  ADDWFC x94,W
060DA:  MOVWF  FEA
060DC:  MOVF   FEF,W
060DE:  CLRF   xEA
060E0:  CLRF   xE9
060E2:  CLRF   xE8
060E4:  MOVWF  xE7
060E6:  MOVFF  1E8,03
060EA:  MOVFF  1E7,02
060EE:  CLRF   00
060F0:  CLRF   01
060F2:  MOVF   00,W
060F4:  IORWF  xE2,F
060F6:  MOVF   01,W
060F8:  IORWF  xE3,F
060FA:  MOVF   02,W
060FC:  IORWF  xE4,F
060FE:  MOVF   03,W
06100:  IORWF  xE5,F
06102:  MOVLW  03
06104:  ADDWF  x93,W
06106:  MOVWF  FE9
06108:  MOVLW  00
0610A:  ADDWFC x94,W
0610C:  MOVWF  FEA
0610E:  MOVF   FEF,W
06110:  CLRF   xEA
06112:  CLRF   xE9
06114:  CLRF   xE8
06116:  MOVWF  xE7
06118:  MOVFF  1E9,03
0611C:  MOVFF  1E8,02
06120:  MOVFF  1E7,01
06124:  CLRF   00
06126:  MOVF   00,W
06128:  IORWF  xE2,F
0612A:  MOVF   01,W
0612C:  IORWF  xE3,F
0612E:  MOVF   02,W
06130:  IORWF  xE4,F
06132:  MOVF   03,W
06134:  IORWF  xE5,F
06136:  MOVLW  04
06138:  ADDWF  x93,W
0613A:  MOVWF  FE9
0613C:  MOVLW  00
0613E:  ADDWFC x94,W
06140:  MOVWF  FEA
06142:  MOVF   FEF,W
06144:  MOVWF  00
06146:  CLRF   01
06148:  CLRF   02
0614A:  CLRF   03
0614C:  MOVF   00,W
0614E:  IORWF  xE2,W
06150:  MOVWF  x95
06152:  MOVF   01,W
06154:  IORWF  xE3,W
06156:  MOVWF  x96
06158:  MOVF   02,W
0615A:  IORWF  xE4,W
0615C:  MOVWF  x97
0615E:  MOVF   03,W
06160:  IORWF  xE5,W
06162:  MOVWF  x98
06164:  MOVLW  07
06166:  ADDWF  x93,W
06168:  MOVWF  FE9
0616A:  MOVLW  00
0616C:  ADDWFC x94,W
0616E:  MOVWF  FEA
06170:  MOVF   FEF,W
06172:  CLRF   xE3
06174:  MOVWF  xE2
06176:  MOVFF  1E2,1E3
0617A:  CLRF   xE2
0617C:  MOVLW  08
0617E:  ADDWF  x93,W
06180:  MOVWF  FE9
06182:  MOVLW  00
06184:  ADDWFC x94,W
06186:  MOVWF  FEA
06188:  MOVF   FEF,W
0618A:  CLRF   03
0618C:  IORWF  xE2,W
0618E:  MOVWF  x99
06190:  MOVF   03,W
06192:  IORWF  xE3,W
06194:  MOVWF  x9A
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
06196:  CLRF   x9B
06198:  CLRF   x9C
0619A:  CLRF   x9D
0619C:  CLRF   x9E
0619E:  CLRF   x9F
061A0:  CLRF   xA0
061A2:  CLRF   xA1
061A4:  CLRF   xA2
061A6:  CLRF   xA3
061A8:  CLRF   xA4
061AA:  CLRF   xA5
061AC:  CLRF   xA6
061AE:  CLRF   xA7
061B0:  CLRF   xA8
061B2:  CLRF   xA9
061B4:  CLRF   xAA
061B6:  CLRF   xAB
061B8:  CLRF   xAC
061BA:  CLRF   xAD
061BC:  CLRF   xAE
061BE:  CLRF   xAF
061C0:  CLRF   xB0
061C2:  CLRF   xB1
061C4:  CLRF   xB2
061C6:  CLRF   xB3
061C8:  CLRF   xB4
061CA:  CLRF   xB5
061CC:  CLRF   xB6
061CE:  CLRF   xB7
061D0:  CLRF   xB8
061D2:  CLRF   xB9
061D4:  CLRF   xBA
061D6:  CLRF   xBB
061D8:  CLRF   xBC
061DA:  CLRF   xBD
061DC:  CLRF   xBE
061DE:  CLRF   xBF
061E0:  CLRF   xC0
061E2:  CLRF   xC1
061E4:  CLRF   xC2
061E6:  CLRF   xC3
061E8:  CLRF   xC4
061EA:  CLRF   xC5
061EC:  CLRF   xC6
061EE:  CLRF   xC7
061F0:  CLRF   xC8
061F2:  CLRF   xC9
061F4:  CLRF   xCA
061F6:  CLRF   xCB
061F8:  CLRF   xCC
061FA:  CLRF   xCD
061FC:  CLRF   xCE
061FE:  CLRF   xCF
06200:  CLRF   xD0
06202:  CLRF   xD1
06204:  CLRF   xD2
06206:  CLRF   xD3
06208:  CLRF   xD4
0620A:  CLRF   xD5
0620C:  CLRF   xD6
0620E:  CLRF   xD7
06210:  CLRF   xD8
06212:  CLRF   xD9
06214:  CLRF   xDA
....................    if(!is_connect(smf)) {
06216:  MOVFF  115,269
0621A:  MOVFF  114,268
0621E:  MOVFF  113,267
06222:  MOVFF  112,266
06226:  MOVLB  0
06228:  CALL   26DA
0622C:  MOVF   01,F
0622E:  BTFSS  FD8.2
06230:  GOTO   6248
....................       printf("SMF is not connected\r\n");
06234:  MOVLW  D6
06236:  MOVWF  FF6
06238:  MOVLW  18
0623A:  MOVWF  FF7
0623C:  MOVLW  00
0623E:  MOVWF  FF8
06240:  CALL   1BC0
....................       return;
06244:  GOTO   648C
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
06248:  MOVLW  EE
0624A:  MOVWF  FF6
0624C:  MOVLW  18
0624E:  MOVWF  FF7
06250:  MOVLW  00
06252:  MOVWF  FF8
06254:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
06258:  MOVLB  1
0625A:  MOVF   x93,W
0625C:  MOVWF  FE9
0625E:  MOVF   x94,W
06260:  MOVWF  FEA
06262:  MOVFF  FEF,1E2
06266:  MOVFF  1E2,1E6
0626A:  CLRF   xE7
0626C:  MOVLB  0
0626E:  CALL   3F8A
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
06272:  MOVLW  0C
06274:  MOVWF  FF6
06276:  MOVLW  19
06278:  MOVWF  FF7
0627A:  MOVLW  00
0627C:  MOVWF  FF8
0627E:  MOVLW  0E
06280:  MOVLB  9
06282:  MOVWF  xCC
06284:  MOVLB  0
06286:  CALL   1BF0
0628A:  MOVFF  198,9CC
0628E:  MOVLW  37
06290:  MOVLB  9
06292:  MOVWF  xCD
06294:  MOVLB  0
06296:  CALL   1E44
0629A:  MOVFF  197,9CC
0629E:  MOVLW  37
062A0:  MOVLB  9
062A2:  MOVWF  xCD
062A4:  MOVLB  0
062A6:  CALL   1E44
062AA:  MOVFF  196,9CC
062AE:  MOVLW  37
062B0:  MOVLB  9
062B2:  MOVWF  xCD
062B4:  MOVLB  0
062B6:  CALL   1E44
062BA:  MOVFF  195,9CC
062BE:  MOVLW  37
062C0:  MOVLB  9
062C2:  MOVWF  xCD
062C4:  MOVLB  0
062C6:  CALL   1E44
062CA:  MOVLW  0D
062CC:  MOVLB  A
062CE:  MOVWF  xB3
062D0:  MOVLB  0
062D2:  CALL   1B6E
062D6:  MOVLW  0A
062D8:  MOVLB  A
062DA:  MOVWF  xB3
062DC:  MOVLB  0
062DE:  CALL   1B6E
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
062E2:  MOVLW  22
062E4:  MOVWF  FF6
062E6:  MOVLW  19
062E8:  MOVWF  FF7
062EA:  MOVLW  00
062EC:  MOVWF  FF8
062EE:  MOVLW  0E
062F0:  MOVLB  9
062F2:  MOVWF  xCC
062F4:  MOVLB  0
062F6:  CALL   1BF0
062FA:  MOVFF  19A,9CC
062FE:  MOVLW  37
06300:  MOVLB  9
06302:  MOVWF  xCD
06304:  MOVLB  0
06306:  CALL   1E44
0630A:  MOVFF  199,9CC
0630E:  MOVLW  37
06310:  MOVLB  9
06312:  MOVWF  xCD
06314:  MOVLB  0
06316:  CALL   1E44
0631A:  MOVLW  0D
0631C:  MOVLB  A
0631E:  MOVWF  xB3
06320:  MOVLB  0
06322:  CALL   1B6E
06326:  MOVLW  0A
06328:  MOVLB  A
0632A:  MOVWF  xB3
0632C:  MOVLB  0
0632E:  CALL   1B6E
....................    printf("read data\r\n");
06332:  MOVLW  38
06334:  MOVWF  FF6
06336:  MOVLW  19
06338:  MOVWF  FF7
0633A:  MOVLW  00
0633C:  MOVWF  FF8
0633E:  CALL   1BC0
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
06342:  MOVLB  1
06344:  CLRF   xDC
06346:  CLRF   xDB
06348:  MOVLB  0
0634A:  MOVLB  1
0634C:  MOVF   xDC,W
0634E:  SUBWF  x9A,W
06350:  BTFSC  FD8.0
06352:  BRA    635A
06354:  MOVLB  0
06356:  GOTO   6462
0635A:  MOVLB  0
0635C:  BTFSS  FD8.2
0635E:  GOTO   6374
06362:  MOVLB  1
06364:  MOVF   x99,W
06366:  SUBWF  xDB,W
06368:  BTFSS  FD8.0
0636A:  BRA    6372
0636C:  MOVLB  0
0636E:  GOTO   6462
06372:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
06374:  MOVLB  1
06376:  RLCF   xDB,W
06378:  MOVWF  02
0637A:  RLCF   xDC,W
0637C:  MOVWF  03
0637E:  RLCF   02,F
06380:  RLCF   03,F
06382:  RLCF   02,F
06384:  RLCF   03,F
06386:  RLCF   02,F
06388:  RLCF   03,F
0638A:  RLCF   02,F
0638C:  RLCF   03,F
0638E:  RLCF   02,F
06390:  RLCF   03,F
06392:  MOVLW  C0
06394:  ANDWF  02,F
06396:  MOVF   02,W
06398:  ADDWF  x95,W
0639A:  MOVWF  xDD
0639C:  MOVF   03,W
0639E:  ADDWFC x96,W
063A0:  MOVWF  xDE
063A2:  MOVLW  00
063A4:  ADDWFC x97,W
063A6:  MOVWF  xDF
063A8:  MOVLW  00
063AA:  ADDWFC x98,W
063AC:  MOVWF  xE0
063AE:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
063B0:  MOVFF  115,2EB
063B4:  MOVFF  114,2EA
063B8:  MOVFF  113,2E9
063BC:  MOVFF  112,2E8
063C0:  MOVFF  1E0,2EF
063C4:  MOVFF  1DF,2EE
063C8:  MOVFF  1DE,2ED
063CC:  MOVFF  1DD,2EC
063D0:  MOVLW  01
063D2:  MOVLB  2
063D4:  MOVWF  xF1
063D6:  MOVLW  9B
063D8:  MOVWF  xF0
063DA:  CLRF   xF5
063DC:  CLRF   xF4
063DE:  CLRF   xF3
063E0:  MOVLW  40
063E2:  MOVWF  xF2
063E4:  MOVLB  0
063E6:  CALL   27C6
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
063EA:  MOVLB  1
063EC:  CLRF   xE1
063EE:  MOVLB  0
063F0:  MOVLB  1
063F2:  MOVF   xE1,W
063F4:  SUBLW  3F
063F6:  BTFSC  FD8.0
063F8:  BRA    6400
063FA:  MOVLB  0
063FC:  GOTO   643C
06400:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
06402:  CLRF   03
06404:  MOVLB  1
06406:  MOVF   xE1,W
06408:  ADDLW  9B
0640A:  MOVWF  FE9
0640C:  MOVLW  01
0640E:  ADDWFC 03,W
06410:  MOVWF  FEA
06412:  MOVFF  FEF,1E2
06416:  MOVFF  1E2,9CC
0641A:  MOVLW  37
0641C:  MOVLB  9
0641E:  MOVWF  xCD
06420:  MOVLB  0
06422:  CALL   1E44
06426:  MOVLW  20
06428:  MOVLB  A
0642A:  MOVWF  xB3
0642C:  MOVLB  0
0642E:  CALL   1B6E
06432:  MOVLB  1
06434:  INCF   xE1,F
06436:  MOVLB  0
06438:  GOTO   63F0
....................       }
....................       printf("\r\n");
0643C:  MOVLW  0D
0643E:  MOVLB  A
06440:  MOVWF  xB3
06442:  MOVLB  0
06444:  CALL   1B6E
06448:  MOVLW  0A
0644A:  MOVLB  A
0644C:  MOVWF  xB3
0644E:  MOVLB  0
06450:  CALL   1B6E
06454:  MOVLB  1
06456:  INCF   xDB,F
06458:  BTFSC  FD8.2
0645A:  INCF   xDC,F
0645C:  MOVLB  0
0645E:  GOTO   634A
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
06462:  MOVLW  44
06464:  MOVWF  FF6
06466:  MOVLW  19
06468:  MOVWF  FF7
0646A:  MOVLW  00
0646C:  MOVWF  FF8
0646E:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06472:  MOVLB  1
06474:  MOVF   x93,W
06476:  MOVWF  FE9
06478:  MOVF   x94,W
0647A:  MOVWF  FEA
0647C:  MOVFF  FEF,1E2
06480:  MOVFF  1E2,1E6
06484:  SETF   xE7
06486:  MOVLB  0
06488:  CALL   3F8A
0648C:  GOTO   9092 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
06490:  MOVLW  62
06492:  MOVWF  FF6
06494:  MOVLW  19
06496:  MOVWF  FF7
06498:  MOVLW  00
0649A:  MOVWF  FF8
0649C:  CALL   1BC0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
064A0:  MOVLB  1
064A2:  MOVF   x93,W
064A4:  MOVWF  FE9
064A6:  MOVF   x94,W
064A8:  MOVWF  FEA
064AA:  MOVFF  FEF,195
....................    piclog_make(cmd, 0x00); // Log the command execution
064AE:  MOVFF  195,1E6
064B2:  CLRF   xE7
064B4:  MOVLB  0
064B6:  CALL   3F8A
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
064BA:  MOVLW  06
064BC:  MOVLB  1
064BE:  MOVWF  x99
064C0:  MOVLW  AA
064C2:  MOVWF  x98
064C4:  CLRF   x97
064C6:  CLRF   x96
064C8:  MOVLB  0
064CA:  MOVLB  1
064CC:  MOVF   x99,W
064CE:  SUBLW  06
064D0:  BTFSC  FD8.0
064D2:  BRA    64DA
064D4:  MOVLB  0
064D6:  GOTO   6558
064DA:  MOVLB  0
064DC:  BTFSS  FD8.2
064DE:  GOTO   6524
064E2:  MOVLB  1
064E4:  MOVF   x98,W
064E6:  SUBLW  AA
064E8:  BTFSC  FD8.0
064EA:  BRA    64F2
064EC:  MOVLB  0
064EE:  GOTO   6558
064F2:  MOVLB  0
064F4:  BTFSS  FD8.2
064F6:  GOTO   6524
064FA:  MOVLB  1
064FC:  MOVF   x97,W
064FE:  SUBLW  1F
06500:  BTFSC  FD8.0
06502:  BRA    650A
06504:  MOVLB  0
06506:  GOTO   6558
0650A:  MOVLB  0
0650C:  BTFSS  FD8.2
0650E:  GOTO   6524
06512:  MOVLB  1
06514:  MOVF   x96,W
06516:  SUBLW  FE
06518:  BTFSC  FD8.0
0651A:  BRA    6522
0651C:  MOVLB  0
0651E:  GOTO   6558
06522:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
06524:  MOVFF  115,A5F
06528:  MOVFF  114,A5E
0652C:  MOVFF  113,A5D
06530:  MOVFF  112,A5C
06534:  MOVFF  199,A63
06538:  MOVFF  198,A62
0653C:  MOVFF  197,A61
06540:  MOVFF  196,A60
06544:  CALL   3BBC
06548:  MOVLW  01
0654A:  MOVLB  1
0654C:  ADDWF  x98,F
0654E:  MOVLW  00
06550:  ADDWFC x99,F
06552:  MOVLB  0
06554:  GOTO   64CA
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
06558:  MOVFF  195,1E6
0655C:  MOVLB  1
0655E:  SETF   xE7
06560:  MOVLB  0
06562:  CALL   3F8A
....................    printf("End SMF Erase All\r\n");
06566:  MOVLW  78
06568:  MOVWF  FF6
0656A:  MOVLW  19
0656C:  MOVWF  FF7
0656E:  MOVLW  00
06570:  MOVWF  FF8
06572:  CALL   1BC0
06576:  GOTO   90A2 (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
05F08:  MOVLW  8C
05F0A:  MOVWF  FF6
05F0C:  MOVLW  19
05F0E:  MOVWF  FF7
05F10:  MOVLW  00
05F12:  MOVWF  FF8
05F14:  CALL   1BC0
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
05F18:  MOVLB  1
05F1A:  MOVF   x93,W
05F1C:  MOVWF  FE9
05F1E:  MOVF   x94,W
05F20:  MOVWF  FEA
05F22:  MOVFF  FEF,1D9
05F26:  MOVFF  1D9,1E6
05F2A:  CLRF   xE7
05F2C:  MOVLB  0
05F2E:  CALL   3F8A
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
05F32:  MOVLB  1
05F34:  CLRF   x95
05F36:  CLRF   x96
05F38:  CLRF   x97
05F3A:  CLRF   x98
05F3C:  CLRF   x99
05F3E:  CLRF   x9A
05F40:  CLRF   x9B
05F42:  CLRF   x9C
05F44:  CLRF   x9D
05F46:  CLRF   x9E
05F48:  CLRF   x9F
05F4A:  CLRF   xA0
05F4C:  CLRF   xA1
05F4E:  CLRF   xA2
05F50:  CLRF   xA3
05F52:  CLRF   xA4
05F54:  CLRF   xA5
05F56:  CLRF   xA6
05F58:  CLRF   xA7
05F5A:  CLRF   xA8
05F5C:  CLRF   xA9
05F5E:  CLRF   xAA
05F60:  CLRF   xAB
05F62:  CLRF   xAC
05F64:  CLRF   xAD
05F66:  CLRF   xAE
05F68:  CLRF   xAF
05F6A:  CLRF   xB0
05F6C:  CLRF   xB1
05F6E:  CLRF   xB2
05F70:  CLRF   xB3
05F72:  CLRF   xB4
05F74:  CLRF   xB5
05F76:  CLRF   xB6
05F78:  CLRF   xB7
05F7A:  CLRF   xB8
05F7C:  CLRF   xB9
05F7E:  CLRF   xBA
05F80:  CLRF   xBB
05F82:  CLRF   xBC
05F84:  CLRF   xBD
05F86:  CLRF   xBE
05F88:  CLRF   xBF
05F8A:  CLRF   xC0
05F8C:  CLRF   xC1
05F8E:  CLRF   xC2
05F90:  CLRF   xC3
05F92:  CLRF   xC4
05F94:  CLRF   xC5
05F96:  CLRF   xC6
05F98:  CLRF   xC7
05F9A:  CLRF   xC8
05F9C:  CLRF   xC9
05F9E:  CLRF   xCA
05FA0:  CLRF   xCB
05FA2:  CLRF   xCC
05FA4:  CLRF   xCD
05FA6:  CLRF   xCE
05FA8:  CLRF   xCF
05FAA:  CLRF   xD0
05FAC:  CLRF   xD1
05FAE:  CLRF   xD2
05FB0:  CLRF   xD3
05FB2:  CLRF   xD4
....................    for (int32 address = 0x04EC0000; address < 0x056BFFFF; address += SECTOR_64K_BYTE) {
05FB4:  MOVLW  04
05FB6:  MOVWF  xD8
05FB8:  MOVLW  EC
05FBA:  MOVWF  xD7
05FBC:  CLRF   xD6
05FBE:  CLRF   xD5
05FC0:  MOVLB  0
05FC2:  MOVLB  1
05FC4:  MOVF   xD8,W
05FC6:  SUBLW  05
05FC8:  BTFSC  FD8.0
05FCA:  BRA    5FD2
05FCC:  MOVLB  0
05FCE:  GOTO   6050
05FD2:  MOVLB  0
05FD4:  BTFSS  FD8.2
05FD6:  GOTO   601C
05FDA:  MOVLB  1
05FDC:  MOVF   xD7,W
05FDE:  SUBLW  6B
05FE0:  BTFSC  FD8.0
05FE2:  BRA    5FEA
05FE4:  MOVLB  0
05FE6:  GOTO   6050
05FEA:  MOVLB  0
05FEC:  BTFSS  FD8.2
05FEE:  GOTO   601C
05FF2:  MOVLB  1
05FF4:  MOVF   xD6,W
05FF6:  SUBLW  FF
05FF8:  BTFSC  FD8.0
05FFA:  BRA    6002
05FFC:  MOVLB  0
05FFE:  GOTO   6050
06002:  MOVLB  0
06004:  BTFSS  FD8.2
06006:  GOTO   601C
0600A:  MOVLB  1
0600C:  MOVF   xD5,W
0600E:  SUBLW  FE
06010:  BTFSC  FD8.0
06012:  BRA    601A
06014:  MOVLB  0
06016:  GOTO   6050
0601A:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
0601C:  MOVFF  115,A5F
06020:  MOVFF  114,A5E
06024:  MOVFF  113,A5D
06028:  MOVFF  112,A5C
0602C:  MOVFF  1D8,A63
06030:  MOVFF  1D7,A62
06034:  MOVFF  1D6,A61
06038:  MOVFF  1D5,A60
0603C:  CALL   3BBC
06040:  MOVLW  01
06042:  MOVLB  1
06044:  ADDWF  xD7,F
06046:  MOVLW  00
06048:  ADDWFC xD8,F
0604A:  MOVLB  0
0604C:  GOTO   5FC2
....................    }
.................... 
....................    write_data_bytes(smf, 0x04EC0000, writedata, PACKET_SIZE);
06050:  MOVFF  115,A5F
06054:  MOVFF  114,A5E
06058:  MOVFF  113,A5D
0605C:  MOVFF  112,A5C
06060:  MOVLW  04
06062:  MOVLB  A
06064:  MOVWF  x63
06066:  MOVLW  EC
06068:  MOVWF  x62
0606A:  CLRF   x61
0606C:  CLRF   x60
0606E:  MOVLW  01
06070:  MOVWF  x65
06072:  MOVLW  95
06074:  MOVWF  x64
06076:  CLRF   x67
06078:  MOVLW  40
0607A:  MOVWF  x66
0607C:  MOVLB  0
0607E:  CALL   34E0
....................    //smf_init(); // Update the address area after writing
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06082:  MOVLB  1
06084:  MOVF   x93,W
06086:  MOVWF  FE9
06088:  MOVF   x94,W
0608A:  MOVWF  FEA
0608C:  MOVFF  FEF,1D9
06090:  MOVFF  1D9,1E6
06094:  SETF   xE7
06096:  MOVLB  0
06098:  CALL   3F8A
....................    printf("End SMF Reset\r\n");
0609C:  MOVLW  9E
0609E:  MOVWF  FF6
060A0:  MOVLW  19
060A2:  MOVWF  FF7
060A4:  MOVLW  00
060A6:  MOVWF  FF8
060A8:  CALL   1BC0
060AC:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0B094:  CLRF   FF8
0B096:  BCF    FD0.7
0B098:  BSF    07.7
0B09A:  MOVLB  E
0B09C:  MOVLW  55
0B09E:  MOVWF  F7E
0B0A0:  MOVLW  AA
0B0A2:  MOVWF  F7E
0B0A4:  BCF    F66.6
0B0A6:  MOVLW  F9
0B0A8:  MOVWF  x2C
0B0AA:  MOVLW  0F
0B0AC:  MOVWF  x2E
0B0AE:  MOVLW  40
0B0B0:  MOVWF  x12
0B0B2:  MOVLW  30
0B0B4:  MOVWF  x13
0B0B6:  MOVLW  20
0B0B8:  MOVWF  x22
0B0BA:  MOVLW  55
0B0BC:  MOVWF  F7E
0B0BE:  MOVLW  AA
0B0C0:  MOVWF  F7E
0B0C2:  BSF    F66.6
0B0C4:  CLRF   F9B
0B0C6:  CLRF   F64
0B0C8:  CLRF   F65
0B0CA:  CLRF   F66
0B0CC:  MOVLW  02
0B0CE:  MOVWF  FD3
0B0D0:  CLRF   1B
0B0D2:  MOVLB  F
0B0D4:  BSF    x2D.3
0B0D6:  MOVLW  A0
0B0D8:  MOVWF  x2B
0B0DA:  MOVLW  01
0B0DC:  MOVWF  x2C
0B0DE:  MOVLW  A6
0B0E0:  MOVWF  x2E
0B0E2:  MOVLW  90
0B0E4:  MOVWF  x2F
0B0E6:  BCF    F93.6
0B0E8:  BSF    F8A.6
0B0EA:  BSF    F92.1
0B0EC:  BCF    F92.0
0B0EE:  BCF    F92.3
0B0F0:  BCF    F89.3
0B0F2:  BSF    F96.0
0B0F4:  BCF    F96.6
0B0F6:  BCF    F96.1
0B0F8:  BCF    F8D.1
0B0FA:  BSF    F93.4
0B0FC:  BCF    F93.5
0B0FE:  BCF    F93.2
0B100:  BSF    F8A.2
0B102:  CLRF   1F
0B104:  CLRF   1E
0B106:  CLRF   1D
0B108:  CLRF   1C
0B10A:  CLRF   23
0B10C:  CLRF   22
0B10E:  CLRF   21
0B110:  CLRF   20
0B112:  CLRF   25
0B114:  CLRF   24
0B116:  CLRF   46
0B118:  BCF    47.0
0B11A:  MOVLW  1E
0B11C:  MOVLB  1
0B11E:  MOVWF  x4E
0B120:  CLRF   x50
0B122:  CLRF   x4F
0B124:  MOVLB  E
0B126:  CLRF   xD9
0B128:  CLRF   xDA
0B12A:  CLRF   xCE
0B12C:  CLRF   xCF
0B12E:  CLRF   xD0
0B130:  CLRF   xD1
0B132:  CLRF   xD2
0B134:  CLRF   xD3
0B136:  CLRF   xD4
0B138:  CLRF   xD5
0B13A:  CLRF   x45
0B13C:  CLRF   x46
0B13E:  CLRF   x47
0B140:  BCF    x8D.7
0B142:  BCF    x8D.6
0B144:  BCF    x8D.5
0B146:  MOVLB  F
0B148:  CLRF   x53
0B14A:  CLRF   x38
0B14C:  CLRF   x37
0B14E:  MOVLB  0
0B150:  CLRF   26
0B152:  CLRF   27
0B154:  CLRF   28
0B156:  CLRF   29
0B158:  CLRF   2A
0B15A:  CLRF   2B
0B15C:  CLRF   2C
0B15E:  CLRF   2D
0B160:  CLRF   2E
0B162:  CLRF   2F
0B164:  CLRF   30
0B166:  CLRF   31
0B168:  CLRF   32
0B16A:  CLRF   33
0B16C:  CLRF   34
0B16E:  CLRF   35
0B170:  CLRF   36
0B172:  CLRF   37
0B174:  CLRF   38
0B176:  CLRF   39
0B178:  CLRF   3A
0B17A:  CLRF   3B
0B17C:  CLRF   3C
0B17E:  CLRF   3D
0B180:  CLRF   3E
0B182:  CLRF   3F
0B184:  CLRF   40
0B186:  CLRF   41
0B188:  CLRF   42
0B18A:  CLRF   43
0B18C:  CLRF   44
0B18E:  CLRF   45
0B190:  MOVLW  03
0B192:  MOVWF  48
0B194:  CLRF   49
0B196:  CLRF   4A
0B198:  CLRF   4B
0B19A:  CLRF   4C
0B19C:  CLRF   4D
0B19E:  CLRF   4E
0B1A0:  CLRF   4F
0B1A2:  CLRF   50
0B1A4:  CLRF   51
0B1A6:  CLRF   52
0B1A8:  CLRF   53
0B1AA:  CLRF   54
0B1AC:  CLRF   55
0B1AE:  CLRF   56
0B1B0:  CLRF   57
0B1B2:  CLRF   58
0B1B4:  CLRF   59
0B1B6:  CLRF   5A
0B1B8:  CLRF   5B
0B1BA:  CLRF   5C
0B1BC:  CLRF   5D
0B1BE:  CLRF   5E
0B1C0:  CLRF   5F
0B1C2:  CLRF   x60
0B1C4:  CLRF   x61
0B1C6:  CLRF   x62
0B1C8:  CLRF   x63
0B1CA:  CLRF   x64
0B1CC:  CLRF   x65
0B1CE:  CLRF   x66
0B1D0:  CLRF   x67
0B1D2:  CLRF   x68
0B1D4:  CLRF   x69
0B1D6:  CLRF   x6A
0B1D8:  CLRF   x6B
0B1DA:  CLRF   x6C
0B1DC:  CLRF   x6D
0B1DE:  CLRF   x6E
0B1E0:  CLRF   x6F
0B1E2:  CLRF   x70
0B1E4:  CLRF   x71
0B1E6:  CLRF   x72
0B1E8:  CLRF   x73
0B1EA:  CLRF   x74
0B1EC:  CLRF   x75
0B1EE:  CLRF   x76
0B1F0:  CLRF   x77
0B1F2:  CLRF   x78
0B1F4:  CLRF   x79
0B1F6:  CLRF   x7A
0B1F8:  CLRF   x7B
0B1FA:  CLRF   x7C
0B1FC:  CLRF   x7D
0B1FE:  CLRF   x7E
0B200:  CLRF   x7F
0B202:  CLRF   x80
0B204:  CLRF   x81
0B206:  CLRF   x82
0B208:  CLRF   x83
0B20A:  CLRF   x84
0B20C:  CLRF   x85
0B20E:  CLRF   x86
0B210:  CLRF   x87
0B212:  CLRF   x88
0B214:  CLRF   x89
0B216:  CLRF   x8A
0B218:  CLRF   x8B
0B21A:  CLRF   x8C
0B21C:  CLRF   x8D
0B21E:  CLRF   x8E
0B220:  CLRF   x8F
0B222:  CLRF   x90
0B224:  CLRF   x91
0B226:  CLRF   x92
0B228:  CLRF   x93
0B22A:  CLRF   x94
0B22C:  CLRF   x95
0B22E:  CLRF   x96
0B230:  CLRF   x97
0B232:  CLRF   x98
0B234:  CLRF   x99
0B236:  CLRF   x9A
0B238:  CLRF   x9B
0B23A:  CLRF   x9C
0B23C:  CLRF   x9D
0B23E:  CLRF   x9E
0B240:  CLRF   x9F
0B242:  CLRF   xA0
0B244:  CLRF   xA1
0B246:  CLRF   xA2
0B248:  CLRF   xA3
0B24A:  CLRF   xA4
0B24C:  CLRF   xA5
0B24E:  CLRF   xA6
0B250:  CLRF   xA7
0B252:  CLRF   xA8
0B254:  CLRF   xA9
0B256:  CLRF   xAA
0B258:  CLRF   xAB
0B25A:  CLRF   xAC
0B25C:  CLRF   xAD
0B25E:  CLRF   xAE
0B260:  CLRF   xAF
0B262:  CLRF   xB0
0B264:  CLRF   xB1
0B266:  CLRF   xB2
0B268:  CLRF   xB3
0B26A:  CLRF   xB4
0B26C:  CLRF   xB5
0B26E:  CLRF   xB6
0B270:  CLRF   xB7
0B272:  CLRF   xB8
0B274:  CLRF   xB9
0B276:  CLRF   xBA
0B278:  CLRF   xBB
0B27A:  CLRF   xBC
0B27C:  CLRF   xBD
0B27E:  CLRF   xBE
0B280:  CLRF   xBF
0B282:  CLRF   xC0
0B284:  CLRF   xC1
0B286:  CLRF   xC2
0B288:  CLRF   xC3
0B28A:  CLRF   xC4
0B28C:  CLRF   xC5
0B28E:  CLRF   xC6
0B290:  CLRF   xC7
0B292:  CLRF   xC8
0B294:  CLRF   xC9
0B296:  CLRF   xCA
0B298:  CLRF   xCB
0B29A:  CLRF   xCC
0B29C:  CLRF   xCD
0B29E:  CLRF   xCE
0B2A0:  CLRF   xCF
0B2A2:  CLRF   xD0
0B2A4:  CLRF   xD1
0B2A6:  CLRF   xD2
0B2A8:  CLRF   xD3
0B2AA:  CLRF   xD4
0B2AC:  CLRF   xD5
0B2AE:  CLRF   xD6
0B2B0:  CLRF   xD7
0B2B2:  CLRF   xD8
0B2B4:  CLRF   xD9
0B2B6:  CLRF   xDA
0B2B8:  CLRF   xDB
0B2BA:  CLRF   xDC
0B2BC:  CLRF   xDD
0B2BE:  CLRF   xDE
0B2C0:  CLRF   xDF
0B2C2:  CLRF   xE0
0B2C4:  CLRF   xE1
0B2C6:  CLRF   xE2
0B2C8:  CLRF   xE3
0B2CA:  CLRF   xE4
0B2CC:  CLRF   xE5
0B2CE:  CLRF   xE6
0B2D0:  CLRF   xE7
0B2D2:  CLRF   xE8
0B2D4:  CLRF   xE9
0B2D6:  CLRF   xEA
0B2D8:  CLRF   xEB
0B2DA:  CLRF   xEC
0B2DC:  CLRF   xED
0B2DE:  CLRF   xEE
0B2E0:  CLRF   xEF
0B2E2:  CLRF   xF0
0B2E4:  CLRF   xF1
0B2E6:  CLRF   xF2
0B2E8:  CLRF   xF3
0B2EA:  CLRF   xF4
0B2EC:  CLRF   xF5
0B2EE:  CLRF   xF6
0B2F0:  CLRF   xF7
0B2F2:  CLRF   xF8
0B2F4:  CLRF   xF9
0B2F6:  CLRF   xFA
0B2F8:  CLRF   xFB
0B2FA:  CLRF   xFC
0B2FC:  CLRF   xFD
0B2FE:  CLRF   xFE
0B300:  CLRF   xFF
0B302:  MOVLB  1
0B304:  CLRF   x00
0B306:  CLRF   x01
0B308:  CLRF   x02
0B30A:  CLRF   x03
0B30C:  CLRF   x04
0B30E:  CLRF   x05
0B310:  CLRF   x06
0B312:  CLRF   x07
0B314:  CLRF   x08
0B316:  CLRF   x09
0B318:  CLRF   x0A
0B31A:  CLRF   x0B
0B31C:  CLRF   x0C
0B31E:  CLRF   x0D
0B320:  CLRF   x0E
0B322:  CLRF   x0F
0B324:  MOVLW  05
0B326:  MOVWF  x10
0B328:  MOVLW  7C
0B32A:  MOVWF  x11
0B32C:  MOVLW  01
0B32E:  MOVWF  x12
0B330:  MOVLW  01
0B332:  MOVWF  x13
0B334:  MOVLW  02
0B336:  MOVWF  x14
0B338:  MOVLW  7C
0B33A:  MOVWF  x15
0B33C:  CLRF   x16
0B33E:  MOVLW  09
0B340:  MOVWF  x17
0B342:  MOVLW  01
0B344:  MOVWF  x18
0B346:  CLRF   x19
0B348:  MOVLW  02
0B34A:  MOVWF  x1A
0B34C:  MOVLW  01
0B34E:  MOVWF  x1B
0B350:  CLRF   x1C
0B352:  CLRF   x1D
0B354:  CLRF   x1E
0B356:  CLRF   x1F
0B358:  CLRF   x20
0B35A:  CLRF   x21
0B35C:  CLRF   x22
0B35E:  CLRF   x23
0B360:  CLRF   x24
0B362:  CLRF   x25
0B364:  CLRF   x26
0B366:  CLRF   x27
0B368:  CLRF   x28
0B36A:  MOVLW  01
0B36C:  MOVWF  x29
0B36E:  CLRF   x2A
0B370:  CLRF   x2B
0B372:  CLRF   x2C
0B374:  CLRF   x2D
0B376:  CLRF   x2E
0B378:  CLRF   x2F
0B37A:  CLRF   x30
0B37C:  CLRF   x31
0B37E:  CLRF   x32
0B380:  CLRF   x33
0B382:  MOVLW  02
0B384:  MOVWF  x34
0B386:  CLRF   x35
0B388:  CLRF   x36
0B38A:  CLRF   x37
0B38C:  CLRF   x38
0B38E:  CLRF   x39
0B390:  CLRF   x3A
0B392:  CLRF   x3B
0B394:  CLRF   x3C
0B396:  CLRF   x3D
0B398:  CLRF   x3E
0B39A:  MOVLW  03
0B39C:  MOVWF  x3F
0B39E:  CLRF   x40
0B3A0:  CLRF   x41
0B3A2:  CLRF   x42
0B3A4:  CLRF   x43
0B3A6:  CLRF   x44
0B3A8:  CLRF   x45
0B3AA:  CLRF   x46
0B3AC:  CLRF   x47
0B3AE:  CLRF   x48
0B3B0:  CLRF   x49
0B3B2:  CLRF   x51
0B3B4:  CLRF   x52
0B3B6:  CLRF   x53
0B3B8:  CLRF   x54
0B3BA:  CLRF   x55
0B3BC:  CLRF   x56
0B3BE:  CLRF   x57
0B3C0:  CLRF   x58
0B3C2:  CLRF   x59
0B3C4:  CLRF   x5A
0B3C6:  CLRF   x5B
0B3C8:  CLRF   x5C
0B3CA:  CLRF   x5D
0B3CC:  CLRF   x5E
0B3CE:  CLRF   x5F
0B3D0:  CLRF   x60
0B3D2:  CLRF   x61
0B3D4:  CLRF   x62
0B3D6:  CLRF   x63
0B3D8:  CLRF   x64
0B3DA:  CLRF   x65
0B3DC:  CLRF   x66
0B3DE:  CLRF   x67
0B3E0:  CLRF   x68
0B3E2:  CLRF   x69
0B3E4:  CLRF   x6A
0B3E6:  CLRF   x6B
0B3E8:  CLRF   x6C
0B3EA:  CLRF   x6D
0B3EC:  CLRF   x6E
0B3EE:  CLRF   x6F
0B3F0:  CLRF   x70
0B3F2:  CLRF   x71
0B3F4:  CLRF   x72
0B3F6:  CLRF   x73
0B3F8:  CLRF   x74
0B3FA:  CLRF   x75
0B3FC:  CLRF   x76
0B3FE:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0B400:  MOVLW  64
0B402:  MOVLB  A
0B404:  MOVWF  x74
0B406:  MOVLB  0
0B408:  CALL   1B40
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0B40C:  MOVLW  AE
0B40E:  MOVWF  FF6
0B410:  MOVLW  19
0B412:  MOVWF  FF7
0B414:  MOVLW  00
0B416:  MOVWF  FF8
0B418:  CALL   1BC0
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0B41C:  MOVLW  F4
0B41E:  MOVWF  FF6
0B420:  MOVLW  19
0B422:  MOVWF  FF7
0B424:  MOVLW  00
0B426:  MOVWF  FF8
0B428:  CALL   1BC0
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0B42C:  MOVLW  22
0B42E:  MOVWF  FF6
0B430:  MOVLW  1A
0B432:  MOVWF  FF7
0B434:  MOVLW  00
0B436:  MOVWF  FF8
0B438:  MOVLW  10
0B43A:  MOVLB  9
0B43C:  MOVWF  xCC
0B43E:  MOVLB  0
0B440:  CALL   1BF0
0B444:  MOVLW  48
0B446:  MOVWF  FF6
0B448:  MOVLW  1A
0B44A:  MOVWF  FF7
0B44C:  MOVLW  00
0B44E:  MOVWF  FF8
0B450:  CALL   1BC0
0B454:  MOVLW  20
0B456:  MOVLB  A
0B458:  MOVWF  xB3
0B45A:  MOVLB  0
0B45C:  CALL   1B6E
0B460:  MOVLW  52
0B462:  MOVWF  FF6
0B464:  MOVLW  1A
0B466:  MOVWF  FF7
0B468:  MOVLW  00
0B46A:  MOVWF  FF8
0B46C:  CALL   1BC0
0B470:  MOVLW  37
0B472:  MOVWF  FF6
0B474:  MOVLW  1A
0B476:  MOVWF  FF7
0B478:  MOVLW  00
0B47A:  MOVWF  FF8
0B47C:  MOVLW  0F
0B47E:  MOVLB  9
0B480:  MOVWF  xCC
0B482:  MOVLB  0
0B484:  CALL   1BF0
....................    
....................    io_init();
0B488:  GOTO   1C26
....................    setup_uart_to_boss();
0B48C:  GOTO   1C74
....................    setup_timer();
0B490:  GOTO   1C9E
....................    ad7490_init();
0B494:  GOTO   1EB4
....................    mcp4901_init();
0B498:  GOTO   2192
....................    misf_init();
0B49C:  CALL   2FE6
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0B4A0:  MOVLB  1
0B4A2:  CLRF   xE6
0B4A4:  CLRF   xE7
0B4A6:  MOVLB  0
0B4A8:  CALL   3F8A
.................... 
....................    int1 is_finished = FALSE;
0B4AC:  MOVLB  1
0B4AE:  BCF    x77.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0B4B0:  MOVLW  5C
0B4B2:  MOVWF  FF6
0B4B4:  MOVLW  1A
0B4B6:  MOVWF  FF7
0B4B8:  MOVLW  00
0B4BA:  MOVWF  FF8
0B4BC:  MOVLB  0
0B4BE:  CALL   1BC0
....................    
....................    output_low(EN_NPWR);
0B4C2:  MOVLW  5E
0B4C4:  MOVWF  F94
0B4C6:  BCF    F8B.7
....................    
....................    
....................    fprintf(PC,"waiting for BOSS PIC command");
0B4C8:  MOVLW  82
0B4CA:  MOVWF  FF6
0B4CC:  MOVLW  1A
0B4CE:  MOVWF  FF7
0B4D0:  MOVLW  00
0B4D2:  MOVWF  FF8
0B4D4:  CALL   1BC0
....................    
....................    //Start loop
....................    while(!is_finished)
0B4D8:  MOVLB  1
0B4DA:  BTFSS  x77.0
0B4DC:  BRA    B4E4
0B4DE:  MOVLB  0
0B4E0:  GOTO   B6AE
0B4E4:  MOVLB  0
....................    {
....................       unsigned int16 cigs1_amp = ad7490_read(ADC_CIGS2_AMP);
....................       unsigned int16 cigs1_curr = ad7490_read(ADC_CIGS2_CURR);
....................       unsigned int16 cigs1_volt = ad7490_read(ADC_CIGS2_VOLT);
0B4E6:  MOVLW  06
0B4E8:  MOVLB  9
0B4EA:  MOVWF  xDD
0B4EC:  MOVLB  0
0B4EE:  CALL   1DB0
0B4F2:  MOVFF  02,179
0B4F6:  MOVFF  01,178
0B4FA:  MOVLW  05
0B4FC:  MOVLB  9
0B4FE:  MOVWF  xDD
0B500:  MOVLB  0
0B502:  CALL   1DB0
0B506:  MOVFF  02,17B
0B50A:  MOVFF  01,17A
0B50E:  MOVLW  04
0B510:  MOVLB  9
0B512:  MOVWF  xDD
0B514:  MOVLB  0
0B516:  CALL   1DB0
0B51A:  MOVFF  02,17D
0B51E:  MOVFF  01,17C
....................       
....................       fprintf(PC, "CIGS1 Amp: %04LX, Current: %04LX, Voltage: %04LX\r\n", cigs1_amp, cigs1_curr, cigs1_volt);
0B522:  MOVLW  A0
0B524:  MOVWF  FF6
0B526:  MOVLW  1A
0B528:  MOVWF  FF7
0B52A:  MOVLW  00
0B52C:  MOVWF  FF8
0B52E:  MOVLW  0B
0B530:  MOVLB  9
0B532:  MOVWF  xCC
0B534:  MOVLB  0
0B536:  CALL   1BF0
0B53A:  MOVFF  179,9CC
0B53E:  MOVLW  37
0B540:  MOVLB  9
0B542:  MOVWF  xCD
0B544:  MOVLB  0
0B546:  CALL   1E44
0B54A:  MOVFF  178,9CC
0B54E:  MOVLW  37
0B550:  MOVLB  9
0B552:  MOVWF  xCD
0B554:  MOVLB  0
0B556:  CALL   1E44
0B55A:  MOVLW  B0
0B55C:  MOVWF  FF6
0B55E:  MOVLW  1A
0B560:  MOVWF  FF7
0B562:  MOVLW  00
0B564:  MOVWF  FF8
0B566:  MOVLW  0B
0B568:  MOVLB  9
0B56A:  MOVWF  xCC
0B56C:  MOVLB  0
0B56E:  CALL   1BF0
0B572:  MOVFF  17B,9CC
0B576:  MOVLW  37
0B578:  MOVLB  9
0B57A:  MOVWF  xCD
0B57C:  MOVLB  0
0B57E:  CALL   1E44
0B582:  MOVFF  17A,9CC
0B586:  MOVLW  37
0B588:  MOVLB  9
0B58A:  MOVWF  xCD
0B58C:  MOVLB  0
0B58E:  CALL   1E44
0B592:  MOVLW  C0
0B594:  MOVWF  FF6
0B596:  MOVLW  1A
0B598:  MOVWF  FF7
0B59A:  MOVLW  00
0B59C:  MOVWF  FF8
0B59E:  MOVLW  0B
0B5A0:  MOVLB  9
0B5A2:  MOVWF  xCC
0B5A4:  MOVLB  0
0B5A6:  CALL   1BF0
0B5AA:  MOVFF  17D,9CC
0B5AE:  MOVLW  37
0B5B0:  MOVLB  9
0B5B2:  MOVWF  xCD
0B5B4:  MOVLB  0
0B5B6:  CALL   1E44
0B5BA:  MOVFF  17C,9CC
0B5BE:  MOVLW  37
0B5C0:  MOVLB  9
0B5C2:  MOVWF  xCD
0B5C4:  MOVLB  0
0B5C6:  CALL   1E44
0B5CA:  MOVLW  0D
0B5CC:  MOVLB  A
0B5CE:  MOVWF  xB3
0B5D0:  MOVLB  0
0B5D2:  CALL   1B6E
0B5D6:  MOVLW  0A
0B5D8:  MOVLB  A
0B5DA:  MOVWF  xB3
0B5DC:  MOVLB  0
0B5DE:  CALL   1B6E
....................       
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0B5E2:  MOVF   46,F
0B5E4:  BTFSC  FD8.2
0B5E6:  GOTO   B66A
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0B5EA:  MOVLB  1
0B5EC:  CLRF   x91
0B5EE:  MOVLW  26
0B5F0:  MOVWF  x90
0B5F2:  MOVFF  46,192
0B5F6:  MOVLB  0
0B5F8:  GOTO   4438
0B5FC:  MOVFF  02,03
0B600:  MOVF   01,W
0B602:  MOVWF  FE1
0B604:  MOVFF  03,FE2
0B608:  MOVLW  01
0B60A:  MOVWF  FEA
0B60C:  MOVLW  7E
0B60E:  MOVWF  FE9
0B610:  MOVLW  0C
0B612:  MOVWF  01
0B614:  MOVFF  FE6,FEE
0B618:  DECFSZ 01,F
0B61A:  GOTO   B614
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0B61E:  MOVLB  1
0B620:  CLRF   x8B
0B622:  MOVLW  26
0B624:  MOVWF  x8A
0B626:  CLRF   x8D
0B628:  MOVLW  46
0B62A:  MOVWF  x8C
0B62C:  MOVLB  0
0B62E:  GOTO   4634
....................          
....................          if(recieve_cmd.is_exist)
0B632:  MOVLB  1
0B634:  BTFSC  x80.0
0B636:  BRA    B63E
0B638:  MOVLB  0
0B63A:  GOTO   B65A
0B63E:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0B640:  MOVLW  01
0B642:  MOVLB  1
0B644:  MOVWF  x8B
0B646:  MOVLW  7E
0B648:  MOVWF  x8A
0B64A:  MOVLB  0
0B64C:  GOTO   B012
0B650:  MOVLB  1
0B652:  BCF    x77.1
0B654:  BTFSC  01.0
0B656:  BSF    x77.1
0B658:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0B65A:  MOVLW  D4
0B65C:  MOVWF  FF6
0B65E:  MOVLW  1A
0B660:  MOVWF  FF7
0B662:  MOVLW  00
0B664:  MOVWF  FF8
0B666:  CALL   1BC0
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0B66A:  MOVLB  1
0B66C:  BTFSC  x77.0
0B66E:  BRA    B676
0B670:  MOVLB  0
0B672:  GOTO   B67C
0B676:  MOVLB  0
....................          break;
0B678:  GOTO   B6AE
....................          
....................       delay_ms(400);
0B67C:  MOVLW  02
0B67E:  MOVLB  1
0B680:  MOVWF  x8A
0B682:  MOVLB  0
0B684:  MOVLW  C8
0B686:  MOVLB  A
0B688:  MOVWF  x74
0B68A:  MOVLB  0
0B68C:  CALL   1B40
0B690:  MOVLB  1
0B692:  DECFSZ x8A,F
0B694:  BRA    B69A
0B696:  BRA    B69E
0B698:  MOVLB  0
0B69A:  MOVLB  0
0B69C:  BRA    B684
....................       fprintf(PC, ".");
0B69E:  MOVLW  2E
0B6A0:  MOVLB  A
0B6A2:  MOVWF  xB3
0B6A4:  MOVLB  0
0B6A6:  CALL   1B6E
0B6AA:  GOTO   B4D8
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0B6AE:  MOVLW  F4
0B6B0:  MOVWF  FF6
0B6B2:  MOVLW  1A
0B6B4:  MOVWF  FF7
0B6B6:  MOVLW  00
0B6B8:  MOVWF  FF8
0B6BA:  CALL   1BC0
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0B6BE:  MOVLW  2E
0B6C0:  MOVLB  A
0B6C2:  MOVWF  xB3
0B6C4:  MOVLB  0
0B6C6:  CALL   1B6E
....................       delay_ms(1000);
0B6CA:  MOVLW  04
0B6CC:  MOVLB  1
0B6CE:  MOVWF  x8A
0B6D0:  MOVLB  0
0B6D2:  MOVLW  FA
0B6D4:  MOVLB  A
0B6D6:  MOVWF  x74
0B6D8:  MOVLB  0
0B6DA:  CALL   1B40
0B6DE:  MOVLB  1
0B6E0:  DECFSZ x8A,F
0B6E2:  BRA    B6E8
0B6E4:  BRA    B6EC
0B6E6:  MOVLB  0
0B6E8:  MOVLB  0
0B6EA:  BRA    B6D2
0B6EC:  MOVLB  0
0B6EE:  GOTO   B6BE
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0B6F2:  MOVLW  34
0B6F4:  MOVWF  FF6
0B6F6:  MOVLW  1B
0B6F8:  MOVWF  FF7
0B6FA:  MOVLW  00
0B6FC:  MOVWF  FF8
0B6FE:  CALL   1BC0
....................    
.................... }
.................... // Enf of files
0B702:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
