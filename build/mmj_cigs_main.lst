CCS PCH C Compiler, Version 5.104, 57077               14-8-25 11:42

               Filename:   build\mmj_cigs_main.lst

               ROM used:   46764 bytes (36%)
                           Largest free fragment is 65520
               RAM used:   389 (11%) at main() level
                           2751 (77%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   B13A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "cigs/system/mmj_cigs_main.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 45,6E
0028C:  DATA 71,75
0028E:  DATA 65,75
00290:  DATA 65,20
00292:  DATA 46,6C
00294:  DATA 61,73
00296:  DATA 68,20
00298:  DATA 4F,70
0029A:  DATA 65,72
0029C:  DATA 61,74
0029E:  DATA 69,6F
002A0:  DATA 6E,0D
002A2:  DATA 0A,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,66
002B4:  DATA 75,6C
002B6:  DATA 6C,21
002B8:  DATA 21,21
002BA:  DATA 0D,0A
002BC:  DATA 00,00
002BE:  DATA 46,6C
002C0:  DATA 61,73
002C2:  DATA 68,20
002C4:  DATA 71,75
002C6:  DATA 65,75
002C8:  DATA 65,20
002CA:  DATA 69,73
002CC:  DATA 20,65
002CE:  DATA 6D,70
002D0:  DATA 74,79
002D2:  DATA 0D,0A
002D4:  DATA 00,00
002D6:  DATA 0D,0A
002D8:  DATA 53,74
002DA:  DATA 61,72
002DC:  DATA 74,20
002DE:  DATA 6D,61
002E0:  DATA 6B,65
002E2:  DATA 5F,72
002E4:  DATA 65,63
002E6:  DATA 65,69
002E8:  DATA 76,65
002EA:  DATA 5F,63
002EC:  DATA 6F,6D
002EE:  DATA 6D,61
002F0:  DATA 6E,64
002F2:  DATA 0D,0A
002F4:  DATA 00,00
002F6:  DATA 09,5B
002F8:  DATA 42,4F
002FA:  DATA 53,53
002FC:  DATA 5D,20
002FE:  DATA 3E,3E
00300:  DATA 3E,20
00302:  DATA 00,00
00304:  DATA 45,6E
00306:  DATA 64,20
00308:  DATA 6D,61
0030A:  DATA 6B,65
0030C:  DATA 5F,72
0030E:  DATA 65,63
00310:  DATA 69,76
00312:  DATA 65,5F
00314:  DATA 63,6F
00316:  DATA 6D,6D
00318:  DATA 61,6E
0031A:  DATA 64,0D
0031C:  DATA 0A,0D
0031E:  DATA 0A,00
00320:  DATA 73,69
00322:  DATA 67,6E
00324:  DATA 61,6C
00326:  DATA 20,65
00328:  DATA 6E,64
0032A:  DATA 20,77
0032C:  DATA 69,74
0032E:  DATA 68,20
00330:  DATA 53,46
00332:  DATA 44,0D
00334:  DATA 0A,00
00336:  DATA 64,6F
00338:  DATA 6E,27
0033A:  DATA 74,20
0033C:  DATA 66,69
0033E:  DATA 6E,64
00340:  DATA 20,53
00342:  DATA 46,44
00344:  DATA 0D,0A
00346:  DATA 00,00
00348:  DATA 09,2D
0034A:  DATA 3E,20
0034C:  DATA 49,6E
0034E:  DATA 76,61
00350:  DATA 6C,69
00352:  DATA 64,20
00354:  DATA 46,72
00356:  DATA 61,6D
00358:  DATA 65,20
0035A:  DATA 49,44
0035C:  DATA 20,72
0035E:  DATA 65,63
00360:  DATA 65,69
00362:  DATA 76,65
00364:  DATA 64,3A
00366:  DATA 20,25
00368:  DATA 58,0D
0036A:  DATA 0A,00
0036C:  DATA 09,2D
0036E:  DATA 3E,20
00370:  DATA 43,52
00372:  DATA 43,20
00374:  DATA 65,72
00376:  DATA 72,6F
00378:  DATA 72,21
0037A:  DATA 0D,0A
0037C:  DATA 00,00
0037E:  DATA 09,09
00380:  DATA 2D,3E
00382:  DATA 20,72
00384:  DATA 65,63
00386:  DATA 65,69
00388:  DATA 76,65
0038A:  DATA 64,20
0038C:  DATA 43,52
0038E:  DATA 43,3A
00390:  DATA 20,25
00392:  DATA 58,0D
00394:  DATA 0A,00
00396:  DATA 09,09
00398:  DATA 20,20
0039A:  DATA 20,63
0039C:  DATA 6F,6C
0039E:  DATA 6C,65
003A0:  DATA 63,74
003A2:  DATA 20,43
003A4:  DATA 52,43
003A6:  DATA 20,3A
003A8:  DATA 20,25
003AA:  DATA 58,0D
003AC:  DATA 0A,00
003AE:  DATA 09,2D
003B0:  DATA 3E,20
003B2:  DATA 49,6E
003B4:  DATA 76,61
003B6:  DATA 6C,69
003B8:  DATA 64,20
003BA:  DATA 64,65
003BC:  DATA 76,69
003BE:  DATA 63,65
003C0:  DATA 20,49
003C2:  DATA 44,20
003C4:  DATA 72,65
003C6:  DATA 63,65
003C8:  DATA 69,76
003CA:  DATA 65,64
003CC:  DATA 0D,0A
003CE:  DATA 00,00
003D0:  DATA 09,09
003D2:  DATA 2D,3E
003D4:  DATA 20,72
003D6:  DATA 65,63
003D8:  DATA 65,69
003DA:  DATA 76,65
003DC:  DATA 64,3A
003DE:  DATA 20,20
003E0:  DATA 20,20
003E2:  DATA 20,25
003E4:  DATA 58,0D
003E6:  DATA 0A,00
003E8:  DATA 09,09
003EA:  DATA 20,20
003EC:  DATA 20,4D
003EE:  DATA 79,20
003F0:  DATA 64,65
003F2:  DATA 76,69
003F4:  DATA 63,65
003F6:  DATA 20,49
003F8:  DATA 44,3A
003FA:  DATA 20,25
003FC:  DATA 58,0D
003FE:  DATA 0A,00
00400:  DATA 09,5B
00402:  DATA 42,4F
00404:  DATA 53,53
00406:  DATA 5D,20
00408:  DATA 3C,3C
0040A:  DATA 3C,20
0040C:  DATA 00,00
0040E:  DATA 53,74
00410:  DATA 61,72
00412:  DATA 74,20
00414:  DATA 53,4D
00416:  DATA 46,20
00418:  DATA 75,73
0041A:  DATA 69,6E
0041C:  DATA 67,20
0041E:  DATA 72,65
00420:  DATA 71,65
00422:  DATA 73,74
00424:  DATA 20,73
00426:  DATA 65,61
00428:  DATA 71,75
0042A:  DATA 65,6E
0042C:  DATA 63,65
0042E:  DATA 0D,0A
00430:  DATA 00,00
00432:  DATA 45,72
00434:  DATA 72,6F
00436:  DATA 72,21
00438:  DATA 20,52
0043A:  DATA 65,63
0043C:  DATA 65,69
0043E:  DATA 76,69
00440:  DATA 6E,67
00442:  DATA 20,63
00444:  DATA 6F,6D
00446:  DATA 6D,61
00448:  DATA 6E,64
0044A:  DATA 20,69
0044C:  DATA 6E,63
0044E:  DATA 6F,6E
00450:  DATA 73,69
00452:  DATA 73,74
00454:  DATA 65,6E
00456:  DATA 74,20
00458:  DATA 77,69
0045A:  DATA 74,68
0045C:  DATA 20,74
0045E:  DATA 68,65
00460:  DATA 20,64
00462:  DATA 65,73
00464:  DATA 69,67
00466:  DATA 6E,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 61,6C
0047C:  DATA 6C,6F
0047E:  DATA 77,65
00480:  DATA 64,0D
00482:  DATA 0A,00
00484:  DATA 53,4D
00486:  DATA 46,20
00488:  DATA 75,73
0048A:  DATA 65,20
0048C:  DATA 72,65
0048E:  DATA 71,75
00490:  DATA 65,73
00492:  DATA 74,20
00494:  DATA 64,65
00496:  DATA 6E,79
00498:  DATA 65,64
0049A:  DATA 0D,0A
0049C:  DATA 00,00
0049E:  DATA 52,65
004A0:  DATA 74,72
004A2:  DATA 79,20
004A4:  DATA 72,65
004A6:  DATA 71,75
004A8:  DATA 65,73
004AA:  DATA 74,20
004AC:  DATA 74,6F
004AE:  DATA 20,42
004B0:  DATA 4F,53
004B2:  DATA 53,20
004B4:  DATA 50,49
004B6:  DATA 43,0D
004B8:  DATA 0A,00
004BA:  DATA 45,72
004BC:  DATA 72,6F
004BE:  DATA 72,21
004C0:  DATA 20,52
004C2:  DATA 65,63
004C4:  DATA 65,69
004C6:  DATA 76,69
004C8:  DATA 6E,67
004CA:  DATA 20,63
004CC:  DATA 6F,6D
004CE:  DATA 6D,61
004D0:  DATA 6E,64
004D2:  DATA 20,69
004D4:  DATA 6E,63
004D6:  DATA 6F,6E
004D8:  DATA 73,69
004DA:  DATA 73,74
004DC:  DATA 65,6E
004DE:  DATA 74,20
004E0:  DATA 77,69
004E2:  DATA 74,68
004E4:  DATA 20,74
004E6:  DATA 68,65
004E8:  DATA 20,64
004EA:  DATA 65,73
004EC:  DATA 69,67
004EE:  DATA 6E,0D
004F0:  DATA 0A,00
004F2:  DATA 45,6E
004F4:  DATA 64,20
004F6:  DATA 53,4D
004F8:  DATA 46,20
004FA:  DATA 75,73
004FC:  DATA 69,6E
004FE:  DATA 67,20
00500:  DATA 72,65
00502:  DATA 71,65
00504:  DATA 73,74
00506:  DATA 20,73
00508:  DATA 65,61
0050A:  DATA 71,75
0050C:  DATA 65,6E
0050E:  DATA 63,65
00510:  DATA 0D,0A
00512:  DATA 00,00
00514:  DATA 49,4F
00516:  DATA 20,49
00518:  DATA 6E,69
0051A:  DATA 74,69
0051C:  DATA 61,6C
0051E:  DATA 69,7A
00520:  DATA 65,0D
00522:  DATA 0A,00
00524:  DATA 09,43
00526:  DATA 6F,6D
00528:  DATA 70,6C
0052A:  DATA 65,74
0052C:  DATA 65,0D
0052E:  DATA 0A,00
00530:  DATA 53,74
00532:  DATA 61,72
00534:  DATA 74,20
00536:  DATA 54,45
00538:  DATA 53,54
0053A:  DATA 20,53
0053C:  DATA 57,45
0053E:  DATA 45,50
00540:  DATA 0D,0A
00542:  DATA 00,00
00544:  DATA 73,74
00546:  DATA 65,70
00548:  DATA 2C,20
0054A:  DATA 76,6F
0054C:  DATA 6C,74
0054E:  DATA 61,67
00550:  DATA 65,2C
00552:  DATA 20,63
00554:  DATA 75,72
00556:  DATA 72,65
00558:  DATA 6E,74
0055A:  DATA 0D,0A
0055C:  DATA 00,00
0055E:  DATA 53,74
00560:  DATA 61,72
00562:  DATA 74,20
00564:  DATA 41,44
00566:  DATA 43,20
00568:  DATA 54,45
0056A:  DATA 53,54
0056C:  DATA 0D,0A
0056E:  DATA 00,00
00570:  DATA 41,44
00572:  DATA 43,20
00574:  DATA 56,6F
00576:  DATA 6C,74
00578:  DATA 61,67
0057A:  DATA 65,3A
0057C:  DATA 20,25
0057E:  DATA 30,34
00580:  DATA 4C,58
00582:  DATA 0D,0A
00584:  DATA 00,00
00586:  DATA 41,44
00588:  DATA 43,20
0058A:  DATA 43,75
0058C:  DATA 72,72
0058E:  DATA 65,6E
00590:  DATA 74,3A
00592:  DATA 20,25
00594:  DATA 30,34
00596:  DATA 4C,58
00598:  DATA 0D,0A
0059A:  DATA 00,00
0059C:  DATA 41,44
0059E:  DATA 43,20
005A0:  DATA 43,49
005A2:  DATA 47,53
005A4:  DATA 31,20
005A6:  DATA 41,6D
005A8:  DATA 70,3A
005AA:  DATA 20,25
005AC:  DATA 30,34
005AE:  DATA 4C,58
005B0:  DATA 0D,0A
005B2:  DATA 00,00
005B4:  DATA 41,44
005B6:  DATA 43,20
005B8:  DATA 43,49
005BA:  DATA 47,53
005BC:  DATA 31,20
005BE:  DATA 56,52
005C0:  DATA 45,46
005C2:  DATA 3A,20
005C4:  DATA 25,30
005C6:  DATA 34,4C
005C8:  DATA 58,0D
005CA:  DATA 0A,00
005CC:  DATA 53,74
005CE:  DATA 61,72
005D0:  DATA 74,20
005D2:  DATA 53,57
005D4:  DATA 45,45
005D6:  DATA 50,20
005D8:  DATA 32,70
005DA:  DATA 6F,72
005DC:  DATA 74,73
005DE:  DATA 0D,0A
005E0:  DATA 00,00
005E2:  DATA 09,53
005E4:  DATA 77,65
005E6:  DATA 65,70
005E8:  DATA 20,73
005EA:  DATA 74,65
005EC:  DATA 70,20
005EE:  DATA 3A,20
005F0:  DATA 25,75
005F2:  DATA 0D,0A
005F4:  DATA 00,00
005F6:  DATA 45,4E
005F8:  DATA 44,20
005FA:  DATA 53,57
005FC:  DATA 45,45
005FE:  DATA 50,20
00600:  DATA 32,70
00602:  DATA 6F,72
00604:  DATA 74,0D
00606:  DATA 0A,00
00608:  DATA 53,74
0060A:  DATA 61,72
0060C:  DATA 74,20
0060E:  DATA 43,49
00610:  DATA 47,53
00612:  DATA 20,64
00614:  DATA 61,74
00616:  DATA 61,20
00618:  DATA 63,6F
0061A:  DATA 6E,76
0061C:  DATA 65,72
0061E:  DATA 73,69
00620:  DATA 6F,6E
00622:  DATA 0D,0A
00624:  DATA 00,00
00626:  DATA 53,74
00628:  DATA 61,72
0062A:  DATA 74,20
0062C:  DATA 53,57
0062E:  DATA 45,45
00630:  DATA 50,20
00632:  DATA 77,69
00634:  DATA 74,68
00636:  DATA 20,74
00638:  DATA 68,72
0063A:  DATA 65,73
0063C:  DATA 68,6F
0063E:  DATA 6C,64
00640:  DATA 0D,0A
00642:  DATA 00,00
00644:  DATA 4D,61
00646:  DATA 78,69
00648:  DATA 6D,75
0064A:  DATA 6D,20
0064C:  DATA 73,74
0064E:  DATA 65,70
00650:  DATA 20,63
00652:  DATA 6F,75
00654:  DATA 6E,74
00656:  DATA 20,72
00658:  DATA 65,61
0065A:  DATA 63,68
0065C:  DATA 65,64
0065E:  DATA 3A,20
00660:  DATA 25,6C
00662:  DATA 64,0D
00664:  DATA 0A,00
00666:  DATA 43,49
00668:  DATA 47,53
0066A:  DATA 31,20
0066C:  DATA 63,75
0066E:  DATA 72,72
00670:  DATA 65,6E
00672:  DATA 74,20
00674:  DATA 6C,69
00676:  DATA 6D,69
00678:  DATA 74,20
0067A:  DATA 72,65
0067C:  DATA 61,63
0067E:  DATA 68,65
00680:  DATA 64,3A
00682:  DATA 00,00
00684:  DATA 43,49
00686:  DATA 47,53
00688:  DATA 31,20
0068A:  DATA 63,75
0068C:  DATA 72,72
0068E:  DATA 65,6E
00690:  DATA 74,20
00692:  DATA 62,65
00694:  DATA 6C,6F
00696:  DATA 77,20
00698:  DATA 74,68
0069A:  DATA 72,65
0069C:  DATA 73,68
0069E:  DATA 6F,6C
006A0:  DATA 64,00
006A2:  DATA 43,49
006A4:  DATA 47,53
006A6:  DATA 32,20
006A8:  DATA 63,75
006AA:  DATA 72,72
006AC:  DATA 65,6E
006AE:  DATA 74,20
006B0:  DATA 6C,69
006B2:  DATA 6D,69
006B4:  DATA 74,20
006B6:  DATA 72,65
006B8:  DATA 61,63
006BA:  DATA 68,65
006BC:  DATA 64,3A
006BE:  DATA 20,00
006C0:  DATA 43,49
006C2:  DATA 47,53
006C4:  DATA 32,20
006C6:  DATA 63,75
006C8:  DATA 72,72
006CA:  DATA 65,6E
006CC:  DATA 74,20
006CE:  DATA 62,65
006D0:  DATA 6C,6F
006D2:  DATA 77,20
006D4:  DATA 74,68
006D6:  DATA 72,65
006D8:  DATA 73,68
006DA:  DATA 6F,6C
006DC:  DATA 64,3A
006DE:  DATA 00,00
006E0:  DATA 45,6E
006E2:  DATA 64,20
006E4:  DATA 53,57
006E6:  DATA 45,45
006E8:  DATA 50,20
006EA:  DATA 77,69
006EC:  DATA 74,68
006EE:  DATA 20,74
006F0:  DATA 68,72
006F2:  DATA 65,73
006F4:  DATA 68,6F
006F6:  DATA 6C,64
006F8:  DATA 0D,0A
006FA:  DATA 00,00
006FC:  DATA 45,6E
006FE:  DATA 64,20
00700:  DATA 43,49
00702:  DATA 47,53
00704:  DATA 20,64
00706:  DATA 61,74
00708:  DATA 61,20
0070A:  DATA 63,6F
0070C:  DATA 6E,76
0070E:  DATA 65,72
00710:  DATA 73,69
00712:  DATA 6F,6E
00714:  DATA 0D,0A
00716:  DATA 00,00
00718:  DATA 09,5B
0071A:  DATA 50,49
0071C:  DATA 43,4C
0071E:  DATA 4F,47
00720:  DATA 5D,20
00722:  DATA 3A,20
00724:  DATA 00,00
00726:  DATA 43,52
00728:  DATA 43,20
0072A:  DATA 76,65
0072C:  DATA 72,69
0072E:  DATA 66,69
00730:  DATA 63,61
00732:  DATA 74,69
00734:  DATA 6F,6E
00736:  DATA 20,70
00738:  DATA 61,73
0073A:  DATA 73,65
0073C:  DATA 64,20
0073E:  DATA 6F,6E
00740:  DATA 20,61
00742:  DATA 74,74
00744:  DATA 65,6D
00746:  DATA 70,74
00748:  DATA 20,25
0074A:  DATA 75,0D
0074C:  DATA 0A,00
0074E:  DATA 43,52
00750:  DATA 43,20
00752:  DATA 76,65
00754:  DATA 72,69
00756:  DATA 66,69
00758:  DATA 63,61
0075A:  DATA 74,69
0075C:  DATA 6F,6E
0075E:  DATA 20,70
00760:  DATA 61,73
00762:  DATA 73,65
00764:  DATA 64,20
00766:  DATA 6F,6E
00768:  DATA 20,61
0076A:  DATA 74,74
0076C:  DATA 65,6D
0076E:  DATA 70,74
00770:  DATA 20,25
00772:  DATA 64,0D
00774:  DATA 0A,00
00776:  DATA 45,72
00778:  DATA 72,6F
0077A:  DATA 72,3A
0077C:  DATA 20,43
0077E:  DATA 52,43
00780:  DATA 20,76
00782:  DATA 65,72
00784:  DATA 69,66
00786:  DATA 69,63
00788:  DATA 61,74
0078A:  DATA 69,6F
0078C:  DATA 6E,20
0078E:  DATA 66,61
00790:  DATA 69,6C
00792:  DATA 65,64
00794:  DATA 20,61
00796:  DATA 66,74
00798:  DATA 65,72
0079A:  DATA 20,25
0079C:  DATA 64,20
0079E:  DATA 61,74
007A0:  DATA 74,65
007A2:  DATA 6D,70
007A4:  DATA 74,73
007A6:  DATA 0D,0A
007A8:  DATA 00,00
007AA:  DATA 0D,0A
007AC:  DATA 5F,5F
007AE:  DATA 5F,5F
007B0:  DATA 5F,5F
007B2:  DATA 5F,5F
007B4:  DATA 5F,5F
007B6:  DATA 5F,5F
007B8:  DATA 5F,5F
007BA:  DATA 5F,5F
007BC:  DATA 5F,5F
007BE:  DATA 5F,5F
007C0:  DATA 0D,0A
007C2:  DATA 00,00
007C4:  DATA 5F,5F
007C6:  DATA 5F,5F
007C8:  DATA 5F,53
007CA:  DATA 74,61
007CC:  DATA 72,74
007CE:  DATA 20,63
007D0:  DATA 6F,70
007D2:  DATA 79,5F
007D4:  DATA 64,61
007D6:  DATA 74,61
007D8:  DATA 5F,5F
007DA:  DATA 5F,5F
007DC:  DATA 0D,0A
007DE:  DATA 00,00
007E0:  DATA 45,72
007E2:  DATA 72,6F
007E4:  DATA 72,3A
007E6:  DATA 20,4D
007E8:  DATA 49,53
007EA:  DATA 20,46
007EC:  DATA 4D,20
007EE:  DATA 69,73
007F0:  DATA 20,6E
007F2:  DATA 6F,74
007F4:  DATA 20,63
007F6:  DATA 6F,6E
007F8:  DATA 6E,65
007FA:  DATA 63,74
007FC:  DATA 65,64
007FE:  DATA 0D,0A
00800:  DATA 00,00
00802:  DATA 45,72
00804:  DATA 72,6F
00806:  DATA 72,3A
00808:  DATA 20,53
0080A:  DATA 4D,46
0080C:  DATA 20,69
0080E:  DATA 73,20
00810:  DATA 6E,6F
00812:  DATA 74,20
00814:  DATA 63,6F
00816:  DATA 6E,6E
00818:  DATA 65,63
0081A:  DATA 74,65
0081C:  DATA 64,0D
0081E:  DATA 0A,00
00820:  DATA 53,69
00822:  DATA 7A,65
00824:  DATA 20,61
00826:  DATA 72,65
00828:  DATA 61,20
0082A:  DATA 72,65
0082C:  DATA 61,64
0082E:  DATA 0D,0A
00830:  DATA 00,00
00832:  DATA 73,6D
00834:  DATA 66,5F
00836:  DATA 75,73
00838:  DATA 65,64
0083A:  DATA 5F,73
0083C:  DATA 69,7A
0083E:  DATA 65,20
00840:  DATA 3D,20
00842:  DATA 25,6C
00844:  DATA 64,20
00846:  DATA 28,73
00848:  DATA 72,63
0084A:  DATA 20,30
0084C:  DATA 78,25
0084E:  DATA 30,38
00850:  DATA 4C,58
00852:  DATA 29,0D
00854:  DATA 0A,00
00856:  DATA 73,6D
00858:  DATA 66,5F
0085A:  DATA 6C,6F
0085C:  DATA 6F,70
0085E:  DATA 20,63
00860:  DATA 6F,75
00862:  DATA 6E,74
00864:  DATA 3D,20
00866:  DATA 25,64
00868:  DATA 20,20
0086A:  DATA 28,73
0086C:  DATA 72,63
0086E:  DATA 20,30
00870:  DATA 78,25
00872:  DATA 30,38
00874:  DATA 4C,58
00876:  DATA 29,0D
00878:  DATA 0A,00
0087A:  DATA 6D,69
0087C:  DATA 73,66
0087E:  DATA 5F,77
00880:  DATA 72,69
00882:  DATA 74,65
00884:  DATA 5F,73
00886:  DATA 6F,75
00888:  DATA 72,63
0088A:  DATA 65,20
0088C:  DATA 3D,20
0088E:  DATA 30,78
00890:  DATA 25,30
00892:  DATA 38,4C
00894:  DATA 58,0D
00896:  DATA 0A,00
00898:  DATA 6D,69
0089A:  DATA 73,66
0089C:  DATA 5F,77
0089E:  DATA 72,69
008A0:  DATA 74,65
008A2:  DATA 5F,73
008A4:  DATA 69,7A
008A6:  DATA 65,20
008A8:  DATA 3D,20
008AA:  DATA 30,78
008AC:  DATA 25,30
008AE:  DATA 38,4C
008B0:  DATA 58,0D
008B2:  DATA 0A,00
008B4:  DATA 57,72
008B6:  DATA 61,70
008B8:  DATA 20,74
008BA:  DATA 72,69
008BC:  DATA 67,67
008BE:  DATA 65,72
008C0:  DATA 65,64
008C2:  DATA 3A,20
008C4:  DATA 52,65
008C6:  DATA 73,65
008C8:  DATA 74,74
008CA:  DATA 69,6E
008CC:  DATA 67,20
008CE:  DATA 64,61
008D0:  DATA 74,61
008D2:  DATA 5F,77
008D4:  DATA 72,69
008D6:  DATA 74,65
008D8:  DATA 5F,61
008DA:  DATA 64,64
008DC:  DATA 72,20
008DE:  DATA 74,6F
008E0:  DATA 20,73
008E2:  DATA 74,61
008E4:  DATA 72,74
008E6:  DATA 0D,0A
008E8:  DATA 00,00
008EA:  DATA 75,73
008EC:  DATA 65,64
008EE:  DATA 5F,73
008F0:  DATA 69,7A
008F2:  DATA 65,20
008F4:  DATA 3D,20
008F6:  DATA 25,6C
008F8:  DATA 64,0D
008FA:  DATA 0A,00
008FC:  DATA 6C,6F
008FE:  DATA 6F,70
00900:  DATA 5F,63
00902:  DATA 6F,75
00904:  DATA 6E,74
00906:  DATA 20,3D
00908:  DATA 20,25
0090A:  DATA 75,0D
0090C:  DATA 0A,0D
0090E:  DATA 0A,00
00910:  DATA 0D,0A
00912:  DATA 5F,5F
00914:  DATA 5F,45
00916:  DATA 6E,64
00918:  DATA 20,63
0091A:  DATA 6F,70
0091C:  DATA 79,5F
0091E:  DATA 64,61
00920:  DATA 74,61
00922:  DATA 5F,5F
00924:  DATA 5F,5F
00926:  DATA 0D,0A
00928:  DATA 00,00
0092A:  DATA 5F,5F
0092C:  DATA 5F,5F
0092E:  DATA 5F,5F
00930:  DATA 5F,5F
00932:  DATA 5F,5F
00934:  DATA 5F,5F
00936:  DATA 5F,5F
00938:  DATA 5F,5F
0093A:  DATA 5F,5F
0093C:  DATA 5F,5F
0093E:  DATA 0D,0A
00940:  DATA 0D,0A
00942:  DATA 00,00
00944:  DATA 0D,0A
00946:  DATA 5F,5F
00948:  DATA 5F,5F
0094A:  DATA 5F,5F
0094C:  DATA 5F,5F
0094E:  DATA 5F,5F
00950:  DATA 5F,5F
00952:  DATA 5F,5F
00954:  DATA 5F,5F
00956:  DATA 5F,5F
00958:  DATA 5F,5F
0095A:  DATA 0D,0A
0095C:  DATA 00,00
0095E:  DATA 5F,5F
00960:  DATA 5F,53
00962:  DATA 74,61
00964:  DATA 72,74
00966:  DATA 20,53
00968:  DATA 4D,46
0096A:  DATA 20,52
0096C:  DATA 65,61
0096E:  DATA 64,5F
00970:  DATA 5F,5F
00972:  DATA 5F,0D
00974:  DATA 0A,00
00976:  DATA 49,6E
00978:  DATA 20,53
0097A:  DATA 4D,46
0097C:  DATA 20,52
0097E:  DATA 65,61
00980:  DATA 64,20
00982:  DATA 73,6F
00984:  DATA 75,72
00986:  DATA 63,65
00988:  DATA 20,64
0098A:  DATA 61,74
0098C:  DATA 61,20
0098E:  DATA 61,64
00990:  DATA 64,72
00992:  DATA 65,73
00994:  DATA 73,3A
00996:  DATA 20,25
00998:  DATA 4C,58
0099A:  DATA 0D,0A
0099C:  DATA 00,00
0099E:  DATA 49,6E
009A0:  DATA 20,53
009A2:  DATA 4D,46
009A4:  DATA 20,52
009A6:  DATA 65,61
009A8:  DATA 64,20
009AA:  DATA 64,61
009AC:  DATA 74,61
009AE:  DATA 20,73
009B0:  DATA 69,7A
009B2:  DATA 65,20
009B4:  DATA 20,20
009B6:  DATA 20,20
009B8:  DATA 20,20
009BA:  DATA 20,20
009BC:  DATA 20,3A
009BE:  DATA 20,25
009C0:  DATA 6C,75
009C2:  DATA 20,28
009C4:  DATA 30,78
009C6:  DATA 25,6C
009C8:  DATA 78,29
009CA:  DATA 0D,0A
009CC:  DATA 0D,0A
009CE:  DATA 00,00
009D0:  DATA 45,72
009D2:  DATA 72,6F
009D4:  DATA 72,3A
009D6:  DATA 20,53
009D8:  DATA 4D,46
009DA:  DATA 20,69
009DC:  DATA 73,20
009DE:  DATA 6E,6F
009E0:  DATA 74,20
009E2:  DATA 63,6F
009E4:  DATA 6E,6E
009E6:  DATA 65,63
009E8:  DATA 74,65
009EA:  DATA 64,0D
009EC:  DATA 0A,00
009EE:  DATA 52,45
009F0:  DATA 41,44
009F2:  DATA 20,44
009F4:  DATA 41,54
009F6:  DATA 41,20
009F8:  DATA 46,52
009FA:  DATA 4F,4D
009FC:  DATA 20,53
009FE:  DATA 4D,46
00A00:  DATA 2E,2E
00A02:  DATA 2E,0D
00A04:  DATA 0A,00
00A06:  DATA 0D,0A
00A08:  DATA 5F,5F
00A0A:  DATA 5F,45
00A0C:  DATA 6E,64
00A0E:  DATA 20,53
00A10:  DATA 4D,46
00A12:  DATA 20,52
00A14:  DATA 65,61
00A16:  DATA 64,5F
00A18:  DATA 5F,5F
00A1A:  DATA 5F,0D
00A1C:  DATA 0A,00
00A1E:  DATA 5F,5F
00A20:  DATA 5F,5F
00A22:  DATA 5F,5F
00A24:  DATA 5F,5F
00A26:  DATA 5F,5F
00A28:  DATA 5F,5F
00A2A:  DATA 5F,5F
00A2C:  DATA 5F,5F
00A2E:  DATA 5F,5F
00A30:  DATA 5F,5F
00A32:  DATA 0D,0A
00A34:  DATA 0D,0A
00A36:  DATA 00,00
00A38:  DATA 0D,0A
00A3A:  DATA 5F,5F
00A3C:  DATA 5F,5F
00A3E:  DATA 5F,5F
00A40:  DATA 5F,5F
00A42:  DATA 5F,5F
00A44:  DATA 5F,5F
00A46:  DATA 5F,5F
00A48:  DATA 5F,5F
00A4A:  DATA 5F,5F
00A4C:  DATA 5F,5F
00A4E:  DATA 0D,0A
00A50:  DATA 00,00
00A52:  DATA 5F,5F
00A54:  DATA 5F,53
00A56:  DATA 74,61
00A58:  DATA 72,74
00A5A:  DATA 20,73
00A5C:  DATA 6D,66
00A5E:  DATA 5F,65
00A60:  DATA 72,61
00A62:  DATA 73,65
00A64:  DATA 5F,5F
00A66:  DATA 5F,5F
00A68:  DATA 0D,0A
00A6A:  DATA 00,00
00A6C:  DATA 49,6E
00A6E:  DATA 20,53
00A70:  DATA 4D,46
00A72:  DATA 20,45
00A74:  DATA 72,61
00A76:  DATA 73,65
00A78:  DATA 20,73
00A7A:  DATA 6F,75
00A7C:  DATA 72,63
00A7E:  DATA 65,20
00A80:  DATA 64,61
00A82:  DATA 74,61
00A84:  DATA 20,61
00A86:  DATA 64,64
00A88:  DATA 72,65
00A8A:  DATA 73,73
00A8C:  DATA 3A,20
00A8E:  DATA 25,4C
00A90:  DATA 58,0D
00A92:  DATA 0A,00
00A94:  DATA 49,6E
00A96:  DATA 20,53
00A98:  DATA 4D,46
00A9A:  DATA 20,45
00A9C:  DATA 72,61
00A9E:  DATA 73,65
00AA0:  DATA 20,64
00AA2:  DATA 61,74
00AA4:  DATA 61,20
00AA6:  DATA 73,69
00AA8:  DATA 7A,65
00AAA:  DATA 20,20
00AAC:  DATA 20,20
00AAE:  DATA 20,20
00AB0:  DATA 20,20
00AB2:  DATA 20,20
00AB4:  DATA 3A,20
00AB6:  DATA 25,6C
00AB8:  DATA 75,20
00ABA:  DATA 28,30
00ABC:  DATA 78,25
00ABE:  DATA 6C,78
00AC0:  DATA 29,0D
00AC2:  DATA 0A,0D
00AC4:  DATA 0A,00
00AC6:  DATA 45,72
00AC8:  DATA 72,6F
00ACA:  DATA 72,3A
00ACC:  DATA 20,53
00ACE:  DATA 4D,46
00AD0:  DATA 20,69
00AD2:  DATA 73,20
00AD4:  DATA 6E,6F
00AD6:  DATA 74,20
00AD8:  DATA 63,6F
00ADA:  DATA 6E,6E
00ADC:  DATA 65,63
00ADE:  DATA 74,65
00AE0:  DATA 64,0D
00AE2:  DATA 0A,00
00AE4:  DATA 45,72
00AE6:  DATA 72,6F
00AE8:  DATA 72,3A
00AEA:  DATA 20,45
00AEC:  DATA 72,61
00AEE:  DATA 73,65
00AF0:  DATA 20,73
00AF2:  DATA 6F,75
00AF4:  DATA 72,63
00AF6:  DATA 65,20
00AF8:  DATA 61,64
00AFA:  DATA 64,72
00AFC:  DATA 65,73
00AFE:  DATA 73,20
00B00:  DATA 30,78
00B02:  DATA 25,4C
00B04:  DATA 58,20
00B06:  DATA 69,73
00B08:  DATA 20,6F
00B0A:  DATA 75,74
00B0C:  DATA 73,69
00B0E:  DATA 64,65
00B10:  DATA 20,6D
00B12:  DATA 69,73
00B14:  DATA 73,69
00B16:  DATA 6F,6E
00B18:  DATA 20,72
00B1A:  DATA 61,6E
00B1C:  DATA 67,65
00B1E:  DATA 20,5B
00B20:  DATA 30,78
00B22:  DATA 25,4C
00B24:  DATA 58,20
00B26:  DATA 2D,20
00B28:  DATA 30,78
00B2A:  DATA 25,4C
00B2C:  DATA 58,5D
00B2E:  DATA 0D,0A
00B30:  DATA 00,00
00B32:  DATA 45,72
00B34:  DATA 72,6F
00B36:  DATA 72,3A
00B38:  DATA 20,45
00B3A:  DATA 72,61
00B3C:  DATA 73,65
00B3E:  DATA 20,6F
00B40:  DATA 70,65
00B42:  DATA 72,61
00B44:  DATA 74,69
00B46:  DATA 6F,6E
00B48:  DATA 20,77
00B4A:  DATA 6F,75
00B4C:  DATA 6C,64
00B4E:  DATA 20,65
00B50:  DATA 78,63
00B52:  DATA 65,65
00B54:  DATA 64,20
00B56:  DATA 6D,69
00B58:  DATA 73,73
00B5A:  DATA 69,6F
00B5C:  DATA 6E,20
00B5E:  DATA 65,6E
00B60:  DATA 64,20
00B62:  DATA 61,64
00B64:  DATA 64,72
00B66:  DATA 65,73
00B68:  DATA 73,20
00B6A:  DATA 30,78
00B6C:  DATA 25,4C
00B6E:  DATA 58,0D
00B70:  DATA 0A,00
00B72:  DATA 4C,69
00B74:  DATA 6D,69
00B76:  DATA 74,69
00B78:  DATA 6E,67
00B7A:  DATA 20,65
00B7C:  DATA 72,61
00B7E:  DATA 73,65
00B80:  DATA 20,73
00B82:  DATA 69,7A
00B84:  DATA 65,20
00B86:  DATA 74,6F
00B88:  DATA 20,73
00B8A:  DATA 74,61
00B8C:  DATA 79,20
00B8E:  DATA 77,69
00B90:  DATA 74,68
00B92:  DATA 69,6E
00B94:  DATA 20,6D
00B96:  DATA 69,73
00B98:  DATA 73,69
00B9A:  DATA 6F,6E
00B9C:  DATA 20,62
00B9E:  DATA 6F,75
00BA0:  DATA 6E,64
00BA2:  DATA 73,0D
00BA4:  DATA 0A,00
00BA6:  DATA 45,72
00BA8:  DATA 61,73
00BAA:  DATA 65,20
00BAC:  DATA 6F,70
00BAE:  DATA 65,72
00BB0:  DATA 61,74
00BB2:  DATA 69,6F
00BB4:  DATA 6E,20
00BB6:  DATA 76,61
00BB8:  DATA 6C,69
00BBA:  DATA 64,61
00BBC:  DATA 74,65
00BBE:  DATA 64,20
00BC0:  DATA 77,69
00BC2:  DATA 74,68
00BC4:  DATA 69,6E
00BC6:  DATA 20,6D
00BC8:  DATA 69,73
00BCA:  DATA 73,69
00BCC:  DATA 6F,6E
00BCE:  DATA 20,72
00BD0:  DATA 61,6E
00BD2:  DATA 67,65
00BD4:  DATA 0D,0A
00BD6:  DATA 00,00
00BD8:  DATA 0D,0A
00BDA:  DATA 5F,5F
00BDC:  DATA 5F,45
00BDE:  DATA 6E,64
00BE0:  DATA 20,73
00BE2:  DATA 6D,66
00BE4:  DATA 5F,65
00BE6:  DATA 72,61
00BE8:  DATA 73,65
00BEA:  DATA 5F,5F
00BEC:  DATA 5F,5F
00BEE:  DATA 0D,0A
00BF0:  DATA 00,00
00BF2:  DATA 5F,5F
00BF4:  DATA 5F,5F
00BF6:  DATA 5F,5F
00BF8:  DATA 5F,5F
00BFA:  DATA 5F,5F
00BFC:  DATA 5F,5F
00BFE:  DATA 5F,5F
00C00:  DATA 5F,5F
00C02:  DATA 5F,5F
00C04:  DATA 5F,5F
00C06:  DATA 0D,0A
00C08:  DATA 0D,0A
00C0A:  DATA 00,00
00C0C:  DATA 45,72
00C0E:  DATA 72,6F
00C10:  DATA 72,3A
00C12:  DATA 20,55
00C14:  DATA 6E,6B
00C16:  DATA 6E,6F
00C18:  DATA 77,6E
00C1A:  DATA 20,6D
00C1C:  DATA 69,73
00C1E:  DATA 73,69
00C20:  DATA 6F,6E
00C22:  DATA 5F,69
00C24:  DATA 64,3A
00C26:  DATA 20,25
00C28:  DATA 30,32
00C2A:  DATA 58,0D
00C2C:  DATA 0A,00
00C2E:  DATA 55,70
00C30:  DATA 64,61
00C32:  DATA 74,65
00C34:  DATA 64,20
00C36:  DATA 70,61
00C38:  DATA 72,74
00C3A:  DATA 69,74
00C3C:  DATA 69,6F
00C3E:  DATA 6E,20
00C40:  DATA 66,6F
00C42:  DATA 72,20
00C44:  DATA 6D,69
00C46:  DATA 73,73
00C48:  DATA 69,6F
00C4A:  DATA 6E,5F
00C4C:  DATA 69,64
00C4E:  DATA 20,25
00C50:  DATA 30,32
00C52:  DATA 58,3A
00C54:  DATA 20,75
00C56:  DATA 73,65
00C58:  DATA 64,5F
00C5A:  DATA 73,69
00C5C:  DATA 7A,65
00C5E:  DATA 3D,25
00C60:  DATA 6C,64
00C62:  DATA 2C,20
00C64:  DATA 6C,6F
00C66:  DATA 6F,70
00C68:  DATA 5F,63
00C6A:  DATA 6F,75
00C6C:  DATA 6E,74
00C6E:  DATA 65,72
00C70:  DATA 3D,25
00C72:  DATA 6C,64
00C74:  DATA 0D,0A
00C76:  DATA 00,00
00C78:  DATA 4D,49
00C7A:  DATA 53,53
00C7C:  DATA 49,4F
00C7E:  DATA 4E,20
00C80:  DATA 46,4C
00C82:  DATA 41,53
00C84:  DATA 48,20
00C86:  DATA 49,6E
00C88:  DATA 69,74
00C8A:  DATA 69,61
00C8C:  DATA 6C,69
00C8E:  DATA 7A,65
00C90:  DATA 0D,0A
00C92:  DATA 00,00
00C94:  DATA 09,5B
00C96:  DATA 4D,49
00C98:  DATA 53,20
00C9A:  DATA 46,4D
00C9C:  DATA 5D,20
00C9E:  DATA 43,6F
00CA0:  DATA 6E,6E
00CA2:  DATA 65,63
00CA4:  DATA 74,65
00CA6:  DATA 64,0D
00CA8:  DATA 0A,00
00CAA:  DATA 09,5B
00CAC:  DATA 4D,49
00CAE:  DATA 53,20
00CB0:  DATA 46,4D
00CB2:  DATA 5D,20
00CB4:  DATA 4E,6F
00CB6:  DATA 74,20
00CB8:  DATA 43,6F
00CBA:  DATA 6E,6E
00CBC:  DATA 65,63
00CBE:  DATA 74,65
00CC0:  DATA 64,0D
00CC2:  DATA 0A,00
00CC4:  DATA 09,5B
00CC6:  DATA 53,4D
00CC8:  DATA 46,5D
00CCA:  DATA 20,43
00CCC:  DATA 6F,6E
00CCE:  DATA 6E,65
00CD0:  DATA 63,74
00CD2:  DATA 65,64
00CD4:  DATA 0D,0A
00CD6:  DATA 00,00
00CD8:  DATA 09,5B
00CDA:  DATA 53,4D
00CDC:  DATA 46,5D
00CDE:  DATA 20,4E
00CE0:  DATA 6F,74
00CE2:  DATA 20,43
00CE4:  DATA 6F,6E
00CE6:  DATA 6E,65
00CE8:  DATA 63,74
00CEA:  DATA 65,64
00CEC:  DATA 0D,0A
00CEE:  DATA 00,00
00CF0:  DATA 09,5B
00CF2:  DATA 4D,49
00CF4:  DATA 53,20
00CF6:  DATA 46,4D
00CF8:  DATA 5D,20
00CFA:  DATA 43,52
00CFC:  DATA 43,20
00CFE:  DATA 65,72
00D00:  DATA 72,6F
00D02:  DATA 72,20
00D04:  DATA 2D,3E
00D06:  DATA 20,69
00D08:  DATA 6E,69
00D0A:  DATA 74,69
00D0C:  DATA 61,6C
00D0E:  DATA 69,7A
00D10:  DATA 65,20
00D12:  DATA 63,6F
00D14:  DATA 75,6E
00D16:  DATA 74,65
00D18:  DATA 72,73
00D1A:  DATA 0D,0A
00D1C:  DATA 00,00
00D1E:  DATA 09,7C
00D20:  DATA 20,4D
00D22:  DATA 49,53
00D24:  DATA 46,20
00D26:  DATA 7C,20
00D28:  DATA 50,49
00D2A:  DATA 43,4C
00D2C:  DATA 4F,47
00D2E:  DATA 20,20
00D30:  DATA 20,20
00D32:  DATA 7C,20
00D34:  DATA 55,73
00D36:  DATA 65,20
00D38:  DATA 43,6F
00D3A:  DATA 75,6E
00D3C:  DATA 74,65
00D3E:  DATA 72,20
00D40:  DATA 20,20
00D42:  DATA 20,20
00D44:  DATA 20,3A
00D46:  DATA 20,30
00D48:  DATA 78,25
00D4A:  DATA 30,38
00D4C:  DATA 4C,58
00D4E:  DATA 0D,0A
00D50:  DATA 00,00
00D52:  DATA 09,7C
00D54:  DATA 20,4D
00D56:  DATA 49,53
00D58:  DATA 46,20
00D5A:  DATA 7C,20
00D5C:  DATA 50,49
00D5E:  DATA 43,4C
00D60:  DATA 4F,47
00D62:  DATA 20,20
00D64:  DATA 20,20
00D66:  DATA 7C,20
00D68:  DATA 55,6E
00D6A:  DATA 63,6F
00D6C:  DATA 70,79
00D6E:  DATA 65,64
00D70:  DATA 20,43
00D72:  DATA 6F,75
00D74:  DATA 6E,74
00D76:  DATA 65,72
00D78:  DATA 20,3A
00D7A:  DATA 20,30
00D7C:  DATA 78,25
00D7E:  DATA 30,38
00D80:  DATA 4C,58
00D82:  DATA 0D,0A
00D84:  DATA 00,00
00D86:  DATA 09,7C
00D88:  DATA 20,4D
00D8A:  DATA 49,53
00D8C:  DATA 46,20
00D8E:  DATA 7C,20
00D90:  DATA 50,49
00D92:  DATA 43,4C
00D94:  DATA 4F,47
00D96:  DATA 20,20
00D98:  DATA 20,20
00D9A:  DATA 7C,20
00D9C:  DATA 52,65
00D9E:  DATA 73,65
00DA0:  DATA 72,76
00DA2:  DATA 65,20
00DA4:  DATA 43,6F
00DA6:  DATA 75,6E
00DA8:  DATA 74,65
00DAA:  DATA 72,31
00DAC:  DATA 20,3A
00DAE:  DATA 20,30
00DB0:  DATA 78,25
00DB2:  DATA 30,32
00DB4:  DATA 58,0D
00DB6:  DATA 0A,00
00DB8:  DATA 09,7C
00DBA:  DATA 20,4D
00DBC:  DATA 49,53
00DBE:  DATA 46,20
00DC0:  DATA 7C,20
00DC2:  DATA 50,49
00DC4:  DATA 43,4C
00DC6:  DATA 4F,47
00DC8:  DATA 20,20
00DCA:  DATA 20,20
00DCC:  DATA 7C,20
00DCE:  DATA 52,65
00DD0:  DATA 73,65
00DD2:  DATA 72,76
00DD4:  DATA 65,20
00DD6:  DATA 43,6F
00DD8:  DATA 75,6E
00DDA:  DATA 74,65
00DDC:  DATA 72,32
00DDE:  DATA 20,3A
00DE0:  DATA 20,30
00DE2:  DATA 78,25
00DE4:  DATA 30,32
00DE6:  DATA 58,0D
00DE8:  DATA 0A,00
00DEA:  DATA 09,7C
00DEC:  DATA 20,4D
00DEE:  DATA 49,53
00DF0:  DATA 46,20
00DF2:  DATA 7C,20
00DF4:  DATA 45,4E
00DF6:  DATA 56,49
00DF8:  DATA 52,4F
00DFA:  DATA 20,20
00DFC:  DATA 20,20
00DFE:  DATA 7C,20
00E00:  DATA 55,73
00E02:  DATA 65,20
00E04:  DATA 43,6F
00E06:  DATA 75,6E
00E08:  DATA 74,65
00E0A:  DATA 72,20
00E0C:  DATA 20,20
00E0E:  DATA 20,20
00E10:  DATA 20,3A
00E12:  DATA 20,30
00E14:  DATA 78,25
00E16:  DATA 30,38
00E18:  DATA 4C,58
00E1A:  DATA 0D,0A
00E1C:  DATA 00,00
00E1E:  DATA 09,7C
00E20:  DATA 20,4D
00E22:  DATA 49,53
00E24:  DATA 46,20
00E26:  DATA 7C,20
00E28:  DATA 45,4E
00E2A:  DATA 56,49
00E2C:  DATA 52,4F
00E2E:  DATA 20,20
00E30:  DATA 20,20
00E32:  DATA 7C,20
00E34:  DATA 55,6E
00E36:  DATA 63,6F
00E38:  DATA 70,79
00E3A:  DATA 65,64
00E3C:  DATA 20,43
00E3E:  DATA 6F,75
00E40:  DATA 6E,74
00E42:  DATA 65,72
00E44:  DATA 20,3A
00E46:  DATA 20,30
00E48:  DATA 78,25
00E4A:  DATA 30,38
00E4C:  DATA 4C,58
00E4E:  DATA 0D,0A
00E50:  DATA 00,00
00E52:  DATA 09,7C
00E54:  DATA 20,4D
00E56:  DATA 49,53
00E58:  DATA 46,20
00E5A:  DATA 7C,20
00E5C:  DATA 45,4E
00E5E:  DATA 56,49
00E60:  DATA 52,4F
00E62:  DATA 20,20
00E64:  DATA 20,20
00E66:  DATA 7C,20
00E68:  DATA 52,65
00E6A:  DATA 73,65
00E6C:  DATA 72,76
00E6E:  DATA 65,20
00E70:  DATA 43,6F
00E72:  DATA 75,6E
00E74:  DATA 74,65
00E76:  DATA 72,31
00E78:  DATA 20,3A
00E7A:  DATA 20,30
00E7C:  DATA 78,25
00E7E:  DATA 30,32
00E80:  DATA 58,0D
00E82:  DATA 0A,00
00E84:  DATA 09,7C
00E86:  DATA 20,4D
00E88:  DATA 49,53
00E8A:  DATA 46,20
00E8C:  DATA 7C,20
00E8E:  DATA 45,4E
00E90:  DATA 56,49
00E92:  DATA 52,4F
00E94:  DATA 20,20
00E96:  DATA 20,20
00E98:  DATA 7C,20
00E9A:  DATA 52,65
00E9C:  DATA 73,65
00E9E:  DATA 72,76
00EA0:  DATA 65,20
00EA2:  DATA 43,6F
00EA4:  DATA 75,6E
00EA6:  DATA 74,65
00EA8:  DATA 72,32
00EAA:  DATA 20,3A
00EAC:  DATA 20,30
00EAE:  DATA 78,25
00EB0:  DATA 30,32
00EB2:  DATA 58,0D
00EB4:  DATA 0A,00
00EB6:  DATA 09,7C
00EB8:  DATA 20,4D
00EBA:  DATA 49,53
00EBC:  DATA 46,20
00EBE:  DATA 7C,20
00EC0:  DATA 49,56
00EC2:  DATA 20,48
00EC4:  DATA 45,41
00EC6:  DATA 44,45
00EC8:  DATA 52,20
00ECA:  DATA 7C,20
00ECC:  DATA 55,73
00ECE:  DATA 65,20
00ED0:  DATA 43,6F
00ED2:  DATA 75,6E
00ED4:  DATA 74,65
00ED6:  DATA 72,20
00ED8:  DATA 20,20
00EDA:  DATA 20,20
00EDC:  DATA 20,3A
00EDE:  DATA 20,30
00EE0:  DATA 78,25
00EE2:  DATA 30,38
00EE4:  DATA 4C,58
00EE6:  DATA 0D,0A
00EE8:  DATA 00,00
00EEA:  DATA 09,7C
00EEC:  DATA 20,4D
00EEE:  DATA 49,53
00EF0:  DATA 46,20
00EF2:  DATA 7C,20
00EF4:  DATA 49,56
00EF6:  DATA 20,48
00EF8:  DATA 45,41
00EFA:  DATA 44,45
00EFC:  DATA 52,20
00EFE:  DATA 7C,20
00F00:  DATA 55,6E
00F02:  DATA 63,6F
00F04:  DATA 70,79
00F06:  DATA 65,64
00F08:  DATA 20,43
00F0A:  DATA 6F,75
00F0C:  DATA 6E,74
00F0E:  DATA 65,72
00F10:  DATA 20,3A
00F12:  DATA 20,30
00F14:  DATA 78,25
00F16:  DATA 30,38
00F18:  DATA 4C,58
00F1A:  DATA 0D,0A
00F1C:  DATA 00,00
00F1E:  DATA 09,7C
00F20:  DATA 20,4D
00F22:  DATA 49,53
00F24:  DATA 46,20
00F26:  DATA 7C,20
00F28:  DATA 49,56
00F2A:  DATA 20,48
00F2C:  DATA 45,41
00F2E:  DATA 44,45
00F30:  DATA 52,20
00F32:  DATA 7C,20
00F34:  DATA 52,65
00F36:  DATA 73,65
00F38:  DATA 72,76
00F3A:  DATA 65,20
00F3C:  DATA 43,6F
00F3E:  DATA 75,6E
00F40:  DATA 74,65
00F42:  DATA 72,31
00F44:  DATA 20,3A
00F46:  DATA 20,30
00F48:  DATA 78,25
00F4A:  DATA 30,32
00F4C:  DATA 58,0D
00F4E:  DATA 0A,00
00F50:  DATA 09,7C
00F52:  DATA 20,4D
00F54:  DATA 49,53
00F56:  DATA 46,20
00F58:  DATA 7C,20
00F5A:  DATA 49,56
00F5C:  DATA 20,48
00F5E:  DATA 45,41
00F60:  DATA 44,45
00F62:  DATA 52,20
00F64:  DATA 7C,20
00F66:  DATA 52,65
00F68:  DATA 73,65
00F6A:  DATA 72,76
00F6C:  DATA 65,20
00F6E:  DATA 43,6F
00F70:  DATA 75,6E
00F72:  DATA 74,65
00F74:  DATA 72,32
00F76:  DATA 20,3A
00F78:  DATA 20,30
00F7A:  DATA 78,25
00F7C:  DATA 30,32
00F7E:  DATA 58,0D
00F80:  DATA 0A,00
00F82:  DATA 09,7C
00F84:  DATA 20,4D
00F86:  DATA 49,53
00F88:  DATA 46,20
00F8A:  DATA 7C,20
00F8C:  DATA 49,56
00F8E:  DATA 20,44
00F90:  DATA 41,54
00F92:  DATA 41,20
00F94:  DATA 20,20
00F96:  DATA 7C,20
00F98:  DATA 55,73
00F9A:  DATA 65,20
00F9C:  DATA 43,6F
00F9E:  DATA 75,6E
00FA0:  DATA 74,65
00FA2:  DATA 72,20
00FA4:  DATA 20,20
00FA6:  DATA 20,20
00FA8:  DATA 20,3A
00FAA:  DATA 20,30
00FAC:  DATA 78,25
00FAE:  DATA 30,38
00FB0:  DATA 4C,58
00FB2:  DATA 0D,0A
00FB4:  DATA 00,00
00FB6:  DATA 09,7C
00FB8:  DATA 20,4D
00FBA:  DATA 49,53
00FBC:  DATA 46,20
00FBE:  DATA 7C,20
00FC0:  DATA 49,56
00FC2:  DATA 20,44
00FC4:  DATA 41,54
00FC6:  DATA 41,20
00FC8:  DATA 20,20
00FCA:  DATA 7C,20
00FCC:  DATA 55,6E
00FCE:  DATA 63,6F
00FD0:  DATA 70,79
00FD2:  DATA 65,64
00FD4:  DATA 20,43
00FD6:  DATA 6F,75
00FD8:  DATA 6E,74
00FDA:  DATA 65,72
00FDC:  DATA 20,3A
00FDE:  DATA 20,30
00FE0:  DATA 78,25
00FE2:  DATA 30,38
00FE4:  DATA 4C,58
00FE6:  DATA 0D,0A
00FE8:  DATA 00,00
00FEA:  DATA 09,7C
00FEC:  DATA 20,4D
00FEE:  DATA 49,53
00FF0:  DATA 46,20
00FF2:  DATA 7C,20
00FF4:  DATA 49,56
00FF6:  DATA 20,44
00FF8:  DATA 41,54
00FFA:  DATA 41,20
00FFC:  DATA 20,20
00FFE:  DATA 7C,20
01000:  DATA 52,65
01002:  DATA 73,65
01004:  DATA 72,76
01006:  DATA 65,20
01008:  DATA 43,6F
0100A:  DATA 75,6E
0100C:  DATA 74,65
0100E:  DATA 72,31
01010:  DATA 20,3A
01012:  DATA 20,30
01014:  DATA 78,25
01016:  DATA 30,32
01018:  DATA 58,0D
0101A:  DATA 0A,00
0101C:  DATA 09,7C
0101E:  DATA 20,4D
01020:  DATA 49,53
01022:  DATA 46,20
01024:  DATA 7C,20
01026:  DATA 49,56
01028:  DATA 20,44
0102A:  DATA 41,54
0102C:  DATA 41,20
0102E:  DATA 20,20
01030:  DATA 7C,20
01032:  DATA 52,65
01034:  DATA 73,65
01036:  DATA 72,76
01038:  DATA 65,20
0103A:  DATA 43,6F
0103C:  DATA 75,6E
0103E:  DATA 74,65
01040:  DATA 72,32
01042:  DATA 20,3A
01044:  DATA 20,30
01046:  DATA 78,25
01048:  DATA 30,32
0104A:  DATA 58,0D
0104C:  DATA 0A,00
0104E:  DATA 09,43
01050:  DATA 6F,6D
01052:  DATA 70,6C
01054:  DATA 65,74
01056:  DATA 65,0D
01058:  DATA 0A,00
0105A:  DATA 43,52
0105C:  DATA 43,20
0105E:  DATA 76,65
01060:  DATA 72,69
01062:  DATA 66,69
01064:  DATA 63,61
01066:  DATA 74,69
01068:  DATA 6F,6E
0106A:  DATA 20,70
0106C:  DATA 61,73
0106E:  DATA 73,65
01070:  DATA 64,20
01072:  DATA 6F,6E
01074:  DATA 20,61
01076:  DATA 74,74
01078:  DATA 65,6D
0107A:  DATA 70,74
0107C:  DATA 20,25
0107E:  DATA 64,0D
01080:  DATA 0A,00
01082:  DATA 45,72
01084:  DATA 72,6F
01086:  DATA 72,3A
01088:  DATA 20,43
0108A:  DATA 52,43
0108C:  DATA 20,76
0108E:  DATA 65,72
01090:  DATA 69,66
01092:  DATA 69,63
01094:  DATA 61,74
01096:  DATA 69,6F
01098:  DATA 6E,20
0109A:  DATA 66,61
0109C:  DATA 69,6C
0109E:  DATA 65,64
010A0:  DATA 20,61
010A2:  DATA 66,74
010A4:  DATA 65,72
010A6:  DATA 20,25
010A8:  DATA 64,20
010AA:  DATA 61,74
010AC:  DATA 74,65
010AE:  DATA 6D,70
010B0:  DATA 74,73
010B2:  DATA 0D,0A
010B4:  DATA 00,00
010B6:  DATA 0D,0A
010B8:  DATA 5F,5F
010BA:  DATA 5F,5F
010BC:  DATA 5F,5F
010BE:  DATA 5F,5F
010C0:  DATA 5F,5F
010C2:  DATA 5F,5F
010C4:  DATA 5F,5F
010C6:  DATA 5F,5F
010C8:  DATA 5F,5F
010CA:  DATA 5F,5F
010CC:  DATA 5F,5F
010CE:  DATA 5F,5F
010D0:  DATA 5F,5F
010D2:  DATA 5F,5F
010D4:  DATA 5F,5F
010D6:  DATA 0D,0A
010D8:  DATA 5F,5F
010DA:  DATA 5F,5F
010DC:  DATA 5F,53
010DE:  DATA 74,61
010E0:  DATA 72,74
010E2:  DATA 20,65
010E4:  DATA 78,65
010E6:  DATA 63,75
010E8:  DATA 74,65
010EA:  DATA 5F,6D
010EC:  DATA 69,73
010EE:  DATA 73,69
010F0:  DATA 6F,6E
010F2:  DATA 5F,5F
010F4:  DATA 5F,5F
010F6:  DATA 5F,0D
010F8:  DATA 0A,0D
010FA:  DATA 0A,00
010FC:  DATA 43,6F
010FE:  DATA 6D,6D
01100:  DATA 61,6E
01102:  DATA 64,20
01104:  DATA 49,44
01106:  DATA 3A,20
01108:  DATA 25,58
0110A:  DATA 0D,0A
0110C:  DATA 0D,0A
0110E:  DATA 00,00
01110:  DATA 09,09
01112:  DATA 2D,3E
01114:  DATA 20,49
01116:  DATA 6E,76
01118:  DATA 61,6C
0111A:  DATA 69,64
0111C:  DATA 20,43
0111E:  DATA 4D,44
01120:  DATA 20,49
01122:  DATA 44,21
01124:  DATA 0D,0A
01126:  DATA 00,00
01128:  DATA 0D,0A
0112A:  DATA 5F,5F
0112C:  DATA 5F,5F
0112E:  DATA 5F,5F
01130:  DATA 45,6E
01132:  DATA 64,20
01134:  DATA 65,78
01136:  DATA 65,63
01138:  DATA 75,74
0113A:  DATA 65,5F
0113C:  DATA 6D,69
0113E:  DATA 73,73
01140:  DATA 69,6F
01142:  DATA 6E,5F
01144:  DATA 5F,5F
01146:  DATA 5F,5F
01148:  DATA 5F,0D
0114A:  DATA 0A,5F
0114C:  DATA 5F,5F
0114E:  DATA 5F,5F
01150:  DATA 5F,5F
01152:  DATA 5F,5F
01154:  DATA 5F,5F
01156:  DATA 5F,5F
01158:  DATA 5F,5F
0115A:  DATA 5F,5F
0115C:  DATA 5F,5F
0115E:  DATA 5F,5F
01160:  DATA 5F,5F
01162:  DATA 5F,5F
01164:  DATA 5F,5F
01166:  DATA 5F,5F
01168:  DATA 5F,5F
0116A:  DATA 0D,0A
0116C:  DATA 00,00
0116E:  DATA 53,74
01170:  DATA 61,72
01172:  DATA 74,20
01174:  DATA 65,78
01176:  DATA 65,63
01178:  DATA 75,74
0117A:  DATA 65,5F
0117C:  DATA 63,6F
0117E:  DATA 6D,6D
01180:  DATA 61,6E
01182:  DATA 64,0D
01184:  DATA 0A,00
01186:  DATA 09,2D
01188:  DATA 3E,20
0118A:  DATA 55,70
0118C:  DATA 6C,69
0118E:  DATA 6E,6B
01190:  DATA 20,63
01192:  DATA 6F,6D
01194:  DATA 6D,61
01196:  DATA 6E,64
01198:  DATA 0D,0A
0119A:  DATA 00,00
0119C:  DATA 09,20
0119E:  DATA 20,20
011A0:  DATA 54,72
011A2:  DATA 61,6E
011A4:  DATA 73,6D
011A6:  DATA 69,74
011A8:  DATA 20,41
011AA:  DATA 63,6B
011AC:  DATA 6E,6F
011AE:  DATA 6C,65
011B0:  DATA 67,64
011B2:  DATA 65,0D
011B4:  DATA 0A,00
011B6:  DATA 09,2D
011B8:  DATA 3E,20
011BA:  DATA 53,74
011BC:  DATA 61,74
011BE:  DATA 75,73
011C0:  DATA 20,63
011C2:  DATA 68,65
011C4:  DATA 63,6B
011C6:  DATA 0D,0A
011C8:  DATA 00,00
011CA:  DATA 09,20
011CC:  DATA 20,20
011CE:  DATA 54,72
011D0:  DATA 61,6E
011D2:  DATA 73,6D
011D4:  DATA 69,74
011D6:  DATA 20,4D
011D8:  DATA 49,53
011DA:  DATA 20,4D
011DC:  DATA 43,55
011DE:  DATA 20,53
011E0:  DATA 74,61
011E2:  DATA 74,75
011E4:  DATA 73,0D
011E6:  DATA 0A,00
011E8:  DATA 66,69
011EA:  DATA 6E,69
011EC:  DATA 73,68
011EE:  DATA 65,64
011F0:  DATA 20,69
011F2:  DATA 6E,20
011F4:  DATA 73,74
011F6:  DATA 61,74
011F8:  DATA 75,73
011FA:  DATA 5F,63
011FC:  DATA 68,65
011FE:  DATA 63,6B
01200:  DATA 0D,0A
01202:  DATA 00,00
01204:  DATA 09,2D
01206:  DATA 3E,20
01208:  DATA 53,4D
0120A:  DATA 46,20
0120C:  DATA 61,76
0120E:  DATA 61,69
01210:  DATA 6C,61
01212:  DATA 62,6C
01214:  DATA 65,20
01216:  DATA 63,68
01218:  DATA 65,63
0121A:  DATA 6B,0D
0121C:  DATA 0A,00
0121E:  DATA 09,20
01220:  DATA 20,20
01222:  DATA 54,72
01224:  DATA 61,6E
01226:  DATA 73,6D
01228:  DATA 69,74
0122A:  DATA 20,41
0122C:  DATA 63,6B
0122E:  DATA 6E,6F
01230:  DATA 77,6C
01232:  DATA 65,64
01234:  DATA 67,65
01236:  DATA 6D,65
01238:  DATA 6E,74
0123A:  DATA 0D,0A
0123C:  DATA 00,00
0123E:  DATA 09,09
01240:  DATA 2D,3E
01242:  DATA 20,64
01244:  DATA 65,6E
01246:  DATA 69,65
01248:  DATA 64,0D
0124A:  DATA 0A,00
0124C:  DATA 09,09
0124E:  DATA 2D,3E
01250:  DATA 20,61
01252:  DATA 6C,6C
01254:  DATA 6F,77
01256:  DATA 65,64
01258:  DATA 0D,0A
0125A:  DATA 00,00
0125C:  DATA 09,09
0125E:  DATA 2D,3E
01260:  DATA 20,64
01262:  DATA 65,71
01264:  DATA 75,65
01266:  DATA 75,65
01268:  DATA 20,4E
0126A:  DATA 55,4C
0126C:  DATA 4C,20
0126E:  DATA 28,62
01270:  DATA 72,65
01272:  DATA 61,6B
01274:  DATA 29,0D
01276:  DATA 0A,00
01278:  DATA 09,09
0127A:  DATA 2D,3E
0127C:  DATA 20,44
0127E:  DATA 65,71
01280:  DATA 75,65
01282:  DATA 75,65
01284:  DATA 64,3A
01286:  DATA 20,66
01288:  DATA 75,6E
0128A:  DATA 63,3D
0128C:  DATA 25,75
0128E:  DATA 20,6D
01290:  DATA 69,73
01292:  DATA 73,69
01294:  DATA 6F,6E
01296:  DATA 3D,25
01298:  DATA 75,20
0129A:  DATA 73,69
0129C:  DATA 7A,65
0129E:  DATA 3D,25
012A0:  DATA 6C,64
012A2:  DATA 20,61
012A4:  DATA 64,64
012A6:  DATA 72,3D
012A8:  DATA 25,6C
012AA:  DATA 64,0D
012AC:  DATA 0A,00
012AE:  DATA 09,09
012B0:  DATA 20,20
012B2:  DATA 20,55
012B4:  DATA 6E,6B
012B6:  DATA 6E,6F
012B8:  DATA 77,6E
012BA:  DATA 20,66
012BC:  DATA 75,6E
012BE:  DATA 63,5F
012C0:  DATA 74,79
012C2:  DATA 70,65
012C4:  DATA 3D,25
012C6:  DATA 75,0D
012C8:  DATA 0A,00
012CA:  DATA 09,09
012CC:  DATA 2D,3E
012CE:  DATA 20,43
012D0:  DATA 6F,6D
012D2:  DATA 70,6C
012D4:  DATA 65,74
012D6:  DATA 65,64
012D8:  DATA 20,25
012DA:  DATA 75,20
012DC:  DATA 6F,70
012DE:  DATA 65,72
012E0:  DATA 61,74
012E2:  DATA 69,6F
012E4:  DATA 6E,73
012E6:  DATA 0D,0A
012E8:  DATA 00,00
012EA:  DATA 53,74
012EC:  DATA 61,72
012EE:  DATA 74,20
012F0:  DATA 4D,4F
012F2:  DATA 44,45
012F4:  DATA 20,44
012F6:  DATA 55,4D
012F8:  DATA 4D,59
012FA:  DATA 0D,0A
012FC:  DATA 00,00
012FE:  DATA 09,4D
01300:  DATA 4F,44
01302:  DATA 45,20
01304:  DATA 20,20
01306:  DATA 20,20
01308:  DATA 3A,20
0130A:  DATA 25,30
0130C:  DATA 32,58
0130E:  DATA 0D,0A
01310:  DATA 00,00
01312:  DATA 09,50
01314:  DATA 61,72
01316:  DATA 61,6D
01318:  DATA 31,20
0131A:  DATA 20,20
0131C:  DATA 3A,20
0131E:  DATA 30,78
01320:  DATA 25,30
01322:  DATA 38,4C
01324:  DATA 58,0D
01326:  DATA 0A,00
01328:  DATA 09,50
0132A:  DATA 61,72
0132C:  DATA 61,6D
0132E:  DATA 32,20
01330:  DATA 20,20
01332:  DATA 3A,20
01334:  DATA 30,78
01336:  DATA 25,30
01338:  DATA 34,4C
0133A:  DATA 58,0D
0133C:  DATA 0A,00
0133E:  DATA 45,6E
01340:  DATA 64,20
01342:  DATA 4D,4F
01344:  DATA 44,45
01346:  DATA 20,44
01348:  DATA 55,4D
0134A:  DATA 4D,59
0134C:  DATA 0D,0A
0134E:  DATA 00,00
01350:  DATA 53,74
01352:  DATA 61,72
01354:  DATA 74,20
01356:  DATA 4D,4F
01358:  DATA 44,45
0135A:  DATA 20,54
0135C:  DATA 45,53
0135E:  DATA 54,20
01360:  DATA 49,56
01362:  DATA 0D,0A
01364:  DATA 00,00
01366:  DATA 09,53
01368:  DATA 77,65
0136A:  DATA 65,70
0136C:  DATA 20,73
0136E:  DATA 74,65
01370:  DATA 70,20
01372:  DATA 3A,20
01374:  DATA 25,75
01376:  DATA 0D,0A
01378:  DATA 00,00
0137A:  DATA 45,6E
0137C:  DATA 64,20
0137E:  DATA 4D,4F
01380:  DATA 44,45
01382:  DATA 20,54
01384:  DATA 45,53
01386:  DATA 54,20
01388:  DATA 49,56
0138A:  DATA 0D,0A
0138C:  DATA 00,00
0138E:  DATA 53,74
01390:  DATA 61,72
01392:  DATA 74,20
01394:  DATA 4D,4F
01396:  DATA 44,45
01398:  DATA 20,4D
0139A:  DATA 45,41
0139C:  DATA 53,20
0139E:  DATA 49,56
013A0:  DATA 0D,0A
013A2:  DATA 00,00
013A4:  DATA 09,49
013A6:  DATA 44,3A
013A8:  DATA 20,25
013AA:  DATA 30,32
013AC:  DATA 58,0D
013AE:  DATA 0A,00
013B0:  DATA 09,53
013B2:  DATA 6C,65
013B4:  DATA 65,70
013B6:  DATA 20,54
013B8:  DATA 69,6D
013BA:  DATA 65,3A
013BC:  DATA 20,25
013BE:  DATA 30,34
013C0:  DATA 4C,58
013C2:  DATA 20,6D
013C4:  DATA 73,0D
013C6:  DATA 0A,00
013C8:  DATA 09,43
013CA:  DATA 75,72
013CC:  DATA 72,65
013CE:  DATA 6E,74
013D0:  DATA 20,54
013D2:  DATA 68,72
013D4:  DATA 65,73
013D6:  DATA 68,6F
013D8:  DATA 6C,64
013DA:  DATA 3A,20
013DC:  DATA 25,30
013DE:  DATA 34,4C
013E0:  DATA 58,20
013E2:  DATA 6D,41
013E4:  DATA 0D,0A
013E6:  DATA 00,00
013E8:  DATA 09,50
013EA:  DATA 44,20
013EC:  DATA 54,68
013EE:  DATA 72,65
013F0:  DATA 73,68
013F2:  DATA 6F,6C
013F4:  DATA 64,3A
013F6:  DATA 20,25
013F8:  DATA 30,34
013FA:  DATA 4C,58
013FC:  DATA 20,6D
013FE:  DATA 41,0D
01400:  DATA 0A,00
01402:  DATA 09,43
01404:  DATA 75,72
01406:  DATA 72,65
01408:  DATA 6E,74
0140A:  DATA 20,4C
0140C:  DATA 69,6D
0140E:  DATA 69,74
01410:  DATA 3A,20
01412:  DATA 25,30
01414:  DATA 34,4C
01416:  DATA 58,20
01418:  DATA 6D,41
0141A:  DATA 0D,0A
0141C:  DATA 00,00
0141E:  DATA 09,4D
01420:  DATA 65,61
01422:  DATA 73,75
01424:  DATA 72,65
01426:  DATA 6D,65
01428:  DATA 6E,74
0142A:  DATA 20,54
0142C:  DATA 69,6D
0142E:  DATA 65,3A
01430:  DATA 20,25
01432:  DATA 30,34
01434:  DATA 4C,58
01436:  DATA 20,73
01438:  DATA 0D,0A
0143A:  DATA 00,00
0143C:  DATA 09,49
0143E:  DATA 73,20
01440:  DATA 46,69
01442:  DATA 6E,69
01444:  DATA 73,68
01446:  DATA 65,64
01448:  DATA 3A,20
0144A:  DATA 25,75
0144C:  DATA 0D,0A
0144E:  DATA 00,00
01450:  DATA 45,6E
01452:  DATA 71,75
01454:  DATA 65,75
01456:  DATA 65,20
01458:  DATA 46,6C
0145A:  DATA 61,73
0145C:  DATA 68,20
0145E:  DATA 4F,70
01460:  DATA 65,72
01462:  DATA 61,74
01464:  DATA 69,6F
01466:  DATA 6E,0D
01468:  DATA 0A,00
0146A:  DATA 4D,69
0146C:  DATA 73,73
0146E:  DATA 69,6F
01470:  DATA 6E,20
01472:  DATA 49,44
01474:  DATA 3A,20
01476:  DATA 20,20
01478:  DATA 25,30
0147A:  DATA 32,58
0147C:  DATA 0D,0A
0147E:  DATA 00,00
01480:  DATA 46,75
01482:  DATA 6E,63
01484:  DATA 74,69
01486:  DATA 6F,6E
01488:  DATA 20,54
0148A:  DATA 79,70
0148C:  DATA 65,3A
0148E:  DATA 25,30
01490:  DATA 32,58
01492:  DATA 0D,0A
01494:  DATA 00,00
01496:  DATA 57,72
01498:  DATA 69,74
0149A:  DATA 65,20
0149C:  DATA 4D,6F
0149E:  DATA 64,65
014A0:  DATA 3A,20
014A2:  DATA 20,20
014A4:  DATA 25,30
014A6:  DATA 32,58
014A8:  DATA 0D,0A
014AA:  DATA 00,00
014AC:  DATA 53,6F
014AE:  DATA 75,72
014B0:  DATA 63,65
014B2:  DATA 20,54
014B4:  DATA 79,70
014B6:  DATA 65,3A
014B8:  DATA 20,20
014BA:  DATA 25,30
014BC:  DATA 32,58
014BE:  DATA 0D,0A
014C0:  DATA 00,00
014C2:  DATA 53,74
014C4:  DATA 61,72
014C6:  DATA 74,20
014C8:  DATA 41,64
014CA:  DATA 64,72
014CC:  DATA 65,73
014CE:  DATA 73,3A
014D0:  DATA 25,30
014D2:  DATA 34,58
014D4:  DATA 0D,0A
014D6:  DATA 00,00
014D8:  DATA 53,69
014DA:  DATA 7A,65
014DC:  DATA 3A,20
014DE:  DATA 20,20
014E0:  DATA 20,20
014E2:  DATA 20,20
014E4:  DATA 20,20
014E6:  DATA 25,30
014E8:  DATA 34,58
014EA:  DATA 0D,0A
014EC:  DATA 00,00
014EE:  DATA 45,6E
014F0:  DATA 64,20
014F2:  DATA 4D,4F
014F4:  DATA 44,45
014F6:  DATA 20,4D
014F8:  DATA 45,41
014FA:  DATA 53,20
014FC:  DATA 49,56
014FE:  DATA 20,6D
01500:  DATA 69,73
01502:  DATA 73,69
01504:  DATA 6F,6E
01506:  DATA 0D,0A
01508:  DATA 00,00
0150A:  DATA 53,74
0150C:  DATA 61,72
0150E:  DATA 74,20
01510:  DATA 46,6C
01512:  DATA 61,73
01514:  DATA 68,20
01516:  DATA 45,72
01518:  DATA 61,73
0151A:  DATA 65,20
0151C:  DATA 41,6C
0151E:  DATA 6C,0D
01520:  DATA 0A,00
01522:  DATA 45,6E
01524:  DATA 64,20
01526:  DATA 46,6C
01528:  DATA 61,73
0152A:  DATA 68,20
0152C:  DATA 45,72
0152E:  DATA 61,73
01530:  DATA 65,20
01532:  DATA 41,6C
01534:  DATA 6C,0D
01536:  DATA 0A,00
01538:  DATA 53,74
0153A:  DATA 61,72
0153C:  DATA 74,20
0153E:  DATA 46,6C
01540:  DATA 61,73
01542:  DATA 68,20
01544:  DATA 45,72
01546:  DATA 61,73
01548:  DATA 65,20
0154A:  DATA 31,20
0154C:  DATA 53,65
0154E:  DATA 63,74
01550:  DATA 6F,72
01552:  DATA 0D,0A
01554:  DATA 00,00
01556:  DATA 09,53
01558:  DATA 65,63
0155A:  DATA 74,6F
0155C:  DATA 72,20
0155E:  DATA 41,64
01560:  DATA 64,72
01562:  DATA 65,73
01564:  DATA 73,3A
01566:  DATA 20,30
01568:  DATA 78,25
0156A:  DATA 30,38
0156C:  DATA 4C,58
0156E:  DATA 0D,0A
01570:  DATA 00,00
01572:  DATA 45,6E
01574:  DATA 64,20
01576:  DATA 46,6C
01578:  DATA 61,73
0157A:  DATA 68,20
0157C:  DATA 45,72
0157E:  DATA 61,73
01580:  DATA 65,20
01582:  DATA 31,20
01584:  DATA 53,65
01586:  DATA 63,74
01588:  DATA 6F,72
0158A:  DATA 0D,0A
0158C:  DATA 00,00
0158E:  DATA 53,74
01590:  DATA 61,72
01592:  DATA 74,20
01594:  DATA 46,6C
01596:  DATA 61,73
01598:  DATA 68,20
0159A:  DATA 43,6F
0159C:  DATA 70,79
0159E:  DATA 20,31
015A0:  DATA 20,53
015A2:  DATA 65,63
015A4:  DATA 74,6F
015A6:  DATA 72,0D
015A8:  DATA 0A,00
015AA:  DATA 09,53
015AC:  DATA 75,62
015AE:  DATA 73,65
015B0:  DATA 63,74
015B2:  DATA 6F,72
015B4:  DATA 20,41
015B6:  DATA 64,64
015B8:  DATA 72,65
015BA:  DATA 73,73
015BC:  DATA 3A,20
015BE:  DATA 30,78
015C0:  DATA 25,30
015C2:  DATA 38,4C
015C4:  DATA 58,0D
015C6:  DATA 0A,00
015C8:  DATA 45,6E
015CA:  DATA 64,20
015CC:  DATA 46,6C
015CE:  DATA 61,73
015D0:  DATA 68,20
015D2:  DATA 43,6F
015D4:  DATA 70,79
015D6:  DATA 20,31
015D8:  DATA 20,53
015DA:  DATA 65,63
015DC:  DATA 74,6F
015DE:  DATA 72,0D
015E0:  DATA 0A,00
015E2:  DATA 53,74
015E4:  DATA 61,72
015E6:  DATA 74,20
015E8:  DATA 46,6C
015EA:  DATA 61,73
015EC:  DATA 68,20
015EE:  DATA 45,72
015F0:  DATA 61,73
015F2:  DATA 65,20
015F4:  DATA 36,34
015F6:  DATA 6B,42
015F8:  DATA 79,74
015FA:  DATA 65,20
015FC:  DATA 53,75
015FE:  DATA 62,73
01600:  DATA 65,63
01602:  DATA 74,6F
01604:  DATA 72,0D
01606:  DATA 0A,00
01608:  DATA 09,53
0160A:  DATA 75,62
0160C:  DATA 73,65
0160E:  DATA 63,74
01610:  DATA 6F,72
01612:  DATA 20,41
01614:  DATA 64,64
01616:  DATA 72,65
01618:  DATA 73,73
0161A:  DATA 3A,20
0161C:  DATA 30,78
0161E:  DATA 25,30
01620:  DATA 38,4C
01622:  DATA 58,0D
01624:  DATA 0A,00
01626:  DATA 45,6E
01628:  DATA 64,20
0162A:  DATA 46,6C
0162C:  DATA 61,73
0162E:  DATA 68,20
01630:  DATA 45,72
01632:  DATA 61,73
01634:  DATA 65,20
01636:  DATA 36,34
01638:  DATA 6B,42
0163A:  DATA 79,74
0163C:  DATA 65,20
0163E:  DATA 53,75
01640:  DATA 62,73
01642:  DATA 65,63
01644:  DATA 74,6F
01646:  DATA 72,0D
01648:  DATA 0A,00
0164A:  DATA 53,74
0164C:  DATA 61,72
0164E:  DATA 74,20
01650:  DATA 46,6C
01652:  DATA 61,73
01654:  DATA 68,20
01656:  DATA 57,72
01658:  DATA 69,74
0165A:  DATA 65,20
0165C:  DATA 44,65
0165E:  DATA 6D,6F
01660:  DATA 0D,0A
01662:  DATA 00,00
01664:  DATA 09,4D
01666:  DATA 4F,44
01668:  DATA 45,20
0166A:  DATA 20,20
0166C:  DATA 20,20
0166E:  DATA 3A,20
01670:  DATA 25,30
01672:  DATA 32,58
01674:  DATA 0D,0A
01676:  DATA 00,00
01678:  DATA 09,41
0167A:  DATA 64,64
0167C:  DATA 72,65
0167E:  DATA 73,73
01680:  DATA 20,20
01682:  DATA 3A,20
01684:  DATA 30,78
01686:  DATA 25,30
01688:  DATA 38,4C
0168A:  DATA 58,0D
0168C:  DATA 0A,00
0168E:  DATA 09,50
01690:  DATA 61,63
01692:  DATA 6B,65
01694:  DATA 74,4E
01696:  DATA 75,6D
01698:  DATA 3A,20
0169A:  DATA 30,78
0169C:  DATA 25,30
0169E:  DATA 34,4C
016A0:  DATA 58,0D
016A2:  DATA 0A,00
016A4:  DATA 57,72
016A6:  DATA 69,74
016A8:  DATA 65,20
016AA:  DATA 44,61
016AC:  DATA 74,61
016AE:  DATA 0D,0A
016B0:  DATA 00,00
016B2:  DATA 45,6E
016B4:  DATA 64,20
016B6:  DATA 46,6C
016B8:  DATA 61,73
016BA:  DATA 68,20
016BC:  DATA 57,72
016BE:  DATA 69,74
016C0:  DATA 65,20
016C2:  DATA 44,65
016C4:  DATA 6D,6F
016C6:  DATA 0D,0A
016C8:  DATA 00,00
016CA:  DATA 53,74
016CC:  DATA 61,72
016CE:  DATA 74,20
016D0:  DATA 46,6C
016D2:  DATA 61,73
016D4:  DATA 68,20
016D6:  DATA 57,72
016D8:  DATA 69,74
016DA:  DATA 65,20
016DC:  DATA 34,6B
016DE:  DATA 42,79
016E0:  DATA 74,65
016E2:  DATA 20,53
016E4:  DATA 75,62
016E6:  DATA 73,65
016E8:  DATA 63,74
016EA:  DATA 6F,72
016EC:  DATA 0D,0A
016EE:  DATA 00,00
016F0:  DATA 45,6E
016F2:  DATA 64,20
016F4:  DATA 46,6C
016F6:  DATA 61,73
016F8:  DATA 68,20
016FA:  DATA 57,72
016FC:  DATA 69,74
016FE:  DATA 65,20
01700:  DATA 34,6B
01702:  DATA 42,79
01704:  DATA 74,65
01706:  DATA 20,53
01708:  DATA 75,62
0170A:  DATA 73,65
0170C:  DATA 63,74
0170E:  DATA 6F,72
01710:  DATA 0D,0A
01712:  DATA 00,00
01714:  DATA 53,74
01716:  DATA 61,72
01718:  DATA 74,20
0171A:  DATA 46,6C
0171C:  DATA 61,73
0171E:  DATA 68,20
01720:  DATA 52,65
01722:  DATA 61,64
01724:  DATA 0D,0A
01726:  DATA 00,00
01728:  DATA 09,4D
0172A:  DATA 4F,44
0172C:  DATA 45,20
0172E:  DATA 20,20
01730:  DATA 20,20
01732:  DATA 3A,20
01734:  DATA 25,30
01736:  DATA 32,58
01738:  DATA 0D,0A
0173A:  DATA 00,00
0173C:  DATA 09,41
0173E:  DATA 64,64
01740:  DATA 72,65
01742:  DATA 73,73
01744:  DATA 20,20
01746:  DATA 3A,20
01748:  DATA 30,78
0174A:  DATA 25,30
0174C:  DATA 38,4C
0174E:  DATA 58,0D
01750:  DATA 0A,00
01752:  DATA 09,50
01754:  DATA 61,63
01756:  DATA 6B,65
01758:  DATA 74,4E
0175A:  DATA 75,6D
0175C:  DATA 3A,20
0175E:  DATA 30,78
01760:  DATA 25,30
01762:  DATA 34,4C
01764:  DATA 58,0D
01766:  DATA 0A,00
01768:  DATA 52,45
0176A:  DATA 41,44
0176C:  DATA 20,44
0176E:  DATA 41,54
01770:  DATA 41,0D
01772:  DATA 0A,00
01774:  DATA 4D,69
01776:  DATA 73,73
01778:  DATA 69,6F
0177A:  DATA 6E,20
0177C:  DATA 46,6C
0177E:  DATA 61,73
01780:  DATA 68,20
01782:  DATA 69,73
01784:  DATA 20,6E
01786:  DATA 6F,74
01788:  DATA 20,63
0178A:  DATA 6F,6E
0178C:  DATA 6E,65
0178E:  DATA 63,74
01790:  DATA 65,64
01792:  DATA 0D,0A
01794:  DATA 00,00
01796:  DATA 45,6E
01798:  DATA 64,20
0179A:  DATA 46,6C
0179C:  DATA 61,73
0179E:  DATA 68,20
017A0:  DATA 52,65
017A2:  DATA 61,64
017A4:  DATA 0D,0A
017A6:  DATA 00,00
017A8:  DATA 53,74
017AA:  DATA 61,72
017AC:  DATA 74,20
017AE:  DATA 46,6C
017B0:  DATA 61,73
017B2:  DATA 68,20
017B4:  DATA 52,65
017B6:  DATA 61,64
017B8:  DATA 20,41
017BA:  DATA 64,64
017BC:  DATA 72,65
017BE:  DATA 73,73
017C0:  DATA 0D,0A
017C2:  DATA 00,00
017C4:  DATA 52,65
017C6:  DATA 61,64
017C8:  DATA 20,44
017CA:  DATA 61,74
017CC:  DATA 61,3A
017CE:  DATA 20,25
017D0:  DATA 30,32
017D2:  DATA 58,20
017D4:  DATA 25,30
017D6:  DATA 32,58
017D8:  DATA 20,25
017DA:  DATA 30,32
017DC:  DATA 58,20
017DE:  DATA 25,30
017E0:  DATA 32,58
017E2:  DATA 0D,0A
017E4:  DATA 00,00
017E6:  DATA 45,6E
017E8:  DATA 64,20
017EA:  DATA 46,6C
017EC:  DATA 61,73
017EE:  DATA 68,20
017F0:  DATA 52,65
017F2:  DATA 61,64
017F4:  DATA 20,41
017F6:  DATA 64,64
017F8:  DATA 72,65
017FA:  DATA 73,73
017FC:  DATA 0D,0A
017FE:  DATA 00,00
01800:  DATA 53,74
01802:  DATA 61,72
01804:  DATA 74,20
01806:  DATA 46,6C
01808:  DATA 61,73
0180A:  DATA 68,20
0180C:  DATA 45,72
0180E:  DATA 61,73
01810:  DATA 65,20
01812:  DATA 61,6E
01814:  DATA 64,20
01816:  DATA 52,65
01818:  DATA 73,65
0181A:  DATA 74,0D
0181C:  DATA 0A,00
0181E:  DATA 45,6E
01820:  DATA 64,20
01822:  DATA 46,6C
01824:  DATA 61,73
01826:  DATA 68,20
01828:  DATA 45,72
0182A:  DATA 61,73
0182C:  DATA 65,20
0182E:  DATA 61,6E
01830:  DATA 64,20
01832:  DATA 52,65
01834:  DATA 73,65
01836:  DATA 74,0D
01838:  DATA 0A,00
0183A:  DATA 53,74
0183C:  DATA 61,72
0183E:  DATA 74,20
01840:  DATA 46,6C
01842:  DATA 61,73
01844:  DATA 68,20
01846:  DATA 53,4D
01848:  DATA 46,20
0184A:  DATA 43,6F
0184C:  DATA 70,79
0184E:  DATA 0D,0A
01850:  DATA 00,00
01852:  DATA 45,6E
01854:  DATA 64,20
01856:  DATA 46,6C
01858:  DATA 61,73
0185A:  DATA 68,20
0185C:  DATA 53,4D
0185E:  DATA 46,20
01860:  DATA 43,6F
01862:  DATA 70,79
01864:  DATA 0D,0A
01866:  DATA 00,00
01868:  DATA 53,74
0186A:  DATA 61,72
0186C:  DATA 74,20
0186E:  DATA 46,6C
01870:  DATA 61,73
01872:  DATA 68,20
01874:  DATA 53,4D
01876:  DATA 46,20
01878:  DATA 52,65
0187A:  DATA 61,64
0187C:  DATA 0D,0A
0187E:  DATA 00,00
01880:  DATA 52,65
01882:  DATA 61,64
01884:  DATA 20,44
01886:  DATA 61,74
01888:  DATA 61,3A
0188A:  DATA 20,00
0188C:  DATA 0D,0A
0188E:  DATA 45,6E
01890:  DATA 64,20
01892:  DATA 46,6C
01894:  DATA 61,73
01896:  DATA 68,20
01898:  DATA 53,4D
0189A:  DATA 46,20
0189C:  DATA 52,65
0189E:  DATA 61,64
018A0:  DATA 0D,0A
018A2:  DATA 00,00
018A4:  DATA 53,74
018A6:  DATA 61,72
018A8:  DATA 74,20
018AA:  DATA 46,6C
018AC:  DATA 61,73
018AE:  DATA 68,20
018B0:  DATA 53,4D
018B2:  DATA 46,20
018B4:  DATA 45,72
018B6:  DATA 61,73
018B8:  DATA 65,0D
018BA:  DATA 0A,00
018BC:  DATA 45,6E
018BE:  DATA 64,20
018C0:  DATA 46,6C
018C2:  DATA 61,73
018C4:  DATA 68,20
018C6:  DATA 53,4D
018C8:  DATA 46,20
018CA:  DATA 45,72
018CC:  DATA 61,73
018CE:  DATA 65,0D
018D0:  DATA 0A,00
018D2:  DATA 53,74
018D4:  DATA 61,72
018D6:  DATA 74,20
018D8:  DATA 46,6C
018DA:  DATA 61,73
018DC:  DATA 68,20
018DE:  DATA 41,64
018E0:  DATA 64,72
018E2:  DATA 65,73
018E4:  DATA 73,20
018E6:  DATA 52,65
018E8:  DATA 73,65
018EA:  DATA 74,0D
018EC:  DATA 0A,00
018EE:  DATA 45,6E
018F0:  DATA 64,20
018F2:  DATA 46,6C
018F4:  DATA 61,73
018F6:  DATA 68,20
018F8:  DATA 41,64
018FA:  DATA 64,72
018FC:  DATA 65,73
018FE:  DATA 73,20
01900:  DATA 52,65
01902:  DATA 73,65
01904:  DATA 74,0D
01906:  DATA 0A,00
01908:  DATA 53,4D
0190A:  DATA 46,20
0190C:  DATA 69,73
0190E:  DATA 20,6E
01910:  DATA 6F,74
01912:  DATA 20,63
01914:  DATA 6F,6E
01916:  DATA 6E,65
01918:  DATA 63,74
0191A:  DATA 65,64
0191C:  DATA 0D,0A
0191E:  DATA 00,00
01920:  DATA 53,74
01922:  DATA 61,72
01924:  DATA 74,20
01926:  DATA 46,6C
01928:  DATA 61,73
0192A:  DATA 68,20
0192C:  DATA 53,4D
0192E:  DATA 46,20
01930:  DATA 52,65
01932:  DATA 61,64
01934:  DATA 20,46
01936:  DATA 6F,72
01938:  DATA 63,65
0193A:  DATA 0D,0A
0193C:  DATA 00,00
0193E:  DATA 09,41
01940:  DATA 64,64
01942:  DATA 72,65
01944:  DATA 73,73
01946:  DATA 20,20
01948:  DATA 3A,20
0194A:  DATA 30,78
0194C:  DATA 25,30
0194E:  DATA 38,4C
01950:  DATA 58,0D
01952:  DATA 0A,00
01954:  DATA 09,50
01956:  DATA 61,63
01958:  DATA 6B,65
0195A:  DATA 74,4E
0195C:  DATA 75,6D
0195E:  DATA 3A,20
01960:  DATA 30,78
01962:  DATA 25,30
01964:  DATA 34,4C
01966:  DATA 58,0D
01968:  DATA 0A,00
0196A:  DATA 72,65
0196C:  DATA 61,64
0196E:  DATA 20,64
01970:  DATA 61,74
01972:  DATA 61,0D
01974:  DATA 0A,00
01976:  DATA 0D,0A
01978:  DATA 45,6E
0197A:  DATA 64,20
0197C:  DATA 46,6C
0197E:  DATA 61,73
01980:  DATA 68,20
01982:  DATA 53,4D
01984:  DATA 46,20
01986:  DATA 52,65
01988:  DATA 61,64
0198A:  DATA 20,46
0198C:  DATA 6F,72
0198E:  DATA 63,65
01990:  DATA 0D,0A
01992:  DATA 00,00
01994:  DATA 53,74
01996:  DATA 61,72
01998:  DATA 74,20
0199A:  DATA 53,4D
0199C:  DATA 46,20
0199E:  DATA 45,72
019A0:  DATA 61,73
019A2:  DATA 65,20
019A4:  DATA 41,6C
019A6:  DATA 6C,0D
019A8:  DATA 0A,00
019AA:  DATA 45,6E
019AC:  DATA 64,20
019AE:  DATA 53,4D
019B0:  DATA 46,20
019B2:  DATA 45,72
019B4:  DATA 61,73
019B6:  DATA 65,20
019B8:  DATA 41,6C
019BA:  DATA 6C,0D
019BC:  DATA 0A,00
019BE:  DATA 53,74
019C0:  DATA 61,72
019C2:  DATA 74,20
019C4:  DATA 53,4D
019C6:  DATA 46,20
019C8:  DATA 52,65
019CA:  DATA 73,65
019CC:  DATA 74,0D
019CE:  DATA 0A,00
019D0:  DATA 45,6E
019D2:  DATA 64,20
019D4:  DATA 53,4D
019D6:  DATA 46,20
019D8:  DATA 52,65
019DA:  DATA 73,65
019DC:  DATA 74,0D
019DE:  DATA 0A,00
019E0:  DATA 0D,0A
019E2:  DATA 0D,0A
019E4:  DATA 0D,0A
019E6:  DATA 3D,3D
019E8:  DATA 3D,3D
019EA:  DATA 3D,3D
019EC:  DATA 3D,3D
019EE:  DATA 3D,3D
019F0:  DATA 3D,3D
019F2:  DATA 3D,3D
019F4:  DATA 3D,3D
019F6:  DATA 3D,3D
019F8:  DATA 3D,3D
019FA:  DATA 3D,3D
019FC:  DATA 3D,3D
019FE:  DATA 3D,3D
01A00:  DATA 3D,3D
01A02:  DATA 3D,3D
01A04:  DATA 3D,3D
01A06:  DATA 3D,3D
01A08:  DATA 3D,3D
01A0A:  DATA 3D,3D
01A0C:  DATA 3D,3D
01A0E:  DATA 3D,3D
01A10:  DATA 3D,3D
01A12:  DATA 3D,3D
01A14:  DATA 3D,3D
01A16:  DATA 3D,3D
01A18:  DATA 3D,3D
01A1A:  DATA 3D,3D
01A1C:  DATA 3D,3D
01A1E:  DATA 3D,3D
01A20:  DATA 3D,3D
01A22:  DATA 0D,0A
01A24:  DATA 00,00
01A26:  DATA 54,68
01A28:  DATA 69,73
01A2A:  DATA 20,69
01A2C:  DATA 73,20
01A2E:  DATA 4D,4F
01A30:  DATA 4D,49
01A32:  DATA 4A,49
01A34:  DATA 20,43
01A36:  DATA 49,47
01A38:  DATA 53,20
01A3A:  DATA 50,49
01A3C:  DATA 43,20
01A3E:  DATA 42,42
01A40:  DATA 4D,20
01A42:  DATA 66,6F
01A44:  DATA 72,20
01A46:  DATA 4D,49
01A48:  DATA 53,37
01A4A:  DATA 5F,42
01A4C:  DATA 42,4D
01A4E:  DATA 34,2E
01A50:  DATA 0D,0A
01A52:  DATA 00,00
01A54:  DATA 4C,61
01A56:  DATA 73,74
01A58:  DATA 20,75
01A5A:  DATA 70,64
01A5C:  DATA 61,74
01A5E:  DATA 65,64
01A60:  DATA 20,6F
01A62:  DATA 6E,20
01A64:  DATA 25,73
01A66:  DATA 20,25
01A68:  DATA 73,2C
01A6A:  DATA 20,62
01A6C:  DATA 79,20
01A6E:  DATA 49,6E
01A70:  DATA 6F,75
01A72:  DATA 65,2E
01A74:  DATA 0D,0A
01A76:  DATA 0D,0A
01A78:  DATA 00,00
01A7A:  DATA 31,34
01A7C:  DATA 2D,41
01A7E:  DATA 75,67
01A80:  DATA 2D,32
01A82:  DATA 35,00
01A84:  DATA 31,31
01A86:  DATA 3A,34
01A88:  DATA 32,3A
01A8A:  DATA 35,31
01A8C:  DATA 00,00
01A8E:  DATA 5F,5F
01A90:  DATA 5F,5F
01A92:  DATA 43,49
01A94:  DATA 47,53
01A96:  DATA 20,50
01A98:  DATA 49,43
01A9A:  DATA 20,53
01A9C:  DATA 74,61
01A9E:  DATA 72,74
01AA0:  DATA 20,4F
01AA2:  DATA 70,65
01AA4:  DATA 72,61
01AA6:  DATA 74,69
01AA8:  DATA 6F,6E
01AAA:  DATA 5F,5F
01AAC:  DATA 5F,5F
01AAE:  DATA 5F,0D
01AB0:  DATA 0A,0D
01AB2:  DATA 0A,00
01AB4:  DATA 77,61
01AB6:  DATA 69,74
01AB8:  DATA 69,6E
01ABA:  DATA 67,20
01ABC:  DATA 66,6F
01ABE:  DATA 72,20
01AC0:  DATA 42,4F
01AC2:  DATA 53,53
01AC4:  DATA 20,50
01AC6:  DATA 49,43
01AC8:  DATA 20,63
01ACA:  DATA 6F,6D
01ACC:  DATA 6D,61
01ACE:  DATA 6E,64
01AD0:  DATA 00,00
01AD2:  DATA 0D,0A
01AD4:  DATA 77,61
01AD6:  DATA 69,74
01AD8:  DATA 69,6E
01ADA:  DATA 67,20
01ADC:  DATA 66,6F
01ADE:  DATA 72,20
01AE0:  DATA 42,4F
01AE2:  DATA 53,53
01AE4:  DATA 20,50
01AE6:  DATA 49,43
01AE8:  DATA 20,63
01AEA:  DATA 6F,6D
01AEC:  DATA 6D,61
01AEE:  DATA 6E,64
01AF0:  DATA 00,00
01AF2:  DATA 0D,0A
01AF4:  DATA 0D,0A
01AF6:  DATA 3D,3D
01AF8:  DATA 3D,3D
01AFA:  DATA 3D,3D
01AFC:  DATA 0D,0A
01AFE:  DATA 0D,0A
01B00:  DATA 46,69
01B02:  DATA 6E,69
01B04:  DATA 73,68
01B06:  DATA 65,64
01B08:  DATA 20,70
01B0A:  DATA 72,6F
01B0C:  DATA 63,65
01B0E:  DATA 73,73
01B10:  DATA 2E,0D
01B12:  DATA 0A,57
01B14:  DATA 61,69
01B16:  DATA 74,20
01B18:  DATA 66,6F
01B1A:  DATA 72,20
01B1C:  DATA 42,4F
01B1E:  DATA 53,53
01B20:  DATA 20,50
01B22:  DATA 49,43
01B24:  DATA 20,74
01B26:  DATA 75,72
01B28:  DATA 6E,20
01B2A:  DATA 6F,66
01B2C:  DATA 66,20
01B2E:  DATA 6D,65
01B30:  DATA 00,00
01B32:  DATA 45,6E
01B34:  DATA 64,20
01B36:  DATA 6D,61
01B38:  DATA 69,6E
01B3A:  DATA 0D,0A
01B3C:  DATA 00,00
*
01BBE:  TBLRD*+
01BC0:  MOVF   FF5,F
01BC2:  BTFSC  FD8.2
01BC4:  GOTO   1BEC
01BC8:  MOVFF  FF6,A16
01BCC:  MOVFF  FF7,A17
01BD0:  MOVFF  FF8,A18
01BD4:  MOVFF  FF5,AAD
01BD8:  CALL   1B6C
01BDC:  MOVFF  A16,FF6
01BE0:  MOVFF  A17,FF7
01BE4:  MOVFF  A18,FF8
01BE8:  GOTO   1BBE
01BEC:  RETURN 0
01BEE:  TBLRD*+
01BF0:  MOVFF  FF6,9C3
01BF4:  MOVFF  FF7,9C4
01BF8:  MOVFF  FF8,9C5
01BFC:  MOVFF  FF5,AAD
01C00:  CALL   1B6C
01C04:  MOVFF  9C3,FF6
01C08:  MOVFF  9C4,FF7
01C0C:  MOVFF  9C5,FF8
01C10:  MOVLB  9
01C12:  DECFSZ xC2,F
01C14:  BRA    1C1A
01C16:  BRA    1C20
01C18:  MOVLB  0
01C1A:  MOVLB  0
01C1C:  GOTO   1BEE
01C20:  MOVLB  0
01C22:  RETURN 0
*
01E42:  MOVLB  2
01E44:  BTFSS  x65.7
01E46:  BRA    1E4E
01E48:  MOVLB  0
01E4A:  GOTO   1E7E
01E4E:  MOVLW  0F
01E50:  MOVWF  00
01E52:  SWAPF  x64,W
01E54:  ANDWF  00,F
01E56:  MOVLW  0A
01E58:  SUBWF  00,W
01E5A:  BTFSS  FD8.0
01E5C:  BRA    1E64
01E5E:  MOVLB  0
01E60:  GOTO   1E6E
01E64:  MOVLW  30
01E66:  ADDWF  00,F
01E68:  MOVLB  0
01E6A:  GOTO   1E76
01E6E:  MOVLB  2
01E70:  MOVF   x65,W
01E72:  ADDWF  00,F
01E74:  MOVLB  0
01E76:  MOVFF  00,AAD
01E7A:  CALL   1B6C
01E7E:  MOVLW  0F
01E80:  MOVLB  2
01E82:  ANDWF  x64,F
01E84:  MOVLW  0A
01E86:  SUBWF  x64,W
01E88:  BTFSS  FD8.0
01E8A:  BRA    1E92
01E8C:  MOVLB  0
01E8E:  GOTO   1E9A
01E92:  MOVLW  30
01E94:  MOVLB  0
01E96:  GOTO   1EA2
01E9A:  MOVLB  2
01E9C:  BCF    x65.7
01E9E:  MOVF   x65,W
01EA0:  MOVLB  0
01EA2:  MOVLB  2
01EA4:  ADDWF  x64,F
01EA6:  MOVFF  264,AAD
01EAA:  MOVLB  0
01EAC:  CALL   1B6C
01EB0:  RETURN 0
*
02358:  MOVLB  A
0235A:  MOVF   x74,W
0235C:  ANDLW  07
0235E:  MOVWF  00
02360:  RRCF   x74,W
02362:  MOVWF  01
02364:  RRCF   01,F
02366:  RRCF   01,F
02368:  MOVLW  1F
0236A:  ANDWF  01,F
0236C:  MOVF   01,W
0236E:  ADDWF  x76,W
02370:  MOVWF  FE9
02372:  MOVLW  00
02374:  ADDWFC x77,W
02376:  MOVWF  FEA
02378:  CLRF   01
0237A:  INCF   01,F
0237C:  INCF   00,F
0237E:  MOVLB  0
02380:  GOTO   2386
02384:  RLCF   01,F
02386:  DECFSZ 00,F
02388:  GOTO   2384
0238C:  MOVLB  A
0238E:  MOVF   x75,F
02390:  BTFSS  FD8.2
02392:  BRA    239A
02394:  MOVLB  0
02396:  GOTO   23A4
0239A:  MOVF   01,W
0239C:  IORWF  FEF,F
0239E:  MOVLB  0
023A0:  GOTO   23AA
023A4:  COMF   01,F
023A6:  MOVF   01,W
023A8:  ANDWF  FEF,F
023AA:  RETURN 0
*
027A0:  TSTFSZ 01
027A2:  GOTO   27B0
027A6:  TSTFSZ 02
027A8:  GOTO   27B2
027AC:  GOTO   27C2
027B0:  INCF   02,F
027B2:  MOVFF  00,FEE
027B6:  DECFSZ 01,F
027B8:  GOTO   27B2
027BC:  DECFSZ 02,F
027BE:  GOTO   27B2
027C2:  RETURN 0
*
0670A:  MOVLB  2
0670C:  MOVF   xEA,W
0670E:  CLRF   01
06710:  SUBWF  xE9,W
06712:  BTFSS  FD8.0
06714:  BRA    671C
06716:  MOVLB  0
06718:  GOTO   6726
0671C:  MOVF   xE9,W
0671E:  MOVWF  00
06720:  MOVLB  0
06722:  GOTO   6750
06726:  CLRF   00
06728:  MOVLW  08
0672A:  MOVLB  2
0672C:  MOVWF  xEB
0672E:  MOVLB  0
06730:  MOVLB  2
06732:  RLCF   xE9,F
06734:  RLCF   00,F
06736:  MOVF   xEA,W
06738:  SUBWF  00,W
0673A:  BTFSC  FD8.0
0673C:  MOVWF  00
0673E:  RLCF   01,F
06740:  DECFSZ xEB,F
06742:  BRA    6748
06744:  BRA    674E
06746:  MOVLB  0
06748:  MOVLB  0
0674A:  GOTO   6730
0674E:  MOVLB  0
06750:  RETURN 0
06752:  MOVF   01,W
06754:  MOVFF  264,2E9
06758:  MOVLW  64
0675A:  MOVLB  2
0675C:  MOVWF  xEA
0675E:  MOVLB  0
06760:  CALL   670A
06764:  MOVFF  00,264
06768:  MOVF   01,W
0676A:  MOVLW  30
0676C:  BTFSS  FD8.2
0676E:  GOTO   6792
06772:  MOVLB  2
06774:  BTFSC  x65.1
06776:  BRA    677E
06778:  MOVLB  0
0677A:  GOTO   67A6
0677E:  BTFSS  x65.3
06780:  BRA    6788
06782:  MOVLB  0
06784:  GOTO   67A6
06788:  BTFSC  x65.4
0678A:  MOVLW  20
0678C:  MOVLB  0
0678E:  GOTO   679C
06792:  MOVLB  2
06794:  BCF    x65.3
06796:  BCF    x65.4
06798:  BSF    x65.0
0679A:  MOVLB  0
0679C:  ADDWF  01,F
0679E:  MOVFF  01,AAD
067A2:  CALL   1B6C
067A6:  MOVFF  264,2E9
067AA:  MOVLW  0A
067AC:  MOVLB  2
067AE:  MOVWF  xEA
067B0:  MOVLB  0
067B2:  CALL   670A
067B6:  MOVFF  00,264
067BA:  MOVF   01,W
067BC:  MOVLW  30
067BE:  BTFSS  FD8.2
067C0:  GOTO   67E0
067C4:  MOVLB  2
067C6:  BTFSS  x65.3
067C8:  BRA    67D0
067CA:  MOVLB  0
067CC:  GOTO   67EA
067D0:  BTFSC  x65.0
067D2:  BRA    67DA
067D4:  MOVLB  0
067D6:  GOTO   67EA
067DA:  BTFSC  x65.4
067DC:  MOVLW  20
067DE:  MOVLB  0
067E0:  ADDWF  01,F
067E2:  MOVFF  01,AAD
067E6:  CALL   1B6C
067EA:  MOVLW  30
067EC:  MOVLB  2
067EE:  ADDWF  x64,F
067F0:  MOVFF  264,AAD
067F4:  MOVLB  0
067F6:  CALL   1B6C
067FA:  RETURN 0
067FC:  BTFSC  FD8.1
067FE:  GOTO   680A
06802:  MOVLW  09
06804:  MOVWF  FEA
06806:  MOVLW  DF
06808:  MOVWF  FE9
0680A:  CLRF   00
0680C:  CLRF   01
0680E:  CLRF   02
06810:  CLRF   03
06812:  MOVLB  9
06814:  CLRF   xDF
06816:  CLRF   xE0
06818:  CLRF   xE1
0681A:  CLRF   xE2
0681C:  MOVF   xDE,W
0681E:  IORWF  xDD,W
06820:  IORWF  xDC,W
06822:  IORWF  xDB,W
06824:  BTFSS  FD8.2
06826:  BRA    682E
06828:  MOVLB  0
0682A:  GOTO   68BE
0682E:  MOVLB  0
06830:  MOVLW  20
06832:  MOVLB  9
06834:  MOVWF  xE3
06836:  MOVLB  0
06838:  BCF    FD8.0
0683A:  MOVLB  9
0683C:  RLCF   xD7,F
0683E:  RLCF   xD8,F
06840:  RLCF   xD9,F
06842:  RLCF   xDA,F
06844:  RLCF   xDF,F
06846:  RLCF   xE0,F
06848:  RLCF   xE1,F
0684A:  RLCF   xE2,F
0684C:  MOVF   xDE,W
0684E:  SUBWF  xE2,W
06850:  BTFSC  FD8.2
06852:  BRA    685A
06854:  MOVLB  0
06856:  GOTO   687C
0685A:  MOVF   xDD,W
0685C:  SUBWF  xE1,W
0685E:  BTFSC  FD8.2
06860:  BRA    6868
06862:  MOVLB  0
06864:  GOTO   687C
06868:  MOVF   xDC,W
0686A:  SUBWF  xE0,W
0686C:  BTFSC  FD8.2
0686E:  BRA    6876
06870:  MOVLB  0
06872:  GOTO   687C
06876:  MOVF   xDB,W
06878:  SUBWF  xDF,W
0687A:  MOVLB  0
0687C:  BTFSS  FD8.0
0687E:  GOTO   68A4
06882:  MOVLB  9
06884:  MOVF   xDB,W
06886:  SUBWF  xDF,F
06888:  MOVF   xDC,W
0688A:  BTFSS  FD8.0
0688C:  INCFSZ xDC,W
0688E:  SUBWF  xE0,F
06890:  MOVF   xDD,W
06892:  BTFSS  FD8.0
06894:  INCFSZ xDD,W
06896:  SUBWF  xE1,F
06898:  MOVF   xDE,W
0689A:  BTFSS  FD8.0
0689C:  INCFSZ xDE,W
0689E:  SUBWF  xE2,F
068A0:  BSF    FD8.0
068A2:  MOVLB  0
068A4:  RLCF   00,F
068A6:  RLCF   01,F
068A8:  RLCF   02,F
068AA:  RLCF   03,F
068AC:  MOVLB  9
068AE:  DECFSZ xE3,F
068B0:  BRA    68B6
068B2:  BRA    68BC
068B4:  MOVLB  0
068B6:  MOVLB  0
068B8:  GOTO   6838
068BC:  MOVLB  0
068BE:  MOVFF  9DF,FEF
068C2:  MOVFF  9E0,FEC
068C6:  MOVFF  9E1,FEC
068CA:  MOVFF  9E2,FEC
068CE:  MOVF   FED,F
068D0:  MOVF   FED,F
068D2:  MOVF   FED,F
068D4:  RETURN 0
*
06990:  MOVFF  FEA,9CA
06994:  MOVFF  FE9,9C9
06998:  MOVLB  9
0699A:  BTFSC  xC3.7
0699C:  BRA    69A4
0699E:  MOVLB  0
069A0:  GOTO   69B6
069A4:  BSF    xC9.7
069A6:  BTFSS  xC9.4
069A8:  INCF   xC9,F
069AA:  COMF   xC2,F
069AC:  COMF   xC3,F
069AE:  INCF   xC2,F
069B0:  BTFSC  FD8.2
069B2:  INCF   xC3,F
069B4:  MOVLB  0
069B6:  MOVLB  9
069B8:  SWAPF  xC3,W
069BA:  IORLW  F0
069BC:  MOVWF  xC5
069BE:  ADDWF  xC5,F
069C0:  ADDLW  E2
069C2:  MOVWF  xC6
069C4:  ADDLW  32
069C6:  MOVWF  xC8
069C8:  MOVF   xC3,W
069CA:  ANDLW  0F
069CC:  ADDWF  xC6,F
069CE:  ADDWF  xC6,F
069D0:  ADDWF  xC8,F
069D2:  ADDLW  E9
069D4:  MOVWF  xC7
069D6:  ADDWF  xC7,F
069D8:  ADDWF  xC7,F
069DA:  SWAPF  xC2,W
069DC:  ANDLW  0F
069DE:  ADDWF  xC7,F
069E0:  ADDWF  xC8,F
069E2:  RLCF   xC7,F
069E4:  RLCF   xC8,F
069E6:  COMF   xC8,F
069E8:  RLCF   xC8,F
069EA:  MOVF   xC2,W
069EC:  ANDLW  0F
069EE:  ADDWF  xC8,F
069F0:  RLCF   xC5,F
069F2:  MOVLW  07
069F4:  MOVWF  xC4
069F6:  MOVLW  0A
069F8:  MOVLB  0
069FA:  MOVLB  9
069FC:  DECF   xC7,F
069FE:  ADDWF  xC8,F
06A00:  BTFSC  FD8.0
06A02:  BRA    6A0A
06A04:  MOVLB  0
06A06:  GOTO   69FA
06A0A:  MOVLB  0
06A0C:  MOVLB  9
06A0E:  DECF   xC6,F
06A10:  ADDWF  xC7,F
06A12:  BTFSC  FD8.0
06A14:  BRA    6A1C
06A16:  MOVLB  0
06A18:  GOTO   6A0C
06A1C:  MOVLB  0
06A1E:  MOVLB  9
06A20:  DECF   xC5,F
06A22:  ADDWF  xC6,F
06A24:  BTFSC  FD8.0
06A26:  BRA    6A2E
06A28:  MOVLB  0
06A2A:  GOTO   6A1E
06A2E:  MOVLB  0
06A30:  MOVLB  9
06A32:  DECF   xC4,F
06A34:  ADDWF  xC5,F
06A36:  BTFSC  FD8.0
06A38:  BRA    6A40
06A3A:  MOVLB  0
06A3C:  GOTO   6A30
06A40:  MOVLW  09
06A42:  MOVWF  FEA
06A44:  MOVLW  C4
06A46:  MOVWF  FE9
06A48:  MOVLW  07
06A4A:  ANDWF  xC9,W
06A4C:  BCF    xC9.6
06A4E:  MOVF   FED,F
06A50:  ANDWF  xC9,W
06A52:  BTFSC  FD8.2
06A54:  BRA    6A5C
06A56:  MOVLB  0
06A58:  GOTO   6A74
06A5C:  BTFSC  xC9.4
06A5E:  MOVF   FEE,F
06A60:  BTFSS  xC9.4
06A62:  BRA    6A6A
06A64:  MOVLB  0
06A66:  GOTO   6A74
06A6A:  MOVLW  20
06A6C:  MOVWF  00
06A6E:  MOVLB  0
06A70:  GOTO   6AEE
06A74:  ADDWF  FE9,F
06A76:  MOVLW  00
06A78:  ADDWFC FEA,F
06A7A:  MOVF   FE9,W
06A7C:  SUBLW  C8
06A7E:  BTFSS  FD8.2
06A80:  GOTO   6A94
06A84:  MOVF   FEA,W
06A86:  SUBLW  09
06A88:  BTFSS  FD8.2
06A8A:  GOTO   6A94
06A8E:  MOVLB  9
06A90:  BSF    xC9.6
06A92:  MOVLB  0
06A94:  MOVF   FEF,W
06A96:  MOVWF  00
06A98:  BTFSS  FD8.2
06A9A:  GOTO   6AC6
06A9E:  MOVLB  9
06AA0:  BTFSS  xC9.6
06AA2:  BRA    6AAA
06AA4:  MOVLB  0
06AA6:  GOTO   6AC6
06AAA:  BTFSS  xC9.4
06AAC:  BRA    6AB4
06AAE:  MOVLB  0
06AB0:  GOTO   6B06
06AB4:  BTFSS  xC9.3
06AB6:  BRA    6ABE
06AB8:  MOVLB  0
06ABA:  GOTO   6AC6
06ABE:  MOVLW  20
06AC0:  MOVLB  0
06AC2:  GOTO   6AEC
06AC6:  MOVLB  9
06AC8:  BTFSC  xC9.7
06ACA:  BRA    6AD2
06ACC:  MOVLB  0
06ACE:  GOTO   6AE2
06AD2:  MOVLW  2D
06AD4:  MOVWF  00
06AD6:  MOVF   FED,W
06AD8:  BCF    xC9.6
06ADA:  BCF    xC9.7
06ADC:  MOVLB  0
06ADE:  GOTO   6AEE
06AE2:  MOVLB  9
06AE4:  BSF    xC9.3
06AE6:  BCF    xC9.4
06AE8:  MOVLW  30
06AEA:  MOVLB  0
06AEC:  ADDWF  00,F
06AEE:  MOVFF  FEA,9C3
06AF2:  MOVFF  FE9,9C2
06AF6:  MOVFF  00,AAD
06AFA:  CALL   1B6C
06AFE:  MOVFF  9C3,FEA
06B02:  MOVFF  9C2,FE9
06B06:  MOVF   FEE,W
06B08:  MOVLB  9
06B0A:  BTFSC  xC9.6
06B0C:  BRA    6B14
06B0E:  MOVLB  0
06B10:  GOTO   6A7A
06B14:  MOVLB  0
06B16:  GOTO   83CC (RETURN)
*
091FC:  MOVF   FE9,W
091FE:  MOVLB  2
09200:  MOVWF  x64
09202:  BTFSC  x63.7
09204:  BRA    920C
09206:  MOVLB  0
09208:  GOTO   9228
0920C:  DECF   x64,F
0920E:  BSF    x64.5
09210:  COMF   x60,F
09212:  COMF   x61,F
09214:  COMF   x62,F
09216:  COMF   x63,F
09218:  INCF   x60,F
0921A:  BTFSC  FD8.2
0921C:  INCF   x61,F
0921E:  BTFSC  FD8.2
09220:  INCF   x62,F
09222:  BTFSC  FD8.2
09224:  INCF   x63,F
09226:  MOVLB  0
09228:  MOVLW  3B
0922A:  MOVLB  2
0922C:  MOVWF  x6B
0922E:  MOVLW  9A
09230:  MOVWF  x6A
09232:  MOVLW  CA
09234:  MOVWF  x69
09236:  CLRF   x68
09238:  MOVLW  0A
0923A:  MOVWF  x66
0923C:  MOVLB  0
0923E:  BSF    FD8.1
09240:  MOVLW  02
09242:  MOVWF  FEA
09244:  MOVLW  60
09246:  MOVWF  FE9
09248:  MOVFF  263,9DA
0924C:  MOVFF  262,9D9
09250:  MOVFF  261,9D8
09254:  MOVFF  260,9D7
09258:  MOVFF  26B,9DE
0925C:  MOVFF  26A,9DD
09260:  MOVFF  269,9DC
09264:  MOVFF  268,9DB
09268:  CALL   67FC
0926C:  MOVF   01,W
0926E:  MOVF   00,F
09270:  BTFSS  FD8.2
09272:  GOTO   92CA
09276:  MOVLB  2
09278:  MOVF   x66,W
0927A:  XORLW  01
0927C:  BTFSS  FD8.2
0927E:  BRA    9286
09280:  MOVLB  0
09282:  GOTO   92CA
09286:  MOVF   x64,W
09288:  BTFSS  FD8.2
0928A:  BRA    9292
0928C:  MOVLB  0
0928E:  GOTO   92D2
09292:  ANDLW  0F
09294:  SUBWF  x66,W
09296:  BTFSS  FD8.2
09298:  BRA    92A0
0929A:  MOVLB  0
0929C:  GOTO   92AC
092A0:  BTFSS  FD8.0
092A2:  BRA    92AA
092A4:  MOVLB  0
092A6:  GOTO   9330
092AA:  MOVLB  0
092AC:  MOVLB  2
092AE:  BTFSS  x64.7
092B0:  BRA    92B8
092B2:  MOVLB  0
092B4:  GOTO   9330
092B8:  BTFSS  x64.6
092BA:  BRA    92C2
092BC:  MOVLB  0
092BE:  GOTO   92D2
092C2:  MOVLW  20
092C4:  MOVLB  0
092C6:  GOTO   9326
092CA:  MOVLW  20
092CC:  MOVLB  2
092CE:  ANDWF  x64,F
092D0:  MOVLB  0
092D2:  MOVLB  2
092D4:  BTFSC  x64.5
092D6:  BRA    92DE
092D8:  MOVLB  0
092DA:  GOTO   92FA
092DE:  BCF    x64.5
092E0:  MOVF   00,W
092E2:  MOVWF  x64
092E4:  MOVLW  2D
092E6:  MOVLB  A
092E8:  MOVWF  xAD
092EA:  MOVLB  0
092EC:  CALL   1B6C
092F0:  MOVLB  2
092F2:  MOVF   x64,W
092F4:  MOVWF  00
092F6:  CLRF   x64
092F8:  MOVLB  0
092FA:  MOVLW  30
092FC:  MOVLB  2
092FE:  BTFSC  x64.5
09300:  BRA    9308
09302:  MOVLB  0
09304:  GOTO   9326
09308:  BCF    x64.5
0930A:  MOVF   00,W
0930C:  MOVWF  x64
0930E:  MOVLW  2D
09310:  MOVLB  A
09312:  MOVWF  xAD
09314:  MOVLB  0
09316:  CALL   1B6C
0931A:  MOVLB  2
0931C:  MOVF   x64,W
0931E:  MOVWF  00
09320:  CLRF   x64
09322:  MOVLW  30
09324:  MOVLB  0
09326:  ADDWF  00,F
09328:  MOVFF  00,AAD
0932C:  CALL   1B6C
09330:  BCF    FD8.1
09332:  MOVFF  26B,9DA
09336:  MOVFF  26A,9D9
0933A:  MOVFF  269,9D8
0933E:  MOVFF  268,9D7
09342:  MOVLB  9
09344:  CLRF   xDE
09346:  CLRF   xDD
09348:  CLRF   xDC
0934A:  MOVLW  0A
0934C:  MOVWF  xDB
0934E:  MOVLB  0
09350:  CALL   67FC
09354:  MOVFF  03,26B
09358:  MOVFF  02,26A
0935C:  MOVFF  01,269
09360:  MOVFF  00,268
09364:  MOVLB  2
09366:  DECFSZ x66,F
09368:  BRA    936E
0936A:  BRA    9374
0936C:  MOVLB  0
0936E:  MOVLB  0
09370:  GOTO   923E
09374:  MOVLB  0
09376:  RETURN 0
*
09718:  MOVLW  20
0971A:  MOVLB  2
0971C:  BTFSS  xE4.4
0971E:  MOVLW  30
09720:  MOVWF  xE5
09722:  MOVFF  2E3,00
09726:  BTFSC  00.7
09728:  BRA    9730
0972A:  MOVLB  0
0972C:  GOTO   9742
09730:  COMF   00,F
09732:  INCF   00,F
09734:  MOVFF  00,2E3
09738:  MOVLW  2D
0973A:  MOVWF  xE5
0973C:  BSF    xE4.7
0973E:  BSF    xE4.0
09740:  MOVLB  0
09742:  MOVF   01,W
09744:  MOVFF  2E3,2E9
09748:  MOVLW  64
0974A:  MOVLB  2
0974C:  MOVWF  xEA
0974E:  MOVLB  0
09750:  CALL   670A
09754:  MOVFF  00,2E3
09758:  MOVLW  30
0975A:  ADDWF  01,W
0975C:  MOVLB  2
0975E:  MOVWF  xE6
09760:  MOVFF  2E3,2E9
09764:  MOVLW  0A
09766:  MOVWF  xEA
09768:  MOVLB  0
0976A:  CALL   670A
0976E:  MOVLW  30
09770:  ADDWF  00,W
09772:  MOVLB  2
09774:  MOVWF  xE8
09776:  MOVLW  30
09778:  ADDWF  01,W
0977A:  MOVWF  xE7
0977C:  MOVFF  2E5,00
09780:  MOVLB  0
09782:  MOVLW  30
09784:  MOVLB  2
09786:  SUBWF  xE6,W
09788:  BTFSS  FD8.2
0978A:  BRA    9792
0978C:  MOVLB  0
0978E:  GOTO   979E
09792:  BSF    xE4.1
09794:  BTFSC  xE4.7
09796:  BSF    xE4.2
09798:  MOVLB  0
0979A:  GOTO   97DE
0979E:  MOVFF  2E5,2E6
097A2:  MOVLW  20
097A4:  MOVLB  2
097A6:  MOVWF  xE5
097A8:  MOVLW  30
097AA:  SUBWF  xE7,W
097AC:  BTFSS  FD8.2
097AE:  BRA    97B6
097B0:  MOVLB  0
097B2:  GOTO   97C2
097B6:  BSF    xE4.0
097B8:  BTFSC  xE4.7
097BA:  BSF    xE4.1
097BC:  MOVLB  0
097BE:  GOTO   97DE
097C2:  BTFSC  FD8.2
097C4:  BRA    97CC
097C6:  MOVLB  2
097C8:  BSF    xE4.0
097CA:  MOVLB  0
097CC:  BTFSS  FD8.2
097CE:  GOTO   97DE
097D2:  MOVFF  2E6,2E7
097D6:  MOVLW  20
097D8:  MOVLB  2
097DA:  MOVWF  xE6
097DC:  MOVLB  0
097DE:  MOVLB  2
097E0:  BTFSS  xE4.2
097E2:  BRA    97EA
097E4:  MOVLB  0
097E6:  GOTO   9804
097EA:  BTFSS  xE4.1
097EC:  BRA    97F4
097EE:  MOVLB  0
097F0:  GOTO   980C
097F4:  BTFSS  xE4.0
097F6:  BRA    97FE
097F8:  MOVLB  0
097FA:  GOTO   9814
097FE:  MOVLB  0
09800:  GOTO   981C
09804:  MOVFF  2E5,AAD
09808:  CALL   1B6C
0980C:  MOVFF  2E6,AAD
09810:  CALL   1B6C
09814:  MOVFF  2E7,AAD
09818:  CALL   1B6C
0981C:  MOVFF  2E8,AAD
09820:  CALL   1B6C
09824:  RETURN 0
*
0A41A:  MOVF   FE9,W
0A41C:  MOVLB  1
0A41E:  MOVWF  xE9
0A420:  MOVLW  3B
0A422:  MOVWF  xF0
0A424:  MOVLW  9A
0A426:  MOVWF  xEF
0A428:  MOVLW  CA
0A42A:  MOVWF  xEE
0A42C:  CLRF   xED
0A42E:  MOVLW  0A
0A430:  MOVWF  xEB
0A432:  MOVLB  0
0A434:  BSF    FD8.1
0A436:  MOVLW  01
0A438:  MOVWF  FEA
0A43A:  MOVLW  E5
0A43C:  MOVWF  FE9
0A43E:  MOVFF  1E8,9DA
0A442:  MOVFF  1E7,9D9
0A446:  MOVFF  1E6,9D8
0A44A:  MOVFF  1E5,9D7
0A44E:  MOVFF  1F0,9DE
0A452:  MOVFF  1EF,9DD
0A456:  MOVFF  1EE,9DC
0A45A:  MOVFF  1ED,9DB
0A45E:  CALL   67FC
0A462:  MOVF   01,W
0A464:  MOVF   00,F
0A466:  BTFSS  FD8.2
0A468:  GOTO   A4C0
0A46C:  MOVLB  1
0A46E:  MOVF   xEB,W
0A470:  XORLW  01
0A472:  BTFSS  FD8.2
0A474:  BRA    A47C
0A476:  MOVLB  0
0A478:  GOTO   A4C0
0A47C:  MOVF   xE9,W
0A47E:  BTFSS  FD8.2
0A480:  BRA    A488
0A482:  MOVLB  0
0A484:  GOTO   A4C6
0A488:  ANDLW  0F
0A48A:  SUBWF  xEB,W
0A48C:  BTFSS  FD8.2
0A48E:  BRA    A496
0A490:  MOVLB  0
0A492:  GOTO   A4A2
0A496:  BTFSS  FD8.0
0A498:  BRA    A4A0
0A49A:  MOVLB  0
0A49C:  GOTO   A4D2
0A4A0:  MOVLB  0
0A4A2:  MOVLB  1
0A4A4:  BTFSS  xE9.7
0A4A6:  BRA    A4AE
0A4A8:  MOVLB  0
0A4AA:  GOTO   A4D2
0A4AE:  BTFSS  xE9.6
0A4B0:  BRA    A4B8
0A4B2:  MOVLB  0
0A4B4:  GOTO   A4C6
0A4B8:  MOVLW  20
0A4BA:  MOVLB  0
0A4BC:  GOTO   A4C8
0A4C0:  MOVLB  1
0A4C2:  CLRF   xE9
0A4C4:  MOVLB  0
0A4C6:  MOVLW  30
0A4C8:  ADDWF  00,F
0A4CA:  MOVFF  00,AAD
0A4CE:  CALL   1B6C
0A4D2:  BCF    FD8.1
0A4D4:  MOVFF  1F0,9DA
0A4D8:  MOVFF  1EF,9D9
0A4DC:  MOVFF  1EE,9D8
0A4E0:  MOVFF  1ED,9D7
0A4E4:  MOVLB  9
0A4E6:  CLRF   xDE
0A4E8:  CLRF   xDD
0A4EA:  CLRF   xDC
0A4EC:  MOVLW  0A
0A4EE:  MOVWF  xDB
0A4F0:  MOVLB  0
0A4F2:  CALL   67FC
0A4F6:  MOVFF  03,1F0
0A4FA:  MOVFF  02,1EF
0A4FE:  MOVFF  01,1EE
0A502:  MOVFF  00,1ED
0A506:  MOVLB  1
0A508:  DECFSZ xEB,F
0A50A:  BRA    A510
0A50C:  BRA    A516
0A50E:  MOVLB  0
0A510:  MOVLB  0
0A512:  GOTO   A434
0A516:  MOVLB  0
0A518:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01B3E:  MOVLW  0A
01B40:  MOVWF  FEA
01B42:  MOVLW  6E
01B44:  MOVWF  FE9
01B46:  MOVF   FEF,W
01B48:  BTFSC  FD8.2
01B4A:  GOTO   1B6A
01B4E:  MOVLW  05
01B50:  MOVWF  01
01B52:  CLRF   00
01B54:  DECFSZ 00,F
01B56:  BRA    1B54
01B58:  DECFSZ 01,F
01B5A:  BRA    1B52
01B5C:  MOVLW  2E
01B5E:  MOVWF  00
01B60:  DECFSZ 00,F
01B62:  BRA    1B60
01B64:  BRA    1B66
01B66:  DECFSZ FEF,F
01B68:  BRA    1B4E
01B6A:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
04668:  BTFSS  FA6.4
0466A:  GOTO   4668
0466E:  MOVLB  F
04670:  MOVWF  x29
04672:  MOVLB  0
04674:  GOTO   46AA (RETURN)
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01B6C:  BCF    F93.6
01B6E:  BCF    F8A.6
01B70:  MOVLW  08
01B72:  MOVWF  01
01B74:  BRA    1B76
01B76:  NOP   
01B78:  BSF    01.7
01B7A:  GOTO   1BA2
01B7E:  BCF    01.7
01B80:  MOVLB  A
01B82:  RRCF   xAD,F
01B84:  MOVLB  0
01B86:  BTFSC  FD8.0
01B88:  BSF    F8A.6
01B8A:  BTFSS  FD8.0
01B8C:  BCF    F8A.6
01B8E:  BSF    01.6
01B90:  GOTO   1BA2
01B94:  BCF    01.6
01B96:  DECFSZ 01,F
01B98:  GOTO   1B80
01B9C:  BRA    1B9E
01B9E:  NOP   
01BA0:  BSF    F8A.6
01BA2:  MOVLW  84
01BA4:  MOVWF  FE9
01BA6:  DECFSZ FE9,F
01BA8:  GOTO   1BA6
01BAC:  BRA    1BAE
01BAE:  NOP   
01BB0:  BTFSC  01.7
01BB2:  GOTO   1B7E
01BB6:  BTFSC  01.6
01BB8:  GOTO   1B94
01BBC:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
02428:  MOVLB  A
0242A:  MOVF   x91,W
0242C:  SUBLW  08
0242E:  BTFSS  FD8.2
02430:  BRA    2438
02432:  MOVLB  0
02434:  GOTO   2450
02438:  MOVWF  x93
0243A:  MOVLB  0
0243C:  MOVLB  A
0243E:  RLCF   x90,F
02440:  DECFSZ x93,F
02442:  BRA    2448
02444:  BRA    244E
02446:  MOVLB  0
02448:  MOVLB  0
0244A:  GOTO   243C
0244E:  MOVLB  0
02450:  BSF    F92.1
02452:  BCF    F92.0
02454:  BCF    F92.3
02456:  BCF    F89.3
02458:  MOVFF  A91,A93
0245C:  MOVLB  A
0245E:  BTFSS  x90.7
02460:  BCF    F89.0
02462:  BTFSC  x90.7
02464:  BSF    F89.0
02466:  RLCF   x90,F
02468:  BSF    F89.3
0246A:  MOVLW  02
0246C:  MOVWF  x94
0246E:  MOVLB  0
02470:  MOVLB  A
02472:  DECFSZ x94,F
02474:  BRA    247A
02476:  BRA    2480
02478:  MOVLB  0
0247A:  MOVLB  0
0247C:  GOTO   2470
02480:  RLCF   01,F
02482:  BTFSS  F80.1
02484:  BCF    01.0
02486:  BTFSC  F80.1
02488:  BSF    01.0
0248A:  BCF    F89.3
0248C:  MOVLB  0
0248E:  BRA    2490
02490:  MOVLB  A
02492:  DECFSZ x93,F
02494:  BRA    249A
02496:  BRA    24A0
02498:  MOVLB  0
0249A:  MOVLB  0
0249C:  GOTO   245C
024A0:  MOVLB  0
024A2:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
023AC:  MOVLB  A
023AE:  MOVF   x91,W
023B0:  SUBLW  08
023B2:  BTFSS  FD8.2
023B4:  BRA    23BC
023B6:  MOVLB  0
023B8:  GOTO   23D4
023BC:  MOVWF  x93
023BE:  MOVLB  0
023C0:  MOVLB  A
023C2:  RLCF   x90,F
023C4:  DECFSZ x93,F
023C6:  BRA    23CC
023C8:  BRA    23D2
023CA:  MOVLB  0
023CC:  MOVLB  0
023CE:  GOTO   23C0
023D2:  MOVLB  0
023D4:  BSF    F96.0
023D6:  BCF    F96.6
023D8:  BCF    F96.1
023DA:  BCF    F8D.1
023DC:  MOVFF  A91,A93
023E0:  MOVLB  A
023E2:  BTFSS  x90.7
023E4:  BCF    F8D.6
023E6:  BTFSC  x90.7
023E8:  BSF    F8D.6
023EA:  RLCF   x90,F
023EC:  BSF    F8D.1
023EE:  MOVLW  02
023F0:  MOVWF  x94
023F2:  MOVLB  0
023F4:  MOVLB  A
023F6:  DECFSZ x94,F
023F8:  BRA    23FE
023FA:  BRA    2404
023FC:  MOVLB  0
023FE:  MOVLB  0
02400:  GOTO   23F4
02404:  RLCF   01,F
02406:  BTFSS  F84.0
02408:  BCF    01.0
0240A:  BTFSC  F84.0
0240C:  BSF    01.0
0240E:  BCF    F8D.1
02410:  MOVLB  0
02412:  BRA    2414
02414:  MOVLB  A
02416:  DECFSZ x93,F
02418:  BRA    241E
0241A:  BRA    2424
0241C:  MOVLB  0
0241E:  MOVLB  0
02420:  GOTO   23E0
02424:  MOVLB  0
02426:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01D48:  MOVLB  9
01D4A:  MOVF   xE0,W
01D4C:  SUBLW  10
01D4E:  BTFSS  FD8.2
01D50:  BRA    1D58
01D52:  MOVLB  0
01D54:  GOTO   1D72
01D58:  MOVWF  xE2
01D5A:  MOVLB  0
01D5C:  MOVLB  9
01D5E:  RLCF   xDE,F
01D60:  RLCF   xDF,F
01D62:  DECFSZ xE2,F
01D64:  BRA    1D6A
01D66:  BRA    1D70
01D68:  MOVLB  0
01D6A:  MOVLB  0
01D6C:  GOTO   1D5C
01D70:  MOVLB  0
01D72:  BSF    F93.4
01D74:  BCF    F93.5
01D76:  BCF    F93.2
01D78:  BSF    F8A.2
01D7A:  MOVFF  9E0,9E2
01D7E:  MOVLB  9
01D80:  BTFSS  xDF.7
01D82:  BCF    F8A.5
01D84:  BTFSC  xDF.7
01D86:  BSF    F8A.5
01D88:  RLCF   xDE,F
01D8A:  RLCF   xDF,F
01D8C:  BCF    F8A.2
01D8E:  RLCF   01,F
01D90:  RLCF   02,F
01D92:  BTFSS  F81.4
01D94:  BCF    01.0
01D96:  BTFSC  F81.4
01D98:  BSF    01.0
01D9A:  BSF    F8A.2
01D9C:  DECFSZ xE2,F
01D9E:  BRA    1DA4
01DA0:  BRA    1DAA
01DA2:  MOVLB  0
01DA4:  MOVLB  0
01DA6:  GOTO   1D7E
01DAA:  MOVLB  0
01DAC:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/mcu/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/devices/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "../core/measurement/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/storage/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../../system/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "../application/mission/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... #include "../hardware/mcu/src/timer.c"
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
*
000CA:  MOVLW  80
000CC:  MOVWF  FCF
000CE:  MOVLW  12
000D0:  MOVWF  FCE
000D2:  NOP   
....................    sec++;
000D4:  MOVLW  01
000D6:  ADDWF  20,F
000D8:  BTFSC  FD8.0
000DA:  INCF   21,F
000DC:  BTFSC  FD8.2
000DE:  INCF   22,F
000E0:  BTFSC  FD8.2
000E2:  INCF   23,F
....................    /*
....................    if (++subsec >= 100)
....................    {
....................       subsec = 0;
....................       sec++;
.................... 
....................       if (sec >= SEC_IN_A_DAY)
....................       {
....................          day++;
....................       }
....................    }*/
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01C9C:  MOVLW  EA
01C9E:  MOVWF  FF6
01CA0:  MOVLW  00
01CA2:  MOVWF  FF7
01CA4:  MOVLW  00
01CA6:  MOVWF  FF8
01CA8:  CALL   1BBE
....................    clear_interrupt(INT_TIMER1);
01CAC:  BCF    F9E.0
....................    //sec = 0;
....................    // 外部クロックをT1CKIピンから入力、プリスケーラなし
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01CAE:  MOVLW  8F
01CB0:  MOVWF  FCD
01CB2:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01CB4:  MOVLW  80
01CB6:  MOVWF  FCF
01CB8:  MOVLW  12
01CBA:  MOVWF  FCE
01CBC:  NOP   
....................    //set_timer1(0);  // タイマーカウント初期値設定
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);   
01CBE:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01CC0:  MOVLW  C0
01CC2:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CC4:  MOVLW  FE
01CC6:  MOVWF  FF6
01CC8:  MOVLW  00
01CCA:  MOVWF  FF7
01CCC:  MOVLW  00
01CCE:  MOVWF  FF8
01CD0:  CALL   1BBE
01CD4:  GOTO   B53A (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
031B8:  MOVFF  20,00
031BC:  MOVFF  21,01
031C0:  MOVFF  22,02
031C4:  MOVFF  23,03
031C8:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
*
068D6:  BCF    FD8.1
068D8:  MOVFF  1F,9DA
068DC:  MOVFF  1E,9D9
068E0:  MOVFF  1D,9D8
068E4:  MOVFF  1C,9D7
068E8:  MOVLB  9
068EA:  CLRF   xDE
068EC:  CLRF   xDD
068EE:  CLRF   xDC
068F0:  MOVLW  0A
068F2:  MOVWF  xDB
068F4:  MOVLB  0
068F6:  CALL   67FC
068FA:  MOVF   01,W
068FC:  MOVWF  02
068FE:  MOVF   00,W
06900:  MOVWF  01
06902:  GOTO   691E (RETURN)
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/mcu/src/uart.c"
.................... #INT_RDA3
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  47.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   46,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   46,W
0014C:  INCF   46,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  26
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,ABE
00160:  MOVFF  FE9,ABD
00164:  GOTO   010A
00168:  MOVFF  ABE,FEA
0016C:  MOVFF  ABD,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
.................... 
....................    // fprintf(PC, "RDA Interrupt: %d bytes received\r\n", boss_receive_buffer_size);
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01C72:  MOVLW  7A
01C74:  MOVWF  FF6
01C76:  MOVLW  01
01C78:  MOVWF  FF7
01C7A:  MOVLW  00
01C7C:  MOVWF  FF8
01C7E:  CALL   1BBE
....................    enable_interrupts(INT_RDA3);
01C82:  BSF    F61.5
....................    enable_interrupts(global);
01C84:  MOVLW  C0
01C86:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01C88:  MOVLW  8C
01C8A:  MOVWF  FF6
01C8C:  MOVLW  01
01C8E:  MOVWF  FF7
01C90:  MOVLW  00
01C92:  MOVWF  FF8
01C94:  CALL   1BBE
01C98:  GOTO   B536 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
0462A:  MOVFF  187,03
0462E:  MOVLB  1
04630:  MOVF   x86,W
04632:  MOVWF  FE9
04634:  MOVFF  03,FEA
04638:  MOVFF  FEF,188
0463C:  MOVFF  185,FEA
04640:  MOVFF  184,FE9
04644:  CLRF   00
04646:  CLRF   02
04648:  MOVFF  188,01
0464C:  MOVLB  0
0464E:  CALL   27A0
....................    *receive_signal_size = 0;
04652:  MOVFF  187,03
04656:  MOVLB  1
04658:  MOVF   x86,W
0465A:  MOVWF  FE9
0465C:  MOVFF  03,FEA
04660:  CLRF   FEF
04662:  MOVLB  0
04664:  GOTO   B5DC (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/ad7490_driver.c"
.................... #include "../ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01EB2:  MOVLW  98
01EB4:  MOVWF  FF6
01EB6:  MOVLW  01
01EB8:  MOVWF  FF7
01EBA:  MOVLW  00
01EBC:  MOVWF  FF8
01EBE:  CALL   1BBE
....................     output_high(ADC_CS); // Set CS pin high to deselect the ADC
01EC2:  MOVLW  F4
01EC4:  MOVWF  F93
01EC6:  BSF    F8A.1
....................     delay_ms(10); // Wait for the ADC to stabilize
01EC8:  MOVLW  0A
01ECA:  MOVLB  A
01ECC:  MOVWF  x6E
01ECE:  MOVLB  0
01ED0:  CALL   1B3E
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR); // Read a dummy value to initialize the ADC
01ED4:  MOVLW  05
01ED6:  MOVLB  9
01ED8:  MOVWF  xD7
01EDA:  MOVLB  0
01EDC:  CALL   1DAE
01EE0:  MOVFF  02,185
01EE4:  MOVFF  01,184
....................     delay_ms(1); // Wait for the ADC to stabilize after reading
01EE8:  MOVLW  01
01EEA:  MOVLB  A
01EEC:  MOVWF  x6E
01EEE:  MOVLB  0
01EF0:  CALL   1B3E
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01EF4:  MOVLW  09
01EF6:  MOVLB  A
01EF8:  MOVWF  xAD
01EFA:  MOVLB  0
01EFC:  CALL   1B6C
01F00:  MOVFF  185,264
01F04:  MOVLW  37
01F06:  MOVLB  2
01F08:  MOVWF  x65
01F0A:  MOVLB  0
01F0C:  CALL   1E42
01F10:  MOVFF  184,264
01F14:  MOVLW  37
01F16:  MOVLB  2
01F18:  MOVWF  x65
01F1A:  MOVLB  0
01F1C:  CALL   1E42
01F20:  MOVLW  0D
01F22:  MOVLB  A
01F24:  MOVWF  xAD
01F26:  MOVLB  0
01F28:  CALL   1B6C
01F2C:  MOVLW  0A
01F2E:  MOVLB  A
01F30:  MOVWF  xAD
01F32:  MOVLB  0
01F34:  CALL   1B6C
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F38:  MOVLB  1
01F3A:  INCFSZ x84,W
01F3C:  BRA    1F42
01F3E:  BRA    1F48
01F40:  MOVLB  0
01F42:  MOVLB  0
01F44:  GOTO   1F60
01F48:  MOVLB  0
01F4A:  MOVLB  1
01F4C:  INCFSZ x85,W
01F4E:  BRA    1F54
01F50:  BRA    1F5A
01F52:  MOVLB  0
01F54:  MOVLB  0
01F56:  GOTO   1F60
01F5A:  MOVLB  0
01F5C:  GOTO   1F80
01F60:  MOVLB  1
01F62:  MOVF   x84,F
01F64:  BTFSC  FD8.2
01F66:  BRA    1F6E
01F68:  MOVLB  0
01F6A:  GOTO   1F94
01F6E:  MOVLB  0
01F70:  MOVLB  1
01F72:  MOVF   x85,F
01F74:  BTFSC  FD8.2
01F76:  BRA    1F7E
01F78:  MOVLB  0
01F7A:  GOTO   1F94
01F7E:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01F80:  MOVLW  AC
01F82:  MOVWF  FF6
01F84:  MOVLW  01
01F86:  MOVWF  FF7
01F88:  MOVLW  00
01F8A:  MOVWF  FF8
01F8C:  CALL   1BBE
....................     } else {
01F90:  GOTO   1FA4
....................         fprintf(PC, "\tConnect successful\r\n");
01F94:  MOVLW  BE
01F96:  MOVWF  FF6
01F98:  MOVLW  01
01F9A:  MOVWF  FF7
01F9C:  MOVLW  00
01F9E:  MOVWF  FF8
01FA0:  CALL   1BBE
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01FA4:  MOVLW  D4
01FA6:  MOVWF  FF6
01FA8:  MOVLW  01
01FAA:  MOVWF  FF7
01FAC:  MOVLW  00
01FAE:  MOVWF  FF8
01FB0:  CALL   1BBE
01FB4:  GOTO   B53E (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01DAE:  MOVFF  9D7,9DE
01DB2:  GOTO   1CD8
01DB6:  MOVFF  02,9D9
01DBA:  MOVFF  01,9D8
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     // Send the command to the ADC
....................     output_low(ADC_CS); // Set CS pin low to select the ADC
01DBE:  MOVLW  F4
01DC0:  MOVWF  F93
01DC2:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01DC4:  MOVLW  0D
01DC6:  MOVWF  00
01DC8:  DECFSZ 00,F
01DCA:  BRA    1DC8
....................     spi_xfer(ADC_STREAM, cmd); // Dummy transfer to start communication
01DCC:  MOVFF  9D9,9DF
01DD0:  MOVFF  9D8,9DE
01DD4:  MOVLW  10
01DD6:  MOVLB  9
01DD8:  MOVWF  xE0
01DDA:  MOVLW  01
01DDC:  MOVWF  xE1
01DDE:  MOVLB  0
01DE0:  CALL   1D48
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     delay_us(10); // Wait for the ADC to process the command
01DE4:  MOVLW  0D
01DE6:  MOVWF  00
01DE8:  DECFSZ 00,F
01DEA:  BRA    1DE8
....................     output_high(ADC_CS); // Set CS pin high to end communication
01DEC:  MOVLW  F4
01DEE:  MOVWF  F93
01DF0:  BSF    F8A.1
....................     delay_us(10); // Wait for the ADC to process the command
01DF2:  MOVLW  0D
01DF4:  MOVWF  00
01DF6:  DECFSZ 00,F
01DF8:  BRA    1DF6
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01DFA:  MOVLW  F4
01DFC:  MOVWF  F93
01DFE:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01E00:  MOVLW  0D
01E02:  MOVWF  00
01E04:  DECFSZ 00,F
01E06:  BRA    1E04
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000); // Read data from ADC
01E08:  MOVLB  9
01E0A:  CLRF   xDF
01E0C:  CLRF   xDE
01E0E:  MOVLW  10
01E10:  MOVWF  xE0
01E12:  MOVLW  01
01E14:  MOVWF  xE1
01E16:  MOVLB  0
01E18:  CALL   1D48
01E1C:  MOVFF  02,9DB
01E20:  MOVFF  01,9DA
....................     output_high(ADC_CS); 
01E24:  MOVLW  F4
01E26:  MOVWF  F93
01E28:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E2A:  MOVLB  9
01E2C:  MOVF   xDA,W
01E2E:  MOVWF  xDC
01E30:  MOVF   xDB,W
01E32:  ANDLW  0F
01E34:  MOVWF  xDD
....................     
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E36:  MOVF   xDC,W
01E38:  MOVWF  01
01E3A:  MOVF   xDD,W
01E3C:  MOVWF  02
01E3E:  MOVLB  0
01E40:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/mcp4901_driver.c"
.................... #include "../mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
02190:  MOVLW  E0
02192:  MOVWF  FF6
02194:  MOVLW  01
02196:  MOVWF  FF7
02198:  MOVLW  00
0219A:  MOVWF  FF8
0219C:  CALL   1BBE
....................     output_high(DAC1_CS); 
021A0:  MOVLW  F4
021A2:  MOVWF  F93
021A4:  BSF    F8A.3
....................     output_high(DAC2_CS); 
021A6:  MOVLW  F4
021A8:  MOVWF  F93
021AA:  BSF    F8A.0
....................     delay_ms(10); 
021AC:  MOVLW  0A
021AE:  MOVLB  A
021B0:  MOVWF  x6E
021B2:  MOVLB  0
021B4:  CALL   1B3E
....................     mcp4901_1_write(10); 
021B8:  MOVLB  9
021BA:  CLRF   xC3
021BC:  MOVLW  0A
021BE:  MOVWF  xC2
021C0:  MOVLB  0
021C2:  CALL   210C
....................     mcp4901_2_write(10); 
021C6:  MOVLB  9
021C8:  CLRF   xC3
021CA:  MOVLW  0A
021CC:  MOVWF  xC2
021CE:  MOVLB  0
021D0:  CALL   214E
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
021D4:  MOVLW  08
021D6:  MOVLB  9
021D8:  MOVWF  xD7
021DA:  MOVLB  0
021DC:  CALL   1DAE
021E0:  MOVFF  02,185
021E4:  MOVFF  01,184
....................     fprintf(PC, "%04LX\r\n", readdata);
021E8:  MOVFF  185,264
021EC:  MOVLW  37
021EE:  MOVLB  2
021F0:  MOVWF  x65
021F2:  MOVLB  0
021F4:  CALL   1E42
021F8:  MOVFF  184,264
021FC:  MOVLW  37
021FE:  MOVLB  2
02200:  MOVWF  x65
02202:  MOVLB  0
02204:  CALL   1E42
02208:  MOVLW  0D
0220A:  MOVLB  A
0220C:  MOVWF  xAD
0220E:  MOVLB  0
02210:  CALL   1B6C
02214:  MOVLW  0A
02216:  MOVLB  A
02218:  MOVWF  xAD
0221A:  MOVLB  0
0221C:  CALL   1B6C
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
02220:  MOVLB  1
02222:  INCFSZ x84,W
02224:  BRA    222A
02226:  BRA    2230
02228:  MOVLB  0
0222A:  MOVLB  0
0222C:  GOTO   2248
02230:  MOVLB  0
02232:  MOVLB  1
02234:  INCFSZ x85,W
02236:  BRA    223C
02238:  BRA    2242
0223A:  MOVLB  0
0223C:  MOVLB  0
0223E:  GOTO   2248
02242:  MOVLB  0
02244:  GOTO   2268
02248:  MOVLB  1
0224A:  MOVF   x84,F
0224C:  BTFSC  FD8.2
0224E:  BRA    2256
02250:  MOVLB  0
02252:  GOTO   227C
02256:  MOVLB  0
02258:  MOVLB  1
0225A:  MOVF   x85,F
0225C:  BTFSC  FD8.2
0225E:  BRA    2266
02260:  MOVLB  0
02262:  GOTO   227C
02266:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
02268:  MOVLW  F6
0226A:  MOVWF  FF6
0226C:  MOVLW  01
0226E:  MOVWF  FF7
02270:  MOVLW  00
02272:  MOVWF  FF8
02274:  CALL   1BBE
....................     } else {
02278:  GOTO   228C
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
0227C:  MOVLW  16
0227E:  MOVWF  FF6
02280:  MOVLW  02
02282:  MOVWF  FF7
02284:  MOVLW  00
02286:  MOVWF  FF8
02288:  CALL   1BBE
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
0228C:  MOVFF  185,264
02290:  MOVLW  37
02292:  MOVLB  2
02294:  MOVWF  x65
02296:  MOVLB  0
02298:  CALL   1E42
0229C:  MOVFF  184,264
022A0:  MOVLW  37
022A2:  MOVLB  2
022A4:  MOVWF  x65
022A6:  MOVLB  0
022A8:  CALL   1E42
022AC:  MOVLW  0D
022AE:  MOVLB  A
022B0:  MOVWF  xAD
022B2:  MOVLB  0
022B4:  CALL   1B6C
022B8:  MOVLW  0A
022BA:  MOVLB  A
022BC:  MOVWF  xAD
022BE:  MOVLB  0
022C0:  CALL   1B6C
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
022C4:  MOVLW  09
022C6:  MOVLB  9
022C8:  MOVWF  xD7
022CA:  MOVLB  0
022CC:  CALL   1DAE
022D0:  MOVFF  02,185
022D4:  MOVFF  01,184
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
022D8:  MOVLB  1
022DA:  INCFSZ x84,W
022DC:  BRA    22E2
022DE:  BRA    22E8
022E0:  MOVLB  0
022E2:  MOVLB  0
022E4:  GOTO   2300
022E8:  MOVLB  0
022EA:  MOVLB  1
022EC:  INCFSZ x85,W
022EE:  BRA    22F4
022F0:  BRA    22FA
022F2:  MOVLB  0
022F4:  MOVLB  0
022F6:  GOTO   2300
022FA:  MOVLB  0
022FC:  GOTO   2320
02300:  MOVLB  1
02302:  MOVF   x84,F
02304:  BTFSC  FD8.2
02306:  BRA    230E
02308:  MOVLB  0
0230A:  GOTO   2334
0230E:  MOVLB  0
02310:  MOVLB  1
02312:  MOVF   x85,F
02314:  BTFSC  FD8.2
02316:  BRA    231E
02318:  MOVLB  0
0231A:  GOTO   2334
0231E:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
02320:  MOVLW  3A
02322:  MOVWF  FF6
02324:  MOVLW  02
02326:  MOVWF  FF7
02328:  MOVLW  00
0232A:  MOVWF  FF8
0232C:  CALL   1BBE
....................     } else {
02330:  GOTO   2344
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02334:  MOVLW  5A
02336:  MOVWF  FF6
02338:  MOVLW  02
0233A:  MOVWF  FF7
0233C:  MOVLW  00
0233E:  MOVWF  FF8
02340:  CALL   1BBE
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02344:  MOVLW  7E
02346:  MOVWF  FF6
02348:  MOVLW  02
0234A:  MOVWF  FF7
0234C:  MOVLW  00
0234E:  MOVWF  FF8
02350:  CALL   1BBE
02354:  GOTO   B542 (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
0210C:  MOVFF  9C3,9C7
02110:  MOVFF  9C2,9C6
02114:  CALL   1FB8
02118:  MOVFF  02,9C5
0211C:  MOVFF  01,9C4
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
02120:  MOVLW  F4
02122:  MOVWF  F93
02124:  BCF    F8A.3
....................    delay_us(10); 
02126:  MOVLW  0D
02128:  MOVWF  00
0212A:  DECFSZ 00,F
0212C:  BRA    212A
....................    spi_xfer(ADCDAC_STREAM, cmd); 
0212E:  MOVFF  9C5,9DF
02132:  MOVFF  9C4,9DE
02136:  MOVLW  10
02138:  MOVLB  9
0213A:  MOVWF  xE0
0213C:  MOVLW  01
0213E:  MOVWF  xE1
02140:  MOVLB  0
02142:  CALL   1D48
....................    output_high(DAC1_CS); 
02146:  MOVLW  F4
02148:  MOVWF  F93
0214A:  BSF    F8A.3
0214C:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
0214E:  MOVFF  9C3,9C7
02152:  MOVFF  9C2,9C6
02156:  CALL   1FB8
0215A:  MOVFF  02,9C5
0215E:  MOVFF  01,9C4
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
02162:  MOVLW  F4
02164:  MOVWF  F93
02166:  BCF    F8A.0
....................    delay_us(10); 
02168:  MOVLW  0D
0216A:  MOVWF  00
0216C:  DECFSZ 00,F
0216E:  BRA    216C
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02170:  MOVFF  9C5,9DF
02174:  MOVFF  9C4,9DE
02178:  MOVLW  10
0217A:  MOVLB  9
0217C:  MOVWF  xE0
0217E:  MOVLW  01
02180:  MOVWF  xE1
02182:  MOVLB  0
02184:  CALL   1D48
....................    output_high(DAC2_CS); 
02188:  MOVLW  F4
0218A:  MOVWF  F93
0218C:  BSF    F8A.0
0218E:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01CD8:  MOVLB  9
01CDA:  BCF    xDF.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01CDC:  BCF    xDF.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01CDE:  BCF    xDF.2
....................     cmd.fields.reserved3 = 0;
01CE0:  BCF    xDF.3
....................     cmd.fields.coding = 1; // Two's complement
01CE2:  BSF    xDF.4
....................     cmd.fields.range = 0; // Normal mode
01CE4:  BCF    xDF.5
....................     cmd.fields.weak_tri = 0; // Strong trigger
01CE6:  BCF    xDF.6
....................     cmd.fields.shadow = 0; // Direct access
01CE8:  BCF    xDF.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01CEA:  BSF    xE0.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01CEC:  BSF    xE0.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01CEE:  MOVF   xDE,W
01CF0:  ANDLW  01
01CF2:  MOVWF  01
01CF4:  BCF    xE0.2
01CF6:  BTFSC  01.0
01CF8:  BSF    xE0.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01CFA:  BCF    FD8.0
01CFC:  RRCF   xDE,W
01CFE:  ANDLW  01
01D00:  MOVWF  01
01D02:  BCF    xE0.3
01D04:  BTFSC  01.0
01D06:  BSF    xE0.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01D08:  RRCF   xDE,W
01D0A:  MOVWF  00
01D0C:  RRCF   00,F
01D0E:  MOVLW  3F
01D10:  ANDWF  00,F
01D12:  MOVF   00,W
01D14:  ANDLW  01
01D16:  MOVWF  01
01D18:  BCF    xE0.4
01D1A:  BTFSC  01.0
01D1C:  BSF    xE0.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D1E:  RRCF   xDE,W
01D20:  MOVWF  00
01D22:  RRCF   00,F
01D24:  RRCF   00,F
01D26:  MOVLW  1F
01D28:  ANDWF  00,F
01D2A:  MOVF   00,W
01D2C:  ANDLW  01
01D2E:  MOVWF  01
01D30:  BCF    xE0.5
01D32:  BTFSC  01.0
01D34:  BSF    xE0.5
....................     cmd.fields.seq = 0; // Random mode
01D36:  BCF    xE0.6
....................     cmd.fields.write = 1; // Read operation
01D38:  BSF    xE0.7
.................... 
.................... 
....................     return cmd.value;
01D3A:  MOVF   xDF,W
01D3C:  MOVWF  01
01D3E:  MOVF   xE0,W
01D40:  MOVWF  02
01D42:  MOVLB  0
01D44:  GOTO   1DB6 (RETURN)
.................... }
.................... 
.................... #include "../../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
01FB8:  MOVLB  9
01FBA:  BCF    xC9.7
....................    cmd.fields.buffer = 1; // Buffer used
01FBC:  BSF    xC9.6
....................    cmd.fields.gain = 1; // Gain 1x
01FBE:  BSF    xC9.5
....................    cmd.fields.shutdown = 1; // Normal operation
01FC0:  BSF    xC9.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
01FC2:  RRCF   xC7,W
01FC4:  MOVWF  xCB
01FC6:  RRCF   xC6,W
01FC8:  MOVWF  xCA
01FCA:  RRCF   xCB,F
01FCC:  RRCF   xCA,F
01FCE:  RRCF   xCB,F
01FD0:  RRCF   xCA,F
01FD2:  RRCF   xCB,F
01FD4:  RRCF   xCA,F
01FD6:  RRCF   xCB,F
01FD8:  RRCF   xCA,F
01FDA:  RRCF   xCB,F
01FDC:  RRCF   xCA,F
01FDE:  RRCF   xCB,F
01FE0:  RRCF   xCA,F
01FE2:  MOVLW  01
01FE4:  ANDWF  xCB,F
01FE6:  MOVF   xCA,W
01FE8:  ANDLW  01
01FEA:  MOVWF  00
01FEC:  CLRF   03
01FEE:  MOVF   00,W
01FF0:  MOVWF  01
01FF2:  BCF    xC9.3
01FF4:  BTFSC  01.0
01FF6:  BSF    xC9.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
01FF8:  RRCF   xC7,W
01FFA:  MOVWF  xCB
01FFC:  RRCF   xC6,W
01FFE:  MOVWF  xCA
02000:  RRCF   xCB,F
02002:  RRCF   xCA,F
02004:  RRCF   xCB,F
02006:  RRCF   xCA,F
02008:  RRCF   xCB,F
0200A:  RRCF   xCA,F
0200C:  RRCF   xCB,F
0200E:  RRCF   xCA,F
02010:  RRCF   xCB,F
02012:  RRCF   xCA,F
02014:  MOVLW  03
02016:  ANDWF  xCB,F
02018:  MOVF   xCA,W
0201A:  ANDLW  01
0201C:  MOVWF  00
0201E:  CLRF   03
02020:  MOVF   00,W
02022:  MOVWF  01
02024:  BCF    xC9.2
02026:  BTFSC  01.0
02028:  BSF    xC9.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
0202A:  RRCF   xC7,W
0202C:  MOVWF  xCB
0202E:  RRCF   xC6,W
02030:  MOVWF  xCA
02032:  RRCF   xCB,F
02034:  RRCF   xCA,F
02036:  RRCF   xCB,F
02038:  RRCF   xCA,F
0203A:  RRCF   xCB,F
0203C:  RRCF   xCA,F
0203E:  RRCF   xCB,F
02040:  RRCF   xCA,F
02042:  MOVLW  07
02044:  ANDWF  xCB,F
02046:  MOVF   xCA,W
02048:  ANDLW  01
0204A:  MOVWF  00
0204C:  CLRF   03
0204E:  MOVF   00,W
02050:  MOVWF  01
02052:  BCF    xC9.1
02054:  BTFSC  01.0
02056:  BSF    xC9.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
02058:  RRCF   xC7,W
0205A:  MOVWF  xCB
0205C:  RRCF   xC6,W
0205E:  MOVWF  xCA
02060:  RRCF   xCB,F
02062:  RRCF   xCA,F
02064:  RRCF   xCB,F
02066:  RRCF   xCA,F
02068:  RRCF   xCB,F
0206A:  RRCF   xCA,F
0206C:  MOVLW  0F
0206E:  ANDWF  xCB,F
02070:  MOVF   xCA,W
02072:  ANDLW  01
02074:  MOVWF  00
02076:  CLRF   03
02078:  MOVF   00,W
0207A:  MOVWF  01
0207C:  BCF    xC9.0
0207E:  BTFSC  01.0
02080:  BSF    xC9.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
02082:  RRCF   xC7,W
02084:  MOVWF  xCB
02086:  RRCF   xC6,W
02088:  MOVWF  xCA
0208A:  RRCF   xCB,F
0208C:  RRCF   xCA,F
0208E:  RRCF   xCB,F
02090:  RRCF   xCA,F
02092:  MOVLW  1F
02094:  ANDWF  xCB,F
02096:  MOVF   xCA,W
02098:  ANDLW  01
0209A:  MOVWF  00
0209C:  CLRF   03
0209E:  MOVF   00,W
020A0:  MOVWF  01
020A2:  BCF    xC8.7
020A4:  BTFSC  01.0
020A6:  BSF    xC8.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
020A8:  RRCF   xC7,W
020AA:  MOVWF  xCB
020AC:  RRCF   xC6,W
020AE:  MOVWF  xCA
020B0:  RRCF   xCB,F
020B2:  RRCF   xCA,F
020B4:  MOVLW  3F
020B6:  ANDWF  xCB,F
020B8:  MOVF   xCA,W
020BA:  ANDLW  01
020BC:  MOVWF  00
020BE:  CLRF   03
020C0:  MOVF   00,W
020C2:  MOVWF  01
020C4:  BCF    xC8.6
020C6:  BTFSC  01.0
020C8:  BSF    xC8.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
020CA:  BCF    FD8.0
020CC:  RRCF   xC7,W
020CE:  MOVWF  xCB
020D0:  RRCF   xC6,W
020D2:  MOVWF  xCA
020D4:  MOVF   xCA,W
020D6:  ANDLW  01
020D8:  MOVWF  00
020DA:  CLRF   03
020DC:  MOVF   00,W
020DE:  MOVWF  01
020E0:  BCF    xC8.5
020E2:  BTFSC  01.0
020E4:  BSF    xC8.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
020E6:  MOVF   xC6,W
020E8:  ANDLW  01
020EA:  MOVWF  00
020EC:  CLRF   03
020EE:  MOVF   00,W
020F0:  MOVWF  01
020F2:  BCF    xC8.4
020F4:  BTFSC  01.0
020F6:  BSF    xC8.4
....................    cmd.fields.reserved = 0; // Reserved bits
020F8:  BCF    xC8.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
020FA:  BCF    xC8.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
020FC:  BCF    xC8.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
020FE:  BCF    xC8.0
.................... 
....................    return cmd.value;
02100:  MOVF   xC8,W
02102:  MOVWF  01
02104:  MOVF   xC9,W
02106:  MOVWF  02
02108:  MOVLB  0
0210A:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
031CA:  MOVLB  A
031CC:  MOVF   x6E,W
031CE:  XORLW  00
031D0:  MOVLB  0
031D2:  BTFSC  FD8.2
031D4:  GOTO   31E4
031D8:  XORLW  01
031DA:  BTFSC  FD8.2
031DC:  GOTO   324C
031E0:  GOTO   32B4
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
031E4:  MOVLB  A
031E6:  CLRF   x77
031E8:  CLRF   x76
031EA:  MOVLB  0
031EC:  MOVLB  A
031EE:  MOVF   x77,W
031F0:  SUBWF  x75,W
031F2:  BTFSC  FD8.0
031F4:  BRA    31FC
031F6:  MOVLB  0
031F8:  GOTO   3248
031FC:  MOVLB  0
031FE:  BTFSS  FD8.2
03200:  GOTO   3216
03204:  MOVLB  A
03206:  MOVF   x74,W
03208:  SUBWF  x76,W
0320A:  BTFSS  FD8.0
0320C:  BRA    3214
0320E:  MOVLB  0
03210:  GOTO   3248
03214:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
03216:  MOVLB  A
03218:  MOVF   x72,W
0321A:  ADDWF  x76,W
0321C:  MOVWF  FE9
0321E:  MOVF   x73,W
03220:  ADDWFC x77,W
03222:  MOVWF  FEA
03224:  MOVFF  FEF,A7A
03228:  MOVFF  A7A,A90
0322C:  MOVLW  08
0322E:  MOVWF  x91
03230:  MOVLW  01
03232:  MOVWF  x92
03234:  MOVLB  0
03236:  CALL   23AC
0323A:  MOVLB  A
0323C:  INCF   x76,F
0323E:  BTFSC  FD8.2
03240:  INCF   x77,F
03242:  MOVLB  0
03244:  GOTO   31EC
....................          break;
03248:  GOTO   32B8
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
0324C:  MOVLB  A
0324E:  CLRF   x79
03250:  CLRF   x78
03252:  MOVLB  0
03254:  MOVLB  A
03256:  MOVF   x79,W
03258:  SUBWF  x75,W
0325A:  BTFSC  FD8.0
0325C:  BRA    3264
0325E:  MOVLB  0
03260:  GOTO   32B0
03264:  MOVLB  0
03266:  BTFSS  FD8.2
03268:  GOTO   327E
0326C:  MOVLB  A
0326E:  MOVF   x74,W
03270:  SUBWF  x78,W
03272:  BTFSS  FD8.0
03274:  BRA    327C
03276:  MOVLB  0
03278:  GOTO   32B0
0327C:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
0327E:  MOVLB  A
03280:  MOVF   x72,W
03282:  ADDWF  x78,W
03284:  MOVWF  FE9
03286:  MOVF   x73,W
03288:  ADDWFC x79,W
0328A:  MOVWF  FEA
0328C:  MOVFF  FEF,A7A
03290:  MOVFF  A7A,A90
03294:  MOVLW  08
03296:  MOVWF  x91
03298:  MOVLW  01
0329A:  MOVWF  x92
0329C:  MOVLB  0
0329E:  CALL   2428
032A2:  MOVLB  A
032A4:  INCF   x78,F
032A6:  BTFSC  FD8.2
032A8:  INCF   x79,F
032AA:  MOVLB  0
032AC:  GOTO   3254
....................          break;
032B0:  GOTO   32B8
....................          
....................       default:
....................          break;
032B4:  GOTO   32B8
....................    }
....................    return;
032B8:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
024A4:  MOVLB  A
024A6:  MOVF   x74,W
024A8:  XORLW  00
024AA:  MOVLB  0
024AC:  BTFSC  FD8.2
024AE:  GOTO   24BE
024B2:  XORLW  01
024B4:  BTFSC  FD8.2
024B6:  GOTO   25C8
024BA:  GOTO   26D2
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
024BE:  MOVLB  A
024C0:  CLRF   x83
024C2:  CLRF   x82
024C4:  MOVLB  0
024C6:  MOVLB  A
024C8:  MOVF   x83,W
024CA:  SUBWF  x7B,W
024CC:  BTFSC  FD8.0
024CE:  BRA    24D6
024D0:  MOVLB  0
024D2:  GOTO   2522
024D6:  MOVLB  0
024D8:  BTFSS  FD8.2
024DA:  GOTO   24F0
024DE:  MOVLB  A
024E0:  MOVF   x7A,W
024E2:  SUBWF  x82,W
024E4:  BTFSS  FD8.0
024E6:  BRA    24EE
024E8:  MOVLB  0
024EA:  GOTO   2522
024EE:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
024F0:  MOVLB  A
024F2:  MOVF   x78,W
024F4:  ADDWF  x82,W
024F6:  MOVWF  FE9
024F8:  MOVF   x79,W
024FA:  ADDWFC x83,W
024FC:  MOVWF  FEA
024FE:  MOVFF  FEF,A8E
02502:  MOVFF  A8E,A90
02506:  MOVLW  08
02508:  MOVWF  x91
0250A:  MOVLW  01
0250C:  MOVWF  x92
0250E:  MOVLB  0
02510:  CALL   23AC
02514:  MOVLB  A
02516:  INCF   x82,F
02518:  BTFSC  FD8.2
0251A:  INCF   x83,F
0251C:  MOVLB  0
0251E:  GOTO   24C6
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02522:  MOVLB  A
02524:  CLRF   x87
02526:  CLRF   x86
02528:  CLRF   x85
0252A:  CLRF   x84
0252C:  MOVLB  0
0252E:  MOVLB  A
02530:  MOVF   x87,W
02532:  SUBWF  x81,W
02534:  BTFSC  FD8.0
02536:  BRA    253E
02538:  MOVLB  0
0253A:  GOTO   25C4
0253E:  MOVLB  0
02540:  BTFSS  FD8.2
02542:  GOTO   2588
02546:  MOVLB  A
02548:  MOVF   x86,W
0254A:  SUBWF  x80,W
0254C:  BTFSC  FD8.0
0254E:  BRA    2556
02550:  MOVLB  0
02552:  GOTO   25C4
02556:  MOVLB  0
02558:  BTFSS  FD8.2
0255A:  GOTO   2588
0255E:  MOVLB  A
02560:  MOVF   x85,W
02562:  SUBWF  x7F,W
02564:  BTFSC  FD8.0
02566:  BRA    256E
02568:  MOVLB  0
0256A:  GOTO   25C4
0256E:  MOVLB  0
02570:  BTFSS  FD8.2
02572:  GOTO   2588
02576:  MOVLB  A
02578:  MOVF   x7E,W
0257A:  SUBWF  x84,W
0257C:  BTFSS  FD8.0
0257E:  BRA    2586
02580:  MOVLB  0
02582:  GOTO   25C4
02586:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
02588:  MOVLB  A
0258A:  MOVF   x7C,W
0258C:  ADDWF  x84,W
0258E:  MOVWF  FE9
02590:  MOVF   x7D,W
02592:  ADDWFC x85,W
02594:  MOVWF  FEA
02596:  MOVLW  02
02598:  MOVWF  x90
0259A:  MOVLW  08
0259C:  MOVWF  x91
0259E:  MOVLW  01
025A0:  MOVWF  x92
025A2:  MOVLB  0
025A4:  CALL   23AC
025A8:  MOVFF  01,FEF
025AC:  MOVLW  01
025AE:  MOVLB  A
025B0:  ADDWF  x84,F
025B2:  BTFSC  FD8.0
025B4:  INCF   x85,F
025B6:  BTFSC  FD8.2
025B8:  INCF   x86,F
025BA:  BTFSC  FD8.2
025BC:  INCF   x87,F
025BE:  MOVLB  0
025C0:  GOTO   252E
....................          break;
025C4:  GOTO   26D6
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025C8:  MOVLB  A
025CA:  CLRF   x89
025CC:  CLRF   x88
025CE:  MOVLB  0
025D0:  MOVLB  A
025D2:  MOVF   x89,W
025D4:  SUBWF  x7B,W
025D6:  BTFSC  FD8.0
025D8:  BRA    25E0
025DA:  MOVLB  0
025DC:  GOTO   262C
025E0:  MOVLB  0
025E2:  BTFSS  FD8.2
025E4:  GOTO   25FA
025E8:  MOVLB  A
025EA:  MOVF   x7A,W
025EC:  SUBWF  x88,W
025EE:  BTFSS  FD8.0
025F0:  BRA    25F8
025F2:  MOVLB  0
025F4:  GOTO   262C
025F8:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
025FA:  MOVLB  A
025FC:  MOVF   x78,W
025FE:  ADDWF  x88,W
02600:  MOVWF  FE9
02602:  MOVF   x79,W
02604:  ADDWFC x89,W
02606:  MOVWF  FEA
02608:  MOVFF  FEF,A8E
0260C:  MOVFF  A8E,A90
02610:  MOVLW  08
02612:  MOVWF  x91
02614:  MOVLW  01
02616:  MOVWF  x92
02618:  MOVLB  0
0261A:  CALL   2428
0261E:  MOVLB  A
02620:  INCF   x88,F
02622:  BTFSC  FD8.2
02624:  INCF   x89,F
02626:  MOVLB  0
02628:  GOTO   25D0
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0262C:  MOVLB  A
0262E:  CLRF   x8D
02630:  CLRF   x8C
02632:  CLRF   x8B
02634:  CLRF   x8A
02636:  MOVLB  0
02638:  MOVLB  A
0263A:  MOVF   x8D,W
0263C:  SUBWF  x81,W
0263E:  BTFSC  FD8.0
02640:  BRA    2648
02642:  MOVLB  0
02644:  GOTO   26CE
02648:  MOVLB  0
0264A:  BTFSS  FD8.2
0264C:  GOTO   2692
02650:  MOVLB  A
02652:  MOVF   x8C,W
02654:  SUBWF  x80,W
02656:  BTFSC  FD8.0
02658:  BRA    2660
0265A:  MOVLB  0
0265C:  GOTO   26CE
02660:  MOVLB  0
02662:  BTFSS  FD8.2
02664:  GOTO   2692
02668:  MOVLB  A
0266A:  MOVF   x8B,W
0266C:  SUBWF  x7F,W
0266E:  BTFSC  FD8.0
02670:  BRA    2678
02672:  MOVLB  0
02674:  GOTO   26CE
02678:  MOVLB  0
0267A:  BTFSS  FD8.2
0267C:  GOTO   2692
02680:  MOVLB  A
02682:  MOVF   x7E,W
02684:  SUBWF  x8A,W
02686:  BTFSS  FD8.0
02688:  BRA    2690
0268A:  MOVLB  0
0268C:  GOTO   26CE
02690:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
02692:  MOVLB  A
02694:  MOVF   x7C,W
02696:  ADDWF  x8A,W
02698:  MOVWF  FE9
0269A:  MOVF   x7D,W
0269C:  ADDWFC x8B,W
0269E:  MOVWF  FEA
026A0:  MOVLW  01
026A2:  MOVWF  x90
026A4:  MOVLW  08
026A6:  MOVWF  x91
026A8:  MOVLW  01
026AA:  MOVWF  x92
026AC:  MOVLB  0
026AE:  CALL   2428
026B2:  MOVFF  01,FEF
026B6:  MOVLW  01
026B8:  MOVLB  A
026BA:  ADDWF  x8A,F
026BC:  BTFSC  FD8.0
026BE:  INCF   x8B,F
026C0:  BTFSC  FD8.2
026C2:  INCF   x8C,F
026C4:  BTFSC  FD8.2
026C6:  INCF   x8D,F
026C8:  MOVLB  0
026CA:  GOTO   2638
....................          break;
026CE:  GOTO   26D6
....................    
....................          
....................       default:
....................          break;
026D2:  GOTO   26D6
....................    }
....................    return;
026D6:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
032BA:  MOVLB  A
032BC:  MOVF   x6E,W
032BE:  XORLW  00
032C0:  MOVLB  0
032C2:  BTFSC  FD8.2
032C4:  GOTO   32D4
032C8:  XORLW  01
032CA:  BTFSC  FD8.2
032CC:  GOTO   3382
032D0:  GOTO   3430
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
032D4:  MOVLB  A
032D6:  CLRF   x79
032D8:  MOVLB  0
032DA:  MOVLB  A
032DC:  MOVF   x74,W
032DE:  SUBWF  x79,W
032E0:  BTFSS  FD8.0
032E2:  BRA    32EA
032E4:  MOVLB  0
032E6:  GOTO   331A
032EA:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
032EC:  MOVLB  A
032EE:  MOVF   x79,W
032F0:  ADDWF  x72,W
032F2:  MOVWF  FE9
032F4:  MOVLW  00
032F6:  ADDWFC x73,W
032F8:  MOVWF  FEA
032FA:  MOVFF  FEF,A7F
032FE:  MOVFF  A7F,A90
03302:  MOVLW  08
03304:  MOVWF  x91
03306:  MOVLW  01
03308:  MOVWF  x92
0330A:  MOVLB  0
0330C:  CALL   23AC
03310:  MOVLB  A
03312:  INCF   x79,F
03314:  MOVLB  0
03316:  GOTO   32DA
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
0331A:  MOVLB  A
0331C:  CLRF   x7B
0331E:  CLRF   x7A
03320:  MOVLB  0
03322:  MOVLB  A
03324:  MOVF   x7B,W
03326:  SUBWF  x78,W
03328:  BTFSC  FD8.0
0332A:  BRA    3332
0332C:  MOVLB  0
0332E:  GOTO   337E
03332:  MOVLB  0
03334:  BTFSS  FD8.2
03336:  GOTO   334C
0333A:  MOVLB  A
0333C:  MOVF   x77,W
0333E:  SUBWF  x7A,W
03340:  BTFSS  FD8.0
03342:  BRA    334A
03344:  MOVLB  0
03346:  GOTO   337E
0334A:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
0334C:  MOVLB  A
0334E:  MOVF   x75,W
03350:  ADDWF  x7A,W
03352:  MOVWF  FE9
03354:  MOVF   x76,W
03356:  ADDWFC x7B,W
03358:  MOVWF  FEA
0335A:  MOVFF  FEF,A7F
0335E:  MOVFF  A7F,A90
03362:  MOVLW  08
03364:  MOVWF  x91
03366:  MOVLW  01
03368:  MOVWF  x92
0336A:  MOVLB  0
0336C:  CALL   23AC
03370:  MOVLB  A
03372:  INCF   x7A,F
03374:  BTFSC  FD8.2
03376:  INCF   x7B,F
03378:  MOVLB  0
0337A:  GOTO   3322
....................          break;
0337E:  GOTO   3434
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
03382:  MOVLB  A
03384:  CLRF   x7C
03386:  MOVLB  0
03388:  MOVLB  A
0338A:  MOVF   x74,W
0338C:  SUBWF  x7C,W
0338E:  BTFSS  FD8.0
03390:  BRA    3398
03392:  MOVLB  0
03394:  GOTO   33C8
03398:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
0339A:  MOVLB  A
0339C:  MOVF   x7C,W
0339E:  ADDWF  x72,W
033A0:  MOVWF  FE9
033A2:  MOVLW  00
033A4:  ADDWFC x73,W
033A6:  MOVWF  FEA
033A8:  MOVFF  FEF,A7F
033AC:  MOVFF  A7F,A90
033B0:  MOVLW  08
033B2:  MOVWF  x91
033B4:  MOVLW  01
033B6:  MOVWF  x92
033B8:  MOVLB  0
033BA:  CALL   2428
033BE:  MOVLB  A
033C0:  INCF   x7C,F
033C2:  MOVLB  0
033C4:  GOTO   3388
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
033C8:  MOVLB  A
033CA:  CLRF   x7E
033CC:  CLRF   x7D
033CE:  MOVLB  0
033D0:  MOVLB  A
033D2:  MOVF   x7E,W
033D4:  SUBWF  x78,W
033D6:  BTFSC  FD8.0
033D8:  BRA    33E0
033DA:  MOVLB  0
033DC:  GOTO   342C
033E0:  MOVLB  0
033E2:  BTFSS  FD8.2
033E4:  GOTO   33FA
033E8:  MOVLB  A
033EA:  MOVF   x77,W
033EC:  SUBWF  x7D,W
033EE:  BTFSS  FD8.0
033F0:  BRA    33F8
033F2:  MOVLB  0
033F4:  GOTO   342C
033F8:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
033FA:  MOVLB  A
033FC:  MOVF   x75,W
033FE:  ADDWF  x7D,W
03400:  MOVWF  FE9
03402:  MOVF   x76,W
03404:  ADDWFC x7E,W
03406:  MOVWF  FEA
03408:  MOVFF  FEF,A7F
0340C:  MOVFF  A7F,A90
03410:  MOVLW  08
03412:  MOVWF  x91
03414:  MOVLW  01
03416:  MOVWF  x92
03418:  MOVLB  0
0341A:  CALL   2428
0341E:  MOVLB  A
03420:  INCF   x7D,F
03422:  BTFSC  FD8.2
03424:  INCF   x7E,F
03426:  MOVLB  0
03428:  GOTO   33D0
....................          break;
0342C:  GOTO   3434
....................          
....................       default:
....................          break;
03430:  GOTO   3434
....................    }
....................    return;
03434:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
05474:  MOVFF  29A,A74
05478:  MOVLW  01
0547A:  MOVLB  A
0547C:  MOVWF  x75
0547E:  MOVLW  0F
05480:  MOVWF  x77
05482:  MOVLW  89
05484:  MOVWF  x76
05486:  MOVLB  0
05488:  CALL   2358
0548C:  MOVFF  29A,A74
05490:  MOVLB  A
05492:  CLRF   x75
05494:  MOVLW  0F
05496:  MOVWF  x77
05498:  MOVLW  92
0549A:  MOVWF  x76
0549C:  MOVLB  0
0549E:  CALL   2358
054A2:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
03436:  MOVLW  05
03438:  MOVLB  A
0343A:  MOVWF  x72
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
0343C:  MOVFF  A70,A74
03440:  CLRF   x75
03442:  MOVLW  0F
03444:  MOVWF  x77
03446:  MOVLW  89
03448:  MOVWF  x76
0344A:  MOVLB  0
0344C:  CALL   2358
03450:  MOVFF  A70,A74
03454:  MOVLB  A
03456:  CLRF   x75
03458:  MOVLW  0F
0345A:  MOVWF  x77
0345C:  MOVLW  92
0345E:  MOVWF  x76
03460:  MOVLB  0
03462:  CALL   2358
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
03466:  MOVFF  A71,A77
0346A:  MOVFF  A70,A76
0346E:  MOVFF  A6F,A75
03472:  MOVFF  A6E,A74
03476:  MOVLW  0A
03478:  MOVLB  A
0347A:  MOVWF  x79
0347C:  MOVLW  72
0347E:  MOVWF  x78
03480:  CLRF   x7B
03482:  MOVLW  01
03484:  MOVWF  x7A
03486:  MOVLW  0A
03488:  MOVWF  x7D
0348A:  MOVLW  73
0348C:  MOVWF  x7C
0348E:  CLRF   x81
03490:  CLRF   x80
03492:  CLRF   x7F
03494:  MOVLW  01
03496:  MOVWF  x7E
03498:  MOVLB  0
0349A:  CALL   24A4
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
0349E:  MOVFF  A70,A74
034A2:  MOVLW  01
034A4:  MOVLB  A
034A6:  MOVWF  x75
034A8:  MOVLW  0F
034AA:  MOVWF  x77
034AC:  MOVLW  89
034AE:  MOVWF  x76
034B0:  MOVLB  0
034B2:  CALL   2358
034B6:  MOVFF  A70,A74
034BA:  MOVLB  A
034BC:  CLRF   x75
034BE:  MOVLW  0F
034C0:  MOVWF  x77
034C2:  MOVLW  92
034C4:  MOVWF  x76
034C6:  MOVLB  0
034C8:  CALL   2358
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
034CC:  MOVLB  A
034CE:  MOVF   x73,W
034D0:  MOVWF  01
034D2:  MOVLB  0
034D4:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
03BB2:  MOVLB  A
03BB4:  MOVF   x57,F
03BB6:  BTFSC  FD8.2
03BB8:  BRA    3BC0
03BBA:  MOVLB  0
03BBC:  GOTO   3D16
03BC0:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
03BC2:  MOVLW  06
03BC4:  MOVLB  A
03BC6:  MOVWF  x5E
03BC8:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
03BCA:  MOVLW  D8
03BCC:  MOVLB  A
03BCE:  MOVWF  x5F
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03BD0:  MOVFF  A5C,A6B
03BD4:  MOVFF  A5D,A6C
03BD8:  CLRF   x6D
03BDA:  CLRF   x6E
03BDC:  MOVF   x6B,W
03BDE:  MOVWF  00
03BE0:  CLRF   01
03BE2:  CLRF   02
03BE4:  CLRF   03
03BE6:  MOVFF  00,A60
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03BEA:  MOVFF  A5B,A6B
03BEE:  MOVFF  A5C,A6C
03BF2:  MOVFF  A5D,A6D
03BF6:  CLRF   x6E
03BF8:  MOVF   x6B,W
03BFA:  MOVWF  00
03BFC:  CLRF   01
03BFE:  CLRF   02
03C00:  CLRF   03
03C02:  MOVFF  00,A61
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
03C06:  MOVF   x5A,W
03C08:  MOVWF  00
03C0A:  CLRF   01
03C0C:  CLRF   02
03C0E:  CLRF   03
03C10:  MOVFF  00,A62
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03C14:  MOVFF  A58,A74
03C18:  CLRF   x75
03C1A:  MOVLW  0F
03C1C:  MOVWF  x77
03C1E:  MOVLW  89
03C20:  MOVWF  x76
03C22:  MOVLB  0
03C24:  CALL   2358
03C28:  MOVFF  A58,A74
03C2C:  MOVLB  A
03C2E:  CLRF   x75
03C30:  MOVLW  0F
03C32:  MOVWF  x77
03C34:  MOVLW  92
03C36:  MOVWF  x76
03C38:  MOVLB  0
03C3A:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03C3E:  MOVFF  A59,A71
03C42:  MOVFF  A58,A70
03C46:  MOVFF  A57,A6F
03C4A:  MOVFF  A56,A6E
03C4E:  MOVLW  0A
03C50:  MOVLB  A
03C52:  MOVWF  x73
03C54:  MOVLW  5E
03C56:  MOVWF  x72
03C58:  CLRF   x75
03C5A:  MOVLW  01
03C5C:  MOVWF  x74
03C5E:  MOVLB  0
03C60:  CALL   31CA
....................       output_high(flash_stream.cs_pin);
03C64:  MOVFF  A58,A74
03C68:  MOVLW  01
03C6A:  MOVLB  A
03C6C:  MOVWF  x75
03C6E:  MOVLW  0F
03C70:  MOVWF  x77
03C72:  MOVLW  89
03C74:  MOVWF  x76
03C76:  MOVLB  0
03C78:  CALL   2358
03C7C:  MOVFF  A58,A74
03C80:  MOVLB  A
03C82:  CLRF   x75
03C84:  MOVLW  0F
03C86:  MOVWF  x77
03C88:  MOVLW  92
03C8A:  MOVWF  x76
03C8C:  MOVLB  0
03C8E:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03C92:  MOVFF  A58,A74
03C96:  MOVLB  A
03C98:  CLRF   x75
03C9A:  MOVLW  0F
03C9C:  MOVWF  x77
03C9E:  MOVLW  89
03CA0:  MOVWF  x76
03CA2:  MOVLB  0
03CA4:  CALL   2358
03CA8:  MOVFF  A58,A74
03CAC:  MOVLB  A
03CAE:  CLRF   x75
03CB0:  MOVLW  0F
03CB2:  MOVWF  x77
03CB4:  MOVLW  92
03CB6:  MOVWF  x76
03CB8:  MOVLB  0
03CBA:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
03CBE:  MOVFF  A59,A71
03CC2:  MOVFF  A58,A70
03CC6:  MOVFF  A57,A6F
03CCA:  MOVFF  A56,A6E
03CCE:  MOVLW  0A
03CD0:  MOVLB  A
03CD2:  MOVWF  x73
03CD4:  MOVLW  5F
03CD6:  MOVWF  x72
03CD8:  CLRF   x75
03CDA:  MOVLW  04
03CDC:  MOVWF  x74
03CDE:  MOVLB  0
03CE0:  CALL   31CA
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03CE4:  MOVFF  A58,A74
03CE8:  MOVLW  01
03CEA:  MOVLB  A
03CEC:  MOVWF  x75
03CEE:  MOVLW  0F
03CF0:  MOVWF  x77
03CF2:  MOVLW  89
03CF4:  MOVWF  x76
03CF6:  MOVLB  0
03CF8:  CALL   2358
03CFC:  MOVFF  A58,A74
03D00:  MOVLB  A
03D02:  CLRF   x75
03D04:  MOVLW  0F
03D06:  MOVWF  x77
03D08:  MOVLW  92
03D0A:  MOVWF  x76
03D0C:  MOVLB  0
03D0E:  CALL   2358
....................    }
03D12:  GOTO   3E94
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
03D16:  MOVLB  A
03D18:  DECFSZ x57,W
03D1A:  BRA    3D20
03D1C:  BRA    3D26
03D1E:  MOVLB  0
03D20:  MOVLB  0
03D22:  GOTO   3E94
03D26:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
03D28:  MOVLW  06
03D2A:  MOVLB  A
03D2C:  MOVWF  x63
03D2E:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
03D30:  MOVLW  DC
03D32:  MOVLB  A
03D34:  MOVWF  x64
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
03D36:  MOVFF  A5D,A6B
03D3A:  CLRF   x6C
03D3C:  CLRF   x6D
03D3E:  CLRF   x6E
03D40:  MOVF   x6B,W
03D42:  MOVWF  00
03D44:  CLRF   01
03D46:  CLRF   02
03D48:  CLRF   03
03D4A:  MOVFF  00,A65
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03D4E:  MOVFF  A5C,A6B
03D52:  MOVFF  A5D,A6C
03D56:  CLRF   x6D
03D58:  CLRF   x6E
03D5A:  MOVF   x6B,W
03D5C:  MOVWF  00
03D5E:  CLRF   01
03D60:  CLRF   02
03D62:  CLRF   03
03D64:  MOVFF  00,A66
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03D68:  MOVFF  A5B,A6B
03D6C:  MOVFF  A5C,A6C
03D70:  MOVFF  A5D,A6D
03D74:  CLRF   x6E
03D76:  MOVF   x6B,W
03D78:  MOVWF  00
03D7A:  CLRF   01
03D7C:  CLRF   02
03D7E:  CLRF   03
03D80:  MOVFF  00,A67
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
03D84:  MOVF   x5A,W
03D86:  MOVWF  00
03D88:  CLRF   01
03D8A:  CLRF   02
03D8C:  CLRF   03
03D8E:  MOVFF  00,A68
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03D92:  MOVFF  A58,A74
03D96:  CLRF   x75
03D98:  MOVLW  0F
03D9A:  MOVWF  x77
03D9C:  MOVLW  89
03D9E:  MOVWF  x76
03DA0:  MOVLB  0
03DA2:  CALL   2358
03DA6:  MOVFF  A58,A74
03DAA:  MOVLB  A
03DAC:  CLRF   x75
03DAE:  MOVLW  0F
03DB0:  MOVWF  x77
03DB2:  MOVLW  92
03DB4:  MOVWF  x76
03DB6:  MOVLB  0
03DB8:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03DBC:  MOVFF  A59,A71
03DC0:  MOVFF  A58,A70
03DC4:  MOVFF  A57,A6F
03DC8:  MOVFF  A56,A6E
03DCC:  MOVLW  0A
03DCE:  MOVLB  A
03DD0:  MOVWF  x73
03DD2:  MOVLW  63
03DD4:  MOVWF  x72
03DD6:  CLRF   x75
03DD8:  MOVLW  01
03DDA:  MOVWF  x74
03DDC:  MOVLB  0
03DDE:  CALL   31CA
....................       output_high(flash_stream.cs_pin);
03DE2:  MOVFF  A58,A74
03DE6:  MOVLW  01
03DE8:  MOVLB  A
03DEA:  MOVWF  x75
03DEC:  MOVLW  0F
03DEE:  MOVWF  x77
03DF0:  MOVLW  89
03DF2:  MOVWF  x76
03DF4:  MOVLB  0
03DF6:  CALL   2358
03DFA:  MOVFF  A58,A74
03DFE:  MOVLB  A
03E00:  CLRF   x75
03E02:  MOVLW  0F
03E04:  MOVWF  x77
03E06:  MOVLW  92
03E08:  MOVWF  x76
03E0A:  MOVLB  0
03E0C:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03E10:  MOVFF  A58,A74
03E14:  MOVLB  A
03E16:  CLRF   x75
03E18:  MOVLW  0F
03E1A:  MOVWF  x77
03E1C:  MOVLW  89
03E1E:  MOVWF  x76
03E20:  MOVLB  0
03E22:  CALL   2358
03E26:  MOVFF  A58,A74
03E2A:  MOVLB  A
03E2C:  CLRF   x75
03E2E:  MOVLW  0F
03E30:  MOVWF  x77
03E32:  MOVLW  92
03E34:  MOVWF  x76
03E36:  MOVLB  0
03E38:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
03E3C:  MOVFF  A59,A71
03E40:  MOVFF  A58,A70
03E44:  MOVFF  A57,A6F
03E48:  MOVFF  A56,A6E
03E4C:  MOVLW  0A
03E4E:  MOVLB  A
03E50:  MOVWF  x73
03E52:  MOVLW  64
03E54:  MOVWF  x72
03E56:  CLRF   x75
03E58:  MOVLW  05
03E5A:  MOVWF  x74
03E5C:  MOVLB  0
03E5E:  CALL   31CA
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03E62:  MOVFF  A58,A74
03E66:  MOVLW  01
03E68:  MOVLB  A
03E6A:  MOVWF  x75
03E6C:  MOVLW  0F
03E6E:  MOVWF  x77
03E70:  MOVLW  89
03E72:  MOVWF  x76
03E74:  MOVLB  0
03E76:  CALL   2358
03E7A:  MOVFF  A58,A74
03E7E:  MOVLB  A
03E80:  CLRF   x75
03E82:  MOVLW  0F
03E84:  MOVWF  x77
03E86:  MOVLW  92
03E88:  MOVWF  x76
03E8A:  MOVLB  0
03E8C:  CALL   2358
....................    }
03E90:  GOTO   3E94
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
03E94:  MOVLB  A
03E96:  CLRF   x69
03E98:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
03E9A:  MOVFF  A59,A71
03E9E:  MOVFF  A58,A70
03EA2:  MOVFF  A57,A6F
03EA6:  MOVFF  A56,A6E
03EAA:  CALL   3436
03EAE:  MOVF   01,W
03EB0:  ANDLW  01
03EB2:  SUBLW  01
03EB4:  BTFSS  FD8.2
03EB6:  GOTO   3F08
....................       if(timeout_counter > 10)
03EBA:  MOVLB  A
03EBC:  MOVF   x69,W
03EBE:  SUBLW  0A
03EC0:  BTFSS  FD8.0
03EC2:  BRA    3ECA
03EC4:  MOVLB  0
03EC6:  GOTO   3EDC
03ECA:  MOVLB  0
....................          delay_ms(200);
03ECC:  MOVLW  C8
03ECE:  MOVLB  A
03ED0:  MOVWF  x6E
03ED2:  MOVLB  0
03ED4:  CALL   1B3E
03ED8:  GOTO   3EE8
....................       else
....................          delay_ms(10);   
03EDC:  MOVLW  0A
03EDE:  MOVLB  A
03EE0:  MOVWF  x6E
03EE2:  MOVLB  0
03EE4:  CALL   1B3E
....................       
....................       if(timeout_counter > 100){
03EE8:  MOVLB  A
03EEA:  MOVF   x69,W
03EEC:  SUBLW  64
03EEE:  BTFSS  FD8.0
03EF0:  BRA    3EF8
03EF2:  MOVLB  0
03EF4:  GOTO   3EFE
03EF8:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
03EFA:  GOTO   3F08
....................       }  
....................       timeout_counter++;
03EFE:  MOVLB  A
03F00:  INCF   x69,F
03F02:  MOVLB  0
03F04:  GOTO   3E9A
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
03F08:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
04A4A:  MOVLB  2
04A4C:  MOVF   xE3,F
04A4E:  BTFSC  FD8.2
04A50:  BRA    4A58
04A52:  MOVLB  0
04A54:  GOTO   4BB0
04A58:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
04A5A:  MOVLW  06
04A5C:  MOVLB  2
04A5E:  MOVWF  xEA
04A60:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
04A62:  MOVLW  20
04A64:  MOVLB  2
04A66:  MOVWF  xEB
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04A68:  MOVFF  2E8,2F7
04A6C:  MOVFF  2E9,2F8
04A70:  CLRF   xF9
04A72:  CLRF   xFA
04A74:  MOVF   xF7,W
04A76:  MOVWF  00
04A78:  CLRF   01
04A7A:  CLRF   02
04A7C:  CLRF   03
04A7E:  MOVFF  00,2EC
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04A82:  MOVFF  2E7,2F7
04A86:  MOVFF  2E8,2F8
04A8A:  MOVFF  2E9,2F9
04A8E:  CLRF   xFA
04A90:  MOVF   xF7,W
04A92:  MOVWF  00
04A94:  CLRF   01
04A96:  CLRF   02
04A98:  CLRF   03
04A9A:  MOVFF  00,2ED
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04A9E:  MOVF   xE6,W
04AA0:  MOVWF  00
04AA2:  CLRF   01
04AA4:  CLRF   02
04AA6:  CLRF   03
04AA8:  MOVFF  00,2EE
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04AAC:  MOVFF  2E4,A74
04AB0:  MOVLB  A
04AB2:  CLRF   x75
04AB4:  MOVLW  0F
04AB6:  MOVWF  x77
04AB8:  MOVLW  89
04ABA:  MOVWF  x76
04ABC:  MOVLB  0
04ABE:  CALL   2358
04AC2:  MOVFF  2E4,A74
04AC6:  MOVLB  A
04AC8:  CLRF   x75
04ACA:  MOVLW  0F
04ACC:  MOVWF  x77
04ACE:  MOVLW  92
04AD0:  MOVWF  x76
04AD2:  MOVLB  0
04AD4:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04AD8:  MOVFF  2E5,A71
04ADC:  MOVFF  2E4,A70
04AE0:  MOVFF  2E3,A6F
04AE4:  MOVFF  2E2,A6E
04AE8:  MOVLW  02
04AEA:  MOVLB  A
04AEC:  MOVWF  x73
04AEE:  MOVLW  EA
04AF0:  MOVWF  x72
04AF2:  CLRF   x75
04AF4:  MOVLW  01
04AF6:  MOVWF  x74
04AF8:  MOVLB  0
04AFA:  CALL   31CA
....................       output_high(flash_stream.cs_pin);
04AFE:  MOVFF  2E4,A74
04B02:  MOVLW  01
04B04:  MOVLB  A
04B06:  MOVWF  x75
04B08:  MOVLW  0F
04B0A:  MOVWF  x77
04B0C:  MOVLW  89
04B0E:  MOVWF  x76
04B10:  MOVLB  0
04B12:  CALL   2358
04B16:  MOVFF  2E4,A74
04B1A:  MOVLB  A
04B1C:  CLRF   x75
04B1E:  MOVLW  0F
04B20:  MOVWF  x77
04B22:  MOVLW  92
04B24:  MOVWF  x76
04B26:  MOVLB  0
04B28:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04B2C:  MOVFF  2E4,A74
04B30:  MOVLB  A
04B32:  CLRF   x75
04B34:  MOVLW  0F
04B36:  MOVWF  x77
04B38:  MOVLW  89
04B3A:  MOVWF  x76
04B3C:  MOVLB  0
04B3E:  CALL   2358
04B42:  MOVFF  2E4,A74
04B46:  MOVLB  A
04B48:  CLRF   x75
04B4A:  MOVLW  0F
04B4C:  MOVWF  x77
04B4E:  MOVLW  92
04B50:  MOVWF  x76
04B52:  MOVLB  0
04B54:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
04B58:  MOVFF  2E5,A71
04B5C:  MOVFF  2E4,A70
04B60:  MOVFF  2E3,A6F
04B64:  MOVFF  2E2,A6E
04B68:  MOVLW  02
04B6A:  MOVLB  A
04B6C:  MOVWF  x73
04B6E:  MOVLW  EB
04B70:  MOVWF  x72
04B72:  CLRF   x75
04B74:  MOVLW  04
04B76:  MOVWF  x74
04B78:  MOVLB  0
04B7A:  CALL   31CA
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04B7E:  MOVFF  2E4,A74
04B82:  MOVLW  01
04B84:  MOVLB  A
04B86:  MOVWF  x75
04B88:  MOVLW  0F
04B8A:  MOVWF  x77
04B8C:  MOVLW  89
04B8E:  MOVWF  x76
04B90:  MOVLB  0
04B92:  CALL   2358
04B96:  MOVFF  2E4,A74
04B9A:  MOVLB  A
04B9C:  CLRF   x75
04B9E:  MOVLW  0F
04BA0:  MOVWF  x77
04BA2:  MOVLW  92
04BA4:  MOVWF  x76
04BA6:  MOVLB  0
04BA8:  CALL   2358
....................    }
04BAC:  GOTO   4D30
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04BB0:  MOVLB  2
04BB2:  DECFSZ xE3,W
04BB4:  BRA    4BBA
04BB6:  BRA    4BC0
04BB8:  MOVLB  0
04BBA:  MOVLB  0
04BBC:  GOTO   4D30
04BC0:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04BC2:  MOVLW  06
04BC4:  MOVLB  2
04BC6:  MOVWF  xEF
04BC8:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
04BCA:  MOVLW  21
04BCC:  MOVLB  2
04BCE:  MOVWF  xF0
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04BD0:  MOVFF  2E9,2F7
04BD4:  CLRF   xF8
04BD6:  CLRF   xF9
04BD8:  CLRF   xFA
04BDA:  MOVF   xF7,W
04BDC:  MOVWF  00
04BDE:  CLRF   01
04BE0:  CLRF   02
04BE2:  CLRF   03
04BE4:  MOVFF  00,2F1
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04BE8:  MOVFF  2E8,2F7
04BEC:  MOVFF  2E9,2F8
04BF0:  CLRF   xF9
04BF2:  CLRF   xFA
04BF4:  MOVF   xF7,W
04BF6:  MOVWF  00
04BF8:  CLRF   01
04BFA:  CLRF   02
04BFC:  CLRF   03
04BFE:  MOVFF  00,2F2
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04C02:  MOVFF  2E7,2F7
04C06:  MOVFF  2E8,2F8
04C0A:  MOVFF  2E9,2F9
04C0E:  CLRF   xFA
04C10:  MOVF   xF7,W
04C12:  MOVWF  00
04C14:  CLRF   01
04C16:  CLRF   02
04C18:  CLRF   03
04C1A:  MOVFF  00,2F3
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04C1E:  MOVF   xE6,W
04C20:  MOVWF  00
04C22:  CLRF   01
04C24:  CLRF   02
04C26:  CLRF   03
04C28:  MOVFF  00,2F4
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04C2C:  MOVFF  2E4,A74
04C30:  MOVLB  A
04C32:  CLRF   x75
04C34:  MOVLW  0F
04C36:  MOVWF  x77
04C38:  MOVLW  89
04C3A:  MOVWF  x76
04C3C:  MOVLB  0
04C3E:  CALL   2358
04C42:  MOVFF  2E4,A74
04C46:  MOVLB  A
04C48:  CLRF   x75
04C4A:  MOVLW  0F
04C4C:  MOVWF  x77
04C4E:  MOVLW  92
04C50:  MOVWF  x76
04C52:  MOVLB  0
04C54:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04C58:  MOVFF  2E5,A71
04C5C:  MOVFF  2E4,A70
04C60:  MOVFF  2E3,A6F
04C64:  MOVFF  2E2,A6E
04C68:  MOVLW  02
04C6A:  MOVLB  A
04C6C:  MOVWF  x73
04C6E:  MOVLW  EF
04C70:  MOVWF  x72
04C72:  CLRF   x75
04C74:  MOVLW  01
04C76:  MOVWF  x74
04C78:  MOVLB  0
04C7A:  CALL   31CA
....................       output_high(flash_stream.cs_pin);
04C7E:  MOVFF  2E4,A74
04C82:  MOVLW  01
04C84:  MOVLB  A
04C86:  MOVWF  x75
04C88:  MOVLW  0F
04C8A:  MOVWF  x77
04C8C:  MOVLW  89
04C8E:  MOVWF  x76
04C90:  MOVLB  0
04C92:  CALL   2358
04C96:  MOVFF  2E4,A74
04C9A:  MOVLB  A
04C9C:  CLRF   x75
04C9E:  MOVLW  0F
04CA0:  MOVWF  x77
04CA2:  MOVLW  92
04CA4:  MOVWF  x76
04CA6:  MOVLB  0
04CA8:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04CAC:  MOVFF  2E4,A74
04CB0:  MOVLB  A
04CB2:  CLRF   x75
04CB4:  MOVLW  0F
04CB6:  MOVWF  x77
04CB8:  MOVLW  89
04CBA:  MOVWF  x76
04CBC:  MOVLB  0
04CBE:  CALL   2358
04CC2:  MOVFF  2E4,A74
04CC6:  MOVLB  A
04CC8:  CLRF   x75
04CCA:  MOVLW  0F
04CCC:  MOVWF  x77
04CCE:  MOVLW  92
04CD0:  MOVWF  x76
04CD2:  MOVLB  0
04CD4:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04CD8:  MOVFF  2E5,A71
04CDC:  MOVFF  2E4,A70
04CE0:  MOVFF  2E3,A6F
04CE4:  MOVFF  2E2,A6E
04CE8:  MOVLW  02
04CEA:  MOVLB  A
04CEC:  MOVWF  x73
04CEE:  MOVLW  F0
04CF0:  MOVWF  x72
04CF2:  CLRF   x75
04CF4:  MOVLW  05
04CF6:  MOVWF  x74
04CF8:  MOVLB  0
04CFA:  CALL   31CA
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04CFE:  MOVFF  2E4,A74
04D02:  MOVLW  01
04D04:  MOVLB  A
04D06:  MOVWF  x75
04D08:  MOVLW  0F
04D0A:  MOVWF  x77
04D0C:  MOVLW  89
04D0E:  MOVWF  x76
04D10:  MOVLB  0
04D12:  CALL   2358
04D16:  MOVFF  2E4,A74
04D1A:  MOVLB  A
04D1C:  CLRF   x75
04D1E:  MOVLW  0F
04D20:  MOVWF  x77
04D22:  MOVLW  92
04D24:  MOVWF  x76
04D26:  MOVLB  0
04D28:  CALL   2358
....................    }
04D2C:  GOTO   4D30
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04D30:  MOVLB  2
04D32:  CLRF   xF5
04D34:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
04D36:  MOVFF  2E5,A71
04D3A:  MOVFF  2E4,A70
04D3E:  MOVFF  2E3,A6F
04D42:  MOVFF  2E2,A6E
04D46:  CALL   3436
04D4A:  MOVF   01,W
04D4C:  ANDLW  01
04D4E:  SUBLW  01
04D50:  BTFSS  FD8.2
04D52:  GOTO   4DA4
....................       if(timeout_counter > 10)
04D56:  MOVLB  2
04D58:  MOVF   xF5,W
04D5A:  SUBLW  0A
04D5C:  BTFSS  FD8.0
04D5E:  BRA    4D66
04D60:  MOVLB  0
04D62:  GOTO   4D78
04D66:  MOVLB  0
....................          delay_ms(200);
04D68:  MOVLW  C8
04D6A:  MOVLB  A
04D6C:  MOVWF  x6E
04D6E:  MOVLB  0
04D70:  CALL   1B3E
04D74:  GOTO   4D84
....................       else
....................          delay_ms(10);   
04D78:  MOVLW  0A
04D7A:  MOVLB  A
04D7C:  MOVWF  x6E
04D7E:  MOVLB  0
04D80:  CALL   1B3E
....................       
....................       if(timeout_counter > 100){
04D84:  MOVLB  2
04D86:  MOVF   xF5,W
04D88:  SUBLW  64
04D8A:  BTFSS  FD8.0
04D8C:  BRA    4D94
04D8E:  MOVLB  0
04D90:  GOTO   4D9A
04D94:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
04D96:  GOTO   4DA4
....................       }  
....................       timeout_counter++;
04D9A:  MOVLB  2
04D9C:  INCF   xF5,F
04D9E:  MOVLB  0
04DA0:  GOTO   4D36
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
04DA4:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
027C4:  MOVLB  2
027C6:  MOVF   xE3,F
027C8:  BTFSC  FD8.2
027CA:  BRA    27D2
027CC:  MOVLB  0
027CE:  GOTO   28C4
027D2:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
027D4:  MOVLW  03
027D6:  MOVLB  2
027D8:  MOVWF  xF0
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
027DA:  MOVFF  2E8,2FA
027DE:  MOVFF  2E9,2FB
027E2:  CLRF   xFC
027E4:  CLRF   xFD
027E6:  MOVF   xFA,W
027E8:  MOVWF  00
027EA:  CLRF   01
027EC:  CLRF   02
027EE:  CLRF   03
027F0:  MOVFF  00,2F1
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
027F4:  MOVFF  2E7,2FA
027F8:  MOVFF  2E8,2FB
027FC:  MOVFF  2E9,2FC
02800:  CLRF   xFD
02802:  MOVF   xFA,W
02804:  MOVWF  00
02806:  CLRF   01
02808:  CLRF   02
0280A:  CLRF   03
0280C:  MOVFF  00,2F2
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02810:  MOVF   xE6,W
02812:  MOVWF  00
02814:  CLRF   01
02816:  CLRF   02
02818:  CLRF   03
0281A:  MOVFF  00,2F3
....................             
....................       output_low(flash_stream.cs_pin);
0281E:  MOVFF  2E4,A74
02822:  MOVLB  A
02824:  CLRF   x75
02826:  MOVLW  0F
02828:  MOVWF  x77
0282A:  MOVLW  89
0282C:  MOVWF  x76
0282E:  MOVLB  0
02830:  CALL   2358
02834:  MOVFF  2E4,A74
02838:  MOVLB  A
0283A:  CLRF   x75
0283C:  MOVLW  0F
0283E:  MOVWF  x77
02840:  MOVLW  92
02842:  MOVWF  x76
02844:  MOVLB  0
02846:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
0284A:  MOVFF  2E5,A77
0284E:  MOVFF  2E4,A76
02852:  MOVFF  2E3,A75
02856:  MOVFF  2E2,A74
0285A:  MOVLW  02
0285C:  MOVLB  A
0285E:  MOVWF  x79
02860:  MOVLW  F0
02862:  MOVWF  x78
02864:  CLRF   x7B
02866:  MOVLW  04
02868:  MOVWF  x7A
0286A:  MOVFF  2EB,A7D
0286E:  MOVFF  2EA,A7C
02872:  MOVFF  2EF,A81
02876:  MOVFF  2EE,A80
0287A:  MOVFF  2ED,A7F
0287E:  MOVFF  2EC,A7E
02882:  MOVLB  0
02884:  CALL   24A4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
02888:  MOVLW  02
0288A:  MOVWF  00
0288C:  DECFSZ 00,F
0288E:  BRA    288C
02890:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
02892:  MOVFF  2E4,A74
02896:  MOVLW  01
02898:  MOVLB  A
0289A:  MOVWF  x75
0289C:  MOVLW  0F
0289E:  MOVWF  x77
028A0:  MOVLW  89
028A2:  MOVWF  x76
028A4:  MOVLB  0
028A6:  CALL   2358
028AA:  MOVFF  2E4,A74
028AE:  MOVLB  A
028B0:  CLRF   x75
028B2:  MOVLW  0F
028B4:  MOVWF  x77
028B6:  MOVLW  92
028B8:  MOVWF  x76
028BA:  MOVLB  0
028BC:  CALL   2358
....................    }
028C0:  GOTO   29DA
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
028C4:  MOVLB  2
028C6:  DECFSZ xE3,W
028C8:  BRA    28CE
028CA:  BRA    28D4
028CC:  MOVLB  0
028CE:  MOVLB  0
028D0:  GOTO   29DA
028D4:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
028D6:  MOVLW  13
028D8:  MOVLB  2
028DA:  MOVWF  xF4
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
028DC:  MOVFF  2E9,2FA
028E0:  CLRF   xFB
028E2:  CLRF   xFC
028E4:  CLRF   xFD
028E6:  MOVF   xFA,W
028E8:  MOVWF  00
028EA:  CLRF   01
028EC:  CLRF   02
028EE:  CLRF   03
028F0:  MOVFF  00,2F5
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
028F4:  MOVFF  2E8,2FA
028F8:  MOVFF  2E9,2FB
028FC:  CLRF   xFC
028FE:  CLRF   xFD
02900:  MOVF   xFA,W
02902:  MOVWF  00
02904:  CLRF   01
02906:  CLRF   02
02908:  CLRF   03
0290A:  MOVFF  00,2F6
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0290E:  MOVFF  2E7,2FA
02912:  MOVFF  2E8,2FB
02916:  MOVFF  2E9,2FC
0291A:  CLRF   xFD
0291C:  MOVF   xFA,W
0291E:  MOVWF  00
02920:  CLRF   01
02922:  CLRF   02
02924:  CLRF   03
02926:  MOVFF  00,2F7
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
0292A:  MOVF   xE6,W
0292C:  MOVWF  00
0292E:  CLRF   01
02930:  CLRF   02
02932:  CLRF   03
02934:  MOVFF  00,2F8
....................    
....................       output_low(flash_stream.cs_pin);
02938:  MOVFF  2E4,A74
0293C:  MOVLB  A
0293E:  CLRF   x75
02940:  MOVLW  0F
02942:  MOVWF  x77
02944:  MOVLW  89
02946:  MOVWF  x76
02948:  MOVLB  0
0294A:  CALL   2358
0294E:  MOVFF  2E4,A74
02952:  MOVLB  A
02954:  CLRF   x75
02956:  MOVLW  0F
02958:  MOVWF  x77
0295A:  MOVLW  92
0295C:  MOVWF  x76
0295E:  MOVLB  0
02960:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02964:  MOVFF  2E5,A77
02968:  MOVFF  2E4,A76
0296C:  MOVFF  2E3,A75
02970:  MOVFF  2E2,A74
02974:  MOVLW  02
02976:  MOVLB  A
02978:  MOVWF  x79
0297A:  MOVLW  F4
0297C:  MOVWF  x78
0297E:  CLRF   x7B
02980:  MOVLW  05
02982:  MOVWF  x7A
02984:  MOVFF  2EB,A7D
02988:  MOVFF  2EA,A7C
0298C:  MOVFF  2EF,A81
02990:  MOVFF  2EE,A80
02994:  MOVFF  2ED,A7F
02998:  MOVFF  2EC,A7E
0299C:  MOVLB  0
0299E:  CALL   24A4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029A2:  MOVLW  02
029A4:  MOVWF  00
029A6:  DECFSZ 00,F
029A8:  BRA    29A6
029AA:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029AC:  MOVFF  2E4,A74
029B0:  MOVLW  01
029B2:  MOVLB  A
029B4:  MOVWF  x75
029B6:  MOVLW  0F
029B8:  MOVWF  x77
029BA:  MOVLW  89
029BC:  MOVWF  x76
029BE:  MOVLB  0
029C0:  CALL   2358
029C4:  MOVFF  2E4,A74
029C8:  MOVLB  A
029CA:  CLRF   x75
029CC:  MOVLW  0F
029CE:  MOVWF  x77
029D0:  MOVLW  92
029D2:  MOVWF  x76
029D4:  MOVLB  0
029D6:  CALL   2358
....................    }
....................    return;
029DA:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
034D6:  MOVLB  A
034D8:  MOVF   x57,F
034DA:  BTFSC  FD8.2
034DC:  BRA    34E4
034DE:  MOVLB  0
034E0:  GOTO   3652
034E4:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
034E6:  MOVLW  06
034E8:  MOVLB  A
034EA:  MOVWF  x62
034EC:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
034EE:  MOVLW  02
034F0:  MOVLB  A
034F2:  MOVWF  x63
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
034F4:  MOVFF  A5C,A6F
034F8:  MOVFF  A5D,A70
034FC:  CLRF   x71
034FE:  CLRF   x72
03500:  MOVF   x6F,W
03502:  MOVWF  00
03504:  CLRF   01
03506:  CLRF   02
03508:  CLRF   03
0350A:  MOVFF  00,A64
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0350E:  MOVFF  A5B,A6F
03512:  MOVFF  A5C,A70
03516:  MOVFF  A5D,A71
0351A:  CLRF   x72
0351C:  MOVF   x6F,W
0351E:  MOVWF  00
03520:  CLRF   01
03522:  CLRF   02
03524:  CLRF   03
03526:  MOVFF  00,A65
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
0352A:  MOVF   x5A,W
0352C:  MOVWF  00
0352E:  CLRF   01
03530:  CLRF   02
03532:  CLRF   03
03534:  MOVFF  00,A66
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03538:  MOVFF  A58,A74
0353C:  CLRF   x75
0353E:  MOVLW  0F
03540:  MOVWF  x77
03542:  MOVLW  89
03544:  MOVWF  x76
03546:  MOVLB  0
03548:  CALL   2358
0354C:  MOVFF  A58,A74
03550:  MOVLB  A
03552:  CLRF   x75
03554:  MOVLW  0F
03556:  MOVWF  x77
03558:  MOVLW  92
0355A:  MOVWF  x76
0355C:  MOVLB  0
0355E:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03562:  MOVFF  A59,A71
03566:  MOVFF  A58,A70
0356A:  MOVFF  A57,A6F
0356E:  MOVFF  A56,A6E
03572:  MOVLW  0A
03574:  MOVLB  A
03576:  MOVWF  x73
03578:  MOVLW  62
0357A:  MOVWF  x72
0357C:  CLRF   x75
0357E:  MOVLW  01
03580:  MOVWF  x74
03582:  MOVLB  0
03584:  CALL   31CA
....................       output_high(flash_stream.cs_pin);
03588:  MOVFF  A58,A74
0358C:  MOVLW  01
0358E:  MOVLB  A
03590:  MOVWF  x75
03592:  MOVLW  0F
03594:  MOVWF  x77
03596:  MOVLW  89
03598:  MOVWF  x76
0359A:  MOVLB  0
0359C:  CALL   2358
035A0:  MOVFF  A58,A74
035A4:  MOVLB  A
035A6:  CLRF   x75
035A8:  MOVLW  0F
035AA:  MOVWF  x77
035AC:  MOVLW  92
035AE:  MOVWF  x76
035B0:  MOVLB  0
035B2:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
035B6:  MOVFF  A58,A74
035BA:  MOVLB  A
035BC:  CLRF   x75
035BE:  MOVLW  0F
035C0:  MOVWF  x77
035C2:  MOVLW  89
035C4:  MOVWF  x76
035C6:  MOVLB  0
035C8:  CALL   2358
035CC:  MOVFF  A58,A74
035D0:  MOVLB  A
035D2:  CLRF   x75
035D4:  MOVLW  0F
035D6:  MOVWF  x77
035D8:  MOVLW  92
035DA:  MOVWF  x76
035DC:  MOVLB  0
035DE:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
035E2:  MOVFF  A59,A71
035E6:  MOVFF  A58,A70
035EA:  MOVFF  A57,A6F
035EE:  MOVFF  A56,A6E
035F2:  MOVLW  0A
035F4:  MOVLB  A
035F6:  MOVWF  x73
035F8:  MOVLW  63
035FA:  MOVWF  x72
035FC:  MOVLW  04
035FE:  MOVWF  x74
03600:  MOVFF  A5F,A76
03604:  MOVFF  A5E,A75
03608:  MOVFF  A61,A78
0360C:  MOVFF  A60,A77
03610:  MOVLB  0
03612:  CALL   32BA
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
03616:  MOVLW  02
03618:  MOVWF  00
0361A:  DECFSZ 00,F
0361C:  BRA    361A
0361E:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03620:  MOVFF  A58,A74
03624:  MOVLW  01
03626:  MOVLB  A
03628:  MOVWF  x75
0362A:  MOVLW  0F
0362C:  MOVWF  x77
0362E:  MOVLW  89
03630:  MOVWF  x76
03632:  MOVLB  0
03634:  CALL   2358
03638:  MOVFF  A58,A74
0363C:  MOVLB  A
0363E:  CLRF   x75
03640:  MOVLW  0F
03642:  MOVWF  x77
03644:  MOVLW  92
03646:  MOVWF  x76
03648:  MOVLB  0
0364A:  CALL   2358
....................    }
0364E:  GOTO   37E4
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
03652:  MOVLB  A
03654:  DECFSZ x57,W
03656:  BRA    365C
03658:  BRA    3662
0365A:  MOVLB  0
0365C:  MOVLB  0
0365E:  GOTO   37E4
03662:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
03664:  MOVLW  06
03666:  MOVLB  A
03668:  MOVWF  x67
0366A:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
0366C:  MOVLW  12
0366E:  MOVLB  A
03670:  MOVWF  x68
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
03672:  MOVFF  A5D,A6F
03676:  CLRF   x70
03678:  CLRF   x71
0367A:  CLRF   x72
0367C:  MOVF   x6F,W
0367E:  MOVWF  00
03680:  CLRF   01
03682:  CLRF   02
03684:  CLRF   03
03686:  MOVFF  00,A69
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0368A:  MOVFF  A5C,A6F
0368E:  MOVFF  A5D,A70
03692:  CLRF   x71
03694:  CLRF   x72
03696:  MOVF   x6F,W
03698:  MOVWF  00
0369A:  CLRF   01
0369C:  CLRF   02
0369E:  CLRF   03
036A0:  MOVFF  00,A6A
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
036A4:  MOVFF  A5B,A6F
036A8:  MOVFF  A5C,A70
036AC:  MOVFF  A5D,A71
036B0:  CLRF   x72
036B2:  MOVF   x6F,W
036B4:  MOVWF  00
036B6:  CLRF   01
036B8:  CLRF   02
036BA:  CLRF   03
036BC:  MOVFF  00,A6B
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
036C0:  MOVF   x5A,W
036C2:  MOVWF  00
036C4:  CLRF   01
036C6:  CLRF   02
036C8:  CLRF   03
036CA:  MOVFF  00,A6C
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
036CE:  MOVFF  A58,A74
036D2:  CLRF   x75
036D4:  MOVLW  0F
036D6:  MOVWF  x77
036D8:  MOVLW  89
036DA:  MOVWF  x76
036DC:  MOVLB  0
036DE:  CALL   2358
036E2:  MOVFF  A58,A74
036E6:  MOVLB  A
036E8:  CLRF   x75
036EA:  MOVLW  0F
036EC:  MOVWF  x77
036EE:  MOVLW  92
036F0:  MOVWF  x76
036F2:  MOVLB  0
036F4:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
036F8:  MOVFF  A59,A71
036FC:  MOVFF  A58,A70
03700:  MOVFF  A57,A6F
03704:  MOVFF  A56,A6E
03708:  MOVLW  0A
0370A:  MOVLB  A
0370C:  MOVWF  x73
0370E:  MOVLW  67
03710:  MOVWF  x72
03712:  CLRF   x75
03714:  MOVLW  01
03716:  MOVWF  x74
03718:  MOVLB  0
0371A:  CALL   31CA
....................       output_high(flash_stream.cs_pin);
0371E:  MOVFF  A58,A74
03722:  MOVLW  01
03724:  MOVLB  A
03726:  MOVWF  x75
03728:  MOVLW  0F
0372A:  MOVWF  x77
0372C:  MOVLW  89
0372E:  MOVWF  x76
03730:  MOVLB  0
03732:  CALL   2358
03736:  MOVFF  A58,A74
0373A:  MOVLB  A
0373C:  CLRF   x75
0373E:  MOVLW  0F
03740:  MOVWF  x77
03742:  MOVLW  92
03744:  MOVWF  x76
03746:  MOVLB  0
03748:  CALL   2358
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
0374C:  MOVFF  A58,A74
03750:  MOVLB  A
03752:  CLRF   x75
03754:  MOVLW  0F
03756:  MOVWF  x77
03758:  MOVLW  89
0375A:  MOVWF  x76
0375C:  MOVLB  0
0375E:  CALL   2358
03762:  MOVFF  A58,A74
03766:  MOVLB  A
03768:  CLRF   x75
0376A:  MOVLW  0F
0376C:  MOVWF  x77
0376E:  MOVLW  92
03770:  MOVWF  x76
03772:  MOVLB  0
03774:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
03778:  MOVFF  A59,A71
0377C:  MOVFF  A58,A70
03780:  MOVFF  A57,A6F
03784:  MOVFF  A56,A6E
03788:  MOVLW  0A
0378A:  MOVLB  A
0378C:  MOVWF  x73
0378E:  MOVLW  68
03790:  MOVWF  x72
03792:  MOVLW  05
03794:  MOVWF  x74
03796:  MOVFF  A5F,A76
0379A:  MOVFF  A5E,A75
0379E:  MOVFF  A61,A78
037A2:  MOVFF  A60,A77
037A6:  MOVLB  0
037A8:  CALL   32BA
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
037AC:  MOVLW  02
037AE:  MOVWF  00
037B0:  DECFSZ 00,F
037B2:  BRA    37B0
037B4:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
037B6:  MOVFF  A58,A74
037BA:  MOVLW  01
037BC:  MOVLB  A
037BE:  MOVWF  x75
037C0:  MOVLW  0F
037C2:  MOVWF  x77
037C4:  MOVLW  89
037C6:  MOVWF  x76
037C8:  MOVLB  0
037CA:  CALL   2358
037CE:  MOVFF  A58,A74
037D2:  MOVLB  A
037D4:  CLRF   x75
037D6:  MOVLW  0F
037D8:  MOVWF  x77
037DA:  MOVLW  92
037DC:  MOVWF  x76
037DE:  MOVLB  0
037E0:  CALL   2358
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
037E4:  MOVLB  A
037E6:  CLRF   x6D
037E8:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
037EA:  MOVFF  A59,A71
037EE:  MOVFF  A58,A70
037F2:  MOVFF  A57,A6F
037F6:  MOVFF  A56,A6E
037FA:  CALL   3436
037FE:  MOVF   01,W
03800:  ANDLW  01
03802:  SUBLW  01
03804:  BTFSS  FD8.2
03806:  GOTO   3858
....................       if(timeout_counter > 10)
0380A:  MOVLB  A
0380C:  MOVF   x6D,W
0380E:  SUBLW  0A
03810:  BTFSS  FD8.0
03812:  BRA    381A
03814:  MOVLB  0
03816:  GOTO   382C
0381A:  MOVLB  0
....................          delay_ms(200);
0381C:  MOVLW  C8
0381E:  MOVLB  A
03820:  MOVWF  x6E
03822:  MOVLB  0
03824:  CALL   1B3E
03828:  GOTO   3838
....................       else
....................          delay_ms(10);   
0382C:  MOVLW  0A
0382E:  MOVLB  A
03830:  MOVWF  x6E
03832:  MOVLB  0
03834:  CALL   1B3E
....................       
....................       if(timeout_counter > 100){
03838:  MOVLB  A
0383A:  MOVF   x6D,W
0383C:  SUBLW  64
0383E:  BTFSS  FD8.0
03840:  BRA    3848
03842:  MOVLB  0
03844:  GOTO   384E
03848:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
0384A:  GOTO   3858
....................       }  
....................       timeout_counter++;
0384E:  MOVLB  A
03850:  INCF   x6D,F
03852:  MOVLB  0
03854:  GOTO   37EA
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
03858:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
026D8:  MOVLW  9F
026DA:  MOVLB  2
026DC:  MOVWF  x78
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
026DE:  MOVFF  262,A74
026E2:  MOVLB  A
026E4:  CLRF   x75
026E6:  MOVLW  0F
026E8:  MOVWF  x77
026EA:  MOVLW  89
026EC:  MOVWF  x76
026EE:  MOVLB  0
026F0:  CALL   2358
026F4:  MOVFF  262,A74
026F8:  MOVLB  A
026FA:  CLRF   x75
026FC:  MOVLW  0F
026FE:  MOVWF  x77
02700:  MOVLW  92
02702:  MOVWF  x76
02704:  MOVLB  0
02706:  CALL   2358
....................    delay_us(10);  
0270A:  MOVLW  0D
0270C:  MOVWF  00
0270E:  DECFSZ 00,F
02710:  BRA    270E
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
02712:  MOVFF  263,A77
02716:  MOVFF  262,A76
0271A:  MOVFF  261,A75
0271E:  MOVFF  260,A74
02722:  MOVLW  02
02724:  MOVLB  A
02726:  MOVWF  x79
02728:  MOVLW  78
0272A:  MOVWF  x78
0272C:  CLRF   x7B
0272E:  MOVLW  01
02730:  MOVWF  x7A
02732:  MOVLW  02
02734:  MOVWF  x7D
02736:  MOVLW  64
02738:  MOVWF  x7C
0273A:  CLRF   x81
0273C:  CLRF   x80
0273E:  CLRF   x7F
02740:  MOVLW  14
02742:  MOVWF  x7E
02744:  MOVLB  0
02746:  CALL   24A4
....................    output_high(flash_stream.cs_pin);
0274A:  MOVFF  262,A74
0274E:  MOVLW  01
02750:  MOVLB  A
02752:  MOVWF  x75
02754:  MOVLW  0F
02756:  MOVWF  x77
02758:  MOVLW  89
0275A:  MOVWF  x76
0275C:  MOVLB  0
0275E:  CALL   2358
02762:  MOVFF  262,A74
02766:  MOVLB  A
02768:  CLRF   x75
0276A:  MOVLW  0F
0276C:  MOVWF  x77
0276E:  MOVLW  92
02770:  MOVWF  x76
02772:  MOVLB  0
02774:  CALL   2358
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
02778:  MOVLB  2
0277A:  MOVF   x64,W
0277C:  SUBLW  20
0277E:  BTFSC  FD8.2
02780:  BRA    2788
02782:  MOVLB  0
02784:  GOTO   2796
02788:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
0278A:  MOVLW  01
0278C:  MOVWF  01
0278E:  GOTO   279E
....................    }
02792:  GOTO   279E
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
02796:  MOVLW  00
02798:  MOVWF  01
0279A:  GOTO   279E
....................    }
0279E:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
029DC:  MOVLB  A
029DE:  MOVF   xAF,F
029E0:  BTFSC  FD8.2
029E2:  BRA    29EA
029E4:  MOVLB  0
029E6:  GOTO   29F4
029EA:  MOVLB  0
029EC:  MOVLW  00
029EE:  MOVWF  01
029F0:  GOTO   2A46
.................... 
....................    unsigned int8 crc = *frame++;
029F4:  MOVLB  A
029F6:  MOVF   xAE,W
029F8:  MOVWF  03
029FA:  MOVF   xAD,W
029FC:  INCF   xAD,F
029FE:  BTFSC  FD8.2
02A00:  INCF   xAE,F
02A02:  MOVWF  FE9
02A04:  MOVFF  03,FEA
02A08:  MOVFF  FEF,AB0
02A0C:  MOVLB  0
....................    while (--payload_size > 0)
02A0E:  MOVLB  A
02A10:  DECF   xAF,F
02A12:  MOVF   xAF,F
02A14:  BTFSS  FD8.2
02A16:  BRA    2A1E
02A18:  MOVLB  0
02A1A:  GOTO   2A3E
02A1E:  MOVLB  0
....................       crc ^= *frame++;
02A20:  MOVLB  A
02A22:  MOVF   xAE,W
02A24:  MOVWF  03
02A26:  MOVF   xAD,W
02A28:  INCF   xAD,F
02A2A:  BTFSC  FD8.2
02A2C:  INCF   xAE,F
02A2E:  MOVWF  FE9
02A30:  MOVFF  03,FEA
02A34:  MOVF   FEF,W
02A36:  XORWF  xB0,F
02A38:  MOVLB  0
02A3A:  GOTO   2A0E
.................... 
....................    return crc;
02A3E:  MOVLB  A
02A40:  MOVF   xB0,W
02A42:  MOVWF  01
02A44:  MOVLB  0
02A46:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
095A0:  MOVLW  01
095A2:  MOVLB  2
095A4:  SUBWF  xE4,W
095A6:  ADDWF  xE2,W
095A8:  MOVWF  FE9
095AA:  MOVLW  00
095AC:  ADDWFC xE3,W
095AE:  MOVWF  FEA
095B0:  MOVFF  FEF,2E5
095B4:  MOVLW  01
095B6:  SUBWF  xE4,W
095B8:  MOVWF  xE7
095BA:  MOVFF  2E3,AAE
095BE:  MOVFF  2E2,AAD
095C2:  MOVFF  2E7,AAF
095C6:  MOVLB  0
095C8:  CALL   29DC
095CC:  MOVFF  01,2E6
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
095D0:  MOVLB  2
095D2:  MOVF   xE6,W
095D4:  SUBWF  xE5,W
095D6:  BTFSS  FD8.2
095D8:  BRA    95E0
095DA:  MOVLB  0
095DC:  GOTO   95E8
095E0:  MOVLB  0
095E2:  MOVLW  00
095E4:  GOTO   95EA
095E8:  MOVLW  01
095EA:  MOVWF  01
095EC:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
.................... {   
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
*
08638:  MOVLW  8A
0863A:  MOVWF  FF6
0863C:  MOVLW  02
0863E:  MOVWF  FF7
08640:  MOVLW  00
08642:  MOVWF  FF8
08644:  CALL   1BBE
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
08648:  MOVLW  01
0864A:  MOVLB  1
0864C:  ADDWF  x0D,W
0864E:  ANDLW  0F
08650:  MOVWF  xAD
.................... 
....................    if(next_tail == flash_queue.head_index)
08652:  MOVF   x0C,W
08654:  SUBWF  xAD,W
08656:  BTFSC  FD8.2
08658:  BRA    8660
0865A:  MOVLB  0
0865C:  GOTO   8676
08660:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
08662:  MOVLW  A4
08664:  MOVWF  FF6
08666:  MOVLW  02
08668:  MOVWF  FF7
0866A:  MOVLW  00
0866C:  MOVWF  FF8
0866E:  CALL   1BBE
08672:  GOTO   8894
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
08676:  MOVLB  1
08678:  MOVF   x0D,W
0867A:  MULLW  0C
0867C:  MOVF   FF3,W
0867E:  CLRF   xAF
08680:  MOVWF  xAE
08682:  MOVLW  4C
08684:  ADDWF  xAE,W
08686:  MOVWF  01
08688:  MOVLW  00
0868A:  ADDWFC xAF,W
0868C:  MOVWF  03
0868E:  MOVF   01,W
08690:  MOVWF  xB0
08692:  MOVFF  03,1B1
08696:  MOVF   xAB,W
08698:  MOVWF  FE9
0869A:  MOVF   xAC,W
0869C:  MOVWF  FEA
0869E:  MOVF   FEF,W
086A0:  MOVWF  xB2
086A2:  MOVFF  1B1,FEA
086A6:  MOVFF  1B0,FE9
086AA:  MOVFF  1B2,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
086AE:  MOVF   x0D,W
086B0:  MULLW  0C
086B2:  MOVF   FF3,W
086B4:  CLRF   xAF
086B6:  MOVWF  xAE
086B8:  MOVLW  01
086BA:  ADDWF  xAE,W
086BC:  MOVWF  01
086BE:  MOVLW  00
086C0:  ADDWFC xAF,W
086C2:  MOVWF  03
086C4:  MOVF   01,W
086C6:  ADDLW  4C
086C8:  MOVWF  01
086CA:  MOVLW  00
086CC:  ADDWFC 03,F
086CE:  MOVF   01,W
086D0:  MOVWF  xAE
086D2:  MOVFF  03,1AF
086D6:  MOVLW  01
086D8:  ADDWF  xAB,W
086DA:  MOVWF  FE9
086DC:  MOVLW  00
086DE:  ADDWFC xAC,W
086E0:  MOVWF  FEA
086E2:  MOVF   FEF,W
086E4:  MOVWF  xB0
086E6:  MOVFF  1AF,FEA
086EA:  MOVFF  1AE,FE9
086EE:  MOVFF  1B0,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
086F2:  MOVF   x0D,W
086F4:  MULLW  0C
086F6:  MOVF   FF3,W
086F8:  CLRF   xAF
086FA:  MOVWF  xAE
086FC:  MOVLW  02
086FE:  ADDWF  xAE,W
08700:  MOVWF  01
08702:  MOVLW  00
08704:  ADDWFC xAF,W
08706:  MOVWF  03
08708:  MOVF   01,W
0870A:  ADDLW  4C
0870C:  MOVWF  01
0870E:  MOVLW  00
08710:  ADDWFC 03,F
08712:  MOVF   01,W
08714:  MOVWF  xAE
08716:  MOVFF  03,1AF
0871A:  MOVLW  02
0871C:  ADDWF  xAB,W
0871E:  MOVWF  FE9
08720:  MOVLW  00
08722:  ADDWFC xAC,W
08724:  MOVWF  FEA
08726:  MOVF   FEF,W
08728:  MOVWF  xB0
0872A:  MOVFF  1AF,FEA
0872E:  MOVFF  1AE,FE9
08732:  MOVFF  1B0,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
08736:  MOVF   x0D,W
08738:  MULLW  0C
0873A:  MOVF   FF3,W
0873C:  CLRF   xAF
0873E:  MOVWF  xAE
08740:  MOVLW  03
08742:  ADDWF  xAE,W
08744:  MOVWF  01
08746:  MOVLW  00
08748:  ADDWFC xAF,W
0874A:  MOVWF  03
0874C:  MOVF   01,W
0874E:  ADDLW  4C
08750:  MOVWF  01
08752:  MOVLW  00
08754:  ADDWFC 03,F
08756:  MOVF   01,W
08758:  MOVWF  xAE
0875A:  MOVFF  03,1AF
0875E:  MOVLW  03
08760:  ADDWF  xAB,W
08762:  MOVWF  01
08764:  MOVLW  00
08766:  ADDWFC xAC,W
08768:  MOVWF  03
0876A:  MOVF   01,W
0876C:  MOVWF  FE9
0876E:  MOVFF  03,FEA
08772:  MOVLW  00
08774:  BTFSC  FEF.0
08776:  MOVLW  01
08778:  MOVWF  01
0877A:  BTFSS  01.0
0877C:  BRA    8784
0877E:  MOVLB  0
08780:  GOTO   8794
08784:  MOVLB  0
08786:  MOVFF  1AF,FEA
0878A:  MOVFF  1AE,FE9
0878E:  BCF    FEF.0
08790:  GOTO   879E
08794:  MOVFF  1AF,FEA
08798:  MOVFF  1AE,FE9
0879C:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
0879E:  MOVLB  1
087A0:  MOVF   x0D,W
087A2:  MULLW  0C
087A4:  MOVF   FF3,W
087A6:  CLRF   xAF
087A8:  MOVWF  xAE
087AA:  MOVLW  04
087AC:  ADDWF  xAE,W
087AE:  MOVWF  01
087B0:  MOVLW  00
087B2:  ADDWFC xAF,W
087B4:  MOVWF  03
087B6:  MOVF   01,W
087B8:  ADDLW  4C
087BA:  MOVWF  01
087BC:  MOVLW  00
087BE:  ADDWFC 03,F
087C0:  MOVF   01,W
087C2:  MOVWF  xAE
087C4:  MOVFF  03,1AF
087C8:  MOVLW  04
087CA:  ADDWF  xAB,W
087CC:  MOVWF  FE9
087CE:  MOVLW  00
087D0:  ADDWFC xAC,W
087D2:  MOVWF  FEA
087D4:  MOVFF  FEF,00
087D8:  MOVFF  FEC,01
087DC:  MOVFF  FEC,02
087E0:  MOVFF  FEC,03
087E4:  MOVF   FED,F
087E6:  MOVF   FED,F
087E8:  MOVF   FED,F
087EA:  MOVFF  03,1B3
087EE:  MOVFF  02,1B2
087F2:  MOVFF  01,1B1
087F6:  MOVFF  00,1B0
087FA:  MOVFF  1AF,FEA
087FE:  MOVFF  1AE,FE9
08802:  MOVFF  1B0,FEF
08806:  MOVFF  1B1,FEC
0880A:  MOVFF  1B2,FEC
0880E:  MOVFF  1B3,FEC
08812:  MOVF   FED,F
08814:  MOVF   FED,F
08816:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
08818:  MOVF   x0D,W
0881A:  MULLW  0C
0881C:  MOVF   FF3,W
0881E:  CLRF   xAF
08820:  MOVWF  xAE
08822:  MOVLW  08
08824:  ADDWF  xAE,W
08826:  MOVWF  01
08828:  MOVLW  00
0882A:  ADDWFC xAF,W
0882C:  MOVWF  03
0882E:  MOVF   01,W
08830:  ADDLW  4C
08832:  MOVWF  01
08834:  MOVLW  00
08836:  ADDWFC 03,F
08838:  MOVF   01,W
0883A:  MOVWF  xAE
0883C:  MOVFF  03,1AF
08840:  MOVLW  08
08842:  ADDWF  xAB,W
08844:  MOVWF  FE9
08846:  MOVLW  00
08848:  ADDWFC xAC,W
0884A:  MOVWF  FEA
0884C:  MOVFF  FEF,00
08850:  MOVFF  FEC,01
08854:  MOVFF  FEC,02
08858:  MOVFF  FEC,03
0885C:  MOVF   FED,F
0885E:  MOVF   FED,F
08860:  MOVF   FED,F
08862:  MOVFF  03,1B3
08866:  MOVFF  02,1B2
0886A:  MOVFF  01,1B1
0886E:  MOVFF  00,1B0
08872:  MOVFF  1AF,FEA
08876:  MOVFF  1AE,FE9
0887A:  MOVFF  1B0,FEF
0887E:  MOVFF  1B1,FEC
08882:  MOVFF  1B2,FEC
08886:  MOVFF  1B3,FEC
0888A:  MOVF   FED,F
0888C:  MOVF   FED,F
0888E:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
08890:  MOVFF  1AD,10D
08894:  MOVLB  0
....................    }
08896:  GOTO   8E2E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
0919A:  MOVLB  1
0919C:  MOVF   x0D,W
0919E:  SUBWF  x0C,W
091A0:  BTFSC  FD8.2
091A2:  BRA    91AA
091A4:  MOVLB  0
091A6:  GOTO   91CC
091AA:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
091AC:  MOVLW  BE
091AE:  MOVWF  FF6
091B0:  MOVLW  02
091B2:  MOVWF  FF7
091B4:  MOVLW  00
091B6:  MOVWF  FF8
091B8:  CALL   1BBE
....................       return 0x00;
091BC:  MOVLW  00
091BE:  MOVWF  01
091C0:  MOVLW  00
091C2:  MOVWF  02
091C4:  GOTO   91F8
....................    }
091C8:  GOTO   91F8
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
091CC:  MOVFF  10C,18B
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
091D0:  MOVLW  01
091D2:  MOVLB  1
091D4:  ADDWF  x0C,W
091D6:  ANDLW  0F
091D8:  MOVWF  x0C
.................... 
.................... 
....................       return &flash_queue.entries[current_head];
091DA:  MOVF   x8B,W
091DC:  MULLW  0C
091DE:  MOVF   FF3,W
091E0:  CLRF   03
091E2:  ADDLW  4C
091E4:  MOVWF  01
091E6:  MOVLW  00
091E8:  ADDWFC 03,F
091EA:  MOVF   01,W
091EC:  MOVWF  01
091EE:  MOVF   03,W
091F0:  MOVWF  02
091F2:  MOVLB  0
091F4:  GOTO   91F8
....................    }
091F8:  GOTO   AE4C (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
090A4:  MOVLB  1
090A6:  MOVF   x0D,W
090A8:  SUBWF  x0C,W
090AA:  BTFSS  FD8.2
090AC:  BRA    90B4
090AE:  MOVLB  0
090B0:  GOTO   90BC
090B4:  MOVLB  0
090B6:  MOVLW  00
090B8:  GOTO   90BE
090BC:  MOVLW  01
090BE:  MOVWF  01
090C0:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
09378:  MOVLB  2
0937A:  CLRF   x68
0937C:  CLRF   x69
0937E:  CLRF   x6A
09380:  CLRF   x6B
09382:  CLRF   x6C
09384:  CLRF   x6D
09386:  CLRF   x6E
09388:  CLRF   x6F
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0938A:  MOVF   x67,F
0938C:  BTFSC  FD8.2
0938E:  BRA    9396
09390:  MOVLB  0
09392:  GOTO   93BA
09396:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
09398:  MOVLW  06
0939A:  MOVLB  2
0939C:  MOVWF  x6B
0939E:  MOVLW  AA
093A0:  MOVWF  x6A
093A2:  CLRF   x69
093A4:  CLRF   x68
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
093A6:  MOVLW  06
093A8:  MOVWF  x6F
093AA:  MOVLW  AA
093AC:  MOVWF  x6E
093AE:  MOVLW  0F
093B0:  MOVWF  x6D
093B2:  SETF   x6C
093B4:  MOVLB  0
....................    }
093B6:  GOTO   948E
....................    else if (mission_id == CIGS_PICLOG_DATA)
093BA:  MOVLB  2
093BC:  DECFSZ x67,W
093BE:  BRA    93C4
093C0:  BRA    93CA
093C2:  MOVLB  0
093C4:  MOVLB  0
093C6:  GOTO   93F0
093CA:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
093CC:  MOVLW  06
093CE:  MOVLB  2
093D0:  MOVWF  x6B
093D2:  MOVLW  AA
093D4:  MOVWF  x6A
093D6:  MOVLW  10
093D8:  MOVWF  x69
093DA:  CLRF   x68
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
093DC:  MOVLW  06
093DE:  MOVWF  x6F
093E0:  MOVLW  AA
093E2:  MOVWF  x6E
093E4:  MOVLW  1F
093E6:  MOVWF  x6D
093E8:  SETF   x6C
093EA:  MOVLB  0
....................    }
093EC:  GOTO   948E
....................    else if (mission_id == CIGS_ENVIRO_DATA)
093F0:  MOVLB  2
093F2:  MOVF   x67,W
093F4:  SUBLW  02
093F6:  BTFSC  FD8.2
093F8:  BRA    9400
093FA:  MOVLB  0
093FC:  GOTO   9426
09400:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
09402:  MOVLW  06
09404:  MOVLB  2
09406:  MOVWF  x6B
09408:  MOVLW  AA
0940A:  MOVWF  x6A
0940C:  MOVLW  10
0940E:  MOVWF  x69
09410:  CLRF   x68
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
09412:  MOVLW  06
09414:  MOVWF  x6F
09416:  MOVLW  AA
09418:  MOVWF  x6E
0941A:  MOVLW  1F
0941C:  MOVWF  x6D
0941E:  SETF   x6C
09420:  MOVLB  0
....................    }
09422:  GOTO   948E
....................    else if (mission_id == CIGS_IV_HEADER)
09426:  MOVLB  2
09428:  MOVF   x67,W
0942A:  SUBLW  03
0942C:  BTFSC  FD8.2
0942E:  BRA    9436
09430:  MOVLB  0
09432:  GOTO   945C
09436:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_HEADER_START_ADDRESS;
09438:  MOVLW  06
0943A:  MOVLB  2
0943C:  MOVWF  x6B
0943E:  MOVLW  B4
09440:  MOVWF  x6A
09442:  MOVLW  20
09444:  MOVWF  x69
09446:  CLRF   x68
....................       mis_struct.end_address   = CIGS_IV1_HEADER_END_ADDRESS;
09448:  MOVLW  06
0944A:  MOVWF  x6F
0944C:  MOVLW  BE
0944E:  MOVWF  x6E
09450:  MOVLW  1F
09452:  MOVWF  x6D
09454:  SETF   x6C
09456:  MOVLB  0
....................    }
09458:  GOTO   948E
....................    else if (mission_id == CIGS_IV_DATA)
0945C:  MOVLB  2
0945E:  MOVF   x67,W
09460:  SUBLW  04
09462:  BTFSC  FD8.2
09464:  BRA    946C
09466:  MOVLB  0
09468:  GOTO   948E
0946C:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_DATA_START_ADDRESS;
0946E:  MOVLW  06
09470:  MOVLB  2
09472:  MOVWF  x6B
09474:  MOVLW  BE
09476:  MOVWF  x6A
09478:  MOVLW  20
0947A:  MOVWF  x69
0947C:  CLRF   x68
....................       mis_struct.end_address   = CIGS_IV1_DATA_END_ADDRESS;
0947E:  MOVLW  06
09480:  MOVWF  x6F
09482:  MOVLW  FE
09484:  MOVWF  x6E
09486:  MOVLW  2F
09488:  MOVWF  x6D
0948A:  SETF   x6C
0948C:  MOVLB  0
....................    }
....................    return mis_struct;
0948E:  MOVLW  68
09490:  MOVWF  01
09492:  MOVLW  02
09494:  MOVWF  02
09496:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
0442E:  MOVLB  1
04430:  CLRF   x8D
04432:  CLRF   x8E
04434:  CLRF   x8F
04436:  CLRF   x90
04438:  CLRF   x91
0443A:  CLRF   x92
0443C:  CLRF   x93
0443E:  CLRF   x94
04440:  CLRF   x95
04442:  CLRF   x96
04444:  CLRF   x97
04446:  CLRF   x98
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
04448:  MOVLW  D6
0444A:  MOVWF  FF6
0444C:  MOVLW  02
0444E:  MOVWF  FF7
04450:  MOVLW  00
04452:  MOVWF  FF8
04454:  MOVLB  0
04456:  CALL   1BBE
....................    fprintf(PC, "\t[BOSS] >>> ");
0445A:  MOVLW  F6
0445C:  MOVWF  FF6
0445E:  MOVLW  02
04460:  MOVWF  FF7
04462:  MOVLW  00
04464:  MOVWF  FF8
04466:  CALL   1BBE
....................    for (int8 i = 0; i < receive_signal_size; i++)
0446A:  MOVLB  1
0446C:  CLRF   x99
0446E:  MOVLB  0
04470:  MOVLB  1
04472:  MOVF   x8C,W
04474:  SUBWF  x99,W
04476:  BTFSS  FD8.0
04478:  BRA    4480
0447A:  MOVLB  0
0447C:  GOTO   44BA
04480:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
04482:  MOVLB  1
04484:  MOVF   x99,W
04486:  ADDWF  x8A,W
04488:  MOVWF  FE9
0448A:  MOVLW  00
0448C:  ADDWFC x8B,W
0448E:  MOVWF  FEA
04490:  MOVFF  FEF,1A0
04494:  MOVFF  1A0,264
04498:  MOVLW  37
0449A:  MOVLB  2
0449C:  MOVWF  x65
0449E:  MOVLB  0
044A0:  CALL   1E42
044A4:  MOVLW  20
044A6:  MOVLB  A
044A8:  MOVWF  xAD
044AA:  MOVLB  0
044AC:  CALL   1B6C
044B0:  MOVLB  1
044B2:  INCF   x99,F
044B4:  MOVLB  0
044B6:  GOTO   4470
....................    fprintf(PC, "\r\n");
044BA:  MOVLW  0D
044BC:  MOVLB  A
044BE:  MOVWF  xAD
044C0:  MOVLB  0
044C2:  CALL   1B6C
044C6:  MOVLW  0A
044C8:  MOVLB  A
044CA:  MOVWF  xAD
044CC:  MOVLB  0
044CE:  CALL   1B6C
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
044D2:  MOVFF  18B,1A1
044D6:  MOVFF  18A,1A0
044DA:  MOVFF  18C,1A2
044DE:  GOTO   4126
044E2:  MOVFF  01,19A
....................    if (frame_start_position == -1)
044E6:  MOVLB  1
044E8:  MOVF   x9A,W
044EA:  SUBLW  FF
044EC:  BTFSC  FD8.2
044EE:  BRA    44F6
044F0:  MOVLB  0
044F2:  GOTO   4504
044F6:  MOVLB  0
....................       return command;
044F8:  MOVLW  8D
044FA:  MOVWF  01
044FC:  MOVLW  01
044FE:  MOVWF  02
04500:  GOTO   4626
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
04504:  MOVLB  1
04506:  MOVF   x9A,W
04508:  ADDWF  x8A,W
0450A:  MOVWF  01
0450C:  MOVLW  00
0450E:  ADDWFC x8B,W
04510:  MOVWF  03
04512:  MOVF   01,W
04514:  MOVWF  x9B
04516:  MOVFF  03,19C
0451A:  MOVF   x9B,W
0451C:  MOVWF  FE9
0451E:  MOVF   x9C,W
04520:  MOVWF  FEA
04522:  MOVF   FEF,W
04524:  ANDLW  0F
04526:  MOVWF  x9D
04528:  MOVFF  19D,1A0
0452C:  MOVLB  0
0452E:  GOTO   41CE
04532:  MOVFF  01,19E
....................    if (content_size == -1)
04536:  MOVLB  1
04538:  MOVF   x9E,W
0453A:  SUBLW  FF
0453C:  BTFSC  FD8.2
0453E:  BRA    4546
04540:  MOVLB  0
04542:  GOTO   4554
04546:  MOVLB  0
....................       return command;
04548:  MOVLW  8D
0454A:  MOVWF  01
0454C:  MOVLW  01
0454E:  MOVWF  02
04550:  GOTO   4626
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
04554:  MOVLB  1
04556:  MOVF   x9A,W
04558:  SUBWF  x8C,W
0455A:  MOVWF  x9F
....................    
....................    if (!check_crc(frame, receive_frame_size))
0455C:  MOVFF  19C,1A1
04560:  MOVFF  19B,1A0
04564:  MOVFF  19F,1A2
04568:  MOVLB  0
0456A:  GOTO   428A
0456E:  MOVF   01,F
04570:  BTFSS  FD8.2
04572:  GOTO   4582
....................       return command;
04576:  MOVLW  8D
04578:  MOVWF  01
0457A:  MOVLW  01
0457C:  MOVWF  02
0457E:  GOTO   4626
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
04582:  MOVLB  1
04584:  MOVF   x9B,W
04586:  MOVWF  FE9
04588:  MOVF   x9C,W
0458A:  MOVWF  FEA
0458C:  MOVF   FEF,W
0458E:  ANDLW  F0
04590:  MOVWF  00
04592:  SWAPF  00,W
04594:  MOVWF  xA0
04596:  MOVLW  0F
04598:  ANDWF  xA0,F
0459A:  MOVFF  1A0,1A1
0459E:  MOVLB  0
045A0:  GOTO   4374
045A4:  MOVF   01,F
045A6:  BTFSS  FD8.2
045A8:  GOTO   45B8
....................       return command;
045AC:  MOVLW  8D
045AE:  MOVWF  01
045B0:  MOVLW  01
045B2:  MOVWF  02
045B4:  GOTO   4626
.................... 
....................    command.frame_id = frame_id;
045B8:  MOVFF  19D,18D
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
045BC:  MOVLW  01
045BE:  MOVLB  1
045C0:  ADDWF  x9B,W
045C2:  MOVWF  01
045C4:  MOVLW  00
045C6:  ADDWFC x9C,W
045C8:  MOVWF  03
045CA:  MOVF   01,W
045CC:  MOVWF  xA0
045CE:  MOVFF  03,1A1
045D2:  MOVLW  02
045D4:  SUBWF  x9F,W
045D6:  MOVWF  xA2
045D8:  MOVLW  01
045DA:  MOVWF  FEA
045DC:  MOVLW  90
045DE:  MOVWF  FE9
045E0:  MOVFF  1A1,FE2
045E4:  MOVFF  1A0,FE1
045E8:  MOVF   xA2,W
045EA:  MOVWF  01
045EC:  BTFSS  FD8.2
045EE:  BRA    45F6
045F0:  MOVLB  0
045F2:  GOTO   4602
045F6:  MOVLB  0
045F8:  MOVFF  FE6,FEE
045FC:  DECFSZ 01,F
045FE:  GOTO   45F8
....................    command.size = receive_frame_size-2;
04602:  MOVLW  02
04604:  MOVLB  1
04606:  SUBWF  x9F,W
04608:  MOVWF  x8E
....................    command.is_exist = TRUE;
0460A:  BSF    x8F.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
0460C:  MOVLW  04
0460E:  MOVWF  FF6
04610:  MOVLW  03
04612:  MOVWF  FF7
04614:  MOVLW  00
04616:  MOVWF  FF8
04618:  MOVLB  0
0461A:  CALL   1BBE
....................    return command;
0461E:  MOVLW  8D
04620:  MOVWF  01
04622:  MOVLW  01
04624:  MOVWF  02
04626:  GOTO   B5A6 (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
04126:  MOVLB  1
04128:  CLRF   xA3
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
0412A:  CLRF   xA3
0412C:  MOVLB  0
0412E:  MOVLW  01
04130:  MOVLB  1
04132:  SUBWF  xA2,W
04134:  SUBWF  xA3,W
04136:  BTFSS  FD8.0
04138:  BRA    4140
0413A:  MOVLB  0
0413C:  GOTO   4178
04140:  MOVLB  0
....................       if(receive_signal[i] == SFD)
04142:  MOVLB  1
04144:  MOVF   xA3,W
04146:  ADDWF  xA0,W
04148:  MOVWF  FE9
0414A:  MOVLW  00
0414C:  ADDWFC xA1,W
0414E:  MOVWF  FEA
04150:  MOVF   FEF,W
04152:  SUBLW  AA
04154:  BTFSC  FD8.2
04156:  BRA    415E
04158:  MOVLB  0
0415A:  GOTO   416E
0415E:  MOVLB  0
....................          return i+1;
04160:  MOVLW  01
04162:  MOVLB  1
04164:  ADDWF  xA3,W
04166:  MOVWF  01
04168:  MOVLB  0
0416A:  GOTO   41CA
0416E:  MOVLB  1
04170:  INCF   xA3,F
04172:  MOVLB  0
04174:  GOTO   412E
....................    if (receive_signal[i] == SFD)
04178:  MOVLB  1
0417A:  MOVF   xA3,W
0417C:  ADDWF  xA0,W
0417E:  MOVWF  FE9
04180:  MOVLW  00
04182:  ADDWFC xA1,W
04184:  MOVWF  FEA
04186:  MOVF   FEF,W
04188:  SUBLW  AA
0418A:  BTFSC  FD8.2
0418C:  BRA    4194
0418E:  MOVLB  0
04190:  GOTO   41B2
04194:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
04196:  MOVLW  20
04198:  MOVWF  FF6
0419A:  MOVLW  03
0419C:  MOVWF  FF7
0419E:  MOVLW  00
041A0:  MOVWF  FF8
041A2:  CALL   1BBE
....................       return -1;
041A6:  MOVLW  FF
041A8:  MOVWF  01
041AA:  GOTO   41CA
....................    }
041AE:  GOTO   41CA
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
041B2:  MOVLW  36
041B4:  MOVWF  FF6
041B6:  MOVLW  03
041B8:  MOVWF  FF7
041BA:  MOVLW  00
041BC:  MOVWF  FF8
041BE:  CALL   1BBE
....................       return -1;
041C2:  MOVLW  FF
041C4:  MOVWF  01
041C6:  GOTO   41CA
....................    }
041CA:  GOTO   44E2 (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
041CE:  MOVLB  1
041D0:  CLRF   xA1
041D2:  MOVLB  0
041D4:  MOVLB  1
041D6:  MOVF   xA1,W
041D8:  SUBLW  02
041DA:  BTFSC  FD8.0
041DC:  BRA    41E4
041DE:  MOVLB  0
041E0:  GOTO   4242
041E4:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
041E6:  BCF    FD8.0
041E8:  MOVLB  1
041EA:  RLCF   xA1,W
041EC:  CLRF   xA3
041EE:  MOVWF  xA2
041F0:  MOVLW  16
041F2:  ADDWF  xA2,W
041F4:  MOVWF  FE9
041F6:  MOVLW  01
041F8:  ADDWFC xA3,W
041FA:  MOVWF  FEA
041FC:  MOVF   FEF,W
041FE:  SUBWF  xA0,W
04200:  BTFSC  FD8.2
04202:  BRA    420A
04204:  MOVLB  0
04206:  GOTO   4238
0420A:  MOVLB  0
....................          return frame_ids[i].length;
0420C:  BCF    FD8.0
0420E:  MOVLB  1
04210:  RLCF   xA1,W
04212:  CLRF   xA3
04214:  MOVWF  xA2
04216:  MOVLW  01
04218:  ADDWF  xA2,W
0421A:  MOVWF  01
0421C:  MOVLW  00
0421E:  ADDWFC xA3,W
04220:  MOVWF  03
04222:  MOVF   01,W
04224:  ADDLW  16
04226:  MOVWF  FE9
04228:  MOVLW  01
0422A:  ADDWFC 03,W
0422C:  MOVWF  FEA
0422E:  MOVF   FEF,W
04230:  MOVWF  01
04232:  MOVLB  0
04234:  GOTO   4286
04238:  MOVLB  1
0423A:  INCF   xA1,F
0423C:  MOVLB  0
0423E:  GOTO   41D4
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
04242:  MOVLW  48
04244:  MOVWF  FF6
04246:  MOVLW  03
04248:  MOVWF  FF7
0424A:  MOVLW  00
0424C:  MOVWF  FF8
0424E:  MOVLW  1F
04250:  MOVLB  9
04252:  MOVWF  xC2
04254:  MOVLB  0
04256:  CALL   1BEE
0425A:  MOVFF  1A0,264
0425E:  MOVLW  37
04260:  MOVLB  2
04262:  MOVWF  x65
04264:  MOVLB  0
04266:  CALL   1E42
0426A:  MOVLW  0D
0426C:  MOVLB  A
0426E:  MOVWF  xAD
04270:  MOVLB  0
04272:  CALL   1B6C
04276:  MOVLW  0A
04278:  MOVLB  A
0427A:  MOVWF  xAD
0427C:  MOVLB  0
0427E:  CALL   1B6C
....................    return -1;
04282:  MOVLW  FF
04284:  MOVWF  01
04286:  GOTO   4532 (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
0428A:  MOVLW  01
0428C:  MOVLB  1
0428E:  SUBWF  xA2,W
04290:  ADDWF  xA0,W
04292:  MOVWF  FE9
04294:  MOVLW  00
04296:  ADDWFC xA1,W
04298:  MOVWF  FEA
0429A:  MOVFF  FEF,1A3
0429E:  MOVLW  01
042A0:  SUBWF  xA2,W
042A2:  MOVWF  xA5
042A4:  MOVFF  1A1,AAE
042A8:  MOVFF  1A0,AAD
042AC:  MOVFF  1A5,AAF
042B0:  MOVLB  0
042B2:  CALL   29DC
042B6:  MOVFF  01,1A4
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
042BA:  MOVLB  1
042BC:  MOVF   xA4,W
042BE:  SUBWF  xA3,W
042C0:  BTFSC  FD8.2
042C2:  BRA    42CA
042C4:  MOVLB  0
042C6:  GOTO   42D8
042CA:  MOVLB  0
....................       return TRUE;
042CC:  MOVLW  01
042CE:  MOVWF  01
042D0:  GOTO   4370
042D4:  GOTO   4370
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
042D8:  MOVLW  6C
042DA:  MOVWF  FF6
042DC:  MOVLW  03
042DE:  MOVWF  FF7
042E0:  MOVLW  00
042E2:  MOVWF  FF8
042E4:  CALL   1BBE
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
042E8:  MOVLW  7E
042EA:  MOVWF  FF6
042EC:  MOVLW  03
042EE:  MOVWF  FF7
042F0:  MOVLW  00
042F2:  MOVWF  FF8
042F4:  MOVLW  13
042F6:  MOVLB  9
042F8:  MOVWF  xC2
042FA:  MOVLB  0
042FC:  CALL   1BEE
04300:  MOVFF  1A3,264
04304:  MOVLW  37
04306:  MOVLB  2
04308:  MOVWF  x65
0430A:  MOVLB  0
0430C:  CALL   1E42
04310:  MOVLW  0D
04312:  MOVLB  A
04314:  MOVWF  xAD
04316:  MOVLB  0
04318:  CALL   1B6C
0431C:  MOVLW  0A
0431E:  MOVLB  A
04320:  MOVWF  xAD
04322:  MOVLB  0
04324:  CALL   1B6C
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
04328:  MOVLW  96
0432A:  MOVWF  FF6
0432C:  MOVLW  03
0432E:  MOVWF  FF7
04330:  MOVLW  00
04332:  MOVWF  FF8
04334:  MOVLW  13
04336:  MOVLB  9
04338:  MOVWF  xC2
0433A:  MOVLB  0
0433C:  CALL   1BEE
04340:  MOVFF  1A4,264
04344:  MOVLW  37
04346:  MOVLB  2
04348:  MOVWF  x65
0434A:  MOVLB  0
0434C:  CALL   1E42
04350:  MOVLW  0D
04352:  MOVLB  A
04354:  MOVWF  xAD
04356:  MOVLB  0
04358:  CALL   1B6C
0435C:  MOVLW  0A
0435E:  MOVLB  A
04360:  MOVWF  xAD
04362:  MOVLB  0
04364:  CALL   1B6C
....................       return FALSE;
04368:  MOVLW  00
0436A:  MOVWF  01
0436C:  GOTO   4370
....................    }
04370:  GOTO   456E (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
04374:  MOVLB  1
04376:  MOVF   xA1,W
04378:  SUBLW  0C
0437A:  BTFSC  FD8.2
0437C:  BRA    4384
0437E:  MOVLB  0
04380:  GOTO   4392
04384:  MOVLB  0
....................       return TRUE;
04386:  MOVLW  01
04388:  MOVWF  01
0438A:  GOTO   442A
0438E:  GOTO   442A
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
04392:  MOVLW  AE
04394:  MOVWF  FF6
04396:  MOVLW  03
04398:  MOVWF  FF7
0439A:  MOVLW  00
0439C:  MOVWF  FF8
0439E:  CALL   1BBE
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
043A2:  MOVLW  D0
043A4:  MOVWF  FF6
043A6:  MOVLW  03
043A8:  MOVWF  FF7
043AA:  MOVLW  00
043AC:  MOVWF  FF8
043AE:  MOVLW  13
043B0:  MOVLB  9
043B2:  MOVWF  xC2
043B4:  MOVLB  0
043B6:  CALL   1BEE
043BA:  MOVFF  1A1,264
043BE:  MOVLW  37
043C0:  MOVLB  2
043C2:  MOVWF  x65
043C4:  MOVLB  0
043C6:  CALL   1E42
043CA:  MOVLW  0D
043CC:  MOVLB  A
043CE:  MOVWF  xAD
043D0:  MOVLB  0
043D2:  CALL   1B6C
043D6:  MOVLW  0A
043D8:  MOVLB  A
043DA:  MOVWF  xAD
043DC:  MOVLB  0
043DE:  CALL   1B6C
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
043E2:  MOVLW  E8
043E4:  MOVWF  FF6
043E6:  MOVLW  03
043E8:  MOVWF  FF7
043EA:  MOVLW  00
043EC:  MOVWF  FF8
043EE:  MOVLW  13
043F0:  MOVLB  9
043F2:  MOVWF  xC2
043F4:  MOVLB  0
043F6:  CALL   1BEE
043FA:  MOVLW  0C
043FC:  MOVLB  2
043FE:  MOVWF  x64
04400:  MOVLW  37
04402:  MOVWF  x65
04404:  MOVLB  0
04406:  CALL   1E42
0440A:  MOVLW  0D
0440C:  MOVLB  A
0440E:  MOVWF  xAD
04410:  MOVLB  0
04412:  CALL   1B6C
04416:  MOVLW  0A
04418:  MOVLB  A
0441A:  MOVWF  xAD
0441C:  MOVLB  0
0441E:  CALL   1B6C
....................       return FALSE;  
04422:  MOVLW  00
04424:  MOVWF  01
04426:  GOTO   442A
....................    }
0442A:  GOTO   45A4 (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
04730:  MOVLW  AA
04732:  MOVLB  1
04734:  MOVWF  x8F
....................    data[1] = (BOSS_PIC << 4) | frame_id;
04736:  MOVF   x8B,W
04738:  IORLW  50
0473A:  MOVWF  x90
....................    memcpy(&data[2], content, size);
0473C:  MOVLW  01
0473E:  MOVWF  FEA
04740:  MOVLW  91
04742:  MOVWF  FE9
04744:  MOVFF  18D,FE2
04748:  MOVFF  18C,FE1
0474C:  MOVF   x8E,W
0474E:  MOVWF  01
04750:  BTFSS  FD8.2
04752:  BRA    475A
04754:  MOVLB  0
04756:  GOTO   4766
0475A:  MOVLB  0
0475C:  MOVFF  FE6,FEE
04760:  DECFSZ 01,F
04762:  GOTO   475C
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
04766:  MOVLW  02
04768:  MOVLB  1
0476A:  ADDWF  x8E,W
0476C:  MOVWF  x9F
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
0476E:  CLRF   03
04770:  MOVF   x9F,W
04772:  ADDLW  8F
04774:  MOVWF  01
04776:  MOVLW  01
04778:  ADDWFC 03,F
0477A:  MOVF   01,W
0477C:  MOVWF  xA1
0477E:  MOVFF  03,1A2
04782:  MOVLW  01
04784:  SUBWF  x9F,W
04786:  MOVWF  xA3
04788:  MOVLW  01
0478A:  MOVLB  A
0478C:  MOVWF  xAE
0478E:  MOVLW  90
04790:  MOVWF  xAD
04792:  MOVFF  1A3,AAF
04796:  MOVLB  0
04798:  CALL   29DC
0479C:  MOVFF  1A2,FEA
047A0:  MOVFF  1A1,FE9
047A4:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
047A8:  MOVLW  01
047AA:  MOVLB  1
047AC:  ADDWF  x9F,W
047AE:  MOVWF  xA0
....................    
....................    transmit(data, data_size);
047B0:  MOVLW  01
047B2:  MOVWF  xA2
047B4:  MOVLW  8F
047B6:  MOVWF  xA1
047B8:  MOVFF  1A0,1A3
047BC:  MOVLB  0
047BE:  GOTO   4678
047C2:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
04678:  MOVLB  1
0467A:  CLRF   xA4
0467C:  MOVLB  0
0467E:  MOVLB  1
04680:  MOVF   xA3,W
04682:  SUBWF  xA4,W
04684:  BTFSS  FD8.0
04686:  BRA    468E
04688:  MOVLB  0
0468A:  GOTO   46B4
0468E:  MOVLB  0
....................       fputc(data[i], BOSS);
04690:  MOVLB  1
04692:  MOVF   xA4,W
04694:  ADDWF  xA1,W
04696:  MOVWF  FE9
04698:  MOVLW  00
0469A:  ADDWFC xA2,W
0469C:  MOVWF  FEA
0469E:  MOVFF  FEF,1A6
046A2:  MOVF   xA6,W
046A4:  MOVLB  0
046A6:  GOTO   4668
046AA:  MOVLB  1
046AC:  INCF   xA4,F
046AE:  MOVLB  0
046B0:  GOTO   467E
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
046B4:  MOVLW  00
046B6:  MOVWF  FF6
046B8:  MOVLW  04
046BA:  MOVWF  FF7
046BC:  MOVLW  00
046BE:  MOVWF  FF8
046C0:  CALL   1BBE
....................    for(int i = 0; i < data_size; i++)
046C4:  MOVLB  1
046C6:  CLRF   xA5
046C8:  MOVLB  0
046CA:  MOVLB  1
046CC:  MOVF   xA3,W
046CE:  SUBWF  xA5,W
046D0:  BTFSS  FD8.0
046D2:  BRA    46DA
046D4:  MOVLB  0
046D6:  GOTO   4714
046DA:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
046DC:  MOVLB  1
046DE:  MOVF   xA5,W
046E0:  ADDWF  xA1,W
046E2:  MOVWF  FE9
046E4:  MOVLW  00
046E6:  ADDWFC xA2,W
046E8:  MOVWF  FEA
046EA:  MOVFF  FEF,1A6
046EE:  MOVFF  1A6,264
046F2:  MOVLW  37
046F4:  MOVLB  2
046F6:  MOVWF  x65
046F8:  MOVLB  0
046FA:  CALL   1E42
046FE:  MOVLW  20
04700:  MOVLB  A
04702:  MOVWF  xAD
04704:  MOVLB  0
04706:  CALL   1B6C
0470A:  MOVLB  1
0470C:  INCF   xA5,F
0470E:  MOVLB  0
04710:  GOTO   46CA
....................    fprintf(PC, "\r\n");
04714:  MOVLW  0D
04716:  MOVLB  A
04718:  MOVWF  xAD
0471A:  MOVLB  0
0471C:  CALL   1B6C
04720:  MOVLW  0A
04722:  MOVLB  A
04724:  MOVWF  xAD
04726:  MOVLB  0
04728:  CALL   1B6C
0472C:  GOTO   47C2 (RETURN)
.................... }
.................... 
.................... #include "../../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
047C4:  MOVLW  0F
047C6:  MOVLB  1
047C8:  MOVWF  x8B
047CA:  CLRF   x8D
047CC:  CLRF   x8C
047CE:  CLRF   x8E
047D0:  MOVLB  0
047D2:  CALL   4730
047D6:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
0912A:  MOVLW  03
0912C:  MOVLB  1
0912E:  MOVWF  x8B
09130:  CLRF   x8D
09132:  MOVLW  48
09134:  MOVWF  x8C
09136:  MOVLW  04
09138:  MOVWF  x8E
0913A:  MOVLB  0
0913C:  CALL   4730
09140:  GOTO   9168 (RETURN)
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "../core/measurement/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../storage/mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
01C24:  MOVLW  14
01C26:  MOVWF  FF6
01C28:  MOVLW  05
01C2A:  MOVWF  FF7
01C2C:  MOVLW  00
01C2E:  MOVWF  FF8
01C30:  CALL   1BBE
....................     // output_high(ADC_CS); // ADC Chip Select
....................     output_high(MIS_FM_CS); // DAC Chip Select
01C34:  MOVLW  DB
01C36:  MOVWF  F92
01C38:  BSF    F89.5
....................     output_high(SMF_CS); // SMF Chip Select
01C3A:  MOVLW  DB
01C3C:  MOVWF  F92
01C3E:  BSF    F89.2
....................     output_low(CONNECT_CIGS1);
01C40:  MOVLW  5E
01C42:  MOVWF  F94
01C44:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
01C46:  MOVLW  5E
01C48:  MOVWF  F94
01C4A:  BCF    F8B.5
....................     output_high(EN_NPWR);
01C4C:  MOVLW  5E
01C4E:  MOVWF  F94
01C50:  BSF    F8B.7
....................     delay_ms(1);
01C52:  MOVLW  01
01C54:  MOVLB  A
01C56:  MOVWF  x6E
01C58:  MOVLB  0
01C5A:  CALL   1B3E
....................     fprintf(PC, "\tComplete\r\n");
01C5E:  MOVLW  24
01C60:  MOVWF  FF6
01C62:  MOVLW  05
01C64:  MOVWF  FF7
01C66:  MOVLW  00
01C68:  MOVWF  FF8
01C6A:  CALL   1BBE
01C6E:  GOTO   B532 (RETURN)
.................... }
.................... 
.................... 
.................... void test_sweep(unsigned int8 sweep_step)
.................... {
....................     fprintf(PC, "Start TEST SWEEP\r\n");
....................     output_high(CONNECT_CIGS1);
....................     output_low(EN_NPWR); // Enable power to CIGS
....................     delay_us(100); // wait for the CIGS to stabilize
....................     fprintf(PC, "step, voltage, current\r\n");
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     delay_ms(100); // wait for the DAC to stabilize
.................... 
.................... 
....................     unsigned int16 volt;
....................     unsigned int16 curr;
....................     for (unsigned int8 count = 0; count < sweep_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
.................... 
....................         volt = ad7490_read(ADC_CIGS1_AMP); // read CIGS voltage
....................         curr = ad7490_read(ADC_CIGS1_CURR); // read CIGS current
....................         
....................         fprintf(PC, "%u, %lu, %lu\r\n", count, volt, curr);
....................         delay_ms(1); // wait for the ADC to stabilize
....................     }
.................... }
.................... 
.................... void test_adc()
.................... {
....................     unsigned int16 ans;
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     fprintf(PC, "Start ADC TEST\r\n");
....................     ans = ad7490_read(ADC_CIGS1_VOLT);
....................     fprintf(PC, "ADC Voltage: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_CURR);
....................     fprintf(PC, "ADC Current: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_AMP);
....................     fprintf(PC, "ADC CIGS1 Amp: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_VREF);
....................     fprintf(PC, "ADC CIGS1 VREF: %04LX\r\n", ans);
.................... }
.................... 
.................... void sweep_2ports(unsigned int8 measurement_step)
.................... { 
....................     fprintf(PC, "Start SWEEP 2ports\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1 and CIGS2
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
....................     unsigned int16 cigs2_buffer[2][0xFF];
.................... 
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_VOLT);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP 2port\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... 
.................... 
.................... /*
.................... void add_smf_queue_data()
.................... {
....................     SmfDataStruct smf_data;
....................     smf_data.type = SMF_DATA_TYPE_CIGS;
....................     smf_data.length = PACKET_SIZE;
....................     memcpy(smf_data.data, packetdata, PACKET_SIZE);
....................     enqueue_smf_data(&smf_data);
.................... }
.................... */
.................... void add_smf_queue_piclog()
.................... {}
.................... 
.................... void convert_datas(MEASUREMENT_DATA measured_data, )
.................... {
....................     
.................... }
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, "Start SWEEP with threshold\r\n");
*
07140:  MOVLW  26
07142:  MOVWF  FF6
07144:  MOVLW  06
07146:  MOVWF  FF7
07148:  MOVLW  00
0714A:  MOVWF  FF8
0714C:  CALL   1BBE
....................    
....................     // Enable both CIGS ports
....................     output_high(CONNECT_CIGS1);
07150:  MOVLW  5E
07152:  MOVWF  F94
07154:  BSF    F8B.0
....................     output_high(CONNECT_CIGS2);
07156:  MOVLW  5E
07158:  MOVWF  F94
0715A:  BSF    F8B.5
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     SWEEP_CONFIG port1 = {0};
0715C:  MOVLB  1
0715E:  CLRF   xB1
07160:  CLRF   xB2
07162:  CLRF   xB3
07164:  CLRF   xB4
07166:  CLRF   xB5
07168:  CLRF   xB6
0716A:  CLRF   xB7
0716C:  CLRF   xB8
0716E:  CLRF   xB9
07170:  CLRF   xBA
07172:  CLRF   xBB
07174:  CLRF   xBC
07176:  CLRF   xBD
07178:  CLRF   xBE
0717A:  CLRF   xBF
0717C:  CLRF   xC0
0717E:  CLRF   xC1
07180:  CLRF   xC2
07182:  CLRF   xC3
07184:  CLRF   xC4
07186:  CLRF   xC5
07188:  CLRF   xC6
0718A:  CLRF   xC7
0718C:  CLRF   xC8
0718E:  CLRF   xC9
07190:  CLRF   xCA
07192:  CLRF   xCB
07194:  CLRF   xCC
07196:  CLRF   xCD
07198:  CLRF   xCE
0719A:  CLRF   xCF
0719C:  CLRF   xD0
0719E:  CLRF   xD1
071A0:  CLRF   xD2
071A2:  CLRF   xD3
071A4:  CLRF   xD4
071A6:  CLRF   xD5
071A8:  CLRF   xD6
071AA:  CLRF   xD7
071AC:  CLRF   xD8
071AE:  CLRF   xD9
071B0:  CLRF   xDA
071B2:  CLRF   xDB
071B4:  CLRF   xDC
071B6:  CLRF   xDD
071B8:  CLRF   xDE
071BA:  CLRF   xDF
071BC:  CLRF   xE0
071BE:  CLRF   xE1
071C0:  CLRF   xE2
071C2:  CLRF   xE3
071C4:  CLRF   xE4
071C6:  CLRF   xE5
071C8:  CLRF   xE6
071CA:  CLRF   xE7
071CC:  CLRF   xE8
071CE:  CLRF   xE9
071D0:  CLRF   xEA
071D2:  CLRF   xEB
071D4:  CLRF   xEC
071D6:  CLRF   xED
071D8:  CLRF   xEE
071DA:  CLRF   xEF
071DC:  CLRF   xF0
071DE:  CLRF   xF1
071E0:  CLRF   xF2
071E2:  CLRF   xF3
071E4:  CLRF   xF4
071E6:  CLRF   xF5
071E8:  CLRF   xF6
071EA:  CLRF   xF7
071EC:  CLRF   xF8
071EE:  CLRF   xF9
071F0:  CLRF   xFA
071F2:  CLRF   xFB
071F4:  CLRF   xFC
071F6:  CLRF   xFD
071F8:  CLRF   xFE
071FA:  CLRF   xFF
071FC:  MOVLB  2
071FE:  CLRF   x00
07200:  CLRF   x01
07202:  CLRF   x02
07204:  CLRF   x03
07206:  CLRF   x04
07208:  CLRF   x05
0720A:  CLRF   x06
0720C:  CLRF   x07
0720E:  CLRF   x08
07210:  CLRF   x09
07212:  CLRF   x0A
07214:  CLRF   x0B
07216:  CLRF   x0C
07218:  CLRF   x0D
0721A:  CLRF   x0E
0721C:  CLRF   x0F
0721E:  CLRF   x10
07220:  CLRF   x11
07222:  CLRF   x12
07224:  CLRF   x13
07226:  CLRF   x14
07228:  CLRF   x15
0722A:  CLRF   x16
0722C:  CLRF   x17
0722E:  CLRF   x18
07230:  CLRF   x19
07232:  CLRF   x1A
07234:  CLRF   x1B
07236:  CLRF   x1C
07238:  CLRF   x1D
0723A:  CLRF   x1E
0723C:  CLRF   x1F
0723E:  CLRF   x20
07240:  CLRF   x21
07242:  CLRF   x22
07244:  CLRF   x23
07246:  CLRF   x24
07248:  CLRF   x25
0724A:  CLRF   x26
0724C:  CLRF   x27
0724E:  CLRF   x28
07250:  CLRF   x29
07252:  CLRF   x2A
07254:  CLRF   x2B
07256:  CLRF   x2C
07258:  CLRF   x2D
0725A:  CLRF   x2E
0725C:  CLRF   x2F
0725E:  CLRF   x30
07260:  CLRF   x31
07262:  CLRF   x32
07264:  CLRF   x33
07266:  CLRF   x34
07268:  CLRF   x35
0726A:  CLRF   x36
0726C:  CLRF   x37
0726E:  CLRF   x38
07270:  CLRF   x39
07272:  CLRF   x3A
07274:  CLRF   x3B
07276:  CLRF   x3C
07278:  CLRF   x3D
0727A:  CLRF   x3E
0727C:  CLRF   x3F
0727E:  CLRF   x40
07280:  CLRF   x41
07282:  CLRF   x42
07284:  CLRF   x43
07286:  CLRF   x44
07288:  CLRF   x45
0728A:  CLRF   x46
0728C:  CLRF   x47
0728E:  CLRF   x48
07290:  CLRF   x49
07292:  CLRF   x4A
07294:  CLRF   x4B
07296:  CLRF   x4C
07298:  CLRF   x4D
0729A:  CLRF   x4E
0729C:  CLRF   x4F
0729E:  CLRF   x50
072A0:  CLRF   x51
072A2:  CLRF   x52
072A4:  CLRF   x53
072A6:  CLRF   x54
072A8:  CLRF   x55
072AA:  CLRF   x56
072AC:  CLRF   x57
072AE:  CLRF   x58
072B0:  CLRF   x59
072B2:  CLRF   x5A
072B4:  CLRF   x5B
072B6:  CLRF   x5C
072B8:  CLRF   x5D
072BA:  CLRF   x5E
072BC:  CLRF   x5F
072BE:  CLRF   x60
072C0:  CLRF   x61
072C2:  CLRF   x62
072C4:  CLRF   x63
072C6:  CLRF   x64
072C8:  CLRF   x65
072CA:  CLRF   x66
072CC:  CLRF   x67
072CE:  CLRF   x68
072D0:  CLRF   x69
072D2:  CLRF   x6A
072D4:  CLRF   x6B
072D6:  CLRF   x6C
072D8:  CLRF   x6D
072DA:  CLRF   x6E
072DC:  CLRF   x6F
072DE:  CLRF   x70
072E0:  CLRF   x71
072E2:  CLRF   x72
072E4:  CLRF   x73
072E6:  CLRF   x74
072E8:  CLRF   x75
072EA:  CLRF   x76
072EC:  CLRF   x77
072EE:  CLRF   x78
072F0:  CLRF   x79
072F2:  CLRF   x7A
072F4:  CLRF   x7B
072F6:  CLRF   x7C
072F8:  CLRF   x7D
072FA:  CLRF   x7E
072FC:  CLRF   x7F
072FE:  CLRF   x80
07300:  CLRF   x81
07302:  CLRF   x82
07304:  CLRF   x83
07306:  CLRF   x84
07308:  CLRF   x85
0730A:  CLRF   x86
0730C:  CLRF   x87
0730E:  CLRF   x88
07310:  CLRF   x89
07312:  CLRF   x8A
07314:  CLRF   x8B
07316:  CLRF   x8C
07318:  CLRF   x8D
0731A:  CLRF   x8E
0731C:  CLRF   x8F
0731E:  CLRF   x90
07320:  CLRF   x91
07322:  CLRF   x92
07324:  CLRF   x93
07326:  CLRF   x94
07328:  CLRF   x95
0732A:  CLRF   x96
0732C:  CLRF   x97
0732E:  CLRF   x98
07330:  CLRF   x99
07332:  CLRF   x9A
07334:  CLRF   x9B
07336:  CLRF   x9C
07338:  CLRF   x9D
0733A:  CLRF   x9E
0733C:  CLRF   x9F
0733E:  CLRF   xA0
07340:  CLRF   xA1
07342:  CLRF   xA2
07344:  CLRF   xA3
07346:  CLRF   xA4
07348:  CLRF   xA5
0734A:  CLRF   xA6
0734C:  CLRF   xA7
0734E:  CLRF   xA8
07350:  CLRF   xA9
07352:  CLRF   xAA
07354:  CLRF   xAB
07356:  CLRF   xAC
07358:  CLRF   xAD
0735A:  CLRF   xAE
0735C:  CLRF   xAF
0735E:  CLRF   xB0
07360:  CLRF   xB1
07362:  CLRF   xB2
07364:  CLRF   xB3
07366:  CLRF   xB4
07368:  CLRF   xB5
0736A:  CLRF   xB6
0736C:  CLRF   xB7
0736E:  CLRF   xB8
07370:  CLRF   xB9
07372:  CLRF   xBA
07374:  CLRF   xBB
07376:  CLRF   xBC
07378:  CLRF   xBD
0737A:  CLRF   xBE
0737C:  CLRF   xBF
0737E:  CLRF   xC0
07380:  CLRF   xC1
07382:  CLRF   xC2
07384:  CLRF   xC3
07386:  CLRF   xC4
07388:  CLRF   xC5
0738A:  CLRF   xC6
0738C:  CLRF   xC7
0738E:  CLRF   xC8
07390:  CLRF   xC9
07392:  CLRF   xCA
07394:  CLRF   xCB
07396:  CLRF   xCC
07398:  CLRF   xCD
0739A:  CLRF   xCE
0739C:  CLRF   xCF
0739E:  CLRF   xD0
073A0:  CLRF   xD1
073A2:  CLRF   xD2
073A4:  CLRF   xD3
073A6:  CLRF   xD4
073A8:  CLRF   xD5
073AA:  CLRF   xD6
073AC:  CLRF   xD7
073AE:  CLRF   xD8
073B0:  CLRF   xD9
073B2:  CLRF   xDA
073B4:  CLRF   xDB
073B6:  CLRF   xDC
073B8:  CLRF   xDD
073BA:  CLRF   xDE
073BC:  CLRF   xDF
073BE:  CLRF   xE0
073C0:  CLRF   xE1
073C2:  CLRF   xE2
073C4:  CLRF   xE3
073C6:  CLRF   xE4
073C8:  CLRF   xE5
073CA:  CLRF   xE6
073CC:  CLRF   xE7
073CE:  CLRF   xE8
073D0:  CLRF   xE9
073D2:  CLRF   xEA
073D4:  CLRF   xEB
073D6:  CLRF   xEC
073D8:  CLRF   xED
073DA:  CLRF   xEE
073DC:  CLRF   xEF
073DE:  CLRF   xF0
073E0:  CLRF   xF1
073E2:  CLRF   xF2
073E4:  CLRF   xF3
073E6:  CLRF   xF4
073E8:  CLRF   xF5
073EA:  CLRF   xF6
073EC:  CLRF   xF7
073EE:  CLRF   xF8
073F0:  CLRF   xF9
073F2:  CLRF   xFA
073F4:  CLRF   xFB
073F6:  CLRF   xFC
073F8:  CLRF   xFD
073FA:  CLRF   xFE
073FC:  CLRF   xFF
073FE:  MOVLB  3
07400:  CLRF   x00
07402:  CLRF   x01
07404:  CLRF   x02
07406:  CLRF   x03
07408:  CLRF   x04
0740A:  CLRF   x05
0740C:  CLRF   x06
0740E:  CLRF   x07
07410:  CLRF   x08
07412:  CLRF   x09
07414:  CLRF   x0A
07416:  CLRF   x0B
07418:  CLRF   x0C
0741A:  CLRF   x0D
0741C:  CLRF   x0E
0741E:  CLRF   x0F
07420:  CLRF   x10
07422:  CLRF   x11
07424:  CLRF   x12
07426:  CLRF   x13
07428:  CLRF   x14
0742A:  CLRF   x15
0742C:  CLRF   x16
0742E:  CLRF   x17
07430:  CLRF   x18
07432:  CLRF   x19
07434:  CLRF   x1A
07436:  CLRF   x1B
07438:  CLRF   x1C
0743A:  CLRF   x1D
0743C:  CLRF   x1E
0743E:  CLRF   x1F
07440:  CLRF   x20
07442:  CLRF   x21
07444:  CLRF   x22
07446:  CLRF   x23
07448:  CLRF   x24
0744A:  CLRF   x25
0744C:  CLRF   x26
0744E:  CLRF   x27
07450:  CLRF   x28
07452:  CLRF   x29
07454:  CLRF   x2A
07456:  CLRF   x2B
07458:  CLRF   x2C
0745A:  CLRF   x2D
0745C:  CLRF   x2E
0745E:  CLRF   x2F
07460:  CLRF   x30
07462:  CLRF   x31
07464:  CLRF   x32
07466:  CLRF   x33
07468:  CLRF   x34
0746A:  CLRF   x35
0746C:  CLRF   x36
0746E:  CLRF   x37
07470:  CLRF   x38
07472:  CLRF   x39
07474:  CLRF   x3A
07476:  CLRF   x3B
07478:  CLRF   x3C
0747A:  CLRF   x3D
0747C:  CLRF   x3E
0747E:  CLRF   x3F
07480:  CLRF   x40
07482:  CLRF   x41
07484:  CLRF   x42
07486:  CLRF   x43
07488:  CLRF   x44
0748A:  CLRF   x45
0748C:  CLRF   x46
0748E:  CLRF   x47
07490:  CLRF   x48
07492:  CLRF   x49
07494:  CLRF   x4A
07496:  CLRF   x4B
07498:  CLRF   x4C
0749A:  CLRF   x4D
0749C:  CLRF   x4E
0749E:  CLRF   x4F
074A0:  CLRF   x50
074A2:  CLRF   x51
074A4:  CLRF   x52
074A6:  CLRF   x53
074A8:  CLRF   x54
074AA:  CLRF   x55
074AC:  CLRF   x56
074AE:  CLRF   x57
074B0:  CLRF   x58
074B2:  CLRF   x59
074B4:  CLRF   x5A
074B6:  CLRF   x5B
074B8:  CLRF   x5C
074BA:  CLRF   x5D
074BC:  CLRF   x5E
074BE:  CLRF   x5F
074C0:  CLRF   x60
074C2:  CLRF   x61
074C4:  CLRF   x62
074C6:  CLRF   x63
074C8:  CLRF   x64
074CA:  CLRF   x65
074CC:  CLRF   x66
074CE:  CLRF   x67
074D0:  CLRF   x68
074D2:  CLRF   x69
074D4:  CLRF   x6A
074D6:  CLRF   x6B
074D8:  CLRF   x6C
074DA:  CLRF   x6D
074DC:  CLRF   x6E
074DE:  CLRF   x6F
074E0:  CLRF   x70
074E2:  CLRF   x71
074E4:  CLRF   x72
074E6:  CLRF   x73
074E8:  CLRF   x74
074EA:  CLRF   x75
074EC:  CLRF   x76
074EE:  CLRF   x77
074F0:  CLRF   x78
074F2:  CLRF   x79
074F4:  CLRF   x7A
074F6:  CLRF   x7B
074F8:  CLRF   x7C
074FA:  CLRF   x7D
074FC:  CLRF   x7E
074FE:  CLRF   x7F
07500:  CLRF   x80
07502:  CLRF   x81
07504:  CLRF   x82
07506:  CLRF   x83
07508:  CLRF   x84
0750A:  CLRF   x85
0750C:  CLRF   x86
0750E:  CLRF   x87
07510:  CLRF   x88
07512:  CLRF   x89
07514:  CLRF   x8A
07516:  CLRF   x8B
07518:  CLRF   x8C
0751A:  CLRF   x8D
0751C:  CLRF   x8E
0751E:  CLRF   x8F
07520:  CLRF   x90
07522:  CLRF   x91
07524:  CLRF   x92
07526:  CLRF   x93
07528:  CLRF   x94
0752A:  CLRF   x95
0752C:  CLRF   x96
0752E:  CLRF   x97
07530:  CLRF   x98
07532:  CLRF   x99
07534:  CLRF   x9A
07536:  CLRF   x9B
07538:  CLRF   x9C
0753A:  CLRF   x9D
0753C:  CLRF   x9E
0753E:  CLRF   x9F
07540:  CLRF   xA0
07542:  CLRF   xA1
07544:  CLRF   xA2
07546:  CLRF   xA3
07548:  CLRF   xA4
0754A:  CLRF   xA5
0754C:  CLRF   xA6
0754E:  CLRF   xA7
07550:  CLRF   xA8
07552:  CLRF   xA9
07554:  CLRF   xAA
07556:  CLRF   xAB
07558:  CLRF   xAC
0755A:  CLRF   xAD
0755C:  CLRF   xAE
0755E:  CLRF   xAF
07560:  CLRF   xB0
07562:  CLRF   xB1
07564:  CLRF   xB2
07566:  CLRF   xB3
07568:  CLRF   xB4
0756A:  CLRF   xB5
0756C:  CLRF   xB6
0756E:  CLRF   xB7
07570:  CLRF   xB8
07572:  CLRF   xB9
07574:  CLRF   xBA
07576:  CLRF   xBB
07578:  CLRF   xBC
0757A:  CLRF   xBD
0757C:  CLRF   xBE
0757E:  CLRF   xBF
07580:  CLRF   xC0
07582:  CLRF   xC1
07584:  CLRF   xC2
07586:  CLRF   xC3
07588:  CLRF   xC4
0758A:  CLRF   xC5
0758C:  CLRF   xC6
0758E:  CLRF   xC7
07590:  CLRF   xC8
07592:  CLRF   xC9
07594:  CLRF   xCA
07596:  CLRF   xCB
07598:  CLRF   xCC
0759A:  CLRF   xCD
0759C:  CLRF   xCE
0759E:  CLRF   xCF
075A0:  CLRF   xD0
075A2:  CLRF   xD1
075A4:  CLRF   xD2
075A6:  CLRF   xD3
075A8:  CLRF   xD4
075AA:  CLRF   xD5
075AC:  CLRF   xD6
075AE:  CLRF   xD7
075B0:  CLRF   xD8
075B2:  CLRF   xD9
075B4:  CLRF   xDA
075B6:  CLRF   xDB
075B8:  CLRF   xDC
075BA:  CLRF   xDD
075BC:  CLRF   xDE
075BE:  CLRF   xDF
075C0:  CLRF   xE0
075C2:  CLRF   xE1
075C4:  CLRF   xE2
075C6:  CLRF   xE3
075C8:  CLRF   xE4
075CA:  CLRF   xE5
075CC:  CLRF   xE6
075CE:  CLRF   xE7
075D0:  CLRF   xE8
075D2:  CLRF   xE9
075D4:  CLRF   xEA
075D6:  CLRF   xEB
075D8:  CLRF   xEC
075DA:  CLRF   xED
075DC:  CLRF   xEE
075DE:  CLRF   xEF
075E0:  CLRF   xF0
075E2:  CLRF   xF1
075E4:  CLRF   xF2
075E6:  CLRF   xF3
075E8:  CLRF   xF4
075EA:  CLRF   xF5
075EC:  CLRF   xF6
075EE:  CLRF   xF7
075F0:  CLRF   xF8
075F2:  CLRF   xF9
075F4:  CLRF   xFA
075F6:  CLRF   xFB
075F8:  CLRF   xFC
075FA:  CLRF   xFD
075FC:  CLRF   xFE
075FE:  CLRF   xFF
07600:  MOVLB  4
07602:  CLRF   x00
07604:  CLRF   x01
07606:  CLRF   x02
07608:  CLRF   x03
0760A:  CLRF   x04
0760C:  CLRF   x05
0760E:  CLRF   x06
07610:  CLRF   x07
07612:  CLRF   x08
07614:  CLRF   x09
07616:  CLRF   x0A
07618:  CLRF   x0B
0761A:  CLRF   x0C
0761C:  CLRF   x0D
0761E:  CLRF   x0E
07620:  CLRF   x0F
07622:  CLRF   x10
07624:  CLRF   x11
07626:  CLRF   x12
07628:  CLRF   x13
0762A:  CLRF   x14
0762C:  CLRF   x15
0762E:  CLRF   x16
07630:  CLRF   x17
07632:  CLRF   x18
07634:  CLRF   x19
07636:  CLRF   x1A
07638:  CLRF   x1B
0763A:  CLRF   x1C
0763C:  CLRF   x1D
0763E:  CLRF   x1E
07640:  CLRF   x1F
07642:  CLRF   x20
07644:  CLRF   x21
07646:  CLRF   x22
07648:  CLRF   x23
0764A:  CLRF   x24
0764C:  CLRF   x25
0764E:  CLRF   x26
07650:  CLRF   x27
07652:  CLRF   x28
07654:  CLRF   x29
07656:  CLRF   x2A
07658:  CLRF   x2B
0765A:  CLRF   x2C
0765C:  CLRF   x2D
0765E:  CLRF   x2E
07660:  CLRF   x2F
07662:  CLRF   x30
07664:  CLRF   x31
07666:  CLRF   x32
07668:  CLRF   x33
0766A:  CLRF   x34
0766C:  CLRF   x35
0766E:  CLRF   x36
07670:  CLRF   x37
07672:  CLRF   x38
07674:  CLRF   x39
07676:  CLRF   x3A
07678:  CLRF   x3B
0767A:  CLRF   x3C
0767C:  CLRF   x3D
0767E:  CLRF   x3E
07680:  CLRF   x3F
07682:  CLRF   x40
07684:  CLRF   x41
07686:  CLRF   x42
07688:  CLRF   x43
0768A:  CLRF   x44
0768C:  CLRF   x45
0768E:  CLRF   x46
07690:  CLRF   x47
07692:  CLRF   x48
07694:  CLRF   x49
07696:  CLRF   x4A
07698:  CLRF   x4B
0769A:  CLRF   x4C
0769C:  CLRF   x4D
0769E:  CLRF   x4E
076A0:  CLRF   x4F
076A2:  CLRF   x50
076A4:  CLRF   x51
076A6:  CLRF   x52
076A8:  CLRF   x53
076AA:  CLRF   x54
076AC:  CLRF   x55
076AE:  CLRF   x56
076B0:  CLRF   x57
076B2:  CLRF   x58
076B4:  CLRF   x59
076B6:  CLRF   x5A
076B8:  CLRF   x5B
076BA:  CLRF   x5C
076BC:  CLRF   x5D
076BE:  CLRF   x5E
076C0:  CLRF   x5F
076C2:  CLRF   x60
076C4:  CLRF   x61
076C6:  CLRF   x62
076C8:  CLRF   x63
076CA:  CLRF   x64
076CC:  CLRF   x65
076CE:  CLRF   x66
076D0:  CLRF   x67
076D2:  CLRF   x68
076D4:  CLRF   x69
076D6:  CLRF   x6A
076D8:  CLRF   x6B
076DA:  CLRF   x6C
076DC:  CLRF   x6D
076DE:  CLRF   x6E
076E0:  CLRF   x6F
076E2:  CLRF   x70
076E4:  CLRF   x71
076E6:  CLRF   x72
076E8:  CLRF   x73
076EA:  CLRF   x74
076EC:  CLRF   x75
076EE:  CLRF   x76
076F0:  CLRF   x77
076F2:  CLRF   x78
076F4:  CLRF   x79
076F6:  CLRF   x7A
076F8:  CLRF   x7B
076FA:  CLRF   x7C
076FC:  CLRF   x7D
076FE:  CLRF   x7E
07700:  CLRF   x7F
07702:  CLRF   x80
07704:  CLRF   x81
07706:  CLRF   x82
07708:  CLRF   x83
0770A:  CLRF   x84
0770C:  CLRF   x85
0770E:  CLRF   x86
07710:  CLRF   x87
07712:  CLRF   x88
07714:  CLRF   x89
07716:  CLRF   x8A
07718:  CLRF   x8B
0771A:  CLRF   x8C
0771C:  CLRF   x8D
0771E:  CLRF   x8E
07720:  CLRF   x8F
07722:  CLRF   x90
07724:  CLRF   x91
07726:  CLRF   x92
07728:  CLRF   x93
0772A:  CLRF   x94
0772C:  CLRF   x95
0772E:  CLRF   x96
07730:  CLRF   x97
07732:  CLRF   x98
07734:  CLRF   x99
07736:  CLRF   x9A
07738:  CLRF   x9B
0773A:  CLRF   x9C
0773C:  CLRF   x9D
0773E:  CLRF   x9E
07740:  CLRF   x9F
07742:  CLRF   xA0
07744:  CLRF   xA1
07746:  CLRF   xA2
07748:  CLRF   xA3
0774A:  CLRF   xA4
0774C:  CLRF   xA5
0774E:  CLRF   xA6
07750:  CLRF   xA7
07752:  CLRF   xA8
07754:  CLRF   xA9
07756:  CLRF   xAA
07758:  CLRF   xAB
0775A:  CLRF   xAC
0775C:  CLRF   xAD
0775E:  CLRF   xAE
07760:  CLRF   xAF
07762:  CLRF   xB0
07764:  CLRF   xB1
07766:  CLRF   xB2
07768:  CLRF   xB3
0776A:  CLRF   xB4
0776C:  CLRF   xB5
0776E:  CLRF   xB6
07770:  CLRF   xB7
07772:  CLRF   xB8
07774:  CLRF   xB9
07776:  CLRF   xBA
07778:  CLRF   xBB
0777A:  CLRF   xBC
0777C:  CLRF   xBD
0777E:  CLRF   xBE
07780:  CLRF   xBF
07782:  CLRF   xC0
07784:  CLRF   xC1
07786:  CLRF   xC2
07788:  CLRF   xC3
0778A:  CLRF   xC4
0778C:  CLRF   xC5
0778E:  CLRF   xC6
07790:  CLRF   xC7
07792:  CLRF   xC8
07794:  CLRF   xC9
07796:  CLRF   xCA
07798:  CLRF   xCB
0779A:  CLRF   xCC
0779C:  CLRF   xCD
0779E:  CLRF   xCE
077A0:  CLRF   xCF
077A2:  CLRF   xD0
077A4:  CLRF   xD1
077A6:  CLRF   xD2
077A8:  CLRF   xD3
077AA:  CLRF   xD4
077AC:  CLRF   xD5
077AE:  CLRF   xD6
077B0:  CLRF   xD7
077B2:  CLRF   xD8
077B4:  CLRF   xD9
077B6:  CLRF   xDA
077B8:  CLRF   xDB
077BA:  CLRF   xDC
077BC:  CLRF   xDD
077BE:  CLRF   xDE
077C0:  CLRF   xDF
077C2:  CLRF   xE0
077C4:  CLRF   xE1
077C6:  CLRF   xE2
077C8:  CLRF   xE3
077CA:  CLRF   xE4
077CC:  CLRF   xE5
077CE:  CLRF   xE6
077D0:  CLRF   xE7
077D2:  CLRF   xE8
077D4:  CLRF   xE9
077D6:  CLRF   xEA
077D8:  CLRF   xEB
077DA:  CLRF   xEC
077DC:  CLRF   xED
077DE:  CLRF   xEE
077E0:  CLRF   xEF
077E2:  CLRF   xF0
077E4:  CLRF   xF1
077E6:  CLRF   xF2
077E8:  CLRF   xF3
077EA:  CLRF   xF4
077EC:  CLRF   xF5
077EE:  CLRF   xF6
077F0:  CLRF   xF7
077F2:  CLRF   xF8
077F4:  CLRF   xF9
077F6:  CLRF   xFA
077F8:  CLRF   xFB
077FA:  CLRF   xFC
077FC:  CLRF   xFD
077FE:  CLRF   xFE
07800:  CLRF   xFF
07802:  MOVLB  5
07804:  CLRF   x00
07806:  CLRF   x01
07808:  CLRF   x02
0780A:  CLRF   x03
0780C:  CLRF   x04
0780E:  CLRF   x05
07810:  CLRF   x06
07812:  CLRF   x07
07814:  CLRF   x08
07816:  CLRF   x09
07818:  CLRF   x0A
0781A:  CLRF   x0B
0781C:  CLRF   x0C
0781E:  CLRF   x0D
07820:  CLRF   x0E
07822:  CLRF   x0F
07824:  CLRF   x10
07826:  CLRF   x11
07828:  CLRF   x12
0782A:  CLRF   x13
0782C:  CLRF   x14
0782E:  CLRF   x15
07830:  CLRF   x16
07832:  CLRF   x17
07834:  CLRF   x18
07836:  CLRF   x19
07838:  CLRF   x1A
0783A:  CLRF   x1B
0783C:  CLRF   x1C
0783E:  CLRF   x1D
07840:  CLRF   x1E
07842:  CLRF   x1F
07844:  CLRF   x20
07846:  CLRF   x21
07848:  CLRF   x22
0784A:  CLRF   x23
0784C:  CLRF   x24
0784E:  CLRF   x25
07850:  CLRF   x26
07852:  CLRF   x27
07854:  CLRF   x28
07856:  CLRF   x29
07858:  CLRF   x2A
0785A:  CLRF   x2B
0785C:  CLRF   x2C
0785E:  CLRF   x2D
07860:  CLRF   x2E
07862:  CLRF   x2F
07864:  CLRF   x30
07866:  CLRF   x31
07868:  CLRF   x32
0786A:  CLRF   x33
0786C:  CLRF   x34
0786E:  CLRF   x35
07870:  CLRF   x36
07872:  CLRF   x37
07874:  CLRF   x38
07876:  CLRF   x39
07878:  CLRF   x3A
0787A:  CLRF   x3B
0787C:  CLRF   x3C
0787E:  CLRF   x3D
07880:  CLRF   x3E
07882:  CLRF   x3F
07884:  CLRF   x40
07886:  CLRF   x41
07888:  CLRF   x42
0788A:  CLRF   x43
0788C:  CLRF   x44
0788E:  CLRF   x45
07890:  CLRF   x46
07892:  CLRF   x47
07894:  CLRF   x48
07896:  CLRF   x49
07898:  CLRF   x4A
0789A:  CLRF   x4B
0789C:  CLRF   x4C
0789E:  CLRF   x4D
078A0:  CLRF   x4E
078A2:  CLRF   x4F
078A4:  CLRF   x50
078A6:  CLRF   x51
078A8:  CLRF   x52
078AA:  CLRF   x53
078AC:  CLRF   x54
078AE:  CLRF   x55
078B0:  CLRF   x56
078B2:  CLRF   x57
078B4:  CLRF   x58
078B6:  CLRF   x59
078B8:  CLRF   x5A
078BA:  CLRF   x5B
078BC:  CLRF   x5C
078BE:  CLRF   x5D
078C0:  CLRF   x5E
078C2:  CLRF   x5F
078C4:  CLRF   x60
078C6:  CLRF   x61
078C8:  CLRF   x62
078CA:  CLRF   x63
078CC:  CLRF   x64
078CE:  CLRF   x65
078D0:  CLRF   x66
078D2:  CLRF   x67
078D4:  CLRF   x68
078D6:  CLRF   x69
078D8:  CLRF   x6A
078DA:  CLRF   x6B
078DC:  CLRF   x6C
078DE:  CLRF   x6D
078E0:  CLRF   x6E
078E2:  CLRF   x6F
078E4:  CLRF   x70
078E6:  CLRF   x71
078E8:  CLRF   x72
078EA:  CLRF   x73
078EC:  CLRF   x74
078EE:  CLRF   x75
078F0:  CLRF   x76
078F2:  CLRF   x77
078F4:  CLRF   x78
078F6:  CLRF   x79
078F8:  CLRF   x7A
078FA:  CLRF   x7B
078FC:  CLRF   x7C
078FE:  CLRF   x7D
07900:  CLRF   x7E
07902:  CLRF   x7F
07904:  CLRF   x80
07906:  CLRF   x81
07908:  CLRF   x82
0790A:  CLRF   x83
0790C:  CLRF   x84
0790E:  CLRF   x85
07910:  CLRF   x86
07912:  CLRF   x87
07914:  CLRF   x88
07916:  CLRF   x89
07918:  CLRF   x8A
0791A:  CLRF   x8B
0791C:  CLRF   x8C
0791E:  CLRF   x8D
07920:  CLRF   x8E
07922:  CLRF   x8F
07924:  CLRF   x90
07926:  CLRF   x91
07928:  CLRF   x92
0792A:  CLRF   x93
0792C:  CLRF   x94
0792E:  CLRF   x95
07930:  CLRF   x96
07932:  CLRF   x97
07934:  CLRF   x98
07936:  CLRF   x99
07938:  CLRF   x9A
0793A:  CLRF   x9B
0793C:  CLRF   x9C
0793E:  CLRF   x9D
07940:  CLRF   x9E
07942:  CLRF   x9F
07944:  CLRF   xA0
07946:  CLRF   xA1
07948:  CLRF   xA2
0794A:  CLRF   xA3
0794C:  CLRF   xA4
0794E:  CLRF   xA5
07950:  CLRF   xA6
07952:  CLRF   xA7
07954:  CLRF   xA8
07956:  CLRF   xA9
07958:  CLRF   xAA
0795A:  CLRF   xAB
0795C:  CLRF   xAC
0795E:  CLRF   xAD
07960:  CLRF   xAE
07962:  CLRF   xAF
07964:  CLRF   xB0
....................     port1.port_num = 1;
07966:  MOVLW  01
07968:  MOVLB  1
0796A:  MOVWF  xB1
....................     port1.sweep_step = 0;
0796C:  CLRF   xB3
0796E:  CLRF   xB2
....................     port1.active = 1;
07970:  MOVLB  5
07972:  BSF    xB0.0
.................... 
....................     // Init Port2
....................     SWEEP_CONFIG port2 = {0};
07974:  CLRF   xB1
07976:  CLRF   xB2
07978:  CLRF   xB3
0797A:  CLRF   xB4
0797C:  CLRF   xB5
0797E:  CLRF   xB6
07980:  CLRF   xB7
07982:  CLRF   xB8
07984:  CLRF   xB9
07986:  CLRF   xBA
07988:  CLRF   xBB
0798A:  CLRF   xBC
0798C:  CLRF   xBD
0798E:  CLRF   xBE
07990:  CLRF   xBF
07992:  CLRF   xC0
07994:  CLRF   xC1
07996:  CLRF   xC2
07998:  CLRF   xC3
0799A:  CLRF   xC4
0799C:  CLRF   xC5
0799E:  CLRF   xC6
079A0:  CLRF   xC7
079A2:  CLRF   xC8
079A4:  CLRF   xC9
079A6:  CLRF   xCA
079A8:  CLRF   xCB
079AA:  CLRF   xCC
079AC:  CLRF   xCD
079AE:  CLRF   xCE
079B0:  CLRF   xCF
079B2:  CLRF   xD0
079B4:  CLRF   xD1
079B6:  CLRF   xD2
079B8:  CLRF   xD3
079BA:  CLRF   xD4
079BC:  CLRF   xD5
079BE:  CLRF   xD6
079C0:  CLRF   xD7
079C2:  CLRF   xD8
079C4:  CLRF   xD9
079C6:  CLRF   xDA
079C8:  CLRF   xDB
079CA:  CLRF   xDC
079CC:  CLRF   xDD
079CE:  CLRF   xDE
079D0:  CLRF   xDF
079D2:  CLRF   xE0
079D4:  CLRF   xE1
079D6:  CLRF   xE2
079D8:  CLRF   xE3
079DA:  CLRF   xE4
079DC:  CLRF   xE5
079DE:  CLRF   xE6
079E0:  CLRF   xE7
079E2:  CLRF   xE8
079E4:  CLRF   xE9
079E6:  CLRF   xEA
079E8:  CLRF   xEB
079EA:  CLRF   xEC
079EC:  CLRF   xED
079EE:  CLRF   xEE
079F0:  CLRF   xEF
079F2:  CLRF   xF0
079F4:  CLRF   xF1
079F6:  CLRF   xF2
079F8:  CLRF   xF3
079FA:  CLRF   xF4
079FC:  CLRF   xF5
079FE:  CLRF   xF6
07A00:  CLRF   xF7
07A02:  CLRF   xF8
07A04:  CLRF   xF9
07A06:  CLRF   xFA
07A08:  CLRF   xFB
07A0A:  CLRF   xFC
07A0C:  CLRF   xFD
07A0E:  CLRF   xFE
07A10:  CLRF   xFF
07A12:  MOVLB  6
07A14:  CLRF   x00
07A16:  CLRF   x01
07A18:  CLRF   x02
07A1A:  CLRF   x03
07A1C:  CLRF   x04
07A1E:  CLRF   x05
07A20:  CLRF   x06
07A22:  CLRF   x07
07A24:  CLRF   x08
07A26:  CLRF   x09
07A28:  CLRF   x0A
07A2A:  CLRF   x0B
07A2C:  CLRF   x0C
07A2E:  CLRF   x0D
07A30:  CLRF   x0E
07A32:  CLRF   x0F
07A34:  CLRF   x10
07A36:  CLRF   x11
07A38:  CLRF   x12
07A3A:  CLRF   x13
07A3C:  CLRF   x14
07A3E:  CLRF   x15
07A40:  CLRF   x16
07A42:  CLRF   x17
07A44:  CLRF   x18
07A46:  CLRF   x19
07A48:  CLRF   x1A
07A4A:  CLRF   x1B
07A4C:  CLRF   x1C
07A4E:  CLRF   x1D
07A50:  CLRF   x1E
07A52:  CLRF   x1F
07A54:  CLRF   x20
07A56:  CLRF   x21
07A58:  CLRF   x22
07A5A:  CLRF   x23
07A5C:  CLRF   x24
07A5E:  CLRF   x25
07A60:  CLRF   x26
07A62:  CLRF   x27
07A64:  CLRF   x28
07A66:  CLRF   x29
07A68:  CLRF   x2A
07A6A:  CLRF   x2B
07A6C:  CLRF   x2C
07A6E:  CLRF   x2D
07A70:  CLRF   x2E
07A72:  CLRF   x2F
07A74:  CLRF   x30
07A76:  CLRF   x31
07A78:  CLRF   x32
07A7A:  CLRF   x33
07A7C:  CLRF   x34
07A7E:  CLRF   x35
07A80:  CLRF   x36
07A82:  CLRF   x37
07A84:  CLRF   x38
07A86:  CLRF   x39
07A88:  CLRF   x3A
07A8A:  CLRF   x3B
07A8C:  CLRF   x3C
07A8E:  CLRF   x3D
07A90:  CLRF   x3E
07A92:  CLRF   x3F
07A94:  CLRF   x40
07A96:  CLRF   x41
07A98:  CLRF   x42
07A9A:  CLRF   x43
07A9C:  CLRF   x44
07A9E:  CLRF   x45
07AA0:  CLRF   x46
07AA2:  CLRF   x47
07AA4:  CLRF   x48
07AA6:  CLRF   x49
07AA8:  CLRF   x4A
07AAA:  CLRF   x4B
07AAC:  CLRF   x4C
07AAE:  CLRF   x4D
07AB0:  CLRF   x4E
07AB2:  CLRF   x4F
07AB4:  CLRF   x50
07AB6:  CLRF   x51
07AB8:  CLRF   x52
07ABA:  CLRF   x53
07ABC:  CLRF   x54
07ABE:  CLRF   x55
07AC0:  CLRF   x56
07AC2:  CLRF   x57
07AC4:  CLRF   x58
07AC6:  CLRF   x59
07AC8:  CLRF   x5A
07ACA:  CLRF   x5B
07ACC:  CLRF   x5C
07ACE:  CLRF   x5D
07AD0:  CLRF   x5E
07AD2:  CLRF   x5F
07AD4:  CLRF   x60
07AD6:  CLRF   x61
07AD8:  CLRF   x62
07ADA:  CLRF   x63
07ADC:  CLRF   x64
07ADE:  CLRF   x65
07AE0:  CLRF   x66
07AE2:  CLRF   x67
07AE4:  CLRF   x68
07AE6:  CLRF   x69
07AE8:  CLRF   x6A
07AEA:  CLRF   x6B
07AEC:  CLRF   x6C
07AEE:  CLRF   x6D
07AF0:  CLRF   x6E
07AF2:  CLRF   x6F
07AF4:  CLRF   x70
07AF6:  CLRF   x71
07AF8:  CLRF   x72
07AFA:  CLRF   x73
07AFC:  CLRF   x74
07AFE:  CLRF   x75
07B00:  CLRF   x76
07B02:  CLRF   x77
07B04:  CLRF   x78
07B06:  CLRF   x79
07B08:  CLRF   x7A
07B0A:  CLRF   x7B
07B0C:  CLRF   x7C
07B0E:  CLRF   x7D
07B10:  CLRF   x7E
07B12:  CLRF   x7F
07B14:  CLRF   x80
07B16:  CLRF   x81
07B18:  CLRF   x82
07B1A:  CLRF   x83
07B1C:  CLRF   x84
07B1E:  CLRF   x85
07B20:  CLRF   x86
07B22:  CLRF   x87
07B24:  CLRF   x88
07B26:  CLRF   x89
07B28:  CLRF   x8A
07B2A:  CLRF   x8B
07B2C:  CLRF   x8C
07B2E:  CLRF   x8D
07B30:  CLRF   x8E
07B32:  CLRF   x8F
07B34:  CLRF   x90
07B36:  CLRF   x91
07B38:  CLRF   x92
07B3A:  CLRF   x93
07B3C:  CLRF   x94
07B3E:  CLRF   x95
07B40:  CLRF   x96
07B42:  CLRF   x97
07B44:  CLRF   x98
07B46:  CLRF   x99
07B48:  CLRF   x9A
07B4A:  CLRF   x9B
07B4C:  CLRF   x9C
07B4E:  CLRF   x9D
07B50:  CLRF   x9E
07B52:  CLRF   x9F
07B54:  CLRF   xA0
07B56:  CLRF   xA1
07B58:  CLRF   xA2
07B5A:  CLRF   xA3
07B5C:  CLRF   xA4
07B5E:  CLRF   xA5
07B60:  CLRF   xA6
07B62:  CLRF   xA7
07B64:  CLRF   xA8
07B66:  CLRF   xA9
07B68:  CLRF   xAA
07B6A:  CLRF   xAB
07B6C:  CLRF   xAC
07B6E:  CLRF   xAD
07B70:  CLRF   xAE
07B72:  CLRF   xAF
07B74:  CLRF   xB0
07B76:  CLRF   xB1
07B78:  CLRF   xB2
07B7A:  CLRF   xB3
07B7C:  CLRF   xB4
07B7E:  CLRF   xB5
07B80:  CLRF   xB6
07B82:  CLRF   xB7
07B84:  CLRF   xB8
07B86:  CLRF   xB9
07B88:  CLRF   xBA
07B8A:  CLRF   xBB
07B8C:  CLRF   xBC
07B8E:  CLRF   xBD
07B90:  CLRF   xBE
07B92:  CLRF   xBF
07B94:  CLRF   xC0
07B96:  CLRF   xC1
07B98:  CLRF   xC2
07B9A:  CLRF   xC3
07B9C:  CLRF   xC4
07B9E:  CLRF   xC5
07BA0:  CLRF   xC6
07BA2:  CLRF   xC7
07BA4:  CLRF   xC8
07BA6:  CLRF   xC9
07BA8:  CLRF   xCA
07BAA:  CLRF   xCB
07BAC:  CLRF   xCC
07BAE:  CLRF   xCD
07BB0:  CLRF   xCE
07BB2:  CLRF   xCF
07BB4:  CLRF   xD0
07BB6:  CLRF   xD1
07BB8:  CLRF   xD2
07BBA:  CLRF   xD3
07BBC:  CLRF   xD4
07BBE:  CLRF   xD5
07BC0:  CLRF   xD6
07BC2:  CLRF   xD7
07BC4:  CLRF   xD8
07BC6:  CLRF   xD9
07BC8:  CLRF   xDA
07BCA:  CLRF   xDB
07BCC:  CLRF   xDC
07BCE:  CLRF   xDD
07BD0:  CLRF   xDE
07BD2:  CLRF   xDF
07BD4:  CLRF   xE0
07BD6:  CLRF   xE1
07BD8:  CLRF   xE2
07BDA:  CLRF   xE3
07BDC:  CLRF   xE4
07BDE:  CLRF   xE5
07BE0:  CLRF   xE6
07BE2:  CLRF   xE7
07BE4:  CLRF   xE8
07BE6:  CLRF   xE9
07BE8:  CLRF   xEA
07BEA:  CLRF   xEB
07BEC:  CLRF   xEC
07BEE:  CLRF   xED
07BF0:  CLRF   xEE
07BF2:  CLRF   xEF
07BF4:  CLRF   xF0
07BF6:  CLRF   xF1
07BF8:  CLRF   xF2
07BFA:  CLRF   xF3
07BFC:  CLRF   xF4
07BFE:  CLRF   xF5
07C00:  CLRF   xF6
07C02:  CLRF   xF7
07C04:  CLRF   xF8
07C06:  CLRF   xF9
07C08:  CLRF   xFA
07C0A:  CLRF   xFB
07C0C:  CLRF   xFC
07C0E:  CLRF   xFD
07C10:  CLRF   xFE
07C12:  CLRF   xFF
07C14:  MOVLB  7
07C16:  CLRF   x00
07C18:  CLRF   x01
07C1A:  CLRF   x02
07C1C:  CLRF   x03
07C1E:  CLRF   x04
07C20:  CLRF   x05
07C22:  CLRF   x06
07C24:  CLRF   x07
07C26:  CLRF   x08
07C28:  CLRF   x09
07C2A:  CLRF   x0A
07C2C:  CLRF   x0B
07C2E:  CLRF   x0C
07C30:  CLRF   x0D
07C32:  CLRF   x0E
07C34:  CLRF   x0F
07C36:  CLRF   x10
07C38:  CLRF   x11
07C3A:  CLRF   x12
07C3C:  CLRF   x13
07C3E:  CLRF   x14
07C40:  CLRF   x15
07C42:  CLRF   x16
07C44:  CLRF   x17
07C46:  CLRF   x18
07C48:  CLRF   x19
07C4A:  CLRF   x1A
07C4C:  CLRF   x1B
07C4E:  CLRF   x1C
07C50:  CLRF   x1D
07C52:  CLRF   x1E
07C54:  CLRF   x1F
07C56:  CLRF   x20
07C58:  CLRF   x21
07C5A:  CLRF   x22
07C5C:  CLRF   x23
07C5E:  CLRF   x24
07C60:  CLRF   x25
07C62:  CLRF   x26
07C64:  CLRF   x27
07C66:  CLRF   x28
07C68:  CLRF   x29
07C6A:  CLRF   x2A
07C6C:  CLRF   x2B
07C6E:  CLRF   x2C
07C70:  CLRF   x2D
07C72:  CLRF   x2E
07C74:  CLRF   x2F
07C76:  CLRF   x30
07C78:  CLRF   x31
07C7A:  CLRF   x32
07C7C:  CLRF   x33
07C7E:  CLRF   x34
07C80:  CLRF   x35
07C82:  CLRF   x36
07C84:  CLRF   x37
07C86:  CLRF   x38
07C88:  CLRF   x39
07C8A:  CLRF   x3A
07C8C:  CLRF   x3B
07C8E:  CLRF   x3C
07C90:  CLRF   x3D
07C92:  CLRF   x3E
07C94:  CLRF   x3F
07C96:  CLRF   x40
07C98:  CLRF   x41
07C9A:  CLRF   x42
07C9C:  CLRF   x43
07C9E:  CLRF   x44
07CA0:  CLRF   x45
07CA2:  CLRF   x46
07CA4:  CLRF   x47
07CA6:  CLRF   x48
07CA8:  CLRF   x49
07CAA:  CLRF   x4A
07CAC:  CLRF   x4B
07CAE:  CLRF   x4C
07CB0:  CLRF   x4D
07CB2:  CLRF   x4E
07CB4:  CLRF   x4F
07CB6:  CLRF   x50
07CB8:  CLRF   x51
07CBA:  CLRF   x52
07CBC:  CLRF   x53
07CBE:  CLRF   x54
07CC0:  CLRF   x55
07CC2:  CLRF   x56
07CC4:  CLRF   x57
07CC6:  CLRF   x58
07CC8:  CLRF   x59
07CCA:  CLRF   x5A
07CCC:  CLRF   x5B
07CCE:  CLRF   x5C
07CD0:  CLRF   x5D
07CD2:  CLRF   x5E
07CD4:  CLRF   x5F
07CD6:  CLRF   x60
07CD8:  CLRF   x61
07CDA:  CLRF   x62
07CDC:  CLRF   x63
07CDE:  CLRF   x64
07CE0:  CLRF   x65
07CE2:  CLRF   x66
07CE4:  CLRF   x67
07CE6:  CLRF   x68
07CE8:  CLRF   x69
07CEA:  CLRF   x6A
07CEC:  CLRF   x6B
07CEE:  CLRF   x6C
07CF0:  CLRF   x6D
07CF2:  CLRF   x6E
07CF4:  CLRF   x6F
07CF6:  CLRF   x70
07CF8:  CLRF   x71
07CFA:  CLRF   x72
07CFC:  CLRF   x73
07CFE:  CLRF   x74
07D00:  CLRF   x75
07D02:  CLRF   x76
07D04:  CLRF   x77
07D06:  CLRF   x78
07D08:  CLRF   x79
07D0A:  CLRF   x7A
07D0C:  CLRF   x7B
07D0E:  CLRF   x7C
07D10:  CLRF   x7D
07D12:  CLRF   x7E
07D14:  CLRF   x7F
07D16:  CLRF   x80
07D18:  CLRF   x81
07D1A:  CLRF   x82
07D1C:  CLRF   x83
07D1E:  CLRF   x84
07D20:  CLRF   x85
07D22:  CLRF   x86
07D24:  CLRF   x87
07D26:  CLRF   x88
07D28:  CLRF   x89
07D2A:  CLRF   x8A
07D2C:  CLRF   x8B
07D2E:  CLRF   x8C
07D30:  CLRF   x8D
07D32:  CLRF   x8E
07D34:  CLRF   x8F
07D36:  CLRF   x90
07D38:  CLRF   x91
07D3A:  CLRF   x92
07D3C:  CLRF   x93
07D3E:  CLRF   x94
07D40:  CLRF   x95
07D42:  CLRF   x96
07D44:  CLRF   x97
07D46:  CLRF   x98
07D48:  CLRF   x99
07D4A:  CLRF   x9A
07D4C:  CLRF   x9B
07D4E:  CLRF   x9C
07D50:  CLRF   x9D
07D52:  CLRF   x9E
07D54:  CLRF   x9F
07D56:  CLRF   xA0
07D58:  CLRF   xA1
07D5A:  CLRF   xA2
07D5C:  CLRF   xA3
07D5E:  CLRF   xA4
07D60:  CLRF   xA5
07D62:  CLRF   xA6
07D64:  CLRF   xA7
07D66:  CLRF   xA8
07D68:  CLRF   xA9
07D6A:  CLRF   xAA
07D6C:  CLRF   xAB
07D6E:  CLRF   xAC
07D70:  CLRF   xAD
07D72:  CLRF   xAE
07D74:  CLRF   xAF
07D76:  CLRF   xB0
07D78:  CLRF   xB1
07D7A:  CLRF   xB2
07D7C:  CLRF   xB3
07D7E:  CLRF   xB4
07D80:  CLRF   xB5
07D82:  CLRF   xB6
07D84:  CLRF   xB7
07D86:  CLRF   xB8
07D88:  CLRF   xB9
07D8A:  CLRF   xBA
07D8C:  CLRF   xBB
07D8E:  CLRF   xBC
07D90:  CLRF   xBD
07D92:  CLRF   xBE
07D94:  CLRF   xBF
07D96:  CLRF   xC0
07D98:  CLRF   xC1
07D9A:  CLRF   xC2
07D9C:  CLRF   xC3
07D9E:  CLRF   xC4
07DA0:  CLRF   xC5
07DA2:  CLRF   xC6
07DA4:  CLRF   xC7
07DA6:  CLRF   xC8
07DA8:  CLRF   xC9
07DAA:  CLRF   xCA
07DAC:  CLRF   xCB
07DAE:  CLRF   xCC
07DB0:  CLRF   xCD
07DB2:  CLRF   xCE
07DB4:  CLRF   xCF
07DB6:  CLRF   xD0
07DB8:  CLRF   xD1
07DBA:  CLRF   xD2
07DBC:  CLRF   xD3
07DBE:  CLRF   xD4
07DC0:  CLRF   xD5
07DC2:  CLRF   xD6
07DC4:  CLRF   xD7
07DC6:  CLRF   xD8
07DC8:  CLRF   xD9
07DCA:  CLRF   xDA
07DCC:  CLRF   xDB
07DCE:  CLRF   xDC
07DD0:  CLRF   xDD
07DD2:  CLRF   xDE
07DD4:  CLRF   xDF
07DD6:  CLRF   xE0
07DD8:  CLRF   xE1
07DDA:  CLRF   xE2
07DDC:  CLRF   xE3
07DDE:  CLRF   xE4
07DE0:  CLRF   xE5
07DE2:  CLRF   xE6
07DE4:  CLRF   xE7
07DE6:  CLRF   xE8
07DE8:  CLRF   xE9
07DEA:  CLRF   xEA
07DEC:  CLRF   xEB
07DEE:  CLRF   xEC
07DF0:  CLRF   xED
07DF2:  CLRF   xEE
07DF4:  CLRF   xEF
07DF6:  CLRF   xF0
07DF8:  CLRF   xF1
07DFA:  CLRF   xF2
07DFC:  CLRF   xF3
07DFE:  CLRF   xF4
07E00:  CLRF   xF5
07E02:  CLRF   xF6
07E04:  CLRF   xF7
07E06:  CLRF   xF8
07E08:  CLRF   xF9
07E0A:  CLRF   xFA
07E0C:  CLRF   xFB
07E0E:  CLRF   xFC
07E10:  CLRF   xFD
07E12:  CLRF   xFE
07E14:  CLRF   xFF
07E16:  MOVLB  8
07E18:  CLRF   x00
07E1A:  CLRF   x01
07E1C:  CLRF   x02
07E1E:  CLRF   x03
07E20:  CLRF   x04
07E22:  CLRF   x05
07E24:  CLRF   x06
07E26:  CLRF   x07
07E28:  CLRF   x08
07E2A:  CLRF   x09
07E2C:  CLRF   x0A
07E2E:  CLRF   x0B
07E30:  CLRF   x0C
07E32:  CLRF   x0D
07E34:  CLRF   x0E
07E36:  CLRF   x0F
07E38:  CLRF   x10
07E3A:  CLRF   x11
07E3C:  CLRF   x12
07E3E:  CLRF   x13
07E40:  CLRF   x14
07E42:  CLRF   x15
07E44:  CLRF   x16
07E46:  CLRF   x17
07E48:  CLRF   x18
07E4A:  CLRF   x19
07E4C:  CLRF   x1A
07E4E:  CLRF   x1B
07E50:  CLRF   x1C
07E52:  CLRF   x1D
07E54:  CLRF   x1E
07E56:  CLRF   x1F
07E58:  CLRF   x20
07E5A:  CLRF   x21
07E5C:  CLRF   x22
07E5E:  CLRF   x23
07E60:  CLRF   x24
07E62:  CLRF   x25
07E64:  CLRF   x26
07E66:  CLRF   x27
07E68:  CLRF   x28
07E6A:  CLRF   x29
07E6C:  CLRF   x2A
07E6E:  CLRF   x2B
07E70:  CLRF   x2C
07E72:  CLRF   x2D
07E74:  CLRF   x2E
07E76:  CLRF   x2F
07E78:  CLRF   x30
07E7A:  CLRF   x31
07E7C:  CLRF   x32
07E7E:  CLRF   x33
07E80:  CLRF   x34
07E82:  CLRF   x35
07E84:  CLRF   x36
07E86:  CLRF   x37
07E88:  CLRF   x38
07E8A:  CLRF   x39
07E8C:  CLRF   x3A
07E8E:  CLRF   x3B
07E90:  CLRF   x3C
07E92:  CLRF   x3D
07E94:  CLRF   x3E
07E96:  CLRF   x3F
07E98:  CLRF   x40
07E9A:  CLRF   x41
07E9C:  CLRF   x42
07E9E:  CLRF   x43
07EA0:  CLRF   x44
07EA2:  CLRF   x45
07EA4:  CLRF   x46
07EA6:  CLRF   x47
07EA8:  CLRF   x48
07EAA:  CLRF   x49
07EAC:  CLRF   x4A
07EAE:  CLRF   x4B
07EB0:  CLRF   x4C
07EB2:  CLRF   x4D
07EB4:  CLRF   x4E
07EB6:  CLRF   x4F
07EB8:  CLRF   x50
07EBA:  CLRF   x51
07EBC:  CLRF   x52
07EBE:  CLRF   x53
07EC0:  CLRF   x54
07EC2:  CLRF   x55
07EC4:  CLRF   x56
07EC6:  CLRF   x57
07EC8:  CLRF   x58
07ECA:  CLRF   x59
07ECC:  CLRF   x5A
07ECE:  CLRF   x5B
07ED0:  CLRF   x5C
07ED2:  CLRF   x5D
07ED4:  CLRF   x5E
07ED6:  CLRF   x5F
07ED8:  CLRF   x60
07EDA:  CLRF   x61
07EDC:  CLRF   x62
07EDE:  CLRF   x63
07EE0:  CLRF   x64
07EE2:  CLRF   x65
07EE4:  CLRF   x66
07EE6:  CLRF   x67
07EE8:  CLRF   x68
07EEA:  CLRF   x69
07EEC:  CLRF   x6A
07EEE:  CLRF   x6B
07EF0:  CLRF   x6C
07EF2:  CLRF   x6D
07EF4:  CLRF   x6E
07EF6:  CLRF   x6F
07EF8:  CLRF   x70
07EFA:  CLRF   x71
07EFC:  CLRF   x72
07EFE:  CLRF   x73
07F00:  CLRF   x74
07F02:  CLRF   x75
07F04:  CLRF   x76
07F06:  CLRF   x77
07F08:  CLRF   x78
07F0A:  CLRF   x79
07F0C:  CLRF   x7A
07F0E:  CLRF   x7B
07F10:  CLRF   x7C
07F12:  CLRF   x7D
07F14:  CLRF   x7E
07F16:  CLRF   x7F
07F18:  CLRF   x80
07F1A:  CLRF   x81
07F1C:  CLRF   x82
07F1E:  CLRF   x83
07F20:  CLRF   x84
07F22:  CLRF   x85
07F24:  CLRF   x86
07F26:  CLRF   x87
07F28:  CLRF   x88
07F2A:  CLRF   x89
07F2C:  CLRF   x8A
07F2E:  CLRF   x8B
07F30:  CLRF   x8C
07F32:  CLRF   x8D
07F34:  CLRF   x8E
07F36:  CLRF   x8F
07F38:  CLRF   x90
07F3A:  CLRF   x91
07F3C:  CLRF   x92
07F3E:  CLRF   x93
07F40:  CLRF   x94
07F42:  CLRF   x95
07F44:  CLRF   x96
07F46:  CLRF   x97
07F48:  CLRF   x98
07F4A:  CLRF   x99
07F4C:  CLRF   x9A
07F4E:  CLRF   x9B
07F50:  CLRF   x9C
07F52:  CLRF   x9D
07F54:  CLRF   x9E
07F56:  CLRF   x9F
07F58:  CLRF   xA0
07F5A:  CLRF   xA1
07F5C:  CLRF   xA2
07F5E:  CLRF   xA3
07F60:  CLRF   xA4
07F62:  CLRF   xA5
07F64:  CLRF   xA6
07F66:  CLRF   xA7
07F68:  CLRF   xA8
07F6A:  CLRF   xA9
07F6C:  CLRF   xAA
07F6E:  CLRF   xAB
07F70:  CLRF   xAC
07F72:  CLRF   xAD
07F74:  CLRF   xAE
07F76:  CLRF   xAF
07F78:  CLRF   xB0
07F7A:  CLRF   xB1
07F7C:  CLRF   xB2
07F7E:  CLRF   xB3
07F80:  CLRF   xB4
07F82:  CLRF   xB5
07F84:  CLRF   xB6
07F86:  CLRF   xB7
07F88:  CLRF   xB8
07F8A:  CLRF   xB9
07F8C:  CLRF   xBA
07F8E:  CLRF   xBB
07F90:  CLRF   xBC
07F92:  CLRF   xBD
07F94:  CLRF   xBE
07F96:  CLRF   xBF
07F98:  CLRF   xC0
07F9A:  CLRF   xC1
07F9C:  CLRF   xC2
07F9E:  CLRF   xC3
07FA0:  CLRF   xC4
07FA2:  CLRF   xC5
07FA4:  CLRF   xC6
07FA6:  CLRF   xC7
07FA8:  CLRF   xC8
07FAA:  CLRF   xC9
07FAC:  CLRF   xCA
07FAE:  CLRF   xCB
07FB0:  CLRF   xCC
07FB2:  CLRF   xCD
07FB4:  CLRF   xCE
07FB6:  CLRF   xCF
07FB8:  CLRF   xD0
07FBA:  CLRF   xD1
07FBC:  CLRF   xD2
07FBE:  CLRF   xD3
07FC0:  CLRF   xD4
07FC2:  CLRF   xD5
07FC4:  CLRF   xD6
07FC6:  CLRF   xD7
07FC8:  CLRF   xD8
07FCA:  CLRF   xD9
07FCC:  CLRF   xDA
07FCE:  CLRF   xDB
07FD0:  CLRF   xDC
07FD2:  CLRF   xDD
07FD4:  CLRF   xDE
07FD6:  CLRF   xDF
07FD8:  CLRF   xE0
07FDA:  CLRF   xE1
07FDC:  CLRF   xE2
07FDE:  CLRF   xE3
07FE0:  CLRF   xE4
07FE2:  CLRF   xE5
07FE4:  CLRF   xE6
07FE6:  CLRF   xE7
07FE8:  CLRF   xE8
07FEA:  CLRF   xE9
07FEC:  CLRF   xEA
07FEE:  CLRF   xEB
07FF0:  CLRF   xEC
07FF2:  CLRF   xED
07FF4:  CLRF   xEE
07FF6:  CLRF   xEF
07FF8:  CLRF   xF0
07FFA:  CLRF   xF1
07FFC:  CLRF   xF2
07FFE:  CLRF   xF3
08000:  CLRF   xF4
08002:  CLRF   xF5
08004:  CLRF   xF6
08006:  CLRF   xF7
08008:  CLRF   xF8
0800A:  CLRF   xF9
0800C:  CLRF   xFA
0800E:  CLRF   xFB
08010:  CLRF   xFC
08012:  CLRF   xFD
08014:  CLRF   xFE
08016:  CLRF   xFF
08018:  MOVLB  9
0801A:  CLRF   x00
0801C:  CLRF   x01
0801E:  CLRF   x02
08020:  CLRF   x03
08022:  CLRF   x04
08024:  CLRF   x05
08026:  CLRF   x06
08028:  CLRF   x07
0802A:  CLRF   x08
0802C:  CLRF   x09
0802E:  CLRF   x0A
08030:  CLRF   x0B
08032:  CLRF   x0C
08034:  CLRF   x0D
08036:  CLRF   x0E
08038:  CLRF   x0F
0803A:  CLRF   x10
0803C:  CLRF   x11
0803E:  CLRF   x12
08040:  CLRF   x13
08042:  CLRF   x14
08044:  CLRF   x15
08046:  CLRF   x16
08048:  CLRF   x17
0804A:  CLRF   x18
0804C:  CLRF   x19
0804E:  CLRF   x1A
08050:  CLRF   x1B
08052:  CLRF   x1C
08054:  CLRF   x1D
08056:  CLRF   x1E
08058:  CLRF   x1F
0805A:  CLRF   x20
0805C:  CLRF   x21
0805E:  CLRF   x22
08060:  CLRF   x23
08062:  CLRF   x24
08064:  CLRF   x25
08066:  CLRF   x26
08068:  CLRF   x27
0806A:  CLRF   x28
0806C:  CLRF   x29
0806E:  CLRF   x2A
08070:  CLRF   x2B
08072:  CLRF   x2C
08074:  CLRF   x2D
08076:  CLRF   x2E
08078:  CLRF   x2F
0807A:  CLRF   x30
0807C:  CLRF   x31
0807E:  CLRF   x32
08080:  CLRF   x33
08082:  CLRF   x34
08084:  CLRF   x35
08086:  CLRF   x36
08088:  CLRF   x37
0808A:  CLRF   x38
0808C:  CLRF   x39
0808E:  CLRF   x3A
08090:  CLRF   x3B
08092:  CLRF   x3C
08094:  CLRF   x3D
08096:  CLRF   x3E
08098:  CLRF   x3F
0809A:  CLRF   x40
0809C:  CLRF   x41
0809E:  CLRF   x42
080A0:  CLRF   x43
080A2:  CLRF   x44
080A4:  CLRF   x45
080A6:  CLRF   x46
080A8:  CLRF   x47
080AA:  CLRF   x48
080AC:  CLRF   x49
080AE:  CLRF   x4A
080B0:  CLRF   x4B
080B2:  CLRF   x4C
080B4:  CLRF   x4D
080B6:  CLRF   x4E
080B8:  CLRF   x4F
080BA:  CLRF   x50
080BC:  CLRF   x51
080BE:  CLRF   x52
080C0:  CLRF   x53
080C2:  CLRF   x54
080C4:  CLRF   x55
080C6:  CLRF   x56
080C8:  CLRF   x57
080CA:  CLRF   x58
080CC:  CLRF   x59
080CE:  CLRF   x5A
080D0:  CLRF   x5B
080D2:  CLRF   x5C
080D4:  CLRF   x5D
080D6:  CLRF   x5E
080D8:  CLRF   x5F
080DA:  CLRF   x60
080DC:  CLRF   x61
080DE:  CLRF   x62
080E0:  CLRF   x63
080E2:  CLRF   x64
080E4:  CLRF   x65
080E6:  CLRF   x66
080E8:  CLRF   x67
080EA:  CLRF   x68
080EC:  CLRF   x69
080EE:  CLRF   x6A
080F0:  CLRF   x6B
080F2:  CLRF   x6C
080F4:  CLRF   x6D
080F6:  CLRF   x6E
080F8:  CLRF   x6F
080FA:  CLRF   x70
080FC:  CLRF   x71
080FE:  CLRF   x72
08100:  CLRF   x73
08102:  CLRF   x74
08104:  CLRF   x75
08106:  CLRF   x76
08108:  CLRF   x77
0810A:  CLRF   x78
0810C:  CLRF   x79
0810E:  CLRF   x7A
08110:  CLRF   x7B
08112:  CLRF   x7C
08114:  CLRF   x7D
08116:  CLRF   x7E
08118:  CLRF   x7F
0811A:  CLRF   x80
0811C:  CLRF   x81
0811E:  CLRF   x82
08120:  CLRF   x83
08122:  CLRF   x84
08124:  CLRF   x85
08126:  CLRF   x86
08128:  CLRF   x87
0812A:  CLRF   x88
0812C:  CLRF   x89
0812E:  CLRF   x8A
08130:  CLRF   x8B
08132:  CLRF   x8C
08134:  CLRF   x8D
08136:  CLRF   x8E
08138:  CLRF   x8F
0813A:  CLRF   x90
0813C:  CLRF   x91
0813E:  CLRF   x92
08140:  CLRF   x93
08142:  CLRF   x94
08144:  CLRF   x95
08146:  CLRF   x96
08148:  CLRF   x97
0814A:  CLRF   x98
0814C:  CLRF   x99
0814E:  CLRF   x9A
08150:  CLRF   x9B
08152:  CLRF   x9C
08154:  CLRF   x9D
08156:  CLRF   x9E
08158:  CLRF   x9F
0815A:  CLRF   xA0
0815C:  CLRF   xA1
0815E:  CLRF   xA2
08160:  CLRF   xA3
08162:  CLRF   xA4
08164:  CLRF   xA5
08166:  CLRF   xA6
08168:  CLRF   xA7
0816A:  CLRF   xA8
0816C:  CLRF   xA9
0816E:  CLRF   xAA
08170:  CLRF   xAB
08172:  CLRF   xAC
08174:  CLRF   xAD
08176:  CLRF   xAE
08178:  CLRF   xAF
0817A:  CLRF   xB0
....................     port2.port_num = 2;
0817C:  MOVLW  02
0817E:  MOVLB  5
08180:  MOVWF  xB1
....................     port2.sweep_step = 0;
08182:  CLRF   xB3
08184:  CLRF   xB2
....................     port2.active = 1;
08186:  MOVLB  9
08188:  BSF    xB0.0
.................... 
....................     int16 count = 1;
0818A:  CLRF   xB2
0818C:  MOVLW  01
0818E:  MOVWF  xB1
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
08190:  CLRF   xC3
08192:  MOVLW  01
08194:  MOVWF  xC2
08196:  MOVLB  0
08198:  CALL   210C
....................     mcp4901_2_write(1);
0819C:  MOVLB  9
0819E:  CLRF   xC3
081A0:  MOVLW  01
081A2:  MOVWF  xC2
081A4:  MOVLB  0
081A6:  CALL   214E
....................     ad7490_read(ADC_CIGS1_CURR);
081AA:  MOVLW  01
081AC:  MOVLB  9
081AE:  MOVWF  xD7
081B0:  MOVLB  0
081B2:  CALL   1DAE
....................     ad7490_read(ADC_CIGS1_CURR);
081B6:  MOVLW  01
081B8:  MOVLB  9
081BA:  MOVWF  xD7
081BC:  MOVLB  0
081BE:  CALL   1DAE
....................     ad7490_read(ADC_CIGS2_CURR);
081C2:  MOVLW  05
081C4:  MOVLB  9
081C6:  MOVWF  xD7
081C8:  MOVLB  0
081CA:  CALL   1DAE
....................     ad7490_read(ADC_CIGS2_CURR);
081CE:  MOVLW  05
081D0:  MOVLB  9
081D2:  MOVWF  xD7
081D4:  MOVLB  0
081D6:  CALL   1DAE
....................     delay_ms(200);
081DA:  MOVLW  C8
081DC:  MOVLB  A
081DE:  MOVWF  x6E
081E0:  MOVLB  0
081E2:  CALL   1B3E
.................... 
....................     // Read initial PD value
....................     MEASUREMENT_DATA measured_data = create_meas_data();
081E6:  GOTO   6906
081EA:  MOVFF  02,03
081EE:  MOVF   01,W
081F0:  MOVWF  FE1
081F2:  MOVFF  03,FE2
081F6:  MOVLW  09
081F8:  MOVWF  FEA
081FA:  MOVLW  B3
081FC:  MOVWF  FE9
081FE:  MOVLW  0F
08200:  MOVWF  01
08202:  MOVFF  FE6,FEE
08206:  DECFSZ 01,F
08208:  GOTO   8202
....................     // Continue measurement while at least one port is active
....................     while (port1.active || port2.active)
0820C:  MOVLB  5
0820E:  BTFSS  xB0.0
08210:  BRA    8218
08212:  MOVLB  0
08214:  GOTO   8228
08218:  MOVLB  0
0821A:  MOVLB  9
0821C:  BTFSC  xB0.0
0821E:  BRA    8226
08220:  MOVLB  0
08222:  GOTO   85E8
08226:  MOVLB  0
....................     {
....................         // Set DAC values for both ports (synchronized timing)
....................         mcp4901_1_write(count);
08228:  MOVFF  9B2,9C3
0822C:  MOVFF  9B1,9C2
08230:  CALL   210C
....................         mcp4901_2_write(count);
08234:  MOVFF  9B2,9C3
08238:  MOVFF  9B1,9C2
0823C:  CALL   214E
....................         delay_ms(10); // wait for DAC to stabilize
08240:  MOVLW  0A
08242:  MOVLB  A
08244:  MOVWF  x6E
08246:  MOVLB  0
08248:  CALL   1B3E
.................... 
....................         // Read CIGS1 data (port1) only if still active
....................         if (port1.active) {
0824C:  MOVLB  5
0824E:  BTFSC  xB0.0
08250:  BRA    8258
08252:  MOVLB  0
08254:  GOTO   82E4
08258:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
0825A:  BCF    FD8.0
0825C:  MOVLB  9
0825E:  RLCF   xB1,W
08260:  MOVWF  02
08262:  RLCF   xB2,W
08264:  MOVWF  03
08266:  MOVF   02,W
08268:  ADDLW  B4
0826A:  MOVWF  01
0826C:  MOVLW  01
0826E:  ADDWFC 03,F
08270:  MOVF   01,W
08272:  MOVWF  xC2
08274:  MOVFF  03,9C3
08278:  MOVLW  02
0827A:  MOVWF  xD7
0827C:  MOVLB  0
0827E:  CALL   1DAE
08282:  MOVFF  9C3,FEA
08286:  MOVFF  9C2,FE9
0828A:  MOVFF  02,FEC
0828E:  MOVF   FED,F
08290:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
08294:  BCF    FD8.0
08296:  MOVLB  9
08298:  RLCF   xB1,W
0829A:  MOVWF  02
0829C:  RLCF   xB2,W
0829E:  MOVWF  03
082A0:  MOVF   02,W
082A2:  ADDLW  B2
082A4:  MOVWF  01
082A6:  MOVLW  03
082A8:  ADDWFC 03,F
082AA:  MOVF   01,W
082AC:  MOVWF  xC2
082AE:  MOVFF  03,9C3
082B2:  MOVLW  01
082B4:  MOVWF  xD7
082B6:  MOVLB  0
082B8:  CALL   1DAE
082BC:  MOVFF  9C3,FEA
082C0:  MOVFF  9C2,FE9
082C4:  MOVFF  02,FEC
082C8:  MOVF   FED,F
082CA:  MOVFF  01,FEF
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
082CE:  MOVLW  01
082D0:  MOVLB  9
082D2:  ADDWF  xB1,W
082D4:  MOVLB  1
082D6:  MOVWF  xB2
082D8:  MOVLW  00
082DA:  MOVLB  9
082DC:  ADDWFC xB2,W
082DE:  MOVLB  1
082E0:  MOVWF  xB3
082E2:  MOVLB  0
....................         }
....................         
....................         // Read CIGS2 data (port2) only if still active
....................         if (port2.active) {
082E4:  MOVLB  9
082E6:  BTFSC  xB0.0
082E8:  BRA    82F0
082EA:  MOVLB  0
082EC:  GOTO   837C
082F0:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
082F2:  BCF    FD8.0
082F4:  MOVLB  9
082F6:  RLCF   xB1,W
082F8:  MOVWF  02
082FA:  RLCF   xB2,W
082FC:  MOVWF  03
082FE:  MOVF   02,W
08300:  ADDLW  B4
08302:  MOVWF  01
08304:  MOVLW  05
08306:  ADDWFC 03,F
08308:  MOVF   01,W
0830A:  MOVWF  xC2
0830C:  MOVFF  03,9C3
08310:  MOVLW  06
08312:  MOVWF  xD7
08314:  MOVLB  0
08316:  CALL   1DAE
0831A:  MOVFF  9C3,FEA
0831E:  MOVFF  9C2,FE9
08322:  MOVFF  02,FEC
08326:  MOVF   FED,F
08328:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
0832C:  BCF    FD8.0
0832E:  MOVLB  9
08330:  RLCF   xB1,W
08332:  MOVWF  02
08334:  RLCF   xB2,W
08336:  MOVWF  03
08338:  MOVF   02,W
0833A:  ADDLW  B2
0833C:  MOVWF  01
0833E:  MOVLW  07
08340:  ADDWFC 03,F
08342:  MOVF   01,W
08344:  MOVWF  xC2
08346:  MOVFF  03,9C3
0834A:  MOVLW  05
0834C:  MOVWF  xD7
0834E:  MOVLB  0
08350:  CALL   1DAE
08354:  MOVFF  9C3,FEA
08358:  MOVFF  9C2,FE9
0835C:  MOVFF  02,FEC
08360:  MOVF   FED,F
08362:  MOVFF  01,FEF
....................             // fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
08366:  MOVLW  01
08368:  MOVLB  9
0836A:  ADDWF  xB1,W
0836C:  MOVLB  5
0836E:  MOVWF  xB2
08370:  MOVLW  00
08372:  MOVLB  9
08374:  ADDWFC xB2,W
08376:  MOVLB  5
08378:  MOVWF  xB3
0837A:  MOVLB  0
....................         }
.................... 
....................         count++;
0837C:  MOVLB  9
0837E:  INCF   xB1,F
08380:  BTFSC  FD8.2
08382:  INCF   xB2,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
08384:  MOVF   xB2,F
08386:  BTFSC  FD8.2
08388:  BRA    8390
0838A:  MOVLB  0
0838C:  GOTO   83A4
08390:  MOVLB  0
08392:  MOVLB  9
08394:  MOVF   xB1,W
08396:  SUBLW  FE
08398:  BTFSS  FD8.0
0839A:  BRA    83A2
0839C:  MOVLB  0
0839E:  GOTO   83E8
083A2:  MOVLB  0
....................             fprintf(PC, "Maximum step count reached: %ld\r\n", count);
083A4:  MOVLW  44
083A6:  MOVWF  FF6
083A8:  MOVLW  06
083AA:  MOVWF  FF7
083AC:  MOVLW  00
083AE:  MOVWF  FF8
083B0:  MOVLW  1C
083B2:  MOVLB  9
083B4:  MOVWF  xC2
083B6:  MOVLB  0
083B8:  CALL   1BEE
083BC:  MOVLW  10
083BE:  MOVWF  FE9
083C0:  MOVFF  9B2,9C3
083C4:  MOVFF  9B1,9C2
083C8:  GOTO   6990
083CC:  MOVLW  0D
083CE:  MOVLB  A
083D0:  MOVWF  xAD
083D2:  MOVLB  0
083D4:  CALL   1B6C
083D8:  MOVLW  0A
083DA:  MOVLB  A
083DC:  MOVWF  xAD
083DE:  MOVLB  0
083E0:  CALL   1B6C
....................             break;
083E4:  GOTO   85E8
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
083E8:  MOVLB  5
083EA:  BTFSC  xB0.0
083EC:  BRA    83F4
083EE:  MOVLB  0
083F0:  GOTO   84E6
083F4:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
083F6:  MOVLW  01
083F8:  MOVLB  9
083FA:  SUBWF  xB1,W
083FC:  MOVWF  xC2
083FE:  MOVLW  00
08400:  SUBWFB xB2,W
08402:  MOVWF  xC3
08404:  BCF    FD8.0
08406:  RLCF   xC2,W
08408:  MOVWF  02
0840A:  RLCF   xC3,W
0840C:  MOVWF  03
0840E:  MOVF   02,W
08410:  ADDLW  B2
08412:  MOVWF  FE9
08414:  MOVLW  03
08416:  ADDWFC 03,W
08418:  MOVWF  FEA
0841A:  MOVFF  FEC,9C3
0841E:  MOVF   FED,F
08420:  MOVFF  FEF,9C2
08424:  MOVF   xC3,W
08426:  MOVLB  1
08428:  SUBWF  xB0,W
0842A:  BTFSC  FD8.0
0842C:  BRA    8434
0842E:  MOVLB  0
08430:  GOTO   8470
08434:  MOVLB  0
08436:  BTFSS  FD8.2
08438:  GOTO   8450
0843C:  MOVLB  1
0843E:  MOVF   xAF,W
08440:  MOVLB  9
08442:  SUBWF  xC2,W
08444:  BTFSS  FD8.0
08446:  BRA    844E
08448:  MOVLB  0
0844A:  GOTO   8470
0844E:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current limit reached:");
08450:  MOVLW  66
08452:  MOVWF  FF6
08454:  MOVLW  06
08456:  MOVWF  FF7
08458:  MOVLW  00
0845A:  MOVWF  FF8
0845C:  CALL   1BBE
....................                 port1.active = 0;
08460:  MOVLB  5
08462:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
08464:  MOVLW  5E
08466:  MOVWF  F94
08468:  BCF    F8B.0
0846A:  MOVLB  0
....................             }
0846C:  GOTO   84E6
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
08470:  MOVLW  01
08472:  MOVLB  9
08474:  SUBWF  xB1,W
08476:  MOVWF  xC2
08478:  MOVLW  00
0847A:  SUBWFB xB2,W
0847C:  MOVWF  xC3
0847E:  BCF    FD8.0
08480:  RLCF   xC2,W
08482:  MOVWF  02
08484:  RLCF   xC3,W
08486:  MOVWF  03
08488:  MOVF   02,W
0848A:  ADDLW  B2
0848C:  MOVWF  FE9
0848E:  MOVLW  03
08490:  ADDWFC 03,W
08492:  MOVWF  FEA
08494:  MOVFF  FEC,9C3
08498:  MOVF   FED,F
0849A:  MOVFF  FEF,9C2
0849E:  MOVF   xC3,W
084A0:  MOVLB  1
084A2:  SUBWF  xAC,W
084A4:  BTFSC  FD8.0
084A6:  BRA    84AE
084A8:  MOVLB  0
084AA:  GOTO   84E6
084AE:  MOVLB  0
084B0:  BTFSS  FD8.2
084B2:  GOTO   84CA
084B6:  MOVLB  1
084B8:  MOVF   xAB,W
084BA:  MOVLB  9
084BC:  SUBWF  xC2,W
084BE:  BTFSS  FD8.0
084C0:  BRA    84C8
084C2:  MOVLB  0
084C4:  GOTO   84E6
084C8:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current below threshold");
084CA:  MOVLW  84
084CC:  MOVWF  FF6
084CE:  MOVLW  06
084D0:  MOVWF  FF7
084D2:  MOVLW  00
084D4:  MOVWF  FF8
084D6:  CALL   1BBE
....................                 port1.active = 0;
084DA:  MOVLB  5
084DC:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
084DE:  MOVLW  5E
084E0:  MOVWF  F94
084E2:  BCF    F8B.0
084E4:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
084E6:  MOVLB  9
084E8:  BTFSC  xB0.0
084EA:  BRA    84F2
084EC:  MOVLB  0
084EE:  GOTO   85E4
084F2:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
084F4:  MOVLW  01
084F6:  MOVLB  9
084F8:  SUBWF  xB1,W
084FA:  MOVWF  xC2
084FC:  MOVLW  00
084FE:  SUBWFB xB2,W
08500:  MOVWF  xC3
08502:  BCF    FD8.0
08504:  RLCF   xC2,W
08506:  MOVWF  02
08508:  RLCF   xC3,W
0850A:  MOVWF  03
0850C:  MOVF   02,W
0850E:  ADDLW  B2
08510:  MOVWF  FE9
08512:  MOVLW  07
08514:  ADDWFC 03,W
08516:  MOVWF  FEA
08518:  MOVFF  FEC,9C3
0851C:  MOVF   FED,F
0851E:  MOVFF  FEF,9C2
08522:  MOVF   xC3,W
08524:  MOVLB  1
08526:  SUBWF  xB0,W
08528:  BTFSC  FD8.0
0852A:  BRA    8532
0852C:  MOVLB  0
0852E:  GOTO   856E
08532:  MOVLB  0
08534:  BTFSS  FD8.2
08536:  GOTO   854E
0853A:  MOVLB  1
0853C:  MOVF   xAF,W
0853E:  MOVLB  9
08540:  SUBWF  xC2,W
08542:  BTFSS  FD8.0
08544:  BRA    854C
08546:  MOVLB  0
08548:  GOTO   856E
0854C:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current limit reached: ");
0854E:  MOVLW  A2
08550:  MOVWF  FF6
08552:  MOVLW  06
08554:  MOVWF  FF7
08556:  MOVLW  00
08558:  MOVWF  FF8
0855A:  CALL   1BBE
....................                 port2.active = 0;
0855E:  MOVLB  9
08560:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08562:  MOVLW  5E
08564:  MOVWF  F94
08566:  BCF    F8B.5
08568:  MOVLB  0
....................             }
0856A:  GOTO   85E4
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
0856E:  MOVLW  01
08570:  MOVLB  9
08572:  SUBWF  xB1,W
08574:  MOVWF  xC2
08576:  MOVLW  00
08578:  SUBWFB xB2,W
0857A:  MOVWF  xC3
0857C:  BCF    FD8.0
0857E:  RLCF   xC2,W
08580:  MOVWF  02
08582:  RLCF   xC3,W
08584:  MOVWF  03
08586:  MOVF   02,W
08588:  ADDLW  B2
0858A:  MOVWF  FE9
0858C:  MOVLW  07
0858E:  ADDWFC 03,W
08590:  MOVWF  FEA
08592:  MOVFF  FEC,9C3
08596:  MOVF   FED,F
08598:  MOVFF  FEF,9C2
0859C:  MOVF   xC3,W
0859E:  MOVLB  1
085A0:  SUBWF  xAC,W
085A2:  BTFSC  FD8.0
085A4:  BRA    85AC
085A6:  MOVLB  0
085A8:  GOTO   85E4
085AC:  MOVLB  0
085AE:  BTFSS  FD8.2
085B0:  GOTO   85C8
085B4:  MOVLB  1
085B6:  MOVF   xAB,W
085B8:  MOVLB  9
085BA:  SUBWF  xC2,W
085BC:  BTFSS  FD8.0
085BE:  BRA    85C6
085C0:  MOVLB  0
085C2:  GOTO   85E4
085C6:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current below threshold:");
085C8:  MOVLW  C0
085CA:  MOVWF  FF6
085CC:  MOVLW  06
085CE:  MOVWF  FF7
085D0:  MOVLW  00
085D2:  MOVWF  FF8
085D4:  CALL   1BBE
....................                 port2.active = 0;
085D8:  MOVLB  9
085DA:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
085DC:  MOVLW  5E
085DE:  MOVWF  F94
085E0:  BCF    F8B.5
085E2:  MOVLB  0
....................             }
....................         }
085E4:  GOTO   820C
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
085E8:  MOVLW  5E
085EA:  MOVWF  F94
085EC:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
085EE:  MOVLW  5E
085F0:  MOVWF  F94
085F2:  BCF    F8B.5
....................     // output_high(EN_NPWR);
.................... 
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
085F4:  MOVLW  09
085F6:  MOVLB  9
085F8:  MOVWF  xC3
085FA:  MOVLW  B3
085FC:  MOVWF  xC2
085FE:  MOVLW  01
08600:  MOVWF  xC5
08602:  MOVLW  B1
08604:  MOVWF  xC4
08606:  MOVLB  0
08608:  CALL   6B1A
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
0860C:  MOVLW  09
0860E:  MOVLB  9
08610:  MOVWF  xC3
08612:  MOVLW  B3
08614:  MOVWF  xC2
08616:  MOVLW  05
08618:  MOVWF  xC5
0861A:  MOVLW  B1
0861C:  MOVWF  xC4
0861E:  MOVLB  0
08620:  CALL   6B1A
.................... 
....................     fprintf(PC, "End SWEEP with threshold\r\n");
08624:  MOVLW  E0
08626:  MOVWF  FF6
08628:  MOVLW  06
0862A:  MOVWF  FF7
0862C:  MOVLW  00
0862E:  MOVWF  FF8
08630:  CALL   1BBE
08634:  GOTO   8BDA (RETURN)
.................... }
.................... 
.................... 
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data)
*
06B9E:  CLRF   x06
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
*
06B1A:  MOVLB  9
06B1C:  CLRF   xC6
06B1E:  CLRF   xC7
06B20:  CLRF   xC8
06B22:  CLRF   xC9
06B24:  CLRF   xCA
06B26:  CLRF   xCB
06B28:  CLRF   xCC
06B2A:  CLRF   xCD
06B2C:  CLRF   xCE
06B2E:  CLRF   xCF
06B30:  CLRF   xD0
06B32:  CLRF   xD1
06B34:  CLRF   xD2
06B36:  CLRF   xD3
06B38:  CLRF   xD4
06B3A:  CLRF   xD5
06B3C:  CLRF   xD6
06B3E:  CLRF   xD7
06B40:  CLRF   xD8
06B42:  CLRF   xD9
06B44:  CLRF   xDA
06B46:  CLRF   xDB
06B48:  CLRF   xDC
06B4A:  CLRF   xDD
06B4C:  CLRF   xDE
06B4E:  CLRF   xDF
06B50:  CLRF   xE0
06B52:  CLRF   xE1
06B54:  CLRF   xE2
06B56:  CLRF   xE3
06B58:  CLRF   xE4
06B5A:  CLRF   xE5
06B5C:  CLRF   xE6
06B5E:  CLRF   xE7
06B60:  CLRF   xE8
06B62:  CLRF   xE9
06B64:  CLRF   xEA
06B66:  CLRF   xEB
06B68:  CLRF   xEC
06B6A:  CLRF   xED
06B6C:  CLRF   xEE
06B6E:  CLRF   xEF
06B70:  CLRF   xF0
06B72:  CLRF   xF1
06B74:  CLRF   xF2
06B76:  CLRF   xF3
06B78:  CLRF   xF4
06B7A:  CLRF   xF5
06B7C:  CLRF   xF6
06B7E:  CLRF   xF7
06B80:  CLRF   xF8
06B82:  CLRF   xF9
06B84:  CLRF   xFA
06B86:  CLRF   xFB
06B88:  CLRF   xFC
06B8A:  CLRF   xFD
06B8C:  CLRF   xFE
06B8E:  CLRF   xFF
06B90:  MOVLB  A
06B92:  CLRF   x00
06B94:  CLRF   x01
06B96:  CLRF   x02
06B98:  CLRF   x03
06B9A:  CLRF   x04
06B9C:  CLRF   x05
....................     unsigned int8 packetdata_index = 0; // Index for packet data
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
06BA0:  MOVLB  9
06BA2:  SETF   xC6
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data->port_num & 0x0F);
06BA4:  MOVF   xC4,W
06BA6:  MOVWF  FE9
06BA8:  MOVF   xC5,W
06BAA:  MOVWF  FEA
06BAC:  MOVF   FEF,W
06BAE:  ANDLW  0F
06BB0:  IORLW  F0
06BB2:  MOVWF  xC7
....................     packetdata[2] = measured_data->time_sec >> 24 & 0xFF;
06BB4:  MOVF   xC2,W
06BB6:  MOVWF  FE9
06BB8:  MOVF   xC3,W
06BBA:  MOVWF  FEA
06BBC:  MOVFF  FEF,A16
06BC0:  MOVFF  FEC,A17
06BC4:  MOVFF  FEC,A18
06BC8:  MOVFF  FEC,A19
06BCC:  MOVF   FED,F
06BCE:  MOVF   FED,F
06BD0:  MOVF   FED,F
06BD2:  MOVFF  A19,A16
06BD6:  MOVLB  A
06BD8:  CLRF   x17
06BDA:  CLRF   x18
06BDC:  CLRF   x19
06BDE:  MOVF   x16,W
06BE0:  MOVLB  9
06BE2:  MOVWF  xC8
....................     packetdata[3] = measured_data->time_sec >> 16 & 0xFF;
06BE4:  MOVF   xC2,W
06BE6:  MOVWF  FE9
06BE8:  MOVF   xC3,W
06BEA:  MOVWF  FEA
06BEC:  MOVFF  FEF,A16
06BF0:  MOVFF  FEC,A17
06BF4:  MOVFF  FEC,A18
06BF8:  MOVFF  FEC,A19
06BFC:  MOVF   FED,F
06BFE:  MOVF   FED,F
06C00:  MOVF   FED,F
06C02:  MOVFF  A18,A16
06C06:  MOVFF  A19,A17
06C0A:  MOVLB  A
06C0C:  CLRF   x18
06C0E:  CLRF   x19
06C10:  MOVF   x16,W
06C12:  MOVLB  9
06C14:  MOVWF  xC9
....................     packetdata[4] = measured_data->time_sec >> 8 & 0xFF;
06C16:  MOVF   xC2,W
06C18:  MOVWF  FE9
06C1A:  MOVF   xC3,W
06C1C:  MOVWF  FEA
06C1E:  MOVFF  FEF,A16
06C22:  MOVFF  FEC,A17
06C26:  MOVFF  FEC,A18
06C2A:  MOVFF  FEC,A19
06C2E:  MOVF   FED,F
06C30:  MOVF   FED,F
06C32:  MOVF   FED,F
06C34:  MOVFF  A17,A16
06C38:  MOVFF  A18,A17
06C3C:  MOVFF  A19,A18
06C40:  MOVLB  A
06C42:  CLRF   x19
06C44:  MOVF   x16,W
06C46:  MOVLB  9
06C48:  MOVWF  xCA
....................     packetdata[5] = measured_data->time_sec & 0xFF;
06C4A:  MOVF   xC2,W
06C4C:  MOVWF  FE9
06C4E:  MOVF   xC3,W
06C50:  MOVWF  FEA
06C52:  MOVFF  FEF,A16
06C56:  MOVFF  FEC,A17
06C5A:  MOVFF  FEC,A18
06C5E:  MOVFF  FEC,A19
06C62:  MOVF   FED,F
06C64:  MOVF   FED,F
06C66:  MOVF   FED,F
06C68:  MOVLB  A
06C6A:  MOVF   x16,W
06C6C:  MOVLB  9
06C6E:  MOVWF  xCB
....................     packetdata[6] = (measured_data->time_msec & 0x0F) >>4 | measured_data->pd >> 8 & 0x0F;
06C70:  MOVLW  04
06C72:  ADDWF  xC2,W
06C74:  MOVWF  FE9
06C76:  MOVLW  00
06C78:  ADDWFC xC3,W
06C7A:  MOVWF  FEA
06C7C:  MOVF   FEF,W
06C7E:  ANDLW  0F
06C80:  MOVWF  00
06C82:  SWAPF  00,W
06C84:  MOVLB  A
06C86:  MOVWF  x16
06C88:  MOVLW  0F
06C8A:  ANDWF  x16,F
06C8C:  MOVLW  0D
06C8E:  MOVLB  9
06C90:  ADDWF  xC2,W
06C92:  MOVWF  FE9
06C94:  MOVLW  00
06C96:  ADDWFC xC3,W
06C98:  MOVWF  FEA
06C9A:  MOVFF  FEC,A18
06C9E:  MOVF   FED,F
06CA0:  MOVFF  FEF,A17
06CA4:  MOVFF  A18,A17
06CA8:  MOVLB  A
06CAA:  CLRF   x18
06CAC:  MOVF   x17,W
06CAE:  ANDLW  0F
06CB0:  MOVWF  00
06CB2:  CLRF   03
06CB4:  MOVF   00,W
06CB6:  IORWF  x16,W
06CB8:  MOVLB  9
06CBA:  MOVWF  xCC
....................     packetdata[7] = measured_data->pd & 0xFF;
06CBC:  MOVLW  0D
06CBE:  ADDWF  xC2,W
06CC0:  MOVWF  FE9
06CC2:  MOVLW  00
06CC4:  ADDWFC xC3,W
06CC6:  MOVWF  FEA
06CC8:  MOVFF  FEC,A17
06CCC:  MOVF   FED,F
06CCE:  MOVFF  FEF,A16
06CD2:  MOVLB  A
06CD4:  MOVF   x16,W
06CD6:  MOVLB  9
06CD8:  MOVWF  xCD
....................     packetdata[8] = (measured_data->open_voltage >> 4) & 0xFF; // PD start low byte
06CDA:  MOVLW  05
06CDC:  ADDWF  xC2,W
06CDE:  MOVWF  FE9
06CE0:  MOVLW  00
06CE2:  ADDWFC xC3,W
06CE4:  MOVWF  FEA
06CE6:  MOVFF  FEC,A17
06CEA:  MOVF   FED,F
06CEC:  MOVFF  FEF,A16
06CF0:  MOVLB  A
06CF2:  RRCF   x17,F
06CF4:  RRCF   x16,F
06CF6:  RRCF   x17,F
06CF8:  RRCF   x16,F
06CFA:  RRCF   x17,F
06CFC:  RRCF   x16,F
06CFE:  RRCF   x17,F
06D00:  RRCF   x16,F
06D02:  MOVLW  0F
06D04:  ANDWF  x17,F
06D06:  MOVF   x16,W
06D08:  MOVLB  9
06D0A:  MOVWF  xCE
....................     packetdata[9] = (measured_data->open_voltage & 0x0F) << 4 | (measured_data->temp_py_top >> 8) & 0x0F;
06D0C:  MOVLW  05
06D0E:  ADDWF  xC2,W
06D10:  MOVWF  FE9
06D12:  MOVLW  00
06D14:  ADDWFC xC3,W
06D16:  MOVWF  FEA
06D18:  MOVFF  FEC,A17
06D1C:  MOVF   FED,F
06D1E:  MOVFF  FEF,A16
06D22:  MOVLW  0F
06D24:  MOVLB  A
06D26:  ANDWF  x16,F
06D28:  CLRF   x17
06D2A:  RLCF   x16,F
06D2C:  RLCF   x17,F
06D2E:  RLCF   x16,F
06D30:  RLCF   x17,F
06D32:  RLCF   x16,F
06D34:  RLCF   x17,F
06D36:  RLCF   x16,F
06D38:  RLCF   x17,F
06D3A:  MOVLW  F0
06D3C:  ANDWF  x16,F
06D3E:  MOVLW  07
06D40:  MOVLB  9
06D42:  ADDWF  xC2,W
06D44:  MOVWF  FE9
06D46:  MOVLW  00
06D48:  ADDWFC xC3,W
06D4A:  MOVWF  FEA
06D4C:  MOVFF  FEC,A19
06D50:  MOVF   FED,F
06D52:  MOVFF  FEF,A18
06D56:  MOVFF  A19,A18
06D5A:  MOVLB  A
06D5C:  CLRF   x19
06D5E:  MOVF   x18,W
06D60:  ANDLW  0F
06D62:  MOVWF  00
06D64:  CLRF   03
06D66:  MOVF   00,W
06D68:  IORWF  x16,W
06D6A:  MOVLB  9
06D6C:  MOVWF  xCF
....................     packetdata[10] = measured_data->temp_py_top & 0xFF;
06D6E:  MOVLW  07
06D70:  ADDWF  xC2,W
06D72:  MOVWF  FE9
06D74:  MOVLW  00
06D76:  ADDWFC xC3,W
06D78:  MOVWF  FEA
06D7A:  MOVFF  FEC,A17
06D7E:  MOVF   FED,F
06D80:  MOVFF  FEF,A16
06D84:  MOVLB  A
06D86:  MOVF   x16,W
06D88:  MOVLB  9
06D8A:  MOVWF  xD0
....................     packetdata[11] = (measured_data->temp_py_bot >> 4) & 0xFF; // PD start low byte
06D8C:  MOVLW  09
06D8E:  ADDWF  xC2,W
06D90:  MOVWF  FE9
06D92:  MOVLW  00
06D94:  ADDWFC xC3,W
06D96:  MOVWF  FEA
06D98:  MOVFF  FEC,A17
06D9C:  MOVF   FED,F
06D9E:  MOVFF  FEF,A16
06DA2:  MOVLB  A
06DA4:  RRCF   x17,F
06DA6:  RRCF   x16,F
06DA8:  RRCF   x17,F
06DAA:  RRCF   x16,F
06DAC:  RRCF   x17,F
06DAE:  RRCF   x16,F
06DB0:  RRCF   x17,F
06DB2:  RRCF   x16,F
06DB4:  MOVLW  0F
06DB6:  ANDWF  x17,F
06DB8:  MOVF   x16,W
06DBA:  MOVLB  9
06DBC:  MOVWF  xD1
....................     packetdata[12] = (measured_data->temp_py_bot & 0x0F) << 4 | (measured_data->temp_mis7 >> 8) & 0x0F;
06DBE:  MOVLW  09
06DC0:  ADDWF  xC2,W
06DC2:  MOVWF  FE9
06DC4:  MOVLW  00
06DC6:  ADDWFC xC3,W
06DC8:  MOVWF  FEA
06DCA:  MOVFF  FEC,A17
06DCE:  MOVF   FED,F
06DD0:  MOVFF  FEF,A16
06DD4:  MOVLW  0F
06DD6:  MOVLB  A
06DD8:  ANDWF  x16,F
06DDA:  CLRF   x17
06DDC:  RLCF   x16,F
06DDE:  RLCF   x17,F
06DE0:  RLCF   x16,F
06DE2:  RLCF   x17,F
06DE4:  RLCF   x16,F
06DE6:  RLCF   x17,F
06DE8:  RLCF   x16,F
06DEA:  RLCF   x17,F
06DEC:  MOVLW  F0
06DEE:  ANDWF  x16,F
06DF0:  MOVLW  0B
06DF2:  MOVLB  9
06DF4:  ADDWF  xC2,W
06DF6:  MOVWF  FE9
06DF8:  MOVLW  00
06DFA:  ADDWFC xC3,W
06DFC:  MOVWF  FEA
06DFE:  MOVFF  FEC,A19
06E02:  MOVF   FED,F
06E04:  MOVFF  FEF,A18
06E08:  MOVFF  A19,A18
06E0C:  MOVLB  A
06E0E:  CLRF   x19
06E10:  MOVF   x18,W
06E12:  ANDLW  0F
06E14:  MOVWF  00
06E16:  CLRF   03
06E18:  MOVF   00,W
06E1A:  IORWF  x16,W
06E1C:  MOVLB  9
06E1E:  MOVWF  xD2
....................     packetdata[13] = measured_data->temp_mis7 & 0xFF;
06E20:  MOVLW  0B
06E22:  ADDWF  xC2,W
06E24:  MOVWF  FE9
06E26:  MOVLW  00
06E28:  ADDWFC xC3,W
06E2A:  MOVWF  FEA
06E2C:  MOVFF  FEC,A17
06E30:  MOVF   FED,F
06E32:  MOVFF  FEF,A16
06E36:  MOVLB  A
06E38:  MOVF   x16,W
06E3A:  MOVLB  9
06E3C:  MOVWF  xD3
.................... 
....................     packetdata_index = 14; // Start index for data
06E3E:  MOVLW  0E
06E40:  MOVLB  A
06E42:  MOVWF  x06
.................... 
....................     for (unsigned int16 i = 0; i < port_data->sweep_step ; i++) {
06E44:  CLRF   x08
06E46:  CLRF   x07
06E48:  MOVLB  0
06E4A:  MOVLW  01
06E4C:  MOVLB  9
06E4E:  ADDWF  xC4,W
06E50:  MOVWF  FE9
06E52:  MOVLW  00
06E54:  ADDWFC xC5,W
06E56:  MOVWF  FEA
06E58:  MOVFF  FEC,03
06E5C:  MOVF   FED,F
06E5E:  MOVF   FEF,W
06E60:  MOVWF  01
06E62:  MOVLB  A
06E64:  MOVF   x08,W
06E66:  SUBWF  03,W
06E68:  BTFSC  FD8.0
06E6A:  BRA    6E72
06E6C:  MOVLB  0
06E6E:  GOTO   7050
06E72:  MOVLB  0
06E74:  BTFSS  FD8.2
06E76:  GOTO   6E8C
06E7A:  MOVF   01,W
06E7C:  MOVLB  A
06E7E:  SUBWF  x07,W
06E80:  BTFSS  FD8.0
06E82:  BRA    6E8A
06E84:  MOVLB  0
06E86:  GOTO   7050
06E8A:  MOVLB  0
....................         unsigned int16 data0 = port_data->data_buffer[0][i];
....................         unsigned int16 data1 = port_data->data_buffer[1][i];
06E8C:  BCF    FD8.0
06E8E:  MOVLB  A
06E90:  RLCF   x07,W
06E92:  MOVWF  02
06E94:  RLCF   x08,W
06E96:  MOVWF  03
06E98:  MOVF   02,W
06E9A:  ADDLW  03
06E9C:  MOVWF  01
06E9E:  MOVLW  00
06EA0:  ADDWFC 03,F
06EA2:  MOVF   01,W
06EA4:  MOVLB  9
06EA6:  ADDWF  xC4,W
06EA8:  MOVWF  FE9
06EAA:  MOVF   xC5,W
06EAC:  ADDWFC 03,W
06EAE:  MOVWF  FEA
06EB0:  MOVFF  FEC,A0A
06EB4:  MOVF   FED,F
06EB6:  MOVFF  FEF,A09
06EBA:  BCF    FD8.0
06EBC:  MOVLB  A
06EBE:  RLCF   x07,W
06EC0:  MOVWF  02
06EC2:  RLCF   x08,W
06EC4:  MOVWF  03
06EC6:  MOVF   02,W
06EC8:  ADDLW  01
06ECA:  MOVWF  01
06ECC:  MOVLW  02
06ECE:  ADDWFC 03,F
06ED0:  MOVF   01,W
06ED2:  MOVLB  9
06ED4:  ADDWF  xC4,W
06ED6:  MOVWF  FE9
06ED8:  MOVF   xC5,W
06EDA:  ADDWFC 03,W
06EDC:  MOVWF  FEA
06EDE:  MOVFF  FEC,A0C
06EE2:  MOVF   FED,F
06EE4:  MOVFF  FEF,A0B
06EE8:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
06EEA:  MOVLB  A
06EEC:  MOVF   x06,W
06EEE:  INCF   x06,F
06EF0:  CLRF   03
06EF2:  ADDLW  C6
06EF4:  MOVWF  FE9
06EF6:  MOVLW  09
06EF8:  ADDWFC 03,W
06EFA:  MOVWF  FEA
06EFC:  RRCF   x0A,W
06EFE:  MOVWF  x19
06F00:  RRCF   x09,W
06F02:  MOVWF  x18
06F04:  RRCF   x19,F
06F06:  RRCF   x18,F
06F08:  RRCF   x19,F
06F0A:  RRCF   x18,F
06F0C:  RRCF   x19,F
06F0E:  RRCF   x18,F
06F10:  MOVLW  0F
06F12:  ANDWF  x19,F
06F14:  MOVF   x18,W
06F16:  MOVWF  00
06F18:  CLRF   03
06F1A:  MOVF   00,W
06F1C:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
06F1E:  MOVF   x06,W
06F20:  INCF   x06,F
06F22:  CLRF   03
06F24:  ADDLW  C6
06F26:  MOVWF  FE9
06F28:  MOVLW  09
06F2A:  ADDWFC 03,W
06F2C:  MOVWF  FEA
06F2E:  MOVF   x09,W
06F30:  ANDLW  0F
06F32:  MOVWF  x18
06F34:  CLRF   x19
06F36:  RLCF   x18,F
06F38:  RLCF   x19,F
06F3A:  RLCF   x18,F
06F3C:  RLCF   x19,F
06F3E:  RLCF   x18,F
06F40:  RLCF   x19,F
06F42:  RLCF   x18,F
06F44:  RLCF   x19,F
06F46:  MOVLW  F0
06F48:  ANDWF  x18,F
06F4A:  MOVFF  A0C,A1A
06F4E:  CLRF   x1B
06F50:  MOVF   x1A,W
06F52:  ANDLW  0F
06F54:  MOVWF  00
06F56:  CLRF   03
06F58:  MOVF   00,W
06F5A:  IORWF  x18,W
06F5C:  MOVWF  00
06F5E:  MOVF   03,W
06F60:  IORWF  x19,W
06F62:  MOVWF  03
06F64:  MOVF   00,W
06F66:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
06F68:  MOVF   x06,W
06F6A:  INCF   x06,F
06F6C:  CLRF   03
06F6E:  ADDLW  C6
06F70:  MOVWF  FE9
06F72:  MOVLW  09
06F74:  ADDWFC 03,W
06F76:  MOVWF  FEA
06F78:  MOVF   x0B,W
06F7A:  MOVWF  00
06F7C:  CLRF   03
06F7E:  MOVF   00,W
06F80:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
06F82:  MOVLW  03
06F84:  ADDWF  x06,W
06F86:  SUBLW  3E
06F88:  BTFSS  FD8.0
06F8A:  BRA    6F92
06F8C:  MOVLB  0
06F8E:  GOTO   7042
06F92:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
06F94:  MOVLW  09
06F96:  MOVLB  A
06F98:  MOVWF  xAE
06F9A:  MOVLW  C6
06F9C:  MOVWF  xAD
06F9E:  MOVLW  3F
06FA0:  MOVWF  xAF
06FA2:  MOVLB  0
06FA4:  CALL   29DC
06FA8:  MOVFF  01,A05
....................             unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
06FAC:  MOVLB  1
06FAE:  MOVF   x40,W
06FB0:  MOVLB  A
06FB2:  MOVWF  x0D
06FB4:  MOVLW  10
06FB6:  MOVLB  1
06FB8:  ADDWF  x41,W
06FBA:  MOVLB  A
06FBC:  MOVWF  x0E
06FBE:  MOVLW  7C
06FC0:  MOVLB  1
06FC2:  ADDWFC x42,W
06FC4:  MOVLB  A
06FC6:  MOVWF  x0F
06FC8:  MOVLW  00
06FCA:  MOVLB  1
06FCC:  ADDWFC x43,W
06FCE:  MOVLB  A
06FD0:  MOVWF  x10
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
06FD2:  MOVFF  111,A59
06FD6:  MOVFF  110,A58
06FDA:  MOVFF  10F,A57
06FDE:  MOVFF  10E,A56
06FE2:  MOVFF  A10,A5D
06FE6:  MOVFF  A0F,A5C
06FEA:  MOVFF  A0E,A5B
06FEE:  MOVFF  A0D,A5A
06FF2:  MOVLW  09
06FF4:  MOVWF  x5F
06FF6:  MOVLW  C6
06FF8:  MOVWF  x5E
06FFA:  CLRF   x61
06FFC:  MOVLW  40
06FFE:  MOVWF  x60
07000:  MOVLB  0
07002:  CALL   34D6
....................             iv_data.used_counter += PACKET_SIZE;
07006:  MOVLW  40
07008:  MOVLB  1
0700A:  ADDWF  x40,F
0700C:  MOVLW  00
0700E:  ADDWFC x41,F
07010:  MOVLW  00
07012:  ADDWFC x42,F
07014:  MOVLW  00
07016:  ADDWFC x43,F
....................             iv_data.uncopied_counter += PACKET_SIZE;
07018:  MOVLW  40
0701A:  ADDWF  x44,F
0701C:  MOVLW  00
0701E:  ADDWFC x45,F
07020:  MOVLW  00
07022:  ADDWFC x46,F
07024:  MOVLW  00
07026:  ADDWFC x47,F
....................             packetdata_index = 0;
07028:  MOVLB  A
0702A:  CLRF   x06
....................             memset(packetdata, 0x00, PACKET_SIZE);
0702C:  MOVLW  09
0702E:  MOVWF  FEA
07030:  MOVLW  C6
07032:  MOVWF  FE9
07034:  CLRF   00
07036:  CLRF   02
07038:  MOVLW  40
0703A:  MOVWF  01
0703C:  MOVLB  0
0703E:  CALL   27A0
....................         }
07042:  MOVLB  A
07044:  INCF   x07,F
07046:  BTFSC  FD8.2
07048:  INCF   x08,F
0704A:  MOVLB  0
0704C:  GOTO   6E4A
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
07050:  MOVLB  A
07052:  MOVF   x06,F
07054:  BTFSS  FD8.2
07056:  BRA    705E
07058:  MOVLB  0
0705A:  GOTO   712A
0705E:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
07060:  MOVFF  A06,A11
07064:  MOVLB  A
07066:  MOVF   x11,W
07068:  SUBLW  3E
0706A:  BTFSC  FD8.0
0706C:  BRA    7074
0706E:  MOVLB  0
07070:  GOTO   7094
07074:  MOVLB  0
....................             packetdata[j] = 0x00;
07076:  CLRF   03
07078:  MOVLB  A
0707A:  MOVF   x11,W
0707C:  ADDLW  C6
0707E:  MOVWF  FE9
07080:  MOVLW  09
07082:  ADDWFC 03,W
07084:  MOVWF  FEA
07086:  CLRF   FEF
07088:  MOVLB  0
0708A:  MOVLB  A
0708C:  INCF   x11,F
0708E:  MOVLB  0
07090:  GOTO   7064
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
07094:  MOVLW  09
07096:  MOVLB  A
07098:  MOVWF  xAE
0709A:  MOVLW  C6
0709C:  MOVWF  xAD
0709E:  MOVLW  3F
070A0:  MOVWF  xAF
070A2:  MOVLB  0
070A4:  CALL   29DC
070A8:  MOVFF  01,A05
....................         unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
070AC:  MOVLB  1
070AE:  MOVF   x40,W
070B0:  MOVLB  A
070B2:  MOVWF  x12
070B4:  MOVLW  10
070B6:  MOVLB  1
070B8:  ADDWF  x41,W
070BA:  MOVLB  A
070BC:  MOVWF  x13
070BE:  MOVLW  7C
070C0:  MOVLB  1
070C2:  ADDWFC x42,W
070C4:  MOVLB  A
070C6:  MOVWF  x14
070C8:  MOVLW  00
070CA:  MOVLB  1
070CC:  ADDWFC x43,W
070CE:  MOVLB  A
070D0:  MOVWF  x15
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
070D2:  MOVFF  111,A59
070D6:  MOVFF  110,A58
070DA:  MOVFF  10F,A57
070DE:  MOVFF  10E,A56
070E2:  MOVFF  A15,A5D
070E6:  MOVFF  A14,A5C
070EA:  MOVFF  A13,A5B
070EE:  MOVFF  A12,A5A
070F2:  MOVLW  09
070F4:  MOVWF  x5F
070F6:  MOVLW  C6
070F8:  MOVWF  x5E
070FA:  CLRF   x61
070FC:  MOVLW  40
070FE:  MOVWF  x60
07100:  MOVLB  0
07102:  CALL   34D6
....................         iv_data.used_counter += PACKET_SIZE;
07106:  MOVLW  40
07108:  MOVLB  1
0710A:  ADDWF  x40,F
0710C:  MOVLW  00
0710E:  ADDWFC x41,F
07110:  MOVLW  00
07112:  ADDWFC x42,F
07114:  MOVLW  00
07116:  ADDWFC x43,F
....................         iv_data.uncopied_counter += PACKET_SIZE;
07118:  MOVLW  40
0711A:  ADDWF  x44,F
0711C:  MOVLW  00
0711E:  ADDWFC x45,F
07120:  MOVLW  00
07122:  ADDWFC x46,F
07124:  MOVLW  00
07126:  ADDWFC x47,F
07128:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "End CIGS data conversion\r\n");
0712A:  MOVLW  FC
0712C:  MOVWF  FF6
0712E:  MOVLW  06
07130:  MOVWF  FF7
07132:  MOVLW  00
07134:  MOVWF  FF8
07136:  CALL   1BBE
....................     write_misf_address_area(); // Write the mission flash address area
0713A:  CALL   3F0A
0713E:  RETURN 0
.................... }
.................... 
.................... MEASUREMENT_DATA create_meas_data()
.................... {
....................     MEASUREMENT_DATA data;
....................     data.time_sec = get_current_sec();
*
06906:  CALL   31B8
0690A:  MOVFF  03,9CB
0690E:  MOVFF  02,9CA
06912:  MOVFF  01,9C9
06916:  MOVFF  00,9C8
....................     data.time_msec = get_current_msec();
0691A:  GOTO   68D6
0691E:  MOVFF  01,9CC
....................     data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
06922:  MOVLW  0D
06924:  MOVLB  9
06926:  MOVWF  xD7
06928:  MOVLB  0
0692A:  CALL   1DAE
0692E:  MOVFF  02,9D0
06932:  MOVFF  01,9CF
....................     data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
06936:  MOVLW  0E
06938:  MOVLB  9
0693A:  MOVWF  xD7
0693C:  MOVLB  0
0693E:  CALL   1DAE
06942:  MOVFF  02,9D2
06946:  MOVFF  01,9D1
....................     data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
0694A:  MOVLW  0C
0694C:  MOVLB  9
0694E:  MOVWF  xD7
06950:  MOVLB  0
06952:  CALL   1DAE
06956:  MOVFF  02,9D4
0695A:  MOVFF  01,9D3
....................     data.pd = ad7490_read(ADC_PD);
0695E:  MOVLW  0F
06960:  MOVLB  9
06962:  MOVWF  xD7
06964:  MOVLB  0
06966:  CALL   1DAE
0696A:  MOVFF  02,9D6
0696E:  MOVFF  01,9D5
....................     data.open_voltage = ad7490_read(ADC_CIGS1_VOLT); // Assuming this is the correct ADC channel for open voltage
06972:  MOVLB  9
06974:  CLRF   xD7
06976:  MOVLB  0
06978:  CALL   1DAE
0697C:  MOVFF  02,9CE
06980:  MOVFF  01,9CD
....................     return data;
06984:  MOVLW  C8
06986:  MOVWF  01
06988:  MOVLW  09
0698A:  MOVWF  02
0698C:  GOTO   81EA (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/mcu/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../storage/mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
.................... {
....................     PICLOG_t piclog;
....................     memset(piclog.bytes, 0, PICLOG_PACKET_SIZE);
*
03F80:  MOVLW  01
03F82:  MOVWF  FEA
03F84:  MOVLW  E2
03F86:  MOVWF  FE9
03F88:  CLRF   00
03F8A:  CLRF   02
03F8C:  MOVLW  06
03F8E:  MOVWF  01
03F90:  CALL   27A0
....................     piclog.fields.time = get_current_sec();
03F94:  CALL   31B8
03F98:  MOVFF  03,1E5
03F9C:  MOVFF  02,1E4
03FA0:  MOVFF  01,1E3
03FA4:  MOVFF  00,1E2
....................     piclog.fields.function = function;
03FA8:  MOVFF  1E0,1E6
....................     piclog.fields.parameter = parameter;
03FAC:  MOVFF  1E1,1E7
.................... 
....................     printf("\t[PICLOG] : ");
03FB0:  MOVLW  18
03FB2:  MOVWF  FF6
03FB4:  MOVLW  07
03FB6:  MOVWF  FF7
03FB8:  MOVLW  00
03FBA:  MOVWF  FF8
03FBC:  CALL   1BBE
....................     for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
03FC0:  MOVLB  1
03FC2:  CLRF   xE8
03FC4:  MOVLB  0
03FC6:  MOVLB  1
03FC8:  MOVF   xE8,W
03FCA:  SUBLW  05
03FCC:  BTFSC  FD8.0
03FCE:  BRA    3FD6
03FD0:  MOVLB  0
03FD2:  GOTO   4012
03FD6:  MOVLB  0
....................         printf("%02X ", piclog.bytes[i]);
03FD8:  CLRF   03
03FDA:  MOVLB  1
03FDC:  MOVF   xE8,W
03FDE:  ADDLW  E2
03FE0:  MOVWF  FE9
03FE2:  MOVLW  01
03FE4:  ADDWFC 03,W
03FE6:  MOVWF  FEA
03FE8:  MOVFF  FEF,1ED
03FEC:  MOVFF  1ED,264
03FF0:  MOVLW  37
03FF2:  MOVLB  2
03FF4:  MOVWF  x65
03FF6:  MOVLB  0
03FF8:  CALL   1E42
03FFC:  MOVLW  20
03FFE:  MOVLB  A
04000:  MOVWF  xAD
04002:  MOVLB  0
04004:  CALL   1B6C
04008:  MOVLB  1
0400A:  INCF   xE8,F
0400C:  MOVLB  0
0400E:  GOTO   3FC6
....................     }
....................     printf("\r\n");
04012:  MOVLW  0D
04014:  MOVLB  A
04016:  MOVWF  xAD
04018:  MOVLB  0
0401A:  CALL   1B6C
0401E:  MOVLW  0A
04020:  MOVLB  A
04022:  MOVWF  xAD
04024:  MOVLB  0
04026:  CALL   1B6C
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
0402A:  MOVLB  1
0402C:  MOVF   x1F,W
0402E:  MOVWF  xE9
04030:  MOVF   x20,W
04032:  MOVWF  xEA
04034:  MOVLW  01
04036:  ADDWF  x21,W
04038:  MOVWF  xEB
0403A:  MOVLW  00
0403C:  ADDWFC x22,W
0403E:  MOVWF  xEC
....................     write_data_bytes(mis_fm, write_address, piclog.bytes, PICLOG_PACKET_SIZE);
04040:  MOVFF  111,A59
04044:  MOVFF  110,A58
04048:  MOVFF  10F,A57
0404C:  MOVFF  10E,A56
04050:  MOVFF  1EC,A5D
04054:  MOVFF  1EB,A5C
04058:  MOVFF  1EA,A5B
0405C:  MOVFF  1E9,A5A
04060:  MOVLW  01
04062:  MOVLB  A
04064:  MOVWF  x5F
04066:  MOVLW  E2
04068:  MOVWF  x5E
0406A:  CLRF   x61
0406C:  MOVLW  06
0406E:  MOVWF  x60
04070:  MOVLB  0
04072:  CALL   34D6
.................... 
....................     piclog_data.used_counter += PICLOG_PACKET_SIZE;
04076:  MOVLW  06
04078:  MOVLB  1
0407A:  ADDWF  x1F,F
0407C:  MOVLW  00
0407E:  ADDWFC x20,F
04080:  MOVLW  00
04082:  ADDWFC x21,F
04084:  MOVLW  00
04086:  ADDWFC x22,F
....................     piclog_data.uncopied_counter += PICLOG_PACKET_SIZE;
04088:  MOVLW  06
0408A:  ADDWF  x23,F
0408C:  MOVLW  00
0408E:  ADDWFC x24,F
04090:  MOVLW  00
04092:  ADDWFC x25,F
04094:  MOVLW  00
04096:  ADDWFC x26,F
....................     piclog_data.reserve_counter1 += PICLOG_PACKET_SIZE;
04098:  MOVLW  06
0409A:  ADDWF  x27,F
.................... 
....................     // Next Packet
....................     if (piclog_data.reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
0409C:  MOVLW  06
0409E:  ADDWF  x27,W
040A0:  SUBLW  3F
040A2:  BTFSS  FD8.0
040A4:  BRA    40AC
040A6:  MOVLB  0
040A8:  GOTO   4120
040AC:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
040AE:  MOVLB  1
040B0:  MOVF   x1F,W
040B2:  MOVWF  xE9
040B4:  MOVF   x20,W
040B6:  MOVWF  xEA
040B8:  MOVLW  01
040BA:  ADDWF  x21,W
040BC:  MOVWF  xEB
040BE:  MOVLW  00
040C0:  ADDWFC x22,W
040C2:  MOVWF  xEC
....................         write_data_bytes(mis_fm, write_address, PICLOG_BLANK_DATA, sizeof(PICLOG_BLANK_DATA));
040C4:  MOVFF  111,A59
040C8:  MOVFF  110,A58
040CC:  MOVFF  10F,A57
040D0:  MOVFF  10E,A56
040D4:  MOVFF  1EC,A5D
040D8:  MOVFF  1EB,A5C
040DC:  MOVFF  1EA,A5B
040E0:  MOVFF  1E9,A5A
040E4:  MOVLW  01
040E6:  MOVLB  A
040E8:  MOVWF  x5F
040EA:  MOVLW  4A
040EC:  MOVWF  x5E
040EE:  CLRF   x61
040F0:  MOVLW  04
040F2:  MOVWF  x60
040F4:  MOVLB  0
040F6:  CALL   34D6
....................         piclog_data.used_counter += sizeof(PICLOG_BLANK_DATA);
040FA:  MOVLW  04
040FC:  MOVLB  1
040FE:  ADDWF  x1F,F
04100:  MOVLW  00
04102:  ADDWFC x20,F
04104:  MOVLW  00
04106:  ADDWFC x21,F
04108:  MOVLW  00
0410A:  ADDWFC x22,F
....................         piclog_data.uncopied_counter += sizeof(PICLOG_BLANK_DATA);
0410C:  MOVLW  04
0410E:  ADDWF  x23,F
04110:  MOVLW  00
04112:  ADDWFC x24,F
04114:  MOVLW  00
04116:  ADDWFC x25,F
04118:  MOVLW  00
0411A:  ADDWFC x26,F
....................         piclog_data.reserve_counter1 = 0;
0411C:  CLRF   x27
0411E:  MOVLB  0
....................     }
.................... 
....................     write_misf_address_area(); // Update the address area after writing
04120:  CALL   3F0A
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
....................     #ifdef PICLOG_DEBUG
04124:  RETURN 0
....................         //fprintf(PC, "PICLOG written: %02X %02X %02X %02X %02X %02X\r\n", piclog_data.bytes[0], data[1], data[2], data[3], data[4], data[5]);
....................     #endif
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
*
05EEA:  MOVLB  1
05EEC:  CLRF   xD3
05EEE:  CLRF   xD4
05EF0:  CLRF   xD5
05EF2:  CLRF   xD6
05EF4:  CLRF   xD7
05EF6:  CLRF   xD8
05EF8:  CLRF   xD9
05EFA:  CLRF   xDA
05EFC:  CLRF   xDB
05EFE:  CLRF   xDC
05F00:  CLRF   xDD
05F02:  CLRF   xDE
05F04:  CLRF   xDF
05F06:  CLRF   xE0
05F08:  CLRF   xE1
05F0A:  CLRF   xE2
05F0C:  CLRF   xE3
05F0E:  CLRF   xE4
05F10:  CLRF   xE5
05F12:  CLRF   xE6
05F14:  CLRF   xE7
05F16:  CLRF   xE8
05F18:  CLRF   xE9
05F1A:  CLRF   xEA
05F1C:  CLRF   xEB
05F1E:  CLRF   xEC
05F20:  CLRF   xED
05F22:  CLRF   xEE
05F24:  CLRF   xEF
05F26:  CLRF   xF0
05F28:  CLRF   xF1
05F2A:  CLRF   xF2
05F2C:  CLRF   xF3
05F2E:  CLRF   xF4
05F30:  CLRF   xF5
05F32:  CLRF   xF6
05F34:  CLRF   xF7
05F36:  CLRF   xF8
05F38:  CLRF   xF9
05F3A:  CLRF   xFA
05F3C:  CLRF   xFB
05F3E:  CLRF   xFC
05F40:  CLRF   xFD
05F42:  CLRF   xFE
05F44:  CLRF   xFF
05F46:  MOVLB  2
05F48:  CLRF   x00
05F4A:  CLRF   x01
05F4C:  CLRF   x02
05F4E:  CLRF   x03
05F50:  CLRF   x04
05F52:  CLRF   x05
05F54:  CLRF   x06
05F56:  CLRF   x07
05F58:  CLRF   x08
05F5A:  CLRF   x09
05F5C:  CLRF   x0A
05F5E:  CLRF   x0B
05F60:  CLRF   x0C
05F62:  CLRF   x0D
05F64:  CLRF   x0E
05F66:  CLRF   x0F
05F68:  CLRF   x10
05F6A:  CLRF   x11
05F6C:  CLRF   x12
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
05F6E:  MOVLW  01
05F70:  MOVLB  A
05F72:  MOVWF  xAE
05F74:  MOVLW  D3
05F76:  MOVWF  xAD
05F78:  MOVLW  3F
05F7A:  MOVWF  xAF
05F7C:  MOVLB  0
05F7E:  CALL   29DC
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
05F82:  MOVFF  115,A59
05F86:  MOVFF  114,A58
05F8A:  MOVFF  113,A57
05F8E:  MOVFF  112,A56
05F92:  MOVLW  06
05F94:  MOVLB  A
05F96:  MOVWF  x5D
05F98:  MOVLW  AA
05F9A:  MOVWF  x5C
05F9C:  CLRF   x5B
05F9E:  CLRF   x5A
05FA0:  MOVLW  01
05FA2:  MOVWF  x5F
05FA4:  MOVLW  D3
05FA6:  MOVWF  x5E
05FA8:  CLRF   x61
05FAA:  MOVLW  40
05FAC:  MOVWF  x60
05FAE:  MOVLB  0
05FB0:  CALL   34D6
05FB4:  GOTO   6104 (RETURN)
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
095EE:  MOVLB  2
095F0:  MOVF   x60,W
095F2:  MOVWF  01
095F4:  MOVF   x61,W
095F6:  MOVWF  03
095F8:  MOVF   01,W
095FA:  MOVWF  x63
095FC:  MOVFF  03,264
09600:  MOVFF  115,2E5
09604:  MOVFF  114,2E4
09608:  MOVFF  113,2E3
0960C:  MOVFF  112,2E2
09610:  MOVLW  06
09612:  MOVWF  xE9
09614:  MOVLW  AA
09616:  MOVWF  xE8
09618:  CLRF   xE7
0961A:  CLRF   xE6
0961C:  MOVFF  264,2EB
09620:  MOVFF  263,2EA
09624:  CLRF   xEF
09626:  CLRF   xEE
09628:  CLRF   xED
0962A:  MOVLW  40
0962C:  MOVWF  xEC
0962E:  MOVLB  0
09630:  CALL   27C4
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
09634:  MOVLB  2
09636:  CLRF   x62
09638:  MOVLB  0
0963A:  MOVLB  2
0963C:  MOVF   x62,W
0963E:  SUBLW  04
09640:  BTFSC  FD8.0
09642:  BRA    964A
09644:  MOVLB  0
09646:  GOTO   9714
0964A:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
0964C:  MOVLB  2
0964E:  MOVF   x60,W
09650:  MOVWF  01
09652:  MOVF   x61,W
09654:  MOVWF  03
09656:  MOVF   01,W
09658:  MOVWF  x63
0965A:  MOVFF  03,264
0965E:  MOVFF  115,2E5
09662:  MOVFF  114,2E4
09666:  MOVFF  113,2E3
0966A:  MOVFF  112,2E2
0966E:  MOVLW  06
09670:  MOVWF  xE9
09672:  MOVLW  AA
09674:  MOVWF  xE8
09676:  CLRF   xE7
09678:  CLRF   xE6
0967A:  MOVFF  264,2EB
0967E:  MOVFF  263,2EA
09682:  CLRF   xEF
09684:  CLRF   xEE
09686:  CLRF   xED
09688:  MOVLW  40
0968A:  MOVWF  xEC
0968C:  MOVLB  0
0968E:  CALL   27C4
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
09692:  MOVLB  2
09694:  MOVF   x60,W
09696:  MOVWF  01
09698:  MOVF   x61,W
0969A:  MOVWF  03
0969C:  MOVF   01,W
0969E:  MOVWF  x63
096A0:  MOVFF  03,264
096A4:  MOVFF  264,2E3
096A8:  MOVFF  263,2E2
096AC:  MOVLW  3F
096AE:  MOVWF  xE4
096B0:  MOVLB  0
096B2:  CALL   95A0
096B6:  MOVF   01,F
096B8:  BTFSC  FD8.2
096BA:  GOTO   970A
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
096BE:  MOVLW  01
096C0:  MOVLB  2
096C2:  ADDWF  x62,W
096C4:  MOVWF  x63
096C6:  MOVLW  26
096C8:  MOVWF  FF6
096CA:  MOVLW  07
096CC:  MOVWF  FF7
096CE:  MOVLW  00
096D0:  MOVWF  FF8
096D2:  MOVLW  23
096D4:  MOVLB  9
096D6:  MOVWF  xC2
096D8:  MOVLB  0
096DA:  CALL   1BEE
096DE:  MOVFF  263,264
096E2:  MOVLW  1B
096E4:  MOVLB  2
096E6:  MOVWF  x65
096E8:  MOVLB  0
096EA:  CALL   6752
096EE:  MOVLW  0D
096F0:  MOVLB  A
096F2:  MOVWF  xAD
096F4:  MOVLB  0
096F6:  CALL   1B6C
096FA:  MOVLW  0A
096FC:  MOVLB  A
096FE:  MOVWF  xAD
09700:  MOVLB  0
09702:  CALL   1B6C
....................             break;
09706:  GOTO   9714
....................         }
0970A:  MOVLB  2
0970C:  INCF   x62,F
0970E:  MOVLB  0
09710:  GOTO   963A
....................     }
09714:  GOTO   9B8A (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
0982A:  CALL   385A
0982E:  MOVFF  02,03
09832:  MOVF   01,W
09834:  MOVWF  FE1
09836:  MOVFF  03,FE2
0983A:  MOVLW  02
0983C:  MOVWF  FEA
0983E:  MOVLW  60
09840:  MOVWF  FE9
09842:  MOVLW  40
09844:  MOVWF  01
09846:  MOVFF  FE6,FEE
0984A:  DECFSZ 01,F
0984C:  GOTO   9846
09850:  MOVLB  2
09852:  BCF    xE0.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
09854:  CLRF   xE1
09856:  MOVLB  0
09858:  MOVLB  2
0985A:  MOVF   xE1,W
0985C:  SUBLW  04
0985E:  BTFSC  FD8.0
09860:  BRA    9868
09862:  MOVLB  0
09864:  GOTO   9968
09868:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
0986A:  MOVFF  115,2E5
0986E:  MOVFF  114,2E4
09872:  MOVFF  113,2E3
09876:  MOVFF  112,2E2
0987A:  MOVLW  06
0987C:  MOVLB  2
0987E:  MOVWF  xE9
09880:  MOVLW  AA
09882:  MOVWF  xE8
09884:  CLRF   xE7
09886:  CLRF   xE6
09888:  MOVLB  0
0988A:  CALL   4A4A
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
0988E:  MOVFF  115,A59
09892:  MOVFF  114,A58
09896:  MOVFF  113,A57
0989A:  MOVFF  112,A56
0989E:  MOVLW  06
098A0:  MOVLB  A
098A2:  MOVWF  x5D
098A4:  MOVLW  AA
098A6:  MOVWF  x5C
098A8:  CLRF   x5B
098AA:  CLRF   x5A
098AC:  MOVLW  02
098AE:  MOVWF  x5F
098B0:  MOVLW  60
098B2:  MOVWF  x5E
098B4:  CLRF   x61
098B6:  MOVLW  40
098B8:  MOVWF  x60
098BA:  MOVLB  0
098BC:  CALL   34D6
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
098C0:  MOVFF  115,2E5
098C4:  MOVFF  114,2E4
098C8:  MOVFF  113,2E3
098CC:  MOVFF  112,2E2
098D0:  MOVLW  06
098D2:  MOVLB  2
098D4:  MOVWF  xE9
098D6:  MOVLW  AA
098D8:  MOVWF  xE8
098DA:  CLRF   xE7
098DC:  CLRF   xE6
098DE:  MOVLW  02
098E0:  MOVWF  xEB
098E2:  MOVLW  A0
098E4:  MOVWF  xEA
098E6:  CLRF   xEF
098E8:  CLRF   xEE
098EA:  CLRF   xED
098EC:  MOVLW  40
098EE:  MOVWF  xEC
098F0:  MOVLB  0
098F2:  CALL   27C4
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
098F6:  MOVLW  02
098F8:  MOVLB  2
098FA:  MOVWF  xE3
098FC:  MOVLW  A0
098FE:  MOVWF  xE2
09900:  MOVLW  3F
09902:  MOVWF  xE4
09904:  MOVLB  0
09906:  CALL   95A0
0990A:  MOVF   01,F
0990C:  BTFSC  FD8.2
0990E:  GOTO   995E
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
09912:  MOVLW  01
09914:  MOVLB  2
09916:  ADDWF  xE1,W
09918:  MOVWF  xE2
0991A:  MOVLW  4E
0991C:  MOVWF  FF6
0991E:  MOVLW  07
09920:  MOVWF  FF7
09922:  MOVLW  00
09924:  MOVWF  FF8
09926:  MOVLW  23
09928:  MOVLB  9
0992A:  MOVWF  xC2
0992C:  MOVLB  0
0992E:  CALL   1BEE
09932:  MOVFF  2E2,2E3
09936:  MOVLW  18
09938:  MOVLB  2
0993A:  MOVWF  xE4
0993C:  MOVLB  0
0993E:  CALL   9718
09942:  MOVLW  0D
09944:  MOVLB  A
09946:  MOVWF  xAD
09948:  MOVLB  0
0994A:  CALL   1B6C
0994E:  MOVLW  0A
09950:  MOVLB  A
09952:  MOVWF  xAD
09954:  MOVLB  0
09956:  CALL   1B6C
....................             break;
0995A:  GOTO   9968
....................         }
0995E:  MOVLB  2
09960:  INCF   xE1,F
09962:  MOVLB  0
09964:  GOTO   9858
....................     }
....................     if (!crc_valid)
09968:  MOVLB  2
0996A:  BTFSS  xE0.0
0996C:  BRA    9974
0996E:  MOVLB  0
09970:  GOTO   99B6
09974:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
09976:  MOVLW  76
09978:  MOVWF  FF6
0997A:  MOVLW  07
0997C:  MOVWF  FF7
0997E:  MOVLW  00
09980:  MOVWF  FF8
09982:  MOVLW  25
09984:  MOVLB  9
09986:  MOVWF  xC2
09988:  MOVLB  0
0998A:  CALL   1BEE
0998E:  MOVLW  05
09990:  MOVLB  2
09992:  MOVWF  xE3
09994:  MOVLW  18
09996:  MOVWF  xE4
09998:  MOVLB  0
0999A:  CALL   9718
0999E:  MOVLW  9D
099A0:  MOVWF  FF6
099A2:  MOVLW  07
099A4:  MOVWF  FF7
099A6:  MOVLW  00
099A8:  MOVWF  FF8
099AA:  MOVLW  0B
099AC:  MOVLB  9
099AE:  MOVWF  xC2
099B0:  MOVLB  0
099B2:  CALL   1BEE
....................         // return; 
....................     }
099B6:  GOTO   A346 (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
099BE:  MOVLW  AA
099C0:  MOVWF  FF6
099C2:  MOVLW  07
099C4:  MOVWF  FF7
099C6:  MOVLW  00
099C8:  MOVWF  FF8
099CA:  CALL   1BBE
....................     fprintf(PC, "_____Start copy_data____\r\n");
099CE:  MOVLW  C4
099D0:  MOVWF  FF6
099D2:  MOVLW  07
099D4:  MOVWF  FF7
099D6:  MOVLW  00
099D8:  MOVWF  FF8
099DA:  CALL   1BBE
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
.................... 
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
099DE:  MOVLB  1
099E0:  MOVF   x8B,W
099E2:  MOVWF  FE9
099E4:  MOVF   x8C,W
099E6:  MOVWF  FEA
099E8:  MOVFF  FEF,260
099EC:  MOVFF  260,267
099F0:  MOVLB  0
099F2:  CALL   9378
099F6:  MOVFF  02,03
099FA:  MOVF   01,W
099FC:  MOVWF  FE1
099FE:  MOVFF  03,FE2
09A02:  MOVLW  01
09A04:  MOVWF  FEA
09A06:  MOVLW  CD
09A08:  MOVWF  FE9
09A0A:  MOVLW  08
09A0C:  MOVWF  01
09A0E:  MOVFF  FE6,FEE
09A12:  DECFSZ 01,F
09A14:  GOTO   9A0E
09A18:  MOVFF  1D0,1D8
09A1C:  MOVFF  1CF,1D7
09A20:  MOVFF  1CE,1D6
09A24:  MOVFF  1CD,1D5
09A28:  MOVFF  1D4,1DC
09A2C:  MOVFF  1D3,1DB
09A30:  MOVFF  1D2,1DA
09A34:  MOVFF  1D1,1D9
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
09A38:  MOVLW  03
09A3A:  MOVLB  1
09A3C:  ADDWF  x8B,W
09A3E:  MOVWF  01
09A40:  MOVLW  00
09A42:  ADDWFC x8C,W
09A44:  MOVWF  03
09A46:  MOVF   01,W
09A48:  MOVWF  FE9
09A4A:  MOVFF  03,FEA
09A4E:  BTFSS  FEF.0
09A50:  BRA    9A58
09A52:  MOVLB  0
09A54:  GOTO   9AB8
09A58:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
09A5A:  MOVLB  1
09A5C:  MOVF   x8B,W
09A5E:  MOVWF  FE9
09A60:  MOVF   x8C,W
09A62:  MOVWF  FEA
09A64:  MOVFF  FEF,260
09A68:  MOVFF  260,267
09A6C:  MOVLB  0
09A6E:  GOTO   9498
09A72:  MOVFF  02,03
09A76:  MOVF   01,W
09A78:  MOVWF  FE1
09A7A:  MOVFF  03,FE2
09A7E:  MOVLW  01
09A80:  MOVWF  FEA
09A82:  MOVLW  E5
09A84:  MOVWF  FE9
09A86:  MOVLW  08
09A88:  MOVWF  01
09A8A:  MOVFF  FE6,FEE
09A8E:  DECFSZ 01,F
09A90:  GOTO   9A8A
....................         write_src = misf_address.start_address;
09A94:  MOVFF  1E8,1E0
09A98:  MOVFF  1E7,1DF
09A9C:  MOVFF  1E6,1DE
09AA0:  MOVFF  1E5,1DD
....................         write_size = iv_data.uncopied_counter;
09AA4:  MOVFF  147,1E4
09AA8:  MOVFF  146,1E3
09AAC:  MOVFF  145,1E2
09AB0:  MOVFF  144,1E1
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
09AB4:  GOTO   9B22
09AB8:  MOVLW  03
09ABA:  MOVLB  1
09ABC:  ADDWF  x8B,W
09ABE:  MOVWF  01
09AC0:  MOVLW  00
09AC2:  ADDWFC x8C,W
09AC4:  MOVWF  03
09AC6:  MOVF   01,W
09AC8:  MOVWF  FE9
09ACA:  MOVFF  03,FEA
09ACE:  BTFSC  FEF.0
09AD0:  BRA    9AD8
09AD2:  MOVLB  0
09AD4:  GOTO   9B22
09AD8:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
09ADA:  MOVLW  04
09ADC:  MOVLB  1
09ADE:  ADDWF  x8B,W
09AE0:  MOVWF  FE9
09AE2:  MOVLW  00
09AE4:  ADDWFC x8C,W
09AE6:  MOVWF  FEA
09AE8:  MOVFF  FEF,1DD
09AEC:  MOVFF  FEC,1DE
09AF0:  MOVFF  FEC,1DF
09AF4:  MOVFF  FEC,1E0
09AF8:  MOVF   FED,F
09AFA:  MOVF   FED,F
09AFC:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
09AFE:  MOVLW  08
09B00:  ADDWF  x8B,W
09B02:  MOVWF  FE9
09B04:  MOVLW  00
09B06:  ADDWFC x8C,W
09B08:  MOVWF  FEA
09B0A:  MOVFF  FEF,1E1
09B0E:  MOVFF  FEC,1E2
09B12:  MOVFF  FEC,1E3
09B16:  MOVFF  FEC,1E4
09B1A:  MOVF   FED,F
09B1C:  MOVF   FED,F
09B1E:  MOVF   FED,F
09B20:  MOVLB  0
....................     }
.................... 
....................     if (!is_connect(mis_fm))
09B22:  MOVFF  111,263
09B26:  MOVFF  110,262
09B2A:  MOVFF  10F,261
09B2E:  MOVFF  10E,260
09B32:  CALL   26D8
09B36:  MOVF   01,F
09B38:  BTFSS  FD8.2
09B3A:  GOTO   9B4E
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
09B3E:  MOVLW  E0
09B40:  MOVWF  FF6
09B42:  MOVLW  07
09B44:  MOVWF  FF7
09B46:  MOVLW  00
09B48:  MOVWF  FF8
09B4A:  CALL   1BBE
....................     }    
....................     if (!is_connect(smf))
09B4E:  MOVFF  115,263
09B52:  MOVFF  114,262
09B56:  MOVFF  113,261
09B5A:  MOVFF  112,260
09B5E:  CALL   26D8
09B62:  MOVF   01,F
09B64:  BTFSS  FD8.2
09B66:  GOTO   9B7A
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
09B6A:  MOVLW  02
09B6C:  MOVWF  FF6
09B6E:  MOVLW  08
09B70:  MOVWF  FF7
09B72:  MOVLW  00
09B74:  MOVWF  FF8
09B76:  CALL   1BBE
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
09B7A:  MOVLW  01
09B7C:  MOVLB  2
09B7E:  MOVWF  x61
09B80:  MOVLW  8D
09B82:  MOVWF  x60
09B84:  MOVLB  0
09B86:  GOTO   95EE
.................... 
....................     // PartitionParamから値を取得
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
09B8A:  MOVFF  154,1F0
09B8E:  MOVFF  153,1EF
09B92:  MOVFF  152,1EE
09B96:  MOVFF  151,1ED
09B9A:  MOVFF  155,1F1
....................     fprintf(PC, "Size area read\r\n");
09B9E:  MOVLW  20
09BA0:  MOVWF  FF6
09BA2:  MOVLW  08
09BA4:  MOVWF  FF7
09BA6:  MOVLW  00
09BA8:  MOVWF  FF8
09BAA:  CALL   1BBE
....................     fprintf(PC, "smf_used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
09BAE:  MOVLW  32
09BB0:  MOVWF  FF6
09BB2:  MOVLW  08
09BB4:  MOVWF  FF7
09BB6:  MOVLW  00
09BB8:  MOVWF  FF8
09BBA:  MOVLW  10
09BBC:  MOVLB  9
09BBE:  MOVWF  xC2
09BC0:  MOVLB  0
09BC2:  CALL   1BEE
09BC6:  MOVLW  41
09BC8:  MOVWF  FE9
09BCA:  MOVFF  1F0,263
09BCE:  MOVFF  1EF,262
09BD2:  MOVFF  1EE,261
09BD6:  MOVFF  1ED,260
09BDA:  CALL   91FC
09BDE:  MOVLW  45
09BE0:  MOVWF  FF6
09BE2:  MOVLW  08
09BE4:  MOVWF  FF7
09BE6:  MOVLW  00
09BE8:  MOVWF  FF8
09BEA:  MOVLW  08
09BEC:  MOVLB  9
09BEE:  MOVWF  xC2
09BF0:  MOVLB  0
09BF2:  CALL   1BEE
09BF6:  MOVFF  1D8,264
09BFA:  MOVLW  37
09BFC:  MOVLB  2
09BFE:  MOVWF  x65
09C00:  MOVLB  0
09C02:  CALL   1E42
09C06:  MOVFF  1D7,264
09C0A:  MOVLW  37
09C0C:  MOVLB  2
09C0E:  MOVWF  x65
09C10:  MOVLB  0
09C12:  CALL   1E42
09C16:  MOVFF  1D6,264
09C1A:  MOVLW  37
09C1C:  MOVLB  2
09C1E:  MOVWF  x65
09C20:  MOVLB  0
09C22:  CALL   1E42
09C26:  MOVFF  1D5,264
09C2A:  MOVLW  37
09C2C:  MOVLB  2
09C2E:  MOVWF  x65
09C30:  MOVLB  0
09C32:  CALL   1E42
09C36:  MOVLW  52
09C38:  MOVWF  FF6
09C3A:  MOVLW  08
09C3C:  MOVWF  FF7
09C3E:  MOVLW  00
09C40:  MOVWF  FF8
09C42:  MOVLW  03
09C44:  MOVLB  9
09C46:  MOVWF  xC2
09C48:  MOVLB  0
09C4A:  CALL   1BEE
....................     fprintf(PC, "smf_loop count= %d  (src 0x%08LX)\r\n", loop_count, mis_start_address + 4);
09C4E:  MOVLW  04
09C50:  MOVLB  1
09C52:  ADDWF  xD5,W
09C54:  MOVLB  2
09C56:  MOVWF  x60
09C58:  MOVLW  00
09C5A:  MOVLB  1
09C5C:  ADDWFC xD6,W
09C5E:  MOVLB  2
09C60:  MOVWF  x61
09C62:  MOVLW  00
09C64:  MOVLB  1
09C66:  ADDWFC xD7,W
09C68:  MOVLB  2
09C6A:  MOVWF  x62
09C6C:  MOVLW  00
09C6E:  MOVLB  1
09C70:  ADDWFC xD8,W
09C72:  MOVLB  2
09C74:  MOVWF  x63
09C76:  MOVLW  56
09C78:  MOVWF  FF6
09C7A:  MOVLW  08
09C7C:  MOVWF  FF7
09C7E:  MOVLW  00
09C80:  MOVWF  FF8
09C82:  MOVLW  10
09C84:  MOVLB  9
09C86:  MOVWF  xC2
09C88:  MOVLB  0
09C8A:  CALL   1BEE
09C8E:  MOVFF  1F1,2E3
09C92:  MOVLW  18
09C94:  MOVLB  2
09C96:  MOVWF  xE4
09C98:  MOVLB  0
09C9A:  CALL   9718
09C9E:  MOVLW  68
09CA0:  MOVWF  FF6
09CA2:  MOVLW  08
09CA4:  MOVWF  FF7
09CA6:  MOVLW  00
09CA8:  MOVWF  FF8
09CAA:  MOVLW  09
09CAC:  MOVLB  9
09CAE:  MOVWF  xC2
09CB0:  MOVLB  0
09CB2:  CALL   1BEE
09CB6:  MOVFF  263,264
09CBA:  MOVLW  37
09CBC:  MOVLB  2
09CBE:  MOVWF  x65
09CC0:  MOVLB  0
09CC2:  CALL   1E42
09CC6:  MOVFF  262,264
09CCA:  MOVLW  37
09CCC:  MOVLB  2
09CCE:  MOVWF  x65
09CD0:  MOVLB  0
09CD2:  CALL   1E42
09CD6:  MOVFF  261,264
09CDA:  MOVLW  37
09CDC:  MOVLB  2
09CDE:  MOVWF  x65
09CE0:  MOVLB  0
09CE2:  CALL   1E42
09CE6:  MOVFF  260,264
09CEA:  MOVLW  37
09CEC:  MOVLB  2
09CEE:  MOVWF  x65
09CF0:  MOVLB  0
09CF2:  CALL   1E42
09CF6:  MOVLW  76
09CF8:  MOVWF  FF6
09CFA:  MOVLW  08
09CFC:  MOVWF  FF7
09CFE:  MOVLW  00
09D00:  MOVWF  FF8
09D02:  MOVLW  03
09D04:  MOVLB  9
09D06:  MOVWF  xC2
09D08:  MOVLB  0
09D0A:  CALL   1BEE
....................     fprintf(PC, "misf_write_source = 0x%08LX\r\n", write_src);
09D0E:  MOVLW  7A
09D10:  MOVWF  FF6
09D12:  MOVLW  08
09D14:  MOVWF  FF7
09D16:  MOVLW  00
09D18:  MOVWF  FF8
09D1A:  MOVLW  16
09D1C:  MOVLB  9
09D1E:  MOVWF  xC2
09D20:  MOVLB  0
09D22:  CALL   1BEE
09D26:  MOVFF  1E0,264
09D2A:  MOVLW  37
09D2C:  MOVLB  2
09D2E:  MOVWF  x65
09D30:  MOVLB  0
09D32:  CALL   1E42
09D36:  MOVFF  1DF,264
09D3A:  MOVLW  37
09D3C:  MOVLB  2
09D3E:  MOVWF  x65
09D40:  MOVLB  0
09D42:  CALL   1E42
09D46:  MOVFF  1DE,264
09D4A:  MOVLW  37
09D4C:  MOVLB  2
09D4E:  MOVWF  x65
09D50:  MOVLB  0
09D52:  CALL   1E42
09D56:  MOVFF  1DD,264
09D5A:  MOVLW  37
09D5C:  MOVLB  2
09D5E:  MOVWF  x65
09D60:  MOVLB  0
09D62:  CALL   1E42
09D66:  MOVLW  0D
09D68:  MOVLB  A
09D6A:  MOVWF  xAD
09D6C:  MOVLB  0
09D6E:  CALL   1B6C
09D72:  MOVLW  0A
09D74:  MOVLB  A
09D76:  MOVWF  xAD
09D78:  MOVLB  0
09D7A:  CALL   1B6C
....................     fprintf(PC, "misf_write_size = 0x%08LX\r\n", write_size);
09D7E:  MOVLW  98
09D80:  MOVWF  FF6
09D82:  MOVLW  08
09D84:  MOVWF  FF7
09D86:  MOVLW  00
09D88:  MOVWF  FF8
09D8A:  MOVLW  14
09D8C:  MOVLB  9
09D8E:  MOVWF  xC2
09D90:  MOVLB  0
09D92:  CALL   1BEE
09D96:  MOVFF  1E4,264
09D9A:  MOVLW  37
09D9C:  MOVLB  2
09D9E:  MOVWF  x65
09DA0:  MOVLB  0
09DA2:  CALL   1E42
09DA6:  MOVFF  1E3,264
09DAA:  MOVLW  37
09DAC:  MOVLB  2
09DAE:  MOVWF  x65
09DB0:  MOVLB  0
09DB2:  CALL   1E42
09DB6:  MOVFF  1E2,264
09DBA:  MOVLW  37
09DBC:  MOVLB  2
09DBE:  MOVWF  x65
09DC0:  MOVLB  0
09DC2:  CALL   1E42
09DC6:  MOVFF  1E1,264
09DCA:  MOVLW  37
09DCC:  MOVLB  2
09DCE:  MOVWF  x65
09DD0:  MOVLB  0
09DD2:  CALL   1E42
09DD6:  MOVLW  0D
09DD8:  MOVLB  A
09DDA:  MOVWF  xAD
09DDC:  MOVLB  0
09DDE:  CALL   1B6C
09DE2:  MOVLW  0A
09DE4:  MOVLB  A
09DE6:  MOVWF  xAD
09DE8:  MOVLB  0
09DEA:  CALL   1B6C
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
09DEE:  MOVLB  1
09DF0:  MOVF   xD5,W
09DF2:  MOVWF  xF2
09DF4:  MOVLW  10
09DF6:  ADDWF  xD6,W
09DF8:  MOVWF  xF3
09DFA:  MOVLW  00
09DFC:  ADDWFC xD7,W
09DFE:  MOVWF  xF4
09E00:  MOVLW  00
09E02:  ADDWFC xD8,W
09E04:  MOVWF  xF5
09E06:  MOVFF  1DC,1F9
09E0A:  MOVFF  1DB,1F8
09E0E:  MOVFF  1DA,1F7
09E12:  MOVFF  1D9,1F6
09E16:  MOVF   xF2,W
09E18:  SUBWF  xF6,W
09E1A:  MOVWF  xFA
09E1C:  MOVF   xF3,W
09E1E:  SUBWFB xF7,W
09E20:  MOVWF  xFB
09E22:  MOVF   xF4,W
09E24:  SUBWFB xF8,W
09E26:  MOVWF  xFC
09E28:  MOVF   xF5,W
09E2A:  SUBWFB xF9,W
09E2C:  MOVWF  xFD
09E2E:  MOVF   xED,W
09E30:  ADDWF  xF2,W
09E32:  MOVWF  xFE
09E34:  MOVF   xEE,W
09E36:  ADDWFC xF3,W
09E38:  MOVWF  xFF
09E3A:  MOVF   xEF,W
09E3C:  ADDWFC xF4,W
09E3E:  MOVLB  2
09E40:  MOVWF  x00
09E42:  MOVLB  1
09E44:  MOVF   xF0,W
09E46:  ADDWFC xF5,W
09E48:  MOVLB  2
09E4A:  MOVWF  x01
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
09E4C:  MOVLB  1
09E4E:  MOVF   xE1,W
09E50:  ADDWF  xED,W
09E52:  MOVLB  2
09E54:  MOVWF  x60
09E56:  MOVLB  1
09E58:  MOVF   xE2,W
09E5A:  ADDWFC xEE,W
09E5C:  MOVLB  2
09E5E:  MOVWF  x61
09E60:  MOVLB  1
09E62:  MOVF   xE3,W
09E64:  ADDWFC xEF,W
09E66:  MOVLB  2
09E68:  MOVWF  x62
09E6A:  MOVLB  1
09E6C:  MOVF   xE4,W
09E6E:  ADDWFC xF0,W
09E70:  MOVLB  2
09E72:  MOVWF  x63
09E74:  MOVLB  1
09E76:  MOVF   xFD,W
09E78:  MOVLB  2
09E7A:  SUBWF  x63,W
09E7C:  BTFSC  FD8.0
09E7E:  BRA    9E86
09E80:  MOVLB  0
09E82:  GOTO   9FC2
09E86:  MOVLB  0
09E88:  BTFSS  FD8.2
09E8A:  GOTO   9ED6
09E8E:  MOVLB  1
09E90:  MOVF   xFC,W
09E92:  MOVLB  2
09E94:  SUBWF  x62,W
09E96:  BTFSC  FD8.0
09E98:  BRA    9EA0
09E9A:  MOVLB  0
09E9C:  GOTO   9FC2
09EA0:  MOVLB  0
09EA2:  BTFSS  FD8.2
09EA4:  GOTO   9ED6
09EA8:  MOVLB  1
09EAA:  MOVF   xFB,W
09EAC:  MOVLB  2
09EAE:  SUBWF  x61,W
09EB0:  BTFSC  FD8.0
09EB2:  BRA    9EBA
09EB4:  MOVLB  0
09EB6:  GOTO   9FC2
09EBA:  MOVLB  0
09EBC:  BTFSS  FD8.2
09EBE:  GOTO   9ED6
09EC2:  MOVLB  2
09EC4:  MOVF   x60,W
09EC6:  MOVLB  1
09EC8:  SUBWF  xFA,W
09ECA:  BTFSS  FD8.0
09ECC:  BRA    9ED4
09ECE:  MOVLB  0
09ED0:  GOTO   9FC2
09ED4:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
09ED6:  MOVLW  B4
09ED8:  MOVWF  FF6
09EDA:  MOVLW  08
09EDC:  MOVWF  FF7
09EDE:  MOVLW  00
09EE0:  MOVWF  FF8
09EE2:  CALL   1BBE
....................         loop_count++;
09EE6:  MOVLB  1
09EE8:  INCF   xF1,F
....................         used_size = 0;
09EEA:  CLRF   xF0
09EEC:  CLRF   xEF
09EEE:  CLRF   xEE
09EF0:  CLRF   xED
....................         data_write_addr = data_region_start;
09EF2:  MOVFF  1F5,201
09EF6:  MOVFF  1F4,200
09EFA:  MOVFF  1F3,1FF
09EFE:  MOVFF  1F2,1FE
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
09F02:  MOVF   x8B,W
09F04:  MOVWF  FE9
09F06:  MOVF   x8C,W
09F08:  MOVWF  FEA
09F0A:  MOVFF  FEF,260
09F0E:  MOVFF  260,261
09F12:  MOVLB  0
09F14:  GOTO   9826
....................         
....................         unsigned int32 erase_ptr = data_region_start;
09F18:  MOVFF  1F5,205
09F1C:  MOVFF  1F4,204
09F20:  MOVFF  1F3,203
09F24:  MOVFF  1F2,202
....................         while (erase_ptr < data_region_end)
09F28:  MOVLB  2
09F2A:  MOVF   x05,W
09F2C:  MOVLB  1
09F2E:  SUBWF  xF9,W
09F30:  BTFSC  FD8.0
09F32:  BRA    9F3A
09F34:  MOVLB  0
09F36:  GOTO   9FC2
09F3A:  MOVLB  0
09F3C:  BTFSS  FD8.2
09F3E:  GOTO   9F8A
09F42:  MOVLB  2
09F44:  MOVF   x04,W
09F46:  MOVLB  1
09F48:  SUBWF  xF8,W
09F4A:  BTFSC  FD8.0
09F4C:  BRA    9F54
09F4E:  MOVLB  0
09F50:  GOTO   9FC2
09F54:  MOVLB  0
09F56:  BTFSS  FD8.2
09F58:  GOTO   9F8A
09F5C:  MOVLB  2
09F5E:  MOVF   x03,W
09F60:  MOVLB  1
09F62:  SUBWF  xF7,W
09F64:  BTFSC  FD8.0
09F66:  BRA    9F6E
09F68:  MOVLB  0
09F6A:  GOTO   9FC2
09F6E:  MOVLB  0
09F70:  BTFSS  FD8.2
09F72:  GOTO   9F8A
09F76:  MOVLB  1
09F78:  MOVF   xF6,W
09F7A:  MOVLB  2
09F7C:  SUBWF  x02,W
09F7E:  BTFSS  FD8.0
09F80:  BRA    9F88
09F82:  MOVLB  0
09F84:  GOTO   9FC2
09F88:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
09F8A:  MOVFF  115,2E5
09F8E:  MOVFF  114,2E4
09F92:  MOVFF  113,2E3
09F96:  MOVFF  112,2E2
09F9A:  MOVFF  205,2E9
09F9E:  MOVFF  204,2E8
09FA2:  MOVFF  203,2E7
09FA6:  MOVFF  202,2E6
09FAA:  CALL   4A4A
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
09FAE:  MOVLW  10
09FB0:  MOVLB  2
09FB2:  ADDWF  x03,F
09FB4:  MOVLW  00
09FB6:  ADDWFC x04,F
09FB8:  MOVLW  00
09FBA:  ADDWFC x05,F
09FBC:  MOVLB  0
09FBE:  GOTO   9F28
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
09FC2:  MOVLB  2
09FC4:  CLRF   x06
09FC6:  MOVLB  1
09FC8:  MOVF   xFF,W
09FCA:  ANDLW  F0
09FCC:  MOVLB  2
09FCE:  MOVWF  x07
09FD0:  CLRF   x08
09FD2:  CLRF   x09
09FD4:  MOVLB  1
09FD6:  MOVF   xE1,W
09FD8:  ADDWF  xFE,W
09FDA:  MOVLB  2
09FDC:  MOVWF  x60
09FDE:  MOVLB  1
09FE0:  MOVF   xE2,W
09FE2:  ADDWFC xFF,W
09FE4:  MOVLB  2
09FE6:  MOVWF  x61
09FE8:  MOVLB  1
09FEA:  MOVF   xE3,W
09FEC:  MOVLB  2
09FEE:  ADDWFC x00,W
09FF0:  MOVWF  x62
09FF2:  MOVLB  1
09FF4:  MOVF   xE4,W
09FF6:  MOVLB  2
09FF8:  ADDWFC x01,W
09FFA:  MOVWF  x63
09FFC:  MOVLW  FF
09FFE:  ADDWF  x60,F
0A000:  MOVLW  0F
0A002:  ADDWFC x61,F
0A004:  MOVLW  00
0A006:  ADDWFC x62,F
0A008:  MOVLW  00
0A00A:  ADDWFC x63,F
0A00C:  CLRF   x0A
0A00E:  MOVF   x61,W
0A010:  ANDLW  F0
0A012:  MOVWF  x0B
0A014:  CLRF   x0C
0A016:  CLRF   x0D
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
0A018:  MOVFF  209,211
0A01C:  MOVFF  208,210
0A020:  MOVFF  207,20F
0A024:  MOVFF  206,20E
0A028:  MOVLB  0
0A02A:  MOVLB  2
0A02C:  MOVF   x11,W
0A02E:  SUBWF  x0D,W
0A030:  BTFSC  FD8.0
0A032:  BRA    A03A
0A034:  MOVLB  0
0A036:  GOTO   A11E
0A03A:  MOVLB  0
0A03C:  BTFSS  FD8.2
0A03E:  GOTO   A084
0A042:  MOVLB  2
0A044:  MOVF   x10,W
0A046:  SUBWF  x0C,W
0A048:  BTFSC  FD8.0
0A04A:  BRA    A052
0A04C:  MOVLB  0
0A04E:  GOTO   A11E
0A052:  MOVLB  0
0A054:  BTFSS  FD8.2
0A056:  GOTO   A084
0A05A:  MOVLB  2
0A05C:  MOVF   x0F,W
0A05E:  SUBWF  x0B,W
0A060:  BTFSC  FD8.0
0A062:  BRA    A06A
0A064:  MOVLB  0
0A066:  GOTO   A11E
0A06A:  MOVLB  0
0A06C:  BTFSS  FD8.2
0A06E:  GOTO   A084
0A072:  MOVLB  2
0A074:  MOVF   x0A,W
0A076:  SUBWF  x0E,W
0A078:  BTFSS  FD8.0
0A07A:  BRA    A082
0A07C:  MOVLB  0
0A07E:  GOTO   A11E
0A082:  MOVLB  0
0A084:  MOVLB  2
0A086:  MOVF   x11,W
0A088:  MOVLB  1
0A08A:  SUBWF  xDC,W
0A08C:  BTFSC  FD8.0
0A08E:  BRA    A096
0A090:  MOVLB  0
0A092:  GOTO   A11E
0A096:  MOVLB  0
0A098:  BTFSS  FD8.2
0A09A:  GOTO   A0E6
0A09E:  MOVLB  2
0A0A0:  MOVF   x10,W
0A0A2:  MOVLB  1
0A0A4:  SUBWF  xDB,W
0A0A6:  BTFSC  FD8.0
0A0A8:  BRA    A0B0
0A0AA:  MOVLB  0
0A0AC:  GOTO   A11E
0A0B0:  MOVLB  0
0A0B2:  BTFSS  FD8.2
0A0B4:  GOTO   A0E6
0A0B8:  MOVLB  2
0A0BA:  MOVF   x0F,W
0A0BC:  MOVLB  1
0A0BE:  SUBWF  xDA,W
0A0C0:  BTFSC  FD8.0
0A0C2:  BRA    A0CA
0A0C4:  MOVLB  0
0A0C6:  GOTO   A11E
0A0CA:  MOVLB  0
0A0CC:  BTFSS  FD8.2
0A0CE:  GOTO   A0E6
0A0D2:  MOVLB  1
0A0D4:  MOVF   xD9,W
0A0D6:  MOVLB  2
0A0D8:  SUBWF  x0E,W
0A0DA:  BTFSS  FD8.0
0A0DC:  BRA    A0E4
0A0DE:  MOVLB  0
0A0E0:  GOTO   A11E
0A0E4:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
0A0E6:  MOVFF  115,2E5
0A0EA:  MOVFF  114,2E4
0A0EE:  MOVFF  113,2E3
0A0F2:  MOVFF  112,2E2
0A0F6:  MOVFF  211,2E9
0A0FA:  MOVFF  210,2E8
0A0FE:  MOVFF  20F,2E7
0A102:  MOVFF  20E,2E6
0A106:  CALL   4A4A
0A10A:  MOVLW  10
0A10C:  MOVLB  2
0A10E:  ADDWF  x0F,F
0A110:  MOVLW  00
0A112:  ADDWFC x10,F
0A114:  MOVLW  00
0A116:  ADDWFC x11,F
0A118:  MOVLB  0
0A11A:  GOTO   A02A
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
0A11E:  MOVFF  1E4,215
0A122:  MOVFF  1E3,214
0A126:  MOVFF  1E2,213
0A12A:  MOVFF  1E1,212
0A12E:  MOVFF  1E0,219
0A132:  MOVFF  1DF,218
0A136:  MOVFF  1DE,217
0A13A:  MOVFF  1DD,216
....................     while (remaining > 0)
0A13E:  MOVLB  2
0A140:  MOVF   x12,F
0A142:  BTFSC  FD8.2
0A144:  BRA    A14C
0A146:  MOVLB  0
0A148:  GOTO   A17E
0A14C:  MOVLB  0
0A14E:  MOVLB  2
0A150:  MOVF   x13,F
0A152:  BTFSC  FD8.2
0A154:  BRA    A15C
0A156:  MOVLB  0
0A158:  GOTO   A17E
0A15C:  MOVLB  0
0A15E:  MOVLB  2
0A160:  MOVF   x14,F
0A162:  BTFSC  FD8.2
0A164:  BRA    A16C
0A166:  MOVLB  0
0A168:  GOTO   A17E
0A16C:  MOVLB  0
0A16E:  MOVLB  2
0A170:  MOVF   x15,F
0A172:  BTFSS  FD8.2
0A174:  BRA    A17C
0A176:  MOVLB  0
0A178:  GOTO   A342
0A17C:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
0A17E:  MOVLB  2
0A180:  MOVF   x15,F
0A182:  BTFSC  FD8.2
0A184:  BRA    A18C
0A186:  MOVLB  0
0A188:  GOTO   A1C0
0A18C:  MOVLB  0
0A18E:  MOVLB  2
0A190:  MOVF   x14,F
0A192:  BTFSC  FD8.2
0A194:  BRA    A19C
0A196:  MOVLB  0
0A198:  GOTO   A1C0
0A19C:  MOVLB  0
0A19E:  MOVLB  2
0A1A0:  MOVF   x13,F
0A1A2:  BTFSC  FD8.2
0A1A4:  BRA    A1AC
0A1A6:  MOVLB  0
0A1A8:  GOTO   A1C0
0A1AC:  MOVLB  0
0A1AE:  MOVLB  2
0A1B0:  MOVF   x12,W
0A1B2:  SUBLW  40
0A1B4:  BTFSS  FD8.0
0A1B6:  BRA    A1BE
0A1B8:  MOVLB  0
0A1BA:  GOTO   A1C8
0A1BE:  MOVLB  0
0A1C0:  CLRF   03
0A1C2:  MOVLW  40
0A1C4:  GOTO   A1D2
0A1C8:  MOVFF  213,03
0A1CC:  MOVLB  2
0A1CE:  MOVF   x12,W
0A1D0:  MOVLB  0
0A1D2:  MOVLB  2
0A1D4:  MOVWF  x5A
0A1D6:  MOVFF  03,25B
0A1DA:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
0A1DC:  MOVFF  111,2E5
0A1E0:  MOVFF  110,2E4
0A1E4:  MOVFF  10F,2E3
0A1E8:  MOVFF  10E,2E2
0A1EC:  MOVFF  219,2E9
0A1F0:  MOVFF  218,2E8
0A1F4:  MOVFF  217,2E7
0A1F8:  MOVFF  216,2E6
0A1FC:  MOVLW  02
0A1FE:  MOVLB  2
0A200:  MOVWF  xEB
0A202:  MOVLW  1A
0A204:  MOVWF  xEA
0A206:  CLRF   xEF
0A208:  CLRF   xEE
0A20A:  MOVFF  25B,2ED
0A20E:  MOVFF  25A,2EC
0A212:  MOVLB  0
0A214:  CALL   27C4
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
0A218:  MOVFF  115,A59
0A21C:  MOVFF  114,A58
0A220:  MOVFF  113,A57
0A224:  MOVFF  112,A56
0A228:  MOVFF  201,A5D
0A22C:  MOVFF  200,A5C
0A230:  MOVFF  1FF,A5B
0A234:  MOVFF  1FE,A5A
0A238:  MOVLW  02
0A23A:  MOVLB  A
0A23C:  MOVWF  x5F
0A23E:  MOVLW  1A
0A240:  MOVWF  x5E
0A242:  MOVFF  25B,A61
0A246:  MOVFF  25A,A60
0A24A:  MOVLB  0
0A24C:  CALL   34D6
....................         for (unsigned int32 i = 0; i < chunk; i++)
0A250:  MOVLB  2
0A252:  CLRF   x5F
0A254:  CLRF   x5E
0A256:  CLRF   x5D
0A258:  CLRF   x5C
0A25A:  MOVLB  0
0A25C:  MOVLB  2
0A25E:  MOVF   x5F,F
0A260:  BTFSC  FD8.2
0A262:  BRA    A26A
0A264:  MOVLB  0
0A266:  GOTO   A2EA
0A26A:  MOVLB  0
0A26C:  MOVLB  2
0A26E:  MOVF   x5E,F
0A270:  BTFSC  FD8.2
0A272:  BRA    A27A
0A274:  MOVLB  0
0A276:  GOTO   A2EA
0A27A:  MOVLB  0
0A27C:  MOVLB  2
0A27E:  MOVF   x5D,W
0A280:  SUBWF  x5B,W
0A282:  BTFSC  FD8.0
0A284:  BRA    A28C
0A286:  MOVLB  0
0A288:  GOTO   A2EA
0A28C:  MOVLB  0
0A28E:  BTFSS  FD8.2
0A290:  GOTO   A2A6
0A294:  MOVLB  2
0A296:  MOVF   x5A,W
0A298:  SUBWF  x5C,W
0A29A:  BTFSS  FD8.0
0A29C:  BRA    A2A4
0A29E:  MOVLB  0
0A2A0:  GOTO   A2EA
0A2A4:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A2A6:  MOVLW  1A
0A2A8:  MOVLB  2
0A2AA:  ADDWF  x5C,W
0A2AC:  MOVWF  FE9
0A2AE:  MOVLW  02
0A2B0:  ADDWFC x5D,W
0A2B2:  MOVWF  FEA
0A2B4:  MOVFF  FEF,260
0A2B8:  MOVFF  260,264
0A2BC:  MOVLW  37
0A2BE:  MOVWF  x65
0A2C0:  MOVLB  0
0A2C2:  CALL   1E42
0A2C6:  MOVLW  20
0A2C8:  MOVLB  A
0A2CA:  MOVWF  xAD
0A2CC:  MOVLB  0
0A2CE:  CALL   1B6C
0A2D2:  MOVLW  01
0A2D4:  MOVLB  2
0A2D6:  ADDWF  x5C,F
0A2D8:  BTFSC  FD8.0
0A2DA:  INCF   x5D,F
0A2DC:  BTFSC  FD8.2
0A2DE:  INCF   x5E,F
0A2E0:  BTFSC  FD8.2
0A2E2:  INCF   x5F,F
0A2E4:  MOVLB  0
0A2E6:  GOTO   A25C
....................         }
....................         src_addr += chunk;
0A2EA:  MOVLB  2
0A2EC:  MOVF   x5A,W
0A2EE:  ADDWF  x16,F
0A2F0:  MOVF   x5B,W
0A2F2:  ADDWFC x17,F
0A2F4:  MOVLW  00
0A2F6:  ADDWFC x18,F
0A2F8:  MOVLW  00
0A2FA:  ADDWFC x19,F
....................         data_write_addr += chunk;
0A2FC:  MOVF   x5A,W
0A2FE:  MOVLB  1
0A300:  ADDWF  xFE,F
0A302:  MOVLB  2
0A304:  MOVF   x5B,W
0A306:  MOVLB  1
0A308:  ADDWFC xFF,F
0A30A:  MOVLW  00
0A30C:  MOVLB  2
0A30E:  ADDWFC x00,F
0A310:  MOVLW  00
0A312:  ADDWFC x01,F
....................         used_size += chunk;
0A314:  MOVF   x5A,W
0A316:  MOVLB  1
0A318:  ADDWF  xED,F
0A31A:  MOVLB  2
0A31C:  MOVF   x5B,W
0A31E:  MOVLB  1
0A320:  ADDWFC xEE,F
0A322:  MOVLW  00
0A324:  ADDWFC xEF,F
0A326:  MOVLW  00
0A328:  ADDWFC xF0,F
....................         remaining -= chunk;
0A32A:  MOVLB  2
0A32C:  MOVF   x5A,W
0A32E:  SUBWF  x12,F
0A330:  MOVF   x5B,W
0A332:  SUBWFB x13,F
0A334:  MOVLW  00
0A336:  SUBWFB x14,F
0A338:  MOVLW  00
0A33A:  SUBWFB x15,F
0A33C:  MOVLB  0
0A33E:  GOTO   A13E
....................     }
....................     // write size area
....................     write_smf_header();
0A342:  GOTO   982A
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0A346:  MOVLB  1
0A348:  MOVF   x8B,W
0A34A:  MOVWF  FE9
0A34C:  MOVF   x8C,W
0A34E:  MOVWF  FEA
0A350:  MOVFF  FEF,260
0A354:  MOVFF  260,261
0A358:  MOVFF  1E4,265
0A35C:  MOVFF  1E3,264
0A360:  MOVFF  1E2,263
0A364:  MOVFF  1E1,262
0A368:  MOVLB  0
0A36A:  GOTO   99BA
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0A36E:  MOVLW  EA
0A370:  MOVWF  FF6
0A372:  MOVLW  08
0A374:  MOVWF  FF7
0A376:  MOVLW  00
0A378:  MOVWF  FF8
0A37A:  MOVLW  0C
0A37C:  MOVLB  9
0A37E:  MOVWF  xC2
0A380:  MOVLB  0
0A382:  CALL   1BEE
0A386:  MOVLW  41
0A388:  MOVWF  FE9
0A38A:  MOVFF  1F0,263
0A38E:  MOVFF  1EF,262
0A392:  MOVFF  1EE,261
0A396:  MOVFF  1ED,260
0A39A:  CALL   91FC
0A39E:  MOVLW  0D
0A3A0:  MOVLB  A
0A3A2:  MOVWF  xAD
0A3A4:  MOVLB  0
0A3A6:  CALL   1B6C
0A3AA:  MOVLW  0A
0A3AC:  MOVLB  A
0A3AE:  MOVWF  xAD
0A3B0:  MOVLB  0
0A3B2:  CALL   1B6C
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0A3B6:  MOVLW  FC
0A3B8:  MOVWF  FF6
0A3BA:  MOVLW  08
0A3BC:  MOVWF  FF7
0A3BE:  MOVLW  00
0A3C0:  MOVWF  FF8
0A3C2:  MOVLW  0D
0A3C4:  MOVLB  9
0A3C6:  MOVWF  xC2
0A3C8:  MOVLB  0
0A3CA:  CALL   1BEE
0A3CE:  MOVFF  1F1,264
0A3D2:  MOVLW  1B
0A3D4:  MOVLB  2
0A3D6:  MOVWF  x65
0A3D8:  MOVLB  0
0A3DA:  CALL   6752
0A3DE:  MOVLW  0B
0A3E0:  MOVWF  FF6
0A3E2:  MOVLW  09
0A3E4:  MOVWF  FF7
0A3E6:  MOVLW  00
0A3E8:  MOVWF  FF8
0A3EA:  MOVLW  04
0A3EC:  MOVLB  9
0A3EE:  MOVWF  xC2
0A3F0:  MOVLB  0
0A3F2:  CALL   1BEE
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0A3F6:  MOVLW  10
0A3F8:  MOVWF  FF6
0A3FA:  MOVLW  09
0A3FC:  MOVWF  FF7
0A3FE:  MOVLW  00
0A400:  MOVWF  FF8
0A402:  CALL   1BBE
....................     fprintf(PC, "____________________\r\n\r\n");
0A406:  MOVLW  2A
0A408:  MOVWF  FF6
0A40A:  MOVLW  09
0A40C:  MOVWF  FF7
0A40E:  MOVLW  00
0A410:  MOVWF  FF8
0A412:  CALL   1BBE
0A416:  GOTO   AFEC (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0A51A:  MOVLW  44
0A51C:  MOVWF  FF6
0A51E:  MOVLW  09
0A520:  MOVWF  FF7
0A522:  MOVLW  00
0A524:  MOVWF  FF8
0A526:  CALL   1BBE
....................     fprintf(PC, "___Start SMF Read____\r\n");
0A52A:  MOVLW  5E
0A52C:  MOVWF  FF6
0A52E:  MOVLW  09
0A530:  MOVWF  FF7
0A532:  MOVLW  00
0A534:  MOVWF  FF8
0A536:  CALL   1BBE
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0A53A:  MOVLB  1
0A53C:  MOVF   x8B,W
0A53E:  MOVWF  FE9
0A540:  MOVF   x8C,W
0A542:  MOVWF  FEA
0A544:  MOVFF  FEF,1E5
0A548:  MOVFF  1E5,267
0A54C:  MOVLB  0
0A54E:  CALL   9378
0A552:  MOVFF  02,03
0A556:  MOVF   01,W
0A558:  MOVWF  FE1
0A55A:  MOVFF  03,FE2
0A55E:  MOVLW  01
0A560:  MOVWF  FEA
0A562:  MOVLW  CD
0A564:  MOVWF  FE9
0A566:  MOVLW  08
0A568:  MOVWF  01
0A56A:  MOVFF  FE6,FEE
0A56E:  DECFSZ 01,F
0A570:  GOTO   A56A
0A574:  MOVLW  04
0A576:  MOVLB  1
0A578:  ADDWF  x8B,W
0A57A:  MOVWF  FE9
0A57C:  MOVLW  00
0A57E:  ADDWFC x8C,W
0A580:  MOVWF  FEA
0A582:  MOVFF  FEF,1D5
0A586:  MOVFF  FEC,1D6
0A58A:  MOVFF  FEC,1D7
0A58E:  MOVFF  FEC,1D8
0A592:  MOVF   FED,F
0A594:  MOVF   FED,F
0A596:  MOVF   FED,F
0A598:  MOVLW  08
0A59A:  ADDWF  x8B,W
0A59C:  MOVWF  FE9
0A59E:  MOVLW  00
0A5A0:  ADDWFC x8C,W
0A5A2:  MOVWF  FEA
0A5A4:  MOVFF  FEF,1D9
0A5A8:  MOVFF  FEC,1DA
0A5AC:  MOVFF  FEC,1DB
0A5B0:  MOVFF  FEC,1DC
0A5B4:  MOVF   FED,F
0A5B6:  MOVF   FED,F
0A5B8:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0A5BA:  MOVLW  76
0A5BC:  MOVWF  FF6
0A5BE:  MOVLW  09
0A5C0:  MOVWF  FF7
0A5C2:  MOVLW  00
0A5C4:  MOVWF  FF8
0A5C6:  MOVLW  21
0A5C8:  MOVLB  9
0A5CA:  MOVWF  xC2
0A5CC:  MOVLB  0
0A5CE:  CALL   1BEE
0A5D2:  MOVFF  1D8,264
0A5D6:  MOVLW  37
0A5D8:  MOVLB  2
0A5DA:  MOVWF  x65
0A5DC:  MOVLB  0
0A5DE:  CALL   1E42
0A5E2:  MOVFF  1D7,264
0A5E6:  MOVLW  37
0A5E8:  MOVLB  2
0A5EA:  MOVWF  x65
0A5EC:  MOVLB  0
0A5EE:  CALL   1E42
0A5F2:  MOVFF  1D6,264
0A5F6:  MOVLW  37
0A5F8:  MOVLB  2
0A5FA:  MOVWF  x65
0A5FC:  MOVLB  0
0A5FE:  CALL   1E42
0A602:  MOVFF  1D5,264
0A606:  MOVLW  37
0A608:  MOVLB  2
0A60A:  MOVWF  x65
0A60C:  MOVLB  0
0A60E:  CALL   1E42
0A612:  MOVLW  0D
0A614:  MOVLB  A
0A616:  MOVWF  xAD
0A618:  MOVLB  0
0A61A:  CALL   1B6C
0A61E:  MOVLW  0A
0A620:  MOVLB  A
0A622:  MOVWF  xAD
0A624:  MOVLB  0
0A626:  CALL   1B6C
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0A62A:  MOVLW  9E
0A62C:  MOVWF  FF6
0A62E:  MOVLW  09
0A630:  MOVWF  FF7
0A632:  MOVLW  00
0A634:  MOVWF  FF8
0A636:  MOVLW  21
0A638:  MOVLB  9
0A63A:  MOVWF  xC2
0A63C:  MOVLB  0
0A63E:  CALL   1BEE
0A642:  MOVLW  41
0A644:  MOVWF  FE9
0A646:  MOVFF  1DC,1E8
0A64A:  MOVFF  1DB,1E7
0A64E:  MOVFF  1DA,1E6
0A652:  MOVFF  1D9,1E5
0A656:  CALL   A41A
0A65A:  MOVLW  C2
0A65C:  MOVWF  FF6
0A65E:  MOVLW  09
0A660:  MOVWF  FF7
0A662:  MOVLW  00
0A664:  MOVWF  FF8
0A666:  MOVLW  04
0A668:  MOVLB  9
0A66A:  MOVWF  xC2
0A66C:  MOVLB  0
0A66E:  CALL   1BEE
0A672:  MOVFF  1DC,264
0A676:  MOVLW  57
0A678:  MOVLB  2
0A67A:  MOVWF  x65
0A67C:  MOVLB  0
0A67E:  CALL   1E42
0A682:  MOVFF  1DB,264
0A686:  MOVLW  57
0A688:  MOVLB  2
0A68A:  MOVWF  x65
0A68C:  MOVLB  0
0A68E:  CALL   1E42
0A692:  MOVFF  1DA,264
0A696:  MOVLW  57
0A698:  MOVLB  2
0A69A:  MOVWF  x65
0A69C:  MOVLB  0
0A69E:  CALL   1E42
0A6A2:  MOVFF  1D9,264
0A6A6:  MOVLW  57
0A6A8:  MOVLB  2
0A6AA:  MOVWF  x65
0A6AC:  MOVLB  0
0A6AE:  CALL   1E42
0A6B2:  MOVLW  C9
0A6B4:  MOVWF  FF6
0A6B6:  MOVLW  09
0A6B8:  MOVWF  FF7
0A6BA:  MOVLW  00
0A6BC:  MOVWF  FF8
0A6BE:  MOVLW  05
0A6C0:  MOVLB  9
0A6C2:  MOVWF  xC2
0A6C4:  MOVLB  0
0A6C6:  CALL   1BEE
.................... 
....................     if (!is_connect(smf)){
0A6CA:  MOVFF  115,263
0A6CE:  MOVFF  114,262
0A6D2:  MOVFF  113,261
0A6D6:  MOVFF  112,260
0A6DA:  CALL   26D8
0A6DE:  MOVF   01,F
0A6E0:  BTFSS  FD8.2
0A6E2:  GOTO   A6F6
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A6E6:  MOVLW  D0
0A6E8:  MOVWF  FF6
0A6EA:  MOVLW  09
0A6EC:  MOVWF  FF7
0A6EE:  MOVLW  00
0A6F0:  MOVWF  FF8
0A6F2:  CALL   1BBE
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0A6F6:  MOVLW  EE
0A6F8:  MOVWF  FF6
0A6FA:  MOVLW  09
0A6FC:  MOVWF  FF7
0A6FE:  MOVLW  00
0A700:  MOVWF  FF8
0A702:  CALL   1BBE
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0A706:  MOVFF  1D8,1E0
0A70A:  MOVFF  1D7,1DF
0A70E:  MOVFF  1D6,1DE
0A712:  MOVFF  1D5,1DD
0A716:  MOVLB  1
0A718:  MOVF   xD9,W
0A71A:  ADDWF  xD5,W
0A71C:  MOVWF  00
0A71E:  MOVF   xDA,W
0A720:  ADDWFC xD6,W
0A722:  MOVWF  01
0A724:  MOVF   xDB,W
0A726:  ADDWFC xD7,W
0A728:  MOVWF  02
0A72A:  MOVF   xDC,W
0A72C:  ADDWFC xD8,W
0A72E:  MOVWF  03
0A730:  MOVF   xE0,W
0A732:  SUBWF  03,W
0A734:  BTFSC  FD8.0
0A736:  BRA    A73E
0A738:  MOVLB  0
0A73A:  GOTO   A886
0A73E:  MOVLB  0
0A740:  BTFSS  FD8.2
0A742:  GOTO   A788
0A746:  MOVLB  1
0A748:  MOVF   xDF,W
0A74A:  SUBWF  02,W
0A74C:  BTFSC  FD8.0
0A74E:  BRA    A756
0A750:  MOVLB  0
0A752:  GOTO   A886
0A756:  MOVLB  0
0A758:  BTFSS  FD8.2
0A75A:  GOTO   A788
0A75E:  MOVLB  1
0A760:  MOVF   xDE,W
0A762:  SUBWF  01,W
0A764:  BTFSC  FD8.0
0A766:  BRA    A76E
0A768:  MOVLB  0
0A76A:  GOTO   A886
0A76E:  MOVLB  0
0A770:  BTFSS  FD8.2
0A772:  GOTO   A788
0A776:  MOVF   00,W
0A778:  MOVLB  1
0A77A:  SUBWF  xDD,W
0A77C:  BTFSS  FD8.0
0A77E:  BRA    A786
0A780:  MOVLB  0
0A782:  GOTO   A886
0A786:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0A788:  MOVFF  115,2E5
0A78C:  MOVFF  114,2E4
0A790:  MOVFF  113,2E3
0A794:  MOVFF  112,2E2
0A798:  MOVFF  1E0,2E9
0A79C:  MOVFF  1DF,2E8
0A7A0:  MOVFF  1DE,2E7
0A7A4:  MOVFF  1DD,2E6
0A7A8:  MOVLW  01
0A7AA:  MOVLB  2
0A7AC:  MOVWF  xEB
0A7AE:  MOVLW  8D
0A7B0:  MOVWF  xEA
0A7B2:  CLRF   xEF
0A7B4:  CLRF   xEE
0A7B6:  CLRF   xED
0A7B8:  MOVLW  40
0A7BA:  MOVWF  xEC
0A7BC:  MOVLB  0
0A7BE:  CALL   27C4
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0A7C2:  MOVLB  1
0A7C4:  CLRF   xE4
0A7C6:  CLRF   xE3
0A7C8:  CLRF   xE2
0A7CA:  CLRF   xE1
0A7CC:  MOVLB  0
0A7CE:  MOVLB  1
0A7D0:  MOVF   xE4,F
0A7D2:  BTFSC  FD8.2
0A7D4:  BRA    A7DC
0A7D6:  MOVLB  0
0A7D8:  GOTO   A856
0A7DC:  MOVLB  0
0A7DE:  MOVLB  1
0A7E0:  MOVF   xE3,F
0A7E2:  BTFSC  FD8.2
0A7E4:  BRA    A7EC
0A7E6:  MOVLB  0
0A7E8:  GOTO   A856
0A7EC:  MOVLB  0
0A7EE:  MOVLB  1
0A7F0:  MOVF   xE2,F
0A7F2:  BTFSC  FD8.2
0A7F4:  BRA    A7FC
0A7F6:  MOVLB  0
0A7F8:  GOTO   A856
0A7FC:  MOVLB  0
0A7FE:  MOVLB  1
0A800:  MOVF   xE1,W
0A802:  SUBLW  3F
0A804:  BTFSC  FD8.0
0A806:  BRA    A80E
0A808:  MOVLB  0
0A80A:  GOTO   A856
0A80E:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A810:  MOVLW  8D
0A812:  MOVLB  1
0A814:  ADDWF  xE1,W
0A816:  MOVWF  FE9
0A818:  MOVLW  01
0A81A:  ADDWFC xE2,W
0A81C:  MOVWF  FEA
0A81E:  MOVFF  FEF,1E5
0A822:  MOVFF  1E5,264
0A826:  MOVLW  37
0A828:  MOVLB  2
0A82A:  MOVWF  x65
0A82C:  MOVLB  0
0A82E:  CALL   1E42
0A832:  MOVLW  20
0A834:  MOVLB  A
0A836:  MOVWF  xAD
0A838:  MOVLB  0
0A83A:  CALL   1B6C
0A83E:  MOVLW  01
0A840:  MOVLB  1
0A842:  ADDWF  xE1,F
0A844:  BTFSC  FD8.0
0A846:  INCF   xE2,F
0A848:  BTFSC  FD8.2
0A84A:  INCF   xE3,F
0A84C:  BTFSC  FD8.2
0A84E:  INCF   xE4,F
0A850:  MOVLB  0
0A852:  GOTO   A7CE
....................         }
....................         fprintf(PC, "\r\n");
0A856:  MOVLW  0D
0A858:  MOVLB  A
0A85A:  MOVWF  xAD
0A85C:  MOVLB  0
0A85E:  CALL   1B6C
0A862:  MOVLW  0A
0A864:  MOVLB  A
0A866:  MOVWF  xAD
0A868:  MOVLB  0
0A86A:  CALL   1B6C
0A86E:  MOVLW  40
0A870:  MOVLB  1
0A872:  ADDWF  xDD,F
0A874:  MOVLW  00
0A876:  ADDWFC xDE,F
0A878:  MOVLW  00
0A87A:  ADDWFC xDF,F
0A87C:  MOVLW  00
0A87E:  ADDWFC xE0,F
0A880:  MOVLB  0
0A882:  GOTO   A716
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0A886:  MOVLW  06
0A888:  MOVWF  FF6
0A88A:  MOVLW  0A
0A88C:  MOVWF  FF7
0A88E:  MOVLW  00
0A890:  MOVWF  FF8
0A892:  CALL   1BBE
....................     fprintf(PC, "____________________\r\n\r\n");
0A896:  MOVLW  1E
0A898:  MOVWF  FF6
0A89A:  MOVLW  0A
0A89C:  MOVWF  FF7
0A89E:  MOVLW  00
0A8A0:  MOVWF  FF8
0A8A2:  CALL   1BBE
0A8A6:  GOTO   AFFC (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0A8AA:  MOVLW  38
0A8AC:  MOVWF  FF6
0A8AE:  MOVLW  0A
0A8B0:  MOVWF  FF7
0A8B2:  MOVLW  00
0A8B4:  MOVWF  FF8
0A8B6:  CALL   1BBE
....................     fprintf(PC, "___Start smf_erase____\r\n");
0A8BA:  MOVLW  52
0A8BC:  MOVWF  FF6
0A8BE:  MOVLW  0A
0A8C0:  MOVWF  FF7
0A8C2:  MOVLW  00
0A8C4:  MOVWF  FF8
0A8C6:  CALL   1BBE
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0A8CA:  MOVLB  1
0A8CC:  MOVF   x8B,W
0A8CE:  MOVWF  FE9
0A8D0:  MOVF   x8C,W
0A8D2:  MOVWF  FEA
0A8D4:  MOVFF  FEF,19D
0A8D8:  MOVFF  19D,267
0A8DC:  MOVLB  0
0A8DE:  CALL   9378
0A8E2:  MOVFF  02,03
0A8E6:  MOVF   01,W
0A8E8:  MOVWF  FE1
0A8EA:  MOVFF  03,FE2
0A8EE:  MOVLW  01
0A8F0:  MOVWF  FEA
0A8F2:  MOVLW  8D
0A8F4:  MOVWF  FE9
0A8F6:  MOVLW  08
0A8F8:  MOVWF  01
0A8FA:  MOVFF  FE6,FEE
0A8FE:  DECFSZ 01,F
0A900:  GOTO   A8FA
0A904:  MOVLW  04
0A906:  MOVLB  1
0A908:  ADDWF  x8B,W
0A90A:  MOVWF  FE9
0A90C:  MOVLW  00
0A90E:  ADDWFC x8C,W
0A910:  MOVWF  FEA
0A912:  MOVFF  FEF,195
0A916:  MOVFF  FEC,196
0A91A:  MOVFF  FEC,197
0A91E:  MOVFF  FEC,198
0A922:  MOVF   FED,F
0A924:  MOVF   FED,F
0A926:  MOVF   FED,F
0A928:  MOVLW  08
0A92A:  ADDWF  x8B,W
0A92C:  MOVWF  FE9
0A92E:  MOVLW  00
0A930:  ADDWFC x8C,W
0A932:  MOVWF  FEA
0A934:  MOVFF  FEF,199
0A938:  MOVFF  FEC,19A
0A93C:  MOVFF  FEC,19B
0A940:  MOVFF  FEC,19C
0A944:  MOVF   FED,F
0A946:  MOVF   FED,F
0A948:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0A94A:  MOVLW  6C
0A94C:  MOVWF  FF6
0A94E:  MOVLW  0A
0A950:  MOVWF  FF7
0A952:  MOVLW  00
0A954:  MOVWF  FF8
0A956:  MOVLW  22
0A958:  MOVLB  9
0A95A:  MOVWF  xC2
0A95C:  MOVLB  0
0A95E:  CALL   1BEE
0A962:  MOVFF  198,264
0A966:  MOVLW  37
0A968:  MOVLB  2
0A96A:  MOVWF  x65
0A96C:  MOVLB  0
0A96E:  CALL   1E42
0A972:  MOVFF  197,264
0A976:  MOVLW  37
0A978:  MOVLB  2
0A97A:  MOVWF  x65
0A97C:  MOVLB  0
0A97E:  CALL   1E42
0A982:  MOVFF  196,264
0A986:  MOVLW  37
0A988:  MOVLB  2
0A98A:  MOVWF  x65
0A98C:  MOVLB  0
0A98E:  CALL   1E42
0A992:  MOVFF  195,264
0A996:  MOVLW  37
0A998:  MOVLB  2
0A99A:  MOVWF  x65
0A99C:  MOVLB  0
0A99E:  CALL   1E42
0A9A2:  MOVLW  0D
0A9A4:  MOVLB  A
0A9A6:  MOVWF  xAD
0A9A8:  MOVLB  0
0A9AA:  CALL   1B6C
0A9AE:  MOVLW  0A
0A9B0:  MOVLB  A
0A9B2:  MOVWF  xAD
0A9B4:  MOVLB  0
0A9B6:  CALL   1B6C
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0A9BA:  MOVLW  94
0A9BC:  MOVWF  FF6
0A9BE:  MOVLW  0A
0A9C0:  MOVWF  FF7
0A9C2:  MOVLW  00
0A9C4:  MOVWF  FF8
0A9C6:  MOVLW  22
0A9C8:  MOVLB  9
0A9CA:  MOVWF  xC2
0A9CC:  MOVLB  0
0A9CE:  CALL   1BEE
0A9D2:  MOVLW  41
0A9D4:  MOVWF  FE9
0A9D6:  MOVFF  19C,1E8
0A9DA:  MOVFF  19B,1E7
0A9DE:  MOVFF  19A,1E6
0A9E2:  MOVFF  199,1E5
0A9E6:  CALL   A41A
0A9EA:  MOVLW  B9
0A9EC:  MOVWF  FF6
0A9EE:  MOVLW  0A
0A9F0:  MOVWF  FF7
0A9F2:  MOVLW  00
0A9F4:  MOVWF  FF8
0A9F6:  MOVLW  04
0A9F8:  MOVLB  9
0A9FA:  MOVWF  xC2
0A9FC:  MOVLB  0
0A9FE:  CALL   1BEE
0AA02:  MOVFF  19C,264
0AA06:  MOVLW  57
0AA08:  MOVLB  2
0AA0A:  MOVWF  x65
0AA0C:  MOVLB  0
0AA0E:  CALL   1E42
0AA12:  MOVFF  19B,264
0AA16:  MOVLW  57
0AA18:  MOVLB  2
0AA1A:  MOVWF  x65
0AA1C:  MOVLB  0
0AA1E:  CALL   1E42
0AA22:  MOVFF  19A,264
0AA26:  MOVLW  57
0AA28:  MOVLB  2
0AA2A:  MOVWF  x65
0AA2C:  MOVLB  0
0AA2E:  CALL   1E42
0AA32:  MOVFF  199,264
0AA36:  MOVLW  57
0AA38:  MOVLB  2
0AA3A:  MOVWF  x65
0AA3C:  MOVLB  0
0AA3E:  CALL   1E42
0AA42:  MOVLW  C0
0AA44:  MOVWF  FF6
0AA46:  MOVLW  0A
0AA48:  MOVWF  FF7
0AA4A:  MOVLW  00
0AA4C:  MOVWF  FF8
0AA4E:  MOVLW  05
0AA50:  MOVLB  9
0AA52:  MOVWF  xC2
0AA54:  MOVLB  0
0AA56:  CALL   1BEE
.................... 
....................     if (!is_connect(smf)){
0AA5A:  MOVFF  115,263
0AA5E:  MOVFF  114,262
0AA62:  MOVFF  113,261
0AA66:  MOVFF  112,260
0AA6A:  CALL   26D8
0AA6E:  MOVF   01,F
0AA70:  BTFSS  FD8.2
0AA72:  GOTO   AA8A
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0AA76:  MOVLW  C6
0AA78:  MOVWF  FF6
0AA7A:  MOVLW  0A
0AA7C:  MOVWF  FF7
0AA7E:  MOVLW  00
0AA80:  MOVWF  FF8
0AA82:  CALL   1BBE
....................         return;
0AA86:  GOTO   ADC4
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0AA8A:  MOVLB  1
0AA8C:  MOVF   x98,W
0AA8E:  SUBWF  x90,W
0AA90:  BTFSC  FD8.0
0AA92:  BRA    AA9A
0AA94:  MOVLB  0
0AA96:  GOTO   AAE4
0AA9A:  MOVLB  0
0AA9C:  BTFSS  FD8.2
0AA9E:  GOTO   AB3E
0AAA2:  MOVLB  1
0AAA4:  MOVF   x97,W
0AAA6:  SUBWF  x8F,W
0AAA8:  BTFSC  FD8.0
0AAAA:  BRA    AAB2
0AAAC:  MOVLB  0
0AAAE:  GOTO   AAE4
0AAB2:  MOVLB  0
0AAB4:  BTFSS  FD8.2
0AAB6:  GOTO   AB3E
0AABA:  MOVLB  1
0AABC:  MOVF   x96,W
0AABE:  SUBWF  x8E,W
0AAC0:  BTFSC  FD8.0
0AAC2:  BRA    AACA
0AAC4:  MOVLB  0
0AAC6:  GOTO   AAE4
0AACA:  MOVLB  0
0AACC:  BTFSS  FD8.2
0AACE:  GOTO   AB3E
0AAD2:  MOVLB  1
0AAD4:  MOVF   x8D,W
0AAD6:  SUBWF  x95,W
0AAD8:  BTFSC  FD8.0
0AADA:  BRA    AAE2
0AADC:  MOVLB  0
0AADE:  GOTO   AB3E
0AAE2:  MOVLB  0
0AAE4:  MOVLB  1
0AAE6:  MOVF   x94,W
0AAE8:  SUBWF  x98,W
0AAEA:  BTFSC  FD8.0
0AAEC:  BRA    AAF4
0AAEE:  MOVLB  0
0AAF0:  GOTO   AC62
0AAF4:  MOVLB  0
0AAF6:  BTFSS  FD8.2
0AAF8:  GOTO   AB3E
0AAFC:  MOVLB  1
0AAFE:  MOVF   x93,W
0AB00:  SUBWF  x97,W
0AB02:  BTFSC  FD8.0
0AB04:  BRA    AB0C
0AB06:  MOVLB  0
0AB08:  GOTO   AC62
0AB0C:  MOVLB  0
0AB0E:  BTFSS  FD8.2
0AB10:  GOTO   AB3E
0AB14:  MOVLB  1
0AB16:  MOVF   x92,W
0AB18:  SUBWF  x96,W
0AB1A:  BTFSC  FD8.0
0AB1C:  BRA    AB24
0AB1E:  MOVLB  0
0AB20:  GOTO   AC62
0AB24:  MOVLB  0
0AB26:  BTFSS  FD8.2
0AB28:  GOTO   AB3E
0AB2C:  MOVLB  1
0AB2E:  MOVF   x91,W
0AB30:  SUBWF  x95,W
0AB32:  BTFSC  FD8.0
0AB34:  BRA    AB3C
0AB36:  MOVLB  0
0AB38:  GOTO   AC62
0AB3C:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0AB3E:  MOVLW  E4
0AB40:  MOVWF  FF6
0AB42:  MOVLW  0A
0AB44:  MOVWF  FF7
0AB46:  MOVLW  00
0AB48:  MOVWF  FF8
0AB4A:  MOVLW  1E
0AB4C:  MOVLB  9
0AB4E:  MOVWF  xC2
0AB50:  MOVLB  0
0AB52:  CALL   1BEE
0AB56:  MOVFF  198,264
0AB5A:  MOVLW  37
0AB5C:  MOVLB  2
0AB5E:  MOVWF  x65
0AB60:  MOVLB  0
0AB62:  CALL   1E42
0AB66:  MOVFF  197,264
0AB6A:  MOVLW  37
0AB6C:  MOVLB  2
0AB6E:  MOVWF  x65
0AB70:  MOVLB  0
0AB72:  CALL   1E42
0AB76:  MOVFF  196,264
0AB7A:  MOVLW  37
0AB7C:  MOVLB  2
0AB7E:  MOVWF  x65
0AB80:  MOVLB  0
0AB82:  CALL   1E42
0AB86:  MOVFF  195,264
0AB8A:  MOVLW  37
0AB8C:  MOVLB  2
0AB8E:  MOVWF  x65
0AB90:  MOVLB  0
0AB92:  CALL   1E42
0AB96:  MOVLW  05
0AB98:  MOVWF  FF6
0AB9A:  MOVLW  0B
0AB9C:  MOVWF  FF7
0AB9E:  MOVLW  00
0ABA0:  MOVWF  FF8
0ABA2:  MOVLW  1D
0ABA4:  MOVLB  9
0ABA6:  MOVWF  xC2
0ABA8:  MOVLB  0
0ABAA:  CALL   1BEE
0ABAE:  MOVFF  190,264
0ABB2:  MOVLW  37
0ABB4:  MOVLB  2
0ABB6:  MOVWF  x65
0ABB8:  MOVLB  0
0ABBA:  CALL   1E42
0ABBE:  MOVFF  18F,264
0ABC2:  MOVLW  37
0ABC4:  MOVLB  2
0ABC6:  MOVWF  x65
0ABC8:  MOVLB  0
0ABCA:  CALL   1E42
0ABCE:  MOVFF  18E,264
0ABD2:  MOVLW  37
0ABD4:  MOVLB  2
0ABD6:  MOVWF  x65
0ABD8:  MOVLB  0
0ABDA:  CALL   1E42
0ABDE:  MOVFF  18D,264
0ABE2:  MOVLW  37
0ABE4:  MOVLB  2
0ABE6:  MOVWF  x65
0ABE8:  MOVLB  0
0ABEA:  CALL   1E42
0ABEE:  MOVLW  25
0ABF0:  MOVWF  FF6
0ABF2:  MOVLW  0B
0ABF4:  MOVWF  FF7
0ABF6:  MOVLW  00
0ABF8:  MOVWF  FF8
0ABFA:  MOVLW  05
0ABFC:  MOVLB  9
0ABFE:  MOVWF  xC2
0AC00:  MOVLB  0
0AC02:  CALL   1BEE
0AC06:  MOVFF  194,264
0AC0A:  MOVLW  37
0AC0C:  MOVLB  2
0AC0E:  MOVWF  x65
0AC10:  MOVLB  0
0AC12:  CALL   1E42
0AC16:  MOVFF  193,264
0AC1A:  MOVLW  37
0AC1C:  MOVLB  2
0AC1E:  MOVWF  x65
0AC20:  MOVLB  0
0AC22:  CALL   1E42
0AC26:  MOVFF  192,264
0AC2A:  MOVLW  37
0AC2C:  MOVLB  2
0AC2E:  MOVWF  x65
0AC30:  MOVLB  0
0AC32:  CALL   1E42
0AC36:  MOVFF  191,264
0AC3A:  MOVLW  37
0AC3C:  MOVLB  2
0AC3E:  MOVWF  x65
0AC40:  MOVLB  0
0AC42:  CALL   1E42
0AC46:  MOVLW  2D
0AC48:  MOVWF  FF6
0AC4A:  MOVLW  0B
0AC4C:  MOVWF  FF7
0AC4E:  MOVLW  00
0AC50:  MOVWF  FF8
0AC52:  MOVLW  03
0AC54:  MOVLB  9
0AC56:  MOVWF  xC2
0AC58:  MOVLB  0
0AC5A:  CALL   1BEE
....................         return;
0AC5E:  GOTO   ADC4
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0AC62:  MOVLB  1
0AC64:  MOVF   x99,W
0AC66:  ADDWF  x95,W
0AC68:  MOVWF  x9D
0AC6A:  MOVF   x9A,W
0AC6C:  ADDWFC x96,W
0AC6E:  MOVWF  x9E
0AC70:  MOVF   x9B,W
0AC72:  ADDWFC x97,W
0AC74:  MOVWF  x9F
0AC76:  MOVF   x9C,W
0AC78:  ADDWFC x98,W
0AC7A:  MOVWF  xA0
0AC7C:  MOVF   x94,W
0AC7E:  SUBWF  xA0,W
0AC80:  BTFSC  FD8.0
0AC82:  BRA    AC8A
0AC84:  MOVLB  0
0AC86:  GOTO   AD70
0AC8A:  MOVLB  0
0AC8C:  BTFSS  FD8.2
0AC8E:  GOTO   ACD4
0AC92:  MOVLB  1
0AC94:  MOVF   x93,W
0AC96:  SUBWF  x9F,W
0AC98:  BTFSC  FD8.0
0AC9A:  BRA    ACA2
0AC9C:  MOVLB  0
0AC9E:  GOTO   AD70
0ACA2:  MOVLB  0
0ACA4:  BTFSS  FD8.2
0ACA6:  GOTO   ACD4
0ACAA:  MOVLB  1
0ACAC:  MOVF   x92,W
0ACAE:  SUBWF  x9E,W
0ACB0:  BTFSC  FD8.0
0ACB2:  BRA    ACBA
0ACB4:  MOVLB  0
0ACB6:  GOTO   AD70
0ACBA:  MOVLB  0
0ACBC:  BTFSS  FD8.2
0ACBE:  GOTO   ACD4
0ACC2:  MOVLB  1
0ACC4:  MOVF   x9D,W
0ACC6:  SUBWF  x91,W
0ACC8:  BTFSS  FD8.0
0ACCA:  BRA    ACD2
0ACCC:  MOVLB  0
0ACCE:  GOTO   AD70
0ACD2:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0ACD4:  MOVLW  32
0ACD6:  MOVWF  FF6
0ACD8:  MOVLW  0B
0ACDA:  MOVWF  FF7
0ACDC:  MOVLW  00
0ACDE:  MOVWF  FF8
0ACE0:  MOVLW  3A
0ACE2:  MOVLB  9
0ACE4:  MOVWF  xC2
0ACE6:  MOVLB  0
0ACE8:  CALL   1BEE
0ACEC:  MOVFF  194,264
0ACF0:  MOVLW  37
0ACF2:  MOVLB  2
0ACF4:  MOVWF  x65
0ACF6:  MOVLB  0
0ACF8:  CALL   1E42
0ACFC:  MOVFF  193,264
0AD00:  MOVLW  37
0AD02:  MOVLB  2
0AD04:  MOVWF  x65
0AD06:  MOVLB  0
0AD08:  CALL   1E42
0AD0C:  MOVFF  192,264
0AD10:  MOVLW  37
0AD12:  MOVLB  2
0AD14:  MOVWF  x65
0AD16:  MOVLB  0
0AD18:  CALL   1E42
0AD1C:  MOVFF  191,264
0AD20:  MOVLW  37
0AD22:  MOVLB  2
0AD24:  MOVWF  x65
0AD26:  MOVLB  0
0AD28:  CALL   1E42
0AD2C:  MOVLW  0D
0AD2E:  MOVLB  A
0AD30:  MOVWF  xAD
0AD32:  MOVLB  0
0AD34:  CALL   1B6C
0AD38:  MOVLW  0A
0AD3A:  MOVLB  A
0AD3C:  MOVWF  xAD
0AD3E:  MOVLB  0
0AD40:  CALL   1B6C
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0AD44:  MOVLW  72
0AD46:  MOVWF  FF6
0AD48:  MOVLW  0B
0AD4A:  MOVWF  FF7
0AD4C:  MOVLW  00
0AD4E:  MOVWF  FF8
0AD50:  CALL   1BBE
....................         erase_size = mission_type.end_address - erase_address;
0AD54:  MOVLB  1
0AD56:  MOVF   x95,W
0AD58:  SUBWF  x91,W
0AD5A:  MOVWF  x99
0AD5C:  MOVF   x96,W
0AD5E:  SUBWFB x92,W
0AD60:  MOVWF  x9A
0AD62:  MOVF   x97,W
0AD64:  SUBWFB x93,W
0AD66:  MOVWF  x9B
0AD68:  MOVF   x98,W
0AD6A:  SUBWFB x94,W
0AD6C:  MOVWF  x9C
0AD6E:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0AD70:  MOVLW  A6
0AD72:  MOVWF  FF6
0AD74:  MOVLW  0B
0AD76:  MOVWF  FF7
0AD78:  MOVLW  00
0AD7A:  MOVWF  FF8
0AD7C:  CALL   1BBE
....................     subsector_4kByte_erase(smf, erase_address);
0AD80:  MOVFF  115,2E5
0AD84:  MOVFF  114,2E4
0AD88:  MOVFF  113,2E3
0AD8C:  MOVFF  112,2E2
0AD90:  MOVFF  198,2E9
0AD94:  MOVFF  197,2E8
0AD98:  MOVFF  196,2E7
0AD9C:  MOVFF  195,2E6
0ADA0:  CALL   4A4A
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0ADA4:  MOVLW  D8
0ADA6:  MOVWF  FF6
0ADA8:  MOVLW  0B
0ADAA:  MOVWF  FF7
0ADAC:  MOVLW  00
0ADAE:  MOVWF  FF8
0ADB0:  CALL   1BBE
....................     fprintf(PC, "____________________\r\n\r\n");
0ADB4:  MOVLW  F2
0ADB6:  MOVWF  FF6
0ADB8:  MOVLW  0B
0ADBA:  MOVWF  FF7
0ADBC:  MOVLW  00
0ADBE:  MOVWF  FF8
0ADC0:  CALL   1BBE
0ADC4:  GOTO   B00C (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
099BA:  GOTO   A36E (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
09826:  GOTO   9F18 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"                // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"             // ツールライブラリ
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/smf_queue.h"              // SMFキュー管理
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
02FDC:  MOVLW  78
02FDE:  MOVWF  FF6
02FE0:  MOVLW  0C
02FE2:  MOVWF  FF7
02FE4:  MOVLW  00
02FE6:  MOVWF  FF8
02FE8:  CALL   1BBE
....................     output_high(MIS_FM_CS);
02FEC:  MOVLW  DB
02FEE:  MOVWF  F92
02FF0:  BSF    F89.5
....................     output_high(SMF_CS);
02FF2:  MOVLW  DB
02FF4:  MOVWF  F92
02FF6:  BSF    F89.2
....................     delay_ms(100);
02FF8:  MOVLW  64
02FFA:  MOVLB  A
02FFC:  MOVWF  x6E
02FFE:  MOVLB  0
03000:  CALL   1B3E
.................... 
....................     // 読み込みID処理 ・・・(既存そのまま)
....................     if (is_connect(mis_fm)) {
03004:  MOVFF  111,263
03008:  MOVFF  110,262
0300C:  MOVFF  10F,261
03010:  MOVFF  10E,260
03014:  CALL   26D8
03018:  MOVF   01,F
0301A:  BTFSC  FD8.2
0301C:  GOTO   3034
....................         fprintf(PC, "\t[MIS FM] Connected\r\n");
03020:  MOVLW  94
03022:  MOVWF  FF6
03024:  MOVLW  0C
03026:  MOVWF  FF7
03028:  MOVLW  00
0302A:  MOVWF  FF8
0302C:  CALL   1BBE
....................     } else {
03030:  GOTO   3044
....................         fprintf(PC, "\t[MIS FM] Not Connected\r\n");
03034:  MOVLW  AA
03036:  MOVWF  FF6
03038:  MOVLW  0C
0303A:  MOVWF  FF7
0303C:  MOVLW  00
0303E:  MOVWF  FF8
03040:  CALL   1BBE
....................     }
.................... 
....................     if (is_connect(smf)) {
03044:  MOVFF  115,263
03048:  MOVFF  114,262
0304C:  MOVFF  113,261
03050:  MOVFF  112,260
03054:  CALL   26D8
03058:  MOVF   01,F
0305A:  BTFSC  FD8.2
0305C:  GOTO   3074
....................         fprintf(PC, "\t[SMF] Connected\r\n");
03060:  MOVLW  C4
03062:  MOVWF  FF6
03064:  MOVLW  0C
03066:  MOVWF  FF7
03068:  MOVLW  00
0306A:  MOVWF  FF8
0306C:  CALL   1BBE
....................     } else {
03070:  GOTO   3084
....................         fprintf(PC, "\t[SMF] Not Connected\r\n");
03074:  MOVLW  D8
03076:  MOVWF  FF6
03078:  MOVLW  0C
0307A:  MOVWF  FF7
0307C:  MOVLW  00
0307E:  MOVWF  FF8
03080:  CALL   1BBE
....................     }
.................... 
....................     //=== MIS_FM カウンタテーブル読出し ===//
....................     FlashData_t flash_data;
....................     memset(flash_data.bytes, 0, PACKET_SIZE);
03084:  MOVLW  01
03086:  MOVWF  FEA
03088:  MOVLW  D3
0308A:  MOVWF  FE9
0308C:  CLRF   00
0308E:  CLRF   02
03090:  MOVLW  40
03092:  MOVWF  01
03094:  CALL   27A0
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
03098:  MOVFF  111,2E5
0309C:  MOVFF  110,2E4
030A0:  MOVFF  10F,2E3
030A4:  MOVFF  10E,2E2
030A8:  MOVLB  2
030AA:  CLRF   xE9
030AC:  CLRF   xE8
030AE:  CLRF   xE7
030B0:  CLRF   xE6
030B2:  MOVLW  01
030B4:  MOVWF  xEB
030B6:  MOVLW  D3
030B8:  MOVWF  xEA
030BA:  CLRF   xEF
030BC:  CLRF   xEE
030BE:  CLRF   xED
030C0:  MOVLW  40
030C2:  MOVWF  xEC
030C4:  MOVLB  0
030C6:  CALL   27C4
.................... 
....................     // CRC 検証
....................     if (flash_data.packet.crc != calc_crc8(flash_data.bytes, PACKET_SIZE - 1)) {
030CA:  MOVLW  01
030CC:  MOVLB  A
030CE:  MOVWF  xAE
030D0:  MOVLW  D3
030D2:  MOVWF  xAD
030D4:  MOVLW  3F
030D6:  MOVWF  xAF
030D8:  MOVLB  0
030DA:  CALL   29DC
030DE:  MOVF   01,W
030E0:  MOVLB  2
030E2:  SUBWF  x12,W
030E4:  BTFSS  FD8.2
030E6:  BRA    30EE
030E8:  MOVLB  0
030EA:  GOTO   3100
030EE:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error -> initialize counters\r\n");
030F0:  MOVLW  F0
030F2:  MOVWF  FF6
030F4:  MOVLW  0C
030F6:  MOVWF  FF7
030F8:  MOVLW  00
030FA:  MOVWF  FF8
030FC:  CALL   1BBE
....................         // デフォルト初期化
....................         /*
....................         piclog_data.id        = FLASH_ID_PICLOG;
....................         environment_data.id   = FLASH_ID_ENVIRONMENT;
....................         iv_header.id          = FLASH_ID_IV_HEADER;
....................         iv_data.id            = FLASH_ID_IV_DATA;
....................         piclog_data.used_counter = 0;
....................         piclog_data.uncopied_counter = 0;
....................         environment_data.used_counter = 0;
....................         environment_data.uncopied_counter = 0;
....................         iv_header.used_counter = 0;
....................         iv_header.uncopied_counter = 0;
....................         iv_data.used_counter = 0;
....................         iv_data.uncopied_counter = 0;
....................         write_misf_address_area();   // 初期テーブル書込み
....................         print_flash_status();
....................         return;
....................         */
....................     }
.................... 
....................     //=== 個別コピー (キャスト禁止) ===//
....................     piclog_data.id        = FLASH_ID_PICLOG;
03100:  MOVLB  1
03102:  CLRF   x1E
....................     piclog_data.used_counter     = flash_data.packet.payload.logdata.piclog.used_counter;
03104:  MOVFF  1D6,122
03108:  MOVFF  1D5,121
0310C:  MOVFF  1D4,120
03110:  MOVFF  1D3,11F
....................     piclog_data.uncopied_counter = flash_data.packet.payload.logdata.piclog.uncopied_counter;
03114:  MOVFF  1DA,126
03118:  MOVFF  1D9,125
0311C:  MOVFF  1D8,124
03120:  MOVFF  1D7,123
....................     piclog_data.reserve_counter1 = flash_data.packet.payload.logdata.piclog.reserve_counter1;
03124:  MOVFF  1DB,127
....................     piclog_data.reserve_counter2 = flash_data.packet.payload.logdata.piclog.reserve_counter2;
03128:  MOVFF  1DC,128
.................... 
....................     environment_data.id        = FLASH_ID_ENVIRONMENT;
0312C:  MOVLW  01
0312E:  MOVWF  x29
....................     environment_data.used_counter     = flash_data.packet.payload.logdata.environment.used_counter;
03130:  MOVFF  1E0,12D
03134:  MOVFF  1DF,12C
03138:  MOVFF  1DE,12B
0313C:  MOVFF  1DD,12A
....................     environment_data.uncopied_counter = flash_data.packet.payload.logdata.environment.uncopied_counter;
03140:  MOVFF  1E4,131
03144:  MOVFF  1E3,130
03148:  MOVFF  1E2,12F
0314C:  MOVFF  1E1,12E
....................     environment_data.reserve_counter1 = flash_data.packet.payload.logdata.environment.reserve_counter1;
03150:  MOVFF  1E5,132
....................     environment_data.reserve_counter2 = flash_data.packet.payload.logdata.environment.reserve_counter2;
03154:  MOVFF  1E6,133
.................... 
....................     iv_header.id        = FLASH_ID_IV_HEADER;
03158:  MOVLW  02
0315A:  MOVWF  x34
....................     iv_header.used_counter     = flash_data.packet.payload.logdata.iv_header.used_counter;
0315C:  MOVFF  1EA,138
03160:  MOVFF  1E9,137
03164:  MOVFF  1E8,136
03168:  MOVFF  1E7,135
....................     iv_header.uncopied_counter = flash_data.packet.payload.logdata.iv_header.uncopied_counter;
0316C:  MOVFF  1EE,13C
03170:  MOVFF  1ED,13B
03174:  MOVFF  1EC,13A
03178:  MOVFF  1EB,139
....................     iv_header.reserve_counter1 = flash_data.packet.payload.logdata.iv_header.reserve_counter1;
0317C:  MOVFF  1EF,13D
....................     iv_header.reserve_counter2 = flash_data.packet.payload.logdata.iv_header.reserve_counter2;
03180:  MOVFF  1F0,13E
.................... 
....................     iv_data.id        = FLASH_ID_IV_DATA;
03184:  MOVLW  03
03186:  MOVWF  x3F
....................     iv_data.used_counter     = flash_data.packet.payload.logdata.iv_data.used_counter;
03188:  MOVFF  1F4,143
0318C:  MOVFF  1F3,142
03190:  MOVFF  1F2,141
03194:  MOVFF  1F1,140
....................     iv_data.uncopied_counter = flash_data.packet.payload.logdata.iv_data.uncopied_counter;
03198:  MOVFF  1F8,147
0319C:  MOVFF  1F7,146
031A0:  MOVFF  1F6,145
031A4:  MOVFF  1F5,144
....................     iv_data.reserve_counter1 = flash_data.packet.payload.logdata.iv_data.reserve_counter1;
031A8:  MOVFF  1F9,148
....................     iv_data.reserve_counter2 = flash_data.packet.payload.logdata.iv_data.reserve_counter2;
031AC:  MOVFF  1FA,149
.................... 
....................     print_flash_status();
031B0:  MOVLB  0
031B2:  GOTO   2A48
031B6:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table()
.................... {
....................     FlashData_t flash_data;
....................     memset(&flash_data.bytes, 0, sizeof(flash_data.bytes));
*
0385A:  MOVLW  0A
0385C:  MOVWF  FEA
0385E:  MOVLW  5C
03860:  MOVWF  FE9
03862:  CLRF   00
03864:  CLRF   02
03866:  MOVLW  40
03868:  MOVWF  01
0386A:  CALL   27A0
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv_header,
....................         &flash_data.packet.payload.logdata.iv_data
....................     };
0386E:  MOVLW  0A
03870:  MOVLB  A
03872:  MOVWF  x9D
03874:  MOVLW  5C
03876:  MOVWF  x9C
03878:  MOVLW  0A
0387A:  MOVWF  x9F
0387C:  MOVLW  66
0387E:  MOVWF  x9E
03880:  MOVLW  0A
03882:  MOVWF  xA1
03884:  MOVLW  70
03886:  MOVWF  xA0
03888:  MOVLW  0A
0388A:  MOVWF  xA3
0388C:  MOVLW  7A
0388E:  MOVWF  xA2
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv_header,
....................         &iv_data
....................     };
03890:  MOVLW  01
03892:  MOVWF  xA5
03894:  MOVLW  1E
03896:  MOVWF  xA4
03898:  MOVLW  01
0389A:  MOVWF  xA7
0389C:  MOVLW  29
0389E:  MOVWF  xA6
038A0:  MOVLW  01
038A2:  MOVWF  xA9
038A4:  MOVLW  34
038A6:  MOVWF  xA8
038A8:  MOVLW  01
038AA:  MOVWF  xAB
038AC:  MOVLW  3F
038AE:  MOVWF  xAA
.................... 
....................     for (int i = 0; i < 4; i++) {
038B0:  CLRF   xAC
038B2:  MOVLB  0
038B4:  MOVLB  A
038B6:  MOVF   xAC,W
038B8:  SUBLW  03
038BA:  BTFSC  FD8.0
038BC:  BRA    38C4
038BE:  MOVLB  0
038C0:  GOTO   3B78
038C4:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
038C6:  CLRF   03
038C8:  MOVLB  A
038CA:  MOVF   xAC,W
038CC:  MOVWF  02
038CE:  BCF    FD8.0
038D0:  RLCF   02,F
038D2:  RLCF   03,F
038D4:  MOVF   02,W
038D6:  ADDLW  9C
038D8:  MOVWF  01
038DA:  MOVLW  0A
038DC:  ADDWFC 03,F
038DE:  MOVF   01,W
038E0:  MOVWF  xAD
038E2:  MOVFF  03,AAE
038E6:  MOVFF  AAE,FEA
038EA:  MOVFF  AAD,FE9
038EE:  MOVFF  FEC,AB0
038F2:  MOVF   FED,F
038F4:  MOVFF  FEF,AAF
038F8:  MOVF   xAF,W
038FA:  MOVWF  01
038FC:  MOVF   xB0,W
038FE:  MOVWF  03
03900:  MOVF   01,W
03902:  MOVWF  xB1
03904:  MOVFF  03,AB2
03908:  CLRF   03
0390A:  MOVF   xAC,W
0390C:  MOVWF  02
0390E:  BCF    FD8.0
03910:  RLCF   02,F
03912:  RLCF   03,F
03914:  MOVF   02,W
03916:  ADDLW  A4
03918:  MOVWF  01
0391A:  MOVLW  0A
0391C:  ADDWFC 03,F
0391E:  MOVF   01,W
03920:  MOVWF  xB3
03922:  MOVFF  03,AB4
03926:  MOVFF  AB4,FEA
0392A:  MOVFF  AB3,FE9
0392E:  MOVFF  FEC,AB6
03932:  MOVF   FED,F
03934:  MOVFF  FEF,AB5
03938:  MOVLW  01
0393A:  ADDWF  xB5,W
0393C:  MOVWF  FE9
0393E:  MOVLW  00
03940:  ADDWFC xB6,W
03942:  MOVWF  FEA
03944:  MOVFF  FEF,00
03948:  MOVFF  FEC,01
0394C:  MOVFF  FEC,02
03950:  MOVFF  FEC,03
03954:  MOVF   FED,F
03956:  MOVF   FED,F
03958:  MOVF   FED,F
0395A:  MOVFF  03,ABA
0395E:  MOVFF  02,AB9
03962:  MOVFF  01,AB8
03966:  MOVFF  00,AB7
0396A:  MOVFF  AB2,FEA
0396E:  MOVFF  AB1,FE9
03972:  MOVFF  AB7,FEF
03976:  MOVFF  AB8,FEC
0397A:  MOVFF  AB9,FEC
0397E:  MOVFF  ABA,FEC
03982:  MOVF   FED,F
03984:  MOVF   FED,F
03986:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
03988:  CLRF   03
0398A:  MOVF   xAC,W
0398C:  MOVWF  02
0398E:  BCF    FD8.0
03990:  RLCF   02,F
03992:  RLCF   03,F
03994:  MOVF   02,W
03996:  ADDLW  9C
03998:  MOVWF  01
0399A:  MOVLW  0A
0399C:  ADDWFC 03,F
0399E:  MOVF   01,W
039A0:  MOVWF  xAD
039A2:  MOVFF  03,AAE
039A6:  MOVFF  AAE,FEA
039AA:  MOVFF  AAD,FE9
039AE:  MOVFF  FEC,AB0
039B2:  MOVF   FED,F
039B4:  MOVFF  FEF,AAF
039B8:  MOVLW  04
039BA:  ADDWF  xAF,W
039BC:  MOVWF  01
039BE:  MOVLW  00
039C0:  ADDWFC xB0,W
039C2:  MOVWF  03
039C4:  MOVF   01,W
039C6:  MOVWF  xB1
039C8:  MOVFF  03,AB2
039CC:  CLRF   03
039CE:  MOVF   xAC,W
039D0:  MOVWF  02
039D2:  BCF    FD8.0
039D4:  RLCF   02,F
039D6:  RLCF   03,F
039D8:  MOVF   02,W
039DA:  ADDLW  A4
039DC:  MOVWF  01
039DE:  MOVLW  0A
039E0:  ADDWFC 03,F
039E2:  MOVF   01,W
039E4:  MOVWF  xB3
039E6:  MOVFF  03,AB4
039EA:  MOVFF  AB4,FEA
039EE:  MOVFF  AB3,FE9
039F2:  MOVFF  FEC,AB6
039F6:  MOVF   FED,F
039F8:  MOVFF  FEF,AB5
039FC:  MOVLW  05
039FE:  ADDWF  xB5,W
03A00:  MOVWF  FE9
03A02:  MOVLW  00
03A04:  ADDWFC xB6,W
03A06:  MOVWF  FEA
03A08:  MOVFF  FEF,00
03A0C:  MOVFF  FEC,01
03A10:  MOVFF  FEC,02
03A14:  MOVFF  FEC,03
03A18:  MOVF   FED,F
03A1A:  MOVF   FED,F
03A1C:  MOVF   FED,F
03A1E:  MOVFF  03,ABA
03A22:  MOVFF  02,AB9
03A26:  MOVFF  01,AB8
03A2A:  MOVFF  00,AB7
03A2E:  MOVFF  AB2,FEA
03A32:  MOVFF  AB1,FE9
03A36:  MOVFF  AB7,FEF
03A3A:  MOVFF  AB8,FEC
03A3E:  MOVFF  AB9,FEC
03A42:  MOVFF  ABA,FEC
03A46:  MOVF   FED,F
03A48:  MOVF   FED,F
03A4A:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
03A4C:  CLRF   03
03A4E:  MOVF   xAC,W
03A50:  MOVWF  02
03A52:  BCF    FD8.0
03A54:  RLCF   02,F
03A56:  RLCF   03,F
03A58:  MOVF   02,W
03A5A:  ADDLW  9C
03A5C:  MOVWF  01
03A5E:  MOVLW  0A
03A60:  ADDWFC 03,F
03A62:  MOVF   01,W
03A64:  MOVWF  xAD
03A66:  MOVFF  03,AAE
03A6A:  MOVFF  AAE,FEA
03A6E:  MOVFF  AAD,FE9
03A72:  MOVFF  FEC,AB0
03A76:  MOVF   FED,F
03A78:  MOVFF  FEF,AAF
03A7C:  MOVLW  08
03A7E:  ADDWF  xAF,W
03A80:  MOVWF  01
03A82:  MOVLW  00
03A84:  ADDWFC xB0,W
03A86:  MOVWF  03
03A88:  MOVF   01,W
03A8A:  MOVWF  xB1
03A8C:  MOVFF  03,AB2
03A90:  CLRF   03
03A92:  MOVF   xAC,W
03A94:  MOVWF  02
03A96:  BCF    FD8.0
03A98:  RLCF   02,F
03A9A:  RLCF   03,F
03A9C:  MOVF   02,W
03A9E:  ADDLW  A4
03AA0:  MOVWF  01
03AA2:  MOVLW  0A
03AA4:  ADDWFC 03,F
03AA6:  MOVF   01,W
03AA8:  MOVWF  xB3
03AAA:  MOVFF  03,AB4
03AAE:  MOVFF  AB4,FEA
03AB2:  MOVFF  AB3,FE9
03AB6:  MOVFF  FEC,AB6
03ABA:  MOVF   FED,F
03ABC:  MOVFF  FEF,AB5
03AC0:  MOVLW  09
03AC2:  ADDWF  xB5,W
03AC4:  MOVWF  FE9
03AC6:  MOVLW  00
03AC8:  ADDWFC xB6,W
03ACA:  MOVWF  FEA
03ACC:  MOVF   FEF,W
03ACE:  MOVWF  xB7
03AD0:  MOVFF  AB2,FEA
03AD4:  MOVFF  AB1,FE9
03AD8:  MOVFF  AB7,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
03ADC:  CLRF   03
03ADE:  MOVF   xAC,W
03AE0:  MOVWF  02
03AE2:  BCF    FD8.0
03AE4:  RLCF   02,F
03AE6:  RLCF   03,F
03AE8:  MOVF   02,W
03AEA:  ADDLW  9C
03AEC:  MOVWF  01
03AEE:  MOVLW  0A
03AF0:  ADDWFC 03,F
03AF2:  MOVF   01,W
03AF4:  MOVWF  xAD
03AF6:  MOVFF  03,AAE
03AFA:  MOVFF  AAE,FEA
03AFE:  MOVFF  AAD,FE9
03B02:  MOVFF  FEC,AB0
03B06:  MOVF   FED,F
03B08:  MOVFF  FEF,AAF
03B0C:  MOVLW  09
03B0E:  ADDWF  xAF,W
03B10:  MOVWF  01
03B12:  MOVLW  00
03B14:  ADDWFC xB0,W
03B16:  MOVWF  03
03B18:  MOVF   01,W
03B1A:  MOVWF  xB1
03B1C:  MOVFF  03,AB2
03B20:  CLRF   03
03B22:  MOVF   xAC,W
03B24:  MOVWF  02
03B26:  BCF    FD8.0
03B28:  RLCF   02,F
03B2A:  RLCF   03,F
03B2C:  MOVF   02,W
03B2E:  ADDLW  A4
03B30:  MOVWF  01
03B32:  MOVLW  0A
03B34:  ADDWFC 03,F
03B36:  MOVF   01,W
03B38:  MOVWF  xB3
03B3A:  MOVFF  03,AB4
03B3E:  MOVFF  AB4,FEA
03B42:  MOVFF  AB3,FE9
03B46:  MOVFF  FEC,AB6
03B4A:  MOVF   FED,F
03B4C:  MOVFF  FEF,AB5
03B50:  MOVLW  0A
03B52:  ADDWF  xB5,W
03B54:  MOVWF  FE9
03B56:  MOVLW  00
03B58:  ADDWFC xB6,W
03B5A:  MOVWF  FEA
03B5C:  MOVF   FEF,W
03B5E:  MOVWF  xB7
03B60:  MOVFF  AB2,FEA
03B64:  MOVFF  AB1,FE9
03B68:  MOVFF  AB7,FEF
03B6C:  MOVLB  0
03B6E:  MOVLB  A
03B70:  INCF   xAC,F
03B72:  MOVLB  0
03B74:  GOTO   38B4
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
03B78:  MOVLW  0A
03B7A:  MOVLB  A
03B7C:  MOVWF  xAE
03B7E:  MOVLW  5C
03B80:  MOVWF  xAD
03B82:  MOVLW  3F
03B84:  MOVWF  xAF
03B86:  MOVLB  0
03B88:  CALL   29DC
03B8C:  MOVFF  01,A9B
....................     // fprintf(PC, "make table\r\n");
....................     // for (int i = 0; i < PACKET_SIZE; i++) {
....................         // fprintf(PC, "%02X ", flash_data.bytes[i]);
....................     // }
....................     fprintf(PC, "\r\n");
03B90:  MOVLW  0D
03B92:  MOVLB  A
03B94:  MOVWF  xAD
03B96:  MOVLB  0
03B98:  CALL   1B6C
03B9C:  MOVLW  0A
03B9E:  MOVLB  A
03BA0:  MOVWF  xAD
03BA2:  MOVLB  0
03BA4:  CALL   1B6C
....................     return flash_data;
03BA8:  MOVLW  5C
03BAA:  MOVWF  01
03BAC:  MOVLW  0A
03BAE:  MOVWF  02
03BB0:  RETURN 0
.................... }
.................... 
.................... 
.................... void write_misf_address_area(void)
*
03F0A:  CALL   385A
03F0E:  MOVFF  02,03
03F12:  MOVF   01,W
03F14:  MOVWF  FE1
03F16:  MOVFF  03,FE2
03F1A:  MOVLW  0A
03F1C:  MOVWF  FEA
03F1E:  MOVLW  16
03F20:  MOVWF  FE9
03F22:  MOVLW  40
03F24:  MOVWF  01
03F26:  MOVFF  FE6,FEE
03F2A:  DECFSZ 01,F
03F2C:  GOTO   3F26
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
....................     sector_erase(mis_fm, MISF_CIGS_DATA_TABLE_START);
03F30:  MOVFF  111,A59
03F34:  MOVFF  110,A58
03F38:  MOVFF  10F,A57
03F3C:  MOVFF  10E,A56
03F40:  MOVLB  A
03F42:  CLRF   x5D
03F44:  CLRF   x5C
03F46:  CLRF   x5B
03F48:  CLRF   x5A
03F4A:  MOVLB  0
03F4C:  CALL   3BB2
....................     // START に書く (以前 END だった)
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
03F50:  MOVFF  111,A59
03F54:  MOVFF  110,A58
03F58:  MOVFF  10F,A57
03F5C:  MOVFF  10E,A56
03F60:  MOVLB  A
03F62:  CLRF   x5D
03F64:  CLRF   x5C
03F66:  CLRF   x5B
03F68:  CLRF   x5A
03F6A:  MOVLW  0A
03F6C:  MOVWF  x5F
03F6E:  MOVLW  16
03F70:  MOVWF  x5E
03F72:  CLRF   x61
03F74:  MOVLW  40
03F76:  MOVWF  x60
03F78:  MOVLB  0
03F7A:  CALL   34D6
03F7E:  RETURN 0
.................... }
.................... 
.................... // PICLOG 更新後に呼ばれる関数例 (piclog_write 内で既に write_misf_address_area 呼んでいる場合は不要)
.................... static void update_piclog_counters_after_write(unsigned int16 wrote_size)
.................... {
....................     piclog_data.used_counter     += wrote_size;
....................     piclog_data.uncopied_counter += wrote_size;
....................     // 必要なら wrap 処理追加
....................     write_misf_address_area();
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG    | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02A48:  MOVLW  1E
02A4A:  MOVWF  FF6
02A4C:  MOVLW  0D
02A4E:  MOVWF  FF7
02A50:  MOVLW  00
02A52:  MOVWF  FF8
02A54:  MOVLW  2B
02A56:  MOVLB  9
02A58:  MOVWF  xC2
02A5A:  MOVLB  0
02A5C:  CALL   1BEE
02A60:  MOVFF  122,264
02A64:  MOVLW  37
02A66:  MOVLB  2
02A68:  MOVWF  x65
02A6A:  MOVLB  0
02A6C:  CALL   1E42
02A70:  MOVFF  121,264
02A74:  MOVLW  37
02A76:  MOVLB  2
02A78:  MOVWF  x65
02A7A:  MOVLB  0
02A7C:  CALL   1E42
02A80:  MOVFF  120,264
02A84:  MOVLW  37
02A86:  MOVLB  2
02A88:  MOVWF  x65
02A8A:  MOVLB  0
02A8C:  CALL   1E42
02A90:  MOVFF  11F,264
02A94:  MOVLW  37
02A96:  MOVLB  2
02A98:  MOVWF  x65
02A9A:  MOVLB  0
02A9C:  CALL   1E42
02AA0:  MOVLW  0D
02AA2:  MOVLB  A
02AA4:  MOVWF  xAD
02AA6:  MOVLB  0
02AA8:  CALL   1B6C
02AAC:  MOVLW  0A
02AAE:  MOVLB  A
02AB0:  MOVWF  xAD
02AB2:  MOVLB  0
02AB4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | PICLOG    | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02AB8:  MOVLW  52
02ABA:  MOVWF  FF6
02ABC:  MOVLW  0D
02ABE:  MOVWF  FF7
02AC0:  MOVLW  00
02AC2:  MOVWF  FF8
02AC4:  MOVLW  2B
02AC6:  MOVLB  9
02AC8:  MOVWF  xC2
02ACA:  MOVLB  0
02ACC:  CALL   1BEE
02AD0:  MOVFF  126,264
02AD4:  MOVLW  37
02AD6:  MOVLB  2
02AD8:  MOVWF  x65
02ADA:  MOVLB  0
02ADC:  CALL   1E42
02AE0:  MOVFF  125,264
02AE4:  MOVLW  37
02AE6:  MOVLB  2
02AE8:  MOVWF  x65
02AEA:  MOVLB  0
02AEC:  CALL   1E42
02AF0:  MOVFF  124,264
02AF4:  MOVLW  37
02AF6:  MOVLB  2
02AF8:  MOVWF  x65
02AFA:  MOVLB  0
02AFC:  CALL   1E42
02B00:  MOVFF  123,264
02B04:  MOVLW  37
02B06:  MOVLB  2
02B08:  MOVWF  x65
02B0A:  MOVLB  0
02B0C:  CALL   1E42
02B10:  MOVLW  0D
02B12:  MOVLB  A
02B14:  MOVWF  xAD
02B16:  MOVLB  0
02B18:  CALL   1B6C
02B1C:  MOVLW  0A
02B1E:  MOVLB  A
02B20:  MOVWF  xAD
02B22:  MOVLB  0
02B24:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02B28:  MOVLW  86
02B2A:  MOVWF  FF6
02B2C:  MOVLW  0D
02B2E:  MOVWF  FF7
02B30:  MOVLW  00
02B32:  MOVWF  FF8
02B34:  MOVLW  2B
02B36:  MOVLB  9
02B38:  MOVWF  xC2
02B3A:  MOVLB  0
02B3C:  CALL   1BEE
02B40:  MOVFF  127,264
02B44:  MOVLW  37
02B46:  MOVLB  2
02B48:  MOVWF  x65
02B4A:  MOVLB  0
02B4C:  CALL   1E42
02B50:  MOVLW  0D
02B52:  MOVLB  A
02B54:  MOVWF  xAD
02B56:  MOVLB  0
02B58:  CALL   1B6C
02B5C:  MOVLW  0A
02B5E:  MOVLB  A
02B60:  MOVWF  xAD
02B62:  MOVLB  0
02B64:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02B68:  MOVLW  B8
02B6A:  MOVWF  FF6
02B6C:  MOVLW  0D
02B6E:  MOVWF  FF7
02B70:  MOVLW  00
02B72:  MOVWF  FF8
02B74:  MOVLW  2B
02B76:  MOVLB  9
02B78:  MOVWF  xC2
02B7A:  MOVLB  0
02B7C:  CALL   1BEE
02B80:  MOVFF  128,264
02B84:  MOVLW  37
02B86:  MOVLB  2
02B88:  MOVWF  x65
02B8A:  MOVLB  0
02B8C:  CALL   1E42
02B90:  MOVLW  0D
02B92:  MOVLB  A
02B94:  MOVWF  xAD
02B96:  MOVLB  0
02B98:  CALL   1B6C
02B9C:  MOVLW  0A
02B9E:  MOVLB  A
02BA0:  MOVWF  xAD
02BA2:  MOVLB  0
02BA4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02BA8:  MOVLW  EA
02BAA:  MOVWF  FF6
02BAC:  MOVLW  0D
02BAE:  MOVWF  FF7
02BB0:  MOVLW  00
02BB2:  MOVWF  FF8
02BB4:  MOVLW  2B
02BB6:  MOVLB  9
02BB8:  MOVWF  xC2
02BBA:  MOVLB  0
02BBC:  CALL   1BEE
02BC0:  MOVFF  12D,264
02BC4:  MOVLW  37
02BC6:  MOVLB  2
02BC8:  MOVWF  x65
02BCA:  MOVLB  0
02BCC:  CALL   1E42
02BD0:  MOVFF  12C,264
02BD4:  MOVLW  37
02BD6:  MOVLB  2
02BD8:  MOVWF  x65
02BDA:  MOVLB  0
02BDC:  CALL   1E42
02BE0:  MOVFF  12B,264
02BE4:  MOVLW  37
02BE6:  MOVLB  2
02BE8:  MOVWF  x65
02BEA:  MOVLB  0
02BEC:  CALL   1E42
02BF0:  MOVFF  12A,264
02BF4:  MOVLW  37
02BF6:  MOVLB  2
02BF8:  MOVWF  x65
02BFA:  MOVLB  0
02BFC:  CALL   1E42
02C00:  MOVLW  0D
02C02:  MOVLB  A
02C04:  MOVWF  xAD
02C06:  MOVLB  0
02C08:  CALL   1B6C
02C0C:  MOVLW  0A
02C0E:  MOVLB  A
02C10:  MOVWF  xAD
02C12:  MOVLB  0
02C14:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02C18:  MOVLW  1E
02C1A:  MOVWF  FF6
02C1C:  MOVLW  0E
02C1E:  MOVWF  FF7
02C20:  MOVLW  00
02C22:  MOVWF  FF8
02C24:  MOVLW  2B
02C26:  MOVLB  9
02C28:  MOVWF  xC2
02C2A:  MOVLB  0
02C2C:  CALL   1BEE
02C30:  MOVFF  131,264
02C34:  MOVLW  37
02C36:  MOVLB  2
02C38:  MOVWF  x65
02C3A:  MOVLB  0
02C3C:  CALL   1E42
02C40:  MOVFF  130,264
02C44:  MOVLW  37
02C46:  MOVLB  2
02C48:  MOVWF  x65
02C4A:  MOVLB  0
02C4C:  CALL   1E42
02C50:  MOVFF  12F,264
02C54:  MOVLW  37
02C56:  MOVLB  2
02C58:  MOVWF  x65
02C5A:  MOVLB  0
02C5C:  CALL   1E42
02C60:  MOVFF  12E,264
02C64:  MOVLW  37
02C66:  MOVLB  2
02C68:  MOVWF  x65
02C6A:  MOVLB  0
02C6C:  CALL   1E42
02C70:  MOVLW  0D
02C72:  MOVLB  A
02C74:  MOVWF  xAD
02C76:  MOVLB  0
02C78:  CALL   1B6C
02C7C:  MOVLW  0A
02C7E:  MOVLB  A
02C80:  MOVWF  xAD
02C82:  MOVLB  0
02C84:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02C88:  MOVLW  52
02C8A:  MOVWF  FF6
02C8C:  MOVLW  0E
02C8E:  MOVWF  FF7
02C90:  MOVLW  00
02C92:  MOVWF  FF8
02C94:  MOVLW  2B
02C96:  MOVLB  9
02C98:  MOVWF  xC2
02C9A:  MOVLB  0
02C9C:  CALL   1BEE
02CA0:  MOVFF  132,264
02CA4:  MOVLW  37
02CA6:  MOVLB  2
02CA8:  MOVWF  x65
02CAA:  MOVLB  0
02CAC:  CALL   1E42
02CB0:  MOVLW  0D
02CB2:  MOVLB  A
02CB4:  MOVWF  xAD
02CB6:  MOVLB  0
02CB8:  CALL   1B6C
02CBC:  MOVLW  0A
02CBE:  MOVLB  A
02CC0:  MOVWF  xAD
02CC2:  MOVLB  0
02CC4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02CC8:  MOVLW  84
02CCA:  MOVWF  FF6
02CCC:  MOVLW  0E
02CCE:  MOVWF  FF7
02CD0:  MOVLW  00
02CD2:  MOVWF  FF8
02CD4:  MOVLW  2B
02CD6:  MOVLB  9
02CD8:  MOVWF  xC2
02CDA:  MOVLB  0
02CDC:  CALL   1BEE
02CE0:  MOVFF  133,264
02CE4:  MOVLW  37
02CE6:  MOVLB  2
02CE8:  MOVWF  x65
02CEA:  MOVLB  0
02CEC:  CALL   1E42
02CF0:  MOVLW  0D
02CF2:  MOVLB  A
02CF4:  MOVWF  xAD
02CF6:  MOVLB  0
02CF8:  CALL   1B6C
02CFC:  MOVLW  0A
02CFE:  MOVLB  A
02D00:  MOVWF  xAD
02D02:  MOVLB  0
02D04:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Use Counter      : 0x%08LX\r\n", iv_header.used_counter);
02D08:  MOVLW  B6
02D0A:  MOVWF  FF6
02D0C:  MOVLW  0E
02D0E:  MOVWF  FF7
02D10:  MOVLW  00
02D12:  MOVWF  FF8
02D14:  MOVLW  2B
02D16:  MOVLB  9
02D18:  MOVWF  xC2
02D1A:  MOVLB  0
02D1C:  CALL   1BEE
02D20:  MOVFF  138,264
02D24:  MOVLW  37
02D26:  MOVLB  2
02D28:  MOVWF  x65
02D2A:  MOVLB  0
02D2C:  CALL   1E42
02D30:  MOVFF  137,264
02D34:  MOVLW  37
02D36:  MOVLB  2
02D38:  MOVWF  x65
02D3A:  MOVLB  0
02D3C:  CALL   1E42
02D40:  MOVFF  136,264
02D44:  MOVLW  37
02D46:  MOVLB  2
02D48:  MOVWF  x65
02D4A:  MOVLB  0
02D4C:  CALL   1E42
02D50:  MOVFF  135,264
02D54:  MOVLW  37
02D56:  MOVLB  2
02D58:  MOVWF  x65
02D5A:  MOVLB  0
02D5C:  CALL   1E42
02D60:  MOVLW  0D
02D62:  MOVLB  A
02D64:  MOVWF  xAD
02D66:  MOVLB  0
02D68:  CALL   1B6C
02D6C:  MOVLW  0A
02D6E:  MOVLB  A
02D70:  MOVWF  xAD
02D72:  MOVLB  0
02D74:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Uncopyed Counter : 0x%08LX\r\n", iv_header.uncopied_counter);
02D78:  MOVLW  EA
02D7A:  MOVWF  FF6
02D7C:  MOVLW  0E
02D7E:  MOVWF  FF7
02D80:  MOVLW  00
02D82:  MOVWF  FF8
02D84:  MOVLW  2B
02D86:  MOVLB  9
02D88:  MOVWF  xC2
02D8A:  MOVLB  0
02D8C:  CALL   1BEE
02D90:  MOVFF  13C,264
02D94:  MOVLW  37
02D96:  MOVLB  2
02D98:  MOVWF  x65
02D9A:  MOVLB  0
02D9C:  CALL   1E42
02DA0:  MOVFF  13B,264
02DA4:  MOVLW  37
02DA6:  MOVLB  2
02DA8:  MOVWF  x65
02DAA:  MOVLB  0
02DAC:  CALL   1E42
02DB0:  MOVFF  13A,264
02DB4:  MOVLW  37
02DB6:  MOVLB  2
02DB8:  MOVWF  x65
02DBA:  MOVLB  0
02DBC:  CALL   1E42
02DC0:  MOVFF  139,264
02DC4:  MOVLW  37
02DC6:  MOVLB  2
02DC8:  MOVWF  x65
02DCA:  MOVLB  0
02DCC:  CALL   1E42
02DD0:  MOVLW  0D
02DD2:  MOVLB  A
02DD4:  MOVWF  xAD
02DD6:  MOVLB  0
02DD8:  CALL   1B6C
02DDC:  MOVLW  0A
02DDE:  MOVLB  A
02DE0:  MOVWF  xAD
02DE2:  MOVLB  0
02DE4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter1 : 0x%02X\r\n", iv_header.reserve_counter1);
02DE8:  MOVLW  1E
02DEA:  MOVWF  FF6
02DEC:  MOVLW  0F
02DEE:  MOVWF  FF7
02DF0:  MOVLW  00
02DF2:  MOVWF  FF8
02DF4:  MOVLW  2B
02DF6:  MOVLB  9
02DF8:  MOVWF  xC2
02DFA:  MOVLB  0
02DFC:  CALL   1BEE
02E00:  MOVFF  13D,264
02E04:  MOVLW  37
02E06:  MOVLB  2
02E08:  MOVWF  x65
02E0A:  MOVLB  0
02E0C:  CALL   1E42
02E10:  MOVLW  0D
02E12:  MOVLB  A
02E14:  MOVWF  xAD
02E16:  MOVLB  0
02E18:  CALL   1B6C
02E1C:  MOVLW  0A
02E1E:  MOVLB  A
02E20:  MOVWF  xAD
02E22:  MOVLB  0
02E24:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter2 : 0x%02X\r\n", iv_header.reserve_counter2);
02E28:  MOVLW  50
02E2A:  MOVWF  FF6
02E2C:  MOVLW  0F
02E2E:  MOVWF  FF7
02E30:  MOVLW  00
02E32:  MOVWF  FF8
02E34:  MOVLW  2B
02E36:  MOVLB  9
02E38:  MOVWF  xC2
02E3A:  MOVLB  0
02E3C:  CALL   1BEE
02E40:  MOVFF  13E,264
02E44:  MOVLW  37
02E46:  MOVLB  2
02E48:  MOVWF  x65
02E4A:  MOVLB  0
02E4C:  CALL   1E42
02E50:  MOVLW  0D
02E52:  MOVLB  A
02E54:  MOVWF  xAD
02E56:  MOVLB  0
02E58:  CALL   1B6C
02E5C:  MOVLW  0A
02E5E:  MOVLB  A
02E60:  MOVWF  xAD
02E62:  MOVLB  0
02E64:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Use Counter      : 0x%08LX\r\n", iv_data.used_counter);
02E68:  MOVLW  82
02E6A:  MOVWF  FF6
02E6C:  MOVLW  0F
02E6E:  MOVWF  FF7
02E70:  MOVLW  00
02E72:  MOVWF  FF8
02E74:  MOVLW  2B
02E76:  MOVLB  9
02E78:  MOVWF  xC2
02E7A:  MOVLB  0
02E7C:  CALL   1BEE
02E80:  MOVFF  143,264
02E84:  MOVLW  37
02E86:  MOVLB  2
02E88:  MOVWF  x65
02E8A:  MOVLB  0
02E8C:  CALL   1E42
02E90:  MOVFF  142,264
02E94:  MOVLW  37
02E96:  MOVLB  2
02E98:  MOVWF  x65
02E9A:  MOVLB  0
02E9C:  CALL   1E42
02EA0:  MOVFF  141,264
02EA4:  MOVLW  37
02EA6:  MOVLB  2
02EA8:  MOVWF  x65
02EAA:  MOVLB  0
02EAC:  CALL   1E42
02EB0:  MOVFF  140,264
02EB4:  MOVLW  37
02EB6:  MOVLB  2
02EB8:  MOVWF  x65
02EBA:  MOVLB  0
02EBC:  CALL   1E42
02EC0:  MOVLW  0D
02EC2:  MOVLB  A
02EC4:  MOVWF  xAD
02EC6:  MOVLB  0
02EC8:  CALL   1B6C
02ECC:  MOVLW  0A
02ECE:  MOVLB  A
02ED0:  MOVWF  xAD
02ED2:  MOVLB  0
02ED4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Uncopyed Counter : 0x%08LX\r\n", iv_data.uncopied_counter);
02ED8:  MOVLW  B6
02EDA:  MOVWF  FF6
02EDC:  MOVLW  0F
02EDE:  MOVWF  FF7
02EE0:  MOVLW  00
02EE2:  MOVWF  FF8
02EE4:  MOVLW  2B
02EE6:  MOVLB  9
02EE8:  MOVWF  xC2
02EEA:  MOVLB  0
02EEC:  CALL   1BEE
02EF0:  MOVFF  147,264
02EF4:  MOVLW  37
02EF6:  MOVLB  2
02EF8:  MOVWF  x65
02EFA:  MOVLB  0
02EFC:  CALL   1E42
02F00:  MOVFF  146,264
02F04:  MOVLW  37
02F06:  MOVLB  2
02F08:  MOVWF  x65
02F0A:  MOVLB  0
02F0C:  CALL   1E42
02F10:  MOVFF  145,264
02F14:  MOVLW  37
02F16:  MOVLB  2
02F18:  MOVWF  x65
02F1A:  MOVLB  0
02F1C:  CALL   1E42
02F20:  MOVFF  144,264
02F24:  MOVLW  37
02F26:  MOVLB  2
02F28:  MOVWF  x65
02F2A:  MOVLB  0
02F2C:  CALL   1E42
02F30:  MOVLW  0D
02F32:  MOVLB  A
02F34:  MOVWF  xAD
02F36:  MOVLB  0
02F38:  CALL   1B6C
02F3C:  MOVLW  0A
02F3E:  MOVLB  A
02F40:  MOVWF  xAD
02F42:  MOVLB  0
02F44:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter1 : 0x%02X\r\n", iv_data.reserve_counter1);
02F48:  MOVLW  EA
02F4A:  MOVWF  FF6
02F4C:  MOVLW  0F
02F4E:  MOVWF  FF7
02F50:  MOVLW  00
02F52:  MOVWF  FF8
02F54:  MOVLW  2B
02F56:  MOVLB  9
02F58:  MOVWF  xC2
02F5A:  MOVLB  0
02F5C:  CALL   1BEE
02F60:  MOVFF  148,264
02F64:  MOVLW  37
02F66:  MOVLB  2
02F68:  MOVWF  x65
02F6A:  MOVLB  0
02F6C:  CALL   1E42
02F70:  MOVLW  0D
02F72:  MOVLB  A
02F74:  MOVWF  xAD
02F76:  MOVLB  0
02F78:  CALL   1B6C
02F7C:  MOVLW  0A
02F7E:  MOVLB  A
02F80:  MOVWF  xAD
02F82:  MOVLB  0
02F84:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter2 : 0x%02X\r\n", iv_data.reserve_counter2);
02F88:  MOVLW  1C
02F8A:  MOVWF  FF6
02F8C:  MOVLW  10
02F8E:  MOVWF  FF7
02F90:  MOVLW  00
02F92:  MOVWF  FF8
02F94:  MOVLW  2B
02F96:  MOVLB  9
02F98:  MOVWF  xC2
02F9A:  MOVLB  0
02F9C:  CALL   1BEE
02FA0:  MOVFF  149,264
02FA4:  MOVLW  37
02FA6:  MOVLB  2
02FA8:  MOVWF  x65
02FAA:  MOVLB  0
02FAC:  CALL   1E42
02FB0:  MOVLW  0D
02FB2:  MOVLB  A
02FB4:  MOVWF  xAD
02FB6:  MOVLB  0
02FB8:  CALL   1B6C
02FBC:  MOVLW  0A
02FBE:  MOVLB  A
02FC0:  MOVWF  xAD
02FC2:  MOVLB  0
02FC4:  CALL   1B6C
....................     fprintf(PC, "\tComplete\r\n");
02FC8:  MOVLW  4E
02FCA:  MOVWF  FF6
02FCC:  MOVLW  10
02FCE:  MOVWF  FF7
02FD0:  MOVLW  00
02FD2:  MOVWF  FF8
02FD4:  CALL   1BBE
02FD8:  GOTO   31B6 (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
09498:  MOVLB  2
0949A:  CLRF   x68
0949C:  CLRF   x69
0949E:  CLRF   x6A
094A0:  CLRF   x6B
094A2:  CLRF   x6C
094A4:  CLRF   x6D
094A6:  CLRF   x6E
094A8:  CLRF   x6F
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
094AA:  MOVF   x67,F
094AC:  BTFSC  FD8.2
094AE:  BRA    94B6
094B0:  MOVLB  0
094B2:  GOTO   94D2
094B6:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
094B8:  MOVLB  2
094BA:  CLRF   x6B
094BC:  CLRF   x6A
094BE:  CLRF   x69
094C0:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
094C2:  CLRF   x6F
094C4:  CLRF   x6E
094C6:  MOVLW  0F
094C8:  MOVWF  x6D
094CA:  SETF   x6C
094CC:  MOVLB  0
....................    }
094CE:  GOTO   9594
....................    else if (mission_id == CIGS_PICLOG_DATA)
094D2:  MOVLB  2
094D4:  DECFSZ x67,W
094D6:  BRA    94DC
094D8:  BRA    94E2
094DA:  MOVLB  0
094DC:  MOVLB  0
094DE:  GOTO   9502
094E2:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
094E4:  MOVLB  2
094E6:  CLRF   x6B
094E8:  MOVLW  01
094EA:  MOVWF  x6A
094EC:  CLRF   x69
094EE:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
094F0:  CLRF   x6F
094F2:  MOVLW  14
094F4:  MOVWF  x6E
094F6:  MOVLW  0F
094F8:  MOVWF  x6D
094FA:  SETF   x6C
094FC:  MOVLB  0
....................    }
094FE:  GOTO   9594
....................    else if (mission_id == CIGS_ENVIRO_DATA)
09502:  MOVLB  2
09504:  MOVF   x67,W
09506:  SUBLW  02
09508:  BTFSC  FD8.2
0950A:  BRA    9512
0950C:  MOVLB  0
0950E:  GOTO   9534
09512:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
09514:  MOVLB  2
09516:  CLRF   x6B
09518:  MOVLW  28
0951A:  MOVWF  x6A
0951C:  MOVLW  10
0951E:  MOVWF  x69
09520:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
09522:  CLRF   x6F
09524:  MOVLW  32
09526:  MOVWF  x6E
09528:  MOVLW  0F
0952A:  MOVWF  x6D
0952C:  SETF   x6C
0952E:  MOVLB  0
....................    }
09530:  GOTO   9594
....................    else if (mission_id == CIGS_IV_HEADER)
09534:  MOVLB  2
09536:  MOVF   x67,W
09538:  SUBLW  03
0953A:  BTFSC  FD8.2
0953C:  BRA    9544
0953E:  MOVLB  0
09540:  GOTO   9566
09544:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
09546:  MOVLB  2
09548:  CLRF   x6B
0954A:  MOVLW  72
0954C:  MOVWF  x6A
0954E:  MOVLW  10
09550:  MOVWF  x69
09552:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
09554:  CLRF   x6F
09556:  MOVLW  7C
09558:  MOVWF  x6E
0955A:  MOVLW  0F
0955C:  MOVWF  x6D
0955E:  SETF   x6C
09560:  MOVLB  0
....................    }
09562:  GOTO   9594
....................    else if (mission_id == CIGS_IV_DATA)
09566:  MOVLB  2
09568:  MOVF   x67,W
0956A:  SUBLW  04
0956C:  BTFSC  FD8.2
0956E:  BRA    9576
09570:  MOVLB  0
09572:  GOTO   9594
09576:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
09578:  MOVLB  2
0957A:  CLRF   x6B
0957C:  MOVLW  7C
0957E:  MOVWF  x6A
09580:  MOVLW  10
09582:  MOVWF  x69
09584:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
09586:  CLRF   x6F
09588:  MOVLW  BC
0958A:  MOVWF  x6E
0958C:  MOVLW  0F
0958E:  MOVWF  x6D
09590:  SETF   x6C
09592:  MOVLB  0
....................    }
....................    return mis_struct;
09594:  MOVLW  68
09596:  MOVWF  01
09598:  MOVLW  02
0959A:  MOVWF  02
0959C:  GOTO   9A72 (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv_header.used_counter - iv_header.uncopied_counter;
....................         mis_write_struct.size = iv_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter - iv_data.uncopied_counter;
....................         mis_write_struct.size = iv_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... // End of file
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "../application/mission/mmj_cigs_excute_mission.c"
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
08E42:  MOVLB  1
08E44:  MOVF   x8A,W
08E46:  MOVWF  FE9
08E48:  MOVF   x8B,W
08E4A:  MOVWF  FEA
08E4C:  MOVFF  FEF,18C
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
08E50:  MOVLW  B6
08E52:  MOVWF  FF6
08E54:  MOVLW  10
08E56:  MOVWF  FF7
08E58:  MOVLW  00
08E5A:  MOVWF  FF8
08E5C:  MOVLB  0
08E5E:  CALL   1BBE
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
08E62:  MOVLW  FC
08E64:  MOVWF  FF6
08E66:  MOVLW  10
08E68:  MOVWF  FF7
08E6A:  MOVLW  00
08E6C:  MOVWF  FF8
08E6E:  MOVLW  0C
08E70:  MOVLB  9
08E72:  MOVWF  xC2
08E74:  MOVLB  0
08E76:  CALL   1BEE
08E7A:  MOVFF  18C,264
08E7E:  MOVLW  37
08E80:  MOVLB  2
08E82:  MOVWF  x65
08E84:  MOVLB  0
08E86:  CALL   1E42
08E8A:  MOVLW  0A
08E8C:  MOVWF  FF6
08E8E:  MOVLW  11
08E90:  MOVWF  FF7
08E92:  MOVLW  00
08E94:  MOVWF  FF8
08E96:  MOVLW  04
08E98:  MOVLB  9
08E9A:  MOVWF  xC2
08E9C:  MOVLB  0
08E9E:  CALL   1BEE
....................    switch(command_id)
08EA2:  MOVLB  1
08EA4:  MOVF   x8C,W
08EA6:  XORLW  10
08EA8:  MOVLB  0
08EAA:  BTFSC  FD8.2
08EAC:  GOTO   8F5C
08EB0:  XORLW  01
08EB2:  BTFSC  FD8.2
08EB4:  GOTO   8F60
08EB8:  XORLW  03
08EBA:  BTFSC  FD8.2
08EBC:  GOTO   8F64
08EC0:  XORLW  13
08EC2:  BTFSC  FD8.2
08EC4:  GOTO   8F68
08EC8:  XORLW  12
08ECA:  BTFSC  FD8.2
08ECC:  GOTO   8F6C
08ED0:  XORLW  93
08ED2:  BTFSC  FD8.2
08ED4:  GOTO   8F70
08ED8:  XORLW  01
08EDA:  BTFSC  FD8.2
08EDC:  GOTO   8F80
08EE0:  XORLW  03
08EE2:  BTFSC  FD8.2
08EE4:  GOTO   8F90
08EE8:  XORLW  01
08EEA:  BTFSC  FD8.2
08EEC:  GOTO   8FA0
08EF0:  XORLW  07
08EF2:  BTFSC  FD8.2
08EF4:  GOTO   8FB0
08EF8:  XORLW  01
08EFA:  BTFSC  FD8.2
08EFC:  GOTO   8FC0
08F00:  XORLW  03
08F02:  BTFSC  FD8.2
08F04:  GOTO   8FD0
08F08:  XORLW  01
08F0A:  BTFSC  FD8.2
08F0C:  GOTO   8FE0
08F10:  XORLW  0F
08F12:  BTFSC  FD8.2
08F14:  GOTO   8FF0
08F18:  XORLW  18
08F1A:  BTFSC  FD8.2
08F1C:  GOTO   9000
08F20:  XORLW  01
08F22:  BTFSC  FD8.2
08F24:  GOTO   9010
08F28:  XORLW  03
08F2A:  BTFSC  FD8.2
08F2C:  GOTO   9020
08F30:  XORLW  01
08F32:  BTFSC  FD8.2
08F34:  GOTO   9030
08F38:  XORLW  07
08F3A:  BTFSC  FD8.2
08F3C:  GOTO   9040
08F40:  XORLW  01
08F42:  BTFSC  FD8.2
08F44:  GOTO   9050
08F48:  XORLW  03
08F4A:  BTFSC  FD8.2
08F4C:  GOTO   9060
08F50:  XORLW  36
08F52:  BTFSC  FD8.2
08F54:  GOTO   9070
08F58:  GOTO   9080
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
08F5C:  GOTO   9090
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
08F60:  GOTO   9090
....................       case 0x12:
....................          // test_adc();
....................          break;
08F64:  GOTO   9090
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
08F68:  GOTO   9090
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
08F6C:  GOTO   9090
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
08F70:  MOVFF  18B,190
08F74:  MOVFF  18A,18F
08F78:  CALL   47D8
....................          break;
08F7C:  GOTO   9090
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
08F80:  MOVFF  18B,18E
08F84:  MOVFF  18A,18D
08F88:  GOTO   48B4
....................          break;
08F8C:  GOTO   9090
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
08F90:  MOVFF  18B,18E
08F94:  MOVFF  18A,18D
08F98:  GOTO   4DA6
....................          break;
08F9C:  GOTO   9090
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
08FA0:  MOVFF  18B,18E
08FA4:  MOVFF  18A,18D
08FA8:  GOTO   4F38
....................          break;
08FAC:  GOTO   9090
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
08FB0:  MOVFF  18B,18E
08FB4:  MOVFF  18A,18D
08FB8:  GOTO   50AA
....................          break;
08FBC:  GOTO   9090
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
08FC0:  MOVFF  18B,18E
08FC4:  MOVFF  18A,18D
08FC8:  GOTO   54A4
....................          break;
08FCC:  GOTO   9090
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
08FD0:  MOVFF  18B,18E
08FD4:  MOVFF  18A,18D
08FD8:  GOTO   5518
....................          break;
08FDC:  GOTO   9090
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
08FE0:  MOVFF  18B,18E
08FE4:  MOVFF  18A,18D
08FE8:  GOTO   599C
....................          break;
08FEC:  GOTO   9090
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
08FF0:  MOVFF  18B,18E
08FF4:  MOVFF  18A,18D
08FF8:  GOTO   5C94
....................          break;
08FFC:  GOTO   9090
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
09000:  MOVFF  18B,18E
09004:  MOVFF  18A,18D
09008:  GOTO   5CEA
....................          break;
0900C:  GOTO   9090
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
09010:  MOVFF  18B,18E
09014:  MOVFF  18A,18D
09018:  GOTO   5DC6
....................          break;
0901C:  GOTO   9090
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
09020:  MOVFF  18B,18E
09024:  MOVFF  18A,18D
09028:  GOTO   5E82
....................          break;
0902C:  GOTO   9090
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
09030:  MOVFF  18B,18E
09034:  MOVFF  18A,18D
09038:  CALL   5FB8
....................          break;
0903C:  GOTO   9090
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
09040:  MOVFF  18B,18E
09044:  MOVFF  18A,18D
09048:  GOTO   6130
....................          break;
0904C:  GOTO   9090
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
09050:  MOVFF  18B,18E
09054:  MOVFF  18A,18D
09058:  GOTO   6512
....................          break;
0905C:  GOTO   9090
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
09060:  MOVFF  18B,18E
09064:  MOVFF  18A,18D
09068:  CALL   5FB8
....................          break;
0906C:  GOTO   9090
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
09070:  MOVFF  18B,18E
09074:  MOVFF  18A,18D
09078:  GOTO   889A
....................          break;
0907C:  GOTO   9090
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
09080:  MOVLW  10
09082:  MOVWF  FF6
09084:  MOVLW  11
09086:  MOVWF  FF7
09088:  MOVLW  00
0908A:  MOVWF  FF8
0908C:  CALL   1BBE
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
09090:  MOVLW  28
09092:  MOVWF  FF6
09094:  MOVLW  11
09096:  MOVWF  FF7
09098:  MOVLW  00
0909A:  MOVWF  FF8
0909C:  CALL   1BBE
090A0:  GOTO   910E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0B0B8:  MOVLW  6E
0B0BA:  MOVWF  FF6
0B0BC:  MOVLW  11
0B0BE:  MOVWF  FF7
0B0C0:  MOVLW  00
0B0C2:  MOVWF  FF8
0B0C4:  CALL   1BBE
....................    
....................    switch(command->frame_id)
0B0C8:  MOVLB  1
0B0CA:  MOVF   x84,W
0B0CC:  MOVWF  FE9
0B0CE:  MOVF   x85,W
0B0D0:  MOVWF  FEA
0B0D2:  MOVF   FEF,W
0B0D4:  XORLW  00
0B0D6:  MOVLB  0
0B0D8:  BTFSC  FD8.2
0B0DA:  GOTO   B0F2
0B0DE:  XORLW  01
0B0E0:  BTFSC  FD8.2
0B0E2:  GOTO   B102
0B0E6:  XORLW  03
0B0E8:  BTFSC  FD8.2
0B0EA:  GOTO   B122
0B0EE:  GOTO   B132
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0B0F2:  MOVFF  185,187
0B0F6:  MOVFF  184,186
0B0FA:  GOTO   90C2
....................          break;
0B0FE:  GOTO   B132
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0B102:  MOVFF  185,187
0B106:  MOVFF  184,186
0B10A:  GOTO   9144
0B10E:  MOVF   01,F
0B110:  BTFSC  FD8.2
0B112:  GOTO   B11E
....................             return TRUE; // if status is finished, return TRUE
0B116:  MOVLW  01
0B118:  MOVWF  01
0B11A:  GOTO   B136
....................          }        
....................          break;
0B11E:  GOTO   B132
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0B122:  MOVFF  185,187
0B126:  MOVFF  184,186
0B12A:  GOTO   ADC8
....................          break;
0B12E:  GOTO   B132
....................    }
....................    return FALSE;
0B132:  MOVLW  00
0B134:  MOVWF  01
0B136:  GOTO   B5FA (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
090C2:  MOVLW  86
090C4:  MOVWF  FF6
090C6:  MOVLW  11
090C8:  MOVWF  FF7
090CA:  MOVLW  00
090CC:  MOVWF  FF8
090CE:  CALL   1BBE
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
090D2:  MOVLW  9C
090D4:  MOVWF  FF6
090D6:  MOVLW  11
090D8:  MOVWF  FF7
090DA:  MOVLW  00
090DC:  MOVWF  FF8
090DE:  CALL   1BBE
....................    transmit_ack();
090E2:  CALL   47C4
.................... 
....................    status[0] = EXECUTING_MISSION;
090E6:  MOVLW  02
090E8:  MOVWF  48
....................    execute_mission(command->content);
090EA:  MOVLW  03
090EC:  MOVLB  1
090EE:  ADDWF  x86,W
090F0:  MOVWF  01
090F2:  MOVLW  00
090F4:  ADDWFC x87,W
090F6:  MOVWF  03
090F8:  MOVF   01,W
090FA:  MOVWF  x88
090FC:  MOVFF  03,189
09100:  MOVFF  189,18B
09104:  MOVFF  188,18A
09108:  MOVLB  0
0910A:  GOTO   8E42
....................    if (is_empty_flash_queue())
0910E:  CALL   90A4
09112:  MOVF   01,F
09114:  BTFSC  FD8.2
09116:  GOTO   9122
....................       status[0] = FINISHED;
0911A:  MOVLW  06
0911C:  MOVWF  48
0911E:  GOTO   9126
....................    else
....................       status[0] = SMF_USE_REQ;
09122:  MOVLW  04
09124:  MOVWF  48
09126:  GOTO   B0FE (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
09144:  MOVLW  B6
09146:  MOVWF  FF6
09148:  MOVLW  11
0914A:  MOVWF  FF7
0914C:  MOVLW  00
0914E:  MOVWF  FF8
09150:  CALL   1BBE
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
09154:  MOVLW  CA
09156:  MOVWF  FF6
09158:  MOVLW  11
0915A:  MOVWF  FF7
0915C:  MOVLW  00
0915E:  MOVWF  FF8
09160:  CALL   1BBE
....................    transmit_status();
09164:  GOTO   912A
....................    if (status[0] == FINISHED)
09168:  MOVF   48,W
0916A:  SUBLW  06
0916C:  BTFSS  FD8.2
0916E:  GOTO   918E
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
09172:  MOVLW  E8
09174:  MOVWF  FF6
09176:  MOVLW  11
09178:  MOVWF  FF7
0917A:  MOVLW  00
0917C:  MOVWF  FF8
0917E:  CALL   1BBE
....................       return TRUE;
09182:  MOVLW  01
09184:  MOVWF  01
09186:  GOTO   9196
....................    }
0918A:  GOTO   9196
....................    else{
....................       return FALSE;
0918E:  MOVLW  00
09190:  MOVWF  01
09192:  GOTO   9196
....................    }
09196:  GOTO   B10E (RETURN)
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command)
.................... {
....................     fprintf(PC, "\t-> SMF available check\r\n");
*
0ADC8:  MOVLW  04
0ADCA:  MOVWF  FF6
0ADCC:  MOVLW  12
0ADCE:  MOVWF  FF7
0ADD0:  MOVLW  00
0ADD2:  MOVWF  FF8
0ADD4:  CALL   1BBE
....................     fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0ADD8:  MOVLW  1E
0ADDA:  MOVWF  FF6
0ADDC:  MOVLW  12
0ADDE:  MOVWF  FF7
0ADE0:  MOVLW  00
0ADE2:  MOVWF  FF8
0ADE4:  CALL   1BBE
....................     transmit_ack();
0ADE8:  CALL   47C4
.................... 
....................     if (command->content[0] != ALLOW) {
0ADEC:  MOVLW  03
0ADEE:  MOVLB  1
0ADF0:  ADDWF  x86,W
0ADF2:  MOVWF  FE9
0ADF4:  MOVLW  00
0ADF6:  ADDWFC x87,W
0ADF8:  MOVWF  FEA
0ADFA:  DECFSZ FEF,W
0ADFC:  BRA    AE02
0ADFE:  BRA    AE08
0AE00:  MOVLB  0
0AE02:  MOVLB  0
0AE04:  GOTO   AE0E
0AE08:  MOVLB  0
0AE0A:  GOTO   AE22
....................         fprintf(PC, "\t\t-> denied\r\n");
0AE0E:  MOVLW  3E
0AE10:  MOVWF  FF6
0AE12:  MOVLW  12
0AE14:  MOVWF  FF7
0AE16:  MOVLW  00
0AE18:  MOVWF  FF8
0AE1A:  CALL   1BBE
....................         return;
0AE1E:  GOTO   B0B4
....................     }
.................... 
....................     fprintf(PC, "\t\t-> allowed\r\n");
0AE22:  MOVLW  4C
0AE24:  MOVWF  FF6
0AE26:  MOVLW  12
0AE28:  MOVWF  FF7
0AE2A:  MOVLW  00
0AE2C:  MOVWF  FF8
0AE2E:  CALL   1BBE
....................     status[0] = COPYING;
0AE32:  MOVLW  05
0AE34:  MOVWF  48
.................... 
....................     int8 processed_count = 0;
0AE36:  MOVLB  1
0AE38:  CLRF   x88
0AE3A:  MOVLB  0
.................... 
....................     while (!is_empty_flash_queue()) {
0AE3C:  CALL   90A4
0AE40:  MOVF   01,F
0AE42:  BTFSS  FD8.2
0AE44:  GOTO   B070
....................         FlashOperationStruct *smf_data = dequeue_flash_operation();
0AE48:  GOTO   919A
0AE4C:  MOVFF  02,18A
0AE50:  MOVFF  01,189
....................         if (smf_data == NULL) {
0AE54:  MOVLB  1
0AE56:  MOVF   x89,F
0AE58:  BTFSC  FD8.2
0AE5A:  BRA    AE62
0AE5C:  MOVLB  0
0AE5E:  GOTO   AE88
0AE62:  MOVLB  0
0AE64:  MOVLB  1
0AE66:  MOVF   x8A,F
0AE68:  BTFSC  FD8.2
0AE6A:  BRA    AE72
0AE6C:  MOVLB  0
0AE6E:  GOTO   AE88
0AE72:  MOVLB  0
....................             fprintf(PC, "\t\t-> dequeue NULL (break)\r\n");
0AE74:  MOVLW  5C
0AE76:  MOVWF  FF6
0AE78:  MOVLW  12
0AE7A:  MOVWF  FF7
0AE7C:  MOVLW  00
0AE7E:  MOVWF  FF8
0AE80:  CALL   1BBE
....................             break;
0AE84:  GOTO   B070
....................         }
.................... 
....................         fprintf(PC, "\t\t-> Dequeued: func=%u mission=%u size=%ld addr=%ld\r\n",
....................                 (unsigned int)smf_data->func_type,
....................                 (unsigned int)smf_data->mission_id,
....................                 smf_data->misf_size,
....................                 smf_data->misf_start_addr);
0AE88:  MOVLW  01
0AE8A:  MOVLB  1
0AE8C:  ADDWF  x89,W
0AE8E:  MOVWF  FE9
0AE90:  MOVLW  00
0AE92:  ADDWFC x8A,W
0AE94:  MOVWF  FEA
0AE96:  MOVFF  FEF,18B
0AE9A:  MOVF   x89,W
0AE9C:  MOVWF  FE9
0AE9E:  MOVF   x8A,W
0AEA0:  MOVWF  FEA
0AEA2:  MOVFF  FEF,18C
0AEA6:  MOVLW  08
0AEA8:  ADDWF  x89,W
0AEAA:  MOVWF  FE9
0AEAC:  MOVLW  00
0AEAE:  ADDWFC x8A,W
0AEB0:  MOVWF  FEA
0AEB2:  MOVFF  FEF,18D
0AEB6:  MOVFF  FEC,18E
0AEBA:  MOVFF  FEC,18F
0AEBE:  MOVFF  FEC,190
0AEC2:  MOVF   FED,F
0AEC4:  MOVF   FED,F
0AEC6:  MOVF   FED,F
0AEC8:  MOVLW  04
0AECA:  ADDWF  x89,W
0AECC:  MOVWF  FE9
0AECE:  MOVLW  00
0AED0:  ADDWFC x8A,W
0AED2:  MOVWF  FEA
0AED4:  MOVFF  FEF,191
0AED8:  MOVFF  FEC,192
0AEDC:  MOVFF  FEC,193
0AEE0:  MOVFF  FEC,194
0AEE4:  MOVF   FED,F
0AEE6:  MOVF   FED,F
0AEE8:  MOVF   FED,F
0AEEA:  MOVLW  78
0AEEC:  MOVWF  FF6
0AEEE:  MOVLW  12
0AEF0:  MOVWF  FF7
0AEF2:  MOVLW  00
0AEF4:  MOVWF  FF8
0AEF6:  MOVLW  14
0AEF8:  MOVLB  9
0AEFA:  MOVWF  xC2
0AEFC:  MOVLB  0
0AEFE:  CALL   1BEE
0AF02:  MOVFF  18B,264
0AF06:  MOVLW  1B
0AF08:  MOVLB  2
0AF0A:  MOVWF  x65
0AF0C:  MOVLB  0
0AF0E:  CALL   6752
0AF12:  MOVLW  8E
0AF14:  MOVWF  FF6
0AF16:  MOVLW  12
0AF18:  MOVWF  FF7
0AF1A:  MOVLW  00
0AF1C:  MOVWF  FF8
0AF1E:  MOVLW  09
0AF20:  MOVLB  9
0AF22:  MOVWF  xC2
0AF24:  MOVLB  0
0AF26:  CALL   1BEE
0AF2A:  MOVFF  18C,264
0AF2E:  MOVLW  1B
0AF30:  MOVLB  2
0AF32:  MOVWF  x65
0AF34:  MOVLB  0
0AF36:  CALL   6752
0AF3A:  MOVLW  99
0AF3C:  MOVWF  FF6
0AF3E:  MOVLW  12
0AF40:  MOVWF  FF7
0AF42:  MOVLW  00
0AF44:  MOVWF  FF8
0AF46:  MOVLW  06
0AF48:  MOVLB  9
0AF4A:  MOVWF  xC2
0AF4C:  MOVLB  0
0AF4E:  CALL   1BEE
0AF52:  MOVLW  41
0AF54:  MOVWF  FE9
0AF56:  MOVFF  190,263
0AF5A:  MOVFF  18F,262
0AF5E:  MOVFF  18E,261
0AF62:  MOVFF  18D,260
0AF66:  CALL   91FC
0AF6A:  MOVLW  A2
0AF6C:  MOVWF  FF6
0AF6E:  MOVLW  12
0AF70:  MOVWF  FF7
0AF72:  MOVLW  00
0AF74:  MOVWF  FF8
0AF76:  MOVLW  06
0AF78:  MOVLB  9
0AF7A:  MOVWF  xC2
0AF7C:  MOVLB  0
0AF7E:  CALL   1BEE
0AF82:  MOVLW  41
0AF84:  MOVWF  FE9
0AF86:  MOVFF  194,263
0AF8A:  MOVFF  193,262
0AF8E:  MOVFF  192,261
0AF92:  MOVFF  191,260
0AF96:  CALL   91FC
0AF9A:  MOVLW  0D
0AF9C:  MOVLB  A
0AF9E:  MOVWF  xAD
0AFA0:  MOVLB  0
0AFA2:  CALL   1B6C
0AFA6:  MOVLW  0A
0AFA8:  MOVLB  A
0AFAA:  MOVWF  xAD
0AFAC:  MOVLB  0
0AFAE:  CALL   1B6C
.................... 
....................         switch (smf_data->func_type) {
0AFB2:  MOVLW  01
0AFB4:  MOVLB  1
0AFB6:  ADDWF  x89,W
0AFB8:  MOVWF  FE9
0AFBA:  MOVLW  00
0AFBC:  ADDWFC x8A,W
0AFBE:  MOVWF  FEA
0AFC0:  MOVF   FEF,W
0AFC2:  XORLW  00
0AFC4:  MOVLB  0
0AFC6:  BTFSC  FD8.2
0AFC8:  GOTO   AFE0
0AFCC:  XORLW  01
0AFCE:  BTFSC  FD8.2
0AFD0:  GOTO   AFF0
0AFD4:  XORLW  03
0AFD6:  BTFSC  FD8.2
0AFD8:  GOTO   B000
0AFDC:  GOTO   B010
....................             case ENUM_SMF_WRITE:
....................                 smf_write(smf_data);
0AFE0:  MOVFF  18A,18C
0AFE4:  MOVFF  189,18B
0AFE8:  GOTO   99BE
....................                 break;
0AFEC:  GOTO   B066
....................             case ENUM_SMF_READ:
....................                 smf_read(smf_data);
0AFF0:  MOVFF  18A,18C
0AFF4:  MOVFF  189,18B
0AFF8:  GOTO   A51A
....................                 break;
0AFFC:  GOTO   B066
....................             case ENUM_SMF_ERASE:
....................                 smf_erase(smf_data);
0B000:  MOVFF  18A,18C
0B004:  MOVFF  189,18B
0B008:  GOTO   A8AA
....................                 break;
0B00C:  GOTO   B066
....................             default:
....................                 fprintf(PC, "\t\t   Unknown func_type=%u\r\n",
....................                         (unsigned int)smf_data->func_type);
0B010:  MOVLW  01
0B012:  MOVLB  1
0B014:  ADDWF  x89,W
0B016:  MOVWF  FE9
0B018:  MOVLW  00
0B01A:  ADDWFC x8A,W
0B01C:  MOVWF  FEA
0B01E:  MOVFF  FEF,18B
0B022:  MOVLW  AE
0B024:  MOVWF  FF6
0B026:  MOVLW  12
0B028:  MOVWF  FF7
0B02A:  MOVLW  00
0B02C:  MOVWF  FF8
0B02E:  MOVLW  17
0B030:  MOVLB  9
0B032:  MOVWF  xC2
0B034:  MOVLB  0
0B036:  CALL   1BEE
0B03A:  MOVFF  18B,264
0B03E:  MOVLW  1B
0B040:  MOVLB  2
0B042:  MOVWF  x65
0B044:  MOVLB  0
0B046:  CALL   6752
0B04A:  MOVLW  0D
0B04C:  MOVLB  A
0B04E:  MOVWF  xAD
0B050:  MOVLB  0
0B052:  CALL   1B6C
0B056:  MOVLW  0A
0B058:  MOVLB  A
0B05A:  MOVWF  xAD
0B05C:  MOVLB  0
0B05E:  CALL   1B6C
....................                 break;
0B062:  GOTO   B066
....................         }
....................         processed_count++;
0B066:  MOVLB  1
0B068:  INCF   x88,F
0B06A:  MOVLB  0
0B06C:  GOTO   AE3C
....................     }
.................... 
....................     fprintf(PC, "\t\t-> Completed %u operations\r\n",
....................             (unsigned int)processed_count);
0B070:  MOVLW  CA
0B072:  MOVWF  FF6
0B074:  MOVLW  12
0B076:  MOVWF  FF7
0B078:  MOVLW  00
0B07A:  MOVWF  FF8
0B07C:  MOVLW  0F
0B07E:  MOVLB  9
0B080:  MOVWF  xC2
0B082:  MOVLB  0
0B084:  CALL   1BEE
0B088:  MOVFF  188,264
0B08C:  MOVLW  1B
0B08E:  MOVLB  2
0B090:  MOVWF  x65
0B092:  MOVLB  0
0B094:  CALL   6752
0B098:  MOVLW  DB
0B09A:  MOVWF  FF6
0B09C:  MOVLW  12
0B09E:  MOVWF  FF7
0B0A0:  MOVLW  00
0B0A2:  MOVWF  FF8
0B0A4:  MOVLW  0D
0B0A6:  MOVLB  9
0B0A8:  MOVWF  xC2
0B0AA:  MOVLB  0
0B0AC:  CALL   1BEE
.................... 
....................     status[0] = FINISHED;
0B0B0:  MOVLW  06
0B0B2:  MOVWF  48
0B0B4:  GOTO   B12E (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[])
.................... {
....................    unsigned int8 measurement_step = uplinkcmd[1]; // Get the measurement step from the parameter array
....................    fprintf(PC, "Start MODE TEST IV\r\n");
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(uplinkcmd); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
.................... //!   sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = ENUM_SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
0889A:  MOVLW  8E
0889C:  MOVWF  FF6
0889E:  MOVLW  13
088A0:  MOVWF  FF7
088A2:  MOVLW  00
088A4:  MOVWF  FF8
088A6:  CALL   1BBE
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
088AA:  MOVFF  18E,1B2
088AE:  MOVFF  18D,1B1
088B2:  GOTO   65FC
088B6:  MOVFF  02,03
088BA:  MOVF   01,W
088BC:  MOVWF  FE1
088BE:  MOVFF  03,FE2
088C2:  MOVLW  01
088C4:  MOVWF  FEA
088C6:  MOVLW  8F
088C8:  MOVWF  FE9
088CA:  MOVLW  0C
088CC:  MOVWF  01
088CE:  MOVFF  FE6,FEE
088D2:  DECFSZ 01,F
088D4:  GOTO   88CE
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
088D8:  MOVLW  A4
088DA:  MOVWF  FF6
088DC:  MOVLW  13
088DE:  MOVWF  FF7
088E0:  MOVLW  00
088E2:  MOVWF  FF8
088E4:  MOVLW  05
088E6:  MOVLB  9
088E8:  MOVWF  xC2
088EA:  MOVLB  0
088EC:  CALL   1BEE
088F0:  MOVFF  18F,264
088F4:  MOVLW  37
088F6:  MOVLB  2
088F8:  MOVWF  x65
088FA:  MOVLB  0
088FC:  CALL   1E42
08900:  MOVLW  0D
08902:  MOVLB  A
08904:  MOVWF  xAD
08906:  MOVLB  0
08908:  CALL   1B6C
0890C:  MOVLW  0A
0890E:  MOVLB  A
08910:  MOVWF  xAD
08912:  MOVLB  0
08914:  CALL   1B6C
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
08918:  MOVLW  B0
0891A:  MOVWF  FF6
0891C:  MOVLW  13
0891E:  MOVWF  FF7
08920:  MOVLW  00
08922:  MOVWF  FF8
08924:  MOVLW  0D
08926:  MOVLB  9
08928:  MOVWF  xC2
0892A:  MOVLB  0
0892C:  CALL   1BEE
08930:  MOVFF  191,264
08934:  MOVLW  37
08936:  MOVLB  2
08938:  MOVWF  x65
0893A:  MOVLB  0
0893C:  CALL   1E42
08940:  MOVFF  190,264
08944:  MOVLW  37
08946:  MOVLB  2
08948:  MOVWF  x65
0894A:  MOVLB  0
0894C:  CALL   1E42
08950:  MOVLW  C2
08952:  MOVWF  FF6
08954:  MOVLW  13
08956:  MOVWF  FF7
08958:  MOVLW  00
0895A:  MOVWF  FF8
0895C:  MOVLW  05
0895E:  MOVLB  9
08960:  MOVWF  xC2
08962:  MOVLB  0
08964:  CALL   1BEE
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
08968:  MOVLW  C8
0896A:  MOVWF  FF6
0896C:  MOVLW  13
0896E:  MOVWF  FF7
08970:  MOVLW  00
08972:  MOVWF  FF8
08974:  MOVLW  14
08976:  MOVLB  9
08978:  MOVWF  xC2
0897A:  MOVLB  0
0897C:  CALL   1BEE
08980:  MOVFF  193,264
08984:  MOVLW  37
08986:  MOVLB  2
08988:  MOVWF  x65
0898A:  MOVLB  0
0898C:  CALL   1E42
08990:  MOVFF  192,264
08994:  MOVLW  37
08996:  MOVLB  2
08998:  MOVWF  x65
0899A:  MOVLB  0
0899C:  CALL   1E42
089A0:  MOVLW  E1
089A2:  MOVWF  FF6
089A4:  MOVLW  13
089A6:  MOVWF  FF7
089A8:  MOVLW  00
089AA:  MOVWF  FF8
089AC:  MOVLW  05
089AE:  MOVLB  9
089B0:  MOVWF  xC2
089B2:  MOVLB  0
089B4:  CALL   1BEE
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
089B8:  MOVLW  E8
089BA:  MOVWF  FF6
089BC:  MOVLW  13
089BE:  MOVWF  FF7
089C0:  MOVLW  00
089C2:  MOVWF  FF8
089C4:  MOVLW  0F
089C6:  MOVLB  9
089C8:  MOVWF  xC2
089CA:  MOVLB  0
089CC:  CALL   1BEE
089D0:  MOVFF  195,264
089D4:  MOVLW  37
089D6:  MOVLB  2
089D8:  MOVWF  x65
089DA:  MOVLB  0
089DC:  CALL   1E42
089E0:  MOVFF  194,264
089E4:  MOVLW  37
089E6:  MOVLB  2
089E8:  MOVWF  x65
089EA:  MOVLB  0
089EC:  CALL   1E42
089F0:  MOVLW  FC
089F2:  MOVWF  FF6
089F4:  MOVLW  13
089F6:  MOVWF  FF7
089F8:  MOVLW  00
089FA:  MOVWF  FF8
089FC:  MOVLW  05
089FE:  MOVLB  9
08A00:  MOVWF  xC2
08A02:  MOVLB  0
08A04:  CALL   1BEE
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
08A08:  MOVLW  02
08A0A:  MOVWF  FF6
08A0C:  MOVLW  14
08A0E:  MOVWF  FF7
08A10:  MOVLW  00
08A12:  MOVWF  FF8
08A14:  MOVLW  10
08A16:  MOVLB  9
08A18:  MOVWF  xC2
08A1A:  MOVLB  0
08A1C:  CALL   1BEE
08A20:  MOVFF  197,264
08A24:  MOVLW  37
08A26:  MOVLB  2
08A28:  MOVWF  x65
08A2A:  MOVLB  0
08A2C:  CALL   1E42
08A30:  MOVFF  196,264
08A34:  MOVLW  37
08A36:  MOVLB  2
08A38:  MOVWF  x65
08A3A:  MOVLB  0
08A3C:  CALL   1E42
08A40:  MOVLW  17
08A42:  MOVWF  FF6
08A44:  MOVLW  14
08A46:  MOVWF  FF7
08A48:  MOVLW  00
08A4A:  MOVWF  FF8
08A4C:  MOVLW  05
08A4E:  MOVLB  9
08A50:  MOVWF  xC2
08A52:  MOVLB  0
08A54:  CALL   1BEE
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
08A58:  MOVLW  1E
08A5A:  MOVWF  FF6
08A5C:  MOVLW  14
08A5E:  MOVWF  FF7
08A60:  MOVLW  00
08A62:  MOVWF  FF8
08A64:  MOVLW  13
08A66:  MOVLB  9
08A68:  MOVWF  xC2
08A6A:  MOVLB  0
08A6C:  CALL   1BEE
08A70:  MOVFF  199,264
08A74:  MOVLW  37
08A76:  MOVLB  2
08A78:  MOVWF  x65
08A7A:  MOVLB  0
08A7C:  CALL   1E42
08A80:  MOVFF  198,264
08A84:  MOVLW  37
08A86:  MOVLB  2
08A88:  MOVWF  x65
08A8A:  MOVLB  0
08A8C:  CALL   1E42
08A90:  MOVLW  36
08A92:  MOVWF  FF6
08A94:  MOVLW  14
08A96:  MOVWF  FF7
08A98:  MOVLW  00
08A9A:  MOVWF  FF8
08A9C:  MOVLW  04
08A9E:  MOVLB  9
08AA0:  MOVWF  xC2
08AA2:  MOVLB  0
08AA4:  CALL   1BEE
....................    fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
08AA8:  MOVLW  3C
08AAA:  MOVWF  FF6
08AAC:  MOVLW  14
08AAE:  MOVWF  FF7
08AB0:  MOVLW  00
08AB2:  MOVWF  FF8
08AB4:  MOVLW  0E
08AB6:  MOVLB  9
08AB8:  MOVWF  xC2
08ABA:  MOVLB  0
08ABC:  CALL   1BEE
08AC0:  MOVFF  19A,264
08AC4:  MOVLW  1B
08AC6:  MOVLB  2
08AC8:  MOVWF  x65
08ACA:  MOVLB  0
08ACC:  CALL   6752
08AD0:  MOVLW  0D
08AD2:  MOVLB  A
08AD4:  MOVWF  xAD
08AD6:  MOVLB  0
08AD8:  CALL   1B6C
08ADC:  MOVLW  0A
08ADE:  MOVLB  A
08AE0:  MOVWF  xAD
08AE2:  MOVLB  0
08AE4:  CALL   1B6C
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
08AE8:  MOVFF  18F,1E0
08AEC:  MOVLB  1
08AEE:  CLRF   xE1
08AF0:  MOVLB  0
08AF2:  CALL   3F80
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
08AF6:  CALL   31B8
08AFA:  MOVFF  01,19C
08AFE:  MOVFF  00,19B
08B02:  MOVLB  1
08B04:  CLRF   x9E
08B06:  CLRF   x9D
08B08:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
08B0A:  CALL   31B8
08B0E:  MOVFF  03,1AE
08B12:  MOVFF  02,1AD
08B16:  MOVFF  01,1AC
08B1A:  MOVFF  00,1AB
08B1E:  MOVLB  1
08B20:  MOVF   x9B,W
08B22:  SUBWF  xAB,F
08B24:  MOVF   x9C,W
08B26:  SUBWFB xAC,F
08B28:  MOVLW  00
08B2A:  SUBWFB xAD,F
08B2C:  MOVLW  00
08B2E:  SUBWFB xAE,F
08B30:  MOVF   xAE,F
08B32:  BTFSC  FD8.2
08B34:  BRA    8B3C
08B36:  MOVLB  0
08B38:  GOTO   8C06
08B3C:  MOVLB  0
08B3E:  MOVLB  1
08B40:  MOVF   xAD,F
08B42:  BTFSC  FD8.2
08B44:  BRA    8B4C
08B46:  MOVLB  0
08B48:  GOTO   8C06
08B4C:  MOVLB  0
08B4E:  MOVLB  1
08B50:  MOVF   xAC,W
08B52:  SUBWF  x99,W
08B54:  BTFSC  FD8.0
08B56:  BRA    8B5E
08B58:  MOVLB  0
08B5A:  GOTO   8C06
08B5E:  MOVLB  0
08B60:  BTFSS  FD8.2
08B62:  GOTO   8B78
08B66:  MOVLB  1
08B68:  MOVF   x98,W
08B6A:  SUBWF  xAB,W
08B6C:  BTFSS  FD8.0
08B6E:  BRA    8B76
08B70:  MOVLB  0
08B72:  GOTO   8C06
08B76:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
08B78:  CALL   31B8
08B7C:  MOVFF  01,19E
08B80:  MOVFF  00,19D
....................       if (current_sec - start_time >= cmd.meas_time) {
08B84:  MOVLB  1
08B86:  MOVF   x9B,W
08B88:  SUBWF  x9D,W
08B8A:  MOVWF  xAB
08B8C:  MOVF   x9C,W
08B8E:  SUBWFB x9E,W
08B90:  MOVWF  xAC
08B92:  MOVF   x99,W
08B94:  SUBWF  xAC,W
08B96:  BTFSC  FD8.0
08B98:  BRA    8BA0
08B9A:  MOVLB  0
08B9C:  GOTO   8BBE
08BA0:  MOVLB  0
08BA2:  BTFSS  FD8.2
08BA4:  GOTO   8BBA
08BA8:  MOVLB  1
08BAA:  MOVF   x98,W
08BAC:  SUBWF  xAB,W
08BAE:  BTFSC  FD8.0
08BB0:  BRA    8BB8
08BB2:  MOVLB  0
08BB4:  GOTO   8BBE
08BB8:  MOVLB  0
....................           break;
08BBA:  GOTO   8C06
....................       }
....................       sweep_with_threshold(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
08BBE:  MOVFF  193,1AC
08BC2:  MOVFF  192,1AB
08BC6:  MOVFF  195,1AE
08BCA:  MOVFF  194,1AD
08BCE:  MOVFF  197,1B0
08BD2:  MOVFF  196,1AF
08BD6:  GOTO   7140
....................       // Sleep for the specified time
....................       delay_ms(cmd.sleep_time);
08BDA:  MOVFF  191,1AB
08BDE:  MOVLB  1
08BE0:  INCF   xAB,F
08BE2:  MOVLB  0
08BE4:  MOVLB  1
08BE6:  DECFSZ xAB,F
08BE8:  BRA    8BEE
08BEA:  MOVLB  0
08BEC:  BRA    8BFA
08BEE:  MOVLB  A
08BF0:  SETF   x6E
08BF2:  MOVLB  0
08BF4:  CALL   1B3E
08BF8:  BRA    8BE4
08BFA:  MOVFF  190,A6E
08BFE:  CALL   1B3E
08C02:  GOTO   8B0A
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
08C06:  MOVFF  18F,1E0
08C0A:  MOVLB  1
08C0C:  SETF   xE1
08C0E:  MOVLB  0
08C10:  CALL   3F80
.................... 
....................    FlashOperationStruct data = {0};
08C14:  MOVLB  1
08C16:  CLRF   x9F
08C18:  CLRF   xA0
08C1A:  CLRF   xA1
08C1C:  CLRF   xA2
08C1E:  CLRF   xA3
08C20:  CLRF   xA4
08C22:  CLRF   xA5
08C24:  CLRF   xA6
08C26:  CLRF   xA7
08C28:  CLRF   xA8
08C2A:  CLRF   xA9
08C2C:  CLRF   xAA
....................    data.func_type = ENUM_SMF_WRITE;
08C2E:  CLRF   xA0
....................    data.mission_id = CIGS_IV_DATA; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
08C30:  MOVLW  04
08C32:  MOVWF  x9F
....................    data.write_mode = SMF_WRITE_CIRCULAR;
08C34:  MOVLW  02
08C36:  MOVWF  xA1
....................    data.source_type = SOURCE_MISF_UNCOPIED;
08C38:  BCF    xA2.0
....................    // data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    // data.size = 0; // コピーするデータのサイズ
.................... 
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
08C3A:  MOVLW  50
08C3C:  MOVWF  FF6
08C3E:  MOVLW  14
08C40:  MOVWF  FF7
08C42:  MOVLW  00
08C44:  MOVWF  FF8
08C46:  MOVLB  0
08C48:  CALL   1BBE
....................    fprintf(PC, "Mission ID:   %02X\r\n", data.mission_id);
08C4C:  MOVLW  6A
08C4E:  MOVWF  FF6
08C50:  MOVLW  14
08C52:  MOVWF  FF7
08C54:  MOVLW  00
08C56:  MOVWF  FF8
08C58:  MOVLW  0E
08C5A:  MOVLB  9
08C5C:  MOVWF  xC2
08C5E:  MOVLB  0
08C60:  CALL   1BEE
08C64:  MOVFF  19F,264
08C68:  MOVLW  37
08C6A:  MOVLB  2
08C6C:  MOVWF  x65
08C6E:  MOVLB  0
08C70:  CALL   1E42
08C74:  MOVLW  0D
08C76:  MOVLB  A
08C78:  MOVWF  xAD
08C7A:  MOVLB  0
08C7C:  CALL   1B6C
08C80:  MOVLW  0A
08C82:  MOVLB  A
08C84:  MOVWF  xAD
08C86:  MOVLB  0
08C88:  CALL   1B6C
....................    fprintf(PC, "Function Type:%02X\r\n", data.func_type);
08C8C:  MOVLW  80
08C8E:  MOVWF  FF6
08C90:  MOVLW  14
08C92:  MOVWF  FF7
08C94:  MOVLW  00
08C96:  MOVWF  FF8
08C98:  MOVLW  0E
08C9A:  MOVLB  9
08C9C:  MOVWF  xC2
08C9E:  MOVLB  0
08CA0:  CALL   1BEE
08CA4:  MOVFF  1A0,264
08CA8:  MOVLW  37
08CAA:  MOVLB  2
08CAC:  MOVWF  x65
08CAE:  MOVLB  0
08CB0:  CALL   1E42
08CB4:  MOVLW  0D
08CB6:  MOVLB  A
08CB8:  MOVWF  xAD
08CBA:  MOVLB  0
08CBC:  CALL   1B6C
08CC0:  MOVLW  0A
08CC2:  MOVLB  A
08CC4:  MOVWF  xAD
08CC6:  MOVLB  0
08CC8:  CALL   1B6C
....................    fprintf(PC, "Write Mode:   %02X\r\n", data.write_mode);
08CCC:  MOVLW  96
08CCE:  MOVWF  FF6
08CD0:  MOVLW  14
08CD2:  MOVWF  FF7
08CD4:  MOVLW  00
08CD6:  MOVWF  FF8
08CD8:  MOVLW  0E
08CDA:  MOVLB  9
08CDC:  MOVWF  xC2
08CDE:  MOVLB  0
08CE0:  CALL   1BEE
08CE4:  MOVFF  1A1,264
08CE8:  MOVLW  37
08CEA:  MOVLB  2
08CEC:  MOVWF  x65
08CEE:  MOVLB  0
08CF0:  CALL   1E42
08CF4:  MOVLW  0D
08CF6:  MOVLB  A
08CF8:  MOVWF  xAD
08CFA:  MOVLB  0
08CFC:  CALL   1B6C
08D00:  MOVLW  0A
08D02:  MOVLB  A
08D04:  MOVWF  xAD
08D06:  MOVLB  0
08D08:  CALL   1B6C
....................    fprintf(PC, "Source Type:  %02X\r\n", data.source_type);
08D0C:  MOVLW  00
08D0E:  MOVLB  1
08D10:  BTFSC  xA2.0
08D12:  MOVLW  01
08D14:  MOVWF  xAB
08D16:  MOVLW  AC
08D18:  MOVWF  FF6
08D1A:  MOVLW  14
08D1C:  MOVWF  FF7
08D1E:  MOVLW  00
08D20:  MOVWF  FF8
08D22:  MOVLW  0E
08D24:  MOVLB  9
08D26:  MOVWF  xC2
08D28:  MOVLB  0
08D2A:  CALL   1BEE
08D2E:  MOVFF  1AB,264
08D32:  MOVLW  37
08D34:  MOVLB  2
08D36:  MOVWF  x65
08D38:  MOVLB  0
08D3A:  CALL   1E42
08D3E:  MOVLW  0D
08D40:  MOVLB  A
08D42:  MOVWF  xAD
08D44:  MOVLB  0
08D46:  CALL   1B6C
08D4A:  MOVLW  0A
08D4C:  MOVLB  A
08D4E:  MOVWF  xAD
08D50:  MOVLB  0
08D52:  CALL   1B6C
....................    fprintf(PC, "Start Address:%04X\r\n", data.misf_start_addr);
08D56:  MOVLW  C2
08D58:  MOVWF  FF6
08D5A:  MOVLW  14
08D5C:  MOVWF  FF7
08D5E:  MOVLW  00
08D60:  MOVWF  FF8
08D62:  MOVLW  0E
08D64:  MOVLB  9
08D66:  MOVWF  xC2
08D68:  MOVLB  0
08D6A:  CALL   1BEE
08D6E:  MOVLW  02
08D70:  MOVLB  1
08D72:  MOVWF  xAB
08D74:  MOVLB  0
08D76:  MOVLW  30
08D78:  MOVLB  A
08D7A:  MOVWF  xAD
08D7C:  MOVLB  0
08D7E:  CALL   1B6C
08D82:  MOVLB  1
08D84:  DECFSZ xAB,F
08D86:  BRA    8D8C
08D88:  BRA    8D92
08D8A:  MOVLB  0
08D8C:  MOVLB  0
08D8E:  GOTO   8D76
08D92:  MOVFF  1A3,264
08D96:  MOVLW  37
08D98:  MOVLB  2
08D9A:  MOVWF  x65
08D9C:  MOVLB  0
08D9E:  CALL   1E42
08DA2:  MOVLW  0D
08DA4:  MOVLB  A
08DA6:  MOVWF  xAD
08DA8:  MOVLB  0
08DAA:  CALL   1B6C
08DAE:  MOVLW  0A
08DB0:  MOVLB  A
08DB2:  MOVWF  xAD
08DB4:  MOVLB  0
08DB6:  CALL   1B6C
....................    fprintf(PC, "Size:         %04X\r\n", data.misf_size);
08DBA:  MOVLW  D8
08DBC:  MOVWF  FF6
08DBE:  MOVLW  14
08DC0:  MOVWF  FF7
08DC2:  MOVLW  00
08DC4:  MOVWF  FF8
08DC6:  MOVLW  0E
08DC8:  MOVLB  9
08DCA:  MOVWF  xC2
08DCC:  MOVLB  0
08DCE:  CALL   1BEE
08DD2:  MOVLW  02
08DD4:  MOVLB  1
08DD6:  MOVWF  xAB
08DD8:  MOVLB  0
08DDA:  MOVLW  30
08DDC:  MOVLB  A
08DDE:  MOVWF  xAD
08DE0:  MOVLB  0
08DE2:  CALL   1B6C
08DE6:  MOVLB  1
08DE8:  DECFSZ xAB,F
08DEA:  BRA    8DF0
08DEC:  BRA    8DF6
08DEE:  MOVLB  0
08DF0:  MOVLB  0
08DF2:  GOTO   8DDA
08DF6:  MOVFF  1A7,264
08DFA:  MOVLW  37
08DFC:  MOVLB  2
08DFE:  MOVWF  x65
08E00:  MOVLB  0
08E02:  CALL   1E42
08E06:  MOVLW  0D
08E08:  MOVLB  A
08E0A:  MOVWF  xAD
08E0C:  MOVLB  0
08E0E:  CALL   1B6C
08E12:  MOVLW  0A
08E14:  MOVLB  A
08E16:  MOVWF  xAD
08E18:  MOVLB  0
08E1A:  CALL   1B6C
.................... 
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
08E1E:  MOVLW  01
08E20:  MOVLB  1
08E22:  MOVWF  xAC
08E24:  MOVLW  9F
08E26:  MOVWF  xAB
08E28:  MOVLB  0
08E2A:  GOTO   8638
.................... 
....................    fprintf(PC, "End MODE MEAS IV mission\r\n");
08E2E:  MOVLW  EE
08E30:  MOVWF  FF6
08E32:  MOVLW  14
08E34:  MOVWF  FF7
08E36:  MOVLW  00
08E38:  MOVWF  FF8
08E3A:  CALL   1BBE
08E3E:  GOTO   907C (RETURN)
.................... }
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
065FC:  MOVLB  1
065FE:  MOVF   xB1,W
06600:  MOVWF  FE9
06602:  MOVF   xB2,W
06604:  MOVWF  FEA
06606:  MOVFF  FEF,1B3
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
0660A:  MOVLW  01
0660C:  ADDWF  xB1,W
0660E:  MOVWF  FE9
06610:  MOVLW  00
06612:  ADDWFC xB2,W
06614:  MOVWF  FEA
06616:  MOVF   FEF,W
06618:  CLRF   xC0
0661A:  MOVWF  xBF
0661C:  MOVFF  1BF,1C0
06620:  CLRF   xBF
06622:  MOVLW  02
06624:  ADDWF  xB1,W
06626:  MOVWF  FE9
06628:  MOVLW  00
0662A:  ADDWFC xB2,W
0662C:  MOVWF  FEA
0662E:  MOVF   FEF,W
06630:  CLRF   03
06632:  IORWF  xBF,W
06634:  MOVWF  xB4
06636:  MOVF   03,W
06638:  IORWF  xC0,W
0663A:  MOVWF  xB5
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
0663C:  MOVLW  03
0663E:  ADDWF  xB1,W
06640:  MOVWF  FE9
06642:  MOVLW  00
06644:  ADDWFC xB2,W
06646:  MOVWF  FEA
06648:  MOVF   FEF,W
0664A:  CLRF   xC0
0664C:  MOVWF  xBF
0664E:  RLCF   xBF,W
06650:  MOVWF  xB6
06652:  RLCF   xC0,W
06654:  MOVWF  xB7
06656:  RLCF   xB6,F
06658:  RLCF   xB7,F
0665A:  RLCF   xB6,F
0665C:  RLCF   xB7,F
0665E:  RLCF   xB6,F
06660:  RLCF   xB7,F
06662:  MOVLW  F0
06664:  ANDWF  xB6,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
06666:  MOVLW  04
06668:  ADDWF  xB1,W
0666A:  MOVWF  FE9
0666C:  MOVLW  00
0666E:  ADDWFC xB2,W
06670:  MOVWF  FEA
06672:  MOVF   FEF,W
06674:  CLRF   xC0
06676:  MOVWF  xBF
06678:  RLCF   xBF,W
0667A:  MOVWF  xB8
0667C:  RLCF   xC0,W
0667E:  MOVWF  xB9
06680:  RLCF   xB8,F
06682:  RLCF   xB9,F
06684:  RLCF   xB8,F
06686:  RLCF   xB9,F
06688:  RLCF   xB8,F
0668A:  RLCF   xB9,F
0668C:  MOVLW  F0
0668E:  ANDWF  xB8,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
06690:  MOVLW  05
06692:  ADDWF  xB1,W
06694:  MOVWF  FE9
06696:  MOVLW  00
06698:  ADDWFC xB2,W
0669A:  MOVWF  FEA
0669C:  MOVF   FEF,W
0669E:  CLRF   xC0
066A0:  MOVWF  xBF
066A2:  RLCF   xBF,W
066A4:  MOVWF  xBA
066A6:  RLCF   xC0,W
066A8:  MOVWF  xBB
066AA:  RLCF   xBA,F
066AC:  RLCF   xBB,F
066AE:  RLCF   xBA,F
066B0:  RLCF   xBB,F
066B2:  RLCF   xBA,F
066B4:  RLCF   xBB,F
066B6:  MOVLW  F0
066B8:  ANDWF  xBA,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
066BA:  MOVLW  06
066BC:  ADDWF  xB1,W
066BE:  MOVWF  FE9
066C0:  MOVLW  00
066C2:  ADDWFC xB2,W
066C4:  MOVWF  FEA
066C6:  MOVF   FEF,W
066C8:  CLRF   xC0
066CA:  MOVWF  xBF
066CC:  MOVFF  1BF,1C0
066D0:  CLRF   xBF
066D2:  MOVLW  07
066D4:  ADDWF  xB1,W
066D6:  MOVWF  FE9
066D8:  MOVLW  00
066DA:  ADDWFC xB2,W
066DC:  MOVWF  FEA
066DE:  MOVF   FEF,W
066E0:  CLRF   03
066E2:  IORWF  xBF,W
066E4:  MOVWF  xBC
066E6:  MOVF   03,W
066E8:  IORWF  xC0,W
066EA:  MOVWF  xBD
....................    cmd.is_finished = uplinkcmd[8];
066EC:  MOVLW  08
066EE:  ADDWF  xB1,W
066F0:  MOVWF  FE9
066F2:  MOVLW  00
066F4:  ADDWFC xB2,W
066F6:  MOVWF  FEA
066F8:  MOVFF  FEF,1BE
....................    return cmd;
066FC:  MOVLW  B3
066FE:  MOVWF  01
06700:  MOVLW  01
06702:  MOVWF  02
06704:  MOVLB  0
06706:  GOTO   88B6 (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
047D8:  MOVLW  0A
047DA:  MOVWF  FF6
047DC:  MOVLW  15
047DE:  MOVWF  FF7
047E0:  MOVLW  00
047E2:  MOVWF  FF8
047E4:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
047E8:  MOVLB  1
047EA:  MOVF   x8F,W
047EC:  MOVWF  FE9
047EE:  MOVF   x90,W
047F0:  MOVWF  FEA
047F2:  MOVFF  FEF,191
....................    piclog_make(cmd, 0x00); // Log the command execution
047F6:  MOVFF  191,1E0
047FA:  CLRF   xE1
047FC:  MOVLB  0
047FE:  CALL   3F80
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
04802:  MOVLB  1
04804:  CLRF   x95
04806:  CLRF   x94
04808:  CLRF   x93
0480A:  CLRF   x92
0480C:  MOVLB  0
0480E:  MOVLB  1
04810:  MOVF   x95,F
04812:  BTFSC  FD8.2
04814:  BRA    481C
04816:  MOVLB  0
04818:  GOTO   4894
0481C:  MOVLB  0
0481E:  MOVLB  1
04820:  MOVF   x94,W
04822:  SUBLW  0F
04824:  BTFSC  FD8.0
04826:  BRA    482E
04828:  MOVLB  0
0482A:  GOTO   4894
0482E:  MOVLB  0
04830:  BTFSS  FD8.2
04832:  GOTO   4860
04836:  MOVLB  1
04838:  MOVF   x93,W
0483A:  SUBLW  FF
0483C:  BTFSC  FD8.0
0483E:  BRA    4846
04840:  MOVLB  0
04842:  GOTO   4894
04846:  MOVLB  0
04848:  BTFSS  FD8.2
0484A:  GOTO   4860
0484E:  MOVLB  1
04850:  MOVF   x92,W
04852:  SUBLW  FE
04854:  BTFSC  FD8.0
04856:  BRA    485E
04858:  MOVLB  0
0485A:  GOTO   4894
0485E:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
04860:  MOVFF  111,A59
04864:  MOVFF  110,A58
04868:  MOVFF  10F,A57
0486C:  MOVFF  10E,A56
04870:  MOVFF  195,A5D
04874:  MOVFF  194,A5C
04878:  MOVFF  193,A5B
0487C:  MOVFF  192,A5A
04880:  CALL   3BB2
04884:  MOVLW  01
04886:  MOVLB  1
04888:  ADDWF  x94,F
0488A:  MOVLW  00
0488C:  ADDWFC x95,F
0488E:  MOVLB  0
04890:  GOTO   480E
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04894:  MOVFF  191,1E0
04898:  MOVLB  1
0489A:  SETF   xE1
0489C:  MOVLB  0
0489E:  CALL   3F80
....................    printf("End Flash Erase All\r\n");
048A2:  MOVLW  22
048A4:  MOVWF  FF6
048A6:  MOVLW  15
048A8:  MOVWF  FF7
048AA:  MOVLW  00
048AC:  MOVWF  FF8
048AE:  CALL   1BBE
048B2:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
048B4:  MOVLW  38
048B6:  MOVWF  FF6
048B8:  MOVLW  15
048BA:  MOVWF  FF7
048BC:  MOVLW  00
048BE:  MOVWF  FF8
048C0:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
048C4:  MOVLB  1
048C6:  MOVF   x8D,W
048C8:  MOVWF  FE9
048CA:  MOVF   x8E,W
048CC:  MOVWF  FEA
048CE:  MOVFF  FEF,18F
048D2:  MOVLW  01
048D4:  ADDWF  x8D,W
048D6:  MOVWF  FE9
048D8:  MOVLW  00
048DA:  ADDWFC x8E,W
048DC:  MOVWF  FEA
048DE:  MOVF   FEF,W
048E0:  CLRF   x97
048E2:  CLRF   x96
048E4:  CLRF   x95
048E6:  MOVWF  x94
048E8:  MOVFF  194,197
048EC:  CLRF   x94
048EE:  CLRF   x95
048F0:  CLRF   x96
048F2:  MOVLW  02
048F4:  ADDWF  x8D,W
048F6:  MOVWF  FE9
048F8:  MOVLW  00
048FA:  ADDWFC x8E,W
048FC:  MOVWF  FEA
048FE:  MOVF   FEF,W
04900:  CLRF   x9C
04902:  CLRF   x9B
04904:  CLRF   x9A
04906:  MOVWF  x99
04908:  MOVFF  19A,03
0490C:  MOVFF  199,02
04910:  CLRF   00
04912:  CLRF   01
04914:  MOVF   00,W
04916:  IORWF  x94,F
04918:  MOVF   01,W
0491A:  IORWF  x95,F
0491C:  MOVF   02,W
0491E:  IORWF  x96,F
04920:  MOVF   03,W
04922:  IORWF  x97,F
04924:  MOVLW  03
04926:  ADDWF  x8D,W
04928:  MOVWF  FE9
0492A:  MOVLW  00
0492C:  ADDWFC x8E,W
0492E:  MOVWF  FEA
04930:  MOVF   FEF,W
04932:  CLRF   x9C
04934:  CLRF   x9B
04936:  CLRF   x9A
04938:  MOVWF  x99
0493A:  MOVFF  19B,03
0493E:  MOVFF  19A,02
04942:  MOVFF  199,01
04946:  CLRF   00
04948:  MOVF   00,W
0494A:  IORWF  x94,F
0494C:  MOVF   01,W
0494E:  IORWF  x95,F
04950:  MOVF   02,W
04952:  IORWF  x96,F
04954:  MOVF   03,W
04956:  IORWF  x97,F
04958:  MOVLW  04
0495A:  ADDWF  x8D,W
0495C:  MOVWF  FE9
0495E:  MOVLW  00
04960:  ADDWFC x8E,W
04962:  MOVWF  FEA
04964:  MOVF   FEF,W
04966:  MOVWF  00
04968:  CLRF   01
0496A:  CLRF   02
0496C:  CLRF   03
0496E:  MOVF   00,W
04970:  IORWF  x94,W
04972:  MOVWF  x90
04974:  MOVF   01,W
04976:  IORWF  x95,W
04978:  MOVWF  x91
0497A:  MOVF   02,W
0497C:  IORWF  x96,W
0497E:  MOVWF  x92
04980:  MOVF   03,W
04982:  IORWF  x97,W
04984:  MOVWF  x93
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
04986:  MOVLW  56
04988:  MOVWF  FF6
0498A:  MOVLW  15
0498C:  MOVWF  FF7
0498E:  MOVLW  00
04990:  MOVWF  FF8
04992:  MOVLW  13
04994:  MOVLB  9
04996:  MOVWF  xC2
04998:  MOVLB  0
0499A:  CALL   1BEE
0499E:  MOVFF  193,264
049A2:  MOVLW  37
049A4:  MOVLB  2
049A6:  MOVWF  x65
049A8:  MOVLB  0
049AA:  CALL   1E42
049AE:  MOVFF  192,264
049B2:  MOVLW  37
049B4:  MOVLB  2
049B6:  MOVWF  x65
049B8:  MOVLB  0
049BA:  CALL   1E42
049BE:  MOVFF  191,264
049C2:  MOVLW  37
049C4:  MOVLB  2
049C6:  MOVWF  x65
049C8:  MOVLB  0
049CA:  CALL   1E42
049CE:  MOVFF  190,264
049D2:  MOVLW  37
049D4:  MOVLB  2
049D6:  MOVWF  x65
049D8:  MOVLB  0
049DA:  CALL   1E42
049DE:  MOVLW  0D
049E0:  MOVLB  A
049E2:  MOVWF  xAD
049E4:  MOVLB  0
049E6:  CALL   1B6C
049EA:  MOVLW  0A
049EC:  MOVLB  A
049EE:  MOVWF  xAD
049F0:  MOVLB  0
049F2:  CALL   1B6C
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
049F6:  MOVFF  18F,1E0
049FA:  MOVLB  1
049FC:  CLRF   xE1
049FE:  MOVLB  0
04A00:  CALL   3F80
....................    
....................    sector_erase(mis_fm, sector_address);
04A04:  MOVFF  111,A59
04A08:  MOVFF  110,A58
04A0C:  MOVFF  10F,A57
04A10:  MOVFF  10E,A56
04A14:  MOVFF  193,A5D
04A18:  MOVFF  192,A5C
04A1C:  MOVFF  191,A5B
04A20:  MOVFF  190,A5A
04A24:  CALL   3BB2
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04A28:  MOVFF  18F,1E0
04A2C:  MOVLB  1
04A2E:  SETF   xE1
04A30:  MOVLB  0
04A32:  CALL   3F80
....................    printf("End Flash Erase 1 Sector\r\n");
04A36:  MOVLW  72
04A38:  MOVWF  FF6
04A3A:  MOVLW  15
04A3C:  MOVWF  FF7
04A3E:  MOVLW  00
04A40:  MOVWF  FF8
04A42:  CALL   1BBE
04A46:  GOTO   8F8C (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
04DA6:  MOVLW  8E
04DA8:  MOVWF  FF6
04DAA:  MOVLW  15
04DAC:  MOVWF  FF7
04DAE:  MOVLW  00
04DB0:  MOVWF  FF8
04DB2:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
04DB6:  MOVLB  1
04DB8:  MOVF   x8D,W
04DBA:  MOVWF  FE9
04DBC:  MOVF   x8E,W
04DBE:  MOVWF  FEA
04DC0:  MOVFF  FEF,18F
04DC4:  MOVLW  01
04DC6:  ADDWF  x8D,W
04DC8:  MOVWF  FE9
04DCA:  MOVLW  00
04DCC:  ADDWFC x8E,W
04DCE:  MOVWF  FEA
04DD0:  MOVF   FEF,W
04DD2:  CLRF   x97
04DD4:  CLRF   x96
04DD6:  CLRF   x95
04DD8:  MOVWF  x94
04DDA:  MOVFF  194,197
04DDE:  CLRF   x94
04DE0:  CLRF   x95
04DE2:  CLRF   x96
04DE4:  MOVLW  02
04DE6:  ADDWF  x8D,W
04DE8:  MOVWF  FE9
04DEA:  MOVLW  00
04DEC:  ADDWFC x8E,W
04DEE:  MOVWF  FEA
04DF0:  MOVF   FEF,W
04DF2:  CLRF   x9C
04DF4:  CLRF   x9B
04DF6:  CLRF   x9A
04DF8:  MOVWF  x99
04DFA:  MOVFF  19A,03
04DFE:  MOVFF  199,02
04E02:  CLRF   00
04E04:  CLRF   01
04E06:  MOVF   00,W
04E08:  IORWF  x94,F
04E0A:  MOVF   01,W
04E0C:  IORWF  x95,F
04E0E:  MOVF   02,W
04E10:  IORWF  x96,F
04E12:  MOVF   03,W
04E14:  IORWF  x97,F
04E16:  MOVLW  03
04E18:  ADDWF  x8D,W
04E1A:  MOVWF  FE9
04E1C:  MOVLW  00
04E1E:  ADDWFC x8E,W
04E20:  MOVWF  FEA
04E22:  MOVF   FEF,W
04E24:  CLRF   x9C
04E26:  CLRF   x9B
04E28:  CLRF   x9A
04E2A:  MOVWF  x99
04E2C:  MOVFF  19B,03
04E30:  MOVFF  19A,02
04E34:  MOVFF  199,01
04E38:  CLRF   00
04E3A:  MOVF   00,W
04E3C:  IORWF  x94,F
04E3E:  MOVF   01,W
04E40:  IORWF  x95,F
04E42:  MOVF   02,W
04E44:  IORWF  x96,F
04E46:  MOVF   03,W
04E48:  IORWF  x97,F
04E4A:  MOVLW  04
04E4C:  ADDWF  x8D,W
04E4E:  MOVWF  FE9
04E50:  MOVLW  00
04E52:  ADDWFC x8E,W
04E54:  MOVWF  FEA
04E56:  MOVF   FEF,W
04E58:  MOVWF  00
04E5A:  CLRF   01
04E5C:  CLRF   02
04E5E:  CLRF   03
04E60:  MOVF   00,W
04E62:  IORWF  x94,W
04E64:  MOVWF  x90
04E66:  MOVF   01,W
04E68:  IORWF  x95,W
04E6A:  MOVWF  x91
04E6C:  MOVF   02,W
04E6E:  IORWF  x96,W
04E70:  MOVWF  x92
04E72:  MOVF   03,W
04E74:  IORWF  x97,W
04E76:  MOVWF  x93
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
04E78:  MOVLW  AA
04E7A:  MOVWF  FF6
04E7C:  MOVLW  15
04E7E:  MOVWF  FF7
04E80:  MOVLW  00
04E82:  MOVWF  FF8
04E84:  MOVLW  16
04E86:  MOVLB  9
04E88:  MOVWF  xC2
04E8A:  MOVLB  0
04E8C:  CALL   1BEE
04E90:  MOVFF  193,264
04E94:  MOVLW  37
04E96:  MOVLB  2
04E98:  MOVWF  x65
04E9A:  MOVLB  0
04E9C:  CALL   1E42
04EA0:  MOVFF  192,264
04EA4:  MOVLW  37
04EA6:  MOVLB  2
04EA8:  MOVWF  x65
04EAA:  MOVLB  0
04EAC:  CALL   1E42
04EB0:  MOVFF  191,264
04EB4:  MOVLW  37
04EB6:  MOVLB  2
04EB8:  MOVWF  x65
04EBA:  MOVLB  0
04EBC:  CALL   1E42
04EC0:  MOVFF  190,264
04EC4:  MOVLW  37
04EC6:  MOVLB  2
04EC8:  MOVWF  x65
04ECA:  MOVLB  0
04ECC:  CALL   1E42
04ED0:  MOVLW  0D
04ED2:  MOVLB  A
04ED4:  MOVWF  xAD
04ED6:  MOVLB  0
04ED8:  CALL   1B6C
04EDC:  MOVLW  0A
04EDE:  MOVLB  A
04EE0:  MOVWF  xAD
04EE2:  MOVLB  0
04EE4:  CALL   1B6C
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04EE8:  MOVFF  18F,1E0
04EEC:  MOVLB  1
04EEE:  CLRF   xE1
04EF0:  MOVLB  0
04EF2:  CALL   3F80
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
04EF6:  MOVFF  111,2E5
04EFA:  MOVFF  110,2E4
04EFE:  MOVFF  10F,2E3
04F02:  MOVFF  10E,2E2
04F06:  MOVLB  2
04F08:  CLRF   xE9
04F0A:  CLRF   xE8
04F0C:  CLRF   xE7
04F0E:  CLRF   xE6
04F10:  MOVLB  0
04F12:  CALL   4A4A
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04F16:  MOVFF  18F,1E0
04F1A:  MOVLB  1
04F1C:  SETF   xE1
04F1E:  MOVLB  0
04F20:  CALL   3F80
....................    printf("End Flash Copy 1 Sector\r\n");
04F24:  MOVLW  C8
04F26:  MOVWF  FF6
04F28:  MOVLW  15
04F2A:  MOVWF  FF7
04F2C:  MOVLW  00
04F2E:  MOVWF  FF8
04F30:  CALL   1BBE
04F34:  GOTO   8F9C (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
04F38:  MOVLW  E2
04F3A:  MOVWF  FF6
04F3C:  MOVLW  15
04F3E:  MOVWF  FF7
04F40:  MOVLW  00
04F42:  MOVWF  FF8
04F44:  CALL   1BBE
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
04F48:  MOVLB  1
04F4A:  MOVF   x8D,W
04F4C:  MOVWF  FE9
04F4E:  MOVF   x8E,W
04F50:  MOVWF  FEA
04F52:  MOVFF  FEF,18F
04F56:  MOVLW  01
04F58:  ADDWF  x8D,W
04F5A:  MOVWF  FE9
04F5C:  MOVLW  00
04F5E:  ADDWFC x8E,W
04F60:  MOVWF  FEA
04F62:  MOVF   FEF,W
04F64:  CLRF   x97
04F66:  CLRF   x96
04F68:  CLRF   x95
04F6A:  MOVWF  x94
04F6C:  MOVFF  194,197
04F70:  CLRF   x94
04F72:  CLRF   x95
04F74:  CLRF   x96
04F76:  MOVLW  02
04F78:  ADDWF  x8D,W
04F7A:  MOVWF  FE9
04F7C:  MOVLW  00
04F7E:  ADDWFC x8E,W
04F80:  MOVWF  FEA
04F82:  MOVF   FEF,W
04F84:  CLRF   x9C
04F86:  CLRF   x9B
04F88:  CLRF   x9A
04F8A:  MOVWF  x99
04F8C:  MOVFF  19A,03
04F90:  MOVFF  199,02
04F94:  CLRF   00
04F96:  CLRF   01
04F98:  MOVF   00,W
04F9A:  IORWF  x94,F
04F9C:  MOVF   01,W
04F9E:  IORWF  x95,F
04FA0:  MOVF   02,W
04FA2:  IORWF  x96,F
04FA4:  MOVF   03,W
04FA6:  IORWF  x97,F
04FA8:  MOVLW  03
04FAA:  ADDWF  x8D,W
04FAC:  MOVWF  FE9
04FAE:  MOVLW  00
04FB0:  ADDWFC x8E,W
04FB2:  MOVWF  FEA
04FB4:  MOVF   FEF,W
04FB6:  CLRF   x9C
04FB8:  CLRF   x9B
04FBA:  CLRF   x9A
04FBC:  MOVWF  x99
04FBE:  MOVFF  19B,03
04FC2:  MOVFF  19A,02
04FC6:  MOVFF  199,01
04FCA:  CLRF   00
04FCC:  MOVF   00,W
04FCE:  IORWF  x94,F
04FD0:  MOVF   01,W
04FD2:  IORWF  x95,F
04FD4:  MOVF   02,W
04FD6:  IORWF  x96,F
04FD8:  MOVF   03,W
04FDA:  IORWF  x97,F
04FDC:  MOVLW  04
04FDE:  ADDWF  x8D,W
04FE0:  MOVWF  FE9
04FE2:  MOVLW  00
04FE4:  ADDWFC x8E,W
04FE6:  MOVWF  FEA
04FE8:  MOVF   FEF,W
04FEA:  MOVWF  00
04FEC:  CLRF   01
04FEE:  CLRF   02
04FF0:  CLRF   03
04FF2:  MOVF   00,W
04FF4:  IORWF  x94,W
04FF6:  MOVWF  x90
04FF8:  MOVF   01,W
04FFA:  IORWF  x95,W
04FFC:  MOVWF  x91
04FFE:  MOVF   02,W
05000:  IORWF  x96,W
05002:  MOVWF  x92
05004:  MOVF   03,W
05006:  IORWF  x97,W
05008:  MOVWF  x93
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
0500A:  MOVLW  08
0500C:  MOVWF  FF6
0500E:  MOVLW  16
05010:  MOVWF  FF7
05012:  MOVLW  00
05014:  MOVWF  FF8
05016:  MOVLW  16
05018:  MOVLB  9
0501A:  MOVWF  xC2
0501C:  MOVLB  0
0501E:  CALL   1BEE
05022:  MOVFF  193,264
05026:  MOVLW  37
05028:  MOVLB  2
0502A:  MOVWF  x65
0502C:  MOVLB  0
0502E:  CALL   1E42
05032:  MOVFF  192,264
05036:  MOVLW  37
05038:  MOVLB  2
0503A:  MOVWF  x65
0503C:  MOVLB  0
0503E:  CALL   1E42
05042:  MOVFF  191,264
05046:  MOVLW  37
05048:  MOVLB  2
0504A:  MOVWF  x65
0504C:  MOVLB  0
0504E:  CALL   1E42
05052:  MOVFF  190,264
05056:  MOVLW  37
05058:  MOVLB  2
0505A:  MOVWF  x65
0505C:  MOVLB  0
0505E:  CALL   1E42
05062:  MOVLW  0D
05064:  MOVLB  A
05066:  MOVWF  xAD
05068:  MOVLB  0
0506A:  CALL   1B6C
0506E:  MOVLW  0A
05070:  MOVLB  A
05072:  MOVWF  xAD
05074:  MOVLB  0
05076:  CALL   1B6C
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
0507A:  MOVFF  18F,1E0
0507E:  MOVLB  1
05080:  CLRF   xE1
05082:  MOVLB  0
05084:  CALL   3F80
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05088:  MOVFF  18F,1E0
0508C:  MOVLB  1
0508E:  SETF   xE1
05090:  MOVLB  0
05092:  CALL   3F80
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
05096:  MOVLW  26
05098:  MOVWF  FF6
0509A:  MOVLW  16
0509C:  MOVWF  FF7
0509E:  MOVLW  00
050A0:  MOVWF  FF8
050A2:  CALL   1BBE
050A6:  GOTO   8FAC (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
050AA:  MOVLW  4A
050AC:  MOVWF  FF6
050AE:  MOVLW  16
050B0:  MOVWF  FF7
050B2:  MOVLW  00
050B4:  MOVWF  FF8
050B6:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
050BA:  MOVLB  1
050BC:  MOVF   x8D,W
050BE:  MOVWF  FE9
050C0:  MOVF   x8E,W
050C2:  MOVWF  FEA
050C4:  MOVFF  FEF,1DF
050C8:  MOVFF  1DF,1E0
050CC:  CLRF   xE1
050CE:  MOVLB  0
050D0:  CALL   3F80
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
050D4:  MOVLB  1
050D6:  CLRF   x8F
050D8:  CLRF   x90
050DA:  CLRF   x91
050DC:  CLRF   x92
050DE:  CLRF   x93
050E0:  CLRF   x94
050E2:  CLRF   x95
....................    
....................    flash_write_param.id = parameter[0];
050E4:  MOVF   x8D,W
050E6:  MOVWF  FE9
050E8:  MOVF   x8E,W
050EA:  MOVWF  FEA
050EC:  MOVFF  FEF,18F
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
050F0:  MOVLW  01
050F2:  ADDWF  x8D,W
050F4:  MOVWF  FE9
050F6:  MOVLW  00
050F8:  ADDWFC x8E,W
050FA:  MOVWF  FEA
050FC:  MOVF   FEF,W
050FE:  CLRF   xE2
05100:  CLRF   xE1
05102:  CLRF   xE0
05104:  MOVWF  xDF
05106:  MOVFF  1DF,1E2
0510A:  CLRF   xDF
0510C:  CLRF   xE0
0510E:  CLRF   xE1
05110:  MOVLW  02
05112:  ADDWF  x8D,W
05114:  MOVWF  FE9
05116:  MOVLW  00
05118:  ADDWFC x8E,W
0511A:  MOVWF  FEA
0511C:  MOVF   FEF,W
0511E:  CLRF   xE7
05120:  CLRF   xE6
05122:  CLRF   xE5
05124:  MOVWF  xE4
05126:  MOVFF  1E5,03
0512A:  MOVFF  1E4,02
0512E:  CLRF   00
05130:  CLRF   01
05132:  MOVF   00,W
05134:  IORWF  xDF,F
05136:  MOVF   01,W
05138:  IORWF  xE0,F
0513A:  MOVF   02,W
0513C:  IORWF  xE1,F
0513E:  MOVF   03,W
05140:  IORWF  xE2,F
05142:  MOVLW  03
05144:  ADDWF  x8D,W
05146:  MOVWF  FE9
05148:  MOVLW  00
0514A:  ADDWFC x8E,W
0514C:  MOVWF  FEA
0514E:  MOVF   FEF,W
05150:  CLRF   xE7
05152:  CLRF   xE6
05154:  CLRF   xE5
05156:  MOVWF  xE4
05158:  MOVFF  1E6,03
0515C:  MOVFF  1E5,02
05160:  MOVFF  1E4,01
05164:  CLRF   00
05166:  MOVF   00,W
05168:  IORWF  xDF,F
0516A:  MOVF   01,W
0516C:  IORWF  xE0,F
0516E:  MOVF   02,W
05170:  IORWF  xE1,F
05172:  MOVF   03,W
05174:  IORWF  xE2,F
05176:  MOVLW  04
05178:  ADDWF  x8D,W
0517A:  MOVWF  FE9
0517C:  MOVLW  00
0517E:  ADDWFC x8E,W
05180:  MOVWF  FEA
05182:  MOVF   FEF,W
05184:  MOVWF  00
05186:  CLRF   01
05188:  CLRF   02
0518A:  CLRF   03
0518C:  MOVF   00,W
0518E:  IORWF  xDF,W
05190:  MOVWF  x90
05192:  MOVF   01,W
05194:  IORWF  xE0,W
05196:  MOVWF  x91
05198:  MOVF   02,W
0519A:  IORWF  xE1,W
0519C:  MOVWF  x92
0519E:  MOVF   03,W
051A0:  IORWF  xE2,W
051A2:  MOVWF  x93
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
051A4:  MOVLW  07
051A6:  ADDWF  x8D,W
051A8:  MOVWF  FE9
051AA:  MOVLW  00
051AC:  ADDWFC x8E,W
051AE:  MOVWF  FEA
051B0:  MOVF   FEF,W
051B2:  CLRF   xE0
051B4:  MOVWF  xDF
051B6:  MOVFF  1DF,1E0
051BA:  CLRF   xDF
051BC:  MOVLW  08
051BE:  ADDWF  x8D,W
051C0:  MOVWF  FE9
051C2:  MOVLW  00
051C4:  ADDWFC x8E,W
051C6:  MOVWF  FEA
051C8:  MOVF   FEF,W
051CA:  CLRF   03
051CC:  IORWF  xDF,W
051CE:  MOVWF  x94
051D0:  MOVF   03,W
051D2:  IORWF  xE0,W
051D4:  MOVWF  x95
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
051D6:  MOVLW  64
051D8:  MOVWF  FF6
051DA:  MOVLW  16
051DC:  MOVWF  FF7
051DE:  MOVLW  00
051E0:  MOVWF  FF8
051E2:  MOVLW  0C
051E4:  MOVLB  9
051E6:  MOVWF  xC2
051E8:  MOVLB  0
051EA:  CALL   1BEE
051EE:  MOVFF  18F,264
051F2:  MOVLW  37
051F4:  MOVLB  2
051F6:  MOVWF  x65
051F8:  MOVLB  0
051FA:  CALL   1E42
051FE:  MOVLW  0D
05200:  MOVLB  A
05202:  MOVWF  xAD
05204:  MOVLB  0
05206:  CALL   1B6C
0520A:  MOVLW  0A
0520C:  MOVLB  A
0520E:  MOVWF  xAD
05210:  MOVLB  0
05212:  CALL   1B6C
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
05216:  MOVLW  78
05218:  MOVWF  FF6
0521A:  MOVLW  16
0521C:  MOVWF  FF7
0521E:  MOVLW  00
05220:  MOVWF  FF8
05222:  MOVLW  0E
05224:  MOVLB  9
05226:  MOVWF  xC2
05228:  MOVLB  0
0522A:  CALL   1BEE
0522E:  MOVFF  193,264
05232:  MOVLW  37
05234:  MOVLB  2
05236:  MOVWF  x65
05238:  MOVLB  0
0523A:  CALL   1E42
0523E:  MOVFF  192,264
05242:  MOVLW  37
05244:  MOVLB  2
05246:  MOVWF  x65
05248:  MOVLB  0
0524A:  CALL   1E42
0524E:  MOVFF  191,264
05252:  MOVLW  37
05254:  MOVLB  2
05256:  MOVWF  x65
05258:  MOVLB  0
0525A:  CALL   1E42
0525E:  MOVFF  190,264
05262:  MOVLW  37
05264:  MOVLB  2
05266:  MOVWF  x65
05268:  MOVLB  0
0526A:  CALL   1E42
0526E:  MOVLW  0D
05270:  MOVLB  A
05272:  MOVWF  xAD
05274:  MOVLB  0
05276:  CALL   1B6C
0527A:  MOVLW  0A
0527C:  MOVLB  A
0527E:  MOVWF  xAD
05280:  MOVLB  0
05282:  CALL   1B6C
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
05286:  MOVLW  8E
05288:  MOVWF  FF6
0528A:  MOVLW  16
0528C:  MOVWF  FF7
0528E:  MOVLW  00
05290:  MOVWF  FF8
05292:  MOVLW  0E
05294:  MOVLB  9
05296:  MOVWF  xC2
05298:  MOVLB  0
0529A:  CALL   1BEE
0529E:  MOVFF  195,264
052A2:  MOVLW  37
052A4:  MOVLB  2
052A6:  MOVWF  x65
052A8:  MOVLB  0
052AA:  CALL   1E42
052AE:  MOVFF  194,264
052B2:  MOVLW  37
052B4:  MOVLB  2
052B6:  MOVWF  x65
052B8:  MOVLB  0
052BA:  CALL   1E42
052BE:  MOVLW  0D
052C0:  MOVLB  A
052C2:  MOVWF  xAD
052C4:  MOVLB  0
052C6:  CALL   1B6C
052CA:  MOVLW  0A
052CC:  MOVLB  A
052CE:  MOVWF  xAD
052D0:  MOVLB  0
052D2:  CALL   1B6C
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
052D6:  MOVFF  18F,1E0
052DA:  MOVLB  1
052DC:  CLRF   xE1
052DE:  MOVLB  0
052E0:  CALL   3F80
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
052E4:  MOVLW  A4
052E6:  MOVWF  FF6
052E8:  MOVLW  16
052EA:  MOVWF  FF7
052EC:  MOVLW  00
052EE:  MOVWF  FF8
052F0:  CALL   1BBE
....................    for (p = 0; p < flash_write_param.packetnum; p++)
052F4:  MOVLB  1
052F6:  CLRF   xD7
052F8:  CLRF   xD6
052FA:  MOVLB  0
052FC:  MOVLB  1
052FE:  MOVF   xD7,W
05300:  SUBWF  x95,W
05302:  BTFSC  FD8.0
05304:  BRA    530C
05306:  MOVLB  0
05308:  GOTO   543A
0530C:  MOVLB  0
0530E:  BTFSS  FD8.2
05310:  GOTO   5326
05314:  MOVLB  1
05316:  MOVF   x94,W
05318:  SUBWF  xD6,W
0531A:  BTFSS  FD8.0
0531C:  BRA    5324
0531E:  MOVLB  0
05320:  GOTO   543A
05324:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
05326:  MOVLB  1
05328:  RLCF   xD6,W
0532A:  MOVWF  xD8
0532C:  RLCF   xD7,W
0532E:  MOVWF  xD9
05330:  RLCF   xD8,F
05332:  RLCF   xD9,F
05334:  RLCF   xD8,F
05336:  RLCF   xD9,F
05338:  RLCF   xD8,F
0533A:  RLCF   xD9,F
0533C:  RLCF   xD8,F
0533E:  RLCF   xD9,F
05340:  RLCF   xD8,F
05342:  RLCF   xD9,F
05344:  MOVLW  C0
05346:  ANDWF  xD8,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
05348:  CLRF   xDA
0534A:  MOVLB  0
0534C:  MOVLB  1
0534E:  MOVF   xDA,W
05350:  SUBLW  3F
05352:  BTFSC  FD8.0
05354:  BRA    535C
05356:  MOVLB  0
05358:  GOTO   53BC
0535C:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
0535E:  CLRF   03
05360:  MOVLB  1
05362:  MOVF   xDA,W
05364:  ADDLW  96
05366:  MOVWF  FE9
05368:  MOVLW  01
0536A:  ADDWFC 03,W
0536C:  MOVWF  FEA
0536E:  MOVF   xDA,W
05370:  ADDWF  xD8,W
05372:  MOVWF  xE1
05374:  MOVLW  00
05376:  ADDWFC xD9,W
05378:  MOVWF  xE2
0537A:  MOVF   xE1,W
0537C:  MOVWF  00
0537E:  CLRF   03
05380:  MOVF   00,W
05382:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
05384:  CLRF   03
05386:  MOVF   xDA,W
05388:  ADDLW  96
0538A:  MOVWF  FE9
0538C:  MOVLW  01
0538E:  ADDWFC 03,W
05390:  MOVWF  FEA
05392:  MOVFF  FEF,1DF
05396:  MOVFF  1DF,264
0539A:  MOVLW  37
0539C:  MOVLB  2
0539E:  MOVWF  x65
053A0:  MOVLB  0
053A2:  CALL   1E42
053A6:  MOVLW  20
053A8:  MOVLB  A
053AA:  MOVWF  xAD
053AC:  MOVLB  0
053AE:  CALL   1B6C
053B2:  MOVLB  1
053B4:  INCF   xDA,F
053B6:  MOVLB  0
053B8:  GOTO   534C
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
053BC:  MOVLB  1
053BE:  RLCF   xD6,W
053C0:  MOVWF  02
053C2:  RLCF   xD7,W
053C4:  MOVWF  03
053C6:  RLCF   02,F
053C8:  RLCF   03,F
053CA:  RLCF   02,F
053CC:  RLCF   03,F
053CE:  RLCF   02,F
053D0:  RLCF   03,F
053D2:  RLCF   02,F
053D4:  RLCF   03,F
053D6:  RLCF   02,F
053D8:  RLCF   03,F
053DA:  MOVLW  C0
053DC:  ANDWF  02,F
053DE:  MOVF   02,W
053E0:  ADDWF  x90,W
053E2:  MOVWF  xDB
053E4:  MOVF   03,W
053E6:  ADDWFC x91,W
053E8:  MOVWF  xDC
053EA:  MOVLW  00
053EC:  ADDWFC x92,W
053EE:  MOVWF  xDD
053F0:  MOVLW  00
053F2:  ADDWFC x93,W
053F4:  MOVWF  xDE
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
053F6:  MOVFF  111,A59
053FA:  MOVFF  110,A58
053FE:  MOVFF  10F,A57
05402:  MOVFF  10E,A56
05406:  MOVFF  1DE,A5D
0540A:  MOVFF  1DD,A5C
0540E:  MOVFF  1DC,A5B
05412:  MOVFF  1DB,A5A
05416:  MOVLW  01
05418:  MOVLB  A
0541A:  MOVWF  x5F
0541C:  MOVLW  96
0541E:  MOVWF  x5E
05420:  CLRF   x61
05422:  MOVLW  40
05424:  MOVWF  x60
05426:  MOVLB  0
05428:  CALL   34D6
0542C:  MOVLB  1
0542E:  INCF   xD6,F
05430:  BTFSC  FD8.2
05432:  INCF   xD7,F
05434:  MOVLB  0
05436:  GOTO   52FC
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
0543A:  MOVFF  18F,1E0
0543E:  MOVLB  1
05440:  SETF   xE1
05442:  MOVLB  0
05444:  CALL   3F80
....................    fprintf(PC, "\r\n");
05448:  MOVLW  0D
0544A:  MOVLB  A
0544C:  MOVWF  xAD
0544E:  MOVLB  0
05450:  CALL   1B6C
05454:  MOVLW  0A
05456:  MOVLB  A
05458:  MOVWF  xAD
0545A:  MOVLB  0
0545C:  CALL   1B6C
....................    fprintf(PC, "End Flash Write Demo\r\n");
05460:  MOVLW  B2
05462:  MOVWF  FF6
05464:  MOVLW  16
05466:  MOVWF  FF7
05468:  MOVLW  00
0546A:  MOVWF  FF8
0546C:  CALL   1BBE
05470:  GOTO   8FBC (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
054A4:  MOVLW  CA
054A6:  MOVWF  FF6
054A8:  MOVLW  16
054AA:  MOVWF  FF7
054AC:  MOVLW  00
054AE:  MOVWF  FF8
054B0:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
054B4:  MOVLB  1
054B6:  MOVF   x8D,W
054B8:  MOVWF  FE9
054BA:  MOVF   x8E,W
054BC:  MOVWF  FEA
054BE:  MOVFF  FEF,193
054C2:  MOVFF  193,1E0
054C6:  CLRF   xE1
054C8:  MOVLB  0
054CA:  CALL   3F80
....................    flash_setting(mis_fm);
054CE:  MOVFF  111,29B
054D2:  MOVFF  110,29A
054D6:  MOVFF  10F,299
054DA:  MOVFF  10E,298
054DE:  CALL   5474
....................    unsigned int32 write_address = 0x00000000;
054E2:  MOVLB  1
054E4:  CLRF   x92
054E6:  CLRF   x91
054E8:  CLRF   x90
054EA:  CLRF   x8F
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
054EC:  MOVF   x8D,W
054EE:  MOVWF  FE9
054F0:  MOVF   x8E,W
054F2:  MOVWF  FEA
054F4:  MOVFF  FEF,193
054F8:  MOVFF  193,1E0
054FC:  SETF   xE1
054FE:  MOVLB  0
05500:  CALL   3F80
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
05504:  MOVLW  F0
05506:  MOVWF  FF6
05508:  MOVLW  16
0550A:  MOVWF  FF7
0550C:  MOVLW  00
0550E:  MOVWF  FF8
05510:  CALL   1BBE
05514:  GOTO   8FCC (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
05518:  MOVLW  14
0551A:  MOVWF  FF6
0551C:  MOVLW  17
0551E:  MOVWF  FF7
05520:  MOVLW  00
05522:  MOVWF  FF8
05524:  CALL   1BBE
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
05528:  MOVLB  1
0552A:  MOVF   x8D,W
0552C:  MOVWF  FE9
0552E:  MOVF   x8E,W
05530:  MOVWF  FEA
05532:  MOVFF  FEF,1DF
05536:  MOVFF  1DF,1E0
0553A:  CLRF   xE1
0553C:  MOVLB  0
0553E:  CALL   3F80
....................    FLASH_PARAM flash_param = {0};
05542:  MOVLB  1
05544:  CLRF   x8F
05546:  CLRF   x90
05548:  CLRF   x91
0554A:  CLRF   x92
0554C:  CLRF   x93
0554E:  CLRF   x94
05550:  CLRF   x95
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
05552:  MOVF   x8D,W
05554:  MOVWF  FE9
05556:  MOVF   x8E,W
05558:  MOVWF  FEA
0555A:  MOVFF  FEF,18F
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
0555E:  MOVLW  01
05560:  ADDWF  x8D,W
05562:  MOVWF  FE9
05564:  MOVLW  00
05566:  ADDWFC x8E,W
05568:  MOVWF  FEA
0556A:  MOVF   FEF,W
0556C:  CLRF   xE2
0556E:  CLRF   xE1
05570:  CLRF   xE0
05572:  MOVWF  xDF
05574:  MOVFF  1DF,1E2
05578:  CLRF   xDF
0557A:  CLRF   xE0
0557C:  CLRF   xE1
0557E:  MOVLW  02
05580:  ADDWF  x8D,W
05582:  MOVWF  FE9
05584:  MOVLW  00
05586:  ADDWFC x8E,W
05588:  MOVWF  FEA
0558A:  MOVF   FEF,W
0558C:  CLRF   xE7
0558E:  CLRF   xE6
05590:  CLRF   xE5
05592:  MOVWF  xE4
05594:  MOVFF  1E5,03
05598:  MOVFF  1E4,02
0559C:  CLRF   00
0559E:  CLRF   01
055A0:  MOVF   00,W
055A2:  IORWF  xDF,F
055A4:  MOVF   01,W
055A6:  IORWF  xE0,F
055A8:  MOVF   02,W
055AA:  IORWF  xE1,F
055AC:  MOVF   03,W
055AE:  IORWF  xE2,F
055B0:  MOVLW  03
055B2:  ADDWF  x8D,W
055B4:  MOVWF  FE9
055B6:  MOVLW  00
055B8:  ADDWFC x8E,W
055BA:  MOVWF  FEA
055BC:  MOVF   FEF,W
055BE:  CLRF   xE7
055C0:  CLRF   xE6
055C2:  CLRF   xE5
055C4:  MOVWF  xE4
055C6:  MOVFF  1E6,03
055CA:  MOVFF  1E5,02
055CE:  MOVFF  1E4,01
055D2:  CLRF   00
055D4:  MOVF   00,W
055D6:  IORWF  xDF,F
055D8:  MOVF   01,W
055DA:  IORWF  xE0,F
055DC:  MOVF   02,W
055DE:  IORWF  xE1,F
055E0:  MOVF   03,W
055E2:  IORWF  xE2,F
055E4:  MOVLW  04
055E6:  ADDWF  x8D,W
055E8:  MOVWF  FE9
055EA:  MOVLW  00
055EC:  ADDWFC x8E,W
055EE:  MOVWF  FEA
055F0:  MOVF   FEF,W
055F2:  MOVWF  00
055F4:  CLRF   01
055F6:  CLRF   02
055F8:  CLRF   03
055FA:  MOVF   00,W
055FC:  IORWF  xDF,W
055FE:  MOVWF  x92
05600:  MOVF   01,W
05602:  IORWF  xE0,W
05604:  MOVWF  x93
05606:  MOVF   02,W
05608:  IORWF  xE1,W
0560A:  MOVWF  x94
0560C:  MOVF   03,W
0560E:  IORWF  xE2,W
05610:  MOVWF  x95
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
05612:  MOVLW  07
05614:  ADDWF  x8D,W
05616:  MOVWF  FE9
05618:  MOVLW  00
0561A:  ADDWFC x8E,W
0561C:  MOVWF  FEA
0561E:  MOVF   FEF,W
05620:  CLRF   xE0
05622:  MOVWF  xDF
05624:  MOVFF  1DF,1E0
05628:  CLRF   xDF
0562A:  MOVLW  08
0562C:  ADDWF  x8D,W
0562E:  MOVWF  FE9
05630:  MOVLW  00
05632:  ADDWFC x8E,W
05634:  MOVWF  FEA
05636:  MOVF   FEF,W
05638:  CLRF   03
0563A:  IORWF  xDF,W
0563C:  MOVWF  x90
0563E:  MOVF   03,W
05640:  IORWF  xE0,W
05642:  MOVWF  x91
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
05644:  MOVLW  28
05646:  MOVWF  FF6
05648:  MOVLW  17
0564A:  MOVWF  FF7
0564C:  MOVLW  00
0564E:  MOVWF  FF8
05650:  MOVLW  0C
05652:  MOVLB  9
05654:  MOVWF  xC2
05656:  MOVLB  0
05658:  CALL   1BEE
0565C:  MOVFF  18F,264
05660:  MOVLW  37
05662:  MOVLB  2
05664:  MOVWF  x65
05666:  MOVLB  0
05668:  CALL   1E42
0566C:  MOVLW  0D
0566E:  MOVLB  A
05670:  MOVWF  xAD
05672:  MOVLB  0
05674:  CALL   1B6C
05678:  MOVLW  0A
0567A:  MOVLB  A
0567C:  MOVWF  xAD
0567E:  MOVLB  0
05680:  CALL   1B6C
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
05684:  MOVLW  3C
05686:  MOVWF  FF6
05688:  MOVLW  17
0568A:  MOVWF  FF7
0568C:  MOVLW  00
0568E:  MOVWF  FF8
05690:  MOVLW  0E
05692:  MOVLB  9
05694:  MOVWF  xC2
05696:  MOVLB  0
05698:  CALL   1BEE
0569C:  MOVFF  195,264
056A0:  MOVLW  37
056A2:  MOVLB  2
056A4:  MOVWF  x65
056A6:  MOVLB  0
056A8:  CALL   1E42
056AC:  MOVFF  194,264
056B0:  MOVLW  37
056B2:  MOVLB  2
056B4:  MOVWF  x65
056B6:  MOVLB  0
056B8:  CALL   1E42
056BC:  MOVFF  193,264
056C0:  MOVLW  37
056C2:  MOVLB  2
056C4:  MOVWF  x65
056C6:  MOVLB  0
056C8:  CALL   1E42
056CC:  MOVFF  192,264
056D0:  MOVLW  37
056D2:  MOVLB  2
056D4:  MOVWF  x65
056D6:  MOVLB  0
056D8:  CALL   1E42
056DC:  MOVLW  0D
056DE:  MOVLB  A
056E0:  MOVWF  xAD
056E2:  MOVLB  0
056E4:  CALL   1B6C
056E8:  MOVLW  0A
056EA:  MOVLB  A
056EC:  MOVWF  xAD
056EE:  MOVLB  0
056F0:  CALL   1B6C
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
056F4:  MOVLW  52
056F6:  MOVWF  FF6
056F8:  MOVLW  17
056FA:  MOVWF  FF7
056FC:  MOVLW  00
056FE:  MOVWF  FF8
05700:  MOVLW  0E
05702:  MOVLB  9
05704:  MOVWF  xC2
05706:  MOVLB  0
05708:  CALL   1BEE
0570C:  MOVFF  191,264
05710:  MOVLW  37
05712:  MOVLB  2
05714:  MOVWF  x65
05716:  MOVLB  0
05718:  CALL   1E42
0571C:  MOVFF  190,264
05720:  MOVLW  37
05722:  MOVLB  2
05724:  MOVWF  x65
05726:  MOVLB  0
05728:  CALL   1E42
0572C:  MOVLW  0D
0572E:  MOVLB  A
05730:  MOVWF  xAD
05732:  MOVLB  0
05734:  CALL   1B6C
05738:  MOVLW  0A
0573A:  MOVLB  A
0573C:  MOVWF  xAD
0573E:  MOVLB  0
05740:  CALL   1B6C
....................    
....................    piclog_make(flash_param.id, 0x00);
05744:  MOVFF  18F,1E0
05748:  MOVLB  1
0574A:  CLRF   xE1
0574C:  MOVLB  0
0574E:  CALL   3F80
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
05752:  MOVLB  1
05754:  CLRF   x96
05756:  CLRF   x97
05758:  CLRF   x98
0575A:  CLRF   x99
0575C:  CLRF   x9A
0575E:  CLRF   x9B
05760:  CLRF   x9C
05762:  CLRF   x9D
05764:  CLRF   x9E
05766:  CLRF   x9F
05768:  CLRF   xA0
0576A:  CLRF   xA1
0576C:  CLRF   xA2
0576E:  CLRF   xA3
05770:  CLRF   xA4
05772:  CLRF   xA5
05774:  CLRF   xA6
05776:  CLRF   xA7
05778:  CLRF   xA8
0577A:  CLRF   xA9
0577C:  CLRF   xAA
0577E:  CLRF   xAB
05780:  CLRF   xAC
05782:  CLRF   xAD
05784:  CLRF   xAE
05786:  CLRF   xAF
05788:  CLRF   xB0
0578A:  CLRF   xB1
0578C:  CLRF   xB2
0578E:  CLRF   xB3
05790:  CLRF   xB4
05792:  CLRF   xB5
05794:  CLRF   xB6
05796:  CLRF   xB7
05798:  CLRF   xB8
0579A:  CLRF   xB9
0579C:  CLRF   xBA
0579E:  CLRF   xBB
057A0:  CLRF   xBC
057A2:  CLRF   xBD
057A4:  CLRF   xBE
057A6:  CLRF   xBF
057A8:  CLRF   xC0
057AA:  CLRF   xC1
057AC:  CLRF   xC2
057AE:  CLRF   xC3
057B0:  CLRF   xC4
057B2:  CLRF   xC5
057B4:  CLRF   xC6
057B6:  CLRF   xC7
057B8:  CLRF   xC8
057BA:  CLRF   xC9
057BC:  CLRF   xCA
057BE:  CLRF   xCB
057C0:  CLRF   xCC
057C2:  CLRF   xCD
057C4:  CLRF   xCE
057C6:  CLRF   xCF
057C8:  CLRF   xD0
057CA:  CLRF   xD1
057CC:  CLRF   xD2
057CE:  CLRF   xD3
057D0:  CLRF   xD4
057D2:  CLRF   xD5
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
057D4:  MOVLW  68
057D6:  MOVWF  FF6
057D8:  MOVLW  17
057DA:  MOVWF  FF7
057DC:  MOVLW  00
057DE:  MOVWF  FF8
057E0:  MOVLB  0
057E2:  CALL   1BBE
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
057E6:  MOVFF  111,263
057EA:  MOVFF  110,262
057EE:  MOVFF  10F,261
057F2:  MOVFF  10E,260
057F6:  CALL   26D8
057FA:  MOVF   01,F
057FC:  BTFSS  FD8.2
057FE:  GOTO   5812
....................       fprintf(PC, "Mission Flash is not connected\r\n");
05802:  MOVLW  74
05804:  MOVWF  FF6
05806:  MOVLW  17
05808:  MOVWF  FF7
0580A:  MOVLW  00
0580C:  MOVWF  FF8
0580E:  CALL   1BBE
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
05812:  MOVLB  1
05814:  CLRF   xDD
05816:  CLRF   xDC
05818:  CLRF   xDB
0581A:  CLRF   xDA
0581C:  MOVLB  0
0581E:  MOVLB  1
05820:  MOVF   xDD,F
05822:  BTFSC  FD8.2
05824:  BRA    582C
05826:  MOVLB  0
05828:  GOTO   597A
0582C:  MOVLB  0
0582E:  MOVLB  1
05830:  MOVF   xDC,F
05832:  BTFSC  FD8.2
05834:  BRA    583C
05836:  MOVLB  0
05838:  GOTO   597A
0583C:  MOVLB  0
0583E:  MOVLB  1
05840:  MOVF   xDB,W
05842:  SUBWF  x91,W
05844:  BTFSC  FD8.0
05846:  BRA    584E
05848:  MOVLB  0
0584A:  GOTO   597A
0584E:  MOVLB  0
05850:  BTFSS  FD8.2
05852:  GOTO   5868
05856:  MOVLB  1
05858:  MOVF   x90,W
0585A:  SUBWF  xDA,W
0585C:  BTFSS  FD8.0
0585E:  BRA    5866
05860:  MOVLB  0
05862:  GOTO   597A
05866:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
05868:  MOVLB  1
0586A:  RLCF   xDA,W
0586C:  MOVWF  00
0586E:  RLCF   xDB,W
05870:  MOVWF  01
05872:  RLCF   xDC,W
05874:  MOVWF  02
05876:  RLCF   xDD,W
05878:  MOVWF  03
0587A:  RLCF   00,F
0587C:  RLCF   01,F
0587E:  RLCF   02,F
05880:  RLCF   03,F
05882:  RLCF   00,F
05884:  RLCF   01,F
05886:  RLCF   02,F
05888:  RLCF   03,F
0588A:  RLCF   00,F
0588C:  RLCF   01,F
0588E:  RLCF   02,F
05890:  RLCF   03,F
05892:  RLCF   00,F
05894:  RLCF   01,F
05896:  RLCF   02,F
05898:  RLCF   03,F
0589A:  RLCF   00,F
0589C:  RLCF   01,F
0589E:  RLCF   02,F
058A0:  RLCF   03,F
058A2:  MOVLW  C0
058A4:  ANDWF  00,F
058A6:  MOVF   00,W
058A8:  ADDWF  x92,W
058AA:  MOVWF  xD6
058AC:  MOVF   01,W
058AE:  ADDWFC x93,W
058B0:  MOVWF  xD7
058B2:  MOVF   02,W
058B4:  ADDWFC x94,W
058B6:  MOVWF  xD8
058B8:  MOVF   03,W
058BA:  ADDWFC x95,W
058BC:  MOVWF  xD9
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
058BE:  MOVFF  111,2E5
058C2:  MOVFF  110,2E4
058C6:  MOVFF  10F,2E3
058CA:  MOVFF  10E,2E2
058CE:  MOVFF  1D9,2E9
058D2:  MOVFF  1D8,2E8
058D6:  MOVFF  1D7,2E7
058DA:  MOVFF  1D6,2E6
058DE:  MOVLW  01
058E0:  MOVLB  2
058E2:  MOVWF  xEB
058E4:  MOVLW  96
058E6:  MOVWF  xEA
058E8:  CLRF   xEF
058EA:  CLRF   xEE
058EC:  CLRF   xED
058EE:  MOVLW  40
058F0:  MOVWF  xEC
058F2:  MOVLB  0
058F4:  CALL   27C4
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
058F8:  MOVLB  1
058FA:  CLRF   xDE
058FC:  MOVLB  0
058FE:  MOVLB  1
05900:  MOVF   xDE,W
05902:  SUBLW  3F
05904:  BTFSC  FD8.0
05906:  BRA    590E
05908:  MOVLB  0
0590A:  GOTO   594A
0590E:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
05910:  CLRF   03
05912:  MOVLB  1
05914:  MOVF   xDE,W
05916:  ADDLW  96
05918:  MOVWF  FE9
0591A:  MOVLW  01
0591C:  ADDWFC 03,W
0591E:  MOVWF  FEA
05920:  MOVFF  FEF,1DF
05924:  MOVFF  1DF,264
05928:  MOVLW  37
0592A:  MOVLB  2
0592C:  MOVWF  x65
0592E:  MOVLB  0
05930:  CALL   1E42
05934:  MOVLW  20
05936:  MOVLB  A
05938:  MOVWF  xAD
0593A:  MOVLB  0
0593C:  CALL   1B6C
05940:  MOVLB  1
05942:  INCF   xDE,F
05944:  MOVLB  0
05946:  GOTO   58FE
....................       }
....................       fprintf(PC,"\r\n");
0594A:  MOVLW  0D
0594C:  MOVLB  A
0594E:  MOVWF  xAD
05950:  MOVLB  0
05952:  CALL   1B6C
05956:  MOVLW  0A
05958:  MOVLB  A
0595A:  MOVWF  xAD
0595C:  MOVLB  0
0595E:  CALL   1B6C
05962:  MOVLW  01
05964:  MOVLB  1
05966:  ADDWF  xDA,F
05968:  BTFSC  FD8.0
0596A:  INCF   xDB,F
0596C:  BTFSC  FD8.2
0596E:  INCF   xDC,F
05970:  BTFSC  FD8.2
05972:  INCF   xDD,F
05974:  MOVLB  0
05976:  GOTO   581E
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
0597A:  MOVFF  18F,1E0
0597E:  MOVLB  1
05980:  SETF   xE1
05982:  MOVLB  0
05984:  CALL   3F80
....................    fprintf(PC, "End Flash Read\r\n");
05988:  MOVLW  96
0598A:  MOVWF  FF6
0598C:  MOVLW  17
0598E:  MOVWF  FF7
05990:  MOVLW  00
05992:  MOVWF  FF8
05994:  CALL   1BBE
05998:  GOTO   8FDC (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
0599C:  MOVLW  A8
0599E:  MOVWF  FF6
059A0:  MOVLW  17
059A2:  MOVWF  FF7
059A4:  MOVLW  00
059A6:  MOVWF  FF8
059A8:  CALL   1BBE
....................    flash_setting(mis_fm);
059AC:  MOVFF  111,29B
059B0:  MOVFF  110,29A
059B4:  MOVFF  10F,299
059B8:  MOVFF  10E,298
059BC:  CALL   5474
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
059C0:  MOVLB  1
059C2:  CLRF   x92
059C4:  CLRF   x91
059C6:  CLRF   x90
059C8:  CLRF   x8F
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
059CA:  MOVFF  111,2E5
059CE:  MOVFF  110,2E4
059D2:  MOVFF  10F,2E3
059D6:  MOVFF  10E,2E2
059DA:  MOVFF  192,2E9
059DE:  MOVFF  191,2E8
059E2:  MOVFF  190,2E7
059E6:  MOVFF  18F,2E6
059EA:  MOVLW  01
059EC:  MOVLB  2
059EE:  MOVWF  xEB
059F0:  MOVLW  93
059F2:  MOVWF  xEA
059F4:  CLRF   xEF
059F6:  CLRF   xEE
059F8:  CLRF   xED
059FA:  MOVLW  04
059FC:  MOVWF  xEC
059FE:  MOVLB  0
05A00:  CALL   27C4
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
05A04:  MOVLW  C4
05A06:  MOVWF  FF6
05A08:  MOVLW  17
05A0A:  MOVWF  FF7
05A0C:  MOVLW  00
05A0E:  MOVWF  FF8
05A10:  MOVLW  0B
05A12:  MOVLB  9
05A14:  MOVWF  xC2
05A16:  MOVLB  0
05A18:  CALL   1BEE
05A1C:  MOVFF  193,264
05A20:  MOVLW  37
05A22:  MOVLB  2
05A24:  MOVWF  x65
05A26:  MOVLB  0
05A28:  CALL   1E42
05A2C:  MOVLW  20
05A2E:  MOVLB  A
05A30:  MOVWF  xAD
05A32:  MOVLB  0
05A34:  CALL   1B6C
05A38:  MOVFF  194,264
05A3C:  MOVLW  37
05A3E:  MOVLB  2
05A40:  MOVWF  x65
05A42:  MOVLB  0
05A44:  CALL   1E42
05A48:  MOVLW  20
05A4A:  MOVLB  A
05A4C:  MOVWF  xAD
05A4E:  MOVLB  0
05A50:  CALL   1B6C
05A54:  MOVFF  195,264
05A58:  MOVLW  37
05A5A:  MOVLB  2
05A5C:  MOVWF  x65
05A5E:  MOVLB  0
05A60:  CALL   1E42
05A64:  MOVLW  20
05A66:  MOVLB  A
05A68:  MOVWF  xAD
05A6A:  MOVLB  0
05A6C:  CALL   1B6C
05A70:  MOVFF  196,264
05A74:  MOVLW  37
05A76:  MOVLB  2
05A78:  MOVWF  x65
05A7A:  MOVLB  0
05A7C:  CALL   1E42
05A80:  MOVLW  0D
05A82:  MOVLB  A
05A84:  MOVWF  xAD
05A86:  MOVLB  0
05A88:  CALL   1B6C
05A8C:  MOVLW  0A
05A8E:  MOVLB  A
05A90:  MOVWF  xAD
05A92:  MOVLB  0
05A94:  CALL   1B6C
....................    fprintf(PC, "End Flash Read Address\r\n");
05A98:  MOVLW  E6
05A9A:  MOVWF  FF6
05A9C:  MOVLW  17
05A9E:  MOVWF  FF7
05AA0:  MOVLW  00
05AA2:  MOVWF  FF8
05AA4:  CALL   1BBE
05AA8:  GOTO   8FEC (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
05C94:  MOVLW  00
05C96:  MOVWF  FF6
05C98:  MOVLW  18
05C9A:  MOVWF  FF7
05C9C:  MOVLW  00
05C9E:  MOVWF  FF8
05CA0:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05CA4:  MOVLB  1
05CA6:  MOVF   x8D,W
05CA8:  MOVWF  FE9
05CAA:  MOVF   x8E,W
05CAC:  MOVWF  FEA
05CAE:  MOVFF  FEF,18F
05CB2:  MOVFF  18F,1E0
05CB6:  CLRF   xE1
05CB8:  MOVLB  0
05CBA:  CALL   3F80
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
05CBE:  MOVFF  18E,190
05CC2:  MOVFF  18D,18F
05CC6:  CALL   47D8
....................    mode_misf_address_reset(parameter); // Reset the address area
05CCA:  MOVFF  18E,190
05CCE:  MOVFF  18D,18F
05CD2:  GOTO   5AAC
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
05CD6:  MOVLW  1E
05CD8:  MOVWF  FF6
05CDA:  MOVLW  18
05CDC:  MOVWF  FF7
05CDE:  MOVLW  00
05CE0:  MOVWF  FF8
05CE2:  CALL   1BBE
05CE6:  GOTO   8FFC (RETURN)
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
05CEA:  MOVLW  3A
05CEC:  MOVWF  FF6
05CEE:  MOVLW  18
05CF0:  MOVWF  FF7
05CF2:  MOVLW  00
05CF4:  MOVWF  FF8
05CF6:  CALL   1BBE
....................    flash_setting(mis_fm);
05CFA:  MOVFF  111,29B
05CFE:  MOVFF  110,29A
05D02:  MOVFF  10F,299
05D06:  MOVFF  10E,298
05D0A:  CALL   5474
....................    flash_setting(smf);
05D0E:  MOVFF  115,29B
05D12:  MOVFF  114,29A
05D16:  MOVFF  113,299
05D1A:  MOVFF  112,298
05D1E:  CALL   5474
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
05D22:  MOVLB  1
05D24:  MOVF   x8D,W
05D26:  MOVWF  FE9
05D28:  MOVF   x8E,W
05D2A:  MOVWF  FEA
05D2C:  MOVFF  FEF,18F
05D30:  CLRF   x93
05D32:  CLRF   x92
05D34:  CLRF   x91
05D36:  CLRF   x90
05D38:  CLRF   x97
05D3A:  CLRF   x96
05D3C:  MOVLW  10
05D3E:  MOVWF  x95
05D40:  CLRF   x94
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
05D42:  MOVFF  111,2E5
05D46:  MOVFF  110,2E4
05D4A:  MOVFF  10F,2E3
05D4E:  MOVFF  10E,2E2
05D52:  MOVFF  193,2E9
05D56:  MOVFF  192,2E8
05D5A:  MOVFF  191,2E7
05D5E:  MOVFF  190,2E6
05D62:  MOVLW  01
05D64:  MOVLB  2
05D66:  MOVWF  xEB
05D68:  MOVLW  98
05D6A:  MOVWF  xEA
05D6C:  CLRF   xEF
05D6E:  CLRF   xEE
05D70:  MOVLW  01
05D72:  MOVWF  xED
05D74:  CLRF   xEC
05D76:  MOVLB  0
05D78:  CALL   27C4
....................    write_data_bytes(smf, dest_address, read_data, 256);
05D7C:  MOVFF  115,A59
05D80:  MOVFF  114,A58
05D84:  MOVFF  113,A57
05D88:  MOVFF  112,A56
05D8C:  MOVFF  197,A5D
05D90:  MOVFF  196,A5C
05D94:  MOVFF  195,A5B
05D98:  MOVFF  194,A5A
05D9C:  MOVLW  01
05D9E:  MOVLB  A
05DA0:  MOVWF  x5F
05DA2:  MOVLW  98
05DA4:  MOVWF  x5E
05DA6:  MOVLW  01
05DA8:  MOVWF  x61
05DAA:  CLRF   x60
05DAC:  MOVLB  0
05DAE:  CALL   34D6
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
05DB2:  MOVLW  52
05DB4:  MOVWF  FF6
05DB6:  MOVLW  18
05DB8:  MOVWF  FF7
05DBA:  MOVLW  00
05DBC:  MOVWF  FF8
05DBE:  CALL   1BBE
05DC2:  GOTO   900C (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
05DC6:  MOVLW  68
05DC8:  MOVWF  FF6
05DCA:  MOVLW  18
05DCC:  MOVWF  FF7
05DCE:  MOVLW  00
05DD0:  MOVWF  FF8
05DD2:  CALL   1BBE
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
05DD6:  MOVFF  115,2E5
05DDA:  MOVFF  114,2E4
05DDE:  MOVFF  113,2E3
05DE2:  MOVFF  112,2E2
05DE6:  MOVLB  2
05DE8:  CLRF   xE9
05DEA:  CLRF   xE8
05DEC:  MOVLW  01
05DEE:  MOVWF  xE7
05DF0:  MOVLW  8F
05DF2:  MOVWF  xE6
05DF4:  MOVLW  01
05DF6:  MOVWF  xEB
05DF8:  MOVLW  8F
05DFA:  MOVWF  xEA
05DFC:  CLRF   xEF
05DFE:  CLRF   xEE
05E00:  CLRF   xED
05E02:  MOVLW  40
05E04:  MOVWF  xEC
05E06:  MOVLB  0
05E08:  CALL   27C4
....................    fprintf(PC, "Read Data: ");
05E0C:  MOVLW  80
05E0E:  MOVWF  FF6
05E10:  MOVLW  18
05E12:  MOVWF  FF7
05E14:  MOVLW  00
05E16:  MOVWF  FF8
05E18:  CALL   1BBE
....................    for (int i = 0; i < PACKET_SIZE; i++)
05E1C:  MOVLB  1
05E1E:  CLRF   xCF
05E20:  MOVLB  0
05E22:  MOVLB  1
05E24:  MOVF   xCF,W
05E26:  SUBLW  3F
05E28:  BTFSC  FD8.0
05E2A:  BRA    5E32
05E2C:  MOVLB  0
05E2E:  GOTO   5E6E
05E32:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
05E34:  CLRF   03
05E36:  MOVLB  1
05E38:  MOVF   xCF,W
05E3A:  ADDLW  8F
05E3C:  MOVWF  FE9
05E3E:  MOVLW  01
05E40:  ADDWFC 03,W
05E42:  MOVWF  FEA
05E44:  MOVFF  FEF,1D0
05E48:  MOVFF  1D0,264
05E4C:  MOVLW  37
05E4E:  MOVLB  2
05E50:  MOVWF  x65
05E52:  MOVLB  0
05E54:  CALL   1E42
05E58:  MOVLW  20
05E5A:  MOVLB  A
05E5C:  MOVWF  xAD
05E5E:  MOVLB  0
05E60:  CALL   1B6C
05E64:  MOVLB  1
05E66:  INCF   xCF,F
05E68:  MOVLB  0
05E6A:  GOTO   5E22
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
05E6E:  MOVLW  8C
05E70:  MOVWF  FF6
05E72:  MOVLW  18
05E74:  MOVWF  FF7
05E76:  MOVLW  00
05E78:  MOVWF  FF8
05E7A:  CALL   1BBE
05E7E:  GOTO   901C (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
05E82:  MOVLW  A4
05E84:  MOVWF  FF6
05E86:  MOVLW  18
05E88:  MOVWF  FF7
05E8A:  MOVLW  00
05E8C:  MOVWF  FF8
05E8E:  CALL   1BBE
....................    flash_setting(smf);
05E92:  MOVFF  115,29B
05E96:  MOVFF  114,29A
05E9A:  MOVFF  113,299
05E9E:  MOVFF  112,298
05EA2:  CALL   5474
....................    unsigned int32 erase_address = 0x00000000; // Example address
05EA6:  MOVLB  1
05EA8:  CLRF   x92
05EAA:  CLRF   x91
05EAC:  CLRF   x90
05EAE:  CLRF   x8F
....................    sector_erase(smf, erase_address); // Erase the sector
05EB0:  MOVFF  115,A59
05EB4:  MOVFF  114,A58
05EB8:  MOVFF  113,A57
05EBC:  MOVFF  112,A56
05EC0:  MOVFF  192,A5D
05EC4:  MOVFF  191,A5C
05EC8:  MOVFF  190,A5B
05ECC:  MOVFF  18F,A5A
05ED0:  MOVLB  0
05ED2:  CALL   3BB2
....................    fprintf(PC, "End Flash SMF Erase\r\n");
05ED6:  MOVLW  BC
05ED8:  MOVWF  FF6
05EDA:  MOVLW  18
05EDC:  MOVWF  FF7
05EDE:  MOVLW  00
05EE0:  MOVWF  FF8
05EE2:  CALL   1BBE
05EE6:  GOTO   902C (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
05AAC:  MOVLW  D2
05AAE:  MOVWF  FF6
05AB0:  MOVLW  18
05AB2:  MOVWF  FF7
05AB4:  MOVLW  00
05AB6:  MOVWF  FF8
05AB8:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); 
05ABC:  MOVLB  1
05ABE:  MOVF   x8F,W
05AC0:  MOVWF  FE9
05AC2:  MOVF   x90,W
05AC4:  MOVWF  FEA
05AC6:  MOVFF  FEF,1D3
05ACA:  MOVFF  1D3,1E0
05ACE:  CLRF   xE1
05AD0:  MOVLB  0
05AD2:  CALL   3F80
....................    FlashData_t flash_data;
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
05AD6:  MOVLW  01
05AD8:  MOVWF  FEA
05ADA:  MOVLW  91
05ADC:  MOVWF  FE9
05ADE:  CLRF   00
05AE0:  CLRF   02
05AE2:  MOVLW  40
05AE4:  MOVWF  01
05AE6:  CALL   27A0
....................    /*
....................    for (int i = 0; i < PACKET_SIZE; i++) {
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
....................    }
....................    */
....................    fprintf(PC, "\r\n");
05AEA:  MOVLW  0D
05AEC:  MOVLB  A
05AEE:  MOVWF  xAD
05AF0:  MOVLB  0
05AF2:  CALL   1B6C
05AF6:  MOVLW  0A
05AF8:  MOVLB  A
05AFA:  MOVWF  xAD
05AFC:  MOVLB  0
05AFE:  CALL   1B6C
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
05B02:  MOVLW  01
05B04:  MOVLB  A
05B06:  MOVWF  xAE
05B08:  MOVLW  91
05B0A:  MOVWF  xAD
05B0C:  MOVLW  3F
05B0E:  MOVWF  xAF
05B10:  MOVLB  0
05B12:  CALL   29DC
05B16:  MOVFF  01,1D0
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05B1A:  MOVLB  1
05B1C:  CLRF   xD1
05B1E:  MOVLB  0
05B20:  MOVLB  1
05B22:  MOVF   xD1,W
05B24:  SUBLW  3F
05B26:  BTFSC  FD8.0
05B28:  BRA    5B30
05B2A:  MOVLB  0
05B2C:  GOTO   5B6C
05B30:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
05B32:  CLRF   03
05B34:  MOVLB  1
05B36:  MOVF   xD1,W
05B38:  ADDLW  91
05B3A:  MOVWF  FE9
05B3C:  MOVLW  01
05B3E:  ADDWFC 03,W
05B40:  MOVWF  FEA
05B42:  MOVFF  FEF,1D3
05B46:  MOVFF  1D3,264
05B4A:  MOVLW  37
05B4C:  MOVLB  2
05B4E:  MOVWF  x65
05B50:  MOVLB  0
05B52:  CALL   1E42
05B56:  MOVLW  20
05B58:  MOVLB  A
05B5A:  MOVWF  xAD
05B5C:  MOVLB  0
05B5E:  CALL   1B6C
05B62:  MOVLB  1
05B64:  INCF   xD1,F
05B66:  MOVLB  0
05B68:  GOTO   5B20
....................    }
....................    fprintf(PC, "\r\n");
05B6C:  MOVLW  0D
05B6E:  MOVLB  A
05B70:  MOVWF  xAD
05B72:  MOVLB  0
05B74:  CALL   1B6C
05B78:  MOVLW  0A
05B7A:  MOVLB  A
05B7C:  MOVWF  xAD
05B7E:  MOVLB  0
05B80:  CALL   1B6C
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
05B84:  MOVFF  111,A59
05B88:  MOVFF  110,A58
05B8C:  MOVFF  10F,A57
05B90:  MOVFF  10E,A56
05B94:  MOVLB  A
05B96:  CLRF   x5D
05B98:  CLRF   x5C
05B9A:  CLRF   x5B
05B9C:  CLRF   x5A
05B9E:  MOVLW  01
05BA0:  MOVWF  x5F
05BA2:  MOVLW  91
05BA4:  MOVWF  x5E
05BA6:  CLRF   x61
05BA8:  MOVLW  40
05BAA:  MOVWF  x60
05BAC:  MOVLB  0
05BAE:  CALL   34D6
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
05BB2:  MOVLW  01
05BB4:  MOVWF  FEA
05BB6:  MOVLW  91
05BB8:  MOVWF  FE9
05BBA:  CLRF   00
05BBC:  CLRF   02
05BBE:  MOVLW  40
05BC0:  MOVWF  01
05BC2:  CALL   27A0
....................    read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
05BC6:  MOVFF  111,2E5
05BCA:  MOVFF  110,2E4
05BCE:  MOVFF  10F,2E3
05BD2:  MOVFF  10E,2E2
05BD6:  MOVLB  2
05BD8:  CLRF   xE9
05BDA:  CLRF   xE8
05BDC:  CLRF   xE7
05BDE:  CLRF   xE6
05BE0:  MOVLW  01
05BE2:  MOVWF  xEB
05BE4:  MOVLW  91
05BE6:  MOVWF  xEA
05BE8:  CLRF   xEF
05BEA:  CLRF   xEE
05BEC:  CLRF   xED
05BEE:  MOVLW  40
05BF0:  MOVWF  xEC
05BF2:  MOVLB  0
05BF4:  CALL   27C4
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
05BF8:  MOVLW  01
05BFA:  MOVLB  A
05BFC:  MOVWF  xAE
05BFE:  MOVLW  91
05C00:  MOVWF  xAD
05C02:  MOVLW  3F
05C04:  MOVWF  xAF
05C06:  MOVLB  0
05C08:  CALL   29DC
05C0C:  MOVFF  01,1D0
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05C10:  MOVLB  1
05C12:  CLRF   xD2
05C14:  MOVLB  0
05C16:  MOVLB  1
05C18:  MOVF   xD2,W
05C1A:  SUBLW  3F
05C1C:  BTFSC  FD8.0
05C1E:  BRA    5C26
05C20:  MOVLB  0
05C22:  GOTO   5C62
05C26:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
05C28:  CLRF   03
05C2A:  MOVLB  1
05C2C:  MOVF   xD2,W
05C2E:  ADDLW  91
05C30:  MOVWF  FE9
05C32:  MOVLW  01
05C34:  ADDWFC 03,W
05C36:  MOVWF  FEA
05C38:  MOVFF  FEF,1D3
05C3C:  MOVFF  1D3,264
05C40:  MOVLW  37
05C42:  MOVLB  2
05C44:  MOVWF  x65
05C46:  MOVLB  0
05C48:  CALL   1E42
05C4C:  MOVLW  20
05C4E:  MOVLB  A
05C50:  MOVWF  xAD
05C52:  MOVLB  0
05C54:  CALL   1B6C
05C58:  MOVLB  1
05C5A:  INCF   xD2,F
05C5C:  MOVLB  0
05C5E:  GOTO   5C16
....................    }
....................    misf_init(); // Update the address area after writing
05C62:  CALL   2FDC
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05C66:  MOVLB  1
05C68:  MOVF   x8F,W
05C6A:  MOVWF  FE9
05C6C:  MOVF   x90,W
05C6E:  MOVWF  FEA
05C70:  MOVFF  FEF,1D3
05C74:  MOVFF  1D3,1E0
05C78:  SETF   xE1
05C7A:  MOVLB  0
05C7C:  CALL   3F80
....................    fprintf(PC, "End Flash Address Reset\r\n");
05C80:  MOVLW  EE
05C82:  MOVWF  FF6
05C84:  MOVLW  18
05C86:  MOVWF  FF7
05C88:  MOVLW  00
05C8A:  MOVWF  FF8
05C8C:  CALL   1BBE
05C90:  GOTO   5CD6 (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
06130:  MOVLW  01
06132:  MOVLB  1
06134:  ADDWF  x8D,W
06136:  MOVWF  FE9
06138:  MOVLW  00
0613A:  ADDWFC x8E,W
0613C:  MOVWF  FEA
0613E:  MOVF   FEF,W
06140:  CLRF   xDF
06142:  CLRF   xDE
06144:  CLRF   xDD
06146:  MOVWF  xDC
06148:  MOVFF  1DC,1DF
0614C:  CLRF   xDC
0614E:  CLRF   xDD
06150:  CLRF   xDE
06152:  MOVLW  02
06154:  ADDWF  x8D,W
06156:  MOVWF  FE9
06158:  MOVLW  00
0615A:  ADDWFC x8E,W
0615C:  MOVWF  FEA
0615E:  MOVF   FEF,W
06160:  CLRF   xE4
06162:  CLRF   xE3
06164:  CLRF   xE2
06166:  MOVWF  xE1
06168:  MOVFF  1E2,03
0616C:  MOVFF  1E1,02
06170:  CLRF   00
06172:  CLRF   01
06174:  MOVF   00,W
06176:  IORWF  xDC,F
06178:  MOVF   01,W
0617A:  IORWF  xDD,F
0617C:  MOVF   02,W
0617E:  IORWF  xDE,F
06180:  MOVF   03,W
06182:  IORWF  xDF,F
06184:  MOVLW  03
06186:  ADDWF  x8D,W
06188:  MOVWF  FE9
0618A:  MOVLW  00
0618C:  ADDWFC x8E,W
0618E:  MOVWF  FEA
06190:  MOVF   FEF,W
06192:  CLRF   xE4
06194:  CLRF   xE3
06196:  CLRF   xE2
06198:  MOVWF  xE1
0619A:  MOVFF  1E3,03
0619E:  MOVFF  1E2,02
061A2:  MOVFF  1E1,01
061A6:  CLRF   00
061A8:  MOVF   00,W
061AA:  IORWF  xDC,F
061AC:  MOVF   01,W
061AE:  IORWF  xDD,F
061B0:  MOVF   02,W
061B2:  IORWF  xDE,F
061B4:  MOVF   03,W
061B6:  IORWF  xDF,F
061B8:  MOVLW  04
061BA:  ADDWF  x8D,W
061BC:  MOVWF  FE9
061BE:  MOVLW  00
061C0:  ADDWFC x8E,W
061C2:  MOVWF  FEA
061C4:  MOVF   FEF,W
061C6:  MOVWF  00
061C8:  CLRF   01
061CA:  CLRF   02
061CC:  CLRF   03
061CE:  MOVF   00,W
061D0:  IORWF  xDC,W
061D2:  MOVWF  x8F
061D4:  MOVF   01,W
061D6:  IORWF  xDD,W
061D8:  MOVWF  x90
061DA:  MOVF   02,W
061DC:  IORWF  xDE,W
061DE:  MOVWF  x91
061E0:  MOVF   03,W
061E2:  IORWF  xDF,W
061E4:  MOVWF  x92
061E6:  MOVLW  07
061E8:  ADDWF  x8D,W
061EA:  MOVWF  FE9
061EC:  MOVLW  00
061EE:  ADDWFC x8E,W
061F0:  MOVWF  FEA
061F2:  MOVF   FEF,W
061F4:  CLRF   xDD
061F6:  MOVWF  xDC
061F8:  MOVFF  1DC,1DD
061FC:  CLRF   xDC
061FE:  MOVLW  08
06200:  ADDWF  x8D,W
06202:  MOVWF  FE9
06204:  MOVLW  00
06206:  ADDWFC x8E,W
06208:  MOVWF  FEA
0620A:  MOVF   FEF,W
0620C:  CLRF   03
0620E:  IORWF  xDC,W
06210:  MOVWF  x93
06212:  MOVF   03,W
06214:  IORWF  xDD,W
06216:  MOVWF  x94
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
06218:  CLRF   x95
0621A:  CLRF   x96
0621C:  CLRF   x97
0621E:  CLRF   x98
06220:  CLRF   x99
06222:  CLRF   x9A
06224:  CLRF   x9B
06226:  CLRF   x9C
06228:  CLRF   x9D
0622A:  CLRF   x9E
0622C:  CLRF   x9F
0622E:  CLRF   xA0
06230:  CLRF   xA1
06232:  CLRF   xA2
06234:  CLRF   xA3
06236:  CLRF   xA4
06238:  CLRF   xA5
0623A:  CLRF   xA6
0623C:  CLRF   xA7
0623E:  CLRF   xA8
06240:  CLRF   xA9
06242:  CLRF   xAA
06244:  CLRF   xAB
06246:  CLRF   xAC
06248:  CLRF   xAD
0624A:  CLRF   xAE
0624C:  CLRF   xAF
0624E:  CLRF   xB0
06250:  CLRF   xB1
06252:  CLRF   xB2
06254:  CLRF   xB3
06256:  CLRF   xB4
06258:  CLRF   xB5
0625A:  CLRF   xB6
0625C:  CLRF   xB7
0625E:  CLRF   xB8
06260:  CLRF   xB9
06262:  CLRF   xBA
06264:  CLRF   xBB
06266:  CLRF   xBC
06268:  CLRF   xBD
0626A:  CLRF   xBE
0626C:  CLRF   xBF
0626E:  CLRF   xC0
06270:  CLRF   xC1
06272:  CLRF   xC2
06274:  CLRF   xC3
06276:  CLRF   xC4
06278:  CLRF   xC5
0627A:  CLRF   xC6
0627C:  CLRF   xC7
0627E:  CLRF   xC8
06280:  CLRF   xC9
06282:  CLRF   xCA
06284:  CLRF   xCB
06286:  CLRF   xCC
06288:  CLRF   xCD
0628A:  CLRF   xCE
0628C:  CLRF   xCF
0628E:  CLRF   xD0
06290:  CLRF   xD1
06292:  CLRF   xD2
06294:  CLRF   xD3
06296:  CLRF   xD4
....................    if(!is_connect(smf)) {
06298:  MOVFF  115,263
0629C:  MOVFF  114,262
062A0:  MOVFF  113,261
062A4:  MOVFF  112,260
062A8:  MOVLB  0
062AA:  CALL   26D8
062AE:  MOVF   01,F
062B0:  BTFSS  FD8.2
062B2:  GOTO   62CA
....................       printf("SMF is not connected\r\n");
062B6:  MOVLW  08
062B8:  MOVWF  FF6
062BA:  MOVLW  19
062BC:  MOVWF  FF7
062BE:  MOVLW  00
062C0:  MOVWF  FF8
062C2:  CALL   1BBE
....................       return;
062C6:  GOTO   650E
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
062CA:  MOVLW  20
062CC:  MOVWF  FF6
062CE:  MOVLW  19
062D0:  MOVWF  FF7
062D2:  MOVLW  00
062D4:  MOVWF  FF8
062D6:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
062DA:  MOVLB  1
062DC:  MOVF   x8D,W
062DE:  MOVWF  FE9
062E0:  MOVF   x8E,W
062E2:  MOVWF  FEA
062E4:  MOVFF  FEF,1DC
062E8:  MOVFF  1DC,1E0
062EC:  CLRF   xE1
062EE:  MOVLB  0
062F0:  CALL   3F80
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
062F4:  MOVLW  3E
062F6:  MOVWF  FF6
062F8:  MOVLW  19
062FA:  MOVWF  FF7
062FC:  MOVLW  00
062FE:  MOVWF  FF8
06300:  MOVLW  0E
06302:  MOVLB  9
06304:  MOVWF  xC2
06306:  MOVLB  0
06308:  CALL   1BEE
0630C:  MOVFF  192,264
06310:  MOVLW  37
06312:  MOVLB  2
06314:  MOVWF  x65
06316:  MOVLB  0
06318:  CALL   1E42
0631C:  MOVFF  191,264
06320:  MOVLW  37
06322:  MOVLB  2
06324:  MOVWF  x65
06326:  MOVLB  0
06328:  CALL   1E42
0632C:  MOVFF  190,264
06330:  MOVLW  37
06332:  MOVLB  2
06334:  MOVWF  x65
06336:  MOVLB  0
06338:  CALL   1E42
0633C:  MOVFF  18F,264
06340:  MOVLW  37
06342:  MOVLB  2
06344:  MOVWF  x65
06346:  MOVLB  0
06348:  CALL   1E42
0634C:  MOVLW  0D
0634E:  MOVLB  A
06350:  MOVWF  xAD
06352:  MOVLB  0
06354:  CALL   1B6C
06358:  MOVLW  0A
0635A:  MOVLB  A
0635C:  MOVWF  xAD
0635E:  MOVLB  0
06360:  CALL   1B6C
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
06364:  MOVLW  54
06366:  MOVWF  FF6
06368:  MOVLW  19
0636A:  MOVWF  FF7
0636C:  MOVLW  00
0636E:  MOVWF  FF8
06370:  MOVLW  0E
06372:  MOVLB  9
06374:  MOVWF  xC2
06376:  MOVLB  0
06378:  CALL   1BEE
0637C:  MOVFF  194,264
06380:  MOVLW  37
06382:  MOVLB  2
06384:  MOVWF  x65
06386:  MOVLB  0
06388:  CALL   1E42
0638C:  MOVFF  193,264
06390:  MOVLW  37
06392:  MOVLB  2
06394:  MOVWF  x65
06396:  MOVLB  0
06398:  CALL   1E42
0639C:  MOVLW  0D
0639E:  MOVLB  A
063A0:  MOVWF  xAD
063A2:  MOVLB  0
063A4:  CALL   1B6C
063A8:  MOVLW  0A
063AA:  MOVLB  A
063AC:  MOVWF  xAD
063AE:  MOVLB  0
063B0:  CALL   1B6C
....................    printf("read data\r\n");
063B4:  MOVLW  6A
063B6:  MOVWF  FF6
063B8:  MOVLW  19
063BA:  MOVWF  FF7
063BC:  MOVLW  00
063BE:  MOVWF  FF8
063C0:  CALL   1BBE
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
063C4:  MOVLB  1
063C6:  CLRF   xD6
063C8:  CLRF   xD5
063CA:  MOVLB  0
063CC:  MOVLB  1
063CE:  MOVF   xD6,W
063D0:  SUBWF  x94,W
063D2:  BTFSC  FD8.0
063D4:  BRA    63DC
063D6:  MOVLB  0
063D8:  GOTO   64E4
063DC:  MOVLB  0
063DE:  BTFSS  FD8.2
063E0:  GOTO   63F6
063E4:  MOVLB  1
063E6:  MOVF   x93,W
063E8:  SUBWF  xD5,W
063EA:  BTFSS  FD8.0
063EC:  BRA    63F4
063EE:  MOVLB  0
063F0:  GOTO   64E4
063F4:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
063F6:  MOVLB  1
063F8:  RLCF   xD5,W
063FA:  MOVWF  02
063FC:  RLCF   xD6,W
063FE:  MOVWF  03
06400:  RLCF   02,F
06402:  RLCF   03,F
06404:  RLCF   02,F
06406:  RLCF   03,F
06408:  RLCF   02,F
0640A:  RLCF   03,F
0640C:  RLCF   02,F
0640E:  RLCF   03,F
06410:  RLCF   02,F
06412:  RLCF   03,F
06414:  MOVLW  C0
06416:  ANDWF  02,F
06418:  MOVF   02,W
0641A:  ADDWF  x8F,W
0641C:  MOVWF  xD7
0641E:  MOVF   03,W
06420:  ADDWFC x90,W
06422:  MOVWF  xD8
06424:  MOVLW  00
06426:  ADDWFC x91,W
06428:  MOVWF  xD9
0642A:  MOVLW  00
0642C:  ADDWFC x92,W
0642E:  MOVWF  xDA
06430:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
06432:  MOVFF  115,2E5
06436:  MOVFF  114,2E4
0643A:  MOVFF  113,2E3
0643E:  MOVFF  112,2E2
06442:  MOVFF  1DA,2E9
06446:  MOVFF  1D9,2E8
0644A:  MOVFF  1D8,2E7
0644E:  MOVFF  1D7,2E6
06452:  MOVLW  01
06454:  MOVLB  2
06456:  MOVWF  xEB
06458:  MOVLW  95
0645A:  MOVWF  xEA
0645C:  CLRF   xEF
0645E:  CLRF   xEE
06460:  CLRF   xED
06462:  MOVLW  40
06464:  MOVWF  xEC
06466:  MOVLB  0
06468:  CALL   27C4
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
0646C:  MOVLB  1
0646E:  CLRF   xDB
06470:  MOVLB  0
06472:  MOVLB  1
06474:  MOVF   xDB,W
06476:  SUBLW  3F
06478:  BTFSC  FD8.0
0647A:  BRA    6482
0647C:  MOVLB  0
0647E:  GOTO   64BE
06482:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
06484:  CLRF   03
06486:  MOVLB  1
06488:  MOVF   xDB,W
0648A:  ADDLW  95
0648C:  MOVWF  FE9
0648E:  MOVLW  01
06490:  ADDWFC 03,W
06492:  MOVWF  FEA
06494:  MOVFF  FEF,1DC
06498:  MOVFF  1DC,264
0649C:  MOVLW  37
0649E:  MOVLB  2
064A0:  MOVWF  x65
064A2:  MOVLB  0
064A4:  CALL   1E42
064A8:  MOVLW  20
064AA:  MOVLB  A
064AC:  MOVWF  xAD
064AE:  MOVLB  0
064B0:  CALL   1B6C
064B4:  MOVLB  1
064B6:  INCF   xDB,F
064B8:  MOVLB  0
064BA:  GOTO   6472
....................       }
....................       printf("\r\n");
064BE:  MOVLW  0D
064C0:  MOVLB  A
064C2:  MOVWF  xAD
064C4:  MOVLB  0
064C6:  CALL   1B6C
064CA:  MOVLW  0A
064CC:  MOVLB  A
064CE:  MOVWF  xAD
064D0:  MOVLB  0
064D2:  CALL   1B6C
064D6:  MOVLB  1
064D8:  INCF   xD5,F
064DA:  BTFSC  FD8.2
064DC:  INCF   xD6,F
064DE:  MOVLB  0
064E0:  GOTO   63CC
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
064E4:  MOVLW  76
064E6:  MOVWF  FF6
064E8:  MOVLW  19
064EA:  MOVWF  FF7
064EC:  MOVLW  00
064EE:  MOVWF  FF8
064F0:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
064F4:  MOVLB  1
064F6:  MOVF   x8D,W
064F8:  MOVWF  FE9
064FA:  MOVF   x8E,W
064FC:  MOVWF  FEA
064FE:  MOVFF  FEF,1DC
06502:  MOVFF  1DC,1E0
06506:  SETF   xE1
06508:  MOVLB  0
0650A:  CALL   3F80
0650E:  GOTO   904C (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
06512:  MOVLW  94
06514:  MOVWF  FF6
06516:  MOVLW  19
06518:  MOVWF  FF7
0651A:  MOVLW  00
0651C:  MOVWF  FF8
0651E:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
06522:  MOVLB  1
06524:  MOVF   x8D,W
06526:  MOVWF  FE9
06528:  MOVF   x8E,W
0652A:  MOVWF  FEA
0652C:  MOVFF  FEF,18F
....................    piclog_make(cmd, 0x00); // Log the command execution
06530:  MOVFF  18F,1E0
06534:  CLRF   xE1
06536:  MOVLB  0
06538:  CALL   3F80
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
0653C:  MOVLW  06
0653E:  MOVLB  1
06540:  MOVWF  x93
06542:  MOVLW  AA
06544:  MOVWF  x92
06546:  CLRF   x91
06548:  CLRF   x90
0654A:  MOVLB  0
0654C:  MOVLB  1
0654E:  MOVF   x93,W
06550:  SUBLW  06
06552:  BTFSC  FD8.0
06554:  BRA    655C
06556:  MOVLB  0
06558:  GOTO   65DA
0655C:  MOVLB  0
0655E:  BTFSS  FD8.2
06560:  GOTO   65A6
06564:  MOVLB  1
06566:  MOVF   x92,W
06568:  SUBLW  AA
0656A:  BTFSC  FD8.0
0656C:  BRA    6574
0656E:  MOVLB  0
06570:  GOTO   65DA
06574:  MOVLB  0
06576:  BTFSS  FD8.2
06578:  GOTO   65A6
0657C:  MOVLB  1
0657E:  MOVF   x91,W
06580:  SUBLW  1F
06582:  BTFSC  FD8.0
06584:  BRA    658C
06586:  MOVLB  0
06588:  GOTO   65DA
0658C:  MOVLB  0
0658E:  BTFSS  FD8.2
06590:  GOTO   65A6
06594:  MOVLB  1
06596:  MOVF   x90,W
06598:  SUBLW  FE
0659A:  BTFSC  FD8.0
0659C:  BRA    65A4
0659E:  MOVLB  0
065A0:  GOTO   65DA
065A4:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
065A6:  MOVFF  115,A59
065AA:  MOVFF  114,A58
065AE:  MOVFF  113,A57
065B2:  MOVFF  112,A56
065B6:  MOVFF  193,A5D
065BA:  MOVFF  192,A5C
065BE:  MOVFF  191,A5B
065C2:  MOVFF  190,A5A
065C6:  CALL   3BB2
065CA:  MOVLW  01
065CC:  MOVLB  1
065CE:  ADDWF  x92,F
065D0:  MOVLW  00
065D2:  ADDWFC x93,F
065D4:  MOVLB  0
065D6:  GOTO   654C
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
065DA:  MOVFF  18F,1E0
065DE:  MOVLB  1
065E0:  SETF   xE1
065E2:  MOVLB  0
065E4:  CALL   3F80
....................    printf("End SMF Erase All\r\n");
065E8:  MOVLW  AA
065EA:  MOVWF  FF6
065EC:  MOVLW  19
065EE:  MOVWF  FF7
065F0:  MOVLW  00
065F2:  MOVWF  FF8
065F4:  CALL   1BBE
065F8:  GOTO   905C (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
05FB8:  MOVLW  BE
05FBA:  MOVWF  FF6
05FBC:  MOVLW  19
05FBE:  MOVWF  FF7
05FC0:  MOVLW  00
05FC2:  MOVWF  FF8
05FC4:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
05FC8:  MOVLB  1
05FCA:  MOVF   x8D,W
05FCC:  MOVWF  FE9
05FCE:  MOVF   x8E,W
05FD0:  MOVWF  FEA
05FD2:  MOVFF  FEF,1D3
05FD6:  MOVFF  1D3,1E0
05FDA:  CLRF   xE1
05FDC:  MOVLB  0
05FDE:  CALL   3F80
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
05FE2:  MOVLB  1
05FE4:  CLRF   x8F
05FE6:  CLRF   x90
05FE8:  CLRF   x91
05FEA:  CLRF   x92
05FEC:  CLRF   x93
05FEE:  CLRF   x94
05FF0:  CLRF   x95
05FF2:  CLRF   x96
05FF4:  CLRF   x97
05FF6:  CLRF   x98
05FF8:  CLRF   x99
05FFA:  CLRF   x9A
05FFC:  CLRF   x9B
05FFE:  CLRF   x9C
06000:  CLRF   x9D
06002:  CLRF   x9E
06004:  CLRF   x9F
06006:  CLRF   xA0
06008:  CLRF   xA1
0600A:  CLRF   xA2
0600C:  CLRF   xA3
0600E:  CLRF   xA4
06010:  CLRF   xA5
06012:  CLRF   xA6
06014:  CLRF   xA7
06016:  CLRF   xA8
06018:  CLRF   xA9
0601A:  CLRF   xAA
0601C:  CLRF   xAB
0601E:  CLRF   xAC
06020:  CLRF   xAD
06022:  CLRF   xAE
06024:  CLRF   xAF
06026:  CLRF   xB0
06028:  CLRF   xB1
0602A:  CLRF   xB2
0602C:  CLRF   xB3
0602E:  CLRF   xB4
06030:  CLRF   xB5
06032:  CLRF   xB6
06034:  CLRF   xB7
06036:  CLRF   xB8
06038:  CLRF   xB9
0603A:  CLRF   xBA
0603C:  CLRF   xBB
0603E:  CLRF   xBC
06040:  CLRF   xBD
06042:  CLRF   xBE
06044:  CLRF   xBF
06046:  CLRF   xC0
06048:  CLRF   xC1
0604A:  CLRF   xC2
0604C:  CLRF   xC3
0604E:  CLRF   xC4
06050:  CLRF   xC5
06052:  CLRF   xC6
06054:  CLRF   xC7
06056:  CLRF   xC8
06058:  CLRF   xC9
0605A:  CLRF   xCA
0605C:  CLRF   xCB
0605E:  CLRF   xCC
06060:  CLRF   xCD
06062:  CLRF   xCE
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_IV2_DATA_END_ADDRESS; address += SECTOR_64K_BYTE) {
06064:  MOVLW  06
06066:  MOVWF  xD2
06068:  MOVLW  AA
0606A:  MOVWF  xD1
0606C:  CLRF   xD0
0606E:  CLRF   xCF
06070:  MOVLB  0
06072:  MOVLB  1
06074:  MOVF   xD2,W
06076:  SUBLW  07
06078:  BTFSC  FD8.0
0607A:  BRA    6082
0607C:  MOVLB  0
0607E:  GOTO   6100
06082:  MOVLB  0
06084:  BTFSS  FD8.2
06086:  GOTO   60CC
0608A:  MOVLB  1
0608C:  MOVF   xD1,W
0608E:  SUBLW  48
06090:  BTFSC  FD8.0
06092:  BRA    609A
06094:  MOVLB  0
06096:  GOTO   6100
0609A:  MOVLB  0
0609C:  BTFSS  FD8.2
0609E:  GOTO   60CC
060A2:  MOVLB  1
060A4:  MOVF   xD0,W
060A6:  SUBLW  3F
060A8:  BTFSC  FD8.0
060AA:  BRA    60B2
060AC:  MOVLB  0
060AE:  GOTO   6100
060B2:  MOVLB  0
060B4:  BTFSS  FD8.2
060B6:  GOTO   60CC
060BA:  MOVLB  1
060BC:  MOVF   xCF,W
060BE:  SUBLW  FE
060C0:  BTFSC  FD8.0
060C2:  BRA    60CA
060C4:  MOVLB  0
060C6:  GOTO   6100
060CA:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
060CC:  MOVFF  115,A59
060D0:  MOVFF  114,A58
060D4:  MOVFF  113,A57
060D8:  MOVFF  112,A56
060DC:  MOVFF  1D2,A5D
060E0:  MOVFF  1D1,A5C
060E4:  MOVFF  1D0,A5B
060E8:  MOVFF  1CF,A5A
060EC:  CALL   3BB2
060F0:  MOVLW  01
060F2:  MOVLB  1
060F4:  ADDWF  xD1,F
060F6:  MOVLW  00
060F8:  ADDWFC xD2,F
060FA:  MOVLB  0
060FC:  GOTO   6072
....................    }
....................    smf_data_table_init(); // Update the address area after writing
06100:  GOTO   5EEA
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06104:  MOVLB  1
06106:  MOVF   x8D,W
06108:  MOVWF  FE9
0610A:  MOVF   x8E,W
0610C:  MOVWF  FEA
0610E:  MOVFF  FEF,1D3
06112:  MOVFF  1D3,1E0
06116:  SETF   xE1
06118:  MOVLB  0
0611A:  CALL   3F80
....................    printf("End SMF Reset\r\n");
0611E:  MOVLW  D0
06120:  MOVWF  FF6
06122:  MOVLW  19
06124:  MOVWF  FF7
06126:  MOVLW  00
06128:  MOVWF  FF8
0612A:  CALL   1BBE
0612E:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0B13A:  CLRF   FF8
0B13C:  BCF    FD0.7
0B13E:  BSF    07.7
0B140:  MOVLB  E
0B142:  MOVLW  55
0B144:  MOVWF  F7E
0B146:  MOVLW  AA
0B148:  MOVWF  F7E
0B14A:  BCF    F66.6
0B14C:  MOVLW  F9
0B14E:  MOVWF  x2C
0B150:  MOVLW  0F
0B152:  MOVWF  x2E
0B154:  MOVLW  40
0B156:  MOVWF  x12
0B158:  MOVLW  30
0B15A:  MOVWF  x13
0B15C:  MOVLW  20
0B15E:  MOVWF  x22
0B160:  MOVLW  55
0B162:  MOVWF  F7E
0B164:  MOVLW  AA
0B166:  MOVWF  F7E
0B168:  BSF    F66.6
0B16A:  CLRF   F9B
0B16C:  CLRF   F64
0B16E:  CLRF   F65
0B170:  CLRF   F66
0B172:  MOVLW  02
0B174:  MOVWF  FD3
0B176:  CLRF   1B
0B178:  MOVLB  F
0B17A:  BSF    x2D.3
0B17C:  MOVLW  A0
0B17E:  MOVWF  x2B
0B180:  MOVLW  01
0B182:  MOVWF  x2C
0B184:  MOVLW  A6
0B186:  MOVWF  x2E
0B188:  MOVLW  90
0B18A:  MOVWF  x2F
0B18C:  BCF    F93.6
0B18E:  BSF    F8A.6
0B190:  BSF    F92.1
0B192:  BCF    F92.0
0B194:  BCF    F92.3
0B196:  BCF    F89.3
0B198:  BSF    F96.0
0B19A:  BCF    F96.6
0B19C:  BCF    F96.1
0B19E:  BCF    F8D.1
0B1A0:  BSF    F93.4
0B1A2:  BCF    F93.5
0B1A4:  BCF    F93.2
0B1A6:  BSF    F8A.2
0B1A8:  CLRF   1F
0B1AA:  CLRF   1E
0B1AC:  CLRF   1D
0B1AE:  CLRF   1C
0B1B0:  CLRF   23
0B1B2:  CLRF   22
0B1B4:  CLRF   21
0B1B6:  CLRF   20
0B1B8:  CLRF   25
0B1BA:  CLRF   24
0B1BC:  CLRF   46
0B1BE:  BCF    47.0
0B1C0:  MOVLW  1E
0B1C2:  MOVLB  1
0B1C4:  MOVWF  x4E
0B1C6:  CLRF   x50
0B1C8:  CLRF   x4F
0B1CA:  MOVLB  E
0B1CC:  CLRF   xD9
0B1CE:  CLRF   xDA
0B1D0:  CLRF   xCE
0B1D2:  CLRF   xCF
0B1D4:  CLRF   xD0
0B1D6:  CLRF   xD1
0B1D8:  CLRF   xD2
0B1DA:  CLRF   xD3
0B1DC:  CLRF   xD4
0B1DE:  CLRF   xD5
0B1E0:  CLRF   x45
0B1E2:  CLRF   x46
0B1E4:  CLRF   x47
0B1E6:  BCF    x8D.7
0B1E8:  BCF    x8D.6
0B1EA:  BCF    x8D.5
0B1EC:  MOVLB  F
0B1EE:  CLRF   x53
0B1F0:  CLRF   x38
0B1F2:  CLRF   x37
0B1F4:  MOVLB  0
0B1F6:  CLRF   26
0B1F8:  CLRF   27
0B1FA:  CLRF   28
0B1FC:  CLRF   29
0B1FE:  CLRF   2A
0B200:  CLRF   2B
0B202:  CLRF   2C
0B204:  CLRF   2D
0B206:  CLRF   2E
0B208:  CLRF   2F
0B20A:  CLRF   30
0B20C:  CLRF   31
0B20E:  CLRF   32
0B210:  CLRF   33
0B212:  CLRF   34
0B214:  CLRF   35
0B216:  CLRF   36
0B218:  CLRF   37
0B21A:  CLRF   38
0B21C:  CLRF   39
0B21E:  CLRF   3A
0B220:  CLRF   3B
0B222:  CLRF   3C
0B224:  CLRF   3D
0B226:  CLRF   3E
0B228:  CLRF   3F
0B22A:  CLRF   40
0B22C:  CLRF   41
0B22E:  CLRF   42
0B230:  CLRF   43
0B232:  CLRF   44
0B234:  CLRF   45
0B236:  MOVLW  03
0B238:  MOVWF  48
0B23A:  CLRF   49
0B23C:  CLRF   4A
0B23E:  CLRF   4B
0B240:  CLRF   4C
0B242:  CLRF   4D
0B244:  CLRF   4E
0B246:  CLRF   4F
0B248:  CLRF   50
0B24A:  CLRF   51
0B24C:  CLRF   52
0B24E:  CLRF   53
0B250:  CLRF   54
0B252:  CLRF   55
0B254:  CLRF   56
0B256:  CLRF   57
0B258:  CLRF   58
0B25A:  CLRF   59
0B25C:  CLRF   5A
0B25E:  CLRF   5B
0B260:  CLRF   5C
0B262:  CLRF   5D
0B264:  CLRF   5E
0B266:  CLRF   5F
0B268:  CLRF   x60
0B26A:  CLRF   x61
0B26C:  CLRF   x62
0B26E:  CLRF   x63
0B270:  CLRF   x64
0B272:  CLRF   x65
0B274:  CLRF   x66
0B276:  CLRF   x67
0B278:  CLRF   x68
0B27A:  CLRF   x69
0B27C:  CLRF   x6A
0B27E:  CLRF   x6B
0B280:  CLRF   x6C
0B282:  CLRF   x6D
0B284:  CLRF   x6E
0B286:  CLRF   x6F
0B288:  CLRF   x70
0B28A:  CLRF   x71
0B28C:  CLRF   x72
0B28E:  CLRF   x73
0B290:  CLRF   x74
0B292:  CLRF   x75
0B294:  CLRF   x76
0B296:  CLRF   x77
0B298:  CLRF   x78
0B29A:  CLRF   x79
0B29C:  CLRF   x7A
0B29E:  CLRF   x7B
0B2A0:  CLRF   x7C
0B2A2:  CLRF   x7D
0B2A4:  CLRF   x7E
0B2A6:  CLRF   x7F
0B2A8:  CLRF   x80
0B2AA:  CLRF   x81
0B2AC:  CLRF   x82
0B2AE:  CLRF   x83
0B2B0:  CLRF   x84
0B2B2:  CLRF   x85
0B2B4:  CLRF   x86
0B2B6:  CLRF   x87
0B2B8:  CLRF   x88
0B2BA:  CLRF   x89
0B2BC:  CLRF   x8A
0B2BE:  CLRF   x8B
0B2C0:  CLRF   x8C
0B2C2:  CLRF   x8D
0B2C4:  CLRF   x8E
0B2C6:  CLRF   x8F
0B2C8:  CLRF   x90
0B2CA:  CLRF   x91
0B2CC:  CLRF   x92
0B2CE:  CLRF   x93
0B2D0:  CLRF   x94
0B2D2:  CLRF   x95
0B2D4:  CLRF   x96
0B2D6:  CLRF   x97
0B2D8:  CLRF   x98
0B2DA:  CLRF   x99
0B2DC:  CLRF   x9A
0B2DE:  CLRF   x9B
0B2E0:  CLRF   x9C
0B2E2:  CLRF   x9D
0B2E4:  CLRF   x9E
0B2E6:  CLRF   x9F
0B2E8:  CLRF   xA0
0B2EA:  CLRF   xA1
0B2EC:  CLRF   xA2
0B2EE:  CLRF   xA3
0B2F0:  CLRF   xA4
0B2F2:  CLRF   xA5
0B2F4:  CLRF   xA6
0B2F6:  CLRF   xA7
0B2F8:  CLRF   xA8
0B2FA:  CLRF   xA9
0B2FC:  CLRF   xAA
0B2FE:  CLRF   xAB
0B300:  CLRF   xAC
0B302:  CLRF   xAD
0B304:  CLRF   xAE
0B306:  CLRF   xAF
0B308:  CLRF   xB0
0B30A:  CLRF   xB1
0B30C:  CLRF   xB2
0B30E:  CLRF   xB3
0B310:  CLRF   xB4
0B312:  CLRF   xB5
0B314:  CLRF   xB6
0B316:  CLRF   xB7
0B318:  CLRF   xB8
0B31A:  CLRF   xB9
0B31C:  CLRF   xBA
0B31E:  CLRF   xBB
0B320:  CLRF   xBC
0B322:  CLRF   xBD
0B324:  CLRF   xBE
0B326:  CLRF   xBF
0B328:  CLRF   xC0
0B32A:  CLRF   xC1
0B32C:  CLRF   xC2
0B32E:  CLRF   xC3
0B330:  CLRF   xC4
0B332:  CLRF   xC5
0B334:  CLRF   xC6
0B336:  CLRF   xC7
0B338:  CLRF   xC8
0B33A:  CLRF   xC9
0B33C:  CLRF   xCA
0B33E:  CLRF   xCB
0B340:  CLRF   xCC
0B342:  CLRF   xCD
0B344:  CLRF   xCE
0B346:  CLRF   xCF
0B348:  CLRF   xD0
0B34A:  CLRF   xD1
0B34C:  CLRF   xD2
0B34E:  CLRF   xD3
0B350:  CLRF   xD4
0B352:  CLRF   xD5
0B354:  CLRF   xD6
0B356:  CLRF   xD7
0B358:  CLRF   xD8
0B35A:  CLRF   xD9
0B35C:  CLRF   xDA
0B35E:  CLRF   xDB
0B360:  CLRF   xDC
0B362:  CLRF   xDD
0B364:  CLRF   xDE
0B366:  CLRF   xDF
0B368:  CLRF   xE0
0B36A:  CLRF   xE1
0B36C:  CLRF   xE2
0B36E:  CLRF   xE3
0B370:  CLRF   xE4
0B372:  CLRF   xE5
0B374:  CLRF   xE6
0B376:  CLRF   xE7
0B378:  CLRF   xE8
0B37A:  CLRF   xE9
0B37C:  CLRF   xEA
0B37E:  CLRF   xEB
0B380:  CLRF   xEC
0B382:  CLRF   xED
0B384:  CLRF   xEE
0B386:  CLRF   xEF
0B388:  CLRF   xF0
0B38A:  CLRF   xF1
0B38C:  CLRF   xF2
0B38E:  CLRF   xF3
0B390:  CLRF   xF4
0B392:  CLRF   xF5
0B394:  CLRF   xF6
0B396:  CLRF   xF7
0B398:  CLRF   xF8
0B39A:  CLRF   xF9
0B39C:  CLRF   xFA
0B39E:  CLRF   xFB
0B3A0:  CLRF   xFC
0B3A2:  CLRF   xFD
0B3A4:  CLRF   xFE
0B3A6:  CLRF   xFF
0B3A8:  MOVLB  1
0B3AA:  CLRF   x00
0B3AC:  CLRF   x01
0B3AE:  CLRF   x02
0B3B0:  CLRF   x03
0B3B2:  CLRF   x04
0B3B4:  CLRF   x05
0B3B6:  CLRF   x06
0B3B8:  CLRF   x07
0B3BA:  CLRF   x08
0B3BC:  CLRF   x09
0B3BE:  CLRF   x0A
0B3C0:  CLRF   x0B
0B3C2:  CLRF   x0C
0B3C4:  CLRF   x0D
0B3C6:  CLRF   x0E
0B3C8:  CLRF   x0F
0B3CA:  MOVLW  05
0B3CC:  MOVWF  x10
0B3CE:  MOVLW  7C
0B3D0:  MOVWF  x11
0B3D2:  MOVLW  01
0B3D4:  MOVWF  x12
0B3D6:  MOVLW  01
0B3D8:  MOVWF  x13
0B3DA:  MOVLW  02
0B3DC:  MOVWF  x14
0B3DE:  MOVLW  7C
0B3E0:  MOVWF  x15
0B3E2:  CLRF   x16
0B3E4:  MOVLW  09
0B3E6:  MOVWF  x17
0B3E8:  MOVLW  01
0B3EA:  MOVWF  x18
0B3EC:  CLRF   x19
0B3EE:  MOVLW  02
0B3F0:  MOVWF  x1A
0B3F2:  MOVLW  01
0B3F4:  MOVWF  x1B
0B3F6:  CLRF   x1C
0B3F8:  CLRF   x1D
0B3FA:  CLRF   x1E
0B3FC:  CLRF   x1F
0B3FE:  CLRF   x20
0B400:  CLRF   x21
0B402:  CLRF   x22
0B404:  CLRF   x23
0B406:  CLRF   x24
0B408:  CLRF   x25
0B40A:  CLRF   x26
0B40C:  CLRF   x27
0B40E:  CLRF   x28
0B410:  MOVLW  01
0B412:  MOVWF  x29
0B414:  CLRF   x2A
0B416:  CLRF   x2B
0B418:  CLRF   x2C
0B41A:  CLRF   x2D
0B41C:  CLRF   x2E
0B41E:  CLRF   x2F
0B420:  CLRF   x30
0B422:  CLRF   x31
0B424:  CLRF   x32
0B426:  CLRF   x33
0B428:  MOVLW  02
0B42A:  MOVWF  x34
0B42C:  CLRF   x35
0B42E:  CLRF   x36
0B430:  CLRF   x37
0B432:  CLRF   x38
0B434:  CLRF   x39
0B436:  CLRF   x3A
0B438:  CLRF   x3B
0B43A:  CLRF   x3C
0B43C:  CLRF   x3D
0B43E:  CLRF   x3E
0B440:  MOVLW  03
0B442:  MOVWF  x3F
0B444:  CLRF   x40
0B446:  CLRF   x41
0B448:  CLRF   x42
0B44A:  CLRF   x43
0B44C:  CLRF   x44
0B44E:  CLRF   x45
0B450:  CLRF   x46
0B452:  CLRF   x47
0B454:  CLRF   x48
0B456:  CLRF   x49
0B458:  CLRF   x51
0B45A:  CLRF   x52
0B45C:  CLRF   x53
0B45E:  CLRF   x54
0B460:  CLRF   x55
0B462:  CLRF   x56
0B464:  CLRF   x57
0B466:  CLRF   x58
0B468:  CLRF   x59
0B46A:  CLRF   x5A
0B46C:  CLRF   x5B
0B46E:  CLRF   x5C
0B470:  CLRF   x5D
0B472:  CLRF   x5E
0B474:  CLRF   x5F
0B476:  CLRF   x60
0B478:  CLRF   x61
0B47A:  CLRF   x62
0B47C:  CLRF   x63
0B47E:  CLRF   x64
0B480:  CLRF   x65
0B482:  CLRF   x66
0B484:  CLRF   x67
0B486:  CLRF   x68
0B488:  CLRF   x69
0B48A:  CLRF   x6A
0B48C:  CLRF   x6B
0B48E:  CLRF   x6C
0B490:  CLRF   x6D
0B492:  CLRF   x6E
0B494:  CLRF   x6F
0B496:  CLRF   x70
0B498:  CLRF   x71
0B49A:  CLRF   x72
0B49C:  CLRF   x73
0B49E:  CLRF   x74
0B4A0:  CLRF   x75
0B4A2:  CLRF   x76
0B4A4:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0B4A6:  MOVLW  64
0B4A8:  MOVLB  A
0B4AA:  MOVWF  x6E
0B4AC:  MOVLB  0
0B4AE:  CALL   1B3E
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0B4B2:  MOVLW  E0
0B4B4:  MOVWF  FF6
0B4B6:  MOVLW  19
0B4B8:  MOVWF  FF7
0B4BA:  MOVLW  00
0B4BC:  MOVWF  FF8
0B4BE:  CALL   1BBE
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0B4C2:  MOVLW  26
0B4C4:  MOVWF  FF6
0B4C6:  MOVLW  1A
0B4C8:  MOVWF  FF7
0B4CA:  MOVLW  00
0B4CC:  MOVWF  FF8
0B4CE:  CALL   1BBE
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0B4D2:  MOVLW  54
0B4D4:  MOVWF  FF6
0B4D6:  MOVLW  1A
0B4D8:  MOVWF  FF7
0B4DA:  MOVLW  00
0B4DC:  MOVWF  FF8
0B4DE:  MOVLW  10
0B4E0:  MOVLB  9
0B4E2:  MOVWF  xC2
0B4E4:  MOVLB  0
0B4E6:  CALL   1BEE
0B4EA:  MOVLW  7A
0B4EC:  MOVWF  FF6
0B4EE:  MOVLW  1A
0B4F0:  MOVWF  FF7
0B4F2:  MOVLW  00
0B4F4:  MOVWF  FF8
0B4F6:  CALL   1BBE
0B4FA:  MOVLW  20
0B4FC:  MOVLB  A
0B4FE:  MOVWF  xAD
0B500:  MOVLB  0
0B502:  CALL   1B6C
0B506:  MOVLW  84
0B508:  MOVWF  FF6
0B50A:  MOVLW  1A
0B50C:  MOVWF  FF7
0B50E:  MOVLW  00
0B510:  MOVWF  FF8
0B512:  CALL   1BBE
0B516:  MOVLW  69
0B518:  MOVWF  FF6
0B51A:  MOVLW  1A
0B51C:  MOVWF  FF7
0B51E:  MOVLW  00
0B520:  MOVWF  FF8
0B522:  MOVLW  0F
0B524:  MOVLB  9
0B526:  MOVWF  xC2
0B528:  MOVLB  0
0B52A:  CALL   1BEE
....................    
....................    io_init();
0B52E:  GOTO   1C24
....................    setup_uart_to_boss();
0B532:  GOTO   1C72
....................    setup_timer();
0B536:  GOTO   1C9C
....................    ad7490_init();
0B53A:  GOTO   1EB2
....................    mcp4901_init();
0B53E:  GOTO   2190
....................    misf_init();
0B542:  CALL   2FDC
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0B546:  MOVLB  1
0B548:  CLRF   xE0
0B54A:  CLRF   xE1
0B54C:  MOVLB  0
0B54E:  CALL   3F80
.................... 
....................    int1 is_finished = FALSE;
0B552:  MOVLB  1
0B554:  BCF    x77.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0B556:  MOVLW  8E
0B558:  MOVWF  FF6
0B55A:  MOVLW  1A
0B55C:  MOVWF  FF7
0B55E:  MOVLW  00
0B560:  MOVWF  FF8
0B562:  MOVLB  0
0B564:  CALL   1BBE
....................    
....................    output_low(EN_NPWR);
0B568:  MOVLW  5E
0B56A:  MOVWF  F94
0B56C:  BCF    F8B.7
....................    
....................    
....................    fprintf(PC,"waiting for BOSS PIC command");
0B56E:  MOVLW  B4
0B570:  MOVWF  FF6
0B572:  MOVLW  1A
0B574:  MOVWF  FF7
0B576:  MOVLW  00
0B578:  MOVWF  FF8
0B57A:  CALL   1BBE
....................    
....................    //Start loop
....................    while(!is_finished)
0B57E:  MOVLB  1
0B580:  BTFSS  x77.0
0B582:  BRA    B58A
0B584:  MOVLB  0
0B586:  GOTO   B658
0B58A:  MOVLB  0
....................    {
....................       // unsigned int16 cigs1_amp = ad7490_read(ADC_CIGS2_AMP);
....................       // unsigned int16 cigs1_curr = ad7490_read(ADC_CIGS2_CURR);
....................       // unsigned int16 cigs1_volt = ad7490_read(ADC_CIGS2_VOLT);
....................       
....................       // fprintf(PC, "CIGS1 Amp: %04LX, Current: %04LX, Voltage: %04LX\r\n", cigs1_amp, cigs1_curr, cigs1_volt);
....................       
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0B58C:  MOVF   46,F
0B58E:  BTFSC  FD8.2
0B590:  GOTO   B614
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0B594:  MOVLB  1
0B596:  CLRF   x8B
0B598:  MOVLW  26
0B59A:  MOVWF  x8A
0B59C:  MOVFF  46,18C
0B5A0:  MOVLB  0
0B5A2:  GOTO   442E
0B5A6:  MOVFF  02,03
0B5AA:  MOVF   01,W
0B5AC:  MOVWF  FE1
0B5AE:  MOVFF  03,FE2
0B5B2:  MOVLW  01
0B5B4:  MOVWF  FEA
0B5B6:  MOVLW  78
0B5B8:  MOVWF  FE9
0B5BA:  MOVLW  0C
0B5BC:  MOVWF  01
0B5BE:  MOVFF  FE6,FEE
0B5C2:  DECFSZ 01,F
0B5C4:  GOTO   B5BE
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0B5C8:  MOVLB  1
0B5CA:  CLRF   x85
0B5CC:  MOVLW  26
0B5CE:  MOVWF  x84
0B5D0:  CLRF   x87
0B5D2:  MOVLW  46
0B5D4:  MOVWF  x86
0B5D6:  MOVLB  0
0B5D8:  GOTO   462A
....................          
....................          if(recieve_cmd.is_exist)
0B5DC:  MOVLB  1
0B5DE:  BTFSC  x7A.0
0B5E0:  BRA    B5E8
0B5E2:  MOVLB  0
0B5E4:  GOTO   B604
0B5E8:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0B5EA:  MOVLW  01
0B5EC:  MOVLB  1
0B5EE:  MOVWF  x85
0B5F0:  MOVLW  78
0B5F2:  MOVWF  x84
0B5F4:  MOVLB  0
0B5F6:  GOTO   B0B8
0B5FA:  MOVLB  1
0B5FC:  BCF    x77.1
0B5FE:  BTFSC  01.0
0B600:  BSF    x77.1
0B602:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0B604:  MOVLW  D2
0B606:  MOVWF  FF6
0B608:  MOVLW  1A
0B60A:  MOVWF  FF7
0B60C:  MOVLW  00
0B60E:  MOVWF  FF8
0B610:  CALL   1BBE
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0B614:  MOVLB  1
0B616:  BTFSC  x77.0
0B618:  BRA    B620
0B61A:  MOVLB  0
0B61C:  GOTO   B626
0B620:  MOVLB  0
....................          break;
0B622:  GOTO   B658
....................          
....................       delay_ms(400);
0B626:  MOVLW  02
0B628:  MOVLB  1
0B62A:  MOVWF  x84
0B62C:  MOVLB  0
0B62E:  MOVLW  C8
0B630:  MOVLB  A
0B632:  MOVWF  x6E
0B634:  MOVLB  0
0B636:  CALL   1B3E
0B63A:  MOVLB  1
0B63C:  DECFSZ x84,F
0B63E:  BRA    B644
0B640:  BRA    B648
0B642:  MOVLB  0
0B644:  MOVLB  0
0B646:  BRA    B62E
....................       fprintf(PC, ".");
0B648:  MOVLW  2E
0B64A:  MOVLB  A
0B64C:  MOVWF  xAD
0B64E:  MOVLB  0
0B650:  CALL   1B6C
0B654:  GOTO   B57E
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0B658:  MOVLW  F2
0B65A:  MOVWF  FF6
0B65C:  MOVLW  1A
0B65E:  MOVWF  FF7
0B660:  MOVLW  00
0B662:  MOVWF  FF8
0B664:  CALL   1BBE
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0B668:  MOVLW  2E
0B66A:  MOVLB  A
0B66C:  MOVWF  xAD
0B66E:  MOVLB  0
0B670:  CALL   1B6C
....................       delay_ms(1000);
0B674:  MOVLW  04
0B676:  MOVLB  1
0B678:  MOVWF  x84
0B67A:  MOVLB  0
0B67C:  MOVLW  FA
0B67E:  MOVLB  A
0B680:  MOVWF  x6E
0B682:  MOVLB  0
0B684:  CALL   1B3E
0B688:  MOVLB  1
0B68A:  DECFSZ x84,F
0B68C:  BRA    B692
0B68E:  BRA    B696
0B690:  MOVLB  0
0B692:  MOVLB  0
0B694:  BRA    B67C
0B696:  MOVLB  0
0B698:  GOTO   B668
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0B69C:  MOVLW  32
0B69E:  MOVWF  FF6
0B6A0:  MOVLW  1B
0B6A2:  MOVWF  FF7
0B6A4:  MOVLW  00
0B6A6:  MOVWF  FF8
0B6A8:  CALL   1BBE
....................    
.................... }
.................... // Enf of files
0B6AC:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
