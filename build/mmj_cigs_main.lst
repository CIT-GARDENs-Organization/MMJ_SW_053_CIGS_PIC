CCS PCH C Compiler, Version 5.104, 57077               09-8-25 01:42

               Filename:   build\mmj_cigs_main.lst

               ROM used:   46534 bytes (36%)
                           Largest free fragment is 65520
               RAM used:   727 (20%) at main() level
                           3092 (86%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   AE10
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "cigs/system/mmj_cigs_main.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 46,6C
0028C:  DATA 61,73
0028E:  DATA 68,20
00290:  DATA 71,75
00292:  DATA 65,75
00294:  DATA 65,20
00296:  DATA 69,73
00298:  DATA 20,66
0029A:  DATA 75,6C
0029C:  DATA 6C,21
0029E:  DATA 21,21
002A0:  DATA 0D,0A
002A2:  DATA 00,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,65
002B4:  DATA 6D,70
002B6:  DATA 74,79
002B8:  DATA 0D,0A
002BA:  DATA 00,00
002BC:  DATA 0D,0A
002BE:  DATA 53,74
002C0:  DATA 61,72
002C2:  DATA 74,20
002C4:  DATA 6D,61
002C6:  DATA 6B,65
002C8:  DATA 5F,72
002CA:  DATA 65,63
002CC:  DATA 65,69
002CE:  DATA 76,65
002D0:  DATA 5F,63
002D2:  DATA 6F,6D
002D4:  DATA 6D,61
002D6:  DATA 6E,64
002D8:  DATA 0D,0A
002DA:  DATA 00,00
002DC:  DATA 09,5B
002DE:  DATA 42,4F
002E0:  DATA 53,53
002E2:  DATA 5D,20
002E4:  DATA 3E,3E
002E6:  DATA 3E,20
002E8:  DATA 00,00
002EA:  DATA 45,6E
002EC:  DATA 64,20
002EE:  DATA 6D,61
002F0:  DATA 6B,65
002F2:  DATA 5F,72
002F4:  DATA 65,63
002F6:  DATA 69,76
002F8:  DATA 65,5F
002FA:  DATA 63,6F
002FC:  DATA 6D,6D
002FE:  DATA 61,6E
00300:  DATA 64,0D
00302:  DATA 0A,0D
00304:  DATA 0A,00
00306:  DATA 73,69
00308:  DATA 67,6E
0030A:  DATA 61,6C
0030C:  DATA 20,65
0030E:  DATA 6E,64
00310:  DATA 20,77
00312:  DATA 69,74
00314:  DATA 68,20
00316:  DATA 53,46
00318:  DATA 44,0D
0031A:  DATA 0A,00
0031C:  DATA 64,6F
0031E:  DATA 6E,27
00320:  DATA 74,20
00322:  DATA 66,69
00324:  DATA 6E,64
00326:  DATA 20,53
00328:  DATA 46,44
0032A:  DATA 0D,0A
0032C:  DATA 00,00
0032E:  DATA 09,2D
00330:  DATA 3E,20
00332:  DATA 49,6E
00334:  DATA 76,61
00336:  DATA 6C,69
00338:  DATA 64,20
0033A:  DATA 46,72
0033C:  DATA 61,6D
0033E:  DATA 65,20
00340:  DATA 49,44
00342:  DATA 20,72
00344:  DATA 65,63
00346:  DATA 65,69
00348:  DATA 76,65
0034A:  DATA 64,3A
0034C:  DATA 20,25
0034E:  DATA 58,0D
00350:  DATA 0A,00
00352:  DATA 09,2D
00354:  DATA 3E,20
00356:  DATA 43,52
00358:  DATA 43,20
0035A:  DATA 65,72
0035C:  DATA 72,6F
0035E:  DATA 72,21
00360:  DATA 0D,0A
00362:  DATA 00,00
00364:  DATA 09,09
00366:  DATA 2D,3E
00368:  DATA 20,72
0036A:  DATA 65,63
0036C:  DATA 65,69
0036E:  DATA 76,65
00370:  DATA 64,20
00372:  DATA 43,52
00374:  DATA 43,3A
00376:  DATA 20,25
00378:  DATA 58,0D
0037A:  DATA 0A,00
0037C:  DATA 09,09
0037E:  DATA 20,20
00380:  DATA 20,63
00382:  DATA 6F,6C
00384:  DATA 6C,65
00386:  DATA 63,74
00388:  DATA 20,43
0038A:  DATA 52,43
0038C:  DATA 20,3A
0038E:  DATA 20,25
00390:  DATA 58,0D
00392:  DATA 0A,00
00394:  DATA 09,2D
00396:  DATA 3E,20
00398:  DATA 49,6E
0039A:  DATA 76,61
0039C:  DATA 6C,69
0039E:  DATA 64,20
003A0:  DATA 64,65
003A2:  DATA 76,69
003A4:  DATA 63,65
003A6:  DATA 20,49
003A8:  DATA 44,20
003AA:  DATA 72,65
003AC:  DATA 63,65
003AE:  DATA 69,76
003B0:  DATA 65,64
003B2:  DATA 0D,0A
003B4:  DATA 00,00
003B6:  DATA 09,09
003B8:  DATA 2D,3E
003BA:  DATA 20,72
003BC:  DATA 65,63
003BE:  DATA 65,69
003C0:  DATA 76,65
003C2:  DATA 64,3A
003C4:  DATA 20,20
003C6:  DATA 20,20
003C8:  DATA 20,25
003CA:  DATA 58,0D
003CC:  DATA 0A,00
003CE:  DATA 09,09
003D0:  DATA 20,20
003D2:  DATA 20,4D
003D4:  DATA 79,20
003D6:  DATA 64,65
003D8:  DATA 76,69
003DA:  DATA 63,65
003DC:  DATA 20,49
003DE:  DATA 44,3A
003E0:  DATA 20,25
003E2:  DATA 58,0D
003E4:  DATA 0A,00
003E6:  DATA 09,5B
003E8:  DATA 42,4F
003EA:  DATA 53,53
003EC:  DATA 5D,20
003EE:  DATA 3C,3C
003F0:  DATA 3C,20
003F2:  DATA 00,00
003F4:  DATA 53,74
003F6:  DATA 61,72
003F8:  DATA 74,20
003FA:  DATA 53,4D
003FC:  DATA 46,20
003FE:  DATA 75,73
00400:  DATA 69,6E
00402:  DATA 67,20
00404:  DATA 72,65
00406:  DATA 71,65
00408:  DATA 73,74
0040A:  DATA 20,73
0040C:  DATA 65,61
0040E:  DATA 71,75
00410:  DATA 65,6E
00412:  DATA 63,65
00414:  DATA 0D,0A
00416:  DATA 00,00
00418:  DATA 45,72
0041A:  DATA 72,6F
0041C:  DATA 72,21
0041E:  DATA 20,52
00420:  DATA 65,63
00422:  DATA 65,69
00424:  DATA 76,69
00426:  DATA 6E,67
00428:  DATA 20,63
0042A:  DATA 6F,6D
0042C:  DATA 6D,61
0042E:  DATA 6E,64
00430:  DATA 20,69
00432:  DATA 6E,63
00434:  DATA 6F,6E
00436:  DATA 73,69
00438:  DATA 73,74
0043A:  DATA 65,6E
0043C:  DATA 74,20
0043E:  DATA 77,69
00440:  DATA 74,68
00442:  DATA 20,74
00444:  DATA 68,65
00446:  DATA 20,64
00448:  DATA 65,73
0044A:  DATA 69,67
0044C:  DATA 6E,0D
0044E:  DATA 0A,00
00450:  DATA 53,4D
00452:  DATA 46,20
00454:  DATA 75,73
00456:  DATA 65,20
00458:  DATA 72,65
0045A:  DATA 71,75
0045C:  DATA 65,73
0045E:  DATA 74,20
00460:  DATA 61,6C
00462:  DATA 6C,6F
00464:  DATA 77,65
00466:  DATA 64,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 64,65
0047C:  DATA 6E,79
0047E:  DATA 65,64
00480:  DATA 0D,0A
00482:  DATA 00,00
00484:  DATA 52,65
00486:  DATA 74,72
00488:  DATA 79,20
0048A:  DATA 72,65
0048C:  DATA 71,75
0048E:  DATA 65,73
00490:  DATA 74,20
00492:  DATA 74,6F
00494:  DATA 20,42
00496:  DATA 4F,53
00498:  DATA 53,20
0049A:  DATA 50,49
0049C:  DATA 43,0D
0049E:  DATA 0A,00
004A0:  DATA 45,72
004A2:  DATA 72,6F
004A4:  DATA 72,21
004A6:  DATA 20,52
004A8:  DATA 65,63
004AA:  DATA 65,69
004AC:  DATA 76,69
004AE:  DATA 6E,67
004B0:  DATA 20,63
004B2:  DATA 6F,6D
004B4:  DATA 6D,61
004B6:  DATA 6E,64
004B8:  DATA 20,69
004BA:  DATA 6E,63
004BC:  DATA 6F,6E
004BE:  DATA 73,69
004C0:  DATA 73,74
004C2:  DATA 65,6E
004C4:  DATA 74,20
004C6:  DATA 77,69
004C8:  DATA 74,68
004CA:  DATA 20,74
004CC:  DATA 68,65
004CE:  DATA 20,64
004D0:  DATA 65,73
004D2:  DATA 69,67
004D4:  DATA 6E,0D
004D6:  DATA 0A,00
004D8:  DATA 45,6E
004DA:  DATA 64,20
004DC:  DATA 53,4D
004DE:  DATA 46,20
004E0:  DATA 75,73
004E2:  DATA 69,6E
004E4:  DATA 67,20
004E6:  DATA 72,65
004E8:  DATA 71,65
004EA:  DATA 73,74
004EC:  DATA 20,73
004EE:  DATA 65,61
004F0:  DATA 71,75
004F2:  DATA 65,6E
004F4:  DATA 63,65
004F6:  DATA 0D,0A
004F8:  DATA 00,00
004FA:  DATA 49,4F
004FC:  DATA 20,49
004FE:  DATA 6E,69
00500:  DATA 74,69
00502:  DATA 61,6C
00504:  DATA 69,7A
00506:  DATA 65,0D
00508:  DATA 0A,00
0050A:  DATA 09,43
0050C:  DATA 6F,6D
0050E:  DATA 70,6C
00510:  DATA 65,74
00512:  DATA 65,0D
00514:  DATA 0A,00
00516:  DATA 53,74
00518:  DATA 61,72
0051A:  DATA 74,20
0051C:  DATA 54,45
0051E:  DATA 53,54
00520:  DATA 20,53
00522:  DATA 57,45
00524:  DATA 45,50
00526:  DATA 0D,0A
00528:  DATA 00,00
0052A:  DATA 73,74
0052C:  DATA 65,70
0052E:  DATA 2C,20
00530:  DATA 76,6F
00532:  DATA 6C,74
00534:  DATA 61,67
00536:  DATA 65,2C
00538:  DATA 20,63
0053A:  DATA 75,72
0053C:  DATA 72,65
0053E:  DATA 6E,74
00540:  DATA 0D,0A
00542:  DATA 00,00
00544:  DATA 53,74
00546:  DATA 61,72
00548:  DATA 74,20
0054A:  DATA 41,44
0054C:  DATA 43,20
0054E:  DATA 54,45
00550:  DATA 53,54
00552:  DATA 0D,0A
00554:  DATA 00,00
00556:  DATA 41,44
00558:  DATA 43,20
0055A:  DATA 56,6F
0055C:  DATA 6C,74
0055E:  DATA 61,67
00560:  DATA 65,3A
00562:  DATA 20,25
00564:  DATA 30,34
00566:  DATA 4C,58
00568:  DATA 0D,0A
0056A:  DATA 00,00
0056C:  DATA 41,44
0056E:  DATA 43,20
00570:  DATA 43,75
00572:  DATA 72,72
00574:  DATA 65,6E
00576:  DATA 74,3A
00578:  DATA 20,25
0057A:  DATA 30,34
0057C:  DATA 4C,58
0057E:  DATA 0D,0A
00580:  DATA 00,00
00582:  DATA 41,44
00584:  DATA 43,20
00586:  DATA 43,49
00588:  DATA 47,53
0058A:  DATA 31,20
0058C:  DATA 41,6D
0058E:  DATA 70,3A
00590:  DATA 20,25
00592:  DATA 30,34
00594:  DATA 4C,58
00596:  DATA 0D,0A
00598:  DATA 00,00
0059A:  DATA 41,44
0059C:  DATA 43,20
0059E:  DATA 43,49
005A0:  DATA 47,53
005A2:  DATA 31,20
005A4:  DATA 56,52
005A6:  DATA 45,46
005A8:  DATA 3A,20
005AA:  DATA 25,30
005AC:  DATA 34,4C
005AE:  DATA 58,0D
005B0:  DATA 0A,00
005B2:  DATA 53,74
005B4:  DATA 61,72
005B6:  DATA 74,20
005B8:  DATA 53,57
005BA:  DATA 45,45
005BC:  DATA 50,20
005BE:  DATA 32,70
005C0:  DATA 6F,72
005C2:  DATA 74,73
005C4:  DATA 0D,0A
005C6:  DATA 00,00
005C8:  DATA 09,53
005CA:  DATA 77,65
005CC:  DATA 65,70
005CE:  DATA 20,73
005D0:  DATA 74,65
005D2:  DATA 70,20
005D4:  DATA 3A,20
005D6:  DATA 25,75
005D8:  DATA 0D,0A
005DA:  DATA 00,00
005DC:  DATA 45,4E
005DE:  DATA 44,20
005E0:  DATA 53,57
005E2:  DATA 45,45
005E4:  DATA 50,20
005E6:  DATA 32,70
005E8:  DATA 6F,72
005EA:  DATA 74,0D
005EC:  DATA 0A,00
005EE:  DATA 53,74
005F0:  DATA 61,72
005F2:  DATA 74,20
005F4:  DATA 43,49
005F6:  DATA 47,53
005F8:  DATA 20,64
005FA:  DATA 61,74
005FC:  DATA 61,20
005FE:  DATA 63,6F
00600:  DATA 6E,76
00602:  DATA 65,72
00604:  DATA 73,69
00606:  DATA 6F,6E
00608:  DATA 0D,0A
0060A:  DATA 00,00
0060C:  DATA 53,74
0060E:  DATA 61,72
00610:  DATA 74,20
00612:  DATA 53,57
00614:  DATA 45,45
00616:  DATA 50,20
00618:  DATA 77,69
0061A:  DATA 74,68
0061C:  DATA 20,74
0061E:  DATA 68,72
00620:  DATA 65,73
00622:  DATA 68,6F
00624:  DATA 6C,64
00626:  DATA 0D,0A
00628:  DATA 00,00
0062A:  DATA 43,49
0062C:  DATA 47,53
0062E:  DATA 32,20
00630:  DATA 64,61
00632:  DATA 74,61
00634:  DATA 3A,20
00636:  DATA 25,30
00638:  DATA 34,4C
0063A:  DATA 58,2C
0063C:  DATA 20,25
0063E:  DATA 30,34
00640:  DATA 4C,58
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 4D,61
00648:  DATA 78,69
0064A:  DATA 6D,75
0064C:  DATA 6D,20
0064E:  DATA 73,74
00650:  DATA 65,70
00652:  DATA 20,63
00654:  DATA 6F,75
00656:  DATA 6E,74
00658:  DATA 20,72
0065A:  DATA 65,61
0065C:  DATA 63,68
0065E:  DATA 65,64
00660:  DATA 3A,20
00662:  DATA 25,6C
00664:  DATA 64,0D
00666:  DATA 0A,00
00668:  DATA 43,49
0066A:  DATA 47,53
0066C:  DATA 31,20
0066E:  DATA 63,75
00670:  DATA 72,72
00672:  DATA 65,6E
00674:  DATA 74,20
00676:  DATA 6C,69
00678:  DATA 6D,69
0067A:  DATA 74,20
0067C:  DATA 72,65
0067E:  DATA 61,63
00680:  DATA 68,65
00682:  DATA 64,3A
00684:  DATA 00,00
00686:  DATA 43,49
00688:  DATA 47,53
0068A:  DATA 31,20
0068C:  DATA 63,75
0068E:  DATA 72,72
00690:  DATA 65,6E
00692:  DATA 74,20
00694:  DATA 62,65
00696:  DATA 6C,6F
00698:  DATA 77,20
0069A:  DATA 74,68
0069C:  DATA 72,65
0069E:  DATA 73,68
006A0:  DATA 6F,6C
006A2:  DATA 64,00
006A4:  DATA 43,49
006A6:  DATA 47,53
006A8:  DATA 32,20
006AA:  DATA 63,75
006AC:  DATA 72,72
006AE:  DATA 65,6E
006B0:  DATA 74,20
006B2:  DATA 6C,69
006B4:  DATA 6D,69
006B6:  DATA 74,20
006B8:  DATA 72,65
006BA:  DATA 61,63
006BC:  DATA 68,65
006BE:  DATA 64,3A
006C0:  DATA 20,00
006C2:  DATA 43,49
006C4:  DATA 47,53
006C6:  DATA 32,20
006C8:  DATA 63,75
006CA:  DATA 72,72
006CC:  DATA 65,6E
006CE:  DATA 74,20
006D0:  DATA 62,65
006D2:  DATA 6C,6F
006D4:  DATA 77,20
006D6:  DATA 74,68
006D8:  DATA 72,65
006DA:  DATA 73,68
006DC:  DATA 6F,6C
006DE:  DATA 64,3A
006E0:  DATA 00,00
006E2:  DATA 45,6E
006E4:  DATA 64,20
006E6:  DATA 53,57
006E8:  DATA 45,45
006EA:  DATA 50,20
006EC:  DATA 77,69
006EE:  DATA 74,68
006F0:  DATA 20,74
006F2:  DATA 68,72
006F4:  DATA 65,73
006F6:  DATA 68,6F
006F8:  DATA 6C,64
006FA:  DATA 0D,0A
006FC:  DATA 00,00
006FE:  DATA 45,6E
00700:  DATA 64,20
00702:  DATA 43,49
00704:  DATA 47,53
00706:  DATA 20,64
00708:  DATA 61,74
0070A:  DATA 61,20
0070C:  DATA 63,6F
0070E:  DATA 6E,76
00710:  DATA 65,72
00712:  DATA 73,69
00714:  DATA 6F,6E
00716:  DATA 0D,0A
00718:  DATA 00,00
0071A:  DATA 43,52
0071C:  DATA 43,20
0071E:  DATA 76,65
00720:  DATA 72,69
00722:  DATA 66,69
00724:  DATA 63,61
00726:  DATA 74,69
00728:  DATA 6F,6E
0072A:  DATA 20,70
0072C:  DATA 61,73
0072E:  DATA 73,65
00730:  DATA 64,20
00732:  DATA 6F,6E
00734:  DATA 20,61
00736:  DATA 74,74
00738:  DATA 65,6D
0073A:  DATA 70,74
0073C:  DATA 20,25
0073E:  DATA 75,0D
00740:  DATA 0A,00
00742:  DATA 43,52
00744:  DATA 43,20
00746:  DATA 76,65
00748:  DATA 72,69
0074A:  DATA 66,69
0074C:  DATA 63,61
0074E:  DATA 74,69
00750:  DATA 6F,6E
00752:  DATA 20,70
00754:  DATA 61,73
00756:  DATA 73,65
00758:  DATA 64,20
0075A:  DATA 6F,6E
0075C:  DATA 20,61
0075E:  DATA 74,74
00760:  DATA 65,6D
00762:  DATA 70,74
00764:  DATA 20,25
00766:  DATA 64,0D
00768:  DATA 0A,00
0076A:  DATA 45,72
0076C:  DATA 72,6F
0076E:  DATA 72,3A
00770:  DATA 20,43
00772:  DATA 52,43
00774:  DATA 20,76
00776:  DATA 65,72
00778:  DATA 69,66
0077A:  DATA 69,63
0077C:  DATA 61,74
0077E:  DATA 69,6F
00780:  DATA 6E,20
00782:  DATA 66,61
00784:  DATA 69,6C
00786:  DATA 65,64
00788:  DATA 20,61
0078A:  DATA 66,74
0078C:  DATA 65,72
0078E:  DATA 20,25
00790:  DATA 64,20
00792:  DATA 61,74
00794:  DATA 74,65
00796:  DATA 6D,70
00798:  DATA 74,73
0079A:  DATA 0D,0A
0079C:  DATA 00,00
0079E:  DATA 0D,0A
007A0:  DATA 5F,5F
007A2:  DATA 5F,5F
007A4:  DATA 5F,5F
007A6:  DATA 5F,5F
007A8:  DATA 5F,5F
007AA:  DATA 5F,5F
007AC:  DATA 5F,5F
007AE:  DATA 5F,5F
007B0:  DATA 5F,5F
007B2:  DATA 5F,5F
007B4:  DATA 0D,0A
007B6:  DATA 00,00
007B8:  DATA 5F,5F
007BA:  DATA 5F,5F
007BC:  DATA 5F,53
007BE:  DATA 74,61
007C0:  DATA 72,74
007C2:  DATA 20,63
007C4:  DATA 6F,70
007C6:  DATA 79,5F
007C8:  DATA 64,61
007CA:  DATA 74,61
007CC:  DATA 5F,5F
007CE:  DATA 5F,5F
007D0:  DATA 0D,0A
007D2:  DATA 00,00
007D4:  DATA 45,72
007D6:  DATA 72,6F
007D8:  DATA 72,3A
007DA:  DATA 20,4D
007DC:  DATA 49,53
007DE:  DATA 20,46
007E0:  DATA 4D,20
007E2:  DATA 69,73
007E4:  DATA 20,6E
007E6:  DATA 6F,74
007E8:  DATA 20,63
007EA:  DATA 6F,6E
007EC:  DATA 6E,65
007EE:  DATA 63,74
007F0:  DATA 65,64
007F2:  DATA 0D,0A
007F4:  DATA 00,00
007F6:  DATA 45,72
007F8:  DATA 72,6F
007FA:  DATA 72,3A
007FC:  DATA 20,53
007FE:  DATA 4D,46
00800:  DATA 20,69
00802:  DATA 73,20
00804:  DATA 6E,6F
00806:  DATA 74,20
00808:  DATA 63,6F
0080A:  DATA 6E,6E
0080C:  DATA 65,63
0080E:  DATA 74,65
00810:  DATA 64,0D
00812:  DATA 0A,00
00814:  DATA 53,69
00816:  DATA 7A,65
00818:  DATA 20,61
0081A:  DATA 72,65
0081C:  DATA 61,20
0081E:  DATA 72,65
00820:  DATA 61,64
00822:  DATA 0D,0A
00824:  DATA 00,00
00826:  DATA 75,73
00828:  DATA 65,64
0082A:  DATA 5F,73
0082C:  DATA 69,7A
0082E:  DATA 65,20
00830:  DATA 3D,20
00832:  DATA 25,6C
00834:  DATA 64,20
00836:  DATA 28,73
00838:  DATA 72,63
0083A:  DATA 20,30
0083C:  DATA 78,25
0083E:  DATA 30,38
00840:  DATA 4C,58
00842:  DATA 29,0D
00844:  DATA 0A,00
00846:  DATA 6C,6F
00848:  DATA 6F,70
0084A:  DATA 20,63
0084C:  DATA 6F,75
0084E:  DATA 6E,74
00850:  DATA 3D,20
00852:  DATA 25,64
00854:  DATA 20,20
00856:  DATA 28,73
00858:  DATA 72,63
0085A:  DATA 20,30
0085C:  DATA 78,25
0085E:  DATA 30,38
00860:  DATA 4C,58
00862:  DATA 29,0D
00864:  DATA 0A,0D
00866:  DATA 0A,00
00868:  DATA 57,72
0086A:  DATA 61,70
0086C:  DATA 20,74
0086E:  DATA 72,69
00870:  DATA 67,67
00872:  DATA 65,72
00874:  DATA 65,64
00876:  DATA 3A,20
00878:  DATA 52,65
0087A:  DATA 73,65
0087C:  DATA 74,74
0087E:  DATA 69,6E
00880:  DATA 67,20
00882:  DATA 64,61
00884:  DATA 74,61
00886:  DATA 5F,77
00888:  DATA 72,69
0088A:  DATA 74,65
0088C:  DATA 5F,61
0088E:  DATA 64,64
00890:  DATA 72,20
00892:  DATA 74,6F
00894:  DATA 20,73
00896:  DATA 74,61
00898:  DATA 72,74
0089A:  DATA 0D,0A
0089C:  DATA 00,00
0089E:  DATA 75,73
008A0:  DATA 65,64
008A2:  DATA 5F,73
008A4:  DATA 69,7A
008A6:  DATA 65,20
008A8:  DATA 3D,20
008AA:  DATA 25,6C
008AC:  DATA 64,0D
008AE:  DATA 0A,00
008B0:  DATA 6C,6F
008B2:  DATA 6F,70
008B4:  DATA 5F,63
008B6:  DATA 6F,75
008B8:  DATA 6E,74
008BA:  DATA 20,3D
008BC:  DATA 20,25
008BE:  DATA 75,0D
008C0:  DATA 0A,0D
008C2:  DATA 0A,00
008C4:  DATA 0D,0A
008C6:  DATA 5F,5F
008C8:  DATA 5F,45
008CA:  DATA 6E,64
008CC:  DATA 20,63
008CE:  DATA 6F,70
008D0:  DATA 79,5F
008D2:  DATA 64,61
008D4:  DATA 74,61
008D6:  DATA 5F,5F
008D8:  DATA 5F,5F
008DA:  DATA 0D,0A
008DC:  DATA 00,00
008DE:  DATA 5F,5F
008E0:  DATA 5F,5F
008E2:  DATA 5F,5F
008E4:  DATA 5F,5F
008E6:  DATA 5F,5F
008E8:  DATA 5F,5F
008EA:  DATA 5F,5F
008EC:  DATA 5F,5F
008EE:  DATA 5F,5F
008F0:  DATA 5F,5F
008F2:  DATA 0D,0A
008F4:  DATA 0D,0A
008F6:  DATA 00,00
008F8:  DATA 0D,0A
008FA:  DATA 5F,5F
008FC:  DATA 5F,5F
008FE:  DATA 5F,5F
00900:  DATA 5F,5F
00902:  DATA 5F,5F
00904:  DATA 5F,5F
00906:  DATA 5F,5F
00908:  DATA 5F,5F
0090A:  DATA 5F,5F
0090C:  DATA 5F,5F
0090E:  DATA 0D,0A
00910:  DATA 00,00
00912:  DATA 5F,5F
00914:  DATA 5F,53
00916:  DATA 74,61
00918:  DATA 72,74
0091A:  DATA 20,53
0091C:  DATA 4D,46
0091E:  DATA 20,52
00920:  DATA 65,61
00922:  DATA 64,5F
00924:  DATA 5F,5F
00926:  DATA 5F,0D
00928:  DATA 0A,00
0092A:  DATA 49,6E
0092C:  DATA 20,53
0092E:  DATA 4D,46
00930:  DATA 20,52
00932:  DATA 65,61
00934:  DATA 64,20
00936:  DATA 73,6F
00938:  DATA 75,72
0093A:  DATA 63,65
0093C:  DATA 20,64
0093E:  DATA 61,74
00940:  DATA 61,20
00942:  DATA 61,64
00944:  DATA 64,72
00946:  DATA 65,73
00948:  DATA 73,3A
0094A:  DATA 20,25
0094C:  DATA 4C,58
0094E:  DATA 0D,0A
00950:  DATA 00,00
00952:  DATA 49,6E
00954:  DATA 20,53
00956:  DATA 4D,46
00958:  DATA 20,52
0095A:  DATA 65,61
0095C:  DATA 64,20
0095E:  DATA 64,61
00960:  DATA 74,61
00962:  DATA 20,73
00964:  DATA 69,7A
00966:  DATA 65,20
00968:  DATA 20,20
0096A:  DATA 20,20
0096C:  DATA 20,20
0096E:  DATA 20,20
00970:  DATA 20,3A
00972:  DATA 20,25
00974:  DATA 6C,75
00976:  DATA 20,28
00978:  DATA 30,78
0097A:  DATA 25,6C
0097C:  DATA 78,29
0097E:  DATA 0D,0A
00980:  DATA 0D,0A
00982:  DATA 00,00
00984:  DATA 45,72
00986:  DATA 72,6F
00988:  DATA 72,3A
0098A:  DATA 20,53
0098C:  DATA 4D,46
0098E:  DATA 20,69
00990:  DATA 73,20
00992:  DATA 6E,6F
00994:  DATA 74,20
00996:  DATA 63,6F
00998:  DATA 6E,6E
0099A:  DATA 65,63
0099C:  DATA 74,65
0099E:  DATA 64,0D
009A0:  DATA 0A,00
009A2:  DATA 52,45
009A4:  DATA 41,44
009A6:  DATA 20,44
009A8:  DATA 41,54
009AA:  DATA 41,20
009AC:  DATA 46,52
009AE:  DATA 4F,4D
009B0:  DATA 20,53
009B2:  DATA 4D,46
009B4:  DATA 2E,2E
009B6:  DATA 2E,0D
009B8:  DATA 0A,00
009BA:  DATA 0D,0A
009BC:  DATA 5F,5F
009BE:  DATA 5F,45
009C0:  DATA 6E,64
009C2:  DATA 20,53
009C4:  DATA 4D,46
009C6:  DATA 20,52
009C8:  DATA 65,61
009CA:  DATA 64,5F
009CC:  DATA 5F,5F
009CE:  DATA 5F,0D
009D0:  DATA 0A,00
009D2:  DATA 5F,5F
009D4:  DATA 5F,5F
009D6:  DATA 5F,5F
009D8:  DATA 5F,5F
009DA:  DATA 5F,5F
009DC:  DATA 5F,5F
009DE:  DATA 5F,5F
009E0:  DATA 5F,5F
009E2:  DATA 5F,5F
009E4:  DATA 5F,5F
009E6:  DATA 0D,0A
009E8:  DATA 0D,0A
009EA:  DATA 00,00
009EC:  DATA 0D,0A
009EE:  DATA 5F,5F
009F0:  DATA 5F,5F
009F2:  DATA 5F,5F
009F4:  DATA 5F,5F
009F6:  DATA 5F,5F
009F8:  DATA 5F,5F
009FA:  DATA 5F,5F
009FC:  DATA 5F,5F
009FE:  DATA 5F,5F
00A00:  DATA 5F,5F
00A02:  DATA 0D,0A
00A04:  DATA 00,00
00A06:  DATA 5F,5F
00A08:  DATA 5F,53
00A0A:  DATA 74,61
00A0C:  DATA 72,74
00A0E:  DATA 20,73
00A10:  DATA 6D,66
00A12:  DATA 5F,65
00A14:  DATA 72,61
00A16:  DATA 73,65
00A18:  DATA 5F,5F
00A1A:  DATA 5F,5F
00A1C:  DATA 0D,0A
00A1E:  DATA 00,00
00A20:  DATA 49,6E
00A22:  DATA 20,53
00A24:  DATA 4D,46
00A26:  DATA 20,45
00A28:  DATA 72,61
00A2A:  DATA 73,65
00A2C:  DATA 20,73
00A2E:  DATA 6F,75
00A30:  DATA 72,63
00A32:  DATA 65,20
00A34:  DATA 64,61
00A36:  DATA 74,61
00A38:  DATA 20,61
00A3A:  DATA 64,64
00A3C:  DATA 72,65
00A3E:  DATA 73,73
00A40:  DATA 3A,20
00A42:  DATA 25,4C
00A44:  DATA 58,0D
00A46:  DATA 0A,00
00A48:  DATA 49,6E
00A4A:  DATA 20,53
00A4C:  DATA 4D,46
00A4E:  DATA 20,45
00A50:  DATA 72,61
00A52:  DATA 73,65
00A54:  DATA 20,64
00A56:  DATA 61,74
00A58:  DATA 61,20
00A5A:  DATA 73,69
00A5C:  DATA 7A,65
00A5E:  DATA 20,20
00A60:  DATA 20,20
00A62:  DATA 20,20
00A64:  DATA 20,20
00A66:  DATA 20,20
00A68:  DATA 3A,20
00A6A:  DATA 25,6C
00A6C:  DATA 75,20
00A6E:  DATA 28,30
00A70:  DATA 78,25
00A72:  DATA 6C,78
00A74:  DATA 29,0D
00A76:  DATA 0A,0D
00A78:  DATA 0A,00
00A7A:  DATA 45,72
00A7C:  DATA 72,6F
00A7E:  DATA 72,3A
00A80:  DATA 20,53
00A82:  DATA 4D,46
00A84:  DATA 20,69
00A86:  DATA 73,20
00A88:  DATA 6E,6F
00A8A:  DATA 74,20
00A8C:  DATA 63,6F
00A8E:  DATA 6E,6E
00A90:  DATA 65,63
00A92:  DATA 74,65
00A94:  DATA 64,0D
00A96:  DATA 0A,00
00A98:  DATA 45,72
00A9A:  DATA 72,6F
00A9C:  DATA 72,3A
00A9E:  DATA 20,45
00AA0:  DATA 72,61
00AA2:  DATA 73,65
00AA4:  DATA 20,73
00AA6:  DATA 6F,75
00AA8:  DATA 72,63
00AAA:  DATA 65,20
00AAC:  DATA 61,64
00AAE:  DATA 64,72
00AB0:  DATA 65,73
00AB2:  DATA 73,20
00AB4:  DATA 30,78
00AB6:  DATA 25,4C
00AB8:  DATA 58,20
00ABA:  DATA 69,73
00ABC:  DATA 20,6F
00ABE:  DATA 75,74
00AC0:  DATA 73,69
00AC2:  DATA 64,65
00AC4:  DATA 20,6D
00AC6:  DATA 69,73
00AC8:  DATA 73,69
00ACA:  DATA 6F,6E
00ACC:  DATA 20,72
00ACE:  DATA 61,6E
00AD0:  DATA 67,65
00AD2:  DATA 20,5B
00AD4:  DATA 30,78
00AD6:  DATA 25,4C
00AD8:  DATA 58,20
00ADA:  DATA 2D,20
00ADC:  DATA 30,78
00ADE:  DATA 25,4C
00AE0:  DATA 58,5D
00AE2:  DATA 0D,0A
00AE4:  DATA 00,00
00AE6:  DATA 45,72
00AE8:  DATA 72,6F
00AEA:  DATA 72,3A
00AEC:  DATA 20,45
00AEE:  DATA 72,61
00AF0:  DATA 73,65
00AF2:  DATA 20,6F
00AF4:  DATA 70,65
00AF6:  DATA 72,61
00AF8:  DATA 74,69
00AFA:  DATA 6F,6E
00AFC:  DATA 20,77
00AFE:  DATA 6F,75
00B00:  DATA 6C,64
00B02:  DATA 20,65
00B04:  DATA 78,63
00B06:  DATA 65,65
00B08:  DATA 64,20
00B0A:  DATA 6D,69
00B0C:  DATA 73,73
00B0E:  DATA 69,6F
00B10:  DATA 6E,20
00B12:  DATA 65,6E
00B14:  DATA 64,20
00B16:  DATA 61,64
00B18:  DATA 64,72
00B1A:  DATA 65,73
00B1C:  DATA 73,20
00B1E:  DATA 30,78
00B20:  DATA 25,4C
00B22:  DATA 58,0D
00B24:  DATA 0A,00
00B26:  DATA 4C,69
00B28:  DATA 6D,69
00B2A:  DATA 74,69
00B2C:  DATA 6E,67
00B2E:  DATA 20,65
00B30:  DATA 72,61
00B32:  DATA 73,65
00B34:  DATA 20,73
00B36:  DATA 69,7A
00B38:  DATA 65,20
00B3A:  DATA 74,6F
00B3C:  DATA 20,73
00B3E:  DATA 74,61
00B40:  DATA 79,20
00B42:  DATA 77,69
00B44:  DATA 74,68
00B46:  DATA 69,6E
00B48:  DATA 20,6D
00B4A:  DATA 69,73
00B4C:  DATA 73,69
00B4E:  DATA 6F,6E
00B50:  DATA 20,62
00B52:  DATA 6F,75
00B54:  DATA 6E,64
00B56:  DATA 73,0D
00B58:  DATA 0A,00
00B5A:  DATA 45,72
00B5C:  DATA 61,73
00B5E:  DATA 65,20
00B60:  DATA 6F,70
00B62:  DATA 65,72
00B64:  DATA 61,74
00B66:  DATA 69,6F
00B68:  DATA 6E,20
00B6A:  DATA 76,61
00B6C:  DATA 6C,69
00B6E:  DATA 64,61
00B70:  DATA 74,65
00B72:  DATA 64,20
00B74:  DATA 77,69
00B76:  DATA 74,68
00B78:  DATA 69,6E
00B7A:  DATA 20,6D
00B7C:  DATA 69,73
00B7E:  DATA 73,69
00B80:  DATA 6F,6E
00B82:  DATA 20,72
00B84:  DATA 61,6E
00B86:  DATA 67,65
00B88:  DATA 0D,0A
00B8A:  DATA 00,00
00B8C:  DATA 0D,0A
00B8E:  DATA 5F,5F
00B90:  DATA 5F,45
00B92:  DATA 6E,64
00B94:  DATA 20,73
00B96:  DATA 6D,66
00B98:  DATA 5F,65
00B9A:  DATA 72,61
00B9C:  DATA 73,65
00B9E:  DATA 5F,5F
00BA0:  DATA 5F,5F
00BA2:  DATA 0D,0A
00BA4:  DATA 00,00
00BA6:  DATA 5F,5F
00BA8:  DATA 5F,5F
00BAA:  DATA 5F,5F
00BAC:  DATA 5F,5F
00BAE:  DATA 5F,5F
00BB0:  DATA 5F,5F
00BB2:  DATA 5F,5F
00BB4:  DATA 5F,5F
00BB6:  DATA 5F,5F
00BB8:  DATA 5F,5F
00BBA:  DATA 0D,0A
00BBC:  DATA 0D,0A
00BBE:  DATA 00,00
00BC0:  DATA 45,72
00BC2:  DATA 72,6F
00BC4:  DATA 72,3A
00BC6:  DATA 20,55
00BC8:  DATA 6E,6B
00BCA:  DATA 6E,6F
00BCC:  DATA 77,6E
00BCE:  DATA 20,6D
00BD0:  DATA 69,73
00BD2:  DATA 73,69
00BD4:  DATA 6F,6E
00BD6:  DATA 5F,69
00BD8:  DATA 64,3A
00BDA:  DATA 20,25
00BDC:  DATA 30,32
00BDE:  DATA 58,0D
00BE0:  DATA 0A,00
00BE2:  DATA 55,70
00BE4:  DATA 64,61
00BE6:  DATA 74,65
00BE8:  DATA 64,20
00BEA:  DATA 70,61
00BEC:  DATA 72,74
00BEE:  DATA 69,74
00BF0:  DATA 69,6F
00BF2:  DATA 6E,20
00BF4:  DATA 66,6F
00BF6:  DATA 72,20
00BF8:  DATA 6D,69
00BFA:  DATA 73,73
00BFC:  DATA 69,6F
00BFE:  DATA 6E,5F
00C00:  DATA 69,64
00C02:  DATA 20,25
00C04:  DATA 30,32
00C06:  DATA 58,3A
00C08:  DATA 20,75
00C0A:  DATA 73,65
00C0C:  DATA 64,5F
00C0E:  DATA 73,69
00C10:  DATA 7A,65
00C12:  DATA 3D,25
00C14:  DATA 6C,64
00C16:  DATA 2C,20
00C18:  DATA 6C,6F
00C1A:  DATA 6F,70
00C1C:  DATA 5F,63
00C1E:  DATA 6F,75
00C20:  DATA 6E,74
00C22:  DATA 65,72
00C24:  DATA 3D,25
00C26:  DATA 6C,64
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 4D,49
00C2E:  DATA 53,53
00C30:  DATA 49,4F
00C32:  DATA 4E,20
00C34:  DATA 46,4C
00C36:  DATA 41,53
00C38:  DATA 48,20
00C3A:  DATA 49,6E
00C3C:  DATA 69,74
00C3E:  DATA 69,61
00C40:  DATA 6C,69
00C42:  DATA 7A,65
00C44:  DATA 0D,0A
00C46:  DATA 00,00
00C48:  DATA 09,5B
00C4A:  DATA 4D,49
00C4C:  DATA 53,20
00C4E:  DATA 46,4D
00C50:  DATA 5D,20
00C52:  DATA 52,45
00C54:  DATA 41,44
00C56:  DATA 20,49
00C58:  DATA 44,3A
00C5A:  DATA 20,00
00C5C:  DATA 09,5B
00C5E:  DATA 53,4D
00C60:  DATA 46,20
00C62:  DATA 20,20
00C64:  DATA 5D,20
00C66:  DATA 52,45
00C68:  DATA 41,44
00C6A:  DATA 20,49
00C6C:  DATA 44,3A
00C6E:  DATA 20,00
00C70:  DATA 09,5B
00C72:  DATA 53,4D
00C74:  DATA 46,20
00C76:  DATA 20,20
00C78:  DATA 5D,20
00C7A:  DATA 63,6F
00C7C:  DATA 6E,6E
00C7E:  DATA 65,63
00C80:  DATA 74,20
00C82:  DATA 65,72
00C84:  DATA 72,6F
00C86:  DATA 72,21
00C88:  DATA 0D,0A
00C8A:  DATA 00,00
00C8C:  DATA 09,5B
00C8E:  DATA 53,4D
00C90:  DATA 46,20
00C92:  DATA 20,20
00C94:  DATA 5D,20
00C96:  DATA 69,73
00C98:  DATA 20,63
00C9A:  DATA 6F,6E
00C9C:  DATA 6E,65
00C9E:  DATA 63,74
00CA0:  DATA 65,64
00CA2:  DATA 0D,0A
00CA4:  DATA 00,00
00CA6:  DATA 09,5B
00CA8:  DATA 4D,49
00CAA:  DATA 53,20
00CAC:  DATA 46,4D
00CAE:  DATA 5D,20
00CB0:  DATA 63,6F
00CB2:  DATA 6E,6E
00CB4:  DATA 65,63
00CB6:  DATA 74,20
00CB8:  DATA 65,72
00CBA:  DATA 72,6F
00CBC:  DATA 72,21
00CBE:  DATA 0D,0A
00CC0:  DATA 00,00
00CC2:  DATA 09,5B
00CC4:  DATA 4D,49
00CC6:  DATA 53,20
00CC8:  DATA 46,4D
00CCA:  DATA 5D,20
00CCC:  DATA 69,73
00CCE:  DATA 20,63
00CD0:  DATA 6F,6E
00CD2:  DATA 6E,65
00CD4:  DATA 63,74
00CD6:  DATA 65,64
00CD8:  DATA 0D,0A
00CDA:  DATA 00,00
00CDC:  DATA 09,5B
00CDE:  DATA 4D,49
00CE0:  DATA 53,20
00CE2:  DATA 46,4D
00CE4:  DATA 5D,20
00CE6:  DATA 43,52
00CE8:  DATA 43,20
00CEA:  DATA 65,72
00CEC:  DATA 72,6F
00CEE:  DATA 72,21
00CF0:  DATA 0D,0A
00CF2:  DATA 00,00
00CF4:  DATA 09,7C
00CF6:  DATA 20,4D
00CF8:  DATA 49,53
00CFA:  DATA 46,20
00CFC:  DATA 7C,20
00CFE:  DATA 50,49
00D00:  DATA 43,4C
00D02:  DATA 4F,47
00D04:  DATA 20,20
00D06:  DATA 20,20
00D08:  DATA 7C,20
00D0A:  DATA 55,73
00D0C:  DATA 65,20
00D0E:  DATA 43,6F
00D10:  DATA 75,6E
00D12:  DATA 74,65
00D14:  DATA 72,20
00D16:  DATA 20,20
00D18:  DATA 20,20
00D1A:  DATA 20,3A
00D1C:  DATA 20,30
00D1E:  DATA 78,25
00D20:  DATA 30,38
00D22:  DATA 4C,58
00D24:  DATA 0D,0A
00D26:  DATA 00,00
00D28:  DATA 09,7C
00D2A:  DATA 20,4D
00D2C:  DATA 49,53
00D2E:  DATA 46,20
00D30:  DATA 7C,20
00D32:  DATA 50,49
00D34:  DATA 43,4C
00D36:  DATA 4F,47
00D38:  DATA 20,20
00D3A:  DATA 20,20
00D3C:  DATA 7C,20
00D3E:  DATA 55,6E
00D40:  DATA 63,6F
00D42:  DATA 70,79
00D44:  DATA 65,64
00D46:  DATA 20,43
00D48:  DATA 6F,75
00D4A:  DATA 6E,74
00D4C:  DATA 65,72
00D4E:  DATA 20,3A
00D50:  DATA 20,30
00D52:  DATA 78,25
00D54:  DATA 30,38
00D56:  DATA 4C,58
00D58:  DATA 0D,0A
00D5A:  DATA 00,00
00D5C:  DATA 09,7C
00D5E:  DATA 20,4D
00D60:  DATA 49,53
00D62:  DATA 46,20
00D64:  DATA 7C,20
00D66:  DATA 50,49
00D68:  DATA 43,4C
00D6A:  DATA 4F,47
00D6C:  DATA 20,20
00D6E:  DATA 20,20
00D70:  DATA 7C,20
00D72:  DATA 52,65
00D74:  DATA 73,65
00D76:  DATA 72,76
00D78:  DATA 65,20
00D7A:  DATA 43,6F
00D7C:  DATA 75,6E
00D7E:  DATA 74,65
00D80:  DATA 72,31
00D82:  DATA 20,3A
00D84:  DATA 20,30
00D86:  DATA 78,25
00D88:  DATA 30,32
00D8A:  DATA 58,0D
00D8C:  DATA 0A,00
00D8E:  DATA 09,7C
00D90:  DATA 20,4D
00D92:  DATA 49,53
00D94:  DATA 46,20
00D96:  DATA 7C,20
00D98:  DATA 50,49
00D9A:  DATA 43,4C
00D9C:  DATA 4F,47
00D9E:  DATA 20,20
00DA0:  DATA 20,20
00DA2:  DATA 7C,20
00DA4:  DATA 52,65
00DA6:  DATA 73,65
00DA8:  DATA 72,76
00DAA:  DATA 65,20
00DAC:  DATA 43,6F
00DAE:  DATA 75,6E
00DB0:  DATA 74,65
00DB2:  DATA 72,32
00DB4:  DATA 20,3A
00DB6:  DATA 20,30
00DB8:  DATA 78,25
00DBA:  DATA 30,32
00DBC:  DATA 58,0D
00DBE:  DATA 0A,00
00DC0:  DATA 09,7C
00DC2:  DATA 20,4D
00DC4:  DATA 49,53
00DC6:  DATA 46,20
00DC8:  DATA 7C,20
00DCA:  DATA 45,4E
00DCC:  DATA 56,49
00DCE:  DATA 52,4F
00DD0:  DATA 20,20
00DD2:  DATA 20,20
00DD4:  DATA 7C,20
00DD6:  DATA 55,73
00DD8:  DATA 65,20
00DDA:  DATA 43,6F
00DDC:  DATA 75,6E
00DDE:  DATA 74,65
00DE0:  DATA 72,20
00DE2:  DATA 20,20
00DE4:  DATA 20,20
00DE6:  DATA 20,3A
00DE8:  DATA 20,30
00DEA:  DATA 78,25
00DEC:  DATA 30,38
00DEE:  DATA 4C,58
00DF0:  DATA 0D,0A
00DF2:  DATA 00,00
00DF4:  DATA 09,7C
00DF6:  DATA 20,4D
00DF8:  DATA 49,53
00DFA:  DATA 46,20
00DFC:  DATA 7C,20
00DFE:  DATA 45,4E
00E00:  DATA 56,49
00E02:  DATA 52,4F
00E04:  DATA 20,20
00E06:  DATA 20,20
00E08:  DATA 7C,20
00E0A:  DATA 55,6E
00E0C:  DATA 63,6F
00E0E:  DATA 70,79
00E10:  DATA 65,64
00E12:  DATA 20,43
00E14:  DATA 6F,75
00E16:  DATA 6E,74
00E18:  DATA 65,72
00E1A:  DATA 20,3A
00E1C:  DATA 20,30
00E1E:  DATA 78,25
00E20:  DATA 30,38
00E22:  DATA 4C,58
00E24:  DATA 0D,0A
00E26:  DATA 00,00
00E28:  DATA 09,7C
00E2A:  DATA 20,4D
00E2C:  DATA 49,53
00E2E:  DATA 46,20
00E30:  DATA 7C,20
00E32:  DATA 45,4E
00E34:  DATA 56,49
00E36:  DATA 52,4F
00E38:  DATA 20,20
00E3A:  DATA 20,20
00E3C:  DATA 7C,20
00E3E:  DATA 52,65
00E40:  DATA 73,65
00E42:  DATA 72,76
00E44:  DATA 65,20
00E46:  DATA 43,6F
00E48:  DATA 75,6E
00E4A:  DATA 74,65
00E4C:  DATA 72,31
00E4E:  DATA 20,3A
00E50:  DATA 20,30
00E52:  DATA 78,25
00E54:  DATA 30,32
00E56:  DATA 58,0D
00E58:  DATA 0A,00
00E5A:  DATA 09,7C
00E5C:  DATA 20,4D
00E5E:  DATA 49,53
00E60:  DATA 46,20
00E62:  DATA 7C,20
00E64:  DATA 45,4E
00E66:  DATA 56,49
00E68:  DATA 52,4F
00E6A:  DATA 20,20
00E6C:  DATA 20,20
00E6E:  DATA 7C,20
00E70:  DATA 52,65
00E72:  DATA 73,65
00E74:  DATA 72,76
00E76:  DATA 65,20
00E78:  DATA 43,6F
00E7A:  DATA 75,6E
00E7C:  DATA 74,65
00E7E:  DATA 72,32
00E80:  DATA 20,3A
00E82:  DATA 20,30
00E84:  DATA 78,25
00E86:  DATA 30,32
00E88:  DATA 58,0D
00E8A:  DATA 0A,00
00E8C:  DATA 09,7C
00E8E:  DATA 20,4D
00E90:  DATA 49,53
00E92:  DATA 46,20
00E94:  DATA 7C,20
00E96:  DATA 49,56
00E98:  DATA 20,48
00E9A:  DATA 45,41
00E9C:  DATA 44,45
00E9E:  DATA 52,20
00EA0:  DATA 7C,20
00EA2:  DATA 55,73
00EA4:  DATA 65,20
00EA6:  DATA 43,6F
00EA8:  DATA 75,6E
00EAA:  DATA 74,65
00EAC:  DATA 72,20
00EAE:  DATA 20,20
00EB0:  DATA 20,20
00EB2:  DATA 20,3A
00EB4:  DATA 20,30
00EB6:  DATA 78,25
00EB8:  DATA 30,38
00EBA:  DATA 4C,58
00EBC:  DATA 0D,0A
00EBE:  DATA 00,00
00EC0:  DATA 09,7C
00EC2:  DATA 20,4D
00EC4:  DATA 49,53
00EC6:  DATA 46,20
00EC8:  DATA 7C,20
00ECA:  DATA 49,56
00ECC:  DATA 20,48
00ECE:  DATA 45,41
00ED0:  DATA 44,45
00ED2:  DATA 52,20
00ED4:  DATA 7C,20
00ED6:  DATA 55,6E
00ED8:  DATA 63,6F
00EDA:  DATA 70,79
00EDC:  DATA 65,64
00EDE:  DATA 20,43
00EE0:  DATA 6F,75
00EE2:  DATA 6E,74
00EE4:  DATA 65,72
00EE6:  DATA 20,3A
00EE8:  DATA 20,30
00EEA:  DATA 78,25
00EEC:  DATA 30,38
00EEE:  DATA 4C,58
00EF0:  DATA 0D,0A
00EF2:  DATA 00,00
00EF4:  DATA 09,7C
00EF6:  DATA 20,4D
00EF8:  DATA 49,53
00EFA:  DATA 46,20
00EFC:  DATA 7C,20
00EFE:  DATA 49,56
00F00:  DATA 20,48
00F02:  DATA 45,41
00F04:  DATA 44,45
00F06:  DATA 52,20
00F08:  DATA 7C,20
00F0A:  DATA 52,65
00F0C:  DATA 73,65
00F0E:  DATA 72,76
00F10:  DATA 65,20
00F12:  DATA 43,6F
00F14:  DATA 75,6E
00F16:  DATA 74,65
00F18:  DATA 72,31
00F1A:  DATA 20,3A
00F1C:  DATA 20,30
00F1E:  DATA 78,25
00F20:  DATA 30,32
00F22:  DATA 58,0D
00F24:  DATA 0A,00
00F26:  DATA 09,7C
00F28:  DATA 20,4D
00F2A:  DATA 49,53
00F2C:  DATA 46,20
00F2E:  DATA 7C,20
00F30:  DATA 49,56
00F32:  DATA 20,48
00F34:  DATA 45,41
00F36:  DATA 44,45
00F38:  DATA 52,20
00F3A:  DATA 7C,20
00F3C:  DATA 52,65
00F3E:  DATA 73,65
00F40:  DATA 72,76
00F42:  DATA 65,20
00F44:  DATA 43,6F
00F46:  DATA 75,6E
00F48:  DATA 74,65
00F4A:  DATA 72,32
00F4C:  DATA 20,3A
00F4E:  DATA 20,30
00F50:  DATA 78,25
00F52:  DATA 30,32
00F54:  DATA 58,0D
00F56:  DATA 0A,00
00F58:  DATA 09,7C
00F5A:  DATA 20,4D
00F5C:  DATA 49,53
00F5E:  DATA 46,20
00F60:  DATA 7C,20
00F62:  DATA 49,56
00F64:  DATA 20,44
00F66:  DATA 41,54
00F68:  DATA 41,20
00F6A:  DATA 20,20
00F6C:  DATA 7C,20
00F6E:  DATA 55,73
00F70:  DATA 65,20
00F72:  DATA 43,6F
00F74:  DATA 75,6E
00F76:  DATA 74,65
00F78:  DATA 72,20
00F7A:  DATA 20,20
00F7C:  DATA 20,20
00F7E:  DATA 20,3A
00F80:  DATA 20,30
00F82:  DATA 78,25
00F84:  DATA 30,38
00F86:  DATA 4C,58
00F88:  DATA 0D,0A
00F8A:  DATA 00,00
00F8C:  DATA 09,7C
00F8E:  DATA 20,4D
00F90:  DATA 49,53
00F92:  DATA 46,20
00F94:  DATA 7C,20
00F96:  DATA 49,56
00F98:  DATA 20,44
00F9A:  DATA 41,54
00F9C:  DATA 41,20
00F9E:  DATA 20,20
00FA0:  DATA 7C,20
00FA2:  DATA 55,6E
00FA4:  DATA 63,6F
00FA6:  DATA 70,79
00FA8:  DATA 65,64
00FAA:  DATA 20,43
00FAC:  DATA 6F,75
00FAE:  DATA 6E,74
00FB0:  DATA 65,72
00FB2:  DATA 20,3A
00FB4:  DATA 20,30
00FB6:  DATA 78,25
00FB8:  DATA 30,38
00FBA:  DATA 4C,58
00FBC:  DATA 0D,0A
00FBE:  DATA 00,00
00FC0:  DATA 09,7C
00FC2:  DATA 20,4D
00FC4:  DATA 49,53
00FC6:  DATA 46,20
00FC8:  DATA 7C,20
00FCA:  DATA 49,56
00FCC:  DATA 20,44
00FCE:  DATA 41,54
00FD0:  DATA 41,20
00FD2:  DATA 20,20
00FD4:  DATA 7C,20
00FD6:  DATA 52,65
00FD8:  DATA 73,65
00FDA:  DATA 72,76
00FDC:  DATA 65,20
00FDE:  DATA 43,6F
00FE0:  DATA 75,6E
00FE2:  DATA 74,65
00FE4:  DATA 72,31
00FE6:  DATA 20,3A
00FE8:  DATA 20,30
00FEA:  DATA 78,25
00FEC:  DATA 30,32
00FEE:  DATA 58,0D
00FF0:  DATA 0A,00
00FF2:  DATA 09,7C
00FF4:  DATA 20,4D
00FF6:  DATA 49,53
00FF8:  DATA 46,20
00FFA:  DATA 7C,20
00FFC:  DATA 49,56
00FFE:  DATA 20,44
01000:  DATA 41,54
01002:  DATA 41,20
01004:  DATA 20,20
01006:  DATA 7C,20
01008:  DATA 52,65
0100A:  DATA 73,65
0100C:  DATA 72,76
0100E:  DATA 65,20
01010:  DATA 43,6F
01012:  DATA 75,6E
01014:  DATA 74,65
01016:  DATA 72,32
01018:  DATA 20,3A
0101A:  DATA 20,30
0101C:  DATA 78,25
0101E:  DATA 30,32
01020:  DATA 58,0D
01022:  DATA 0A,00
01024:  DATA 09,43
01026:  DATA 6F,6D
01028:  DATA 70,6C
0102A:  DATA 65,74
0102C:  DATA 65,0D
0102E:  DATA 0A,00
01030:  DATA 43,52
01032:  DATA 43,20
01034:  DATA 76,65
01036:  DATA 72,69
01038:  DATA 66,69
0103A:  DATA 63,61
0103C:  DATA 74,69
0103E:  DATA 6F,6E
01040:  DATA 20,70
01042:  DATA 61,73
01044:  DATA 73,65
01046:  DATA 64,20
01048:  DATA 6F,6E
0104A:  DATA 20,61
0104C:  DATA 74,74
0104E:  DATA 65,6D
01050:  DATA 70,74
01052:  DATA 20,25
01054:  DATA 64,0D
01056:  DATA 0A,00
01058:  DATA 45,72
0105A:  DATA 72,6F
0105C:  DATA 72,3A
0105E:  DATA 20,43
01060:  DATA 52,43
01062:  DATA 20,76
01064:  DATA 65,72
01066:  DATA 69,66
01068:  DATA 69,63
0106A:  DATA 61,74
0106C:  DATA 69,6F
0106E:  DATA 6E,20
01070:  DATA 66,61
01072:  DATA 69,6C
01074:  DATA 65,64
01076:  DATA 20,61
01078:  DATA 66,74
0107A:  DATA 65,72
0107C:  DATA 20,25
0107E:  DATA 64,20
01080:  DATA 61,74
01082:  DATA 74,65
01084:  DATA 6D,70
01086:  DATA 74,73
01088:  DATA 0D,0A
0108A:  DATA 00,00
0108C:  DATA 0D,0A
0108E:  DATA 5F,5F
01090:  DATA 5F,5F
01092:  DATA 5F,5F
01094:  DATA 5F,5F
01096:  DATA 5F,5F
01098:  DATA 5F,5F
0109A:  DATA 5F,5F
0109C:  DATA 5F,5F
0109E:  DATA 5F,5F
010A0:  DATA 5F,5F
010A2:  DATA 5F,5F
010A4:  DATA 5F,5F
010A6:  DATA 5F,5F
010A8:  DATA 5F,5F
010AA:  DATA 5F,5F
010AC:  DATA 0D,0A
010AE:  DATA 5F,5F
010B0:  DATA 5F,5F
010B2:  DATA 5F,53
010B4:  DATA 74,61
010B6:  DATA 72,74
010B8:  DATA 20,65
010BA:  DATA 78,65
010BC:  DATA 63,75
010BE:  DATA 74,65
010C0:  DATA 5F,6D
010C2:  DATA 69,73
010C4:  DATA 73,69
010C6:  DATA 6F,6E
010C8:  DATA 5F,5F
010CA:  DATA 5F,5F
010CC:  DATA 5F,0D
010CE:  DATA 0A,0D
010D0:  DATA 0A,00
010D2:  DATA 43,6F
010D4:  DATA 6D,6D
010D6:  DATA 61,6E
010D8:  DATA 64,20
010DA:  DATA 49,44
010DC:  DATA 3A,20
010DE:  DATA 25,58
010E0:  DATA 0D,0A
010E2:  DATA 0D,0A
010E4:  DATA 00,00
010E6:  DATA 09,09
010E8:  DATA 2D,3E
010EA:  DATA 20,49
010EC:  DATA 6E,76
010EE:  DATA 61,6C
010F0:  DATA 69,64
010F2:  DATA 20,43
010F4:  DATA 4D,44
010F6:  DATA 20,49
010F8:  DATA 44,21
010FA:  DATA 0D,0A
010FC:  DATA 00,00
010FE:  DATA 0D,0A
01100:  DATA 5F,5F
01102:  DATA 5F,5F
01104:  DATA 5F,5F
01106:  DATA 45,6E
01108:  DATA 64,20
0110A:  DATA 65,78
0110C:  DATA 65,63
0110E:  DATA 75,74
01110:  DATA 65,5F
01112:  DATA 6D,69
01114:  DATA 73,73
01116:  DATA 69,6F
01118:  DATA 6E,5F
0111A:  DATA 5F,5F
0111C:  DATA 5F,5F
0111E:  DATA 5F,0D
01120:  DATA 0A,5F
01122:  DATA 5F,5F
01124:  DATA 5F,5F
01126:  DATA 5F,5F
01128:  DATA 5F,5F
0112A:  DATA 5F,5F
0112C:  DATA 5F,5F
0112E:  DATA 5F,5F
01130:  DATA 5F,5F
01132:  DATA 5F,5F
01134:  DATA 5F,5F
01136:  DATA 5F,5F
01138:  DATA 5F,5F
0113A:  DATA 5F,5F
0113C:  DATA 5F,5F
0113E:  DATA 5F,5F
01140:  DATA 0D,0A
01142:  DATA 00,00
01144:  DATA 53,74
01146:  DATA 61,72
01148:  DATA 74,20
0114A:  DATA 65,78
0114C:  DATA 65,63
0114E:  DATA 75,74
01150:  DATA 65,5F
01152:  DATA 63,6F
01154:  DATA 6D,6D
01156:  DATA 61,6E
01158:  DATA 64,0D
0115A:  DATA 0A,00
0115C:  DATA 09,2D
0115E:  DATA 3E,20
01160:  DATA 55,70
01162:  DATA 6C,69
01164:  DATA 6E,6B
01166:  DATA 20,63
01168:  DATA 6F,6D
0116A:  DATA 6D,61
0116C:  DATA 6E,64
0116E:  DATA 0D,0A
01170:  DATA 00,00
01172:  DATA 09,20
01174:  DATA 20,20
01176:  DATA 54,72
01178:  DATA 61,6E
0117A:  DATA 73,6D
0117C:  DATA 69,74
0117E:  DATA 20,41
01180:  DATA 63,6B
01182:  DATA 6E,6F
01184:  DATA 6C,65
01186:  DATA 67,64
01188:  DATA 65,0D
0118A:  DATA 0A,00
0118C:  DATA 09,2D
0118E:  DATA 3E,20
01190:  DATA 53,74
01192:  DATA 61,74
01194:  DATA 75,73
01196:  DATA 20,63
01198:  DATA 68,65
0119A:  DATA 63,6B
0119C:  DATA 0D,0A
0119E:  DATA 00,00
011A0:  DATA 09,20
011A2:  DATA 20,20
011A4:  DATA 54,72
011A6:  DATA 61,6E
011A8:  DATA 73,6D
011AA:  DATA 69,74
011AC:  DATA 20,4D
011AE:  DATA 49,53
011B0:  DATA 20,4D
011B2:  DATA 43,55
011B4:  DATA 20,53
011B6:  DATA 74,61
011B8:  DATA 74,75
011BA:  DATA 73,0D
011BC:  DATA 0A,00
011BE:  DATA 66,69
011C0:  DATA 6E,69
011C2:  DATA 73,68
011C4:  DATA 65,64
011C6:  DATA 20,69
011C8:  DATA 6E,20
011CA:  DATA 73,74
011CC:  DATA 61,74
011CE:  DATA 75,73
011D0:  DATA 5F,63
011D2:  DATA 68,65
011D4:  DATA 63,6B
011D6:  DATA 0D,0A
011D8:  DATA 00,00
011DA:  DATA 09,2D
011DC:  DATA 3E,20
011DE:  DATA 53,4D
011E0:  DATA 46,20
011E2:  DATA 61,76
011E4:  DATA 61,69
011E6:  DATA 6C,61
011E8:  DATA 62,6C
011EA:  DATA 65,20
011EC:  DATA 63,68
011EE:  DATA 65,63
011F0:  DATA 6B,0D
011F2:  DATA 0A,00
011F4:  DATA 09,20
011F6:  DATA 20,20
011F8:  DATA 54,72
011FA:  DATA 61,6E
011FC:  DATA 73,6D
011FE:  DATA 69,74
01200:  DATA 20,41
01202:  DATA 63,6B
01204:  DATA 6E,6F
01206:  DATA 77,6C
01208:  DATA 65,64
0120A:  DATA 67,65
0120C:  DATA 6D,65
0120E:  DATA 6E,74
01210:  DATA 0D,0A
01212:  DATA 00,00
01214:  DATA 09,09
01216:  DATA 2D,3E
01218:  DATA 20,61
0121A:  DATA 6C,6C
0121C:  DATA 6F,77
0121E:  DATA 65,64
01220:  DATA 0D,0A
01222:  DATA 00,00
01224:  DATA 09,09
01226:  DATA 2D,3E
01228:  DATA 20,50
0122A:  DATA 72,6F
0122C:  DATA 63,65
0122E:  DATA 73,73
01230:  DATA 69,6E
01232:  DATA 67,20
01234:  DATA 53,4D
01236:  DATA 46,20
01238:  DATA 64,61
0123A:  DATA 74,61
0123C:  DATA 20,5B
0123E:  DATA 25,64
01240:  DATA 5D,0D
01242:  DATA 0A,00
01244:  DATA 66,75
01246:  DATA 6E,63
01248:  DATA 20,74
0124A:  DATA 79,70
0124C:  DATA 65,20
0124E:  DATA 3A,20
01250:  DATA 30,78
01252:  DATA 25,30
01254:  DATA 32,58
01256:  DATA 00,00
01258:  DATA 09,09
0125A:  DATA 2D,3E
0125C:  DATA 20,45
0125E:  DATA 78,65
01260:  DATA 63,75
01262:  DATA 74,69
01264:  DATA 6E,67
01266:  DATA 20,53
01268:  DATA 4D,46
0126A:  DATA 20,57
0126C:  DATA 52,49
0126E:  DATA 54,45
01270:  DATA 20,28
01272:  DATA 73,69
01274:  DATA 6E,67
01276:  DATA 6C,65
01278:  DATA 29,0D
0127A:  DATA 0A,00
0127C:  DATA 09,09
0127E:  DATA 2D,3E
01280:  DATA 20,45
01282:  DATA 78,65
01284:  DATA 63,75
01286:  DATA 74,69
01288:  DATA 6E,67
0128A:  DATA 20,53
0128C:  DATA 4D,46
0128E:  DATA 20,52
01290:  DATA 45,41
01292:  DATA 44,20
01294:  DATA 28,73
01296:  DATA 69,6E
01298:  DATA 67,6C
0129A:  DATA 65,29
0129C:  DATA 0D,0A
0129E:  DATA 00,00
012A0:  DATA 09,09
012A2:  DATA 2D,3E
012A4:  DATA 20,45
012A6:  DATA 78,65
012A8:  DATA 63,75
012AA:  DATA 74,69
012AC:  DATA 6E,67
012AE:  DATA 20,53
012B0:  DATA 4D,46
012B2:  DATA 20,45
012B4:  DATA 52,41
012B6:  DATA 53,45
012B8:  DATA 20,28
012BA:  DATA 73,69
012BC:  DATA 6E,67
012BE:  DATA 6C,65
012C0:  DATA 29,0D
012C2:  DATA 0A,00
012C4:  DATA 09,09
012C6:  DATA 2D,3E
012C8:  DATA 20,55
012CA:  DATA 6E,6B
012CC:  DATA 6E,6F
012CE:  DATA 77,6E
012D0:  DATA 20,53
012D2:  DATA 4D,46
012D4:  DATA 20,66
012D6:  DATA 75,6E
012D8:  DATA 63,74
012DA:  DATA 69,6F
012DC:  DATA 6E,20
012DE:  DATA 74,79
012E0:  DATA 70,65
012E2:  DATA 0D,0A
012E4:  DATA 00,00
012E6:  DATA 09,09
012E8:  DATA 2D,3E
012EA:  DATA 20,45
012EC:  DATA 72,72
012EE:  DATA 6F,72
012F0:  DATA 3A,20
012F2:  DATA 46,61
012F4:  DATA 69,6C
012F6:  DATA 65,64
012F8:  DATA 20,74
012FA:  DATA 6F,20
012FC:  DATA 64,65
012FE:  DATA 71,75
01300:  DATA 65,75
01302:  DATA 65,20
01304:  DATA 53,4D
01306:  DATA 46,20
01308:  DATA 64,61
0130A:  DATA 74,61
0130C:  DATA 0D,0A
0130E:  DATA 00,00
01310:  DATA 09,09
01312:  DATA 2D,3E
01314:  DATA 20,43
01316:  DATA 6F,6D
01318:  DATA 70,6C
0131A:  DATA 65,74
0131C:  DATA 65,64
0131E:  DATA 20,70
01320:  DATA 72,6F
01322:  DATA 63,65
01324:  DATA 73,73
01326:  DATA 69,6E
01328:  DATA 67,20
0132A:  DATA 25,64
0132C:  DATA 20,53
0132E:  DATA 4D,46
01330:  DATA 20,6F
01332:  DATA 70,65
01334:  DATA 72,61
01336:  DATA 74,69
01338:  DATA 6F,6E
0133A:  DATA 73,0D
0133C:  DATA 0A,00
0133E:  DATA 09,09
01340:  DATA 2D,3E
01342:  DATA 20,64
01344:  DATA 65,6E
01346:  DATA 69,65
01348:  DATA 64,0D
0134A:  DATA 0A,00
0134C:  DATA 53,74
0134E:  DATA 61,72
01350:  DATA 74,20
01352:  DATA 4D,4F
01354:  DATA 44,45
01356:  DATA 20,44
01358:  DATA 55,4D
0135A:  DATA 4D,59
0135C:  DATA 0D,0A
0135E:  DATA 00,00
01360:  DATA 09,4D
01362:  DATA 4F,44
01364:  DATA 45,20
01366:  DATA 20,20
01368:  DATA 20,20
0136A:  DATA 3A,20
0136C:  DATA 25,30
0136E:  DATA 32,58
01370:  DATA 0D,0A
01372:  DATA 00,00
01374:  DATA 09,50
01376:  DATA 61,72
01378:  DATA 61,6D
0137A:  DATA 31,20
0137C:  DATA 20,20
0137E:  DATA 3A,20
01380:  DATA 30,78
01382:  DATA 25,30
01384:  DATA 38,4C
01386:  DATA 58,0D
01388:  DATA 0A,00
0138A:  DATA 09,50
0138C:  DATA 61,72
0138E:  DATA 61,6D
01390:  DATA 32,20
01392:  DATA 20,20
01394:  DATA 3A,20
01396:  DATA 30,78
01398:  DATA 25,30
0139A:  DATA 34,4C
0139C:  DATA 58,0D
0139E:  DATA 0A,00
013A0:  DATA 45,6E
013A2:  DATA 64,20
013A4:  DATA 4D,4F
013A6:  DATA 44,45
013A8:  DATA 20,44
013AA:  DATA 55,4D
013AC:  DATA 4D,59
013AE:  DATA 0D,0A
013B0:  DATA 00,00
013B2:  DATA 53,74
013B4:  DATA 61,72
013B6:  DATA 74,20
013B8:  DATA 4D,4F
013BA:  DATA 44,45
013BC:  DATA 20,54
013BE:  DATA 45,53
013C0:  DATA 54,20
013C2:  DATA 49,56
013C4:  DATA 0D,0A
013C6:  DATA 00,00
013C8:  DATA 09,53
013CA:  DATA 77,65
013CC:  DATA 65,70
013CE:  DATA 20,73
013D0:  DATA 74,65
013D2:  DATA 70,20
013D4:  DATA 3A,20
013D6:  DATA 25,75
013D8:  DATA 0D,0A
013DA:  DATA 00,00
013DC:  DATA 45,6E
013DE:  DATA 64,20
013E0:  DATA 4D,4F
013E2:  DATA 44,45
013E4:  DATA 20,54
013E6:  DATA 45,53
013E8:  DATA 54,20
013EA:  DATA 49,56
013EC:  DATA 0D,0A
013EE:  DATA 00,00
013F0:  DATA 53,74
013F2:  DATA 61,72
013F4:  DATA 74,20
013F6:  DATA 4D,4F
013F8:  DATA 44,45
013FA:  DATA 20,4D
013FC:  DATA 45,41
013FE:  DATA 53,20
01400:  DATA 49,56
01402:  DATA 0D,0A
01404:  DATA 00,00
01406:  DATA 09,49
01408:  DATA 44,3A
0140A:  DATA 20,25
0140C:  DATA 30,32
0140E:  DATA 58,0D
01410:  DATA 0A,00
01412:  DATA 09,53
01414:  DATA 6C,65
01416:  DATA 65,70
01418:  DATA 20,54
0141A:  DATA 69,6D
0141C:  DATA 65,3A
0141E:  DATA 20,25
01420:  DATA 30,34
01422:  DATA 4C,58
01424:  DATA 20,6D
01426:  DATA 73,0D
01428:  DATA 0A,00
0142A:  DATA 09,43
0142C:  DATA 75,72
0142E:  DATA 72,65
01430:  DATA 6E,74
01432:  DATA 20,54
01434:  DATA 68,72
01436:  DATA 65,73
01438:  DATA 68,6F
0143A:  DATA 6C,64
0143C:  DATA 3A,20
0143E:  DATA 25,30
01440:  DATA 34,4C
01442:  DATA 58,20
01444:  DATA 6D,41
01446:  DATA 0D,0A
01448:  DATA 00,00
0144A:  DATA 09,50
0144C:  DATA 44,20
0144E:  DATA 54,68
01450:  DATA 72,65
01452:  DATA 73,68
01454:  DATA 6F,6C
01456:  DATA 64,3A
01458:  DATA 20,25
0145A:  DATA 30,34
0145C:  DATA 4C,58
0145E:  DATA 20,6D
01460:  DATA 41,0D
01462:  DATA 0A,00
01464:  DATA 09,43
01466:  DATA 75,72
01468:  DATA 72,65
0146A:  DATA 6E,74
0146C:  DATA 20,4C
0146E:  DATA 69,6D
01470:  DATA 69,74
01472:  DATA 3A,20
01474:  DATA 25,30
01476:  DATA 34,4C
01478:  DATA 58,20
0147A:  DATA 6D,41
0147C:  DATA 0D,0A
0147E:  DATA 00,00
01480:  DATA 09,4D
01482:  DATA 65,61
01484:  DATA 73,75
01486:  DATA 72,65
01488:  DATA 6D,65
0148A:  DATA 6E,74
0148C:  DATA 20,54
0148E:  DATA 69,6D
01490:  DATA 65,3A
01492:  DATA 20,25
01494:  DATA 30,34
01496:  DATA 4C,58
01498:  DATA 20,73
0149A:  DATA 0D,0A
0149C:  DATA 00,00
0149E:  DATA 09,49
014A0:  DATA 73,20
014A2:  DATA 46,69
014A4:  DATA 6E,69
014A6:  DATA 73,68
014A8:  DATA 65,64
014AA:  DATA 3A,20
014AC:  DATA 25,75
014AE:  DATA 0D,0A
014B0:  DATA 00,00
014B2:  DATA 45,6E
014B4:  DATA 64,20
014B6:  DATA 4D,4F
014B8:  DATA 44,45
014BA:  DATA 20,4D
014BC:  DATA 45,41
014BE:  DATA 53,20
014C0:  DATA 49,56
014C2:  DATA 0D,0A
014C4:  DATA 00,00
014C6:  DATA 53,74
014C8:  DATA 61,72
014CA:  DATA 74,20
014CC:  DATA 46,6C
014CE:  DATA 61,73
014D0:  DATA 68,20
014D2:  DATA 45,72
014D4:  DATA 61,73
014D6:  DATA 65,20
014D8:  DATA 41,6C
014DA:  DATA 6C,0D
014DC:  DATA 0A,00
014DE:  DATA 45,6E
014E0:  DATA 64,20
014E2:  DATA 46,6C
014E4:  DATA 61,73
014E6:  DATA 68,20
014E8:  DATA 45,72
014EA:  DATA 61,73
014EC:  DATA 65,20
014EE:  DATA 41,6C
014F0:  DATA 6C,0D
014F2:  DATA 0A,00
014F4:  DATA 53,74
014F6:  DATA 61,72
014F8:  DATA 74,20
014FA:  DATA 46,6C
014FC:  DATA 61,73
014FE:  DATA 68,20
01500:  DATA 45,72
01502:  DATA 61,73
01504:  DATA 65,20
01506:  DATA 31,20
01508:  DATA 53,65
0150A:  DATA 63,74
0150C:  DATA 6F,72
0150E:  DATA 0D,0A
01510:  DATA 00,00
01512:  DATA 09,53
01514:  DATA 65,63
01516:  DATA 74,6F
01518:  DATA 72,20
0151A:  DATA 41,64
0151C:  DATA 64,72
0151E:  DATA 65,73
01520:  DATA 73,3A
01522:  DATA 20,30
01524:  DATA 78,25
01526:  DATA 30,38
01528:  DATA 4C,58
0152A:  DATA 0D,0A
0152C:  DATA 00,00
0152E:  DATA 45,6E
01530:  DATA 64,20
01532:  DATA 46,6C
01534:  DATA 61,73
01536:  DATA 68,20
01538:  DATA 45,72
0153A:  DATA 61,73
0153C:  DATA 65,20
0153E:  DATA 31,20
01540:  DATA 53,65
01542:  DATA 63,74
01544:  DATA 6F,72
01546:  DATA 0D,0A
01548:  DATA 00,00
0154A:  DATA 53,74
0154C:  DATA 61,72
0154E:  DATA 74,20
01550:  DATA 46,6C
01552:  DATA 61,73
01554:  DATA 68,20
01556:  DATA 43,6F
01558:  DATA 70,79
0155A:  DATA 20,31
0155C:  DATA 20,53
0155E:  DATA 65,63
01560:  DATA 74,6F
01562:  DATA 72,0D
01564:  DATA 0A,00
01566:  DATA 09,53
01568:  DATA 75,62
0156A:  DATA 73,65
0156C:  DATA 63,74
0156E:  DATA 6F,72
01570:  DATA 20,41
01572:  DATA 64,64
01574:  DATA 72,65
01576:  DATA 73,73
01578:  DATA 3A,20
0157A:  DATA 30,78
0157C:  DATA 25,30
0157E:  DATA 38,4C
01580:  DATA 58,0D
01582:  DATA 0A,00
01584:  DATA 45,6E
01586:  DATA 64,20
01588:  DATA 46,6C
0158A:  DATA 61,73
0158C:  DATA 68,20
0158E:  DATA 43,6F
01590:  DATA 70,79
01592:  DATA 20,31
01594:  DATA 20,53
01596:  DATA 65,63
01598:  DATA 74,6F
0159A:  DATA 72,0D
0159C:  DATA 0A,00
0159E:  DATA 53,74
015A0:  DATA 61,72
015A2:  DATA 74,20
015A4:  DATA 46,6C
015A6:  DATA 61,73
015A8:  DATA 68,20
015AA:  DATA 45,72
015AC:  DATA 61,73
015AE:  DATA 65,20
015B0:  DATA 36,34
015B2:  DATA 6B,42
015B4:  DATA 79,74
015B6:  DATA 65,20
015B8:  DATA 53,75
015BA:  DATA 62,73
015BC:  DATA 65,63
015BE:  DATA 74,6F
015C0:  DATA 72,0D
015C2:  DATA 0A,00
015C4:  DATA 09,53
015C6:  DATA 75,62
015C8:  DATA 73,65
015CA:  DATA 63,74
015CC:  DATA 6F,72
015CE:  DATA 20,41
015D0:  DATA 64,64
015D2:  DATA 72,65
015D4:  DATA 73,73
015D6:  DATA 3A,20
015D8:  DATA 30,78
015DA:  DATA 25,30
015DC:  DATA 38,4C
015DE:  DATA 58,0D
015E0:  DATA 0A,00
015E2:  DATA 45,6E
015E4:  DATA 64,20
015E6:  DATA 46,6C
015E8:  DATA 61,73
015EA:  DATA 68,20
015EC:  DATA 45,72
015EE:  DATA 61,73
015F0:  DATA 65,20
015F2:  DATA 36,34
015F4:  DATA 6B,42
015F6:  DATA 79,74
015F8:  DATA 65,20
015FA:  DATA 53,75
015FC:  DATA 62,73
015FE:  DATA 65,63
01600:  DATA 74,6F
01602:  DATA 72,0D
01604:  DATA 0A,00
01606:  DATA 53,74
01608:  DATA 61,72
0160A:  DATA 74,20
0160C:  DATA 46,6C
0160E:  DATA 61,73
01610:  DATA 68,20
01612:  DATA 57,72
01614:  DATA 69,74
01616:  DATA 65,20
01618:  DATA 44,65
0161A:  DATA 6D,6F
0161C:  DATA 0D,0A
0161E:  DATA 00,00
01620:  DATA 09,4D
01622:  DATA 4F,44
01624:  DATA 45,20
01626:  DATA 20,20
01628:  DATA 20,20
0162A:  DATA 3A,20
0162C:  DATA 25,30
0162E:  DATA 32,58
01630:  DATA 0D,0A
01632:  DATA 00,00
01634:  DATA 09,41
01636:  DATA 64,64
01638:  DATA 72,65
0163A:  DATA 73,73
0163C:  DATA 20,20
0163E:  DATA 3A,20
01640:  DATA 30,78
01642:  DATA 25,30
01644:  DATA 38,4C
01646:  DATA 58,0D
01648:  DATA 0A,00
0164A:  DATA 09,50
0164C:  DATA 61,63
0164E:  DATA 6B,65
01650:  DATA 74,4E
01652:  DATA 75,6D
01654:  DATA 3A,20
01656:  DATA 30,78
01658:  DATA 25,30
0165A:  DATA 34,4C
0165C:  DATA 58,0D
0165E:  DATA 0A,00
01660:  DATA 57,72
01662:  DATA 69,74
01664:  DATA 65,20
01666:  DATA 44,61
01668:  DATA 74,61
0166A:  DATA 0D,0A
0166C:  DATA 00,00
0166E:  DATA 45,6E
01670:  DATA 64,20
01672:  DATA 46,6C
01674:  DATA 61,73
01676:  DATA 68,20
01678:  DATA 57,72
0167A:  DATA 69,74
0167C:  DATA 65,20
0167E:  DATA 44,65
01680:  DATA 6D,6F
01682:  DATA 0D,0A
01684:  DATA 00,00
01686:  DATA 53,74
01688:  DATA 61,72
0168A:  DATA 74,20
0168C:  DATA 46,6C
0168E:  DATA 61,73
01690:  DATA 68,20
01692:  DATA 57,72
01694:  DATA 69,74
01696:  DATA 65,20
01698:  DATA 34,6B
0169A:  DATA 42,79
0169C:  DATA 74,65
0169E:  DATA 20,53
016A0:  DATA 75,62
016A2:  DATA 73,65
016A4:  DATA 63,74
016A6:  DATA 6F,72
016A8:  DATA 0D,0A
016AA:  DATA 00,00
016AC:  DATA 45,6E
016AE:  DATA 64,20
016B0:  DATA 46,6C
016B2:  DATA 61,73
016B4:  DATA 68,20
016B6:  DATA 57,72
016B8:  DATA 69,74
016BA:  DATA 65,20
016BC:  DATA 34,6B
016BE:  DATA 42,79
016C0:  DATA 74,65
016C2:  DATA 20,53
016C4:  DATA 75,62
016C6:  DATA 73,65
016C8:  DATA 63,74
016CA:  DATA 6F,72
016CC:  DATA 0D,0A
016CE:  DATA 00,00
016D0:  DATA 53,74
016D2:  DATA 61,72
016D4:  DATA 74,20
016D6:  DATA 46,6C
016D8:  DATA 61,73
016DA:  DATA 68,20
016DC:  DATA 52,65
016DE:  DATA 61,64
016E0:  DATA 0D,0A
016E2:  DATA 00,00
016E4:  DATA 09,4D
016E6:  DATA 4F,44
016E8:  DATA 45,20
016EA:  DATA 20,20
016EC:  DATA 20,20
016EE:  DATA 3A,20
016F0:  DATA 25,30
016F2:  DATA 32,58
016F4:  DATA 0D,0A
016F6:  DATA 00,00
016F8:  DATA 09,41
016FA:  DATA 64,64
016FC:  DATA 72,65
016FE:  DATA 73,73
01700:  DATA 20,20
01702:  DATA 3A,20
01704:  DATA 30,78
01706:  DATA 25,30
01708:  DATA 38,4C
0170A:  DATA 58,0D
0170C:  DATA 0A,00
0170E:  DATA 09,50
01710:  DATA 61,63
01712:  DATA 6B,65
01714:  DATA 74,4E
01716:  DATA 75,6D
01718:  DATA 3A,20
0171A:  DATA 30,78
0171C:  DATA 25,30
0171E:  DATA 34,4C
01720:  DATA 58,0D
01722:  DATA 0A,00
01724:  DATA 52,45
01726:  DATA 41,44
01728:  DATA 20,44
0172A:  DATA 41,54
0172C:  DATA 41,0D
0172E:  DATA 0A,00
01730:  DATA 4D,69
01732:  DATA 73,73
01734:  DATA 69,6F
01736:  DATA 6E,20
01738:  DATA 46,6C
0173A:  DATA 61,73
0173C:  DATA 68,20
0173E:  DATA 69,73
01740:  DATA 20,6E
01742:  DATA 6F,74
01744:  DATA 20,63
01746:  DATA 6F,6E
01748:  DATA 6E,65
0174A:  DATA 63,74
0174C:  DATA 65,64
0174E:  DATA 0D,0A
01750:  DATA 00,00
01752:  DATA 45,6E
01754:  DATA 64,20
01756:  DATA 46,6C
01758:  DATA 61,73
0175A:  DATA 68,20
0175C:  DATA 52,65
0175E:  DATA 61,64
01760:  DATA 0D,0A
01762:  DATA 00,00
01764:  DATA 53,74
01766:  DATA 61,72
01768:  DATA 74,20
0176A:  DATA 46,6C
0176C:  DATA 61,73
0176E:  DATA 68,20
01770:  DATA 52,65
01772:  DATA 61,64
01774:  DATA 20,41
01776:  DATA 64,64
01778:  DATA 72,65
0177A:  DATA 73,73
0177C:  DATA 0D,0A
0177E:  DATA 00,00
01780:  DATA 52,65
01782:  DATA 61,64
01784:  DATA 20,44
01786:  DATA 61,74
01788:  DATA 61,3A
0178A:  DATA 20,25
0178C:  DATA 30,32
0178E:  DATA 58,20
01790:  DATA 25,30
01792:  DATA 32,58
01794:  DATA 20,25
01796:  DATA 30,32
01798:  DATA 58,20
0179A:  DATA 25,30
0179C:  DATA 32,58
0179E:  DATA 0D,0A
017A0:  DATA 00,00
017A2:  DATA 45,6E
017A4:  DATA 64,20
017A6:  DATA 46,6C
017A8:  DATA 61,73
017AA:  DATA 68,20
017AC:  DATA 52,65
017AE:  DATA 61,64
017B0:  DATA 20,41
017B2:  DATA 64,64
017B4:  DATA 72,65
017B6:  DATA 73,73
017B8:  DATA 0D,0A
017BA:  DATA 00,00
017BC:  DATA 53,74
017BE:  DATA 61,72
017C0:  DATA 74,20
017C2:  DATA 46,6C
017C4:  DATA 61,73
017C6:  DATA 68,20
017C8:  DATA 45,72
017CA:  DATA 61,73
017CC:  DATA 65,20
017CE:  DATA 61,6E
017D0:  DATA 64,20
017D2:  DATA 52,65
017D4:  DATA 73,65
017D6:  DATA 74,0D
017D8:  DATA 0A,00
017DA:  DATA 45,6E
017DC:  DATA 64,20
017DE:  DATA 46,6C
017E0:  DATA 61,73
017E2:  DATA 68,20
017E4:  DATA 45,72
017E6:  DATA 61,73
017E8:  DATA 65,20
017EA:  DATA 61,6E
017EC:  DATA 64,20
017EE:  DATA 52,65
017F0:  DATA 73,65
017F2:  DATA 74,0D
017F4:  DATA 0A,00
017F6:  DATA 53,74
017F8:  DATA 61,72
017FA:  DATA 74,20
017FC:  DATA 46,6C
017FE:  DATA 61,73
01800:  DATA 68,20
01802:  DATA 41,64
01804:  DATA 64,72
01806:  DATA 65,73
01808:  DATA 73,20
0180A:  DATA 52,65
0180C:  DATA 73,65
0180E:  DATA 74,0D
01810:  DATA 0A,00
01812:  DATA 45,6E
01814:  DATA 64,20
01816:  DATA 46,6C
01818:  DATA 61,73
0181A:  DATA 68,20
0181C:  DATA 41,64
0181E:  DATA 64,72
01820:  DATA 65,73
01822:  DATA 73,20
01824:  DATA 52,65
01826:  DATA 73,65
01828:  DATA 74,0D
0182A:  DATA 0A,00
0182C:  DATA 53,74
0182E:  DATA 61,72
01830:  DATA 74,20
01832:  DATA 46,6C
01834:  DATA 61,73
01836:  DATA 68,20
01838:  DATA 53,4D
0183A:  DATA 46,20
0183C:  DATA 43,6F
0183E:  DATA 70,79
01840:  DATA 0D,0A
01842:  DATA 00,00
01844:  DATA 45,6E
01846:  DATA 64,20
01848:  DATA 46,6C
0184A:  DATA 61,73
0184C:  DATA 68,20
0184E:  DATA 53,4D
01850:  DATA 46,20
01852:  DATA 43,6F
01854:  DATA 70,79
01856:  DATA 0D,0A
01858:  DATA 00,00
0185A:  DATA 53,74
0185C:  DATA 61,72
0185E:  DATA 74,20
01860:  DATA 46,6C
01862:  DATA 61,73
01864:  DATA 68,20
01866:  DATA 53,4D
01868:  DATA 46,20
0186A:  DATA 52,65
0186C:  DATA 61,64
0186E:  DATA 0D,0A
01870:  DATA 00,00
01872:  DATA 52,65
01874:  DATA 61,64
01876:  DATA 20,44
01878:  DATA 61,74
0187A:  DATA 61,3A
0187C:  DATA 20,00
0187E:  DATA 0D,0A
01880:  DATA 45,6E
01882:  DATA 64,20
01884:  DATA 46,6C
01886:  DATA 61,73
01888:  DATA 68,20
0188A:  DATA 53,4D
0188C:  DATA 46,20
0188E:  DATA 52,65
01890:  DATA 61,64
01892:  DATA 0D,0A
01894:  DATA 00,00
01896:  DATA 53,74
01898:  DATA 61,72
0189A:  DATA 74,20
0189C:  DATA 46,6C
0189E:  DATA 61,73
018A0:  DATA 68,20
018A2:  DATA 53,4D
018A4:  DATA 46,20
018A6:  DATA 45,72
018A8:  DATA 61,73
018AA:  DATA 65,0D
018AC:  DATA 0A,00
018AE:  DATA 45,6E
018B0:  DATA 64,20
018B2:  DATA 46,6C
018B4:  DATA 61,73
018B6:  DATA 68,20
018B8:  DATA 53,4D
018BA:  DATA 46,20
018BC:  DATA 45,72
018BE:  DATA 61,73
018C0:  DATA 65,0D
018C2:  DATA 0A,00
018C4:  DATA 53,74
018C6:  DATA 61,72
018C8:  DATA 74,20
018CA:  DATA 46,6C
018CC:  DATA 61,73
018CE:  DATA 68,20
018D0:  DATA 41,64
018D2:  DATA 64,72
018D4:  DATA 65,73
018D6:  DATA 73,20
018D8:  DATA 52,65
018DA:  DATA 73,65
018DC:  DATA 74,0D
018DE:  DATA 0A,00
018E0:  DATA 45,6E
018E2:  DATA 64,20
018E4:  DATA 46,6C
018E6:  DATA 61,73
018E8:  DATA 68,20
018EA:  DATA 41,64
018EC:  DATA 64,72
018EE:  DATA 65,73
018F0:  DATA 73,20
018F2:  DATA 52,65
018F4:  DATA 73,65
018F6:  DATA 74,0D
018F8:  DATA 0A,00
018FA:  DATA 53,4D
018FC:  DATA 46,20
018FE:  DATA 69,73
01900:  DATA 20,6E
01902:  DATA 6F,74
01904:  DATA 20,63
01906:  DATA 6F,6E
01908:  DATA 6E,65
0190A:  DATA 63,74
0190C:  DATA 65,64
0190E:  DATA 0D,0A
01910:  DATA 00,00
01912:  DATA 53,74
01914:  DATA 61,72
01916:  DATA 74,20
01918:  DATA 46,6C
0191A:  DATA 61,73
0191C:  DATA 68,20
0191E:  DATA 53,4D
01920:  DATA 46,20
01922:  DATA 52,65
01924:  DATA 61,64
01926:  DATA 20,46
01928:  DATA 6F,72
0192A:  DATA 63,65
0192C:  DATA 0D,0A
0192E:  DATA 00,00
01930:  DATA 09,41
01932:  DATA 64,64
01934:  DATA 72,65
01936:  DATA 73,73
01938:  DATA 20,20
0193A:  DATA 3A,20
0193C:  DATA 30,78
0193E:  DATA 25,30
01940:  DATA 38,4C
01942:  DATA 58,0D
01944:  DATA 0A,00
01946:  DATA 09,50
01948:  DATA 61,63
0194A:  DATA 6B,65
0194C:  DATA 74,4E
0194E:  DATA 75,6D
01950:  DATA 3A,20
01952:  DATA 30,78
01954:  DATA 25,30
01956:  DATA 34,4C
01958:  DATA 58,0D
0195A:  DATA 0A,00
0195C:  DATA 72,65
0195E:  DATA 61,64
01960:  DATA 20,64
01962:  DATA 61,74
01964:  DATA 61,0D
01966:  DATA 0A,00
01968:  DATA 0D,0A
0196A:  DATA 45,6E
0196C:  DATA 64,20
0196E:  DATA 46,6C
01970:  DATA 61,73
01972:  DATA 68,20
01974:  DATA 53,4D
01976:  DATA 46,20
01978:  DATA 52,65
0197A:  DATA 61,64
0197C:  DATA 20,46
0197E:  DATA 6F,72
01980:  DATA 63,65
01982:  DATA 0D,0A
01984:  DATA 00,00
01986:  DATA 53,74
01988:  DATA 61,72
0198A:  DATA 74,20
0198C:  DATA 53,4D
0198E:  DATA 46,20
01990:  DATA 45,72
01992:  DATA 61,73
01994:  DATA 65,20
01996:  DATA 41,6C
01998:  DATA 6C,0D
0199A:  DATA 0A,00
0199C:  DATA 45,6E
0199E:  DATA 64,20
019A0:  DATA 53,4D
019A2:  DATA 46,20
019A4:  DATA 45,72
019A6:  DATA 61,73
019A8:  DATA 65,20
019AA:  DATA 41,6C
019AC:  DATA 6C,0D
019AE:  DATA 0A,00
019B0:  DATA 53,74
019B2:  DATA 61,72
019B4:  DATA 74,20
019B6:  DATA 53,4D
019B8:  DATA 46,20
019BA:  DATA 52,65
019BC:  DATA 73,65
019BE:  DATA 74,0D
019C0:  DATA 0A,00
019C2:  DATA 45,6E
019C4:  DATA 64,20
019C6:  DATA 53,4D
019C8:  DATA 46,20
019CA:  DATA 52,65
019CC:  DATA 73,65
019CE:  DATA 74,0D
019D0:  DATA 0A,00
019D2:  DATA 0D,0A
019D4:  DATA 0D,0A
019D6:  DATA 0D,0A
019D8:  DATA 3D,3D
019DA:  DATA 3D,3D
019DC:  DATA 3D,3D
019DE:  DATA 3D,3D
019E0:  DATA 3D,3D
019E2:  DATA 3D,3D
019E4:  DATA 3D,3D
019E6:  DATA 3D,3D
019E8:  DATA 3D,3D
019EA:  DATA 3D,3D
019EC:  DATA 3D,3D
019EE:  DATA 3D,3D
019F0:  DATA 3D,3D
019F2:  DATA 3D,3D
019F4:  DATA 3D,3D
019F6:  DATA 3D,3D
019F8:  DATA 3D,3D
019FA:  DATA 3D,3D
019FC:  DATA 3D,3D
019FE:  DATA 3D,3D
01A00:  DATA 3D,3D
01A02:  DATA 3D,3D
01A04:  DATA 3D,3D
01A06:  DATA 3D,3D
01A08:  DATA 3D,3D
01A0A:  DATA 3D,3D
01A0C:  DATA 3D,3D
01A0E:  DATA 3D,3D
01A10:  DATA 3D,3D
01A12:  DATA 3D,3D
01A14:  DATA 0D,0A
01A16:  DATA 00,00
01A18:  DATA 54,68
01A1A:  DATA 69,73
01A1C:  DATA 20,69
01A1E:  DATA 73,20
01A20:  DATA 4D,4F
01A22:  DATA 4D,49
01A24:  DATA 4A,49
01A26:  DATA 20,43
01A28:  DATA 49,47
01A2A:  DATA 53,20
01A2C:  DATA 50,49
01A2E:  DATA 43,20
01A30:  DATA 42,42
01A32:  DATA 4D,20
01A34:  DATA 66,6F
01A36:  DATA 72,20
01A38:  DATA 4D,49
01A3A:  DATA 53,37
01A3C:  DATA 5F,42
01A3E:  DATA 42,4D
01A40:  DATA 34,2E
01A42:  DATA 0D,0A
01A44:  DATA 00,00
01A46:  DATA 4C,61
01A48:  DATA 73,74
01A4A:  DATA 20,75
01A4C:  DATA 70,64
01A4E:  DATA 61,74
01A50:  DATA 65,64
01A52:  DATA 20,6F
01A54:  DATA 6E,20
01A56:  DATA 25,73
01A58:  DATA 20,25
01A5A:  DATA 73,2C
01A5C:  DATA 20,62
01A5E:  DATA 79,20
01A60:  DATA 49,6E
01A62:  DATA 6F,75
01A64:  DATA 65,2E
01A66:  DATA 0D,0A
01A68:  DATA 0D,0A
01A6A:  DATA 00,00
01A6C:  DATA 39,2D
01A6E:  DATA 41,75
01A70:  DATA 67,2D
01A72:  DATA 32,35
01A74:  DATA 00,00
01A76:  DATA 30,31
01A78:  DATA 3A,34
01A7A:  DATA 32,3A
01A7C:  DATA 34,33
01A7E:  DATA 00,00
01A80:  DATA 5F,5F
01A82:  DATA 5F,5F
01A84:  DATA 43,49
01A86:  DATA 47,53
01A88:  DATA 20,50
01A8A:  DATA 49,43
01A8C:  DATA 20,53
01A8E:  DATA 74,61
01A90:  DATA 72,74
01A92:  DATA 20,4F
01A94:  DATA 70,65
01A96:  DATA 72,61
01A98:  DATA 74,69
01A9A:  DATA 6F,6E
01A9C:  DATA 5F,5F
01A9E:  DATA 5F,5F
01AA0:  DATA 5F,0D
01AA2:  DATA 0A,0D
01AA4:  DATA 0A,00
01AA6:  DATA 77,61
01AA8:  DATA 69,74
01AAA:  DATA 69,6E
01AAC:  DATA 67,20
01AAE:  DATA 66,6F
01AB0:  DATA 72,20
01AB2:  DATA 42,4F
01AB4:  DATA 53,53
01AB6:  DATA 20,50
01AB8:  DATA 49,43
01ABA:  DATA 20,63
01ABC:  DATA 6F,6D
01ABE:  DATA 6D,61
01AC0:  DATA 6E,64
01AC2:  DATA 00,00
01AC4:  DATA 0D,0A
01AC6:  DATA 77,61
01AC8:  DATA 69,74
01ACA:  DATA 69,6E
01ACC:  DATA 67,20
01ACE:  DATA 66,6F
01AD0:  DATA 72,20
01AD2:  DATA 42,4F
01AD4:  DATA 53,53
01AD6:  DATA 20,50
01AD8:  DATA 49,43
01ADA:  DATA 20,63
01ADC:  DATA 6F,6D
01ADE:  DATA 6D,61
01AE0:  DATA 6E,64
01AE2:  DATA 00,00
01AE4:  DATA 0D,0A
01AE6:  DATA 0D,0A
01AE8:  DATA 3D,3D
01AEA:  DATA 3D,3D
01AEC:  DATA 3D,3D
01AEE:  DATA 0D,0A
01AF0:  DATA 0D,0A
01AF2:  DATA 46,69
01AF4:  DATA 6E,69
01AF6:  DATA 73,68
01AF8:  DATA 65,64
01AFA:  DATA 20,70
01AFC:  DATA 72,6F
01AFE:  DATA 63,65
01B00:  DATA 73,73
01B02:  DATA 2E,0D
01B04:  DATA 0A,57
01B06:  DATA 61,69
01B08:  DATA 74,20
01B0A:  DATA 66,6F
01B0C:  DATA 72,20
01B0E:  DATA 42,4F
01B10:  DATA 53,53
01B12:  DATA 20,50
01B14:  DATA 49,43
01B16:  DATA 20,74
01B18:  DATA 75,72
01B1A:  DATA 6E,20
01B1C:  DATA 6F,66
01B1E:  DATA 66,20
01B20:  DATA 6D,65
01B22:  DATA 00,00
01B24:  DATA 45,6E
01B26:  DATA 64,20
01B28:  DATA 6D,61
01B2A:  DATA 69,6E
01B2C:  DATA 0D,0A
01B2E:  DATA 00,00
*
01BB0:  TBLRD*+
01BB2:  MOVF   FF5,F
01BB4:  BTFSC  FD8.2
01BB6:  GOTO   1BDE
01BBA:  MOVFF  FF6,B6B
01BBE:  MOVFF  FF7,B6C
01BC2:  MOVFF  FF8,B6D
01BC6:  MOVFF  FF5,B6E
01BCA:  CALL   1B5E
01BCE:  MOVFF  B6B,FF6
01BD2:  MOVFF  B6C,FF7
01BD6:  MOVFF  B6D,FF8
01BDA:  GOTO   1BB0
01BDE:  RETURN 0
01BE0:  TBLRD*+
01BE2:  MOVFF  FF6,B1C
01BE6:  MOVFF  FF7,B1D
01BEA:  MOVFF  FF8,B1E
01BEE:  MOVFF  FF5,B6E
01BF2:  CALL   1B5E
01BF6:  MOVFF  B1C,FF6
01BFA:  MOVFF  B1D,FF7
01BFE:  MOVFF  B1E,FF8
01C02:  MOVLB  B
01C04:  DECFSZ x1B,F
01C06:  BRA    1C0C
01C08:  BRA    1C12
01C0A:  MOVLB  0
01C0C:  MOVLB  0
01C0E:  GOTO   1BE0
01C12:  MOVLB  0
01C14:  RETURN 0
*
01E34:  MOVLB  B
01E36:  BTFSS  x1C.7
01E38:  BRA    1E40
01E3A:  MOVLB  0
01E3C:  GOTO   1E70
01E40:  MOVLW  0F
01E42:  MOVWF  00
01E44:  SWAPF  x1B,W
01E46:  ANDWF  00,F
01E48:  MOVLW  0A
01E4A:  SUBWF  00,W
01E4C:  BTFSS  FD8.0
01E4E:  BRA    1E56
01E50:  MOVLB  0
01E52:  GOTO   1E60
01E56:  MOVLW  30
01E58:  ADDWF  00,F
01E5A:  MOVLB  0
01E5C:  GOTO   1E68
01E60:  MOVLB  B
01E62:  MOVF   x1C,W
01E64:  ADDWF  00,F
01E66:  MOVLB  0
01E68:  MOVFF  00,B6E
01E6C:  CALL   1B5E
01E70:  MOVLW  0F
01E72:  MOVLB  B
01E74:  ANDWF  x1B,F
01E76:  MOVLW  0A
01E78:  SUBWF  x1B,W
01E7A:  BTFSS  FD8.0
01E7C:  BRA    1E84
01E7E:  MOVLB  0
01E80:  GOTO   1E8C
01E84:  MOVLW  30
01E86:  MOVLB  0
01E88:  GOTO   1E94
01E8C:  MOVLB  B
01E8E:  BCF    x1C.7
01E90:  MOVF   x1C,W
01E92:  MOVLB  0
01E94:  MOVLB  B
01E96:  ADDWF  x1B,F
01E98:  MOVFF  B1B,B6E
01E9C:  MOVLB  0
01E9E:  CALL   1B5E
01EA2:  RETURN 0
*
0234A:  MOVLB  B
0234C:  MOVF   xC9,W
0234E:  ANDLW  07
02350:  MOVWF  00
02352:  RRCF   xC9,W
02354:  MOVWF  01
02356:  RRCF   01,F
02358:  RRCF   01,F
0235A:  MOVLW  1F
0235C:  ANDWF  01,F
0235E:  MOVF   01,W
02360:  ADDWF  xCB,W
02362:  MOVWF  FE9
02364:  MOVLW  00
02366:  ADDWFC xCC,W
02368:  MOVWF  FEA
0236A:  CLRF   01
0236C:  INCF   01,F
0236E:  INCF   00,F
02370:  MOVLB  0
02372:  GOTO   2378
02376:  RLCF   01,F
02378:  DECFSZ 00,F
0237A:  GOTO   2376
0237E:  MOVLB  B
02380:  MOVF   xCA,F
02382:  BTFSS  FD8.2
02384:  BRA    238C
02386:  MOVLB  0
02388:  GOTO   2396
0238C:  MOVF   01,W
0238E:  IORWF  FEF,F
02390:  MOVLB  0
02392:  GOTO   239C
02396:  COMF   01,F
02398:  MOVF   01,W
0239A:  ANDWF  FEF,F
0239C:  RETURN 0
*
03A02:  TSTFSZ 01
03A04:  GOTO   3A12
03A08:  TSTFSZ 02
03A0A:  GOTO   3A14
03A0E:  GOTO   3A24
03A12:  INCF   02,F
03A14:  MOVFF  00,FEE
03A18:  DECFSZ 01,F
03A1A:  GOTO   3A14
03A1E:  DECFSZ 02,F
03A20:  GOTO   3A14
03A24:  RETURN 0
*
06750:  MOVLB  4
06752:  MOVF   x3D,W
06754:  CLRF   01
06756:  SUBWF  x3C,W
06758:  BTFSS  FD8.0
0675A:  BRA    6762
0675C:  MOVLB  0
0675E:  GOTO   676C
06762:  MOVF   x3C,W
06764:  MOVWF  00
06766:  MOVLB  0
06768:  GOTO   6796
0676C:  CLRF   00
0676E:  MOVLW  08
06770:  MOVLB  4
06772:  MOVWF  x3E
06774:  MOVLB  0
06776:  MOVLB  4
06778:  RLCF   x3C,F
0677A:  RLCF   00,F
0677C:  MOVF   x3D,W
0677E:  SUBWF  00,W
06780:  BTFSC  FD8.0
06782:  MOVWF  00
06784:  RLCF   01,F
06786:  DECFSZ x3E,F
06788:  BRA    678E
0678A:  BRA    6794
0678C:  MOVLB  0
0678E:  MOVLB  0
06790:  GOTO   6776
06794:  MOVLB  0
06796:  RETURN 0
06798:  MOVF   01,W
0679A:  MOVFF  3B7,43C
0679E:  MOVLW  64
067A0:  MOVLB  4
067A2:  MOVWF  x3D
067A4:  MOVLB  0
067A6:  CALL   6750
067AA:  MOVFF  00,3B7
067AE:  MOVF   01,W
067B0:  MOVLW  30
067B2:  BTFSS  FD8.2
067B4:  GOTO   67D8
067B8:  MOVLB  3
067BA:  BTFSC  xB8.1
067BC:  BRA    67C4
067BE:  MOVLB  0
067C0:  GOTO   67EC
067C4:  BTFSS  xB8.3
067C6:  BRA    67CE
067C8:  MOVLB  0
067CA:  GOTO   67EC
067CE:  BTFSC  xB8.4
067D0:  MOVLW  20
067D2:  MOVLB  0
067D4:  GOTO   67E2
067D8:  MOVLB  3
067DA:  BCF    xB8.3
067DC:  BCF    xB8.4
067DE:  BSF    xB8.0
067E0:  MOVLB  0
067E2:  ADDWF  01,F
067E4:  MOVFF  01,B6E
067E8:  CALL   1B5E
067EC:  MOVFF  3B7,43C
067F0:  MOVLW  0A
067F2:  MOVLB  4
067F4:  MOVWF  x3D
067F6:  MOVLB  0
067F8:  CALL   6750
067FC:  MOVFF  00,3B7
06800:  MOVF   01,W
06802:  MOVLW  30
06804:  BTFSS  FD8.2
06806:  GOTO   6826
0680A:  MOVLB  3
0680C:  BTFSS  xB8.3
0680E:  BRA    6816
06810:  MOVLB  0
06812:  GOTO   6830
06816:  BTFSC  xB8.0
06818:  BRA    6820
0681A:  MOVLB  0
0681C:  GOTO   6830
06820:  BTFSC  xB8.4
06822:  MOVLW  20
06824:  MOVLB  0
06826:  ADDWF  01,F
06828:  MOVFF  01,B6E
0682C:  CALL   1B5E
06830:  MOVLW  30
06832:  MOVLB  3
06834:  ADDWF  xB7,F
06836:  MOVFF  3B7,B6E
0683A:  MOVLB  0
0683C:  CALL   1B5E
06840:  RETURN 0
06842:  BTFSC  FD8.1
06844:  GOTO   6850
06848:  MOVLW  0B
0684A:  MOVWF  FEA
0684C:  MOVLW  32
0684E:  MOVWF  FE9
06850:  CLRF   00
06852:  CLRF   01
06854:  CLRF   02
06856:  CLRF   03
06858:  MOVLB  B
0685A:  CLRF   x32
0685C:  CLRF   x33
0685E:  CLRF   x34
06860:  CLRF   x35
06862:  MOVF   x31,W
06864:  IORWF  x30,W
06866:  IORWF  x2F,W
06868:  IORWF  x2E,W
0686A:  BTFSS  FD8.2
0686C:  BRA    6874
0686E:  MOVLB  0
06870:  GOTO   6904
06874:  MOVLB  0
06876:  MOVLW  20
06878:  MOVLB  B
0687A:  MOVWF  x36
0687C:  MOVLB  0
0687E:  BCF    FD8.0
06880:  MOVLB  B
06882:  RLCF   x2A,F
06884:  RLCF   x2B,F
06886:  RLCF   x2C,F
06888:  RLCF   x2D,F
0688A:  RLCF   x32,F
0688C:  RLCF   x33,F
0688E:  RLCF   x34,F
06890:  RLCF   x35,F
06892:  MOVF   x31,W
06894:  SUBWF  x35,W
06896:  BTFSC  FD8.2
06898:  BRA    68A0
0689A:  MOVLB  0
0689C:  GOTO   68C2
068A0:  MOVF   x30,W
068A2:  SUBWF  x34,W
068A4:  BTFSC  FD8.2
068A6:  BRA    68AE
068A8:  MOVLB  0
068AA:  GOTO   68C2
068AE:  MOVF   x2F,W
068B0:  SUBWF  x33,W
068B2:  BTFSC  FD8.2
068B4:  BRA    68BC
068B6:  MOVLB  0
068B8:  GOTO   68C2
068BC:  MOVF   x2E,W
068BE:  SUBWF  x32,W
068C0:  MOVLB  0
068C2:  BTFSS  FD8.0
068C4:  GOTO   68EA
068C8:  MOVLB  B
068CA:  MOVF   x2E,W
068CC:  SUBWF  x32,F
068CE:  MOVF   x2F,W
068D0:  BTFSS  FD8.0
068D2:  INCFSZ x2F,W
068D4:  SUBWF  x33,F
068D6:  MOVF   x30,W
068D8:  BTFSS  FD8.0
068DA:  INCFSZ x30,W
068DC:  SUBWF  x34,F
068DE:  MOVF   x31,W
068E0:  BTFSS  FD8.0
068E2:  INCFSZ x31,W
068E4:  SUBWF  x35,F
068E6:  BSF    FD8.0
068E8:  MOVLB  0
068EA:  RLCF   00,F
068EC:  RLCF   01,F
068EE:  RLCF   02,F
068F0:  RLCF   03,F
068F2:  MOVLB  B
068F4:  DECFSZ x36,F
068F6:  BRA    68FC
068F8:  BRA    6902
068FA:  MOVLB  0
068FC:  MOVLB  0
068FE:  GOTO   687E
06902:  MOVLB  0
06904:  MOVFF  B32,FEF
06908:  MOVFF  B33,FEC
0690C:  MOVFF  B34,FEC
06910:  MOVFF  B35,FEC
06914:  MOVF   FED,F
06916:  MOVF   FED,F
06918:  MOVF   FED,F
0691A:  RETURN 0
*
069D6:  MOVFF  FEA,B1F
069DA:  MOVFF  FE9,B1E
069DE:  MOVLB  B
069E0:  BTFSC  x18.7
069E2:  BRA    69EA
069E4:  MOVLB  0
069E6:  GOTO   69FC
069EA:  BSF    x1E.7
069EC:  BTFSS  x1E.4
069EE:  INCF   x1E,F
069F0:  COMF   x17,F
069F2:  COMF   x18,F
069F4:  INCF   x17,F
069F6:  BTFSC  FD8.2
069F8:  INCF   x18,F
069FA:  MOVLB  0
069FC:  MOVLB  B
069FE:  SWAPF  x18,W
06A00:  IORLW  F0
06A02:  MOVWF  x1A
06A04:  ADDWF  x1A,F
06A06:  ADDLW  E2
06A08:  MOVWF  x1B
06A0A:  ADDLW  32
06A0C:  MOVWF  x1D
06A0E:  MOVF   x18,W
06A10:  ANDLW  0F
06A12:  ADDWF  x1B,F
06A14:  ADDWF  x1B,F
06A16:  ADDWF  x1D,F
06A18:  ADDLW  E9
06A1A:  MOVWF  x1C
06A1C:  ADDWF  x1C,F
06A1E:  ADDWF  x1C,F
06A20:  SWAPF  x17,W
06A22:  ANDLW  0F
06A24:  ADDWF  x1C,F
06A26:  ADDWF  x1D,F
06A28:  RLCF   x1C,F
06A2A:  RLCF   x1D,F
06A2C:  COMF   x1D,F
06A2E:  RLCF   x1D,F
06A30:  MOVF   x17,W
06A32:  ANDLW  0F
06A34:  ADDWF  x1D,F
06A36:  RLCF   x1A,F
06A38:  MOVLW  07
06A3A:  MOVWF  x19
06A3C:  MOVLW  0A
06A3E:  MOVLB  0
06A40:  MOVLB  B
06A42:  DECF   x1C,F
06A44:  ADDWF  x1D,F
06A46:  BTFSC  FD8.0
06A48:  BRA    6A50
06A4A:  MOVLB  0
06A4C:  GOTO   6A40
06A50:  MOVLB  0
06A52:  MOVLB  B
06A54:  DECF   x1B,F
06A56:  ADDWF  x1C,F
06A58:  BTFSC  FD8.0
06A5A:  BRA    6A62
06A5C:  MOVLB  0
06A5E:  GOTO   6A52
06A62:  MOVLB  0
06A64:  MOVLB  B
06A66:  DECF   x1A,F
06A68:  ADDWF  x1B,F
06A6A:  BTFSC  FD8.0
06A6C:  BRA    6A74
06A6E:  MOVLB  0
06A70:  GOTO   6A64
06A74:  MOVLB  0
06A76:  MOVLB  B
06A78:  DECF   x19,F
06A7A:  ADDWF  x1A,F
06A7C:  BTFSC  FD8.0
06A7E:  BRA    6A86
06A80:  MOVLB  0
06A82:  GOTO   6A76
06A86:  MOVLW  0B
06A88:  MOVWF  FEA
06A8A:  MOVLW  19
06A8C:  MOVWF  FE9
06A8E:  MOVLW  07
06A90:  ANDWF  x1E,W
06A92:  BCF    x1E.6
06A94:  MOVF   FED,F
06A96:  ANDWF  x1E,W
06A98:  BTFSC  FD8.2
06A9A:  BRA    6AA2
06A9C:  MOVLB  0
06A9E:  GOTO   6ABA
06AA2:  BTFSC  x1E.4
06AA4:  MOVF   FEE,F
06AA6:  BTFSS  x1E.4
06AA8:  BRA    6AB0
06AAA:  MOVLB  0
06AAC:  GOTO   6ABA
06AB0:  MOVLW  20
06AB2:  MOVWF  00
06AB4:  MOVLB  0
06AB6:  GOTO   6B34
06ABA:  ADDWF  FE9,F
06ABC:  MOVLW  00
06ABE:  ADDWFC FEA,F
06AC0:  MOVF   FE9,W
06AC2:  SUBLW  1D
06AC4:  BTFSS  FD8.2
06AC6:  GOTO   6ADA
06ACA:  MOVF   FEA,W
06ACC:  SUBLW  0B
06ACE:  BTFSS  FD8.2
06AD0:  GOTO   6ADA
06AD4:  MOVLB  B
06AD6:  BSF    x1E.6
06AD8:  MOVLB  0
06ADA:  MOVF   FEF,W
06ADC:  MOVWF  00
06ADE:  BTFSS  FD8.2
06AE0:  GOTO   6B0C
06AE4:  MOVLB  B
06AE6:  BTFSS  x1E.6
06AE8:  BRA    6AF0
06AEA:  MOVLB  0
06AEC:  GOTO   6B0C
06AF0:  BTFSS  x1E.4
06AF2:  BRA    6AFA
06AF4:  MOVLB  0
06AF6:  GOTO   6B4C
06AFA:  BTFSS  x1E.3
06AFC:  BRA    6B04
06AFE:  MOVLB  0
06B00:  GOTO   6B0C
06B04:  MOVLW  20
06B06:  MOVLB  0
06B08:  GOTO   6B32
06B0C:  MOVLB  B
06B0E:  BTFSC  x1E.7
06B10:  BRA    6B18
06B12:  MOVLB  0
06B14:  GOTO   6B28
06B18:  MOVLW  2D
06B1A:  MOVWF  00
06B1C:  MOVF   FED,W
06B1E:  BCF    x1E.6
06B20:  BCF    x1E.7
06B22:  MOVLB  0
06B24:  GOTO   6B34
06B28:  MOVLB  B
06B2A:  BSF    x1E.3
06B2C:  BCF    x1E.4
06B2E:  MOVLW  30
06B30:  MOVLB  0
06B32:  ADDWF  00,F
06B34:  MOVFF  FEA,B18
06B38:  MOVFF  FE9,B17
06B3C:  MOVFF  00,B6E
06B40:  CALL   1B5E
06B44:  MOVFF  B18,FEA
06B48:  MOVFF  B17,FE9
06B4C:  MOVF   FEE,W
06B4E:  MOVLB  B
06B50:  BTFSC  x1E.6
06B52:  BRA    6B5A
06B54:  MOVLB  0
06B56:  GOTO   6AC0
06B5A:  MOVLB  0
06B5C:  GOTO   8480 (RETURN)
*
0907E:  MOVLW  20
09080:  MOVLB  4
09082:  BTFSS  x37.4
09084:  MOVLW  30
09086:  MOVWF  x38
09088:  MOVFF  436,00
0908C:  BTFSC  00.7
0908E:  BRA    9096
09090:  MOVLB  0
09092:  GOTO   90A8
09096:  COMF   00,F
09098:  INCF   00,F
0909A:  MOVFF  00,436
0909E:  MOVLW  2D
090A0:  MOVWF  x38
090A2:  BSF    x37.7
090A4:  BSF    x37.0
090A6:  MOVLB  0
090A8:  MOVF   01,W
090AA:  MOVFF  436,43C
090AE:  MOVLW  64
090B0:  MOVLB  4
090B2:  MOVWF  x3D
090B4:  MOVLB  0
090B6:  CALL   6750
090BA:  MOVFF  00,436
090BE:  MOVLW  30
090C0:  ADDWF  01,W
090C2:  MOVLB  4
090C4:  MOVWF  x39
090C6:  MOVFF  436,43C
090CA:  MOVLW  0A
090CC:  MOVWF  x3D
090CE:  MOVLB  0
090D0:  CALL   6750
090D4:  MOVLW  30
090D6:  ADDWF  00,W
090D8:  MOVLB  4
090DA:  MOVWF  x3B
090DC:  MOVLW  30
090DE:  ADDWF  01,W
090E0:  MOVWF  x3A
090E2:  MOVFF  438,00
090E6:  MOVLB  0
090E8:  MOVLW  30
090EA:  MOVLB  4
090EC:  SUBWF  x39,W
090EE:  BTFSS  FD8.2
090F0:  BRA    90F8
090F2:  MOVLB  0
090F4:  GOTO   9104
090F8:  BSF    x37.1
090FA:  BTFSC  x37.7
090FC:  BSF    x37.2
090FE:  MOVLB  0
09100:  GOTO   9144
09104:  MOVFF  438,439
09108:  MOVLW  20
0910A:  MOVLB  4
0910C:  MOVWF  x38
0910E:  MOVLW  30
09110:  SUBWF  x3A,W
09112:  BTFSS  FD8.2
09114:  BRA    911C
09116:  MOVLB  0
09118:  GOTO   9128
0911C:  BSF    x37.0
0911E:  BTFSC  x37.7
09120:  BSF    x37.1
09122:  MOVLB  0
09124:  GOTO   9144
09128:  BTFSC  FD8.2
0912A:  BRA    9132
0912C:  MOVLB  4
0912E:  BSF    x37.0
09130:  MOVLB  0
09132:  BTFSS  FD8.2
09134:  GOTO   9144
09138:  MOVFF  439,43A
0913C:  MOVLW  20
0913E:  MOVLB  4
09140:  MOVWF  x39
09142:  MOVLB  0
09144:  MOVLB  4
09146:  BTFSS  x37.2
09148:  BRA    9150
0914A:  MOVLB  0
0914C:  GOTO   916A
09150:  BTFSS  x37.1
09152:  BRA    915A
09154:  MOVLB  0
09156:  GOTO   9172
0915A:  BTFSS  x37.0
0915C:  BRA    9164
0915E:  MOVLB  0
09160:  GOTO   917A
09164:  MOVLB  0
09166:  GOTO   9182
0916A:  MOVFF  438,B6E
0916E:  CALL   1B5E
09172:  MOVFF  439,B6E
09176:  CALL   1B5E
0917A:  MOVFF  43A,B6E
0917E:  CALL   1B5E
09182:  MOVFF  43B,B6E
09186:  CALL   1B5E
0918A:  RETURN 0
*
09586:  MOVF   FE9,W
09588:  MOVLB  3
0958A:  MOVWF  xB7
0958C:  BTFSC  xB6.7
0958E:  BRA    9596
09590:  MOVLB  0
09592:  GOTO   95B2
09596:  DECF   xB7,F
09598:  BSF    xB7.5
0959A:  COMF   xB3,F
0959C:  COMF   xB4,F
0959E:  COMF   xB5,F
095A0:  COMF   xB6,F
095A2:  INCF   xB3,F
095A4:  BTFSC  FD8.2
095A6:  INCF   xB4,F
095A8:  BTFSC  FD8.2
095AA:  INCF   xB5,F
095AC:  BTFSC  FD8.2
095AE:  INCF   xB6,F
095B0:  MOVLB  0
095B2:  MOVLW  3B
095B4:  MOVLB  3
095B6:  MOVWF  xBE
095B8:  MOVLW  9A
095BA:  MOVWF  xBD
095BC:  MOVLW  CA
095BE:  MOVWF  xBC
095C0:  CLRF   xBB
095C2:  MOVLW  0A
095C4:  MOVWF  xB9
095C6:  MOVLB  0
095C8:  BSF    FD8.1
095CA:  MOVLW  03
095CC:  MOVWF  FEA
095CE:  MOVLW  B3
095D0:  MOVWF  FE9
095D2:  MOVFF  3B6,B2D
095D6:  MOVFF  3B5,B2C
095DA:  MOVFF  3B4,B2B
095DE:  MOVFF  3B3,B2A
095E2:  MOVFF  3BE,B31
095E6:  MOVFF  3BD,B30
095EA:  MOVFF  3BC,B2F
095EE:  MOVFF  3BB,B2E
095F2:  CALL   6842
095F6:  MOVF   01,W
095F8:  MOVF   00,F
095FA:  BTFSS  FD8.2
095FC:  GOTO   9654
09600:  MOVLB  3
09602:  MOVF   xB9,W
09604:  XORLW  01
09606:  BTFSS  FD8.2
09608:  BRA    9610
0960A:  MOVLB  0
0960C:  GOTO   9654
09610:  MOVF   xB7,W
09612:  BTFSS  FD8.2
09614:  BRA    961C
09616:  MOVLB  0
09618:  GOTO   965C
0961C:  ANDLW  0F
0961E:  SUBWF  xB9,W
09620:  BTFSS  FD8.2
09622:  BRA    962A
09624:  MOVLB  0
09626:  GOTO   9636
0962A:  BTFSS  FD8.0
0962C:  BRA    9634
0962E:  MOVLB  0
09630:  GOTO   96BA
09634:  MOVLB  0
09636:  MOVLB  3
09638:  BTFSS  xB7.7
0963A:  BRA    9642
0963C:  MOVLB  0
0963E:  GOTO   96BA
09642:  BTFSS  xB7.6
09644:  BRA    964C
09646:  MOVLB  0
09648:  GOTO   965C
0964C:  MOVLW  20
0964E:  MOVLB  0
09650:  GOTO   96B0
09654:  MOVLW  20
09656:  MOVLB  3
09658:  ANDWF  xB7,F
0965A:  MOVLB  0
0965C:  MOVLB  3
0965E:  BTFSC  xB7.5
09660:  BRA    9668
09662:  MOVLB  0
09664:  GOTO   9684
09668:  BCF    xB7.5
0966A:  MOVF   00,W
0966C:  MOVWF  xB7
0966E:  MOVLW  2D
09670:  MOVLB  B
09672:  MOVWF  x6E
09674:  MOVLB  0
09676:  CALL   1B5E
0967A:  MOVLB  3
0967C:  MOVF   xB7,W
0967E:  MOVWF  00
09680:  CLRF   xB7
09682:  MOVLB  0
09684:  MOVLW  30
09686:  MOVLB  3
09688:  BTFSC  xB7.5
0968A:  BRA    9692
0968C:  MOVLB  0
0968E:  GOTO   96B0
09692:  BCF    xB7.5
09694:  MOVF   00,W
09696:  MOVWF  xB7
09698:  MOVLW  2D
0969A:  MOVLB  B
0969C:  MOVWF  x6E
0969E:  MOVLB  0
096A0:  CALL   1B5E
096A4:  MOVLB  3
096A6:  MOVF   xB7,W
096A8:  MOVWF  00
096AA:  CLRF   xB7
096AC:  MOVLW  30
096AE:  MOVLB  0
096B0:  ADDWF  00,F
096B2:  MOVFF  00,B6E
096B6:  CALL   1B5E
096BA:  BCF    FD8.1
096BC:  MOVFF  3BE,B2D
096C0:  MOVFF  3BD,B2C
096C4:  MOVFF  3BC,B2B
096C8:  MOVFF  3BB,B2A
096CC:  MOVLB  B
096CE:  CLRF   x31
096D0:  CLRF   x30
096D2:  CLRF   x2F
096D4:  MOVLW  0A
096D6:  MOVWF  x2E
096D8:  MOVLB  0
096DA:  CALL   6842
096DE:  MOVFF  03,3BE
096E2:  MOVFF  02,3BD
096E6:  MOVFF  01,3BC
096EA:  MOVFF  00,3BB
096EE:  MOVLB  3
096F0:  DECFSZ xB9,F
096F2:  BRA    96F8
096F4:  BRA    96FE
096F6:  MOVLB  0
096F8:  MOVLB  0
096FA:  GOTO   95C8
096FE:  MOVLB  0
09700:  RETURN 0
*
0A1A8:  MOVF   FE9,W
0A1AA:  MOVLB  3
0A1AC:  MOVWF  x3C
0A1AE:  MOVLW  3B
0A1B0:  MOVWF  x43
0A1B2:  MOVLW  9A
0A1B4:  MOVWF  x42
0A1B6:  MOVLW  CA
0A1B8:  MOVWF  x41
0A1BA:  CLRF   x40
0A1BC:  MOVLW  0A
0A1BE:  MOVWF  x3E
0A1C0:  MOVLB  0
0A1C2:  BSF    FD8.1
0A1C4:  MOVLW  03
0A1C6:  MOVWF  FEA
0A1C8:  MOVLW  38
0A1CA:  MOVWF  FE9
0A1CC:  MOVFF  33B,B2D
0A1D0:  MOVFF  33A,B2C
0A1D4:  MOVFF  339,B2B
0A1D8:  MOVFF  338,B2A
0A1DC:  MOVFF  343,B31
0A1E0:  MOVFF  342,B30
0A1E4:  MOVFF  341,B2F
0A1E8:  MOVFF  340,B2E
0A1EC:  CALL   6842
0A1F0:  MOVF   01,W
0A1F2:  MOVF   00,F
0A1F4:  BTFSS  FD8.2
0A1F6:  GOTO   A24E
0A1FA:  MOVLB  3
0A1FC:  MOVF   x3E,W
0A1FE:  XORLW  01
0A200:  BTFSS  FD8.2
0A202:  BRA    A20A
0A204:  MOVLB  0
0A206:  GOTO   A24E
0A20A:  MOVF   x3C,W
0A20C:  BTFSS  FD8.2
0A20E:  BRA    A216
0A210:  MOVLB  0
0A212:  GOTO   A254
0A216:  ANDLW  0F
0A218:  SUBWF  x3E,W
0A21A:  BTFSS  FD8.2
0A21C:  BRA    A224
0A21E:  MOVLB  0
0A220:  GOTO   A230
0A224:  BTFSS  FD8.0
0A226:  BRA    A22E
0A228:  MOVLB  0
0A22A:  GOTO   A260
0A22E:  MOVLB  0
0A230:  MOVLB  3
0A232:  BTFSS  x3C.7
0A234:  BRA    A23C
0A236:  MOVLB  0
0A238:  GOTO   A260
0A23C:  BTFSS  x3C.6
0A23E:  BRA    A246
0A240:  MOVLB  0
0A242:  GOTO   A254
0A246:  MOVLW  20
0A248:  MOVLB  0
0A24A:  GOTO   A256
0A24E:  MOVLB  3
0A250:  CLRF   x3C
0A252:  MOVLB  0
0A254:  MOVLW  30
0A256:  ADDWF  00,F
0A258:  MOVFF  00,B6E
0A25C:  CALL   1B5E
0A260:  BCF    FD8.1
0A262:  MOVFF  343,B2D
0A266:  MOVFF  342,B2C
0A26A:  MOVFF  341,B2B
0A26E:  MOVFF  340,B2A
0A272:  MOVLB  B
0A274:  CLRF   x31
0A276:  CLRF   x30
0A278:  CLRF   x2F
0A27A:  MOVLW  0A
0A27C:  MOVWF  x2E
0A27E:  MOVLB  0
0A280:  CALL   6842
0A284:  MOVFF  03,343
0A288:  MOVFF  02,342
0A28C:  MOVFF  01,341
0A290:  MOVFF  00,340
0A294:  MOVLB  3
0A296:  DECFSZ x3E,F
0A298:  BRA    A29E
0A29A:  BRA    A2A4
0A29C:  MOVLB  0
0A29E:  MOVLB  0
0A2A0:  GOTO   A1C2
0A2A4:  MOVLB  0
0A2A6:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01B30:  MOVLW  0B
01B32:  MOVWF  FEA
01B34:  MOVLW  C3
01B36:  MOVWF  FE9
01B38:  MOVF   FEF,W
01B3A:  BTFSC  FD8.2
01B3C:  GOTO   1B5C
01B40:  MOVLW  05
01B42:  MOVWF  01
01B44:  CLRF   00
01B46:  DECFSZ 00,F
01B48:  BRA    1B46
01B4A:  DECFSZ 01,F
01B4C:  BRA    1B44
01B4E:  MOVLW  2E
01B50:  MOVWF  00
01B52:  DECFSZ 00,F
01B54:  BRA    1B52
01B56:  BRA    1B58
01B58:  DECFSZ FEF,F
01B5A:  BRA    1B40
01B5C:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
043F8:  BTFSS  FA6.4
043FA:  GOTO   43F8
043FE:  MOVLB  F
04400:  MOVWF  x29
04402:  MOVLB  0
04404:  GOTO   443A (RETURN)
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01B5E:  BCF    F93.6
01B60:  BCF    F8A.6
01B62:  MOVLW  08
01B64:  MOVWF  01
01B66:  BRA    1B68
01B68:  NOP   
01B6A:  BSF    01.7
01B6C:  GOTO   1B94
01B70:  BCF    01.7
01B72:  MOVLB  B
01B74:  RRCF   x6E,F
01B76:  MOVLB  0
01B78:  BTFSC  FD8.0
01B7A:  BSF    F8A.6
01B7C:  BTFSS  FD8.0
01B7E:  BCF    F8A.6
01B80:  BSF    01.6
01B82:  GOTO   1B94
01B86:  BCF    01.6
01B88:  DECFSZ 01,F
01B8A:  GOTO   1B72
01B8E:  BRA    1B90
01B90:  NOP   
01B92:  BSF    F8A.6
01B94:  MOVLW  84
01B96:  MOVWF  FE9
01B98:  DECFSZ FE9,F
01B9A:  GOTO   1B98
01B9E:  BRA    1BA0
01BA0:  NOP   
01BA2:  BTFSC  01.7
01BA4:  GOTO   1B70
01BA8:  BTFSC  01.6
01BAA:  GOTO   1B86
01BAE:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
0241A:  MOVLB  B
0241C:  MOVF   xE6,W
0241E:  SUBLW  08
02420:  BTFSS  FD8.2
02422:  BRA    242A
02424:  MOVLB  0
02426:  GOTO   2442
0242A:  MOVWF  xE8
0242C:  MOVLB  0
0242E:  MOVLB  B
02430:  RLCF   xE5,F
02432:  DECFSZ xE8,F
02434:  BRA    243A
02436:  BRA    2440
02438:  MOVLB  0
0243A:  MOVLB  0
0243C:  GOTO   242E
02440:  MOVLB  0
02442:  BSF    F92.1
02444:  BCF    F92.0
02446:  BCF    F92.3
02448:  BCF    F89.3
0244A:  MOVFF  BE6,BE8
0244E:  MOVLB  B
02450:  BTFSS  xE5.7
02452:  BCF    F89.0
02454:  BTFSC  xE5.7
02456:  BSF    F89.0
02458:  RLCF   xE5,F
0245A:  BSF    F89.3
0245C:  MOVLW  02
0245E:  MOVWF  xE9
02460:  MOVLB  0
02462:  MOVLB  B
02464:  DECFSZ xE9,F
02466:  BRA    246C
02468:  BRA    2472
0246A:  MOVLB  0
0246C:  MOVLB  0
0246E:  GOTO   2462
02472:  RLCF   01,F
02474:  BTFSS  F80.1
02476:  BCF    01.0
02478:  BTFSC  F80.1
0247A:  BSF    01.0
0247C:  BCF    F89.3
0247E:  MOVLB  0
02480:  BRA    2482
02482:  MOVLB  B
02484:  DECFSZ xE8,F
02486:  BRA    248C
02488:  BRA    2492
0248A:  MOVLB  0
0248C:  MOVLB  0
0248E:  GOTO   244E
02492:  MOVLB  0
02494:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
0239E:  MOVLB  B
023A0:  MOVF   xE6,W
023A2:  SUBLW  08
023A4:  BTFSS  FD8.2
023A6:  BRA    23AE
023A8:  MOVLB  0
023AA:  GOTO   23C6
023AE:  MOVWF  xE8
023B0:  MOVLB  0
023B2:  MOVLB  B
023B4:  RLCF   xE5,F
023B6:  DECFSZ xE8,F
023B8:  BRA    23BE
023BA:  BRA    23C4
023BC:  MOVLB  0
023BE:  MOVLB  0
023C0:  GOTO   23B2
023C4:  MOVLB  0
023C6:  BSF    F96.0
023C8:  BCF    F96.6
023CA:  BCF    F96.1
023CC:  BCF    F8D.1
023CE:  MOVFF  BE6,BE8
023D2:  MOVLB  B
023D4:  BTFSS  xE5.7
023D6:  BCF    F8D.6
023D8:  BTFSC  xE5.7
023DA:  BSF    F8D.6
023DC:  RLCF   xE5,F
023DE:  BSF    F8D.1
023E0:  MOVLW  02
023E2:  MOVWF  xE9
023E4:  MOVLB  0
023E6:  MOVLB  B
023E8:  DECFSZ xE9,F
023EA:  BRA    23F0
023EC:  BRA    23F6
023EE:  MOVLB  0
023F0:  MOVLB  0
023F2:  GOTO   23E6
023F6:  RLCF   01,F
023F8:  BTFSS  F84.0
023FA:  BCF    01.0
023FC:  BTFSC  F84.0
023FE:  BSF    01.0
02400:  BCF    F8D.1
02402:  MOVLB  0
02404:  BRA    2406
02406:  MOVLB  B
02408:  DECFSZ xE8,F
0240A:  BRA    2410
0240C:  BRA    2416
0240E:  MOVLB  0
02410:  MOVLB  0
02412:  GOTO   23D2
02416:  MOVLB  0
02418:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01D3A:  MOVLB  B
01D3C:  MOVF   x33,W
01D3E:  SUBLW  10
01D40:  BTFSS  FD8.2
01D42:  BRA    1D4A
01D44:  MOVLB  0
01D46:  GOTO   1D64
01D4A:  MOVWF  x35
01D4C:  MOVLB  0
01D4E:  MOVLB  B
01D50:  RLCF   x31,F
01D52:  RLCF   x32,F
01D54:  DECFSZ x35,F
01D56:  BRA    1D5C
01D58:  BRA    1D62
01D5A:  MOVLB  0
01D5C:  MOVLB  0
01D5E:  GOTO   1D4E
01D62:  MOVLB  0
01D64:  BSF    F93.4
01D66:  BCF    F93.5
01D68:  BCF    F93.2
01D6A:  BSF    F8A.2
01D6C:  MOVFF  B33,B35
01D70:  MOVLB  B
01D72:  BTFSS  x32.7
01D74:  BCF    F8A.5
01D76:  BTFSC  x32.7
01D78:  BSF    F8A.5
01D7A:  RLCF   x31,F
01D7C:  RLCF   x32,F
01D7E:  BCF    F8A.2
01D80:  RLCF   01,F
01D82:  RLCF   02,F
01D84:  BTFSS  F81.4
01D86:  BCF    01.0
01D88:  BTFSC  F81.4
01D8A:  BSF    01.0
01D8C:  BSF    F8A.2
01D8E:  DECFSZ x35,F
01D90:  BRA    1D96
01D92:  BRA    1D9C
01D94:  MOVLB  0
01D96:  MOVLB  0
01D98:  GOTO   1D70
01D9C:  MOVLB  0
01D9E:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/mcu/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/devices/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... #include "../../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_MEASURE_DATA_START_ADDRESS 0x06AA1000
.................... #define CIGS_MEASURE_DATA_END_ADDRESS 0x07AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x07AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x07AA1FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "../core/measurement/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/storage/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../../system/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "../application/mission/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... #include "../hardware/mcu/src/timer.c"
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
*
000CA:  MOVLW  80
000CC:  MOVWF  FCF
000CE:  MOVLW  12
000D0:  MOVWF  FCE
000D2:  NOP   
....................    sec++;
000D4:  MOVLW  01
000D6:  ADDWF  20,F
000D8:  BTFSC  FD8.0
000DA:  INCF   21,F
000DC:  BTFSC  FD8.2
000DE:  INCF   22,F
000E0:  BTFSC  FD8.2
000E2:  INCF   23,F
....................    /*
....................    if (++subsec >= 100)
....................    {
....................       subsec = 0;
....................       sec++;
.................... 
....................       if (sec >= SEC_IN_A_DAY)
....................       {
....................          day++;
....................       }
....................    }*/
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01C8E:  MOVLW  EA
01C90:  MOVWF  FF6
01C92:  MOVLW  00
01C94:  MOVWF  FF7
01C96:  MOVLW  00
01C98:  MOVWF  FF8
01C9A:  CALL   1BB0
....................    clear_interrupt(INT_TIMER1);
01C9E:  BCF    F9E.0
....................    //sec = 0;
....................    // 外部クロックをT1CKIピンから入力、プリスケーラなし
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01CA0:  MOVLW  8F
01CA2:  MOVWF  FCD
01CA4:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01CA6:  MOVLW  80
01CA8:  MOVWF  FCF
01CAA:  MOVLW  12
01CAC:  MOVWF  FCE
01CAE:  NOP   
....................    //set_timer1(0);  // タイマーカウント初期値設定
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);   
01CB0:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01CB2:  MOVLW  C0
01CB4:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CB6:  MOVLW  FE
01CB8:  MOVWF  FF6
01CBA:  MOVLW  00
01CBC:  MOVWF  FF7
01CBE:  MOVLW  00
01CC0:  MOVWF  FF8
01CC2:  CALL   1BB0
01CC6:  GOTO   B454 (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
03360:  MOVFF  20,00
03364:  MOVFF  21,01
03368:  MOVFF  22,02
0336C:  MOVFF  23,03
03370:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
*
0691C:  BCF    FD8.1
0691E:  MOVFF  1F,B2D
06922:  MOVFF  1E,B2C
06926:  MOVFF  1D,B2B
0692A:  MOVFF  1C,B2A
0692E:  MOVLB  B
06930:  CLRF   x31
06932:  CLRF   x30
06934:  CLRF   x2F
06936:  MOVLW  0A
06938:  MOVWF  x2E
0693A:  MOVLB  0
0693C:  CALL   6842
06940:  MOVF   01,W
06942:  MOVWF  02
06944:  MOVF   00,W
06946:  MOVWF  01
06948:  GOTO   6964 (RETURN)
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... 
.................... 
.................... 
.................... #include "../hardware/mcu/src/uart.c"
.................... #INT_RDA3
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  47.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   46,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   46,W
0014C:  INCF   46,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  26
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,C13
00160:  MOVFF  FE9,C12
00164:  GOTO   010A
00168:  MOVFF  C13,FEA
0016C:  MOVFF  C12,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
.................... 
....................    //fprintf(PC, "RDA Interrupt: %d bytes received\r\n", boss_receive_buffer_size);
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01C64:  MOVLW  7A
01C66:  MOVWF  FF6
01C68:  MOVLW  01
01C6A:  MOVWF  FF7
01C6C:  MOVLW  00
01C6E:  MOVWF  FF8
01C70:  CALL   1BB0
....................    enable_interrupts(INT_RDA3);
01C74:  BSF    F61.5
....................    enable_interrupts(global);
01C76:  MOVLW  C0
01C78:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01C7A:  MOVLW  8C
01C7C:  MOVWF  FF6
01C7E:  MOVLW  01
01C80:  MOVWF  FF7
01C82:  MOVLW  00
01C84:  MOVWF  FF8
01C86:  CALL   1BB0
01C8A:  GOTO   B450 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
043BA:  MOVFF  2D9,03
043BE:  MOVLB  2
043C0:  MOVF   xD8,W
043C2:  MOVWF  FE9
043C4:  MOVFF  03,FEA
043C8:  MOVFF  FEF,2DA
043CC:  MOVFF  2D7,FEA
043D0:  MOVFF  2D6,FE9
043D4:  CLRF   00
043D6:  CLRF   02
043D8:  MOVFF  2DA,01
043DC:  MOVLB  0
043DE:  CALL   3A02
....................    *receive_signal_size = 0;
043E2:  MOVFF  2D9,03
043E6:  MOVLB  2
043E8:  MOVF   xD8,W
043EA:  MOVWF  FE9
043EC:  MOVFF  03,FEA
043F0:  CLRF   FEF
043F2:  MOVLB  0
043F4:  GOTO   B4F6 (RETURN)
.................... }
.................... 
.................... 
.................... #include "../hardware/devices/src/ad7490_driver.c"
.................... #include "../ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01EA4:  MOVLW  98
01EA6:  MOVWF  FF6
01EA8:  MOVLW  01
01EAA:  MOVWF  FF7
01EAC:  MOVLW  00
01EAE:  MOVWF  FF8
01EB0:  CALL   1BB0
....................     output_high(ADC_CS); // Set CS pin high to deselect the ADC
01EB4:  MOVLW  F4
01EB6:  MOVWF  F93
01EB8:  BSF    F8A.1
....................     delay_ms(10); // Wait for the ADC to stabilize
01EBA:  MOVLW  0A
01EBC:  MOVLB  B
01EBE:  MOVWF  xC3
01EC0:  MOVLB  0
01EC2:  CALL   1B30
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR); // Read a dummy value to initialize the ADC
01EC6:  MOVLW  05
01EC8:  MOVLB  B
01ECA:  MOVWF  x2A
01ECC:  MOVLB  0
01ECE:  CALL   1DA0
01ED2:  MOVFF  02,2D7
01ED6:  MOVFF  01,2D6
....................     delay_ms(1); // Wait for the ADC to stabilize after reading
01EDA:  MOVLW  01
01EDC:  MOVLB  B
01EDE:  MOVWF  xC3
01EE0:  MOVLB  0
01EE2:  CALL   1B30
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01EE6:  MOVLW  09
01EE8:  MOVLB  B
01EEA:  MOVWF  x6E
01EEC:  MOVLB  0
01EEE:  CALL   1B5E
01EF2:  MOVFF  2D7,B1B
01EF6:  MOVLW  37
01EF8:  MOVLB  B
01EFA:  MOVWF  x1C
01EFC:  MOVLB  0
01EFE:  CALL   1E34
01F02:  MOVFF  2D6,B1B
01F06:  MOVLW  37
01F08:  MOVLB  B
01F0A:  MOVWF  x1C
01F0C:  MOVLB  0
01F0E:  CALL   1E34
01F12:  MOVLW  0D
01F14:  MOVLB  B
01F16:  MOVWF  x6E
01F18:  MOVLB  0
01F1A:  CALL   1B5E
01F1E:  MOVLW  0A
01F20:  MOVLB  B
01F22:  MOVWF  x6E
01F24:  MOVLB  0
01F26:  CALL   1B5E
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F2A:  MOVLB  2
01F2C:  INCFSZ xD6,W
01F2E:  BRA    1F34
01F30:  BRA    1F3A
01F32:  MOVLB  0
01F34:  MOVLB  0
01F36:  GOTO   1F52
01F3A:  MOVLB  0
01F3C:  MOVLB  2
01F3E:  INCFSZ xD7,W
01F40:  BRA    1F46
01F42:  BRA    1F4C
01F44:  MOVLB  0
01F46:  MOVLB  0
01F48:  GOTO   1F52
01F4C:  MOVLB  0
01F4E:  GOTO   1F72
01F52:  MOVLB  2
01F54:  MOVF   xD6,F
01F56:  BTFSC  FD8.2
01F58:  BRA    1F60
01F5A:  MOVLB  0
01F5C:  GOTO   1F86
01F60:  MOVLB  0
01F62:  MOVLB  2
01F64:  MOVF   xD7,F
01F66:  BTFSC  FD8.2
01F68:  BRA    1F70
01F6A:  MOVLB  0
01F6C:  GOTO   1F86
01F70:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01F72:  MOVLW  AC
01F74:  MOVWF  FF6
01F76:  MOVLW  01
01F78:  MOVWF  FF7
01F7A:  MOVLW  00
01F7C:  MOVWF  FF8
01F7E:  CALL   1BB0
....................     } else {
01F82:  GOTO   1F96
....................         fprintf(PC, "\tConnect successful\r\n");
01F86:  MOVLW  BE
01F88:  MOVWF  FF6
01F8A:  MOVLW  01
01F8C:  MOVWF  FF7
01F8E:  MOVLW  00
01F90:  MOVWF  FF8
01F92:  CALL   1BB0
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01F96:  MOVLW  D4
01F98:  MOVWF  FF6
01F9A:  MOVLW  01
01F9C:  MOVWF  FF7
01F9E:  MOVLW  00
01FA0:  MOVWF  FF8
01FA2:  CALL   1BB0
01FA6:  GOTO   B458 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01DA0:  MOVFF  B2A,B31
01DA4:  GOTO   1CCA
01DA8:  MOVFF  02,B2C
01DAC:  MOVFF  01,B2B
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     // Send the command to the ADC
....................     output_low(ADC_CS); // Set CS pin low to select the ADC
01DB0:  MOVLW  F4
01DB2:  MOVWF  F93
01DB4:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01DB6:  MOVLW  0D
01DB8:  MOVWF  00
01DBA:  DECFSZ 00,F
01DBC:  BRA    1DBA
....................     spi_xfer(ADC_STREAM, cmd); // Dummy transfer to start communication
01DBE:  MOVFF  B2C,B32
01DC2:  MOVFF  B2B,B31
01DC6:  MOVLW  10
01DC8:  MOVLB  B
01DCA:  MOVWF  x33
01DCC:  MOVLW  01
01DCE:  MOVWF  x34
01DD0:  MOVLB  0
01DD2:  CALL   1D3A
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     delay_us(10); // Wait for the ADC to process the command
01DD6:  MOVLW  0D
01DD8:  MOVWF  00
01DDA:  DECFSZ 00,F
01DDC:  BRA    1DDA
....................     output_high(ADC_CS); // Set CS pin high to end communication
01DDE:  MOVLW  F4
01DE0:  MOVWF  F93
01DE2:  BSF    F8A.1
....................     delay_us(10); // Wait for the ADC to process the command
01DE4:  MOVLW  0D
01DE6:  MOVWF  00
01DE8:  DECFSZ 00,F
01DEA:  BRA    1DE8
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01DEC:  MOVLW  F4
01DEE:  MOVWF  F93
01DF0:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01DF2:  MOVLW  0D
01DF4:  MOVWF  00
01DF6:  DECFSZ 00,F
01DF8:  BRA    1DF6
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000); // Read data from ADC
01DFA:  MOVLB  B
01DFC:  CLRF   x32
01DFE:  CLRF   x31
01E00:  MOVLW  10
01E02:  MOVWF  x33
01E04:  MOVLW  01
01E06:  MOVWF  x34
01E08:  MOVLB  0
01E0A:  CALL   1D3A
01E0E:  MOVFF  02,B2E
01E12:  MOVFF  01,B2D
....................     output_high(ADC_CS); 
01E16:  MOVLW  F4
01E18:  MOVWF  F93
01E1A:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E1C:  MOVLB  B
01E1E:  MOVF   x2D,W
01E20:  MOVWF  x2F
01E22:  MOVF   x2E,W
01E24:  ANDLW  0F
01E26:  MOVWF  x30
....................     
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E28:  MOVF   x2F,W
01E2A:  MOVWF  01
01E2C:  MOVF   x30,W
01E2E:  MOVWF  02
01E30:  MOVLB  0
01E32:  RETURN 0
.................... }
.................... 
.................... #include "../hardware/devices/src/mcp4901_driver.c"
.................... #include "../mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
02182:  MOVLW  E0
02184:  MOVWF  FF6
02186:  MOVLW  01
02188:  MOVWF  FF7
0218A:  MOVLW  00
0218C:  MOVWF  FF8
0218E:  CALL   1BB0
....................     output_high(DAC1_CS); 
02192:  MOVLW  F4
02194:  MOVWF  F93
02196:  BSF    F8A.3
....................     output_high(DAC2_CS); 
02198:  MOVLW  F4
0219A:  MOVWF  F93
0219C:  BSF    F8A.0
....................     delay_ms(10); 
0219E:  MOVLW  0A
021A0:  MOVLB  B
021A2:  MOVWF  xC3
021A4:  MOVLB  0
021A6:  CALL   1B30
....................     mcp4901_1_write(10); 
021AA:  MOVLB  B
021AC:  CLRF   x18
021AE:  MOVLW  0A
021B0:  MOVWF  x17
021B2:  MOVLB  0
021B4:  CALL   20FE
....................     mcp4901_2_write(10); 
021B8:  MOVLB  B
021BA:  CLRF   x18
021BC:  MOVLW  0A
021BE:  MOVWF  x17
021C0:  MOVLB  0
021C2:  CALL   2140
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
021C6:  MOVLW  08
021C8:  MOVLB  B
021CA:  MOVWF  x2A
021CC:  MOVLB  0
021CE:  CALL   1DA0
021D2:  MOVFF  02,2D7
021D6:  MOVFF  01,2D6
....................     fprintf(PC, "%04LX\r\n", readdata);
021DA:  MOVFF  2D7,B1B
021DE:  MOVLW  37
021E0:  MOVLB  B
021E2:  MOVWF  x1C
021E4:  MOVLB  0
021E6:  CALL   1E34
021EA:  MOVFF  2D6,B1B
021EE:  MOVLW  37
021F0:  MOVLB  B
021F2:  MOVWF  x1C
021F4:  MOVLB  0
021F6:  CALL   1E34
021FA:  MOVLW  0D
021FC:  MOVLB  B
021FE:  MOVWF  x6E
02200:  MOVLB  0
02202:  CALL   1B5E
02206:  MOVLW  0A
02208:  MOVLB  B
0220A:  MOVWF  x6E
0220C:  MOVLB  0
0220E:  CALL   1B5E
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
02212:  MOVLB  2
02214:  INCFSZ xD6,W
02216:  BRA    221C
02218:  BRA    2222
0221A:  MOVLB  0
0221C:  MOVLB  0
0221E:  GOTO   223A
02222:  MOVLB  0
02224:  MOVLB  2
02226:  INCFSZ xD7,W
02228:  BRA    222E
0222A:  BRA    2234
0222C:  MOVLB  0
0222E:  MOVLB  0
02230:  GOTO   223A
02234:  MOVLB  0
02236:  GOTO   225A
0223A:  MOVLB  2
0223C:  MOVF   xD6,F
0223E:  BTFSC  FD8.2
02240:  BRA    2248
02242:  MOVLB  0
02244:  GOTO   226E
02248:  MOVLB  0
0224A:  MOVLB  2
0224C:  MOVF   xD7,F
0224E:  BTFSC  FD8.2
02250:  BRA    2258
02252:  MOVLB  0
02254:  GOTO   226E
02258:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
0225A:  MOVLW  F6
0225C:  MOVWF  FF6
0225E:  MOVLW  01
02260:  MOVWF  FF7
02262:  MOVLW  00
02264:  MOVWF  FF8
02266:  CALL   1BB0
....................     } else {
0226A:  GOTO   227E
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
0226E:  MOVLW  16
02270:  MOVWF  FF6
02272:  MOVLW  02
02274:  MOVWF  FF7
02276:  MOVLW  00
02278:  MOVWF  FF8
0227A:  CALL   1BB0
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
0227E:  MOVFF  2D7,B1B
02282:  MOVLW  37
02284:  MOVLB  B
02286:  MOVWF  x1C
02288:  MOVLB  0
0228A:  CALL   1E34
0228E:  MOVFF  2D6,B1B
02292:  MOVLW  37
02294:  MOVLB  B
02296:  MOVWF  x1C
02298:  MOVLB  0
0229A:  CALL   1E34
0229E:  MOVLW  0D
022A0:  MOVLB  B
022A2:  MOVWF  x6E
022A4:  MOVLB  0
022A6:  CALL   1B5E
022AA:  MOVLW  0A
022AC:  MOVLB  B
022AE:  MOVWF  x6E
022B0:  MOVLB  0
022B2:  CALL   1B5E
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
022B6:  MOVLW  09
022B8:  MOVLB  B
022BA:  MOVWF  x2A
022BC:  MOVLB  0
022BE:  CALL   1DA0
022C2:  MOVFF  02,2D7
022C6:  MOVFF  01,2D6
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
022CA:  MOVLB  2
022CC:  INCFSZ xD6,W
022CE:  BRA    22D4
022D0:  BRA    22DA
022D2:  MOVLB  0
022D4:  MOVLB  0
022D6:  GOTO   22F2
022DA:  MOVLB  0
022DC:  MOVLB  2
022DE:  INCFSZ xD7,W
022E0:  BRA    22E6
022E2:  BRA    22EC
022E4:  MOVLB  0
022E6:  MOVLB  0
022E8:  GOTO   22F2
022EC:  MOVLB  0
022EE:  GOTO   2312
022F2:  MOVLB  2
022F4:  MOVF   xD6,F
022F6:  BTFSC  FD8.2
022F8:  BRA    2300
022FA:  MOVLB  0
022FC:  GOTO   2326
02300:  MOVLB  0
02302:  MOVLB  2
02304:  MOVF   xD7,F
02306:  BTFSC  FD8.2
02308:  BRA    2310
0230A:  MOVLB  0
0230C:  GOTO   2326
02310:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
02312:  MOVLW  3A
02314:  MOVWF  FF6
02316:  MOVLW  02
02318:  MOVWF  FF7
0231A:  MOVLW  00
0231C:  MOVWF  FF8
0231E:  CALL   1BB0
....................     } else {
02322:  GOTO   2336
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02326:  MOVLW  5A
02328:  MOVWF  FF6
0232A:  MOVLW  02
0232C:  MOVWF  FF7
0232E:  MOVLW  00
02330:  MOVWF  FF8
02332:  CALL   1BB0
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02336:  MOVLW  7E
02338:  MOVWF  FF6
0233A:  MOVLW  02
0233C:  MOVWF  FF7
0233E:  MOVLW  00
02340:  MOVWF  FF8
02342:  CALL   1BB0
02346:  GOTO   B45C (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
020FE:  MOVFF  B18,B1C
02102:  MOVFF  B17,B1B
02106:  CALL   1FAA
0210A:  MOVFF  02,B1A
0210E:  MOVFF  01,B19
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
02112:  MOVLW  F4
02114:  MOVWF  F93
02116:  BCF    F8A.3
....................    delay_us(10); 
02118:  MOVLW  0D
0211A:  MOVWF  00
0211C:  DECFSZ 00,F
0211E:  BRA    211C
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02120:  MOVFF  B1A,B32
02124:  MOVFF  B19,B31
02128:  MOVLW  10
0212A:  MOVLB  B
0212C:  MOVWF  x33
0212E:  MOVLW  01
02130:  MOVWF  x34
02132:  MOVLB  0
02134:  CALL   1D3A
....................    output_high(DAC1_CS); 
02138:  MOVLW  F4
0213A:  MOVWF  F93
0213C:  BSF    F8A.3
0213E:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
02140:  MOVFF  B18,B1C
02144:  MOVFF  B17,B1B
02148:  CALL   1FAA
0214C:  MOVFF  02,B1A
02150:  MOVFF  01,B19
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
02154:  MOVLW  F4
02156:  MOVWF  F93
02158:  BCF    F8A.0
....................    delay_us(10); 
0215A:  MOVLW  0D
0215C:  MOVWF  00
0215E:  DECFSZ 00,F
02160:  BRA    215E
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02162:  MOVFF  B1A,B32
02166:  MOVFF  B19,B31
0216A:  MOVLW  10
0216C:  MOVLB  B
0216E:  MOVWF  x33
02170:  MOVLW  01
02172:  MOVWF  x34
02174:  MOVLB  0
02176:  CALL   1D3A
....................    output_high(DAC2_CS); 
0217A:  MOVLW  F4
0217C:  MOVWF  F93
0217E:  BSF    F8A.0
02180:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01CCA:  MOVLB  B
01CCC:  BCF    x32.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01CCE:  BCF    x32.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01CD0:  BCF    x32.2
....................     cmd.fields.reserved3 = 0;
01CD2:  BCF    x32.3
....................     cmd.fields.coding = 1; // Two's complement
01CD4:  BSF    x32.4
....................     cmd.fields.range = 1; // Normal mode
01CD6:  BSF    x32.5
....................     cmd.fields.weak_tri = 0; // Strong trigger
01CD8:  BCF    x32.6
....................     cmd.fields.shadow = 0; // Direct access
01CDA:  BCF    x32.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01CDC:  BSF    x33.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01CDE:  BSF    x33.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01CE0:  MOVF   x31,W
01CE2:  ANDLW  01
01CE4:  MOVWF  01
01CE6:  BCF    x33.2
01CE8:  BTFSC  01.0
01CEA:  BSF    x33.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01CEC:  BCF    FD8.0
01CEE:  RRCF   x31,W
01CF0:  ANDLW  01
01CF2:  MOVWF  01
01CF4:  BCF    x33.3
01CF6:  BTFSC  01.0
01CF8:  BSF    x33.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01CFA:  RRCF   x31,W
01CFC:  MOVWF  00
01CFE:  RRCF   00,F
01D00:  MOVLW  3F
01D02:  ANDWF  00,F
01D04:  MOVF   00,W
01D06:  ANDLW  01
01D08:  MOVWF  01
01D0A:  BCF    x33.4
01D0C:  BTFSC  01.0
01D0E:  BSF    x33.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D10:  RRCF   x31,W
01D12:  MOVWF  00
01D14:  RRCF   00,F
01D16:  RRCF   00,F
01D18:  MOVLW  1F
01D1A:  ANDWF  00,F
01D1C:  MOVF   00,W
01D1E:  ANDLW  01
01D20:  MOVWF  01
01D22:  BCF    x33.5
01D24:  BTFSC  01.0
01D26:  BSF    x33.5
....................     cmd.fields.seq = 0; // Random mode
01D28:  BCF    x33.6
....................     cmd.fields.write = 1; // Read operation
01D2A:  BSF    x33.7
.................... 
.................... 
....................     return cmd.value;
01D2C:  MOVF   x32,W
01D2E:  MOVWF  01
01D30:  MOVF   x33,W
01D32:  MOVWF  02
01D34:  MOVLB  0
01D36:  GOTO   1DA8 (RETURN)
.................... }
.................... 
.................... #include "../../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
01FAA:  MOVLB  B
01FAC:  BCF    x1E.7
....................    cmd.fields.buffer = 1; // Buffer used
01FAE:  BSF    x1E.6
....................    cmd.fields.gain = 1; // Gain 1x
01FB0:  BSF    x1E.5
....................    cmd.fields.shutdown = 1; // Normal operation
01FB2:  BSF    x1E.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
01FB4:  RRCF   x1C,W
01FB6:  MOVWF  x20
01FB8:  RRCF   x1B,W
01FBA:  MOVWF  x1F
01FBC:  RRCF   x20,F
01FBE:  RRCF   x1F,F
01FC0:  RRCF   x20,F
01FC2:  RRCF   x1F,F
01FC4:  RRCF   x20,F
01FC6:  RRCF   x1F,F
01FC8:  RRCF   x20,F
01FCA:  RRCF   x1F,F
01FCC:  RRCF   x20,F
01FCE:  RRCF   x1F,F
01FD0:  RRCF   x20,F
01FD2:  RRCF   x1F,F
01FD4:  MOVLW  01
01FD6:  ANDWF  x20,F
01FD8:  MOVF   x1F,W
01FDA:  ANDLW  01
01FDC:  MOVWF  00
01FDE:  CLRF   03
01FE0:  MOVF   00,W
01FE2:  MOVWF  01
01FE4:  BCF    x1E.3
01FE6:  BTFSC  01.0
01FE8:  BSF    x1E.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
01FEA:  RRCF   x1C,W
01FEC:  MOVWF  x20
01FEE:  RRCF   x1B,W
01FF0:  MOVWF  x1F
01FF2:  RRCF   x20,F
01FF4:  RRCF   x1F,F
01FF6:  RRCF   x20,F
01FF8:  RRCF   x1F,F
01FFA:  RRCF   x20,F
01FFC:  RRCF   x1F,F
01FFE:  RRCF   x20,F
02000:  RRCF   x1F,F
02002:  RRCF   x20,F
02004:  RRCF   x1F,F
02006:  MOVLW  03
02008:  ANDWF  x20,F
0200A:  MOVF   x1F,W
0200C:  ANDLW  01
0200E:  MOVWF  00
02010:  CLRF   03
02012:  MOVF   00,W
02014:  MOVWF  01
02016:  BCF    x1E.2
02018:  BTFSC  01.0
0201A:  BSF    x1E.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
0201C:  RRCF   x1C,W
0201E:  MOVWF  x20
02020:  RRCF   x1B,W
02022:  MOVWF  x1F
02024:  RRCF   x20,F
02026:  RRCF   x1F,F
02028:  RRCF   x20,F
0202A:  RRCF   x1F,F
0202C:  RRCF   x20,F
0202E:  RRCF   x1F,F
02030:  RRCF   x20,F
02032:  RRCF   x1F,F
02034:  MOVLW  07
02036:  ANDWF  x20,F
02038:  MOVF   x1F,W
0203A:  ANDLW  01
0203C:  MOVWF  00
0203E:  CLRF   03
02040:  MOVF   00,W
02042:  MOVWF  01
02044:  BCF    x1E.1
02046:  BTFSC  01.0
02048:  BSF    x1E.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
0204A:  RRCF   x1C,W
0204C:  MOVWF  x20
0204E:  RRCF   x1B,W
02050:  MOVWF  x1F
02052:  RRCF   x20,F
02054:  RRCF   x1F,F
02056:  RRCF   x20,F
02058:  RRCF   x1F,F
0205A:  RRCF   x20,F
0205C:  RRCF   x1F,F
0205E:  MOVLW  0F
02060:  ANDWF  x20,F
02062:  MOVF   x1F,W
02064:  ANDLW  01
02066:  MOVWF  00
02068:  CLRF   03
0206A:  MOVF   00,W
0206C:  MOVWF  01
0206E:  BCF    x1E.0
02070:  BTFSC  01.0
02072:  BSF    x1E.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
02074:  RRCF   x1C,W
02076:  MOVWF  x20
02078:  RRCF   x1B,W
0207A:  MOVWF  x1F
0207C:  RRCF   x20,F
0207E:  RRCF   x1F,F
02080:  RRCF   x20,F
02082:  RRCF   x1F,F
02084:  MOVLW  1F
02086:  ANDWF  x20,F
02088:  MOVF   x1F,W
0208A:  ANDLW  01
0208C:  MOVWF  00
0208E:  CLRF   03
02090:  MOVF   00,W
02092:  MOVWF  01
02094:  BCF    x1D.7
02096:  BTFSC  01.0
02098:  BSF    x1D.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
0209A:  RRCF   x1C,W
0209C:  MOVWF  x20
0209E:  RRCF   x1B,W
020A0:  MOVWF  x1F
020A2:  RRCF   x20,F
020A4:  RRCF   x1F,F
020A6:  MOVLW  3F
020A8:  ANDWF  x20,F
020AA:  MOVF   x1F,W
020AC:  ANDLW  01
020AE:  MOVWF  00
020B0:  CLRF   03
020B2:  MOVF   00,W
020B4:  MOVWF  01
020B6:  BCF    x1D.6
020B8:  BTFSC  01.0
020BA:  BSF    x1D.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
020BC:  BCF    FD8.0
020BE:  RRCF   x1C,W
020C0:  MOVWF  x20
020C2:  RRCF   x1B,W
020C4:  MOVWF  x1F
020C6:  MOVF   x1F,W
020C8:  ANDLW  01
020CA:  MOVWF  00
020CC:  CLRF   03
020CE:  MOVF   00,W
020D0:  MOVWF  01
020D2:  BCF    x1D.5
020D4:  BTFSC  01.0
020D6:  BSF    x1D.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
020D8:  MOVF   x1B,W
020DA:  ANDLW  01
020DC:  MOVWF  00
020DE:  CLRF   03
020E0:  MOVF   00,W
020E2:  MOVWF  01
020E4:  BCF    x1D.4
020E6:  BTFSC  01.0
020E8:  BSF    x1D.4
....................    cmd.fields.reserved = 0; // Reserved bits
020EA:  BCF    x1D.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
020EC:  BCF    x1D.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
020EE:  BCF    x1D.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
020F0:  BCF    x1D.0
.................... 
....................    return cmd.value;
020F2:  MOVF   x1D,W
020F4:  MOVWF  01
020F6:  MOVF   x1E,W
020F8:  MOVWF  02
020FA:  MOVLB  0
020FC:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
03372:  MOVLB  B
03374:  MOVF   xC3,W
03376:  XORLW  00
03378:  MOVLB  0
0337A:  BTFSC  FD8.2
0337C:  GOTO   338C
03380:  XORLW  01
03382:  BTFSC  FD8.2
03384:  GOTO   33F4
03388:  GOTO   345C
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
0338C:  MOVLB  B
0338E:  CLRF   xCC
03390:  CLRF   xCB
03392:  MOVLB  0
03394:  MOVLB  B
03396:  MOVF   xCC,W
03398:  SUBWF  xCA,W
0339A:  BTFSC  FD8.0
0339C:  BRA    33A4
0339E:  MOVLB  0
033A0:  GOTO   33F0
033A4:  MOVLB  0
033A6:  BTFSS  FD8.2
033A8:  GOTO   33BE
033AC:  MOVLB  B
033AE:  MOVF   xC9,W
033B0:  SUBWF  xCB,W
033B2:  BTFSS  FD8.0
033B4:  BRA    33BC
033B6:  MOVLB  0
033B8:  GOTO   33F0
033BC:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
033BE:  MOVLB  B
033C0:  MOVF   xC7,W
033C2:  ADDWF  xCB,W
033C4:  MOVWF  FE9
033C6:  MOVF   xC8,W
033C8:  ADDWFC xCC,W
033CA:  MOVWF  FEA
033CC:  MOVFF  FEF,BCF
033D0:  MOVFF  BCF,BE5
033D4:  MOVLW  08
033D6:  MOVWF  xE6
033D8:  MOVLW  01
033DA:  MOVWF  xE7
033DC:  MOVLB  0
033DE:  CALL   239E
033E2:  MOVLB  B
033E4:  INCF   xCB,F
033E6:  BTFSC  FD8.2
033E8:  INCF   xCC,F
033EA:  MOVLB  0
033EC:  GOTO   3394
....................          break;
033F0:  GOTO   3460
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
033F4:  MOVLB  B
033F6:  CLRF   xCE
033F8:  CLRF   xCD
033FA:  MOVLB  0
033FC:  MOVLB  B
033FE:  MOVF   xCE,W
03400:  SUBWF  xCA,W
03402:  BTFSC  FD8.0
03404:  BRA    340C
03406:  MOVLB  0
03408:  GOTO   3458
0340C:  MOVLB  0
0340E:  BTFSS  FD8.2
03410:  GOTO   3426
03414:  MOVLB  B
03416:  MOVF   xC9,W
03418:  SUBWF  xCD,W
0341A:  BTFSS  FD8.0
0341C:  BRA    3424
0341E:  MOVLB  0
03420:  GOTO   3458
03424:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
03426:  MOVLB  B
03428:  MOVF   xC7,W
0342A:  ADDWF  xCD,W
0342C:  MOVWF  FE9
0342E:  MOVF   xC8,W
03430:  ADDWFC xCE,W
03432:  MOVWF  FEA
03434:  MOVFF  FEF,BCF
03438:  MOVFF  BCF,BE5
0343C:  MOVLW  08
0343E:  MOVWF  xE6
03440:  MOVLW  01
03442:  MOVWF  xE7
03444:  MOVLB  0
03446:  CALL   241A
0344A:  MOVLB  B
0344C:  INCF   xCD,F
0344E:  BTFSC  FD8.2
03450:  INCF   xCE,F
03452:  MOVLB  0
03454:  GOTO   33FC
....................          break;
03458:  GOTO   3460
....................          
....................       default:
....................          break;
0345C:  GOTO   3460
....................    }
....................    return;
03460:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
02496:  MOVLB  B
02498:  MOVF   xC9,W
0249A:  XORLW  00
0249C:  MOVLB  0
0249E:  BTFSC  FD8.2
024A0:  GOTO   24B0
024A4:  XORLW  01
024A6:  BTFSC  FD8.2
024A8:  GOTO   25BA
024AC:  GOTO   26C4
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
024B0:  MOVLB  B
024B2:  CLRF   xD8
024B4:  CLRF   xD7
024B6:  MOVLB  0
024B8:  MOVLB  B
024BA:  MOVF   xD8,W
024BC:  SUBWF  xD0,W
024BE:  BTFSC  FD8.0
024C0:  BRA    24C8
024C2:  MOVLB  0
024C4:  GOTO   2514
024C8:  MOVLB  0
024CA:  BTFSS  FD8.2
024CC:  GOTO   24E2
024D0:  MOVLB  B
024D2:  MOVF   xCF,W
024D4:  SUBWF  xD7,W
024D6:  BTFSS  FD8.0
024D8:  BRA    24E0
024DA:  MOVLB  0
024DC:  GOTO   2514
024E0:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
024E2:  MOVLB  B
024E4:  MOVF   xCD,W
024E6:  ADDWF  xD7,W
024E8:  MOVWF  FE9
024EA:  MOVF   xCE,W
024EC:  ADDWFC xD8,W
024EE:  MOVWF  FEA
024F0:  MOVFF  FEF,BE3
024F4:  MOVFF  BE3,BE5
024F8:  MOVLW  08
024FA:  MOVWF  xE6
024FC:  MOVLW  01
024FE:  MOVWF  xE7
02500:  MOVLB  0
02502:  CALL   239E
02506:  MOVLB  B
02508:  INCF   xD7,F
0250A:  BTFSC  FD8.2
0250C:  INCF   xD8,F
0250E:  MOVLB  0
02510:  GOTO   24B8
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02514:  MOVLB  B
02516:  CLRF   xDC
02518:  CLRF   xDB
0251A:  CLRF   xDA
0251C:  CLRF   xD9
0251E:  MOVLB  0
02520:  MOVLB  B
02522:  MOVF   xDC,W
02524:  SUBWF  xD6,W
02526:  BTFSC  FD8.0
02528:  BRA    2530
0252A:  MOVLB  0
0252C:  GOTO   25B6
02530:  MOVLB  0
02532:  BTFSS  FD8.2
02534:  GOTO   257A
02538:  MOVLB  B
0253A:  MOVF   xDB,W
0253C:  SUBWF  xD5,W
0253E:  BTFSC  FD8.0
02540:  BRA    2548
02542:  MOVLB  0
02544:  GOTO   25B6
02548:  MOVLB  0
0254A:  BTFSS  FD8.2
0254C:  GOTO   257A
02550:  MOVLB  B
02552:  MOVF   xDA,W
02554:  SUBWF  xD4,W
02556:  BTFSC  FD8.0
02558:  BRA    2560
0255A:  MOVLB  0
0255C:  GOTO   25B6
02560:  MOVLB  0
02562:  BTFSS  FD8.2
02564:  GOTO   257A
02568:  MOVLB  B
0256A:  MOVF   xD3,W
0256C:  SUBWF  xD9,W
0256E:  BTFSS  FD8.0
02570:  BRA    2578
02572:  MOVLB  0
02574:  GOTO   25B6
02578:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
0257A:  MOVLB  B
0257C:  MOVF   xD1,W
0257E:  ADDWF  xD9,W
02580:  MOVWF  FE9
02582:  MOVF   xD2,W
02584:  ADDWFC xDA,W
02586:  MOVWF  FEA
02588:  MOVLW  02
0258A:  MOVWF  xE5
0258C:  MOVLW  08
0258E:  MOVWF  xE6
02590:  MOVLW  01
02592:  MOVWF  xE7
02594:  MOVLB  0
02596:  CALL   239E
0259A:  MOVFF  01,FEF
0259E:  MOVLW  01
025A0:  MOVLB  B
025A2:  ADDWF  xD9,F
025A4:  BTFSC  FD8.0
025A6:  INCF   xDA,F
025A8:  BTFSC  FD8.2
025AA:  INCF   xDB,F
025AC:  BTFSC  FD8.2
025AE:  INCF   xDC,F
025B0:  MOVLB  0
025B2:  GOTO   2520
....................          break;
025B6:  GOTO   26C8
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025BA:  MOVLB  B
025BC:  CLRF   xDE
025BE:  CLRF   xDD
025C0:  MOVLB  0
025C2:  MOVLB  B
025C4:  MOVF   xDE,W
025C6:  SUBWF  xD0,W
025C8:  BTFSC  FD8.0
025CA:  BRA    25D2
025CC:  MOVLB  0
025CE:  GOTO   261E
025D2:  MOVLB  0
025D4:  BTFSS  FD8.2
025D6:  GOTO   25EC
025DA:  MOVLB  B
025DC:  MOVF   xCF,W
025DE:  SUBWF  xDD,W
025E0:  BTFSS  FD8.0
025E2:  BRA    25EA
025E4:  MOVLB  0
025E6:  GOTO   261E
025EA:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
025EC:  MOVLB  B
025EE:  MOVF   xCD,W
025F0:  ADDWF  xDD,W
025F2:  MOVWF  FE9
025F4:  MOVF   xCE,W
025F6:  ADDWFC xDE,W
025F8:  MOVWF  FEA
025FA:  MOVFF  FEF,BE3
025FE:  MOVFF  BE3,BE5
02602:  MOVLW  08
02604:  MOVWF  xE6
02606:  MOVLW  01
02608:  MOVWF  xE7
0260A:  MOVLB  0
0260C:  CALL   241A
02610:  MOVLB  B
02612:  INCF   xDD,F
02614:  BTFSC  FD8.2
02616:  INCF   xDE,F
02618:  MOVLB  0
0261A:  GOTO   25C2
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0261E:  MOVLB  B
02620:  CLRF   xE2
02622:  CLRF   xE1
02624:  CLRF   xE0
02626:  CLRF   xDF
02628:  MOVLB  0
0262A:  MOVLB  B
0262C:  MOVF   xE2,W
0262E:  SUBWF  xD6,W
02630:  BTFSC  FD8.0
02632:  BRA    263A
02634:  MOVLB  0
02636:  GOTO   26C0
0263A:  MOVLB  0
0263C:  BTFSS  FD8.2
0263E:  GOTO   2684
02642:  MOVLB  B
02644:  MOVF   xE1,W
02646:  SUBWF  xD5,W
02648:  BTFSC  FD8.0
0264A:  BRA    2652
0264C:  MOVLB  0
0264E:  GOTO   26C0
02652:  MOVLB  0
02654:  BTFSS  FD8.2
02656:  GOTO   2684
0265A:  MOVLB  B
0265C:  MOVF   xE0,W
0265E:  SUBWF  xD4,W
02660:  BTFSC  FD8.0
02662:  BRA    266A
02664:  MOVLB  0
02666:  GOTO   26C0
0266A:  MOVLB  0
0266C:  BTFSS  FD8.2
0266E:  GOTO   2684
02672:  MOVLB  B
02674:  MOVF   xD3,W
02676:  SUBWF  xDF,W
02678:  BTFSS  FD8.0
0267A:  BRA    2682
0267C:  MOVLB  0
0267E:  GOTO   26C0
02682:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
02684:  MOVLB  B
02686:  MOVF   xD1,W
02688:  ADDWF  xDF,W
0268A:  MOVWF  FE9
0268C:  MOVF   xD2,W
0268E:  ADDWFC xE0,W
02690:  MOVWF  FEA
02692:  MOVLW  01
02694:  MOVWF  xE5
02696:  MOVLW  08
02698:  MOVWF  xE6
0269A:  MOVLW  01
0269C:  MOVWF  xE7
0269E:  MOVLB  0
026A0:  CALL   241A
026A4:  MOVFF  01,FEF
026A8:  MOVLW  01
026AA:  MOVLB  B
026AC:  ADDWF  xDF,F
026AE:  BTFSC  FD8.0
026B0:  INCF   xE0,F
026B2:  BTFSC  FD8.2
026B4:  INCF   xE1,F
026B6:  BTFSC  FD8.2
026B8:  INCF   xE2,F
026BA:  MOVLB  0
026BC:  GOTO   262A
....................          break;
026C0:  GOTO   26C8
....................    
....................          
....................       default:
....................          break;
026C4:  GOTO   26C8
....................    }
....................    return;
026C8:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
03462:  MOVLB  B
03464:  MOVF   xC3,W
03466:  XORLW  00
03468:  MOVLB  0
0346A:  BTFSC  FD8.2
0346C:  GOTO   347C
03470:  XORLW  01
03472:  BTFSC  FD8.2
03474:  GOTO   352A
03478:  GOTO   35D8
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
0347C:  MOVLB  B
0347E:  CLRF   xCE
03480:  MOVLB  0
03482:  MOVLB  B
03484:  MOVF   xC9,W
03486:  SUBWF  xCE,W
03488:  BTFSS  FD8.0
0348A:  BRA    3492
0348C:  MOVLB  0
0348E:  GOTO   34C2
03492:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
03494:  MOVLB  B
03496:  MOVF   xCE,W
03498:  ADDWF  xC7,W
0349A:  MOVWF  FE9
0349C:  MOVLW  00
0349E:  ADDWFC xC8,W
034A0:  MOVWF  FEA
034A2:  MOVFF  FEF,BD4
034A6:  MOVFF  BD4,BE5
034AA:  MOVLW  08
034AC:  MOVWF  xE6
034AE:  MOVLW  01
034B0:  MOVWF  xE7
034B2:  MOVLB  0
034B4:  CALL   239E
034B8:  MOVLB  B
034BA:  INCF   xCE,F
034BC:  MOVLB  0
034BE:  GOTO   3482
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
034C2:  MOVLB  B
034C4:  CLRF   xD0
034C6:  CLRF   xCF
034C8:  MOVLB  0
034CA:  MOVLB  B
034CC:  MOVF   xD0,W
034CE:  SUBWF  xCD,W
034D0:  BTFSC  FD8.0
034D2:  BRA    34DA
034D4:  MOVLB  0
034D6:  GOTO   3526
034DA:  MOVLB  0
034DC:  BTFSS  FD8.2
034DE:  GOTO   34F4
034E2:  MOVLB  B
034E4:  MOVF   xCC,W
034E6:  SUBWF  xCF,W
034E8:  BTFSS  FD8.0
034EA:  BRA    34F2
034EC:  MOVLB  0
034EE:  GOTO   3526
034F2:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
034F4:  MOVLB  B
034F6:  MOVF   xCA,W
034F8:  ADDWF  xCF,W
034FA:  MOVWF  FE9
034FC:  MOVF   xCB,W
034FE:  ADDWFC xD0,W
03500:  MOVWF  FEA
03502:  MOVFF  FEF,BD4
03506:  MOVFF  BD4,BE5
0350A:  MOVLW  08
0350C:  MOVWF  xE6
0350E:  MOVLW  01
03510:  MOVWF  xE7
03512:  MOVLB  0
03514:  CALL   239E
03518:  MOVLB  B
0351A:  INCF   xCF,F
0351C:  BTFSC  FD8.2
0351E:  INCF   xD0,F
03520:  MOVLB  0
03522:  GOTO   34CA
....................          break;
03526:  GOTO   35DC
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
0352A:  MOVLB  B
0352C:  CLRF   xD1
0352E:  MOVLB  0
03530:  MOVLB  B
03532:  MOVF   xC9,W
03534:  SUBWF  xD1,W
03536:  BTFSS  FD8.0
03538:  BRA    3540
0353A:  MOVLB  0
0353C:  GOTO   3570
03540:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
03542:  MOVLB  B
03544:  MOVF   xD1,W
03546:  ADDWF  xC7,W
03548:  MOVWF  FE9
0354A:  MOVLW  00
0354C:  ADDWFC xC8,W
0354E:  MOVWF  FEA
03550:  MOVFF  FEF,BD4
03554:  MOVFF  BD4,BE5
03558:  MOVLW  08
0355A:  MOVWF  xE6
0355C:  MOVLW  01
0355E:  MOVWF  xE7
03560:  MOVLB  0
03562:  CALL   241A
03566:  MOVLB  B
03568:  INCF   xD1,F
0356A:  MOVLB  0
0356C:  GOTO   3530
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03570:  MOVLB  B
03572:  CLRF   xD3
03574:  CLRF   xD2
03576:  MOVLB  0
03578:  MOVLB  B
0357A:  MOVF   xD3,W
0357C:  SUBWF  xCD,W
0357E:  BTFSC  FD8.0
03580:  BRA    3588
03582:  MOVLB  0
03584:  GOTO   35D4
03588:  MOVLB  0
0358A:  BTFSS  FD8.2
0358C:  GOTO   35A2
03590:  MOVLB  B
03592:  MOVF   xCC,W
03594:  SUBWF  xD2,W
03596:  BTFSS  FD8.0
03598:  BRA    35A0
0359A:  MOVLB  0
0359C:  GOTO   35D4
035A0:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
035A2:  MOVLB  B
035A4:  MOVF   xCA,W
035A6:  ADDWF  xD2,W
035A8:  MOVWF  FE9
035AA:  MOVF   xCB,W
035AC:  ADDWFC xD3,W
035AE:  MOVWF  FEA
035B0:  MOVFF  FEF,BD4
035B4:  MOVFF  BD4,BE5
035B8:  MOVLW  08
035BA:  MOVWF  xE6
035BC:  MOVLW  01
035BE:  MOVWF  xE7
035C0:  MOVLB  0
035C2:  CALL   241A
035C6:  MOVLB  B
035C8:  INCF   xD2,F
035CA:  BTFSC  FD8.2
035CC:  INCF   xD3,F
035CE:  MOVLB  0
035D0:  GOTO   3578
....................          break;
035D4:  GOTO   35DC
....................          
....................       default:
....................          break;
035D8:  GOTO   35DC
....................    }
....................    return;
035DC:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
055A0:  MOVFF  3EC,BC9
055A4:  MOVLW  01
055A6:  MOVLB  B
055A8:  MOVWF  xCA
055AA:  MOVLW  0F
055AC:  MOVWF  xCC
055AE:  MOVLW  89
055B0:  MOVWF  xCB
055B2:  MOVLB  0
055B4:  CALL   234A
055B8:  MOVFF  3EC,BC9
055BC:  MOVLB  B
055BE:  CLRF   xCA
055C0:  MOVLW  0F
055C2:  MOVWF  xCC
055C4:  MOVLW  92
055C6:  MOVWF  xCB
055C8:  MOVLB  0
055CA:  CALL   234A
055CE:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
035DE:  MOVLW  05
035E0:  MOVLB  B
035E2:  MOVWF  xC7
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
035E4:  MOVFF  BC5,BC9
035E8:  CLRF   xCA
035EA:  MOVLW  0F
035EC:  MOVWF  xCC
035EE:  MOVLW  89
035F0:  MOVWF  xCB
035F2:  MOVLB  0
035F4:  CALL   234A
035F8:  MOVFF  BC5,BC9
035FC:  MOVLB  B
035FE:  CLRF   xCA
03600:  MOVLW  0F
03602:  MOVWF  xCC
03604:  MOVLW  92
03606:  MOVWF  xCB
03608:  MOVLB  0
0360A:  CALL   234A
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
0360E:  MOVFF  BC6,BCC
03612:  MOVFF  BC5,BCB
03616:  MOVFF  BC4,BCA
0361A:  MOVFF  BC3,BC9
0361E:  MOVLW  0B
03620:  MOVLB  B
03622:  MOVWF  xCE
03624:  MOVLW  C7
03626:  MOVWF  xCD
03628:  CLRF   xD0
0362A:  MOVLW  01
0362C:  MOVWF  xCF
0362E:  MOVLW  0B
03630:  MOVWF  xD2
03632:  MOVLW  C8
03634:  MOVWF  xD1
03636:  CLRF   xD6
03638:  CLRF   xD5
0363A:  CLRF   xD4
0363C:  MOVLW  01
0363E:  MOVWF  xD3
03640:  MOVLB  0
03642:  CALL   2496
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
03646:  MOVFF  BC5,BC9
0364A:  MOVLW  01
0364C:  MOVLB  B
0364E:  MOVWF  xCA
03650:  MOVLW  0F
03652:  MOVWF  xCC
03654:  MOVLW  89
03656:  MOVWF  xCB
03658:  MOVLB  0
0365A:  CALL   234A
0365E:  MOVFF  BC5,BC9
03662:  MOVLB  B
03664:  CLRF   xCA
03666:  MOVLW  0F
03668:  MOVWF  xCC
0366A:  MOVLW  92
0366C:  MOVWF  xCB
0366E:  MOVLB  0
03670:  CALL   234A
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
03674:  MOVLB  B
03676:  MOVF   xC8,W
03678:  MOVWF  01
0367A:  MOVLB  0
0367C:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
04568:  MOVLB  3
0456A:  MOVF   x26,F
0456C:  BTFSC  FD8.2
0456E:  BRA    4576
04570:  MOVLB  0
04572:  GOTO   46CE
04576:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
04578:  MOVLW  06
0457A:  MOVLB  3
0457C:  MOVWF  x2D
0457E:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
04580:  MOVLW  D8
04582:  MOVLB  3
04584:  MOVWF  x2E
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04586:  MOVFF  32B,33A
0458A:  MOVFF  32C,33B
0458E:  CLRF   x3C
04590:  CLRF   x3D
04592:  MOVF   x3A,W
04594:  MOVWF  00
04596:  CLRF   01
04598:  CLRF   02
0459A:  CLRF   03
0459C:  MOVFF  00,32F
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
045A0:  MOVFF  32A,33A
045A4:  MOVFF  32B,33B
045A8:  MOVFF  32C,33C
045AC:  CLRF   x3D
045AE:  MOVF   x3A,W
045B0:  MOVWF  00
045B2:  CLRF   01
045B4:  CLRF   02
045B6:  CLRF   03
045B8:  MOVFF  00,330
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
045BC:  MOVF   x29,W
045BE:  MOVWF  00
045C0:  CLRF   01
045C2:  CLRF   02
045C4:  CLRF   03
045C6:  MOVFF  00,331
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
045CA:  MOVFF  327,BC9
045CE:  MOVLB  B
045D0:  CLRF   xCA
045D2:  MOVLW  0F
045D4:  MOVWF  xCC
045D6:  MOVLW  89
045D8:  MOVWF  xCB
045DA:  MOVLB  0
045DC:  CALL   234A
045E0:  MOVFF  327,BC9
045E4:  MOVLB  B
045E6:  CLRF   xCA
045E8:  MOVLW  0F
045EA:  MOVWF  xCC
045EC:  MOVLW  92
045EE:  MOVWF  xCB
045F0:  MOVLB  0
045F2:  CALL   234A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
045F6:  MOVFF  328,BC6
045FA:  MOVFF  327,BC5
045FE:  MOVFF  326,BC4
04602:  MOVFF  325,BC3
04606:  MOVLW  03
04608:  MOVLB  B
0460A:  MOVWF  xC8
0460C:  MOVLW  2D
0460E:  MOVWF  xC7
04610:  CLRF   xCA
04612:  MOVLW  01
04614:  MOVWF  xC9
04616:  MOVLB  0
04618:  CALL   3372
....................       output_high(flash_stream.cs_pin);
0461C:  MOVFF  327,BC9
04620:  MOVLW  01
04622:  MOVLB  B
04624:  MOVWF  xCA
04626:  MOVLW  0F
04628:  MOVWF  xCC
0462A:  MOVLW  89
0462C:  MOVWF  xCB
0462E:  MOVLB  0
04630:  CALL   234A
04634:  MOVFF  327,BC9
04638:  MOVLB  B
0463A:  CLRF   xCA
0463C:  MOVLW  0F
0463E:  MOVWF  xCC
04640:  MOVLW  92
04642:  MOVWF  xCB
04644:  MOVLB  0
04646:  CALL   234A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
0464A:  MOVFF  327,BC9
0464E:  MOVLB  B
04650:  CLRF   xCA
04652:  MOVLW  0F
04654:  MOVWF  xCC
04656:  MOVLW  89
04658:  MOVWF  xCB
0465A:  MOVLB  0
0465C:  CALL   234A
04660:  MOVFF  327,BC9
04664:  MOVLB  B
04666:  CLRF   xCA
04668:  MOVLW  0F
0466A:  MOVWF  xCC
0466C:  MOVLW  92
0466E:  MOVWF  xCB
04670:  MOVLB  0
04672:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
04676:  MOVFF  328,BC6
0467A:  MOVFF  327,BC5
0467E:  MOVFF  326,BC4
04682:  MOVFF  325,BC3
04686:  MOVLW  03
04688:  MOVLB  B
0468A:  MOVWF  xC8
0468C:  MOVLW  2E
0468E:  MOVWF  xC7
04690:  CLRF   xCA
04692:  MOVLW  04
04694:  MOVWF  xC9
04696:  MOVLB  0
04698:  CALL   3372
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0469C:  MOVFF  327,BC9
046A0:  MOVLW  01
046A2:  MOVLB  B
046A4:  MOVWF  xCA
046A6:  MOVLW  0F
046A8:  MOVWF  xCC
046AA:  MOVLW  89
046AC:  MOVWF  xCB
046AE:  MOVLB  0
046B0:  CALL   234A
046B4:  MOVFF  327,BC9
046B8:  MOVLB  B
046BA:  CLRF   xCA
046BC:  MOVLW  0F
046BE:  MOVWF  xCC
046C0:  MOVLW  92
046C2:  MOVWF  xCB
046C4:  MOVLB  0
046C6:  CALL   234A
....................    }
046CA:  GOTO   484E
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
046CE:  MOVLB  3
046D0:  DECFSZ x26,W
046D2:  BRA    46D8
046D4:  BRA    46DE
046D6:  MOVLB  0
046D8:  MOVLB  0
046DA:  GOTO   484E
046DE:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
046E0:  MOVLW  06
046E2:  MOVLB  3
046E4:  MOVWF  x32
046E6:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
046E8:  MOVLW  DC
046EA:  MOVLB  3
046EC:  MOVWF  x33
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
046EE:  MOVFF  32C,33A
046F2:  CLRF   x3B
046F4:  CLRF   x3C
046F6:  CLRF   x3D
046F8:  MOVF   x3A,W
046FA:  MOVWF  00
046FC:  CLRF   01
046FE:  CLRF   02
04700:  CLRF   03
04702:  MOVFF  00,334
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04706:  MOVFF  32B,33A
0470A:  MOVFF  32C,33B
0470E:  CLRF   x3C
04710:  CLRF   x3D
04712:  MOVF   x3A,W
04714:  MOVWF  00
04716:  CLRF   01
04718:  CLRF   02
0471A:  CLRF   03
0471C:  MOVFF  00,335
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04720:  MOVFF  32A,33A
04724:  MOVFF  32B,33B
04728:  MOVFF  32C,33C
0472C:  CLRF   x3D
0472E:  MOVF   x3A,W
04730:  MOVWF  00
04732:  CLRF   01
04734:  CLRF   02
04736:  CLRF   03
04738:  MOVFF  00,336
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
0473C:  MOVF   x29,W
0473E:  MOVWF  00
04740:  CLRF   01
04742:  CLRF   02
04744:  CLRF   03
04746:  MOVFF  00,337
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
0474A:  MOVFF  327,BC9
0474E:  MOVLB  B
04750:  CLRF   xCA
04752:  MOVLW  0F
04754:  MOVWF  xCC
04756:  MOVLW  89
04758:  MOVWF  xCB
0475A:  MOVLB  0
0475C:  CALL   234A
04760:  MOVFF  327,BC9
04764:  MOVLB  B
04766:  CLRF   xCA
04768:  MOVLW  0F
0476A:  MOVWF  xCC
0476C:  MOVLW  92
0476E:  MOVWF  xCB
04770:  MOVLB  0
04772:  CALL   234A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04776:  MOVFF  328,BC6
0477A:  MOVFF  327,BC5
0477E:  MOVFF  326,BC4
04782:  MOVFF  325,BC3
04786:  MOVLW  03
04788:  MOVLB  B
0478A:  MOVWF  xC8
0478C:  MOVLW  32
0478E:  MOVWF  xC7
04790:  CLRF   xCA
04792:  MOVLW  01
04794:  MOVWF  xC9
04796:  MOVLB  0
04798:  CALL   3372
....................       output_high(flash_stream.cs_pin);
0479C:  MOVFF  327,BC9
047A0:  MOVLW  01
047A2:  MOVLB  B
047A4:  MOVWF  xCA
047A6:  MOVLW  0F
047A8:  MOVWF  xCC
047AA:  MOVLW  89
047AC:  MOVWF  xCB
047AE:  MOVLB  0
047B0:  CALL   234A
047B4:  MOVFF  327,BC9
047B8:  MOVLB  B
047BA:  CLRF   xCA
047BC:  MOVLW  0F
047BE:  MOVWF  xCC
047C0:  MOVLW  92
047C2:  MOVWF  xCB
047C4:  MOVLB  0
047C6:  CALL   234A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
047CA:  MOVFF  327,BC9
047CE:  MOVLB  B
047D0:  CLRF   xCA
047D2:  MOVLW  0F
047D4:  MOVWF  xCC
047D6:  MOVLW  89
047D8:  MOVWF  xCB
047DA:  MOVLB  0
047DC:  CALL   234A
047E0:  MOVFF  327,BC9
047E4:  MOVLB  B
047E6:  CLRF   xCA
047E8:  MOVLW  0F
047EA:  MOVWF  xCC
047EC:  MOVLW  92
047EE:  MOVWF  xCB
047F0:  MOVLB  0
047F2:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
047F6:  MOVFF  328,BC6
047FA:  MOVFF  327,BC5
047FE:  MOVFF  326,BC4
04802:  MOVFF  325,BC3
04806:  MOVLW  03
04808:  MOVLB  B
0480A:  MOVWF  xC8
0480C:  MOVLW  33
0480E:  MOVWF  xC7
04810:  CLRF   xCA
04812:  MOVLW  05
04814:  MOVWF  xC9
04816:  MOVLB  0
04818:  CALL   3372
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0481C:  MOVFF  327,BC9
04820:  MOVLW  01
04822:  MOVLB  B
04824:  MOVWF  xCA
04826:  MOVLW  0F
04828:  MOVWF  xCC
0482A:  MOVLW  89
0482C:  MOVWF  xCB
0482E:  MOVLB  0
04830:  CALL   234A
04834:  MOVFF  327,BC9
04838:  MOVLB  B
0483A:  CLRF   xCA
0483C:  MOVLW  0F
0483E:  MOVWF  xCC
04840:  MOVLW  92
04842:  MOVWF  xCB
04844:  MOVLB  0
04846:  CALL   234A
....................    }
0484A:  GOTO   484E
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
0484E:  MOVLB  3
04850:  CLRF   x38
04852:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
04854:  MOVFF  328,BC6
04858:  MOVFF  327,BC5
0485C:  MOVFF  326,BC4
04860:  MOVFF  325,BC3
04864:  CALL   35DE
04868:  MOVF   01,W
0486A:  ANDLW  01
0486C:  SUBLW  01
0486E:  BTFSS  FD8.2
04870:  GOTO   48C2
....................       if(timeout_counter > 10)
04874:  MOVLB  3
04876:  MOVF   x38,W
04878:  SUBLW  0A
0487A:  BTFSS  FD8.0
0487C:  BRA    4884
0487E:  MOVLB  0
04880:  GOTO   4896
04884:  MOVLB  0
....................          delay_ms(200);
04886:  MOVLW  C8
04888:  MOVLB  B
0488A:  MOVWF  xC3
0488C:  MOVLB  0
0488E:  CALL   1B30
04892:  GOTO   48A2
....................       else
....................          delay_ms(10);   
04896:  MOVLW  0A
04898:  MOVLB  B
0489A:  MOVWF  xC3
0489C:  MOVLB  0
0489E:  CALL   1B30
....................       
....................       if(timeout_counter > 100){
048A2:  MOVLB  3
048A4:  MOVF   x38,W
048A6:  SUBLW  64
048A8:  BTFSS  FD8.0
048AA:  BRA    48B2
048AC:  MOVLB  0
048AE:  GOTO   48B8
048B2:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
048B4:  GOTO   48C2
....................       }  
....................       timeout_counter++;
048B8:  MOVLB  3
048BA:  INCF   x38,F
048BC:  MOVLB  0
048BE:  GOTO   4854
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
048C2:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
04B38:  MOVLB  4
04B3A:  MOVF   x36,F
04B3C:  BTFSC  FD8.2
04B3E:  BRA    4B46
04B40:  MOVLB  0
04B42:  GOTO   4C9E
04B46:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
04B48:  MOVLW  06
04B4A:  MOVLB  4
04B4C:  MOVWF  x3D
04B4E:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
04B50:  MOVLW  20
04B52:  MOVLB  4
04B54:  MOVWF  x3E
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04B56:  MOVFF  43B,44A
04B5A:  MOVFF  43C,44B
04B5E:  CLRF   x4C
04B60:  CLRF   x4D
04B62:  MOVF   x4A,W
04B64:  MOVWF  00
04B66:  CLRF   01
04B68:  CLRF   02
04B6A:  CLRF   03
04B6C:  MOVFF  00,43F
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04B70:  MOVFF  43A,44A
04B74:  MOVFF  43B,44B
04B78:  MOVFF  43C,44C
04B7C:  CLRF   x4D
04B7E:  MOVF   x4A,W
04B80:  MOVWF  00
04B82:  CLRF   01
04B84:  CLRF   02
04B86:  CLRF   03
04B88:  MOVFF  00,440
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04B8C:  MOVF   x39,W
04B8E:  MOVWF  00
04B90:  CLRF   01
04B92:  CLRF   02
04B94:  CLRF   03
04B96:  MOVFF  00,441
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04B9A:  MOVFF  437,BC9
04B9E:  MOVLB  B
04BA0:  CLRF   xCA
04BA2:  MOVLW  0F
04BA4:  MOVWF  xCC
04BA6:  MOVLW  89
04BA8:  MOVWF  xCB
04BAA:  MOVLB  0
04BAC:  CALL   234A
04BB0:  MOVFF  437,BC9
04BB4:  MOVLB  B
04BB6:  CLRF   xCA
04BB8:  MOVLW  0F
04BBA:  MOVWF  xCC
04BBC:  MOVLW  92
04BBE:  MOVWF  xCB
04BC0:  MOVLB  0
04BC2:  CALL   234A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04BC6:  MOVFF  438,BC6
04BCA:  MOVFF  437,BC5
04BCE:  MOVFF  436,BC4
04BD2:  MOVFF  435,BC3
04BD6:  MOVLW  04
04BD8:  MOVLB  B
04BDA:  MOVWF  xC8
04BDC:  MOVLW  3D
04BDE:  MOVWF  xC7
04BE0:  CLRF   xCA
04BE2:  MOVLW  01
04BE4:  MOVWF  xC9
04BE6:  MOVLB  0
04BE8:  CALL   3372
....................       output_high(flash_stream.cs_pin);
04BEC:  MOVFF  437,BC9
04BF0:  MOVLW  01
04BF2:  MOVLB  B
04BF4:  MOVWF  xCA
04BF6:  MOVLW  0F
04BF8:  MOVWF  xCC
04BFA:  MOVLW  89
04BFC:  MOVWF  xCB
04BFE:  MOVLB  0
04C00:  CALL   234A
04C04:  MOVFF  437,BC9
04C08:  MOVLB  B
04C0A:  CLRF   xCA
04C0C:  MOVLW  0F
04C0E:  MOVWF  xCC
04C10:  MOVLW  92
04C12:  MOVWF  xCB
04C14:  MOVLB  0
04C16:  CALL   234A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04C1A:  MOVFF  437,BC9
04C1E:  MOVLB  B
04C20:  CLRF   xCA
04C22:  MOVLW  0F
04C24:  MOVWF  xCC
04C26:  MOVLW  89
04C28:  MOVWF  xCB
04C2A:  MOVLB  0
04C2C:  CALL   234A
04C30:  MOVFF  437,BC9
04C34:  MOVLB  B
04C36:  CLRF   xCA
04C38:  MOVLW  0F
04C3A:  MOVWF  xCC
04C3C:  MOVLW  92
04C3E:  MOVWF  xCB
04C40:  MOVLB  0
04C42:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
04C46:  MOVFF  438,BC6
04C4A:  MOVFF  437,BC5
04C4E:  MOVFF  436,BC4
04C52:  MOVFF  435,BC3
04C56:  MOVLW  04
04C58:  MOVLB  B
04C5A:  MOVWF  xC8
04C5C:  MOVLW  3E
04C5E:  MOVWF  xC7
04C60:  CLRF   xCA
04C62:  MOVLW  04
04C64:  MOVWF  xC9
04C66:  MOVLB  0
04C68:  CALL   3372
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04C6C:  MOVFF  437,BC9
04C70:  MOVLW  01
04C72:  MOVLB  B
04C74:  MOVWF  xCA
04C76:  MOVLW  0F
04C78:  MOVWF  xCC
04C7A:  MOVLW  89
04C7C:  MOVWF  xCB
04C7E:  MOVLB  0
04C80:  CALL   234A
04C84:  MOVFF  437,BC9
04C88:  MOVLB  B
04C8A:  CLRF   xCA
04C8C:  MOVLW  0F
04C8E:  MOVWF  xCC
04C90:  MOVLW  92
04C92:  MOVWF  xCB
04C94:  MOVLB  0
04C96:  CALL   234A
....................    }
04C9A:  GOTO   4E1E
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04C9E:  MOVLB  4
04CA0:  DECFSZ x36,W
04CA2:  BRA    4CA8
04CA4:  BRA    4CAE
04CA6:  MOVLB  0
04CA8:  MOVLB  0
04CAA:  GOTO   4E1E
04CAE:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04CB0:  MOVLW  06
04CB2:  MOVLB  4
04CB4:  MOVWF  x42
04CB6:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
04CB8:  MOVLW  21
04CBA:  MOVLB  4
04CBC:  MOVWF  x43
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04CBE:  MOVFF  43C,44A
04CC2:  CLRF   x4B
04CC4:  CLRF   x4C
04CC6:  CLRF   x4D
04CC8:  MOVF   x4A,W
04CCA:  MOVWF  00
04CCC:  CLRF   01
04CCE:  CLRF   02
04CD0:  CLRF   03
04CD2:  MOVFF  00,444
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04CD6:  MOVFF  43B,44A
04CDA:  MOVFF  43C,44B
04CDE:  CLRF   x4C
04CE0:  CLRF   x4D
04CE2:  MOVF   x4A,W
04CE4:  MOVWF  00
04CE6:  CLRF   01
04CE8:  CLRF   02
04CEA:  CLRF   03
04CEC:  MOVFF  00,445
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04CF0:  MOVFF  43A,44A
04CF4:  MOVFF  43B,44B
04CF8:  MOVFF  43C,44C
04CFC:  CLRF   x4D
04CFE:  MOVF   x4A,W
04D00:  MOVWF  00
04D02:  CLRF   01
04D04:  CLRF   02
04D06:  CLRF   03
04D08:  MOVFF  00,446
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04D0C:  MOVF   x39,W
04D0E:  MOVWF  00
04D10:  CLRF   01
04D12:  CLRF   02
04D14:  CLRF   03
04D16:  MOVFF  00,447
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04D1A:  MOVFF  437,BC9
04D1E:  MOVLB  B
04D20:  CLRF   xCA
04D22:  MOVLW  0F
04D24:  MOVWF  xCC
04D26:  MOVLW  89
04D28:  MOVWF  xCB
04D2A:  MOVLB  0
04D2C:  CALL   234A
04D30:  MOVFF  437,BC9
04D34:  MOVLB  B
04D36:  CLRF   xCA
04D38:  MOVLW  0F
04D3A:  MOVWF  xCC
04D3C:  MOVLW  92
04D3E:  MOVWF  xCB
04D40:  MOVLB  0
04D42:  CALL   234A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04D46:  MOVFF  438,BC6
04D4A:  MOVFF  437,BC5
04D4E:  MOVFF  436,BC4
04D52:  MOVFF  435,BC3
04D56:  MOVLW  04
04D58:  MOVLB  B
04D5A:  MOVWF  xC8
04D5C:  MOVLW  42
04D5E:  MOVWF  xC7
04D60:  CLRF   xCA
04D62:  MOVLW  01
04D64:  MOVWF  xC9
04D66:  MOVLB  0
04D68:  CALL   3372
....................       output_high(flash_stream.cs_pin);
04D6C:  MOVFF  437,BC9
04D70:  MOVLW  01
04D72:  MOVLB  B
04D74:  MOVWF  xCA
04D76:  MOVLW  0F
04D78:  MOVWF  xCC
04D7A:  MOVLW  89
04D7C:  MOVWF  xCB
04D7E:  MOVLB  0
04D80:  CALL   234A
04D84:  MOVFF  437,BC9
04D88:  MOVLB  B
04D8A:  CLRF   xCA
04D8C:  MOVLW  0F
04D8E:  MOVWF  xCC
04D90:  MOVLW  92
04D92:  MOVWF  xCB
04D94:  MOVLB  0
04D96:  CALL   234A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04D9A:  MOVFF  437,BC9
04D9E:  MOVLB  B
04DA0:  CLRF   xCA
04DA2:  MOVLW  0F
04DA4:  MOVWF  xCC
04DA6:  MOVLW  89
04DA8:  MOVWF  xCB
04DAA:  MOVLB  0
04DAC:  CALL   234A
04DB0:  MOVFF  437,BC9
04DB4:  MOVLB  B
04DB6:  CLRF   xCA
04DB8:  MOVLW  0F
04DBA:  MOVWF  xCC
04DBC:  MOVLW  92
04DBE:  MOVWF  xCB
04DC0:  MOVLB  0
04DC2:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04DC6:  MOVFF  438,BC6
04DCA:  MOVFF  437,BC5
04DCE:  MOVFF  436,BC4
04DD2:  MOVFF  435,BC3
04DD6:  MOVLW  04
04DD8:  MOVLB  B
04DDA:  MOVWF  xC8
04DDC:  MOVLW  43
04DDE:  MOVWF  xC7
04DE0:  CLRF   xCA
04DE2:  MOVLW  05
04DE4:  MOVWF  xC9
04DE6:  MOVLB  0
04DE8:  CALL   3372
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04DEC:  MOVFF  437,BC9
04DF0:  MOVLW  01
04DF2:  MOVLB  B
04DF4:  MOVWF  xCA
04DF6:  MOVLW  0F
04DF8:  MOVWF  xCC
04DFA:  MOVLW  89
04DFC:  MOVWF  xCB
04DFE:  MOVLB  0
04E00:  CALL   234A
04E04:  MOVFF  437,BC9
04E08:  MOVLB  B
04E0A:  CLRF   xCA
04E0C:  MOVLW  0F
04E0E:  MOVWF  xCC
04E10:  MOVLW  92
04E12:  MOVWF  xCB
04E14:  MOVLB  0
04E16:  CALL   234A
....................    }
04E1A:  GOTO   4E1E
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04E1E:  MOVLB  4
04E20:  CLRF   x48
04E22:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
04E24:  MOVFF  438,BC6
04E28:  MOVFF  437,BC5
04E2C:  MOVFF  436,BC4
04E30:  MOVFF  435,BC3
04E34:  CALL   35DE
04E38:  MOVF   01,W
04E3A:  ANDLW  01
04E3C:  SUBLW  01
04E3E:  BTFSS  FD8.2
04E40:  GOTO   4E92
....................       if(timeout_counter > 10)
04E44:  MOVLB  4
04E46:  MOVF   x48,W
04E48:  SUBLW  0A
04E4A:  BTFSS  FD8.0
04E4C:  BRA    4E54
04E4E:  MOVLB  0
04E50:  GOTO   4E66
04E54:  MOVLB  0
....................          delay_ms(200);
04E56:  MOVLW  C8
04E58:  MOVLB  B
04E5A:  MOVWF  xC3
04E5C:  MOVLB  0
04E5E:  CALL   1B30
04E62:  GOTO   4E72
....................       else
....................          delay_ms(10);   
04E66:  MOVLW  0A
04E68:  MOVLB  B
04E6A:  MOVWF  xC3
04E6C:  MOVLB  0
04E6E:  CALL   1B30
....................       
....................       if(timeout_counter > 100){
04E72:  MOVLB  4
04E74:  MOVF   x48,W
04E76:  SUBLW  64
04E78:  BTFSS  FD8.0
04E7A:  BRA    4E82
04E7C:  MOVLB  0
04E7E:  GOTO   4E88
04E82:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
04E84:  GOTO   4E92
....................       }  
....................       timeout_counter++;
04E88:  MOVLB  4
04E8A:  INCF   x48,F
04E8C:  MOVLB  0
04E8E:  GOTO   4E24
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
04E92:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
02792:  MOVLB  4
02794:  MOVF   x36,F
02796:  BTFSC  FD8.2
02798:  BRA    27A0
0279A:  MOVLB  0
0279C:  GOTO   2892
027A0:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
027A2:  MOVLW  03
027A4:  MOVLB  4
027A6:  MOVWF  x43
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
027A8:  MOVFF  43B,44D
027AC:  MOVFF  43C,44E
027B0:  CLRF   x4F
027B2:  CLRF   x50
027B4:  MOVF   x4D,W
027B6:  MOVWF  00
027B8:  CLRF   01
027BA:  CLRF   02
027BC:  CLRF   03
027BE:  MOVFF  00,444
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
027C2:  MOVFF  43A,44D
027C6:  MOVFF  43B,44E
027CA:  MOVFF  43C,44F
027CE:  CLRF   x50
027D0:  MOVF   x4D,W
027D2:  MOVWF  00
027D4:  CLRF   01
027D6:  CLRF   02
027D8:  CLRF   03
027DA:  MOVFF  00,445
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
027DE:  MOVF   x39,W
027E0:  MOVWF  00
027E2:  CLRF   01
027E4:  CLRF   02
027E6:  CLRF   03
027E8:  MOVFF  00,446
....................             
....................       output_low(flash_stream.cs_pin);
027EC:  MOVFF  437,BC9
027F0:  MOVLB  B
027F2:  CLRF   xCA
027F4:  MOVLW  0F
027F6:  MOVWF  xCC
027F8:  MOVLW  89
027FA:  MOVWF  xCB
027FC:  MOVLB  0
027FE:  CALL   234A
02802:  MOVFF  437,BC9
02806:  MOVLB  B
02808:  CLRF   xCA
0280A:  MOVLW  0F
0280C:  MOVWF  xCC
0280E:  MOVLW  92
02810:  MOVWF  xCB
02812:  MOVLB  0
02814:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
02818:  MOVFF  438,BCC
0281C:  MOVFF  437,BCB
02820:  MOVFF  436,BCA
02824:  MOVFF  435,BC9
02828:  MOVLW  04
0282A:  MOVLB  B
0282C:  MOVWF  xCE
0282E:  MOVLW  43
02830:  MOVWF  xCD
02832:  CLRF   xD0
02834:  MOVLW  04
02836:  MOVWF  xCF
02838:  MOVFF  43E,BD2
0283C:  MOVFF  43D,BD1
02840:  MOVFF  442,BD6
02844:  MOVFF  441,BD5
02848:  MOVFF  440,BD4
0284C:  MOVFF  43F,BD3
02850:  MOVLB  0
02852:  CALL   2496
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
02856:  MOVLW  02
02858:  MOVWF  00
0285A:  DECFSZ 00,F
0285C:  BRA    285A
0285E:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
02860:  MOVFF  437,BC9
02864:  MOVLW  01
02866:  MOVLB  B
02868:  MOVWF  xCA
0286A:  MOVLW  0F
0286C:  MOVWF  xCC
0286E:  MOVLW  89
02870:  MOVWF  xCB
02872:  MOVLB  0
02874:  CALL   234A
02878:  MOVFF  437,BC9
0287C:  MOVLB  B
0287E:  CLRF   xCA
02880:  MOVLW  0F
02882:  MOVWF  xCC
02884:  MOVLW  92
02886:  MOVWF  xCB
02888:  MOVLB  0
0288A:  CALL   234A
....................    }
0288E:  GOTO   29A8
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
02892:  MOVLB  4
02894:  DECFSZ x36,W
02896:  BRA    289C
02898:  BRA    28A2
0289A:  MOVLB  0
0289C:  MOVLB  0
0289E:  GOTO   29A8
028A2:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
028A4:  MOVLW  13
028A6:  MOVLB  4
028A8:  MOVWF  x47
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
028AA:  MOVFF  43C,44D
028AE:  CLRF   x4E
028B0:  CLRF   x4F
028B2:  CLRF   x50
028B4:  MOVF   x4D,W
028B6:  MOVWF  00
028B8:  CLRF   01
028BA:  CLRF   02
028BC:  CLRF   03
028BE:  MOVFF  00,448
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
028C2:  MOVFF  43B,44D
028C6:  MOVFF  43C,44E
028CA:  CLRF   x4F
028CC:  CLRF   x50
028CE:  MOVF   x4D,W
028D0:  MOVWF  00
028D2:  CLRF   01
028D4:  CLRF   02
028D6:  CLRF   03
028D8:  MOVFF  00,449
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
028DC:  MOVFF  43A,44D
028E0:  MOVFF  43B,44E
028E4:  MOVFF  43C,44F
028E8:  CLRF   x50
028EA:  MOVF   x4D,W
028EC:  MOVWF  00
028EE:  CLRF   01
028F0:  CLRF   02
028F2:  CLRF   03
028F4:  MOVFF  00,44A
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
028F8:  MOVF   x39,W
028FA:  MOVWF  00
028FC:  CLRF   01
028FE:  CLRF   02
02900:  CLRF   03
02902:  MOVFF  00,44B
....................    
....................       output_low(flash_stream.cs_pin);
02906:  MOVFF  437,BC9
0290A:  MOVLB  B
0290C:  CLRF   xCA
0290E:  MOVLW  0F
02910:  MOVWF  xCC
02912:  MOVLW  89
02914:  MOVWF  xCB
02916:  MOVLB  0
02918:  CALL   234A
0291C:  MOVFF  437,BC9
02920:  MOVLB  B
02922:  CLRF   xCA
02924:  MOVLW  0F
02926:  MOVWF  xCC
02928:  MOVLW  92
0292A:  MOVWF  xCB
0292C:  MOVLB  0
0292E:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02932:  MOVFF  438,BCC
02936:  MOVFF  437,BCB
0293A:  MOVFF  436,BCA
0293E:  MOVFF  435,BC9
02942:  MOVLW  04
02944:  MOVLB  B
02946:  MOVWF  xCE
02948:  MOVLW  47
0294A:  MOVWF  xCD
0294C:  CLRF   xD0
0294E:  MOVLW  05
02950:  MOVWF  xCF
02952:  MOVFF  43E,BD2
02956:  MOVFF  43D,BD1
0295A:  MOVFF  442,BD6
0295E:  MOVFF  441,BD5
02962:  MOVFF  440,BD4
02966:  MOVFF  43F,BD3
0296A:  MOVLB  0
0296C:  CALL   2496
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
02970:  MOVLW  02
02972:  MOVWF  00
02974:  DECFSZ 00,F
02976:  BRA    2974
02978:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0297A:  MOVFF  437,BC9
0297E:  MOVLW  01
02980:  MOVLB  B
02982:  MOVWF  xCA
02984:  MOVLW  0F
02986:  MOVWF  xCC
02988:  MOVLW  89
0298A:  MOVWF  xCB
0298C:  MOVLB  0
0298E:  CALL   234A
02992:  MOVFF  437,BC9
02996:  MOVLB  B
02998:  CLRF   xCA
0299A:  MOVLW  0F
0299C:  MOVWF  xCC
0299E:  MOVLW  92
029A0:  MOVWF  xCB
029A2:  MOVLB  0
029A4:  CALL   234A
....................    }
....................    return;
029A8:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
0367E:  MOVLB  B
03680:  MOVF   xAC,F
03682:  BTFSC  FD8.2
03684:  BRA    368C
03686:  MOVLB  0
03688:  GOTO   37FA
0368C:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
0368E:  MOVLW  06
03690:  MOVLB  B
03692:  MOVWF  xB7
03694:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
03696:  MOVLW  02
03698:  MOVLB  B
0369A:  MOVWF  xB8
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0369C:  MOVFF  BB1,BC4
036A0:  MOVFF  BB2,BC5
036A4:  CLRF   xC6
036A6:  CLRF   xC7
036A8:  MOVF   xC4,W
036AA:  MOVWF  00
036AC:  CLRF   01
036AE:  CLRF   02
036B0:  CLRF   03
036B2:  MOVFF  00,BB9
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
036B6:  MOVFF  BB0,BC4
036BA:  MOVFF  BB1,BC5
036BE:  MOVFF  BB2,BC6
036C2:  CLRF   xC7
036C4:  MOVF   xC4,W
036C6:  MOVWF  00
036C8:  CLRF   01
036CA:  CLRF   02
036CC:  CLRF   03
036CE:  MOVFF  00,BBA
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
036D2:  MOVF   xAF,W
036D4:  MOVWF  00
036D6:  CLRF   01
036D8:  CLRF   02
036DA:  CLRF   03
036DC:  MOVFF  00,BBB
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
036E0:  MOVFF  BAD,BC9
036E4:  CLRF   xCA
036E6:  MOVLW  0F
036E8:  MOVWF  xCC
036EA:  MOVLW  89
036EC:  MOVWF  xCB
036EE:  MOVLB  0
036F0:  CALL   234A
036F4:  MOVFF  BAD,BC9
036F8:  MOVLB  B
036FA:  CLRF   xCA
036FC:  MOVLW  0F
036FE:  MOVWF  xCC
03700:  MOVLW  92
03702:  MOVWF  xCB
03704:  MOVLB  0
03706:  CALL   234A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0370A:  MOVFF  BAE,BC6
0370E:  MOVFF  BAD,BC5
03712:  MOVFF  BAC,BC4
03716:  MOVFF  BAB,BC3
0371A:  MOVLW  0B
0371C:  MOVLB  B
0371E:  MOVWF  xC8
03720:  MOVLW  B7
03722:  MOVWF  xC7
03724:  CLRF   xCA
03726:  MOVLW  01
03728:  MOVWF  xC9
0372A:  MOVLB  0
0372C:  CALL   3372
....................       output_high(flash_stream.cs_pin);
03730:  MOVFF  BAD,BC9
03734:  MOVLW  01
03736:  MOVLB  B
03738:  MOVWF  xCA
0373A:  MOVLW  0F
0373C:  MOVWF  xCC
0373E:  MOVLW  89
03740:  MOVWF  xCB
03742:  MOVLB  0
03744:  CALL   234A
03748:  MOVFF  BAD,BC9
0374C:  MOVLB  B
0374E:  CLRF   xCA
03750:  MOVLW  0F
03752:  MOVWF  xCC
03754:  MOVLW  92
03756:  MOVWF  xCB
03758:  MOVLB  0
0375A:  CALL   234A
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
0375E:  MOVFF  BAD,BC9
03762:  MOVLB  B
03764:  CLRF   xCA
03766:  MOVLW  0F
03768:  MOVWF  xCC
0376A:  MOVLW  89
0376C:  MOVWF  xCB
0376E:  MOVLB  0
03770:  CALL   234A
03774:  MOVFF  BAD,BC9
03778:  MOVLB  B
0377A:  CLRF   xCA
0377C:  MOVLW  0F
0377E:  MOVWF  xCC
03780:  MOVLW  92
03782:  MOVWF  xCB
03784:  MOVLB  0
03786:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
0378A:  MOVFF  BAE,BC6
0378E:  MOVFF  BAD,BC5
03792:  MOVFF  BAC,BC4
03796:  MOVFF  BAB,BC3
0379A:  MOVLW  0B
0379C:  MOVLB  B
0379E:  MOVWF  xC8
037A0:  MOVLW  B8
037A2:  MOVWF  xC7
037A4:  MOVLW  04
037A6:  MOVWF  xC9
037A8:  MOVFF  BB4,BCB
037AC:  MOVFF  BB3,BCA
037B0:  MOVFF  BB6,BCD
037B4:  MOVFF  BB5,BCC
037B8:  MOVLB  0
037BA:  CALL   3462
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
037BE:  MOVLW  02
037C0:  MOVWF  00
037C2:  DECFSZ 00,F
037C4:  BRA    37C2
037C6:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
037C8:  MOVFF  BAD,BC9
037CC:  MOVLW  01
037CE:  MOVLB  B
037D0:  MOVWF  xCA
037D2:  MOVLW  0F
037D4:  MOVWF  xCC
037D6:  MOVLW  89
037D8:  MOVWF  xCB
037DA:  MOVLB  0
037DC:  CALL   234A
037E0:  MOVFF  BAD,BC9
037E4:  MOVLB  B
037E6:  CLRF   xCA
037E8:  MOVLW  0F
037EA:  MOVWF  xCC
037EC:  MOVLW  92
037EE:  MOVWF  xCB
037F0:  MOVLB  0
037F2:  CALL   234A
....................    }
037F6:  GOTO   398C
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
037FA:  MOVLB  B
037FC:  DECFSZ xAC,W
037FE:  BRA    3804
03800:  BRA    380A
03802:  MOVLB  0
03804:  MOVLB  0
03806:  GOTO   398C
0380A:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
0380C:  MOVLW  06
0380E:  MOVLB  B
03810:  MOVWF  xBC
03812:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
03814:  MOVLW  12
03816:  MOVLB  B
03818:  MOVWF  xBD
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
0381A:  MOVFF  BB2,BC4
0381E:  CLRF   xC5
03820:  CLRF   xC6
03822:  CLRF   xC7
03824:  MOVF   xC4,W
03826:  MOVWF  00
03828:  CLRF   01
0382A:  CLRF   02
0382C:  CLRF   03
0382E:  MOVFF  00,BBE
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03832:  MOVFF  BB1,BC4
03836:  MOVFF  BB2,BC5
0383A:  CLRF   xC6
0383C:  CLRF   xC7
0383E:  MOVF   xC4,W
03840:  MOVWF  00
03842:  CLRF   01
03844:  CLRF   02
03846:  CLRF   03
03848:  MOVFF  00,BBF
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0384C:  MOVFF  BB0,BC4
03850:  MOVFF  BB1,BC5
03854:  MOVFF  BB2,BC6
03858:  CLRF   xC7
0385A:  MOVF   xC4,W
0385C:  MOVWF  00
0385E:  CLRF   01
03860:  CLRF   02
03862:  CLRF   03
03864:  MOVFF  00,BC0
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
03868:  MOVF   xAF,W
0386A:  MOVWF  00
0386C:  CLRF   01
0386E:  CLRF   02
03870:  CLRF   03
03872:  MOVFF  00,BC1
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03876:  MOVFF  BAD,BC9
0387A:  CLRF   xCA
0387C:  MOVLW  0F
0387E:  MOVWF  xCC
03880:  MOVLW  89
03882:  MOVWF  xCB
03884:  MOVLB  0
03886:  CALL   234A
0388A:  MOVFF  BAD,BC9
0388E:  MOVLB  B
03890:  CLRF   xCA
03892:  MOVLW  0F
03894:  MOVWF  xCC
03896:  MOVLW  92
03898:  MOVWF  xCB
0389A:  MOVLB  0
0389C:  CALL   234A
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
038A0:  MOVFF  BAE,BC6
038A4:  MOVFF  BAD,BC5
038A8:  MOVFF  BAC,BC4
038AC:  MOVFF  BAB,BC3
038B0:  MOVLW  0B
038B2:  MOVLB  B
038B4:  MOVWF  xC8
038B6:  MOVLW  BC
038B8:  MOVWF  xC7
038BA:  CLRF   xCA
038BC:  MOVLW  01
038BE:  MOVWF  xC9
038C0:  MOVLB  0
038C2:  CALL   3372
....................       output_high(flash_stream.cs_pin);
038C6:  MOVFF  BAD,BC9
038CA:  MOVLW  01
038CC:  MOVLB  B
038CE:  MOVWF  xCA
038D0:  MOVLW  0F
038D2:  MOVWF  xCC
038D4:  MOVLW  89
038D6:  MOVWF  xCB
038D8:  MOVLB  0
038DA:  CALL   234A
038DE:  MOVFF  BAD,BC9
038E2:  MOVLB  B
038E4:  CLRF   xCA
038E6:  MOVLW  0F
038E8:  MOVWF  xCC
038EA:  MOVLW  92
038EC:  MOVWF  xCB
038EE:  MOVLB  0
038F0:  CALL   234A
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
038F4:  MOVFF  BAD,BC9
038F8:  MOVLB  B
038FA:  CLRF   xCA
038FC:  MOVLW  0F
038FE:  MOVWF  xCC
03900:  MOVLW  89
03902:  MOVWF  xCB
03904:  MOVLB  0
03906:  CALL   234A
0390A:  MOVFF  BAD,BC9
0390E:  MOVLB  B
03910:  CLRF   xCA
03912:  MOVLW  0F
03914:  MOVWF  xCC
03916:  MOVLW  92
03918:  MOVWF  xCB
0391A:  MOVLB  0
0391C:  CALL   234A
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
03920:  MOVFF  BAE,BC6
03924:  MOVFF  BAD,BC5
03928:  MOVFF  BAC,BC4
0392C:  MOVFF  BAB,BC3
03930:  MOVLW  0B
03932:  MOVLB  B
03934:  MOVWF  xC8
03936:  MOVLW  BD
03938:  MOVWF  xC7
0393A:  MOVLW  05
0393C:  MOVWF  xC9
0393E:  MOVFF  BB4,BCB
03942:  MOVFF  BB3,BCA
03946:  MOVFF  BB6,BCD
0394A:  MOVFF  BB5,BCC
0394E:  MOVLB  0
03950:  CALL   3462
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
03954:  MOVLW  02
03956:  MOVWF  00
03958:  DECFSZ 00,F
0395A:  BRA    3958
0395C:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0395E:  MOVFF  BAD,BC9
03962:  MOVLW  01
03964:  MOVLB  B
03966:  MOVWF  xCA
03968:  MOVLW  0F
0396A:  MOVWF  xCC
0396C:  MOVLW  89
0396E:  MOVWF  xCB
03970:  MOVLB  0
03972:  CALL   234A
03976:  MOVFF  BAD,BC9
0397A:  MOVLB  B
0397C:  CLRF   xCA
0397E:  MOVLW  0F
03980:  MOVWF  xCC
03982:  MOVLW  92
03984:  MOVWF  xCB
03986:  MOVLB  0
03988:  CALL   234A
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
0398C:  MOVLB  B
0398E:  CLRF   xC2
03990:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
03992:  MOVFF  BAE,BC6
03996:  MOVFF  BAD,BC5
0399A:  MOVFF  BAC,BC4
0399E:  MOVFF  BAB,BC3
039A2:  CALL   35DE
039A6:  MOVF   01,W
039A8:  ANDLW  01
039AA:  SUBLW  01
039AC:  BTFSS  FD8.2
039AE:  GOTO   3A00
....................       if(timeout_counter > 10)
039B2:  MOVLB  B
039B4:  MOVF   xC2,W
039B6:  SUBLW  0A
039B8:  BTFSS  FD8.0
039BA:  BRA    39C2
039BC:  MOVLB  0
039BE:  GOTO   39D4
039C2:  MOVLB  0
....................          delay_ms(200);
039C4:  MOVLW  C8
039C6:  MOVLB  B
039C8:  MOVWF  xC3
039CA:  MOVLB  0
039CC:  CALL   1B30
039D0:  GOTO   39E0
....................       else
....................          delay_ms(10);   
039D4:  MOVLW  0A
039D6:  MOVLB  B
039D8:  MOVWF  xC3
039DA:  MOVLB  0
039DC:  CALL   1B30
....................       
....................       if(timeout_counter > 100){
039E0:  MOVLB  B
039E2:  MOVF   xC2,W
039E4:  SUBLW  64
039E6:  BTFSS  FD8.0
039E8:  BRA    39F0
039EA:  MOVLB  0
039EC:  GOTO   39F6
039F0:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
039F2:  GOTO   3A00
....................       }  
....................       timeout_counter++;
039F6:  MOVLB  B
039F8:  INCF   xC2,F
039FA:  MOVLB  0
039FC:  GOTO   3992
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
03A00:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
026CA:  MOVLW  9F
026CC:  MOVLB  3
026CE:  MOVWF  xCB
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
026D0:  MOVFF  3B5,BC9
026D4:  MOVLB  B
026D6:  CLRF   xCA
026D8:  MOVLW  0F
026DA:  MOVWF  xCC
026DC:  MOVLW  89
026DE:  MOVWF  xCB
026E0:  MOVLB  0
026E2:  CALL   234A
026E6:  MOVFF  3B5,BC9
026EA:  MOVLB  B
026EC:  CLRF   xCA
026EE:  MOVLW  0F
026F0:  MOVWF  xCC
026F2:  MOVLW  92
026F4:  MOVWF  xCB
026F6:  MOVLB  0
026F8:  CALL   234A
....................    delay_us(10);  
026FC:  MOVLW  0D
026FE:  MOVWF  00
02700:  DECFSZ 00,F
02702:  BRA    2700
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
02704:  MOVFF  3B6,BCC
02708:  MOVFF  3B5,BCB
0270C:  MOVFF  3B4,BCA
02710:  MOVFF  3B3,BC9
02714:  MOVLW  03
02716:  MOVLB  B
02718:  MOVWF  xCE
0271A:  MOVLW  CB
0271C:  MOVWF  xCD
0271E:  CLRF   xD0
02720:  MOVLW  01
02722:  MOVWF  xCF
02724:  MOVLW  03
02726:  MOVWF  xD2
02728:  MOVLW  B7
0272A:  MOVWF  xD1
0272C:  CLRF   xD6
0272E:  CLRF   xD5
02730:  CLRF   xD4
02732:  MOVLW  14
02734:  MOVWF  xD3
02736:  MOVLB  0
02738:  CALL   2496
....................    output_high(flash_stream.cs_pin);
0273C:  MOVFF  3B5,BC9
02740:  MOVLW  01
02742:  MOVLB  B
02744:  MOVWF  xCA
02746:  MOVLW  0F
02748:  MOVWF  xCC
0274A:  MOVLW  89
0274C:  MOVWF  xCB
0274E:  MOVLB  0
02750:  CALL   234A
02754:  MOVFF  3B5,BC9
02758:  MOVLB  B
0275A:  CLRF   xCA
0275C:  MOVLW  0F
0275E:  MOVWF  xCC
02760:  MOVLW  92
02762:  MOVWF  xCB
02764:  MOVLB  0
02766:  CALL   234A
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
0276A:  MOVLB  3
0276C:  MOVF   xB7,W
0276E:  SUBLW  20
02770:  BTFSC  FD8.2
02772:  BRA    277A
02774:  MOVLB  0
02776:  GOTO   2788
0277A:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
0277C:  MOVLW  01
0277E:  MOVWF  01
02780:  GOTO   2790
....................    }
02784:  GOTO   2790
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
02788:  MOVLW  00
0278A:  MOVWF  01
0278C:  GOTO   2790
....................    }
02790:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
029AA:  MOVLB  C
029AC:  MOVF   x04,F
029AE:  BTFSC  FD8.2
029B0:  BRA    29B8
029B2:  MOVLB  0
029B4:  GOTO   29C2
029B8:  MOVLB  0
029BA:  MOVLW  00
029BC:  MOVWF  01
029BE:  GOTO   2A14
.................... 
....................    unsigned int8 crc = *frame++;
029C2:  MOVLB  C
029C4:  MOVF   x03,W
029C6:  MOVWF  03
029C8:  MOVF   x02,W
029CA:  INCF   x02,F
029CC:  BTFSC  FD8.2
029CE:  INCF   x03,F
029D0:  MOVWF  FE9
029D2:  MOVFF  03,FEA
029D6:  MOVFF  FEF,C05
029DA:  MOVLB  0
....................    while (--payload_size > 0)
029DC:  MOVLB  C
029DE:  DECF   x04,F
029E0:  MOVF   x04,F
029E2:  BTFSS  FD8.2
029E4:  BRA    29EC
029E6:  MOVLB  0
029E8:  GOTO   2A0C
029EC:  MOVLB  0
....................       crc ^= *frame++;
029EE:  MOVLB  C
029F0:  MOVF   x03,W
029F2:  MOVWF  03
029F4:  MOVF   x02,W
029F6:  INCF   x02,F
029F8:  BTFSC  FD8.2
029FA:  INCF   x03,F
029FC:  MOVWF  FE9
029FE:  MOVFF  03,FEA
02A02:  MOVF   FEF,W
02A04:  XORWF  x05,F
02A06:  MOVLB  0
02A08:  GOTO   29DC
.................... 
....................    return crc;
02A0C:  MOVLB  C
02A0E:  MOVF   x05,W
02A10:  MOVWF  01
02A12:  MOVLB  0
02A14:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
09408:  MOVLW  01
0940A:  MOVLB  4
0940C:  SUBWF  x37,W
0940E:  ADDWF  x35,W
09410:  MOVWF  FE9
09412:  MOVLW  00
09414:  ADDWFC x36,W
09416:  MOVWF  FEA
09418:  MOVFF  FEF,438
0941C:  MOVLW  01
0941E:  SUBWF  x37,W
09420:  MOVWF  x3A
09422:  MOVFF  436,C03
09426:  MOVFF  435,C02
0942A:  MOVFF  43A,C04
0942E:  MOVLB  0
09430:  CALL   29AA
09434:  MOVFF  01,439
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
09438:  MOVLB  4
0943A:  MOVF   x39,W
0943C:  SUBWF  x38,W
0943E:  BTFSS  FD8.2
09440:  BRA    9448
09442:  MOVLB  0
09444:  GOTO   9450
09448:  MOVLB  0
0944A:  MOVLW  00
0944C:  GOTO   9452
09450:  MOVLW  01
09452:  MOVWF  01
09454:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... 
.................... #include "../../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_MEASURE_DATA_START_ADDRESS 0x06AA1000
.................... #define CIGS_MEASURE_DATA_END_ADDRESS 0x07AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x07AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x07AA1FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
*
086EC:  MOVLW  01
086EE:  MOVLB  1
086F0:  ADDWF  x0D,W
086F2:  ANDLW  0F
086F4:  MOVLB  2
086F6:  MOVWF  xFF
.................... {   
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
.................... 
....................    if(next_tail == flash_queue.head_index)
086F8:  MOVLB  1
086FA:  MOVF   x0C,W
086FC:  MOVLB  2
086FE:  SUBWF  xFF,W
08700:  BTFSC  FD8.2
08702:  BRA    870A
08704:  MOVLB  0
08706:  GOTO   8720
0870A:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
0870C:  MOVLW  8A
0870E:  MOVWF  FF6
08710:  MOVLW  02
08712:  MOVWF  FF7
08714:  MOVLW  00
08716:  MOVWF  FF8
08718:  CALL   1BB0
0871C:  GOTO   8964
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
08720:  MOVLB  1
08722:  MOVF   x0D,W
08724:  MULLW  0C
08726:  MOVF   FF3,W
08728:  MOVLB  3
0872A:  CLRF   x01
0872C:  MOVWF  x00
0872E:  MOVLW  4C
08730:  ADDWF  x00,W
08732:  MOVWF  01
08734:  MOVLW  00
08736:  ADDWFC x01,W
08738:  MOVWF  03
0873A:  MOVF   01,W
0873C:  MOVWF  x02
0873E:  MOVFF  03,303
08742:  MOVLB  2
08744:  MOVF   xFD,W
08746:  MOVWF  FE9
08748:  MOVF   xFE,W
0874A:  MOVWF  FEA
0874C:  MOVF   FEF,W
0874E:  MOVLB  3
08750:  MOVWF  x04
08752:  MOVFF  303,FEA
08756:  MOVFF  302,FE9
0875A:  MOVFF  304,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
0875E:  MOVLB  1
08760:  MOVF   x0D,W
08762:  MULLW  0C
08764:  MOVF   FF3,W
08766:  MOVLB  3
08768:  CLRF   x01
0876A:  MOVWF  x00
0876C:  MOVLW  01
0876E:  ADDWF  x00,W
08770:  MOVWF  01
08772:  MOVLW  00
08774:  ADDWFC x01,W
08776:  MOVWF  03
08778:  MOVF   01,W
0877A:  ADDLW  4C
0877C:  MOVWF  01
0877E:  MOVLW  00
08780:  ADDWFC 03,F
08782:  MOVF   01,W
08784:  MOVWF  x00
08786:  MOVFF  03,301
0878A:  MOVLW  01
0878C:  MOVLB  2
0878E:  ADDWF  xFD,W
08790:  MOVWF  FE9
08792:  MOVLW  00
08794:  ADDWFC xFE,W
08796:  MOVWF  FEA
08798:  MOVF   FEF,W
0879A:  MOVLB  3
0879C:  MOVWF  x02
0879E:  MOVFF  301,FEA
087A2:  MOVFF  300,FE9
087A6:  MOVFF  302,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
087AA:  MOVLB  1
087AC:  MOVF   x0D,W
087AE:  MULLW  0C
087B0:  MOVF   FF3,W
087B2:  MOVLB  3
087B4:  CLRF   x01
087B6:  MOVWF  x00
087B8:  MOVLW  02
087BA:  ADDWF  x00,W
087BC:  MOVWF  01
087BE:  MOVLW  00
087C0:  ADDWFC x01,W
087C2:  MOVWF  03
087C4:  MOVF   01,W
087C6:  ADDLW  4C
087C8:  MOVWF  01
087CA:  MOVLW  00
087CC:  ADDWFC 03,F
087CE:  MOVF   01,W
087D0:  MOVWF  x00
087D2:  MOVFF  03,301
087D6:  MOVLW  02
087D8:  MOVLB  2
087DA:  ADDWF  xFD,W
087DC:  MOVWF  FE9
087DE:  MOVLW  00
087E0:  ADDWFC xFE,W
087E2:  MOVWF  FEA
087E4:  MOVF   FEF,W
087E6:  MOVLB  3
087E8:  MOVWF  x02
087EA:  MOVFF  301,FEA
087EE:  MOVFF  300,FE9
087F2:  MOVFF  302,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
087F6:  MOVLB  1
087F8:  MOVF   x0D,W
087FA:  MULLW  0C
087FC:  MOVF   FF3,W
087FE:  MOVLB  3
08800:  CLRF   x01
08802:  MOVWF  x00
08804:  MOVLW  03
08806:  ADDWF  x00,W
08808:  MOVWF  01
0880A:  MOVLW  00
0880C:  ADDWFC x01,W
0880E:  MOVWF  03
08810:  MOVF   01,W
08812:  ADDLW  4C
08814:  MOVWF  01
08816:  MOVLW  00
08818:  ADDWFC 03,F
0881A:  MOVF   01,W
0881C:  MOVWF  x00
0881E:  MOVFF  03,301
08822:  MOVLW  03
08824:  MOVLB  2
08826:  ADDWF  xFD,W
08828:  MOVWF  01
0882A:  MOVLW  00
0882C:  ADDWFC xFE,W
0882E:  MOVWF  03
08830:  MOVF   01,W
08832:  MOVWF  FE9
08834:  MOVFF  03,FEA
08838:  MOVLW  00
0883A:  BTFSC  FEF.0
0883C:  MOVLW  01
0883E:  MOVWF  01
08840:  BTFSS  01.0
08842:  BRA    884A
08844:  MOVLB  0
08846:  GOTO   885A
0884A:  MOVLB  0
0884C:  MOVFF  301,FEA
08850:  MOVFF  300,FE9
08854:  BCF    FEF.0
08856:  GOTO   8864
0885A:  MOVFF  301,FEA
0885E:  MOVFF  300,FE9
08862:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
08864:  MOVLB  1
08866:  MOVF   x0D,W
08868:  MULLW  0C
0886A:  MOVF   FF3,W
0886C:  MOVLB  3
0886E:  CLRF   x01
08870:  MOVWF  x00
08872:  MOVLW  04
08874:  ADDWF  x00,W
08876:  MOVWF  01
08878:  MOVLW  00
0887A:  ADDWFC x01,W
0887C:  MOVWF  03
0887E:  MOVF   01,W
08880:  ADDLW  4C
08882:  MOVWF  01
08884:  MOVLW  00
08886:  ADDWFC 03,F
08888:  MOVF   01,W
0888A:  MOVWF  x00
0888C:  MOVFF  03,301
08890:  MOVLW  04
08892:  MOVLB  2
08894:  ADDWF  xFD,W
08896:  MOVWF  FE9
08898:  MOVLW  00
0889A:  ADDWFC xFE,W
0889C:  MOVWF  FEA
0889E:  MOVFF  FEF,00
088A2:  MOVFF  FEC,01
088A6:  MOVFF  FEC,02
088AA:  MOVFF  FEC,03
088AE:  MOVF   FED,F
088B0:  MOVF   FED,F
088B2:  MOVF   FED,F
088B4:  MOVFF  03,305
088B8:  MOVFF  02,304
088BC:  MOVFF  01,303
088C0:  MOVFF  00,302
088C4:  MOVFF  301,FEA
088C8:  MOVFF  300,FE9
088CC:  MOVFF  302,FEF
088D0:  MOVFF  303,FEC
088D4:  MOVFF  304,FEC
088D8:  MOVFF  305,FEC
088DC:  MOVF   FED,F
088DE:  MOVF   FED,F
088E0:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
088E2:  MOVLB  1
088E4:  MOVF   x0D,W
088E6:  MULLW  0C
088E8:  MOVF   FF3,W
088EA:  MOVLB  3
088EC:  CLRF   x01
088EE:  MOVWF  x00
088F0:  MOVLW  08
088F2:  ADDWF  x00,W
088F4:  MOVWF  01
088F6:  MOVLW  00
088F8:  ADDWFC x01,W
088FA:  MOVWF  03
088FC:  MOVF   01,W
088FE:  ADDLW  4C
08900:  MOVWF  01
08902:  MOVLW  00
08904:  ADDWFC 03,F
08906:  MOVF   01,W
08908:  MOVWF  x00
0890A:  MOVFF  03,301
0890E:  MOVLW  08
08910:  MOVLB  2
08912:  ADDWF  xFD,W
08914:  MOVWF  FE9
08916:  MOVLW  00
08918:  ADDWFC xFE,W
0891A:  MOVWF  FEA
0891C:  MOVFF  FEF,00
08920:  MOVFF  FEC,01
08924:  MOVFF  FEC,02
08928:  MOVFF  FEC,03
0892C:  MOVF   FED,F
0892E:  MOVF   FED,F
08930:  MOVF   FED,F
08932:  MOVFF  03,305
08936:  MOVFF  02,304
0893A:  MOVFF  01,303
0893E:  MOVFF  00,302
08942:  MOVFF  301,FEA
08946:  MOVFF  300,FE9
0894A:  MOVFF  302,FEF
0894E:  MOVFF  303,FEC
08952:  MOVFF  304,FEC
08956:  MOVFF  305,FEC
0895A:  MOVF   FED,F
0895C:  MOVF   FED,F
0895E:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
08960:  MOVFF  2FF,10D
08964:  MOVLB  0
....................    }
08966:  GOTO   8D12 (RETURN)
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
0918C:  MOVLB  1
0918E:  MOVF   x0D,W
09190:  SUBWF  x0C,W
09192:  BTFSC  FD8.2
09194:  BRA    919C
09196:  MOVLB  0
09198:  GOTO   91BE
0919C:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
0919E:  MOVLW  A4
091A0:  MOVWF  FF6
091A2:  MOVLW  02
091A4:  MOVWF  FF7
091A6:  MOVLW  00
091A8:  MOVWF  FF8
091AA:  CALL   1BB0
....................       return 0x00;
091AE:  MOVLW  00
091B0:  MOVWF  01
091B2:  MOVLW  00
091B4:  MOVWF  02
091B6:  GOTO   91EC
....................    }
091BA:  GOTO   91EC
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
091BE:  MOVFF  10C,2DE
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
091C2:  MOVLW  01
091C4:  MOVLB  1
091C6:  ADDWF  x0C,W
091C8:  ANDLW  0F
091CA:  MOVWF  x0C
....................       return &flash_queue.entries[current_head];
091CC:  MOVLB  2
091CE:  MOVF   xDE,W
091D0:  MULLW  0C
091D2:  MOVF   FF3,W
091D4:  CLRF   03
091D6:  ADDLW  4C
091D8:  MOVWF  01
091DA:  MOVLW  00
091DC:  ADDWFC 03,F
091DE:  MOVF   01,W
091E0:  MOVWF  01
091E2:  MOVF   03,W
091E4:  MOVWF  02
091E6:  MOVLB  0
091E8:  GOTO   91EC
....................    }
091EC:  GOTO   AC02 (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
08F88:  MOVLB  1
08F8A:  MOVF   x0D,W
08F8C:  SUBWF  x0C,W
08F8E:  BTFSS  FD8.2
08F90:  BRA    8F98
08F92:  MOVLB  0
08F94:  GOTO   8FA0
08F98:  MOVLB  0
08F9A:  MOVLW  00
08F9C:  GOTO   8FA2
08FA0:  MOVLW  01
08FA2:  MOVWF  01
08FA4:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
091F0:  MOVLB  3
091F2:  CLRF   xBB
091F4:  CLRF   xBC
091F6:  CLRF   xBD
091F8:  CLRF   xBE
091FA:  CLRF   xBF
091FC:  CLRF   xC0
091FE:  CLRF   xC1
09200:  CLRF   xC2
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
09202:  MOVF   xBA,F
09204:  BTFSC  FD8.2
09206:  BRA    920E
09208:  MOVLB  0
0920A:  GOTO   9232
0920E:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
09210:  MOVLW  06
09212:  MOVLB  3
09214:  MOVWF  xBE
09216:  MOVLW  AA
09218:  MOVWF  xBD
0921A:  CLRF   xBC
0921C:  CLRF   xBB
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
0921E:  MOVLW  06
09220:  MOVWF  xC2
09222:  MOVLW  AA
09224:  MOVWF  xC1
09226:  MOVLW  0F
09228:  MOVWF  xC0
0922A:  SETF   xBF
0922C:  MOVLB  0
....................    }
0922E:  GOTO   9306
....................    else if (mission_id == CIGS_PICLOG_DATA)
09232:  MOVLB  3
09234:  DECFSZ xBA,W
09236:  BRA    923C
09238:  BRA    9242
0923A:  MOVLB  0
0923C:  MOVLB  0
0923E:  GOTO   9268
09242:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
09244:  MOVLW  07
09246:  MOVLB  3
09248:  MOVWF  xBE
0924A:  MOVLW  AA
0924C:  MOVWF  xBD
0924E:  MOVLW  10
09250:  MOVWF  xBC
09252:  CLRF   xBB
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
09254:  MOVLW  07
09256:  MOVWF  xC2
09258:  MOVLW  AA
0925A:  MOVWF  xC1
0925C:  MOVLW  1F
0925E:  MOVWF  xC0
09260:  SETF   xBF
09262:  MOVLB  0
....................    }
09264:  GOTO   9306
....................    else if (mission_id == CIGS_ENVIRO_DATA)
09268:  MOVLB  3
0926A:  MOVF   xBA,W
0926C:  SUBLW  02
0926E:  BTFSC  FD8.2
09270:  BRA    9278
09272:  MOVLB  0
09274:  GOTO   929E
09278:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
0927A:  MOVLW  07
0927C:  MOVLB  3
0927E:  MOVWF  xBE
09280:  MOVLW  AA
09282:  MOVWF  xBD
09284:  MOVLW  10
09286:  MOVWF  xBC
09288:  CLRF   xBB
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
0928A:  MOVLW  07
0928C:  MOVWF  xC2
0928E:  MOVLW  AA
09290:  MOVWF  xC1
09292:  MOVLW  1F
09294:  MOVWF  xC0
09296:  SETF   xBF
09298:  MOVLB  0
....................    }
0929A:  GOTO   9306
....................    else if (mission_id == CIGS_IV_HEADER)
0929E:  MOVLB  3
092A0:  MOVF   xBA,W
092A2:  SUBLW  03
092A4:  BTFSC  FD8.2
092A6:  BRA    92AE
092A8:  MOVLB  0
092AA:  GOTO   92D4
092AE:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_END_ADDRESS;
092B0:  MOVLW  07
092B2:  MOVLB  3
092B4:  MOVWF  xBE
092B6:  MOVLW  AA
092B8:  MOVWF  xBD
092BA:  MOVLW  1F
092BC:  MOVWF  xBC
092BE:  SETF   xBB
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
092C0:  MOVLW  07
092C2:  MOVWF  xC2
092C4:  MOVLW  AA
092C6:  MOVWF  xC1
092C8:  MOVLW  1F
092CA:  MOVWF  xC0
092CC:  SETF   xBF
092CE:  MOVLB  0
....................    }
092D0:  GOTO   9306
....................    else if (mission_id == CIGS_IV_DATA)
092D4:  MOVLB  3
092D6:  MOVF   xBA,W
092D8:  SUBLW  04
092DA:  BTFSC  FD8.2
092DC:  BRA    92E4
092DE:  MOVLB  0
092E0:  GOTO   9306
092E4:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_END_ADDRESS;
092E6:  MOVLW  07
092E8:  MOVLB  3
092EA:  MOVWF  xBE
092EC:  MOVLW  AA
092EE:  MOVWF  xBD
092F0:  MOVLW  1F
092F2:  MOVWF  xBC
092F4:  SETF   xBB
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
092F6:  MOVLW  07
092F8:  MOVWF  xC2
092FA:  MOVLW  AA
092FC:  MOVWF  xC1
092FE:  MOVLW  1F
09300:  MOVWF  xC0
09302:  SETF   xBF
09304:  MOVLB  0
....................    }
....................    return mis_struct;
09306:  MOVLW  BB
09308:  MOVWF  01
0930A:  MOVLW  03
0930C:  MOVWF  02
0930E:  RETURN 0
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
041BE:  MOVLB  2
041C0:  CLRF   xDF
041C2:  CLRF   xE0
041C4:  CLRF   xE1
041C6:  CLRF   xE2
041C8:  CLRF   xE3
041CA:  CLRF   xE4
041CC:  CLRF   xE5
041CE:  CLRF   xE6
041D0:  CLRF   xE7
041D2:  CLRF   xE8
041D4:  CLRF   xE9
041D6:  CLRF   xEA
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
041D8:  MOVLW  BC
041DA:  MOVWF  FF6
041DC:  MOVLW  02
041DE:  MOVWF  FF7
041E0:  MOVLW  00
041E2:  MOVWF  FF8
041E4:  MOVLB  0
041E6:  CALL   1BB0
....................    fprintf(PC, "\t[BOSS] >>> ");
041EA:  MOVLW  DC
041EC:  MOVWF  FF6
041EE:  MOVLW  02
041F0:  MOVWF  FF7
041F2:  MOVLW  00
041F4:  MOVWF  FF8
041F6:  CALL   1BB0
....................    for (int8 i = 0; i < receive_signal_size; i++)
041FA:  MOVLB  2
041FC:  CLRF   xEB
041FE:  MOVLB  0
04200:  MOVLB  2
04202:  MOVF   xDE,W
04204:  SUBWF  xEB,W
04206:  BTFSS  FD8.0
04208:  BRA    4210
0420A:  MOVLB  0
0420C:  GOTO   424A
04210:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
04212:  MOVLB  2
04214:  MOVF   xEB,W
04216:  ADDWF  xDC,W
04218:  MOVWF  FE9
0421A:  MOVLW  00
0421C:  ADDWFC xDD,W
0421E:  MOVWF  FEA
04220:  MOVFF  FEF,2F2
04224:  MOVFF  2F2,B1B
04228:  MOVLW  37
0422A:  MOVLB  B
0422C:  MOVWF  x1C
0422E:  MOVLB  0
04230:  CALL   1E34
04234:  MOVLW  20
04236:  MOVLB  B
04238:  MOVWF  x6E
0423A:  MOVLB  0
0423C:  CALL   1B5E
04240:  MOVLB  2
04242:  INCF   xEB,F
04244:  MOVLB  0
04246:  GOTO   4200
....................    fprintf(PC, "\r\n");
0424A:  MOVLW  0D
0424C:  MOVLB  B
0424E:  MOVWF  x6E
04250:  MOVLB  0
04252:  CALL   1B5E
04256:  MOVLW  0A
04258:  MOVLB  B
0425A:  MOVWF  x6E
0425C:  MOVLB  0
0425E:  CALL   1B5E
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
04262:  MOVFF  2DD,2F3
04266:  MOVFF  2DC,2F2
0426A:  MOVFF  2DE,2F4
0426E:  GOTO   3EB6
04272:  MOVFF  01,2EC
....................    if (frame_start_position == -1)
04276:  MOVLB  2
04278:  MOVF   xEC,W
0427A:  SUBLW  FF
0427C:  BTFSC  FD8.2
0427E:  BRA    4286
04280:  MOVLB  0
04282:  GOTO   4294
04286:  MOVLB  0
....................       return command;
04288:  MOVLW  DF
0428A:  MOVWF  01
0428C:  MOVLW  02
0428E:  MOVWF  02
04290:  GOTO   43B6
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
04294:  MOVLB  2
04296:  MOVF   xEC,W
04298:  ADDWF  xDC,W
0429A:  MOVWF  01
0429C:  MOVLW  00
0429E:  ADDWFC xDD,W
042A0:  MOVWF  03
042A2:  MOVF   01,W
042A4:  MOVWF  xED
042A6:  MOVFF  03,2EE
042AA:  MOVF   xED,W
042AC:  MOVWF  FE9
042AE:  MOVF   xEE,W
042B0:  MOVWF  FEA
042B2:  MOVF   FEF,W
042B4:  ANDLW  0F
042B6:  MOVWF  xEF
042B8:  MOVFF  2EF,2F2
042BC:  MOVLB  0
042BE:  GOTO   3F5E
042C2:  MOVFF  01,2F0
....................    if (content_size == -1)
042C6:  MOVLB  2
042C8:  MOVF   xF0,W
042CA:  SUBLW  FF
042CC:  BTFSC  FD8.2
042CE:  BRA    42D6
042D0:  MOVLB  0
042D2:  GOTO   42E4
042D6:  MOVLB  0
....................       return command;
042D8:  MOVLW  DF
042DA:  MOVWF  01
042DC:  MOVLW  02
042DE:  MOVWF  02
042E0:  GOTO   43B6
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
042E4:  MOVLB  2
042E6:  MOVF   xEC,W
042E8:  SUBWF  xDE,W
042EA:  MOVWF  xF1
....................    
....................    if (!check_crc(frame, receive_frame_size))
042EC:  MOVFF  2EE,2F3
042F0:  MOVFF  2ED,2F2
042F4:  MOVFF  2F1,2F4
042F8:  MOVLB  0
042FA:  GOTO   401A
042FE:  MOVF   01,F
04300:  BTFSS  FD8.2
04302:  GOTO   4312
....................       return command;
04306:  MOVLW  DF
04308:  MOVWF  01
0430A:  MOVLW  02
0430C:  MOVWF  02
0430E:  GOTO   43B6
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
04312:  MOVLB  2
04314:  MOVF   xED,W
04316:  MOVWF  FE9
04318:  MOVF   xEE,W
0431A:  MOVWF  FEA
0431C:  MOVF   FEF,W
0431E:  ANDLW  F0
04320:  MOVWF  00
04322:  SWAPF  00,W
04324:  MOVWF  xF2
04326:  MOVLW  0F
04328:  ANDWF  xF2,F
0432A:  MOVFF  2F2,2F3
0432E:  MOVLB  0
04330:  GOTO   4104
04334:  MOVF   01,F
04336:  BTFSS  FD8.2
04338:  GOTO   4348
....................       return command;
0433C:  MOVLW  DF
0433E:  MOVWF  01
04340:  MOVLW  02
04342:  MOVWF  02
04344:  GOTO   43B6
.................... 
....................    command.frame_id = frame_id;
04348:  MOVFF  2EF,2DF
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
0434C:  MOVLW  01
0434E:  MOVLB  2
04350:  ADDWF  xED,W
04352:  MOVWF  01
04354:  MOVLW  00
04356:  ADDWFC xEE,W
04358:  MOVWF  03
0435A:  MOVF   01,W
0435C:  MOVWF  xF2
0435E:  MOVFF  03,2F3
04362:  MOVLW  02
04364:  SUBWF  xF1,W
04366:  MOVWF  xF4
04368:  MOVLW  02
0436A:  MOVWF  FEA
0436C:  MOVLW  E2
0436E:  MOVWF  FE9
04370:  MOVFF  2F3,FE2
04374:  MOVFF  2F2,FE1
04378:  MOVF   xF4,W
0437A:  MOVWF  01
0437C:  BTFSS  FD8.2
0437E:  BRA    4386
04380:  MOVLB  0
04382:  GOTO   4392
04386:  MOVLB  0
04388:  MOVFF  FE6,FEE
0438C:  DECFSZ 01,F
0438E:  GOTO   4388
....................    command.size = receive_frame_size-2;
04392:  MOVLW  02
04394:  MOVLB  2
04396:  SUBWF  xF1,W
04398:  MOVWF  xE0
....................    command.is_exist = TRUE;
0439A:  BSF    xE1.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
0439C:  MOVLW  EA
0439E:  MOVWF  FF6
043A0:  MOVLW  02
043A2:  MOVWF  FF7
043A4:  MOVLW  00
043A6:  MOVWF  FF8
043A8:  MOVLB  0
043AA:  CALL   1BB0
....................    return command;
043AE:  MOVLW  DF
043B0:  MOVWF  01
043B2:  MOVLW  02
043B4:  MOVWF  02
043B6:  GOTO   B4C0 (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
03EB6:  MOVLB  2
03EB8:  CLRF   xF5
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
03EBA:  CLRF   xF5
03EBC:  MOVLB  0
03EBE:  MOVLW  01
03EC0:  MOVLB  2
03EC2:  SUBWF  xF4,W
03EC4:  SUBWF  xF5,W
03EC6:  BTFSS  FD8.0
03EC8:  BRA    3ED0
03ECA:  MOVLB  0
03ECC:  GOTO   3F08
03ED0:  MOVLB  0
....................       if(receive_signal[i] == SFD)
03ED2:  MOVLB  2
03ED4:  MOVF   xF5,W
03ED6:  ADDWF  xF2,W
03ED8:  MOVWF  FE9
03EDA:  MOVLW  00
03EDC:  ADDWFC xF3,W
03EDE:  MOVWF  FEA
03EE0:  MOVF   FEF,W
03EE2:  SUBLW  AA
03EE4:  BTFSC  FD8.2
03EE6:  BRA    3EEE
03EE8:  MOVLB  0
03EEA:  GOTO   3EFE
03EEE:  MOVLB  0
....................          return i+1;
03EF0:  MOVLW  01
03EF2:  MOVLB  2
03EF4:  ADDWF  xF5,W
03EF6:  MOVWF  01
03EF8:  MOVLB  0
03EFA:  GOTO   3F5A
03EFE:  MOVLB  2
03F00:  INCF   xF5,F
03F02:  MOVLB  0
03F04:  GOTO   3EBE
....................    if (receive_signal[i] == SFD)
03F08:  MOVLB  2
03F0A:  MOVF   xF5,W
03F0C:  ADDWF  xF2,W
03F0E:  MOVWF  FE9
03F10:  MOVLW  00
03F12:  ADDWFC xF3,W
03F14:  MOVWF  FEA
03F16:  MOVF   FEF,W
03F18:  SUBLW  AA
03F1A:  BTFSC  FD8.2
03F1C:  BRA    3F24
03F1E:  MOVLB  0
03F20:  GOTO   3F42
03F24:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
03F26:  MOVLW  06
03F28:  MOVWF  FF6
03F2A:  MOVLW  03
03F2C:  MOVWF  FF7
03F2E:  MOVLW  00
03F30:  MOVWF  FF8
03F32:  CALL   1BB0
....................       return -1;
03F36:  MOVLW  FF
03F38:  MOVWF  01
03F3A:  GOTO   3F5A
....................    }
03F3E:  GOTO   3F5A
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
03F42:  MOVLW  1C
03F44:  MOVWF  FF6
03F46:  MOVLW  03
03F48:  MOVWF  FF7
03F4A:  MOVLW  00
03F4C:  MOVWF  FF8
03F4E:  CALL   1BB0
....................       return -1;
03F52:  MOVLW  FF
03F54:  MOVWF  01
03F56:  GOTO   3F5A
....................    }
03F5A:  GOTO   4272 (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
03F5E:  MOVLB  2
03F60:  CLRF   xF3
03F62:  MOVLB  0
03F64:  MOVLB  2
03F66:  MOVF   xF3,W
03F68:  SUBLW  02
03F6A:  BTFSC  FD8.0
03F6C:  BRA    3F74
03F6E:  MOVLB  0
03F70:  GOTO   3FD2
03F74:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
03F76:  BCF    FD8.0
03F78:  MOVLB  2
03F7A:  RLCF   xF3,W
03F7C:  CLRF   xF5
03F7E:  MOVWF  xF4
03F80:  MOVLW  66
03F82:  ADDWF  xF4,W
03F84:  MOVWF  FE9
03F86:  MOVLW  02
03F88:  ADDWFC xF5,W
03F8A:  MOVWF  FEA
03F8C:  MOVF   FEF,W
03F8E:  SUBWF  xF2,W
03F90:  BTFSC  FD8.2
03F92:  BRA    3F9A
03F94:  MOVLB  0
03F96:  GOTO   3FC8
03F9A:  MOVLB  0
....................          return frame_ids[i].length;
03F9C:  BCF    FD8.0
03F9E:  MOVLB  2
03FA0:  RLCF   xF3,W
03FA2:  CLRF   xF5
03FA4:  MOVWF  xF4
03FA6:  MOVLW  01
03FA8:  ADDWF  xF4,W
03FAA:  MOVWF  01
03FAC:  MOVLW  00
03FAE:  ADDWFC xF5,W
03FB0:  MOVWF  03
03FB2:  MOVF   01,W
03FB4:  ADDLW  66
03FB6:  MOVWF  FE9
03FB8:  MOVLW  02
03FBA:  ADDWFC 03,W
03FBC:  MOVWF  FEA
03FBE:  MOVF   FEF,W
03FC0:  MOVWF  01
03FC2:  MOVLB  0
03FC4:  GOTO   4016
03FC8:  MOVLB  2
03FCA:  INCF   xF3,F
03FCC:  MOVLB  0
03FCE:  GOTO   3F64
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
03FD2:  MOVLW  2E
03FD4:  MOVWF  FF6
03FD6:  MOVLW  03
03FD8:  MOVWF  FF7
03FDA:  MOVLW  00
03FDC:  MOVWF  FF8
03FDE:  MOVLW  1F
03FE0:  MOVLB  B
03FE2:  MOVWF  x1B
03FE4:  MOVLB  0
03FE6:  CALL   1BE0
03FEA:  MOVFF  2F2,B1B
03FEE:  MOVLW  37
03FF0:  MOVLB  B
03FF2:  MOVWF  x1C
03FF4:  MOVLB  0
03FF6:  CALL   1E34
03FFA:  MOVLW  0D
03FFC:  MOVLB  B
03FFE:  MOVWF  x6E
04000:  MOVLB  0
04002:  CALL   1B5E
04006:  MOVLW  0A
04008:  MOVLB  B
0400A:  MOVWF  x6E
0400C:  MOVLB  0
0400E:  CALL   1B5E
....................    return -1;
04012:  MOVLW  FF
04014:  MOVWF  01
04016:  GOTO   42C2 (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
0401A:  MOVLW  01
0401C:  MOVLB  2
0401E:  SUBWF  xF4,W
04020:  ADDWF  xF2,W
04022:  MOVWF  FE9
04024:  MOVLW  00
04026:  ADDWFC xF3,W
04028:  MOVWF  FEA
0402A:  MOVFF  FEF,2F5
0402E:  MOVLW  01
04030:  SUBWF  xF4,W
04032:  MOVWF  xF7
04034:  MOVFF  2F3,C03
04038:  MOVFF  2F2,C02
0403C:  MOVFF  2F7,C04
04040:  MOVLB  0
04042:  CALL   29AA
04046:  MOVFF  01,2F6
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
0404A:  MOVLB  2
0404C:  MOVF   xF6,W
0404E:  SUBWF  xF5,W
04050:  BTFSC  FD8.2
04052:  BRA    405A
04054:  MOVLB  0
04056:  GOTO   4068
0405A:  MOVLB  0
....................       return TRUE;
0405C:  MOVLW  01
0405E:  MOVWF  01
04060:  GOTO   4100
04064:  GOTO   4100
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
04068:  MOVLW  52
0406A:  MOVWF  FF6
0406C:  MOVLW  03
0406E:  MOVWF  FF7
04070:  MOVLW  00
04072:  MOVWF  FF8
04074:  CALL   1BB0
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
04078:  MOVLW  64
0407A:  MOVWF  FF6
0407C:  MOVLW  03
0407E:  MOVWF  FF7
04080:  MOVLW  00
04082:  MOVWF  FF8
04084:  MOVLW  13
04086:  MOVLB  B
04088:  MOVWF  x1B
0408A:  MOVLB  0
0408C:  CALL   1BE0
04090:  MOVFF  2F5,B1B
04094:  MOVLW  37
04096:  MOVLB  B
04098:  MOVWF  x1C
0409A:  MOVLB  0
0409C:  CALL   1E34
040A0:  MOVLW  0D
040A2:  MOVLB  B
040A4:  MOVWF  x6E
040A6:  MOVLB  0
040A8:  CALL   1B5E
040AC:  MOVLW  0A
040AE:  MOVLB  B
040B0:  MOVWF  x6E
040B2:  MOVLB  0
040B4:  CALL   1B5E
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
040B8:  MOVLW  7C
040BA:  MOVWF  FF6
040BC:  MOVLW  03
040BE:  MOVWF  FF7
040C0:  MOVLW  00
040C2:  MOVWF  FF8
040C4:  MOVLW  13
040C6:  MOVLB  B
040C8:  MOVWF  x1B
040CA:  MOVLB  0
040CC:  CALL   1BE0
040D0:  MOVFF  2F6,B1B
040D4:  MOVLW  37
040D6:  MOVLB  B
040D8:  MOVWF  x1C
040DA:  MOVLB  0
040DC:  CALL   1E34
040E0:  MOVLW  0D
040E2:  MOVLB  B
040E4:  MOVWF  x6E
040E6:  MOVLB  0
040E8:  CALL   1B5E
040EC:  MOVLW  0A
040EE:  MOVLB  B
040F0:  MOVWF  x6E
040F2:  MOVLB  0
040F4:  CALL   1B5E
....................       return FALSE;
040F8:  MOVLW  00
040FA:  MOVWF  01
040FC:  GOTO   4100
....................    }
04100:  GOTO   42FE (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
04104:  MOVLB  2
04106:  MOVF   xF3,W
04108:  SUBLW  0C
0410A:  BTFSC  FD8.2
0410C:  BRA    4114
0410E:  MOVLB  0
04110:  GOTO   4122
04114:  MOVLB  0
....................       return TRUE;
04116:  MOVLW  01
04118:  MOVWF  01
0411A:  GOTO   41BA
0411E:  GOTO   41BA
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
04122:  MOVLW  94
04124:  MOVWF  FF6
04126:  MOVLW  03
04128:  MOVWF  FF7
0412A:  MOVLW  00
0412C:  MOVWF  FF8
0412E:  CALL   1BB0
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
04132:  MOVLW  B6
04134:  MOVWF  FF6
04136:  MOVLW  03
04138:  MOVWF  FF7
0413A:  MOVLW  00
0413C:  MOVWF  FF8
0413E:  MOVLW  13
04140:  MOVLB  B
04142:  MOVWF  x1B
04144:  MOVLB  0
04146:  CALL   1BE0
0414A:  MOVFF  2F3,B1B
0414E:  MOVLW  37
04150:  MOVLB  B
04152:  MOVWF  x1C
04154:  MOVLB  0
04156:  CALL   1E34
0415A:  MOVLW  0D
0415C:  MOVLB  B
0415E:  MOVWF  x6E
04160:  MOVLB  0
04162:  CALL   1B5E
04166:  MOVLW  0A
04168:  MOVLB  B
0416A:  MOVWF  x6E
0416C:  MOVLB  0
0416E:  CALL   1B5E
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
04172:  MOVLW  CE
04174:  MOVWF  FF6
04176:  MOVLW  03
04178:  MOVWF  FF7
0417A:  MOVLW  00
0417C:  MOVWF  FF8
0417E:  MOVLW  13
04180:  MOVLB  B
04182:  MOVWF  x1B
04184:  MOVLB  0
04186:  CALL   1BE0
0418A:  MOVLW  0C
0418C:  MOVLB  B
0418E:  MOVWF  x1B
04190:  MOVLW  37
04192:  MOVWF  x1C
04194:  MOVLB  0
04196:  CALL   1E34
0419A:  MOVLW  0D
0419C:  MOVLB  B
0419E:  MOVWF  x6E
041A0:  MOVLB  0
041A2:  CALL   1B5E
041A6:  MOVLW  0A
041A8:  MOVLB  B
041AA:  MOVWF  x6E
041AC:  MOVLB  0
041AE:  CALL   1B5E
....................       return FALSE;  
041B2:  MOVLW  00
041B4:  MOVWF  01
041B6:  GOTO   41BA
....................    }
041BA:  GOTO   4334 (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
044C0:  MOVLW  AA
044C2:  MOVLB  2
044C4:  MOVWF  xE2
....................    data[1] = (BOSS_PIC << 4) | frame_id;
044C6:  MOVF   xDE,W
044C8:  IORLW  50
044CA:  MOVWF  xE3
....................    memcpy(&data[2], content, size);
044CC:  MOVLW  02
044CE:  MOVWF  FEA
044D0:  MOVLW  E4
044D2:  MOVWF  FE9
044D4:  MOVFF  2E0,FE2
044D8:  MOVFF  2DF,FE1
044DC:  MOVF   xE1,W
044DE:  MOVWF  01
044E0:  BTFSS  FD8.2
044E2:  BRA    44EA
044E4:  MOVLB  0
044E6:  GOTO   44F6
044EA:  MOVLB  0
044EC:  MOVFF  FE6,FEE
044F0:  DECFSZ 01,F
044F2:  GOTO   44EC
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
044F6:  MOVLW  02
044F8:  MOVLB  2
044FA:  ADDWF  xE1,W
044FC:  MOVWF  xF2
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
044FE:  CLRF   03
04500:  MOVF   xF2,W
04502:  ADDLW  E2
04504:  MOVWF  01
04506:  MOVLW  02
04508:  ADDWFC 03,F
0450A:  MOVF   01,W
0450C:  MOVWF  xF4
0450E:  MOVFF  03,2F5
04512:  MOVLW  01
04514:  SUBWF  xF2,W
04516:  MOVWF  xF6
04518:  MOVLW  02
0451A:  MOVLB  C
0451C:  MOVWF  x03
0451E:  MOVLW  E3
04520:  MOVWF  x02
04522:  MOVFF  2F6,C04
04526:  MOVLB  0
04528:  CALL   29AA
0452C:  MOVFF  2F5,FEA
04530:  MOVFF  2F4,FE9
04534:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
04538:  MOVLW  01
0453A:  MOVLB  2
0453C:  ADDWF  xF2,W
0453E:  MOVWF  xF3
....................    
....................    transmit(data, data_size);
04540:  MOVLW  02
04542:  MOVWF  xF5
04544:  MOVLW  E2
04546:  MOVWF  xF4
04548:  MOVFF  2F3,2F6
0454C:  MOVLB  0
0454E:  GOTO   4408
04552:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
04408:  MOVLB  2
0440A:  CLRF   xF7
0440C:  MOVLB  0
0440E:  MOVLB  2
04410:  MOVF   xF6,W
04412:  SUBWF  xF7,W
04414:  BTFSS  FD8.0
04416:  BRA    441E
04418:  MOVLB  0
0441A:  GOTO   4444
0441E:  MOVLB  0
....................       fputc(data[i], BOSS);
04420:  MOVLB  2
04422:  MOVF   xF7,W
04424:  ADDWF  xF4,W
04426:  MOVWF  FE9
04428:  MOVLW  00
0442A:  ADDWFC xF5,W
0442C:  MOVWF  FEA
0442E:  MOVFF  FEF,2F9
04432:  MOVF   xF9,W
04434:  MOVLB  0
04436:  GOTO   43F8
0443A:  MOVLB  2
0443C:  INCF   xF7,F
0443E:  MOVLB  0
04440:  GOTO   440E
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
04444:  MOVLW  E6
04446:  MOVWF  FF6
04448:  MOVLW  03
0444A:  MOVWF  FF7
0444C:  MOVLW  00
0444E:  MOVWF  FF8
04450:  CALL   1BB0
....................    for(int i = 0; i < data_size; i++)
04454:  MOVLB  2
04456:  CLRF   xF8
04458:  MOVLB  0
0445A:  MOVLB  2
0445C:  MOVF   xF6,W
0445E:  SUBWF  xF8,W
04460:  BTFSS  FD8.0
04462:  BRA    446A
04464:  MOVLB  0
04466:  GOTO   44A4
0446A:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
0446C:  MOVLB  2
0446E:  MOVF   xF8,W
04470:  ADDWF  xF4,W
04472:  MOVWF  FE9
04474:  MOVLW  00
04476:  ADDWFC xF5,W
04478:  MOVWF  FEA
0447A:  MOVFF  FEF,2F9
0447E:  MOVFF  2F9,B1B
04482:  MOVLW  37
04484:  MOVLB  B
04486:  MOVWF  x1C
04488:  MOVLB  0
0448A:  CALL   1E34
0448E:  MOVLW  20
04490:  MOVLB  B
04492:  MOVWF  x6E
04494:  MOVLB  0
04496:  CALL   1B5E
0449A:  MOVLB  2
0449C:  INCF   xF8,F
0449E:  MOVLB  0
044A0:  GOTO   445A
....................    fprintf(PC, "\r\n");
044A4:  MOVLW  0D
044A6:  MOVLB  B
044A8:  MOVWF  x6E
044AA:  MOVLB  0
044AC:  CALL   1B5E
044B0:  MOVLW  0A
044B2:  MOVLB  B
044B4:  MOVWF  x6E
044B6:  MOVLB  0
044B8:  CALL   1B5E
044BC:  GOTO   4552 (RETURN)
.................... }
.................... 
.................... #include "../../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
04554:  MOVLW  0F
04556:  MOVLB  2
04558:  MOVWF  xDE
0455A:  CLRF   xE0
0455C:  CLRF   xDF
0455E:  CLRF   xE1
04560:  MOVLB  0
04562:  CALL   44C0
04566:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
0900E:  MOVLW  03
09010:  MOVLB  2
09012:  MOVWF  xDE
09014:  CLRF   xE0
09016:  MOVLW  48
09018:  MOVWF  xDF
0901A:  MOVLW  04
0901C:  MOVWF  xE1
0901E:  MOVLB  0
09020:  CALL   44C0
09024:  GOTO   904C (RETURN)
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "../core/measurement/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../storage/mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
01C16:  MOVLW  FA
01C18:  MOVWF  FF6
01C1A:  MOVLW  04
01C1C:  MOVWF  FF7
01C1E:  MOVLW  00
01C20:  MOVWF  FF8
01C22:  CALL   1BB0
....................     // output_high(ADC_CS); // ADC Chip Select
....................     output_high(MIS_FM_CS); // DAC Chip Select
01C26:  MOVLW  DB
01C28:  MOVWF  F92
01C2A:  BSF    F89.5
....................     output_high(SMF_CS); // SMF Chip Select
01C2C:  MOVLW  DB
01C2E:  MOVWF  F92
01C30:  BSF    F89.2
....................     output_low(CONNECT_CIGS1);
01C32:  MOVLW  5E
01C34:  MOVWF  F94
01C36:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
01C38:  MOVLW  5E
01C3A:  MOVWF  F94
01C3C:  BCF    F8B.5
....................     output_high(EN_NPWR);
01C3E:  MOVLW  5E
01C40:  MOVWF  F94
01C42:  BSF    F8B.7
....................     delay_ms(1);
01C44:  MOVLW  01
01C46:  MOVLB  B
01C48:  MOVWF  xC3
01C4A:  MOVLB  0
01C4C:  CALL   1B30
....................     fprintf(PC, "\tComplete\r\n");
01C50:  MOVLW  0A
01C52:  MOVWF  FF6
01C54:  MOVLW  05
01C56:  MOVWF  FF7
01C58:  MOVLW  00
01C5A:  MOVWF  FF8
01C5C:  CALL   1BB0
01C60:  GOTO   B44C (RETURN)
.................... }
.................... 
.................... 
.................... void test_sweep(unsigned int8 sweep_step)
.................... {
....................     fprintf(PC, "Start TEST SWEEP\r\n");
....................     output_high(CONNECT_CIGS1);
....................     output_low(EN_NPWR); // Enable power to CIGS
....................     delay_us(100); // wait for the CIGS to stabilize
....................     fprintf(PC, "step, voltage, current\r\n");
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     delay_ms(100); // wait for the DAC to stabilize
.................... 
.................... 
....................     unsigned int16 volt;
....................     unsigned int16 curr;
....................     for (unsigned int8 count = 0; count < sweep_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
.................... 
....................         volt = ad7490_read(ADC_CIGS1_AMP); // read CIGS voltage
....................         curr = ad7490_read(ADC_CIGS1_CURR); // read CIGS current
....................         
....................         fprintf(PC, "%u, %lu, %lu\r\n", count, volt, curr);
....................         delay_ms(1); // wait for the ADC to stabilize
....................     }
.................... }
.................... 
.................... void test_adc()
.................... {
....................     unsigned int16 ans;
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     fprintf(PC, "Start ADC TEST\r\n");
....................     ans = ad7490_read(ADC_CIGS1_VOLT);
....................     fprintf(PC, "ADC Voltage: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_CURR);
....................     fprintf(PC, "ADC Current: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_AMP);
....................     fprintf(PC, "ADC CIGS1 Amp: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_VREF);
....................     fprintf(PC, "ADC CIGS1 VREF: %04LX\r\n", ans);
.................... }
.................... 
.................... void sweep_2ports(unsigned int8 measurement_step)
.................... { 
....................     fprintf(PC, "Start SWEEP 2ports\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1 and CIGS2
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
....................     unsigned int16 cigs2_buffer[2][0xFF];
.................... 
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_VOLT);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP 2port\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... 
.................... 
.................... /*
.................... void add_smf_queue_data()
.................... {
....................     SmfDataStruct smf_data;
....................     smf_data.type = SMF_DATA_TYPE_CIGS;
....................     smf_data.length = PACKET_SIZE;
....................     memcpy(smf_data.data, packetdata, PACKET_SIZE);
....................     enqueue_smf_data(&smf_data);
.................... }
.................... */
.................... void add_smf_queue_piclog()
.................... {}
.................... 
.................... void convert_datas(MEASUREMENT_DATA measured_data, )
.................... {
....................     
.................... }
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, "Start SWEEP with threshold\r\n");
*
07138:  MOVLW  0C
0713A:  MOVWF  FF6
0713C:  MOVLW  06
0713E:  MOVWF  FF7
07140:  MOVLW  00
07142:  MOVWF  FF8
07144:  CALL   1BB0
....................    
....................     // Enable both CIGS ports
....................     output_high(CONNECT_CIGS1);
07148:  MOVLW  5E
0714A:  MOVWF  F94
0714C:  BSF    F8B.0
....................     output_high(CONNECT_CIGS2);
0714E:  MOVLW  5E
07150:  MOVWF  F94
07152:  BSF    F8B.5
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     SWEEP_CONFIG port1 = {0};
07154:  MOVLB  3
07156:  CLRF   x03
07158:  CLRF   x04
0715A:  CLRF   x05
0715C:  CLRF   x06
0715E:  CLRF   x07
07160:  CLRF   x08
07162:  CLRF   x09
07164:  CLRF   x0A
07166:  CLRF   x0B
07168:  CLRF   x0C
0716A:  CLRF   x0D
0716C:  CLRF   x0E
0716E:  CLRF   x0F
07170:  CLRF   x10
07172:  CLRF   x11
07174:  CLRF   x12
07176:  CLRF   x13
07178:  CLRF   x14
0717A:  CLRF   x15
0717C:  CLRF   x16
0717E:  CLRF   x17
07180:  CLRF   x18
07182:  CLRF   x19
07184:  CLRF   x1A
07186:  CLRF   x1B
07188:  CLRF   x1C
0718A:  CLRF   x1D
0718C:  CLRF   x1E
0718E:  CLRF   x1F
07190:  CLRF   x20
07192:  CLRF   x21
07194:  CLRF   x22
07196:  CLRF   x23
07198:  CLRF   x24
0719A:  CLRF   x25
0719C:  CLRF   x26
0719E:  CLRF   x27
071A0:  CLRF   x28
071A2:  CLRF   x29
071A4:  CLRF   x2A
071A6:  CLRF   x2B
071A8:  CLRF   x2C
071AA:  CLRF   x2D
071AC:  CLRF   x2E
071AE:  CLRF   x2F
071B0:  CLRF   x30
071B2:  CLRF   x31
071B4:  CLRF   x32
071B6:  CLRF   x33
071B8:  CLRF   x34
071BA:  CLRF   x35
071BC:  CLRF   x36
071BE:  CLRF   x37
071C0:  CLRF   x38
071C2:  CLRF   x39
071C4:  CLRF   x3A
071C6:  CLRF   x3B
071C8:  CLRF   x3C
071CA:  CLRF   x3D
071CC:  CLRF   x3E
071CE:  CLRF   x3F
071D0:  CLRF   x40
071D2:  CLRF   x41
071D4:  CLRF   x42
071D6:  CLRF   x43
071D8:  CLRF   x44
071DA:  CLRF   x45
071DC:  CLRF   x46
071DE:  CLRF   x47
071E0:  CLRF   x48
071E2:  CLRF   x49
071E4:  CLRF   x4A
071E6:  CLRF   x4B
071E8:  CLRF   x4C
071EA:  CLRF   x4D
071EC:  CLRF   x4E
071EE:  CLRF   x4F
071F0:  CLRF   x50
071F2:  CLRF   x51
071F4:  CLRF   x52
071F6:  CLRF   x53
071F8:  CLRF   x54
071FA:  CLRF   x55
071FC:  CLRF   x56
071FE:  CLRF   x57
07200:  CLRF   x58
07202:  CLRF   x59
07204:  CLRF   x5A
07206:  CLRF   x5B
07208:  CLRF   x5C
0720A:  CLRF   x5D
0720C:  CLRF   x5E
0720E:  CLRF   x5F
07210:  CLRF   x60
07212:  CLRF   x61
07214:  CLRF   x62
07216:  CLRF   x63
07218:  CLRF   x64
0721A:  CLRF   x65
0721C:  CLRF   x66
0721E:  CLRF   x67
07220:  CLRF   x68
07222:  CLRF   x69
07224:  CLRF   x6A
07226:  CLRF   x6B
07228:  CLRF   x6C
0722A:  CLRF   x6D
0722C:  CLRF   x6E
0722E:  CLRF   x6F
07230:  CLRF   x70
07232:  CLRF   x71
07234:  CLRF   x72
07236:  CLRF   x73
07238:  CLRF   x74
0723A:  CLRF   x75
0723C:  CLRF   x76
0723E:  CLRF   x77
07240:  CLRF   x78
07242:  CLRF   x79
07244:  CLRF   x7A
07246:  CLRF   x7B
07248:  CLRF   x7C
0724A:  CLRF   x7D
0724C:  CLRF   x7E
0724E:  CLRF   x7F
07250:  CLRF   x80
07252:  CLRF   x81
07254:  CLRF   x82
07256:  CLRF   x83
07258:  CLRF   x84
0725A:  CLRF   x85
0725C:  CLRF   x86
0725E:  CLRF   x87
07260:  CLRF   x88
07262:  CLRF   x89
07264:  CLRF   x8A
07266:  CLRF   x8B
07268:  CLRF   x8C
0726A:  CLRF   x8D
0726C:  CLRF   x8E
0726E:  CLRF   x8F
07270:  CLRF   x90
07272:  CLRF   x91
07274:  CLRF   x92
07276:  CLRF   x93
07278:  CLRF   x94
0727A:  CLRF   x95
0727C:  CLRF   x96
0727E:  CLRF   x97
07280:  CLRF   x98
07282:  CLRF   x99
07284:  CLRF   x9A
07286:  CLRF   x9B
07288:  CLRF   x9C
0728A:  CLRF   x9D
0728C:  CLRF   x9E
0728E:  CLRF   x9F
07290:  CLRF   xA0
07292:  CLRF   xA1
07294:  CLRF   xA2
07296:  CLRF   xA3
07298:  CLRF   xA4
0729A:  CLRF   xA5
0729C:  CLRF   xA6
0729E:  CLRF   xA7
072A0:  CLRF   xA8
072A2:  CLRF   xA9
072A4:  CLRF   xAA
072A6:  CLRF   xAB
072A8:  CLRF   xAC
072AA:  CLRF   xAD
072AC:  CLRF   xAE
072AE:  CLRF   xAF
072B0:  CLRF   xB0
072B2:  CLRF   xB1
072B4:  CLRF   xB2
072B6:  CLRF   xB3
072B8:  CLRF   xB4
072BA:  CLRF   xB5
072BC:  CLRF   xB6
072BE:  CLRF   xB7
072C0:  CLRF   xB8
072C2:  CLRF   xB9
072C4:  CLRF   xBA
072C6:  CLRF   xBB
072C8:  CLRF   xBC
072CA:  CLRF   xBD
072CC:  CLRF   xBE
072CE:  CLRF   xBF
072D0:  CLRF   xC0
072D2:  CLRF   xC1
072D4:  CLRF   xC2
072D6:  CLRF   xC3
072D8:  CLRF   xC4
072DA:  CLRF   xC5
072DC:  CLRF   xC6
072DE:  CLRF   xC7
072E0:  CLRF   xC8
072E2:  CLRF   xC9
072E4:  CLRF   xCA
072E6:  CLRF   xCB
072E8:  CLRF   xCC
072EA:  CLRF   xCD
072EC:  CLRF   xCE
072EE:  CLRF   xCF
072F0:  CLRF   xD0
072F2:  CLRF   xD1
072F4:  CLRF   xD2
072F6:  CLRF   xD3
072F8:  CLRF   xD4
072FA:  CLRF   xD5
072FC:  CLRF   xD6
072FE:  CLRF   xD7
07300:  CLRF   xD8
07302:  CLRF   xD9
07304:  CLRF   xDA
07306:  CLRF   xDB
07308:  CLRF   xDC
0730A:  CLRF   xDD
0730C:  CLRF   xDE
0730E:  CLRF   xDF
07310:  CLRF   xE0
07312:  CLRF   xE1
07314:  CLRF   xE2
07316:  CLRF   xE3
07318:  CLRF   xE4
0731A:  CLRF   xE5
0731C:  CLRF   xE6
0731E:  CLRF   xE7
07320:  CLRF   xE8
07322:  CLRF   xE9
07324:  CLRF   xEA
07326:  CLRF   xEB
07328:  CLRF   xEC
0732A:  CLRF   xED
0732C:  CLRF   xEE
0732E:  CLRF   xEF
07330:  CLRF   xF0
07332:  CLRF   xF1
07334:  CLRF   xF2
07336:  CLRF   xF3
07338:  CLRF   xF4
0733A:  CLRF   xF5
0733C:  CLRF   xF6
0733E:  CLRF   xF7
07340:  CLRF   xF8
07342:  CLRF   xF9
07344:  CLRF   xFA
07346:  CLRF   xFB
07348:  CLRF   xFC
0734A:  CLRF   xFD
0734C:  CLRF   xFE
0734E:  CLRF   xFF
07350:  MOVLB  4
07352:  CLRF   x00
07354:  CLRF   x01
07356:  CLRF   x02
07358:  CLRF   x03
0735A:  CLRF   x04
0735C:  CLRF   x05
0735E:  CLRF   x06
07360:  CLRF   x07
07362:  CLRF   x08
07364:  CLRF   x09
07366:  CLRF   x0A
07368:  CLRF   x0B
0736A:  CLRF   x0C
0736C:  CLRF   x0D
0736E:  CLRF   x0E
07370:  CLRF   x0F
07372:  CLRF   x10
07374:  CLRF   x11
07376:  CLRF   x12
07378:  CLRF   x13
0737A:  CLRF   x14
0737C:  CLRF   x15
0737E:  CLRF   x16
07380:  CLRF   x17
07382:  CLRF   x18
07384:  CLRF   x19
07386:  CLRF   x1A
07388:  CLRF   x1B
0738A:  CLRF   x1C
0738C:  CLRF   x1D
0738E:  CLRF   x1E
07390:  CLRF   x1F
07392:  CLRF   x20
07394:  CLRF   x21
07396:  CLRF   x22
07398:  CLRF   x23
0739A:  CLRF   x24
0739C:  CLRF   x25
0739E:  CLRF   x26
073A0:  CLRF   x27
073A2:  CLRF   x28
073A4:  CLRF   x29
073A6:  CLRF   x2A
073A8:  CLRF   x2B
073AA:  CLRF   x2C
073AC:  CLRF   x2D
073AE:  CLRF   x2E
073B0:  CLRF   x2F
073B2:  CLRF   x30
073B4:  CLRF   x31
073B6:  CLRF   x32
073B8:  CLRF   x33
073BA:  CLRF   x34
073BC:  CLRF   x35
073BE:  CLRF   x36
073C0:  CLRF   x37
073C2:  CLRF   x38
073C4:  CLRF   x39
073C6:  CLRF   x3A
073C8:  CLRF   x3B
073CA:  CLRF   x3C
073CC:  CLRF   x3D
073CE:  CLRF   x3E
073D0:  CLRF   x3F
073D2:  CLRF   x40
073D4:  CLRF   x41
073D6:  CLRF   x42
073D8:  CLRF   x43
073DA:  CLRF   x44
073DC:  CLRF   x45
073DE:  CLRF   x46
073E0:  CLRF   x47
073E2:  CLRF   x48
073E4:  CLRF   x49
073E6:  CLRF   x4A
073E8:  CLRF   x4B
073EA:  CLRF   x4C
073EC:  CLRF   x4D
073EE:  CLRF   x4E
073F0:  CLRF   x4F
073F2:  CLRF   x50
073F4:  CLRF   x51
073F6:  CLRF   x52
073F8:  CLRF   x53
073FA:  CLRF   x54
073FC:  CLRF   x55
073FE:  CLRF   x56
07400:  CLRF   x57
07402:  CLRF   x58
07404:  CLRF   x59
07406:  CLRF   x5A
07408:  CLRF   x5B
0740A:  CLRF   x5C
0740C:  CLRF   x5D
0740E:  CLRF   x5E
07410:  CLRF   x5F
07412:  CLRF   x60
07414:  CLRF   x61
07416:  CLRF   x62
07418:  CLRF   x63
0741A:  CLRF   x64
0741C:  CLRF   x65
0741E:  CLRF   x66
07420:  CLRF   x67
07422:  CLRF   x68
07424:  CLRF   x69
07426:  CLRF   x6A
07428:  CLRF   x6B
0742A:  CLRF   x6C
0742C:  CLRF   x6D
0742E:  CLRF   x6E
07430:  CLRF   x6F
07432:  CLRF   x70
07434:  CLRF   x71
07436:  CLRF   x72
07438:  CLRF   x73
0743A:  CLRF   x74
0743C:  CLRF   x75
0743E:  CLRF   x76
07440:  CLRF   x77
07442:  CLRF   x78
07444:  CLRF   x79
07446:  CLRF   x7A
07448:  CLRF   x7B
0744A:  CLRF   x7C
0744C:  CLRF   x7D
0744E:  CLRF   x7E
07450:  CLRF   x7F
07452:  CLRF   x80
07454:  CLRF   x81
07456:  CLRF   x82
07458:  CLRF   x83
0745A:  CLRF   x84
0745C:  CLRF   x85
0745E:  CLRF   x86
07460:  CLRF   x87
07462:  CLRF   x88
07464:  CLRF   x89
07466:  CLRF   x8A
07468:  CLRF   x8B
0746A:  CLRF   x8C
0746C:  CLRF   x8D
0746E:  CLRF   x8E
07470:  CLRF   x8F
07472:  CLRF   x90
07474:  CLRF   x91
07476:  CLRF   x92
07478:  CLRF   x93
0747A:  CLRF   x94
0747C:  CLRF   x95
0747E:  CLRF   x96
07480:  CLRF   x97
07482:  CLRF   x98
07484:  CLRF   x99
07486:  CLRF   x9A
07488:  CLRF   x9B
0748A:  CLRF   x9C
0748C:  CLRF   x9D
0748E:  CLRF   x9E
07490:  CLRF   x9F
07492:  CLRF   xA0
07494:  CLRF   xA1
07496:  CLRF   xA2
07498:  CLRF   xA3
0749A:  CLRF   xA4
0749C:  CLRF   xA5
0749E:  CLRF   xA6
074A0:  CLRF   xA7
074A2:  CLRF   xA8
074A4:  CLRF   xA9
074A6:  CLRF   xAA
074A8:  CLRF   xAB
074AA:  CLRF   xAC
074AC:  CLRF   xAD
074AE:  CLRF   xAE
074B0:  CLRF   xAF
074B2:  CLRF   xB0
074B4:  CLRF   xB1
074B6:  CLRF   xB2
074B8:  CLRF   xB3
074BA:  CLRF   xB4
074BC:  CLRF   xB5
074BE:  CLRF   xB6
074C0:  CLRF   xB7
074C2:  CLRF   xB8
074C4:  CLRF   xB9
074C6:  CLRF   xBA
074C8:  CLRF   xBB
074CA:  CLRF   xBC
074CC:  CLRF   xBD
074CE:  CLRF   xBE
074D0:  CLRF   xBF
074D2:  CLRF   xC0
074D4:  CLRF   xC1
074D6:  CLRF   xC2
074D8:  CLRF   xC3
074DA:  CLRF   xC4
074DC:  CLRF   xC5
074DE:  CLRF   xC6
074E0:  CLRF   xC7
074E2:  CLRF   xC8
074E4:  CLRF   xC9
074E6:  CLRF   xCA
074E8:  CLRF   xCB
074EA:  CLRF   xCC
074EC:  CLRF   xCD
074EE:  CLRF   xCE
074F0:  CLRF   xCF
074F2:  CLRF   xD0
074F4:  CLRF   xD1
074F6:  CLRF   xD2
074F8:  CLRF   xD3
074FA:  CLRF   xD4
074FC:  CLRF   xD5
074FE:  CLRF   xD6
07500:  CLRF   xD7
07502:  CLRF   xD8
07504:  CLRF   xD9
07506:  CLRF   xDA
07508:  CLRF   xDB
0750A:  CLRF   xDC
0750C:  CLRF   xDD
0750E:  CLRF   xDE
07510:  CLRF   xDF
07512:  CLRF   xE0
07514:  CLRF   xE1
07516:  CLRF   xE2
07518:  CLRF   xE3
0751A:  CLRF   xE4
0751C:  CLRF   xE5
0751E:  CLRF   xE6
07520:  CLRF   xE7
07522:  CLRF   xE8
07524:  CLRF   xE9
07526:  CLRF   xEA
07528:  CLRF   xEB
0752A:  CLRF   xEC
0752C:  CLRF   xED
0752E:  CLRF   xEE
07530:  CLRF   xEF
07532:  CLRF   xF0
07534:  CLRF   xF1
07536:  CLRF   xF2
07538:  CLRF   xF3
0753A:  CLRF   xF4
0753C:  CLRF   xF5
0753E:  CLRF   xF6
07540:  CLRF   xF7
07542:  CLRF   xF8
07544:  CLRF   xF9
07546:  CLRF   xFA
07548:  CLRF   xFB
0754A:  CLRF   xFC
0754C:  CLRF   xFD
0754E:  CLRF   xFE
07550:  CLRF   xFF
07552:  MOVLB  5
07554:  CLRF   x00
07556:  CLRF   x01
07558:  CLRF   x02
0755A:  CLRF   x03
0755C:  CLRF   x04
0755E:  CLRF   x05
07560:  CLRF   x06
07562:  CLRF   x07
07564:  CLRF   x08
07566:  CLRF   x09
07568:  CLRF   x0A
0756A:  CLRF   x0B
0756C:  CLRF   x0C
0756E:  CLRF   x0D
07570:  CLRF   x0E
07572:  CLRF   x0F
07574:  CLRF   x10
07576:  CLRF   x11
07578:  CLRF   x12
0757A:  CLRF   x13
0757C:  CLRF   x14
0757E:  CLRF   x15
07580:  CLRF   x16
07582:  CLRF   x17
07584:  CLRF   x18
07586:  CLRF   x19
07588:  CLRF   x1A
0758A:  CLRF   x1B
0758C:  CLRF   x1C
0758E:  CLRF   x1D
07590:  CLRF   x1E
07592:  CLRF   x1F
07594:  CLRF   x20
07596:  CLRF   x21
07598:  CLRF   x22
0759A:  CLRF   x23
0759C:  CLRF   x24
0759E:  CLRF   x25
075A0:  CLRF   x26
075A2:  CLRF   x27
075A4:  CLRF   x28
075A6:  CLRF   x29
075A8:  CLRF   x2A
075AA:  CLRF   x2B
075AC:  CLRF   x2C
075AE:  CLRF   x2D
075B0:  CLRF   x2E
075B2:  CLRF   x2F
075B4:  CLRF   x30
075B6:  CLRF   x31
075B8:  CLRF   x32
075BA:  CLRF   x33
075BC:  CLRF   x34
075BE:  CLRF   x35
075C0:  CLRF   x36
075C2:  CLRF   x37
075C4:  CLRF   x38
075C6:  CLRF   x39
075C8:  CLRF   x3A
075CA:  CLRF   x3B
075CC:  CLRF   x3C
075CE:  CLRF   x3D
075D0:  CLRF   x3E
075D2:  CLRF   x3F
075D4:  CLRF   x40
075D6:  CLRF   x41
075D8:  CLRF   x42
075DA:  CLRF   x43
075DC:  CLRF   x44
075DE:  CLRF   x45
075E0:  CLRF   x46
075E2:  CLRF   x47
075E4:  CLRF   x48
075E6:  CLRF   x49
075E8:  CLRF   x4A
075EA:  CLRF   x4B
075EC:  CLRF   x4C
075EE:  CLRF   x4D
075F0:  CLRF   x4E
075F2:  CLRF   x4F
075F4:  CLRF   x50
075F6:  CLRF   x51
075F8:  CLRF   x52
075FA:  CLRF   x53
075FC:  CLRF   x54
075FE:  CLRF   x55
07600:  CLRF   x56
07602:  CLRF   x57
07604:  CLRF   x58
07606:  CLRF   x59
07608:  CLRF   x5A
0760A:  CLRF   x5B
0760C:  CLRF   x5C
0760E:  CLRF   x5D
07610:  CLRF   x5E
07612:  CLRF   x5F
07614:  CLRF   x60
07616:  CLRF   x61
07618:  CLRF   x62
0761A:  CLRF   x63
0761C:  CLRF   x64
0761E:  CLRF   x65
07620:  CLRF   x66
07622:  CLRF   x67
07624:  CLRF   x68
07626:  CLRF   x69
07628:  CLRF   x6A
0762A:  CLRF   x6B
0762C:  CLRF   x6C
0762E:  CLRF   x6D
07630:  CLRF   x6E
07632:  CLRF   x6F
07634:  CLRF   x70
07636:  CLRF   x71
07638:  CLRF   x72
0763A:  CLRF   x73
0763C:  CLRF   x74
0763E:  CLRF   x75
07640:  CLRF   x76
07642:  CLRF   x77
07644:  CLRF   x78
07646:  CLRF   x79
07648:  CLRF   x7A
0764A:  CLRF   x7B
0764C:  CLRF   x7C
0764E:  CLRF   x7D
07650:  CLRF   x7E
07652:  CLRF   x7F
07654:  CLRF   x80
07656:  CLRF   x81
07658:  CLRF   x82
0765A:  CLRF   x83
0765C:  CLRF   x84
0765E:  CLRF   x85
07660:  CLRF   x86
07662:  CLRF   x87
07664:  CLRF   x88
07666:  CLRF   x89
07668:  CLRF   x8A
0766A:  CLRF   x8B
0766C:  CLRF   x8C
0766E:  CLRF   x8D
07670:  CLRF   x8E
07672:  CLRF   x8F
07674:  CLRF   x90
07676:  CLRF   x91
07678:  CLRF   x92
0767A:  CLRF   x93
0767C:  CLRF   x94
0767E:  CLRF   x95
07680:  CLRF   x96
07682:  CLRF   x97
07684:  CLRF   x98
07686:  CLRF   x99
07688:  CLRF   x9A
0768A:  CLRF   x9B
0768C:  CLRF   x9C
0768E:  CLRF   x9D
07690:  CLRF   x9E
07692:  CLRF   x9F
07694:  CLRF   xA0
07696:  CLRF   xA1
07698:  CLRF   xA2
0769A:  CLRF   xA3
0769C:  CLRF   xA4
0769E:  CLRF   xA5
076A0:  CLRF   xA6
076A2:  CLRF   xA7
076A4:  CLRF   xA8
076A6:  CLRF   xA9
076A8:  CLRF   xAA
076AA:  CLRF   xAB
076AC:  CLRF   xAC
076AE:  CLRF   xAD
076B0:  CLRF   xAE
076B2:  CLRF   xAF
076B4:  CLRF   xB0
076B6:  CLRF   xB1
076B8:  CLRF   xB2
076BA:  CLRF   xB3
076BC:  CLRF   xB4
076BE:  CLRF   xB5
076C0:  CLRF   xB6
076C2:  CLRF   xB7
076C4:  CLRF   xB8
076C6:  CLRF   xB9
076C8:  CLRF   xBA
076CA:  CLRF   xBB
076CC:  CLRF   xBC
076CE:  CLRF   xBD
076D0:  CLRF   xBE
076D2:  CLRF   xBF
076D4:  CLRF   xC0
076D6:  CLRF   xC1
076D8:  CLRF   xC2
076DA:  CLRF   xC3
076DC:  CLRF   xC4
076DE:  CLRF   xC5
076E0:  CLRF   xC6
076E2:  CLRF   xC7
076E4:  CLRF   xC8
076E6:  CLRF   xC9
076E8:  CLRF   xCA
076EA:  CLRF   xCB
076EC:  CLRF   xCC
076EE:  CLRF   xCD
076F0:  CLRF   xCE
076F2:  CLRF   xCF
076F4:  CLRF   xD0
076F6:  CLRF   xD1
076F8:  CLRF   xD2
076FA:  CLRF   xD3
076FC:  CLRF   xD4
076FE:  CLRF   xD5
07700:  CLRF   xD6
07702:  CLRF   xD7
07704:  CLRF   xD8
07706:  CLRF   xD9
07708:  CLRF   xDA
0770A:  CLRF   xDB
0770C:  CLRF   xDC
0770E:  CLRF   xDD
07710:  CLRF   xDE
07712:  CLRF   xDF
07714:  CLRF   xE0
07716:  CLRF   xE1
07718:  CLRF   xE2
0771A:  CLRF   xE3
0771C:  CLRF   xE4
0771E:  CLRF   xE5
07720:  CLRF   xE6
07722:  CLRF   xE7
07724:  CLRF   xE8
07726:  CLRF   xE9
07728:  CLRF   xEA
0772A:  CLRF   xEB
0772C:  CLRF   xEC
0772E:  CLRF   xED
07730:  CLRF   xEE
07732:  CLRF   xEF
07734:  CLRF   xF0
07736:  CLRF   xF1
07738:  CLRF   xF2
0773A:  CLRF   xF3
0773C:  CLRF   xF4
0773E:  CLRF   xF5
07740:  CLRF   xF6
07742:  CLRF   xF7
07744:  CLRF   xF8
07746:  CLRF   xF9
07748:  CLRF   xFA
0774A:  CLRF   xFB
0774C:  CLRF   xFC
0774E:  CLRF   xFD
07750:  CLRF   xFE
07752:  CLRF   xFF
07754:  MOVLB  6
07756:  CLRF   x00
07758:  CLRF   x01
0775A:  CLRF   x02
0775C:  CLRF   x03
0775E:  CLRF   x04
07760:  CLRF   x05
07762:  CLRF   x06
07764:  CLRF   x07
07766:  CLRF   x08
07768:  CLRF   x09
0776A:  CLRF   x0A
0776C:  CLRF   x0B
0776E:  CLRF   x0C
07770:  CLRF   x0D
07772:  CLRF   x0E
07774:  CLRF   x0F
07776:  CLRF   x10
07778:  CLRF   x11
0777A:  CLRF   x12
0777C:  CLRF   x13
0777E:  CLRF   x14
07780:  CLRF   x15
07782:  CLRF   x16
07784:  CLRF   x17
07786:  CLRF   x18
07788:  CLRF   x19
0778A:  CLRF   x1A
0778C:  CLRF   x1B
0778E:  CLRF   x1C
07790:  CLRF   x1D
07792:  CLRF   x1E
07794:  CLRF   x1F
07796:  CLRF   x20
07798:  CLRF   x21
0779A:  CLRF   x22
0779C:  CLRF   x23
0779E:  CLRF   x24
077A0:  CLRF   x25
077A2:  CLRF   x26
077A4:  CLRF   x27
077A6:  CLRF   x28
077A8:  CLRF   x29
077AA:  CLRF   x2A
077AC:  CLRF   x2B
077AE:  CLRF   x2C
077B0:  CLRF   x2D
077B2:  CLRF   x2E
077B4:  CLRF   x2F
077B6:  CLRF   x30
077B8:  CLRF   x31
077BA:  CLRF   x32
077BC:  CLRF   x33
077BE:  CLRF   x34
077C0:  CLRF   x35
077C2:  CLRF   x36
077C4:  CLRF   x37
077C6:  CLRF   x38
077C8:  CLRF   x39
077CA:  CLRF   x3A
077CC:  CLRF   x3B
077CE:  CLRF   x3C
077D0:  CLRF   x3D
077D2:  CLRF   x3E
077D4:  CLRF   x3F
077D6:  CLRF   x40
077D8:  CLRF   x41
077DA:  CLRF   x42
077DC:  CLRF   x43
077DE:  CLRF   x44
077E0:  CLRF   x45
077E2:  CLRF   x46
077E4:  CLRF   x47
077E6:  CLRF   x48
077E8:  CLRF   x49
077EA:  CLRF   x4A
077EC:  CLRF   x4B
077EE:  CLRF   x4C
077F0:  CLRF   x4D
077F2:  CLRF   x4E
077F4:  CLRF   x4F
077F6:  CLRF   x50
077F8:  CLRF   x51
077FA:  CLRF   x52
077FC:  CLRF   x53
077FE:  CLRF   x54
07800:  CLRF   x55
07802:  CLRF   x56
07804:  CLRF   x57
07806:  CLRF   x58
07808:  CLRF   x59
0780A:  CLRF   x5A
0780C:  CLRF   x5B
0780E:  CLRF   x5C
07810:  CLRF   x5D
07812:  CLRF   x5E
07814:  CLRF   x5F
07816:  CLRF   x60
07818:  CLRF   x61
0781A:  CLRF   x62
0781C:  CLRF   x63
0781E:  CLRF   x64
07820:  CLRF   x65
07822:  CLRF   x66
07824:  CLRF   x67
07826:  CLRF   x68
07828:  CLRF   x69
0782A:  CLRF   x6A
0782C:  CLRF   x6B
0782E:  CLRF   x6C
07830:  CLRF   x6D
07832:  CLRF   x6E
07834:  CLRF   x6F
07836:  CLRF   x70
07838:  CLRF   x71
0783A:  CLRF   x72
0783C:  CLRF   x73
0783E:  CLRF   x74
07840:  CLRF   x75
07842:  CLRF   x76
07844:  CLRF   x77
07846:  CLRF   x78
07848:  CLRF   x79
0784A:  CLRF   x7A
0784C:  CLRF   x7B
0784E:  CLRF   x7C
07850:  CLRF   x7D
07852:  CLRF   x7E
07854:  CLRF   x7F
07856:  CLRF   x80
07858:  CLRF   x81
0785A:  CLRF   x82
0785C:  CLRF   x83
0785E:  CLRF   x84
07860:  CLRF   x85
07862:  CLRF   x86
07864:  CLRF   x87
07866:  CLRF   x88
07868:  CLRF   x89
0786A:  CLRF   x8A
0786C:  CLRF   x8B
0786E:  CLRF   x8C
07870:  CLRF   x8D
07872:  CLRF   x8E
07874:  CLRF   x8F
07876:  CLRF   x90
07878:  CLRF   x91
0787A:  CLRF   x92
0787C:  CLRF   x93
0787E:  CLRF   x94
07880:  CLRF   x95
07882:  CLRF   x96
07884:  CLRF   x97
07886:  CLRF   x98
07888:  CLRF   x99
0788A:  CLRF   x9A
0788C:  CLRF   x9B
0788E:  CLRF   x9C
07890:  CLRF   x9D
07892:  CLRF   x9E
07894:  CLRF   x9F
07896:  CLRF   xA0
07898:  CLRF   xA1
0789A:  CLRF   xA2
0789C:  CLRF   xA3
0789E:  CLRF   xA4
078A0:  CLRF   xA5
078A2:  CLRF   xA6
078A4:  CLRF   xA7
078A6:  CLRF   xA8
078A8:  CLRF   xA9
078AA:  CLRF   xAA
078AC:  CLRF   xAB
078AE:  CLRF   xAC
078B0:  CLRF   xAD
078B2:  CLRF   xAE
078B4:  CLRF   xAF
078B6:  CLRF   xB0
078B8:  CLRF   xB1
078BA:  CLRF   xB2
078BC:  CLRF   xB3
078BE:  CLRF   xB4
078C0:  CLRF   xB5
078C2:  CLRF   xB6
078C4:  CLRF   xB7
078C6:  CLRF   xB8
078C8:  CLRF   xB9
078CA:  CLRF   xBA
078CC:  CLRF   xBB
078CE:  CLRF   xBC
078D0:  CLRF   xBD
078D2:  CLRF   xBE
078D4:  CLRF   xBF
078D6:  CLRF   xC0
078D8:  CLRF   xC1
078DA:  CLRF   xC2
078DC:  CLRF   xC3
078DE:  CLRF   xC4
078E0:  CLRF   xC5
078E2:  CLRF   xC6
078E4:  CLRF   xC7
078E6:  CLRF   xC8
078E8:  CLRF   xC9
078EA:  CLRF   xCA
078EC:  CLRF   xCB
078EE:  CLRF   xCC
078F0:  CLRF   xCD
078F2:  CLRF   xCE
078F4:  CLRF   xCF
078F6:  CLRF   xD0
078F8:  CLRF   xD1
078FA:  CLRF   xD2
078FC:  CLRF   xD3
078FE:  CLRF   xD4
07900:  CLRF   xD5
07902:  CLRF   xD6
07904:  CLRF   xD7
07906:  CLRF   xD8
07908:  CLRF   xD9
0790A:  CLRF   xDA
0790C:  CLRF   xDB
0790E:  CLRF   xDC
07910:  CLRF   xDD
07912:  CLRF   xDE
07914:  CLRF   xDF
07916:  CLRF   xE0
07918:  CLRF   xE1
0791A:  CLRF   xE2
0791C:  CLRF   xE3
0791E:  CLRF   xE4
07920:  CLRF   xE5
07922:  CLRF   xE6
07924:  CLRF   xE7
07926:  CLRF   xE8
07928:  CLRF   xE9
0792A:  CLRF   xEA
0792C:  CLRF   xEB
0792E:  CLRF   xEC
07930:  CLRF   xED
07932:  CLRF   xEE
07934:  CLRF   xEF
07936:  CLRF   xF0
07938:  CLRF   xF1
0793A:  CLRF   xF2
0793C:  CLRF   xF3
0793E:  CLRF   xF4
07940:  CLRF   xF5
07942:  CLRF   xF6
07944:  CLRF   xF7
07946:  CLRF   xF8
07948:  CLRF   xF9
0794A:  CLRF   xFA
0794C:  CLRF   xFB
0794E:  CLRF   xFC
07950:  CLRF   xFD
07952:  CLRF   xFE
07954:  CLRF   xFF
07956:  MOVLB  7
07958:  CLRF   x00
0795A:  CLRF   x01
0795C:  CLRF   x02
....................     port1.port_num = 1;
0795E:  MOVLW  01
07960:  MOVLB  3
07962:  MOVWF  x03
....................     port1.sweep_step = 0;
07964:  CLRF   x05
07966:  CLRF   x04
....................     port1.active = 1;
07968:  MOVLB  7
0796A:  BSF    x02.0
.................... 
....................     // Init Port2
....................     SWEEP_CONFIG port2 = {0};
0796C:  CLRF   x03
0796E:  CLRF   x04
07970:  CLRF   x05
07972:  CLRF   x06
07974:  CLRF   x07
07976:  CLRF   x08
07978:  CLRF   x09
0797A:  CLRF   x0A
0797C:  CLRF   x0B
0797E:  CLRF   x0C
07980:  CLRF   x0D
07982:  CLRF   x0E
07984:  CLRF   x0F
07986:  CLRF   x10
07988:  CLRF   x11
0798A:  CLRF   x12
0798C:  CLRF   x13
0798E:  CLRF   x14
07990:  CLRF   x15
07992:  CLRF   x16
07994:  CLRF   x17
07996:  CLRF   x18
07998:  CLRF   x19
0799A:  CLRF   x1A
0799C:  CLRF   x1B
0799E:  CLRF   x1C
079A0:  CLRF   x1D
079A2:  CLRF   x1E
079A4:  CLRF   x1F
079A6:  CLRF   x20
079A8:  CLRF   x21
079AA:  CLRF   x22
079AC:  CLRF   x23
079AE:  CLRF   x24
079B0:  CLRF   x25
079B2:  CLRF   x26
079B4:  CLRF   x27
079B6:  CLRF   x28
079B8:  CLRF   x29
079BA:  CLRF   x2A
079BC:  CLRF   x2B
079BE:  CLRF   x2C
079C0:  CLRF   x2D
079C2:  CLRF   x2E
079C4:  CLRF   x2F
079C6:  CLRF   x30
079C8:  CLRF   x31
079CA:  CLRF   x32
079CC:  CLRF   x33
079CE:  CLRF   x34
079D0:  CLRF   x35
079D2:  CLRF   x36
079D4:  CLRF   x37
079D6:  CLRF   x38
079D8:  CLRF   x39
079DA:  CLRF   x3A
079DC:  CLRF   x3B
079DE:  CLRF   x3C
079E0:  CLRF   x3D
079E2:  CLRF   x3E
079E4:  CLRF   x3F
079E6:  CLRF   x40
079E8:  CLRF   x41
079EA:  CLRF   x42
079EC:  CLRF   x43
079EE:  CLRF   x44
079F0:  CLRF   x45
079F2:  CLRF   x46
079F4:  CLRF   x47
079F6:  CLRF   x48
079F8:  CLRF   x49
079FA:  CLRF   x4A
079FC:  CLRF   x4B
079FE:  CLRF   x4C
07A00:  CLRF   x4D
07A02:  CLRF   x4E
07A04:  CLRF   x4F
07A06:  CLRF   x50
07A08:  CLRF   x51
07A0A:  CLRF   x52
07A0C:  CLRF   x53
07A0E:  CLRF   x54
07A10:  CLRF   x55
07A12:  CLRF   x56
07A14:  CLRF   x57
07A16:  CLRF   x58
07A18:  CLRF   x59
07A1A:  CLRF   x5A
07A1C:  CLRF   x5B
07A1E:  CLRF   x5C
07A20:  CLRF   x5D
07A22:  CLRF   x5E
07A24:  CLRF   x5F
07A26:  CLRF   x60
07A28:  CLRF   x61
07A2A:  CLRF   x62
07A2C:  CLRF   x63
07A2E:  CLRF   x64
07A30:  CLRF   x65
07A32:  CLRF   x66
07A34:  CLRF   x67
07A36:  CLRF   x68
07A38:  CLRF   x69
07A3A:  CLRF   x6A
07A3C:  CLRF   x6B
07A3E:  CLRF   x6C
07A40:  CLRF   x6D
07A42:  CLRF   x6E
07A44:  CLRF   x6F
07A46:  CLRF   x70
07A48:  CLRF   x71
07A4A:  CLRF   x72
07A4C:  CLRF   x73
07A4E:  CLRF   x74
07A50:  CLRF   x75
07A52:  CLRF   x76
07A54:  CLRF   x77
07A56:  CLRF   x78
07A58:  CLRF   x79
07A5A:  CLRF   x7A
07A5C:  CLRF   x7B
07A5E:  CLRF   x7C
07A60:  CLRF   x7D
07A62:  CLRF   x7E
07A64:  CLRF   x7F
07A66:  CLRF   x80
07A68:  CLRF   x81
07A6A:  CLRF   x82
07A6C:  CLRF   x83
07A6E:  CLRF   x84
07A70:  CLRF   x85
07A72:  CLRF   x86
07A74:  CLRF   x87
07A76:  CLRF   x88
07A78:  CLRF   x89
07A7A:  CLRF   x8A
07A7C:  CLRF   x8B
07A7E:  CLRF   x8C
07A80:  CLRF   x8D
07A82:  CLRF   x8E
07A84:  CLRF   x8F
07A86:  CLRF   x90
07A88:  CLRF   x91
07A8A:  CLRF   x92
07A8C:  CLRF   x93
07A8E:  CLRF   x94
07A90:  CLRF   x95
07A92:  CLRF   x96
07A94:  CLRF   x97
07A96:  CLRF   x98
07A98:  CLRF   x99
07A9A:  CLRF   x9A
07A9C:  CLRF   x9B
07A9E:  CLRF   x9C
07AA0:  CLRF   x9D
07AA2:  CLRF   x9E
07AA4:  CLRF   x9F
07AA6:  CLRF   xA0
07AA8:  CLRF   xA1
07AAA:  CLRF   xA2
07AAC:  CLRF   xA3
07AAE:  CLRF   xA4
07AB0:  CLRF   xA5
07AB2:  CLRF   xA6
07AB4:  CLRF   xA7
07AB6:  CLRF   xA8
07AB8:  CLRF   xA9
07ABA:  CLRF   xAA
07ABC:  CLRF   xAB
07ABE:  CLRF   xAC
07AC0:  CLRF   xAD
07AC2:  CLRF   xAE
07AC4:  CLRF   xAF
07AC6:  CLRF   xB0
07AC8:  CLRF   xB1
07ACA:  CLRF   xB2
07ACC:  CLRF   xB3
07ACE:  CLRF   xB4
07AD0:  CLRF   xB5
07AD2:  CLRF   xB6
07AD4:  CLRF   xB7
07AD6:  CLRF   xB8
07AD8:  CLRF   xB9
07ADA:  CLRF   xBA
07ADC:  CLRF   xBB
07ADE:  CLRF   xBC
07AE0:  CLRF   xBD
07AE2:  CLRF   xBE
07AE4:  CLRF   xBF
07AE6:  CLRF   xC0
07AE8:  CLRF   xC1
07AEA:  CLRF   xC2
07AEC:  CLRF   xC3
07AEE:  CLRF   xC4
07AF0:  CLRF   xC5
07AF2:  CLRF   xC6
07AF4:  CLRF   xC7
07AF6:  CLRF   xC8
07AF8:  CLRF   xC9
07AFA:  CLRF   xCA
07AFC:  CLRF   xCB
07AFE:  CLRF   xCC
07B00:  CLRF   xCD
07B02:  CLRF   xCE
07B04:  CLRF   xCF
07B06:  CLRF   xD0
07B08:  CLRF   xD1
07B0A:  CLRF   xD2
07B0C:  CLRF   xD3
07B0E:  CLRF   xD4
07B10:  CLRF   xD5
07B12:  CLRF   xD6
07B14:  CLRF   xD7
07B16:  CLRF   xD8
07B18:  CLRF   xD9
07B1A:  CLRF   xDA
07B1C:  CLRF   xDB
07B1E:  CLRF   xDC
07B20:  CLRF   xDD
07B22:  CLRF   xDE
07B24:  CLRF   xDF
07B26:  CLRF   xE0
07B28:  CLRF   xE1
07B2A:  CLRF   xE2
07B2C:  CLRF   xE3
07B2E:  CLRF   xE4
07B30:  CLRF   xE5
07B32:  CLRF   xE6
07B34:  CLRF   xE7
07B36:  CLRF   xE8
07B38:  CLRF   xE9
07B3A:  CLRF   xEA
07B3C:  CLRF   xEB
07B3E:  CLRF   xEC
07B40:  CLRF   xED
07B42:  CLRF   xEE
07B44:  CLRF   xEF
07B46:  CLRF   xF0
07B48:  CLRF   xF1
07B4A:  CLRF   xF2
07B4C:  CLRF   xF3
07B4E:  CLRF   xF4
07B50:  CLRF   xF5
07B52:  CLRF   xF6
07B54:  CLRF   xF7
07B56:  CLRF   xF8
07B58:  CLRF   xF9
07B5A:  CLRF   xFA
07B5C:  CLRF   xFB
07B5E:  CLRF   xFC
07B60:  CLRF   xFD
07B62:  CLRF   xFE
07B64:  CLRF   xFF
07B66:  MOVLB  8
07B68:  CLRF   x00
07B6A:  CLRF   x01
07B6C:  CLRF   x02
07B6E:  CLRF   x03
07B70:  CLRF   x04
07B72:  CLRF   x05
07B74:  CLRF   x06
07B76:  CLRF   x07
07B78:  CLRF   x08
07B7A:  CLRF   x09
07B7C:  CLRF   x0A
07B7E:  CLRF   x0B
07B80:  CLRF   x0C
07B82:  CLRF   x0D
07B84:  CLRF   x0E
07B86:  CLRF   x0F
07B88:  CLRF   x10
07B8A:  CLRF   x11
07B8C:  CLRF   x12
07B8E:  CLRF   x13
07B90:  CLRF   x14
07B92:  CLRF   x15
07B94:  CLRF   x16
07B96:  CLRF   x17
07B98:  CLRF   x18
07B9A:  CLRF   x19
07B9C:  CLRF   x1A
07B9E:  CLRF   x1B
07BA0:  CLRF   x1C
07BA2:  CLRF   x1D
07BA4:  CLRF   x1E
07BA6:  CLRF   x1F
07BA8:  CLRF   x20
07BAA:  CLRF   x21
07BAC:  CLRF   x22
07BAE:  CLRF   x23
07BB0:  CLRF   x24
07BB2:  CLRF   x25
07BB4:  CLRF   x26
07BB6:  CLRF   x27
07BB8:  CLRF   x28
07BBA:  CLRF   x29
07BBC:  CLRF   x2A
07BBE:  CLRF   x2B
07BC0:  CLRF   x2C
07BC2:  CLRF   x2D
07BC4:  CLRF   x2E
07BC6:  CLRF   x2F
07BC8:  CLRF   x30
07BCA:  CLRF   x31
07BCC:  CLRF   x32
07BCE:  CLRF   x33
07BD0:  CLRF   x34
07BD2:  CLRF   x35
07BD4:  CLRF   x36
07BD6:  CLRF   x37
07BD8:  CLRF   x38
07BDA:  CLRF   x39
07BDC:  CLRF   x3A
07BDE:  CLRF   x3B
07BE0:  CLRF   x3C
07BE2:  CLRF   x3D
07BE4:  CLRF   x3E
07BE6:  CLRF   x3F
07BE8:  CLRF   x40
07BEA:  CLRF   x41
07BEC:  CLRF   x42
07BEE:  CLRF   x43
07BF0:  CLRF   x44
07BF2:  CLRF   x45
07BF4:  CLRF   x46
07BF6:  CLRF   x47
07BF8:  CLRF   x48
07BFA:  CLRF   x49
07BFC:  CLRF   x4A
07BFE:  CLRF   x4B
07C00:  CLRF   x4C
07C02:  CLRF   x4D
07C04:  CLRF   x4E
07C06:  CLRF   x4F
07C08:  CLRF   x50
07C0A:  CLRF   x51
07C0C:  CLRF   x52
07C0E:  CLRF   x53
07C10:  CLRF   x54
07C12:  CLRF   x55
07C14:  CLRF   x56
07C16:  CLRF   x57
07C18:  CLRF   x58
07C1A:  CLRF   x59
07C1C:  CLRF   x5A
07C1E:  CLRF   x5B
07C20:  CLRF   x5C
07C22:  CLRF   x5D
07C24:  CLRF   x5E
07C26:  CLRF   x5F
07C28:  CLRF   x60
07C2A:  CLRF   x61
07C2C:  CLRF   x62
07C2E:  CLRF   x63
07C30:  CLRF   x64
07C32:  CLRF   x65
07C34:  CLRF   x66
07C36:  CLRF   x67
07C38:  CLRF   x68
07C3A:  CLRF   x69
07C3C:  CLRF   x6A
07C3E:  CLRF   x6B
07C40:  CLRF   x6C
07C42:  CLRF   x6D
07C44:  CLRF   x6E
07C46:  CLRF   x6F
07C48:  CLRF   x70
07C4A:  CLRF   x71
07C4C:  CLRF   x72
07C4E:  CLRF   x73
07C50:  CLRF   x74
07C52:  CLRF   x75
07C54:  CLRF   x76
07C56:  CLRF   x77
07C58:  CLRF   x78
07C5A:  CLRF   x79
07C5C:  CLRF   x7A
07C5E:  CLRF   x7B
07C60:  CLRF   x7C
07C62:  CLRF   x7D
07C64:  CLRF   x7E
07C66:  CLRF   x7F
07C68:  CLRF   x80
07C6A:  CLRF   x81
07C6C:  CLRF   x82
07C6E:  CLRF   x83
07C70:  CLRF   x84
07C72:  CLRF   x85
07C74:  CLRF   x86
07C76:  CLRF   x87
07C78:  CLRF   x88
07C7A:  CLRF   x89
07C7C:  CLRF   x8A
07C7E:  CLRF   x8B
07C80:  CLRF   x8C
07C82:  CLRF   x8D
07C84:  CLRF   x8E
07C86:  CLRF   x8F
07C88:  CLRF   x90
07C8A:  CLRF   x91
07C8C:  CLRF   x92
07C8E:  CLRF   x93
07C90:  CLRF   x94
07C92:  CLRF   x95
07C94:  CLRF   x96
07C96:  CLRF   x97
07C98:  CLRF   x98
07C9A:  CLRF   x99
07C9C:  CLRF   x9A
07C9E:  CLRF   x9B
07CA0:  CLRF   x9C
07CA2:  CLRF   x9D
07CA4:  CLRF   x9E
07CA6:  CLRF   x9F
07CA8:  CLRF   xA0
07CAA:  CLRF   xA1
07CAC:  CLRF   xA2
07CAE:  CLRF   xA3
07CB0:  CLRF   xA4
07CB2:  CLRF   xA5
07CB4:  CLRF   xA6
07CB6:  CLRF   xA7
07CB8:  CLRF   xA8
07CBA:  CLRF   xA9
07CBC:  CLRF   xAA
07CBE:  CLRF   xAB
07CC0:  CLRF   xAC
07CC2:  CLRF   xAD
07CC4:  CLRF   xAE
07CC6:  CLRF   xAF
07CC8:  CLRF   xB0
07CCA:  CLRF   xB1
07CCC:  CLRF   xB2
07CCE:  CLRF   xB3
07CD0:  CLRF   xB4
07CD2:  CLRF   xB5
07CD4:  CLRF   xB6
07CD6:  CLRF   xB7
07CD8:  CLRF   xB8
07CDA:  CLRF   xB9
07CDC:  CLRF   xBA
07CDE:  CLRF   xBB
07CE0:  CLRF   xBC
07CE2:  CLRF   xBD
07CE4:  CLRF   xBE
07CE6:  CLRF   xBF
07CE8:  CLRF   xC0
07CEA:  CLRF   xC1
07CEC:  CLRF   xC2
07CEE:  CLRF   xC3
07CF0:  CLRF   xC4
07CF2:  CLRF   xC5
07CF4:  CLRF   xC6
07CF6:  CLRF   xC7
07CF8:  CLRF   xC8
07CFA:  CLRF   xC9
07CFC:  CLRF   xCA
07CFE:  CLRF   xCB
07D00:  CLRF   xCC
07D02:  CLRF   xCD
07D04:  CLRF   xCE
07D06:  CLRF   xCF
07D08:  CLRF   xD0
07D0A:  CLRF   xD1
07D0C:  CLRF   xD2
07D0E:  CLRF   xD3
07D10:  CLRF   xD4
07D12:  CLRF   xD5
07D14:  CLRF   xD6
07D16:  CLRF   xD7
07D18:  CLRF   xD8
07D1A:  CLRF   xD9
07D1C:  CLRF   xDA
07D1E:  CLRF   xDB
07D20:  CLRF   xDC
07D22:  CLRF   xDD
07D24:  CLRF   xDE
07D26:  CLRF   xDF
07D28:  CLRF   xE0
07D2A:  CLRF   xE1
07D2C:  CLRF   xE2
07D2E:  CLRF   xE3
07D30:  CLRF   xE4
07D32:  CLRF   xE5
07D34:  CLRF   xE6
07D36:  CLRF   xE7
07D38:  CLRF   xE8
07D3A:  CLRF   xE9
07D3C:  CLRF   xEA
07D3E:  CLRF   xEB
07D40:  CLRF   xEC
07D42:  CLRF   xED
07D44:  CLRF   xEE
07D46:  CLRF   xEF
07D48:  CLRF   xF0
07D4A:  CLRF   xF1
07D4C:  CLRF   xF2
07D4E:  CLRF   xF3
07D50:  CLRF   xF4
07D52:  CLRF   xF5
07D54:  CLRF   xF6
07D56:  CLRF   xF7
07D58:  CLRF   xF8
07D5A:  CLRF   xF9
07D5C:  CLRF   xFA
07D5E:  CLRF   xFB
07D60:  CLRF   xFC
07D62:  CLRF   xFD
07D64:  CLRF   xFE
07D66:  CLRF   xFF
07D68:  MOVLB  9
07D6A:  CLRF   x00
07D6C:  CLRF   x01
07D6E:  CLRF   x02
07D70:  CLRF   x03
07D72:  CLRF   x04
07D74:  CLRF   x05
07D76:  CLRF   x06
07D78:  CLRF   x07
07D7A:  CLRF   x08
07D7C:  CLRF   x09
07D7E:  CLRF   x0A
07D80:  CLRF   x0B
07D82:  CLRF   x0C
07D84:  CLRF   x0D
07D86:  CLRF   x0E
07D88:  CLRF   x0F
07D8A:  CLRF   x10
07D8C:  CLRF   x11
07D8E:  CLRF   x12
07D90:  CLRF   x13
07D92:  CLRF   x14
07D94:  CLRF   x15
07D96:  CLRF   x16
07D98:  CLRF   x17
07D9A:  CLRF   x18
07D9C:  CLRF   x19
07D9E:  CLRF   x1A
07DA0:  CLRF   x1B
07DA2:  CLRF   x1C
07DA4:  CLRF   x1D
07DA6:  CLRF   x1E
07DA8:  CLRF   x1F
07DAA:  CLRF   x20
07DAC:  CLRF   x21
07DAE:  CLRF   x22
07DB0:  CLRF   x23
07DB2:  CLRF   x24
07DB4:  CLRF   x25
07DB6:  CLRF   x26
07DB8:  CLRF   x27
07DBA:  CLRF   x28
07DBC:  CLRF   x29
07DBE:  CLRF   x2A
07DC0:  CLRF   x2B
07DC2:  CLRF   x2C
07DC4:  CLRF   x2D
07DC6:  CLRF   x2E
07DC8:  CLRF   x2F
07DCA:  CLRF   x30
07DCC:  CLRF   x31
07DCE:  CLRF   x32
07DD0:  CLRF   x33
07DD2:  CLRF   x34
07DD4:  CLRF   x35
07DD6:  CLRF   x36
07DD8:  CLRF   x37
07DDA:  CLRF   x38
07DDC:  CLRF   x39
07DDE:  CLRF   x3A
07DE0:  CLRF   x3B
07DE2:  CLRF   x3C
07DE4:  CLRF   x3D
07DE6:  CLRF   x3E
07DE8:  CLRF   x3F
07DEA:  CLRF   x40
07DEC:  CLRF   x41
07DEE:  CLRF   x42
07DF0:  CLRF   x43
07DF2:  CLRF   x44
07DF4:  CLRF   x45
07DF6:  CLRF   x46
07DF8:  CLRF   x47
07DFA:  CLRF   x48
07DFC:  CLRF   x49
07DFE:  CLRF   x4A
07E00:  CLRF   x4B
07E02:  CLRF   x4C
07E04:  CLRF   x4D
07E06:  CLRF   x4E
07E08:  CLRF   x4F
07E0A:  CLRF   x50
07E0C:  CLRF   x51
07E0E:  CLRF   x52
07E10:  CLRF   x53
07E12:  CLRF   x54
07E14:  CLRF   x55
07E16:  CLRF   x56
07E18:  CLRF   x57
07E1A:  CLRF   x58
07E1C:  CLRF   x59
07E1E:  CLRF   x5A
07E20:  CLRF   x5B
07E22:  CLRF   x5C
07E24:  CLRF   x5D
07E26:  CLRF   x5E
07E28:  CLRF   x5F
07E2A:  CLRF   x60
07E2C:  CLRF   x61
07E2E:  CLRF   x62
07E30:  CLRF   x63
07E32:  CLRF   x64
07E34:  CLRF   x65
07E36:  CLRF   x66
07E38:  CLRF   x67
07E3A:  CLRF   x68
07E3C:  CLRF   x69
07E3E:  CLRF   x6A
07E40:  CLRF   x6B
07E42:  CLRF   x6C
07E44:  CLRF   x6D
07E46:  CLRF   x6E
07E48:  CLRF   x6F
07E4A:  CLRF   x70
07E4C:  CLRF   x71
07E4E:  CLRF   x72
07E50:  CLRF   x73
07E52:  CLRF   x74
07E54:  CLRF   x75
07E56:  CLRF   x76
07E58:  CLRF   x77
07E5A:  CLRF   x78
07E5C:  CLRF   x79
07E5E:  CLRF   x7A
07E60:  CLRF   x7B
07E62:  CLRF   x7C
07E64:  CLRF   x7D
07E66:  CLRF   x7E
07E68:  CLRF   x7F
07E6A:  CLRF   x80
07E6C:  CLRF   x81
07E6E:  CLRF   x82
07E70:  CLRF   x83
07E72:  CLRF   x84
07E74:  CLRF   x85
07E76:  CLRF   x86
07E78:  CLRF   x87
07E7A:  CLRF   x88
07E7C:  CLRF   x89
07E7E:  CLRF   x8A
07E80:  CLRF   x8B
07E82:  CLRF   x8C
07E84:  CLRF   x8D
07E86:  CLRF   x8E
07E88:  CLRF   x8F
07E8A:  CLRF   x90
07E8C:  CLRF   x91
07E8E:  CLRF   x92
07E90:  CLRF   x93
07E92:  CLRF   x94
07E94:  CLRF   x95
07E96:  CLRF   x96
07E98:  CLRF   x97
07E9A:  CLRF   x98
07E9C:  CLRF   x99
07E9E:  CLRF   x9A
07EA0:  CLRF   x9B
07EA2:  CLRF   x9C
07EA4:  CLRF   x9D
07EA6:  CLRF   x9E
07EA8:  CLRF   x9F
07EAA:  CLRF   xA0
07EAC:  CLRF   xA1
07EAE:  CLRF   xA2
07EB0:  CLRF   xA3
07EB2:  CLRF   xA4
07EB4:  CLRF   xA5
07EB6:  CLRF   xA6
07EB8:  CLRF   xA7
07EBA:  CLRF   xA8
07EBC:  CLRF   xA9
07EBE:  CLRF   xAA
07EC0:  CLRF   xAB
07EC2:  CLRF   xAC
07EC4:  CLRF   xAD
07EC6:  CLRF   xAE
07EC8:  CLRF   xAF
07ECA:  CLRF   xB0
07ECC:  CLRF   xB1
07ECE:  CLRF   xB2
07ED0:  CLRF   xB3
07ED2:  CLRF   xB4
07ED4:  CLRF   xB5
07ED6:  CLRF   xB6
07ED8:  CLRF   xB7
07EDA:  CLRF   xB8
07EDC:  CLRF   xB9
07EDE:  CLRF   xBA
07EE0:  CLRF   xBB
07EE2:  CLRF   xBC
07EE4:  CLRF   xBD
07EE6:  CLRF   xBE
07EE8:  CLRF   xBF
07EEA:  CLRF   xC0
07EEC:  CLRF   xC1
07EEE:  CLRF   xC2
07EF0:  CLRF   xC3
07EF2:  CLRF   xC4
07EF4:  CLRF   xC5
07EF6:  CLRF   xC6
07EF8:  CLRF   xC7
07EFA:  CLRF   xC8
07EFC:  CLRF   xC9
07EFE:  CLRF   xCA
07F00:  CLRF   xCB
07F02:  CLRF   xCC
07F04:  CLRF   xCD
07F06:  CLRF   xCE
07F08:  CLRF   xCF
07F0A:  CLRF   xD0
07F0C:  CLRF   xD1
07F0E:  CLRF   xD2
07F10:  CLRF   xD3
07F12:  CLRF   xD4
07F14:  CLRF   xD5
07F16:  CLRF   xD6
07F18:  CLRF   xD7
07F1A:  CLRF   xD8
07F1C:  CLRF   xD9
07F1E:  CLRF   xDA
07F20:  CLRF   xDB
07F22:  CLRF   xDC
07F24:  CLRF   xDD
07F26:  CLRF   xDE
07F28:  CLRF   xDF
07F2A:  CLRF   xE0
07F2C:  CLRF   xE1
07F2E:  CLRF   xE2
07F30:  CLRF   xE3
07F32:  CLRF   xE4
07F34:  CLRF   xE5
07F36:  CLRF   xE6
07F38:  CLRF   xE7
07F3A:  CLRF   xE8
07F3C:  CLRF   xE9
07F3E:  CLRF   xEA
07F40:  CLRF   xEB
07F42:  CLRF   xEC
07F44:  CLRF   xED
07F46:  CLRF   xEE
07F48:  CLRF   xEF
07F4A:  CLRF   xF0
07F4C:  CLRF   xF1
07F4E:  CLRF   xF2
07F50:  CLRF   xF3
07F52:  CLRF   xF4
07F54:  CLRF   xF5
07F56:  CLRF   xF6
07F58:  CLRF   xF7
07F5A:  CLRF   xF8
07F5C:  CLRF   xF9
07F5E:  CLRF   xFA
07F60:  CLRF   xFB
07F62:  CLRF   xFC
07F64:  CLRF   xFD
07F66:  CLRF   xFE
07F68:  CLRF   xFF
07F6A:  MOVLB  A
07F6C:  CLRF   x00
07F6E:  CLRF   x01
07F70:  CLRF   x02
07F72:  CLRF   x03
07F74:  CLRF   x04
07F76:  CLRF   x05
07F78:  CLRF   x06
07F7A:  CLRF   x07
07F7C:  CLRF   x08
07F7E:  CLRF   x09
07F80:  CLRF   x0A
07F82:  CLRF   x0B
07F84:  CLRF   x0C
07F86:  CLRF   x0D
07F88:  CLRF   x0E
07F8A:  CLRF   x0F
07F8C:  CLRF   x10
07F8E:  CLRF   x11
07F90:  CLRF   x12
07F92:  CLRF   x13
07F94:  CLRF   x14
07F96:  CLRF   x15
07F98:  CLRF   x16
07F9A:  CLRF   x17
07F9C:  CLRF   x18
07F9E:  CLRF   x19
07FA0:  CLRF   x1A
07FA2:  CLRF   x1B
07FA4:  CLRF   x1C
07FA6:  CLRF   x1D
07FA8:  CLRF   x1E
07FAA:  CLRF   x1F
07FAC:  CLRF   x20
07FAE:  CLRF   x21
07FB0:  CLRF   x22
07FB2:  CLRF   x23
07FB4:  CLRF   x24
07FB6:  CLRF   x25
07FB8:  CLRF   x26
07FBA:  CLRF   x27
07FBC:  CLRF   x28
07FBE:  CLRF   x29
07FC0:  CLRF   x2A
07FC2:  CLRF   x2B
07FC4:  CLRF   x2C
07FC6:  CLRF   x2D
07FC8:  CLRF   x2E
07FCA:  CLRF   x2F
07FCC:  CLRF   x30
07FCE:  CLRF   x31
07FD0:  CLRF   x32
07FD2:  CLRF   x33
07FD4:  CLRF   x34
07FD6:  CLRF   x35
07FD8:  CLRF   x36
07FDA:  CLRF   x37
07FDC:  CLRF   x38
07FDE:  CLRF   x39
07FE0:  CLRF   x3A
07FE2:  CLRF   x3B
07FE4:  CLRF   x3C
07FE6:  CLRF   x3D
07FE8:  CLRF   x3E
07FEA:  CLRF   x3F
07FEC:  CLRF   x40
07FEE:  CLRF   x41
07FF0:  CLRF   x42
07FF2:  CLRF   x43
07FF4:  CLRF   x44
07FF6:  CLRF   x45
07FF8:  CLRF   x46
07FFA:  CLRF   x47
07FFC:  CLRF   x48
07FFE:  CLRF   x49
08000:  CLRF   x4A
08002:  CLRF   x4B
08004:  CLRF   x4C
08006:  CLRF   x4D
08008:  CLRF   x4E
0800A:  CLRF   x4F
0800C:  CLRF   x50
0800E:  CLRF   x51
08010:  CLRF   x52
08012:  CLRF   x53
08014:  CLRF   x54
08016:  CLRF   x55
08018:  CLRF   x56
0801A:  CLRF   x57
0801C:  CLRF   x58
0801E:  CLRF   x59
08020:  CLRF   x5A
08022:  CLRF   x5B
08024:  CLRF   x5C
08026:  CLRF   x5D
08028:  CLRF   x5E
0802A:  CLRF   x5F
0802C:  CLRF   x60
0802E:  CLRF   x61
08030:  CLRF   x62
08032:  CLRF   x63
08034:  CLRF   x64
08036:  CLRF   x65
08038:  CLRF   x66
0803A:  CLRF   x67
0803C:  CLRF   x68
0803E:  CLRF   x69
08040:  CLRF   x6A
08042:  CLRF   x6B
08044:  CLRF   x6C
08046:  CLRF   x6D
08048:  CLRF   x6E
0804A:  CLRF   x6F
0804C:  CLRF   x70
0804E:  CLRF   x71
08050:  CLRF   x72
08052:  CLRF   x73
08054:  CLRF   x74
08056:  CLRF   x75
08058:  CLRF   x76
0805A:  CLRF   x77
0805C:  CLRF   x78
0805E:  CLRF   x79
08060:  CLRF   x7A
08062:  CLRF   x7B
08064:  CLRF   x7C
08066:  CLRF   x7D
08068:  CLRF   x7E
0806A:  CLRF   x7F
0806C:  CLRF   x80
0806E:  CLRF   x81
08070:  CLRF   x82
08072:  CLRF   x83
08074:  CLRF   x84
08076:  CLRF   x85
08078:  CLRF   x86
0807A:  CLRF   x87
0807C:  CLRF   x88
0807E:  CLRF   x89
08080:  CLRF   x8A
08082:  CLRF   x8B
08084:  CLRF   x8C
08086:  CLRF   x8D
08088:  CLRF   x8E
0808A:  CLRF   x8F
0808C:  CLRF   x90
0808E:  CLRF   x91
08090:  CLRF   x92
08092:  CLRF   x93
08094:  CLRF   x94
08096:  CLRF   x95
08098:  CLRF   x96
0809A:  CLRF   x97
0809C:  CLRF   x98
0809E:  CLRF   x99
080A0:  CLRF   x9A
080A2:  CLRF   x9B
080A4:  CLRF   x9C
080A6:  CLRF   x9D
080A8:  CLRF   x9E
080AA:  CLRF   x9F
080AC:  CLRF   xA0
080AE:  CLRF   xA1
080B0:  CLRF   xA2
080B2:  CLRF   xA3
080B4:  CLRF   xA4
080B6:  CLRF   xA5
080B8:  CLRF   xA6
080BA:  CLRF   xA7
080BC:  CLRF   xA8
080BE:  CLRF   xA9
080C0:  CLRF   xAA
080C2:  CLRF   xAB
080C4:  CLRF   xAC
080C6:  CLRF   xAD
080C8:  CLRF   xAE
080CA:  CLRF   xAF
080CC:  CLRF   xB0
080CE:  CLRF   xB1
080D0:  CLRF   xB2
080D2:  CLRF   xB3
080D4:  CLRF   xB4
080D6:  CLRF   xB5
080D8:  CLRF   xB6
080DA:  CLRF   xB7
080DC:  CLRF   xB8
080DE:  CLRF   xB9
080E0:  CLRF   xBA
080E2:  CLRF   xBB
080E4:  CLRF   xBC
080E6:  CLRF   xBD
080E8:  CLRF   xBE
080EA:  CLRF   xBF
080EC:  CLRF   xC0
080EE:  CLRF   xC1
080F0:  CLRF   xC2
080F2:  CLRF   xC3
080F4:  CLRF   xC4
080F6:  CLRF   xC5
080F8:  CLRF   xC6
080FA:  CLRF   xC7
080FC:  CLRF   xC8
080FE:  CLRF   xC9
08100:  CLRF   xCA
08102:  CLRF   xCB
08104:  CLRF   xCC
08106:  CLRF   xCD
08108:  CLRF   xCE
0810A:  CLRF   xCF
0810C:  CLRF   xD0
0810E:  CLRF   xD1
08110:  CLRF   xD2
08112:  CLRF   xD3
08114:  CLRF   xD4
08116:  CLRF   xD5
08118:  CLRF   xD6
0811A:  CLRF   xD7
0811C:  CLRF   xD8
0811E:  CLRF   xD9
08120:  CLRF   xDA
08122:  CLRF   xDB
08124:  CLRF   xDC
08126:  CLRF   xDD
08128:  CLRF   xDE
0812A:  CLRF   xDF
0812C:  CLRF   xE0
0812E:  CLRF   xE1
08130:  CLRF   xE2
08132:  CLRF   xE3
08134:  CLRF   xE4
08136:  CLRF   xE5
08138:  CLRF   xE6
0813A:  CLRF   xE7
0813C:  CLRF   xE8
0813E:  CLRF   xE9
08140:  CLRF   xEA
08142:  CLRF   xEB
08144:  CLRF   xEC
08146:  CLRF   xED
08148:  CLRF   xEE
0814A:  CLRF   xEF
0814C:  CLRF   xF0
0814E:  CLRF   xF1
08150:  CLRF   xF2
08152:  CLRF   xF3
08154:  CLRF   xF4
08156:  CLRF   xF5
08158:  CLRF   xF6
0815A:  CLRF   xF7
0815C:  CLRF   xF8
0815E:  CLRF   xF9
08160:  CLRF   xFA
08162:  CLRF   xFB
08164:  CLRF   xFC
08166:  CLRF   xFD
08168:  CLRF   xFE
0816A:  CLRF   xFF
0816C:  MOVLB  B
0816E:  CLRF   x00
08170:  CLRF   x01
08172:  CLRF   x02
....................     port2.port_num = 2;
08174:  MOVLW  02
08176:  MOVLB  7
08178:  MOVWF  x03
....................     port2.sweep_step = 0;
0817A:  CLRF   x05
0817C:  CLRF   x04
....................     port2.active = 1;
0817E:  MOVLB  B
08180:  BSF    x02.0
.................... 
....................     int16 count = 1;
08182:  CLRF   x04
08184:  MOVLW  01
08186:  MOVWF  x03
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
08188:  CLRF   x18
0818A:  MOVLW  01
0818C:  MOVWF  x17
0818E:  MOVLB  0
08190:  CALL   20FE
....................     mcp4901_2_write(1);
08194:  MOVLB  B
08196:  CLRF   x18
08198:  MOVLW  01
0819A:  MOVWF  x17
0819C:  MOVLB  0
0819E:  CALL   2140
....................     ad7490_read(ADC_CIGS1_CURR);
081A2:  MOVLW  01
081A4:  MOVLB  B
081A6:  MOVWF  x2A
081A8:  MOVLB  0
081AA:  CALL   1DA0
....................     ad7490_read(ADC_CIGS2_CURR);
081AE:  MOVLW  05
081B0:  MOVLB  B
081B2:  MOVWF  x2A
081B4:  MOVLB  0
081B6:  CALL   1DA0
....................     ad7490_read(ADC_CIGS2_CURR);
081BA:  MOVLW  05
081BC:  MOVLB  B
081BE:  MOVWF  x2A
081C0:  MOVLB  0
081C2:  CALL   1DA0
....................     delay_ms(200);
081C6:  MOVLW  C8
081C8:  MOVLB  B
081CA:  MOVWF  xC3
081CC:  MOVLB  0
081CE:  CALL   1B30
.................... 
....................     // Read initial PD value
....................     MEASUREMENT_DATA measured_data = create_meas_data();
081D2:  GOTO   694C
081D6:  MOVFF  02,03
081DA:  MOVF   01,W
081DC:  MOVWF  FE1
081DE:  MOVFF  03,FE2
081E2:  MOVLW  0B
081E4:  MOVWF  FEA
081E6:  MOVLW  05
081E8:  MOVWF  FE9
081EA:  MOVLW  0F
081EC:  MOVWF  01
081EE:  MOVFF  FE6,FEE
081F2:  DECFSZ 01,F
081F4:  GOTO   81EE
....................     // Continue measurement while at least one port is active
....................     while (port1.active || port2.active)
081F8:  MOVLB  7
081FA:  BTFSS  x02.0
081FC:  BRA    8204
081FE:  MOVLB  0
08200:  GOTO   8214
08204:  MOVLB  0
08206:  MOVLB  B
08208:  BTFSC  x02.0
0820A:  BRA    8212
0820C:  MOVLB  0
0820E:  GOTO   869C
08212:  MOVLB  0
....................     {
....................         // Set DAC values for both ports (synchronized timing)
....................         mcp4901_1_write(count);
08214:  MOVFF  B04,B18
08218:  MOVFF  B03,B17
0821C:  CALL   20FE
....................         mcp4901_2_write(count);
08220:  MOVFF  B04,B18
08224:  MOVFF  B03,B17
08228:  CALL   2140
....................         delay_ms(1); // wait for DAC to stabilize
0822C:  MOVLW  01
0822E:  MOVLB  B
08230:  MOVWF  xC3
08232:  MOVLB  0
08234:  CALL   1B30
.................... 
....................         // Read CIGS1 data (port1) only if still active
....................         if (port1.active) {
08238:  MOVLB  7
0823A:  BTFSC  x02.0
0823C:  BRA    8244
0823E:  MOVLB  0
08240:  GOTO   82D0
08244:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
08246:  BCF    FD8.0
08248:  MOVLB  B
0824A:  RLCF   x03,W
0824C:  MOVWF  02
0824E:  RLCF   x04,W
08250:  MOVWF  03
08252:  MOVF   02,W
08254:  ADDLW  06
08256:  MOVWF  01
08258:  MOVLW  03
0825A:  ADDWFC 03,F
0825C:  MOVF   01,W
0825E:  MOVWF  x14
08260:  MOVFF  03,B15
08264:  MOVLW  02
08266:  MOVWF  x2A
08268:  MOVLB  0
0826A:  CALL   1DA0
0826E:  MOVFF  B15,FEA
08272:  MOVFF  B14,FE9
08276:  MOVFF  02,FEC
0827A:  MOVF   FED,F
0827C:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
08280:  BCF    FD8.0
08282:  MOVLB  B
08284:  RLCF   x03,W
08286:  MOVWF  02
08288:  RLCF   x04,W
0828A:  MOVWF  03
0828C:  MOVF   02,W
0828E:  ADDLW  04
08290:  MOVWF  01
08292:  MOVLW  05
08294:  ADDWFC 03,F
08296:  MOVF   01,W
08298:  MOVWF  x14
0829A:  MOVFF  03,B15
0829E:  MOVLW  01
082A0:  MOVWF  x2A
082A2:  MOVLB  0
082A4:  CALL   1DA0
082A8:  MOVFF  B15,FEA
082AC:  MOVFF  B14,FE9
082B0:  MOVFF  02,FEC
082B4:  MOVF   FED,F
082B6:  MOVFF  01,FEF
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
082BA:  MOVLW  01
082BC:  MOVLB  B
082BE:  ADDWF  x03,W
082C0:  MOVLB  3
082C2:  MOVWF  x04
082C4:  MOVLW  00
082C6:  MOVLB  B
082C8:  ADDWFC x04,W
082CA:  MOVLB  3
082CC:  MOVWF  x05
082CE:  MOVLB  0
....................         }
....................         
....................         // Read CIGS2 data (port2) only if still active
....................         if (port2.active) {
082D0:  MOVLB  B
082D2:  BTFSC  x02.0
082D4:  BRA    82DC
082D6:  MOVLB  0
082D8:  GOTO   8430
082DC:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
082DE:  BCF    FD8.0
082E0:  MOVLB  B
082E2:  RLCF   x03,W
082E4:  MOVWF  02
082E6:  RLCF   x04,W
082E8:  MOVWF  03
082EA:  MOVF   02,W
082EC:  ADDLW  06
082EE:  MOVWF  01
082F0:  MOVLW  07
082F2:  ADDWFC 03,F
082F4:  MOVF   01,W
082F6:  MOVWF  x14
082F8:  MOVFF  03,B15
082FC:  MOVLW  06
082FE:  MOVWF  x2A
08300:  MOVLB  0
08302:  CALL   1DA0
08306:  MOVFF  B15,FEA
0830A:  MOVFF  B14,FE9
0830E:  MOVFF  02,FEC
08312:  MOVF   FED,F
08314:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
08318:  BCF    FD8.0
0831A:  MOVLB  B
0831C:  RLCF   x03,W
0831E:  MOVWF  02
08320:  RLCF   x04,W
08322:  MOVWF  03
08324:  MOVF   02,W
08326:  ADDLW  04
08328:  MOVWF  01
0832A:  MOVLW  09
0832C:  ADDWFC 03,F
0832E:  MOVF   01,W
08330:  MOVWF  x14
08332:  MOVFF  03,B15
08336:  MOVLW  05
08338:  MOVWF  x2A
0833A:  MOVLB  0
0833C:  CALL   1DA0
08340:  MOVFF  B15,FEA
08344:  MOVFF  B14,FE9
08348:  MOVFF  02,FEC
0834C:  MOVF   FED,F
0834E:  MOVFF  01,FEF
....................             fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
08352:  BCF    FD8.0
08354:  MOVLB  B
08356:  RLCF   x03,W
08358:  MOVWF  02
0835A:  RLCF   x04,W
0835C:  MOVWF  03
0835E:  MOVF   02,W
08360:  ADDLW  06
08362:  MOVWF  FE9
08364:  MOVLW  07
08366:  ADDWFC 03,W
08368:  MOVWF  FEA
0836A:  MOVFF  FEC,B15
0836E:  MOVF   FED,F
08370:  MOVFF  FEF,B14
08374:  BCF    FD8.0
08376:  RLCF   x03,W
08378:  MOVWF  02
0837A:  RLCF   x04,W
0837C:  MOVWF  03
0837E:  MOVF   02,W
08380:  ADDLW  04
08382:  MOVWF  FE9
08384:  MOVLW  09
08386:  ADDWFC 03,W
08388:  MOVWF  FEA
0838A:  MOVFF  FEC,B17
0838E:  MOVF   FED,F
08390:  MOVFF  FEF,B16
08394:  MOVLW  2A
08396:  MOVWF  FF6
08398:  MOVLW  06
0839A:  MOVWF  FF7
0839C:  MOVLW  00
0839E:  MOVWF  FF8
083A0:  MOVLW  0C
083A2:  MOVWF  x1B
083A4:  MOVLB  0
083A6:  CALL   1BE0
083AA:  MOVFF  B15,B1B
083AE:  MOVLW  37
083B0:  MOVLB  B
083B2:  MOVWF  x1C
083B4:  MOVLB  0
083B6:  CALL   1E34
083BA:  MOVFF  B14,B1B
083BE:  MOVLW  37
083C0:  MOVLB  B
083C2:  MOVWF  x1C
083C4:  MOVLB  0
083C6:  CALL   1E34
083CA:  MOVLW  2C
083CC:  MOVLB  B
083CE:  MOVWF  x6E
083D0:  MOVLB  0
083D2:  CALL   1B5E
083D6:  MOVLW  20
083D8:  MOVLB  B
083DA:  MOVWF  x6E
083DC:  MOVLB  0
083DE:  CALL   1B5E
083E2:  MOVFF  B17,B1B
083E6:  MOVLW  37
083E8:  MOVLB  B
083EA:  MOVWF  x1C
083EC:  MOVLB  0
083EE:  CALL   1E34
083F2:  MOVFF  B16,B1B
083F6:  MOVLW  37
083F8:  MOVLB  B
083FA:  MOVWF  x1C
083FC:  MOVLB  0
083FE:  CALL   1E34
08402:  MOVLW  0D
08404:  MOVLB  B
08406:  MOVWF  x6E
08408:  MOVLB  0
0840A:  CALL   1B5E
0840E:  MOVLW  0A
08410:  MOVLB  B
08412:  MOVWF  x6E
08414:  MOVLB  0
08416:  CALL   1B5E
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
0841A:  MOVLW  01
0841C:  MOVLB  B
0841E:  ADDWF  x03,W
08420:  MOVLB  7
08422:  MOVWF  x04
08424:  MOVLW  00
08426:  MOVLB  B
08428:  ADDWFC x04,W
0842A:  MOVLB  7
0842C:  MOVWF  x05
0842E:  MOVLB  0
....................         }
.................... 
....................         count++;
08430:  MOVLB  B
08432:  INCF   x03,F
08434:  BTFSC  FD8.2
08436:  INCF   x04,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
08438:  MOVF   x04,F
0843A:  BTFSC  FD8.2
0843C:  BRA    8444
0843E:  MOVLB  0
08440:  GOTO   8458
08444:  MOVLB  0
08446:  MOVLB  B
08448:  MOVF   x03,W
0844A:  SUBLW  FE
0844C:  BTFSS  FD8.0
0844E:  BRA    8456
08450:  MOVLB  0
08452:  GOTO   849C
08456:  MOVLB  0
....................             fprintf(PC, "Maximum step count reached: %ld\r\n", count);
08458:  MOVLW  46
0845A:  MOVWF  FF6
0845C:  MOVLW  06
0845E:  MOVWF  FF7
08460:  MOVLW  00
08462:  MOVWF  FF8
08464:  MOVLW  1C
08466:  MOVLB  B
08468:  MOVWF  x1B
0846A:  MOVLB  0
0846C:  CALL   1BE0
08470:  MOVLW  10
08472:  MOVWF  FE9
08474:  MOVFF  B04,B18
08478:  MOVFF  B03,B17
0847C:  GOTO   69D6
08480:  MOVLW  0D
08482:  MOVLB  B
08484:  MOVWF  x6E
08486:  MOVLB  0
08488:  CALL   1B5E
0848C:  MOVLW  0A
0848E:  MOVLB  B
08490:  MOVWF  x6E
08492:  MOVLB  0
08494:  CALL   1B5E
....................             break;
08498:  GOTO   869C
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
0849C:  MOVLB  7
0849E:  BTFSC  x02.0
084A0:  BRA    84A8
084A2:  MOVLB  0
084A4:  GOTO   859A
084A8:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
084AA:  MOVLW  01
084AC:  MOVLB  B
084AE:  SUBWF  x03,W
084B0:  MOVWF  x14
084B2:  MOVLW  00
084B4:  SUBWFB x04,W
084B6:  MOVWF  x15
084B8:  BCF    FD8.0
084BA:  RLCF   x14,W
084BC:  MOVWF  02
084BE:  RLCF   x15,W
084C0:  MOVWF  03
084C2:  MOVF   02,W
084C4:  ADDLW  04
084C6:  MOVWF  FE9
084C8:  MOVLW  05
084CA:  ADDWFC 03,W
084CC:  MOVWF  FEA
084CE:  MOVFF  FEC,B15
084D2:  MOVF   FED,F
084D4:  MOVFF  FEF,B14
084D8:  MOVF   x15,W
084DA:  MOVLB  3
084DC:  SUBWF  x02,W
084DE:  BTFSC  FD8.0
084E0:  BRA    84E8
084E2:  MOVLB  0
084E4:  GOTO   8524
084E8:  MOVLB  0
084EA:  BTFSS  FD8.2
084EC:  GOTO   8504
084F0:  MOVLB  3
084F2:  MOVF   x01,W
084F4:  MOVLB  B
084F6:  SUBWF  x14,W
084F8:  BTFSS  FD8.0
084FA:  BRA    8502
084FC:  MOVLB  0
084FE:  GOTO   8524
08502:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current limit reached:");
08504:  MOVLW  68
08506:  MOVWF  FF6
08508:  MOVLW  06
0850A:  MOVWF  FF7
0850C:  MOVLW  00
0850E:  MOVWF  FF8
08510:  CALL   1BB0
....................                 port1.active = 0;
08514:  MOVLB  7
08516:  BCF    x02.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
08518:  MOVLW  5E
0851A:  MOVWF  F94
0851C:  BCF    F8B.0
0851E:  MOVLB  0
....................             }
08520:  GOTO   859A
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
08524:  MOVLW  01
08526:  MOVLB  B
08528:  SUBWF  x03,W
0852A:  MOVWF  x14
0852C:  MOVLW  00
0852E:  SUBWFB x04,W
08530:  MOVWF  x15
08532:  BCF    FD8.0
08534:  RLCF   x14,W
08536:  MOVWF  02
08538:  RLCF   x15,W
0853A:  MOVWF  03
0853C:  MOVF   02,W
0853E:  ADDLW  04
08540:  MOVWF  FE9
08542:  MOVLW  05
08544:  ADDWFC 03,W
08546:  MOVWF  FEA
08548:  MOVFF  FEC,B15
0854C:  MOVF   FED,F
0854E:  MOVFF  FEF,B14
08552:  MOVF   x15,W
08554:  MOVLB  2
08556:  SUBWF  xFE,W
08558:  BTFSC  FD8.0
0855A:  BRA    8562
0855C:  MOVLB  0
0855E:  GOTO   859A
08562:  MOVLB  0
08564:  BTFSS  FD8.2
08566:  GOTO   857E
0856A:  MOVLB  2
0856C:  MOVF   xFD,W
0856E:  MOVLB  B
08570:  SUBWF  x14,W
08572:  BTFSS  FD8.0
08574:  BRA    857C
08576:  MOVLB  0
08578:  GOTO   859A
0857C:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current below threshold");
0857E:  MOVLW  86
08580:  MOVWF  FF6
08582:  MOVLW  06
08584:  MOVWF  FF7
08586:  MOVLW  00
08588:  MOVWF  FF8
0858A:  CALL   1BB0
....................                 port1.active = 0;
0858E:  MOVLB  7
08590:  BCF    x02.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
08592:  MOVLW  5E
08594:  MOVWF  F94
08596:  BCF    F8B.0
08598:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
0859A:  MOVLB  B
0859C:  BTFSC  x02.0
0859E:  BRA    85A6
085A0:  MOVLB  0
085A2:  GOTO   8698
085A6:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
085A8:  MOVLW  01
085AA:  MOVLB  B
085AC:  SUBWF  x03,W
085AE:  MOVWF  x14
085B0:  MOVLW  00
085B2:  SUBWFB x04,W
085B4:  MOVWF  x15
085B6:  BCF    FD8.0
085B8:  RLCF   x14,W
085BA:  MOVWF  02
085BC:  RLCF   x15,W
085BE:  MOVWF  03
085C0:  MOVF   02,W
085C2:  ADDLW  04
085C4:  MOVWF  FE9
085C6:  MOVLW  09
085C8:  ADDWFC 03,W
085CA:  MOVWF  FEA
085CC:  MOVFF  FEC,B15
085D0:  MOVF   FED,F
085D2:  MOVFF  FEF,B14
085D6:  MOVF   x15,W
085D8:  MOVLB  3
085DA:  SUBWF  x02,W
085DC:  BTFSC  FD8.0
085DE:  BRA    85E6
085E0:  MOVLB  0
085E2:  GOTO   8622
085E6:  MOVLB  0
085E8:  BTFSS  FD8.2
085EA:  GOTO   8602
085EE:  MOVLB  3
085F0:  MOVF   x01,W
085F2:  MOVLB  B
085F4:  SUBWF  x14,W
085F6:  BTFSS  FD8.0
085F8:  BRA    8600
085FA:  MOVLB  0
085FC:  GOTO   8622
08600:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current limit reached: ");
08602:  MOVLW  A4
08604:  MOVWF  FF6
08606:  MOVLW  06
08608:  MOVWF  FF7
0860A:  MOVLW  00
0860C:  MOVWF  FF8
0860E:  CALL   1BB0
....................                 port2.active = 0;
08612:  MOVLB  B
08614:  BCF    x02.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08616:  MOVLW  5E
08618:  MOVWF  F94
0861A:  BCF    F8B.5
0861C:  MOVLB  0
....................             }
0861E:  GOTO   8698
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
08622:  MOVLW  01
08624:  MOVLB  B
08626:  SUBWF  x03,W
08628:  MOVWF  x14
0862A:  MOVLW  00
0862C:  SUBWFB x04,W
0862E:  MOVWF  x15
08630:  BCF    FD8.0
08632:  RLCF   x14,W
08634:  MOVWF  02
08636:  RLCF   x15,W
08638:  MOVWF  03
0863A:  MOVF   02,W
0863C:  ADDLW  04
0863E:  MOVWF  FE9
08640:  MOVLW  09
08642:  ADDWFC 03,W
08644:  MOVWF  FEA
08646:  MOVFF  FEC,B15
0864A:  MOVF   FED,F
0864C:  MOVFF  FEF,B14
08650:  MOVF   x15,W
08652:  MOVLB  2
08654:  SUBWF  xFE,W
08656:  BTFSC  FD8.0
08658:  BRA    8660
0865A:  MOVLB  0
0865C:  GOTO   8698
08660:  MOVLB  0
08662:  BTFSS  FD8.2
08664:  GOTO   867C
08668:  MOVLB  2
0866A:  MOVF   xFD,W
0866C:  MOVLB  B
0866E:  SUBWF  x14,W
08670:  BTFSS  FD8.0
08672:  BRA    867A
08674:  MOVLB  0
08676:  GOTO   8698
0867A:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current below threshold:");
0867C:  MOVLW  C2
0867E:  MOVWF  FF6
08680:  MOVLW  06
08682:  MOVWF  FF7
08684:  MOVLW  00
08686:  MOVWF  FF8
08688:  CALL   1BB0
....................                 port2.active = 0;
0868C:  MOVLB  B
0868E:  BCF    x02.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08690:  MOVLW  5E
08692:  MOVWF  F94
08694:  BCF    F8B.5
08696:  MOVLB  0
....................             }
....................         }
08698:  GOTO   81F8
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
0869C:  MOVLW  5E
0869E:  MOVWF  F94
086A0:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
086A2:  MOVLW  5E
086A4:  MOVWF  F94
086A6:  BCF    F8B.5
....................     // output_high(EN_NPWR);
.................... 
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
086A8:  MOVLW  0B
086AA:  MOVLB  B
086AC:  MOVWF  x18
086AE:  MOVLW  05
086B0:  MOVWF  x17
086B2:  MOVLW  03
086B4:  MOVWF  x1A
086B6:  MOVLW  03
086B8:  MOVWF  x19
086BA:  MOVLB  0
086BC:  CALL   6B60
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
086C0:  MOVLW  0B
086C2:  MOVLB  B
086C4:  MOVWF  x18
086C6:  MOVLW  05
086C8:  MOVWF  x17
086CA:  MOVLW  07
086CC:  MOVWF  x1A
086CE:  MOVLW  03
086D0:  MOVWF  x19
086D2:  MOVLB  0
086D4:  CALL   6B60
.................... 
....................     fprintf(PC, "End SWEEP with threshold\r\n");
086D8:  MOVLW  E2
086DA:  MOVWF  FF6
086DC:  MOVLW  06
086DE:  MOVWF  FF7
086E0:  MOVLW  00
086E2:  MOVWF  FF8
086E4:  CALL   1BB0
086E8:  GOTO   8CAC (RETURN)
.................... }
.................... 
.................... 
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data)
*
06BE2:  CLRF   x5B
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
*
06B60:  MOVLB  B
06B62:  CLRF   x1B
06B64:  CLRF   x1C
06B66:  CLRF   x1D
06B68:  CLRF   x1E
06B6A:  CLRF   x1F
06B6C:  CLRF   x20
06B6E:  CLRF   x21
06B70:  CLRF   x22
06B72:  CLRF   x23
06B74:  CLRF   x24
06B76:  CLRF   x25
06B78:  CLRF   x26
06B7A:  CLRF   x27
06B7C:  CLRF   x28
06B7E:  CLRF   x29
06B80:  CLRF   x2A
06B82:  CLRF   x2B
06B84:  CLRF   x2C
06B86:  CLRF   x2D
06B88:  CLRF   x2E
06B8A:  CLRF   x2F
06B8C:  CLRF   x30
06B8E:  CLRF   x31
06B90:  CLRF   x32
06B92:  CLRF   x33
06B94:  CLRF   x34
06B96:  CLRF   x35
06B98:  CLRF   x36
06B9A:  CLRF   x37
06B9C:  CLRF   x38
06B9E:  CLRF   x39
06BA0:  CLRF   x3A
06BA2:  CLRF   x3B
06BA4:  CLRF   x3C
06BA6:  CLRF   x3D
06BA8:  CLRF   x3E
06BAA:  CLRF   x3F
06BAC:  CLRF   x40
06BAE:  CLRF   x41
06BB0:  CLRF   x42
06BB2:  CLRF   x43
06BB4:  CLRF   x44
06BB6:  CLRF   x45
06BB8:  CLRF   x46
06BBA:  CLRF   x47
06BBC:  CLRF   x48
06BBE:  CLRF   x49
06BC0:  CLRF   x4A
06BC2:  CLRF   x4B
06BC4:  CLRF   x4C
06BC6:  CLRF   x4D
06BC8:  CLRF   x4E
06BCA:  CLRF   x4F
06BCC:  CLRF   x50
06BCE:  CLRF   x51
06BD0:  CLRF   x52
06BD2:  CLRF   x53
06BD4:  CLRF   x54
06BD6:  CLRF   x55
06BD8:  CLRF   x56
06BDA:  CLRF   x57
06BDC:  CLRF   x58
06BDE:  CLRF   x59
06BE0:  CLRF   x5A
....................     unsigned int8 packetdata_index = 0; // Index for packet data
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
06BE4:  SETF   x1B
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data->port_num & 0x0F);
06BE6:  MOVF   x19,W
06BE8:  MOVWF  FE9
06BEA:  MOVF   x1A,W
06BEC:  MOVWF  FEA
06BEE:  MOVF   FEF,W
06BF0:  ANDLW  0F
06BF2:  IORLW  F0
06BF4:  MOVWF  x1C
....................     packetdata[2] = measured_data->time_sec >> 24 & 0xFF;
06BF6:  MOVF   x17,W
06BF8:  MOVWF  FE9
06BFA:  MOVF   x18,W
06BFC:  MOVWF  FEA
06BFE:  MOVFF  FEF,B6B
06C02:  MOVFF  FEC,B6C
06C06:  MOVFF  FEC,B6D
06C0A:  MOVFF  FEC,B6E
06C0E:  MOVF   FED,F
06C10:  MOVF   FED,F
06C12:  MOVF   FED,F
06C14:  MOVFF  B6E,B6B
06C18:  CLRF   x6C
06C1A:  CLRF   x6D
06C1C:  CLRF   x6E
06C1E:  MOVF   x6B,W
06C20:  MOVWF  x1D
....................     packetdata[3] = measured_data->time_sec >> 16 & 0xFF;
06C22:  MOVF   x17,W
06C24:  MOVWF  FE9
06C26:  MOVF   x18,W
06C28:  MOVWF  FEA
06C2A:  MOVFF  FEF,B6B
06C2E:  MOVFF  FEC,B6C
06C32:  MOVFF  FEC,B6D
06C36:  MOVFF  FEC,B6E
06C3A:  MOVF   FED,F
06C3C:  MOVF   FED,F
06C3E:  MOVF   FED,F
06C40:  MOVFF  B6D,B6B
06C44:  MOVFF  B6E,B6C
06C48:  CLRF   x6D
06C4A:  CLRF   x6E
06C4C:  MOVF   x6B,W
06C4E:  MOVWF  x1E
....................     packetdata[4] = measured_data->time_sec >> 8 & 0xFF;
06C50:  MOVF   x17,W
06C52:  MOVWF  FE9
06C54:  MOVF   x18,W
06C56:  MOVWF  FEA
06C58:  MOVFF  FEF,B6B
06C5C:  MOVFF  FEC,B6C
06C60:  MOVFF  FEC,B6D
06C64:  MOVFF  FEC,B6E
06C68:  MOVF   FED,F
06C6A:  MOVF   FED,F
06C6C:  MOVF   FED,F
06C6E:  MOVFF  B6C,B6B
06C72:  MOVFF  B6D,B6C
06C76:  MOVFF  B6E,B6D
06C7A:  CLRF   x6E
06C7C:  MOVF   x6B,W
06C7E:  MOVWF  x1F
....................     packetdata[5] = measured_data->time_sec & 0xFF;
06C80:  MOVF   x17,W
06C82:  MOVWF  FE9
06C84:  MOVF   x18,W
06C86:  MOVWF  FEA
06C88:  MOVFF  FEF,B6B
06C8C:  MOVFF  FEC,B6C
06C90:  MOVFF  FEC,B6D
06C94:  MOVFF  FEC,B6E
06C98:  MOVF   FED,F
06C9A:  MOVF   FED,F
06C9C:  MOVF   FED,F
06C9E:  MOVF   x6B,W
06CA0:  MOVWF  x20
....................     packetdata[6] = (measured_data->time_msec & 0x0F) >>4 | measured_data->pd >> 8 & 0x0F;
06CA2:  MOVLW  04
06CA4:  ADDWF  x17,W
06CA6:  MOVWF  FE9
06CA8:  MOVLW  00
06CAA:  ADDWFC x18,W
06CAC:  MOVWF  FEA
06CAE:  MOVF   FEF,W
06CB0:  ANDLW  0F
06CB2:  MOVWF  00
06CB4:  SWAPF  00,W
06CB6:  MOVWF  x6B
06CB8:  MOVLW  0F
06CBA:  ANDWF  x6B,F
06CBC:  MOVLW  0D
06CBE:  ADDWF  x17,W
06CC0:  MOVWF  FE9
06CC2:  MOVLW  00
06CC4:  ADDWFC x18,W
06CC6:  MOVWF  FEA
06CC8:  MOVFF  FEC,B6D
06CCC:  MOVF   FED,F
06CCE:  MOVFF  FEF,B6C
06CD2:  MOVFF  B6D,B6C
06CD6:  CLRF   x6D
06CD8:  MOVF   x6C,W
06CDA:  ANDLW  0F
06CDC:  MOVWF  00
06CDE:  CLRF   03
06CE0:  MOVF   00,W
06CE2:  IORWF  x6B,W
06CE4:  MOVWF  x21
....................     packetdata[7] = measured_data->pd & 0xFF;
06CE6:  MOVLW  0D
06CE8:  ADDWF  x17,W
06CEA:  MOVWF  FE9
06CEC:  MOVLW  00
06CEE:  ADDWFC x18,W
06CF0:  MOVWF  FEA
06CF2:  MOVFF  FEC,B6C
06CF6:  MOVF   FED,F
06CF8:  MOVFF  FEF,B6B
06CFC:  MOVF   x6B,W
06CFE:  MOVWF  x22
....................     packetdata[8] = (measured_data->open_voltage >> 4) & 0xFF; // PD start low byte
06D00:  MOVLW  05
06D02:  ADDWF  x17,W
06D04:  MOVWF  FE9
06D06:  MOVLW  00
06D08:  ADDWFC x18,W
06D0A:  MOVWF  FEA
06D0C:  MOVFF  FEC,B6C
06D10:  MOVF   FED,F
06D12:  MOVFF  FEF,B6B
06D16:  RRCF   x6C,F
06D18:  RRCF   x6B,F
06D1A:  RRCF   x6C,F
06D1C:  RRCF   x6B,F
06D1E:  RRCF   x6C,F
06D20:  RRCF   x6B,F
06D22:  RRCF   x6C,F
06D24:  RRCF   x6B,F
06D26:  MOVLW  0F
06D28:  ANDWF  x6C,F
06D2A:  MOVF   x6B,W
06D2C:  MOVWF  x23
....................     packetdata[9] = (measured_data->open_voltage & 0x0F) << 4 | (measured_data->temp_py_top >> 8) & 0x0F;
06D2E:  MOVLW  05
06D30:  ADDWF  x17,W
06D32:  MOVWF  FE9
06D34:  MOVLW  00
06D36:  ADDWFC x18,W
06D38:  MOVWF  FEA
06D3A:  MOVFF  FEC,B6C
06D3E:  MOVF   FED,F
06D40:  MOVFF  FEF,B6B
06D44:  MOVLW  0F
06D46:  ANDWF  x6B,F
06D48:  CLRF   x6C
06D4A:  RLCF   x6B,F
06D4C:  RLCF   x6C,F
06D4E:  RLCF   x6B,F
06D50:  RLCF   x6C,F
06D52:  RLCF   x6B,F
06D54:  RLCF   x6C,F
06D56:  RLCF   x6B,F
06D58:  RLCF   x6C,F
06D5A:  MOVLW  F0
06D5C:  ANDWF  x6B,F
06D5E:  MOVLW  07
06D60:  ADDWF  x17,W
06D62:  MOVWF  FE9
06D64:  MOVLW  00
06D66:  ADDWFC x18,W
06D68:  MOVWF  FEA
06D6A:  MOVFF  FEC,B6E
06D6E:  MOVF   FED,F
06D70:  MOVFF  FEF,B6D
06D74:  MOVFF  B6E,B6D
06D78:  CLRF   x6E
06D7A:  MOVF   x6D,W
06D7C:  ANDLW  0F
06D7E:  MOVWF  00
06D80:  CLRF   03
06D82:  MOVF   00,W
06D84:  IORWF  x6B,W
06D86:  MOVWF  x24
....................     packetdata[10] = measured_data->temp_py_top & 0xFF;
06D88:  MOVLW  07
06D8A:  ADDWF  x17,W
06D8C:  MOVWF  FE9
06D8E:  MOVLW  00
06D90:  ADDWFC x18,W
06D92:  MOVWF  FEA
06D94:  MOVFF  FEC,B6C
06D98:  MOVF   FED,F
06D9A:  MOVFF  FEF,B6B
06D9E:  MOVF   x6B,W
06DA0:  MOVWF  x25
....................     packetdata[11] = (measured_data->temp_py_bot >> 4) & 0xFF; // PD start low byte
06DA2:  MOVLW  09
06DA4:  ADDWF  x17,W
06DA6:  MOVWF  FE9
06DA8:  MOVLW  00
06DAA:  ADDWFC x18,W
06DAC:  MOVWF  FEA
06DAE:  MOVFF  FEC,B6C
06DB2:  MOVF   FED,F
06DB4:  MOVFF  FEF,B6B
06DB8:  RRCF   x6C,F
06DBA:  RRCF   x6B,F
06DBC:  RRCF   x6C,F
06DBE:  RRCF   x6B,F
06DC0:  RRCF   x6C,F
06DC2:  RRCF   x6B,F
06DC4:  RRCF   x6C,F
06DC6:  RRCF   x6B,F
06DC8:  MOVLW  0F
06DCA:  ANDWF  x6C,F
06DCC:  MOVF   x6B,W
06DCE:  MOVWF  x26
....................     packetdata[12] = (measured_data->temp_py_bot & 0x0F) << 4 | (measured_data->temp_mis7 >> 8) & 0x0F;
06DD0:  MOVLW  09
06DD2:  ADDWF  x17,W
06DD4:  MOVWF  FE9
06DD6:  MOVLW  00
06DD8:  ADDWFC x18,W
06DDA:  MOVWF  FEA
06DDC:  MOVFF  FEC,B6C
06DE0:  MOVF   FED,F
06DE2:  MOVFF  FEF,B6B
06DE6:  MOVLW  0F
06DE8:  ANDWF  x6B,F
06DEA:  CLRF   x6C
06DEC:  RLCF   x6B,F
06DEE:  RLCF   x6C,F
06DF0:  RLCF   x6B,F
06DF2:  RLCF   x6C,F
06DF4:  RLCF   x6B,F
06DF6:  RLCF   x6C,F
06DF8:  RLCF   x6B,F
06DFA:  RLCF   x6C,F
06DFC:  MOVLW  F0
06DFE:  ANDWF  x6B,F
06E00:  MOVLW  0B
06E02:  ADDWF  x17,W
06E04:  MOVWF  FE9
06E06:  MOVLW  00
06E08:  ADDWFC x18,W
06E0A:  MOVWF  FEA
06E0C:  MOVFF  FEC,B6E
06E10:  MOVF   FED,F
06E12:  MOVFF  FEF,B6D
06E16:  MOVFF  B6E,B6D
06E1A:  CLRF   x6E
06E1C:  MOVF   x6D,W
06E1E:  ANDLW  0F
06E20:  MOVWF  00
06E22:  CLRF   03
06E24:  MOVF   00,W
06E26:  IORWF  x6B,W
06E28:  MOVWF  x27
....................     packetdata[13] = measured_data->temp_mis7 & 0xFF;
06E2A:  MOVLW  0B
06E2C:  ADDWF  x17,W
06E2E:  MOVWF  FE9
06E30:  MOVLW  00
06E32:  ADDWFC x18,W
06E34:  MOVWF  FEA
06E36:  MOVFF  FEC,B6C
06E3A:  MOVF   FED,F
06E3C:  MOVFF  FEF,B6B
06E40:  MOVF   x6B,W
06E42:  MOVWF  x28
.................... 
....................     packetdata_index = 14; // Start index for data
06E44:  MOVLW  0E
06E46:  MOVWF  x5B
.................... 
....................     for (unsigned int16 i = 0; i < port_data->sweep_step ; i++) {
06E48:  CLRF   x5D
06E4A:  CLRF   x5C
06E4C:  MOVLB  0
06E4E:  MOVLW  01
06E50:  MOVLB  B
06E52:  ADDWF  x19,W
06E54:  MOVWF  FE9
06E56:  MOVLW  00
06E58:  ADDWFC x1A,W
06E5A:  MOVWF  FEA
06E5C:  MOVFF  FEC,03
06E60:  MOVF   FED,F
06E62:  MOVF   FEF,W
06E64:  MOVWF  01
06E66:  MOVF   x5D,W
06E68:  SUBWF  03,W
06E6A:  BTFSC  FD8.0
06E6C:  BRA    6E74
06E6E:  MOVLB  0
06E70:  GOTO   704A
06E74:  MOVLB  0
06E76:  BTFSS  FD8.2
06E78:  GOTO   6E8E
06E7C:  MOVF   01,W
06E7E:  MOVLB  B
06E80:  SUBWF  x5C,W
06E82:  BTFSS  FD8.0
06E84:  BRA    6E8C
06E86:  MOVLB  0
06E88:  GOTO   704A
06E8C:  MOVLB  0
....................         unsigned int16 data0 = port_data->data_buffer[0][i];
....................         unsigned int16 data1 = port_data->data_buffer[1][i];
06E8E:  BCF    FD8.0
06E90:  MOVLB  B
06E92:  RLCF   x5C,W
06E94:  MOVWF  02
06E96:  RLCF   x5D,W
06E98:  MOVWF  03
06E9A:  MOVF   02,W
06E9C:  ADDLW  03
06E9E:  MOVWF  01
06EA0:  MOVLW  00
06EA2:  ADDWFC 03,F
06EA4:  MOVF   01,W
06EA6:  ADDWF  x19,W
06EA8:  MOVWF  FE9
06EAA:  MOVF   x1A,W
06EAC:  ADDWFC 03,W
06EAE:  MOVWF  FEA
06EB0:  MOVFF  FEC,B5F
06EB4:  MOVF   FED,F
06EB6:  MOVFF  FEF,B5E
06EBA:  BCF    FD8.0
06EBC:  RLCF   x5C,W
06EBE:  MOVWF  02
06EC0:  RLCF   x5D,W
06EC2:  MOVWF  03
06EC4:  MOVF   02,W
06EC6:  ADDLW  01
06EC8:  MOVWF  01
06ECA:  MOVLW  02
06ECC:  ADDWFC 03,F
06ECE:  MOVF   01,W
06ED0:  ADDWF  x19,W
06ED2:  MOVWF  FE9
06ED4:  MOVF   x1A,W
06ED6:  ADDWFC 03,W
06ED8:  MOVWF  FEA
06EDA:  MOVFF  FEC,B61
06EDE:  MOVF   FED,F
06EE0:  MOVFF  FEF,B60
06EE4:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
06EE6:  MOVLB  B
06EE8:  MOVF   x5B,W
06EEA:  INCF   x5B,F
06EEC:  CLRF   03
06EEE:  ADDLW  1B
06EF0:  MOVWF  FE9
06EF2:  MOVLW  0B
06EF4:  ADDWFC 03,W
06EF6:  MOVWF  FEA
06EF8:  RRCF   x5F,W
06EFA:  MOVWF  x6E
06EFC:  RRCF   x5E,W
06EFE:  MOVWF  x6D
06F00:  RRCF   x6E,F
06F02:  RRCF   x6D,F
06F04:  RRCF   x6E,F
06F06:  RRCF   x6D,F
06F08:  RRCF   x6E,F
06F0A:  RRCF   x6D,F
06F0C:  MOVLW  0F
06F0E:  ANDWF  x6E,F
06F10:  MOVF   x6D,W
06F12:  MOVWF  00
06F14:  CLRF   03
06F16:  MOVF   00,W
06F18:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
06F1A:  MOVF   x5B,W
06F1C:  INCF   x5B,F
06F1E:  CLRF   03
06F20:  ADDLW  1B
06F22:  MOVWF  FE9
06F24:  MOVLW  0B
06F26:  ADDWFC 03,W
06F28:  MOVWF  FEA
06F2A:  MOVF   x5E,W
06F2C:  ANDLW  0F
06F2E:  MOVWF  x6D
06F30:  CLRF   x6E
06F32:  RLCF   x6D,F
06F34:  RLCF   x6E,F
06F36:  RLCF   x6D,F
06F38:  RLCF   x6E,F
06F3A:  RLCF   x6D,F
06F3C:  RLCF   x6E,F
06F3E:  RLCF   x6D,F
06F40:  RLCF   x6E,F
06F42:  MOVLW  F0
06F44:  ANDWF  x6D,F
06F46:  MOVFF  B61,B6F
06F4A:  CLRF   x70
06F4C:  MOVF   x6F,W
06F4E:  ANDLW  0F
06F50:  MOVWF  00
06F52:  CLRF   03
06F54:  MOVF   00,W
06F56:  IORWF  x6D,W
06F58:  MOVWF  00
06F5A:  MOVF   03,W
06F5C:  IORWF  x6E,W
06F5E:  MOVWF  03
06F60:  MOVF   00,W
06F62:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
06F64:  MOVF   x5B,W
06F66:  INCF   x5B,F
06F68:  CLRF   03
06F6A:  ADDLW  1B
06F6C:  MOVWF  FE9
06F6E:  MOVLW  0B
06F70:  ADDWFC 03,W
06F72:  MOVWF  FEA
06F74:  MOVF   x60,W
06F76:  MOVWF  00
06F78:  CLRF   03
06F7A:  MOVF   00,W
06F7C:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
06F7E:  MOVLW  03
06F80:  ADDWF  x5B,W
06F82:  SUBLW  3E
06F84:  BTFSS  FD8.0
06F86:  BRA    6F8E
06F88:  MOVLB  0
06F8A:  GOTO   703C
06F8E:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
06F90:  MOVLW  0B
06F92:  MOVLB  C
06F94:  MOVWF  x03
06F96:  MOVLW  1B
06F98:  MOVWF  x02
06F9A:  MOVLW  3F
06F9C:  MOVWF  x04
06F9E:  MOVLB  0
06FA0:  CALL   29AA
06FA4:  MOVFF  01,B5A
....................             unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
06FA8:  MOVLB  2
06FAA:  MOVF   x90,W
06FAC:  MOVLB  B
06FAE:  MOVWF  x62
06FB0:  MOVLB  2
06FB2:  MOVF   x91,W
06FB4:  MOVLB  B
06FB6:  MOVWF  x63
06FB8:  MOVLW  04
06FBA:  MOVLB  2
06FBC:  ADDWF  x92,W
06FBE:  MOVLB  B
06FC0:  MOVWF  x64
06FC2:  MOVLW  00
06FC4:  MOVLB  2
06FC6:  ADDWFC x93,W
06FC8:  MOVLB  B
06FCA:  MOVWF  x65
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
06FCC:  MOVFF  261,BAE
06FD0:  MOVFF  260,BAD
06FD4:  MOVFF  25F,BAC
06FD8:  MOVFF  25E,BAB
06FDC:  MOVFF  B65,BB2
06FE0:  MOVFF  B64,BB1
06FE4:  MOVFF  B63,BB0
06FE8:  MOVFF  B62,BAF
06FEC:  MOVLW  0B
06FEE:  MOVWF  xB4
06FF0:  MOVLW  1B
06FF2:  MOVWF  xB3
06FF4:  CLRF   xB6
06FF6:  MOVLW  40
06FF8:  MOVWF  xB5
06FFA:  MOVLB  0
06FFC:  CALL   367E
....................             iv_data.used_counter += PACKET_SIZE;
07000:  MOVLW  40
07002:  MOVLB  2
07004:  ADDWF  x90,F
07006:  MOVLW  00
07008:  ADDWFC x91,F
0700A:  MOVLW  00
0700C:  ADDWFC x92,F
0700E:  MOVLW  00
07010:  ADDWFC x93,F
....................             iv_data.uncopied_counter += PACKET_SIZE;
07012:  MOVLW  40
07014:  ADDWF  x94,F
07016:  MOVLW  00
07018:  ADDWFC x95,F
0701A:  MOVLW  00
0701C:  ADDWFC x96,F
0701E:  MOVLW  00
07020:  ADDWFC x97,F
....................             packetdata_index = 0;
07022:  MOVLB  B
07024:  CLRF   x5B
....................             memset(packetdata, 0x00, PACKET_SIZE);
07026:  MOVLW  0B
07028:  MOVWF  FEA
0702A:  MOVLW  1B
0702C:  MOVWF  FE9
0702E:  CLRF   00
07030:  CLRF   02
07032:  MOVLW  40
07034:  MOVWF  01
07036:  MOVLB  0
07038:  CALL   3A02
....................         }
0703C:  MOVLB  B
0703E:  INCF   x5C,F
07040:  BTFSC  FD8.2
07042:  INCF   x5D,F
07044:  MOVLB  0
07046:  GOTO   6E4E
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
0704A:  MOVLB  B
0704C:  MOVF   x5B,F
0704E:  BTFSS  FD8.2
07050:  BRA    7058
07052:  MOVLB  0
07054:  GOTO   7122
07058:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
0705A:  MOVFF  B5B,B66
0705E:  MOVLB  B
07060:  MOVF   x66,W
07062:  SUBLW  3E
07064:  BTFSC  FD8.0
07066:  BRA    706E
07068:  MOVLB  0
0706A:  GOTO   708E
0706E:  MOVLB  0
....................             packetdata[j] = 0x00;
07070:  CLRF   03
07072:  MOVLB  B
07074:  MOVF   x66,W
07076:  ADDLW  1B
07078:  MOVWF  FE9
0707A:  MOVLW  0B
0707C:  ADDWFC 03,W
0707E:  MOVWF  FEA
07080:  CLRF   FEF
07082:  MOVLB  0
07084:  MOVLB  B
07086:  INCF   x66,F
07088:  MOVLB  0
0708A:  GOTO   705E
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
0708E:  MOVLW  0B
07090:  MOVLB  C
07092:  MOVWF  x03
07094:  MOVLW  1B
07096:  MOVWF  x02
07098:  MOVLW  3F
0709A:  MOVWF  x04
0709C:  MOVLB  0
0709E:  CALL   29AA
070A2:  MOVFF  01,B5A
....................         unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
070A6:  MOVLB  2
070A8:  MOVF   x90,W
070AA:  MOVLB  B
070AC:  MOVWF  x67
070AE:  MOVLB  2
070B0:  MOVF   x91,W
070B2:  MOVLB  B
070B4:  MOVWF  x68
070B6:  MOVLW  04
070B8:  MOVLB  2
070BA:  ADDWF  x92,W
070BC:  MOVLB  B
070BE:  MOVWF  x69
070C0:  MOVLW  00
070C2:  MOVLB  2
070C4:  ADDWFC x93,W
070C6:  MOVLB  B
070C8:  MOVWF  x6A
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
070CA:  MOVFF  261,BAE
070CE:  MOVFF  260,BAD
070D2:  MOVFF  25F,BAC
070D6:  MOVFF  25E,BAB
070DA:  MOVFF  B6A,BB2
070DE:  MOVFF  B69,BB1
070E2:  MOVFF  B68,BB0
070E6:  MOVFF  B67,BAF
070EA:  MOVLW  0B
070EC:  MOVWF  xB4
070EE:  MOVLW  1B
070F0:  MOVWF  xB3
070F2:  CLRF   xB6
070F4:  MOVLW  40
070F6:  MOVWF  xB5
070F8:  MOVLB  0
070FA:  CALL   367E
....................         iv_data.used_counter += PACKET_SIZE;
070FE:  MOVLW  40
07100:  MOVLB  2
07102:  ADDWF  x90,F
07104:  MOVLW  00
07106:  ADDWFC x91,F
07108:  MOVLW  00
0710A:  ADDWFC x92,F
0710C:  MOVLW  00
0710E:  ADDWFC x93,F
....................         iv_data.uncopied_counter += PACKET_SIZE;
07110:  MOVLW  40
07112:  ADDWF  x94,F
07114:  MOVLW  00
07116:  ADDWFC x95,F
07118:  MOVLW  00
0711A:  ADDWFC x96,F
0711C:  MOVLW  00
0711E:  ADDWFC x97,F
07120:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "End CIGS data conversion\r\n");
07122:  MOVLW  FE
07124:  MOVWF  FF6
07126:  MOVLW  06
07128:  MOVWF  FF7
0712A:  MOVLW  00
0712C:  MOVWF  FF8
0712E:  CALL   1BB0
....................     write_misf_address_area(); // Write the mission flash address area
07132:  CALL   3D6C
07136:  RETURN 0
.................... }
.................... 
.................... MEASUREMENT_DATA create_meas_data()
.................... {
....................     MEASUREMENT_DATA data;
....................     data.time_sec = get_current_sec();
*
0694C:  CALL   3360
06950:  MOVFF  03,B1E
06954:  MOVFF  02,B1D
06958:  MOVFF  01,B1C
0695C:  MOVFF  00,B1B
....................     data.time_msec = get_current_msec();
06960:  GOTO   691C
06964:  MOVFF  01,B1F
....................     data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
06968:  MOVLW  0D
0696A:  MOVLB  B
0696C:  MOVWF  x2A
0696E:  MOVLB  0
06970:  CALL   1DA0
06974:  MOVFF  02,B23
06978:  MOVFF  01,B22
....................     data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
0697C:  MOVLW  0E
0697E:  MOVLB  B
06980:  MOVWF  x2A
06982:  MOVLB  0
06984:  CALL   1DA0
06988:  MOVFF  02,B25
0698C:  MOVFF  01,B24
....................     data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
06990:  MOVLW  0C
06992:  MOVLB  B
06994:  MOVWF  x2A
06996:  MOVLB  0
06998:  CALL   1DA0
0699C:  MOVFF  02,B27
069A0:  MOVFF  01,B26
....................     data.pd = ad7490_read(ADC_PD);
069A4:  MOVLW  0F
069A6:  MOVLB  B
069A8:  MOVWF  x2A
069AA:  MOVLB  0
069AC:  CALL   1DA0
069B0:  MOVFF  02,B29
069B4:  MOVFF  01,B28
....................     data.open_voltage = ad7490_read(ADC_CIGS1_VOLT); // Assuming this is the correct ADC channel for open voltage
069B8:  MOVLB  B
069BA:  CLRF   x2A
069BC:  MOVLB  0
069BE:  CALL   1DA0
069C2:  MOVFF  02,B21
069C6:  MOVFF  01,B20
....................     return data;
069CA:  MOVLW  1B
069CC:  MOVWF  01
069CE:  MOVLW  0B
069D0:  MOVWF  02
069D2:  GOTO   81D6 (RETURN)
.................... }
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/mcu/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../storage/mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
.................... {
....................     PICLOG_t piclog;
....................     piclog.fields.time = get_current_sec();
*
03DC2:  CALL   3360
03DC6:  MOVFF  03,337
03DCA:  MOVFF  02,336
03DCE:  MOVFF  01,335
03DD2:  MOVFF  00,334
....................     piclog.fields.function = function;
03DD6:  MOVFF  332,338
....................     piclog.fields.parameter = parameter;
03DDA:  MOVFF  333,339
.................... 
....................     #ifdef PICLOG_DEBUG
....................         printf("[PICLOG] : ");
....................         for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
....................             printf("%02X ", piclog.bytes[i]);
....................         }
....................         printf("\r\n");
....................     #endif
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
03DDE:  MOVLB  2
03DE0:  MOVF   x6F,W
03DE2:  MOVLB  3
03DE4:  MOVWF  x3A
03DE6:  MOVLB  2
03DE8:  MOVF   x70,W
03DEA:  MOVLB  3
03DEC:  MOVWF  x3B
03DEE:  MOVLW  01
03DF0:  MOVLB  2
03DF2:  ADDWF  x71,W
03DF4:  MOVLB  3
03DF6:  MOVWF  x3C
03DF8:  MOVLW  00
03DFA:  MOVLB  2
03DFC:  ADDWFC x72,W
03DFE:  MOVLB  3
03E00:  MOVWF  x3D
....................     write_data_bytes(mis_fm, (int32)write_address, piclog.bytes, (int16)PICLOG_PACKET_SIZE);
03E02:  MOVFF  261,BAE
03E06:  MOVFF  260,BAD
03E0A:  MOVFF  25F,BAC
03E0E:  MOVFF  25E,BAB
03E12:  MOVFF  33D,BB2
03E16:  MOVFF  33C,BB1
03E1A:  MOVFF  33B,BB0
03E1E:  MOVFF  33A,BAF
03E22:  MOVLW  03
03E24:  MOVLB  B
03E26:  MOVWF  xB4
03E28:  MOVLW  34
03E2A:  MOVWF  xB3
03E2C:  CLRF   xB6
03E2E:  MOVLW  06
03E30:  MOVWF  xB5
03E32:  MOVLB  0
03E34:  CALL   367E
.................... 
....................     // 統合管理システムでカウンタを更新
....................     write_misf_address_area();
03E38:  CALL   3D6C
.................... 
....................     // Next Packet
....................     if (piclog_data.reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
03E3C:  MOVLW  06
03E3E:  MOVLB  2
03E40:  ADDWF  x77,W
03E42:  SUBLW  3F
03E44:  BTFSS  FD8.0
03E46:  BRA    3E4E
03E48:  MOVLB  0
03E4A:  GOTO   3EB0
03E4E:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
03E50:  MOVLB  2
03E52:  MOVF   x6F,W
03E54:  MOVLB  3
03E56:  MOVWF  x3A
03E58:  MOVLB  2
03E5A:  MOVF   x70,W
03E5C:  MOVLB  3
03E5E:  MOVWF  x3B
03E60:  MOVLW  01
03E62:  MOVLB  2
03E64:  ADDWF  x71,W
03E66:  MOVLB  3
03E68:  MOVWF  x3C
03E6A:  MOVLW  00
03E6C:  MOVLB  2
03E6E:  ADDWFC x72,W
03E70:  MOVLB  3
03E72:  MOVWF  x3D
....................         write_data_bytes(mis_fm, (int32)write_address, PICLOG_BLANK_DATA, (int16)PICLOG_PACKET_SIZE);
03E74:  MOVFF  261,BAE
03E78:  MOVFF  260,BAD
03E7C:  MOVFF  25F,BAC
03E80:  MOVFF  25E,BAB
03E84:  MOVFF  33D,BB2
03E88:  MOVFF  33C,BB1
03E8C:  MOVFF  33B,BB0
03E90:  MOVFF  33A,BAF
03E94:  MOVLW  02
03E96:  MOVLB  B
03E98:  MOVWF  xB4
03E9A:  MOVLW  9A
03E9C:  MOVWF  xB3
03E9E:  CLRF   xB6
03EA0:  MOVLW  06
03EA2:  MOVWF  xB5
03EA4:  MOVLB  0
03EA6:  CALL   367E
....................         piclog_data.reserve_counter1 = 0;
03EAA:  MOVLB  2
03EAC:  CLRF   x77
03EAE:  MOVLB  0
....................     }
.................... 
....................     write_misf_address_area(); // Update the address area after writing
03EB0:  CALL   3D6C
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
....................     #ifdef PICLOG_DEBUG
03EB4:  RETURN 0
....................         //fprintf(PC, "PICLOG written: %02X %02X %02X %02X %02X %02X\r\n", piclog_data.bytes[0], data[1], data[2], data[3], data[4], data[5]);
....................     #endif
.................... }
.................... 
.................... #include "../core/storage/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... #include "../../../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_MEASURE_DATA_START_ADDRESS 0x06AA1000
.................... #define CIGS_MEASURE_DATA_END_ADDRESS 0x07AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x07AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x07AA1FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
09456:  MOVLB  3
09458:  MOVF   xB3,W
0945A:  MOVWF  01
0945C:  MOVF   xB4,W
0945E:  MOVWF  03
09460:  MOVF   01,W
09462:  MOVWF  xB6
09464:  MOVFF  03,3B7
09468:  MOVFF  265,438
0946C:  MOVFF  264,437
09470:  MOVFF  263,436
09474:  MOVFF  262,435
09478:  MOVLW  06
0947A:  MOVLB  4
0947C:  MOVWF  x3C
0947E:  MOVLW  AA
09480:  MOVWF  x3B
09482:  CLRF   x3A
09484:  CLRF   x39
09486:  MOVFF  3B7,43E
0948A:  MOVFF  3B6,43D
0948E:  CLRF   x42
09490:  CLRF   x41
09492:  CLRF   x40
09494:  MOVLW  40
09496:  MOVWF  x3F
09498:  MOVLB  0
0949A:  CALL   2792
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0949E:  MOVLB  3
094A0:  CLRF   xB5
094A2:  MOVLB  0
094A4:  MOVLB  3
094A6:  MOVF   xB5,W
094A8:  SUBLW  04
094AA:  BTFSC  FD8.0
094AC:  BRA    94B4
094AE:  MOVLB  0
094B0:  GOTO   9582
094B4:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
094B6:  MOVLB  3
094B8:  MOVF   xB3,W
094BA:  MOVWF  01
094BC:  MOVF   xB4,W
094BE:  MOVWF  03
094C0:  MOVF   01,W
094C2:  MOVWF  xB6
094C4:  MOVFF  03,3B7
094C8:  MOVFF  265,438
094CC:  MOVFF  264,437
094D0:  MOVFF  263,436
094D4:  MOVFF  262,435
094D8:  MOVLW  06
094DA:  MOVLB  4
094DC:  MOVWF  x3C
094DE:  MOVLW  AA
094E0:  MOVWF  x3B
094E2:  CLRF   x3A
094E4:  CLRF   x39
094E6:  MOVFF  3B7,43E
094EA:  MOVFF  3B6,43D
094EE:  CLRF   x42
094F0:  CLRF   x41
094F2:  CLRF   x40
094F4:  MOVLW  40
094F6:  MOVWF  x3F
094F8:  MOVLB  0
094FA:  CALL   2792
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
094FE:  MOVLB  3
09500:  MOVF   xB3,W
09502:  MOVWF  01
09504:  MOVF   xB4,W
09506:  MOVWF  03
09508:  MOVF   01,W
0950A:  MOVWF  xB6
0950C:  MOVFF  03,3B7
09510:  MOVFF  3B7,436
09514:  MOVFF  3B6,435
09518:  MOVLW  3F
0951A:  MOVLB  4
0951C:  MOVWF  x37
0951E:  MOVLB  0
09520:  CALL   9408
09524:  MOVF   01,F
09526:  BTFSC  FD8.2
09528:  GOTO   9578
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
0952C:  MOVLW  01
0952E:  MOVLB  3
09530:  ADDWF  xB5,W
09532:  MOVWF  xB6
09534:  MOVLW  1A
09536:  MOVWF  FF6
09538:  MOVLW  07
0953A:  MOVWF  FF7
0953C:  MOVLW  00
0953E:  MOVWF  FF8
09540:  MOVLW  23
09542:  MOVLB  B
09544:  MOVWF  x1B
09546:  MOVLB  0
09548:  CALL   1BE0
0954C:  MOVFF  3B6,3B7
09550:  MOVLW  1B
09552:  MOVLB  3
09554:  MOVWF  xB8
09556:  MOVLB  0
09558:  CALL   6798
0955C:  MOVLW  0D
0955E:  MOVLB  B
09560:  MOVWF  x6E
09562:  MOVLB  0
09564:  CALL   1B5E
09568:  MOVLW  0A
0956A:  MOVLB  B
0956C:  MOVWF  x6E
0956E:  MOVLB  0
09570:  CALL   1B5E
....................             break;
09574:  GOTO   9582
....................         }
09578:  MOVLB  3
0957A:  INCF   xB5,F
0957C:  MOVLB  0
0957E:  GOTO   94A4
....................     }
09582:  GOTO   9A56 (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
09706:  CALL   3A26
0970A:  MOVFF  02,03
0970E:  MOVF   01,W
09710:  MOVWF  FE1
09712:  MOVFF  03,FE2
09716:  MOVLW  03
09718:  MOVWF  FEA
0971A:  MOVLW  B3
0971C:  MOVWF  FE9
0971E:  MOVLW  40
09720:  MOVWF  01
09722:  MOVFF  FE6,FEE
09726:  DECFSZ 01,F
09728:  GOTO   9722
0972C:  MOVLB  4
0972E:  BCF    x33.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
09730:  CLRF   x34
09732:  MOVLB  0
09734:  MOVLB  4
09736:  MOVF   x34,W
09738:  SUBLW  04
0973A:  BTFSC  FD8.0
0973C:  BRA    9744
0973E:  MOVLB  0
09740:  GOTO   9844
09744:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
09746:  MOVFF  265,438
0974A:  MOVFF  264,437
0974E:  MOVFF  263,436
09752:  MOVFF  262,435
09756:  MOVLW  06
09758:  MOVLB  4
0975A:  MOVWF  x3C
0975C:  MOVLW  AA
0975E:  MOVWF  x3B
09760:  CLRF   x3A
09762:  CLRF   x39
09764:  MOVLB  0
09766:  CALL   4B38
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
0976A:  MOVFF  265,BAE
0976E:  MOVFF  264,BAD
09772:  MOVFF  263,BAC
09776:  MOVFF  262,BAB
0977A:  MOVLW  06
0977C:  MOVLB  B
0977E:  MOVWF  xB2
09780:  MOVLW  AA
09782:  MOVWF  xB1
09784:  CLRF   xB0
09786:  CLRF   xAF
09788:  MOVLW  03
0978A:  MOVWF  xB4
0978C:  MOVLW  B3
0978E:  MOVWF  xB3
09790:  CLRF   xB6
09792:  MOVLW  40
09794:  MOVWF  xB5
09796:  MOVLB  0
09798:  CALL   367E
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
0979C:  MOVFF  265,438
097A0:  MOVFF  264,437
097A4:  MOVFF  263,436
097A8:  MOVFF  262,435
097AC:  MOVLW  06
097AE:  MOVLB  4
097B0:  MOVWF  x3C
097B2:  MOVLW  AA
097B4:  MOVWF  x3B
097B6:  CLRF   x3A
097B8:  CLRF   x39
097BA:  MOVLW  03
097BC:  MOVWF  x3E
097BE:  MOVLW  F3
097C0:  MOVWF  x3D
097C2:  CLRF   x42
097C4:  CLRF   x41
097C6:  CLRF   x40
097C8:  MOVLW  40
097CA:  MOVWF  x3F
097CC:  MOVLB  0
097CE:  CALL   2792
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
097D2:  MOVLW  03
097D4:  MOVLB  4
097D6:  MOVWF  x36
097D8:  MOVLW  F3
097DA:  MOVWF  x35
097DC:  MOVLW  3F
097DE:  MOVWF  x37
097E0:  MOVLB  0
097E2:  CALL   9408
097E6:  MOVF   01,F
097E8:  BTFSC  FD8.2
097EA:  GOTO   983A
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
097EE:  MOVLW  01
097F0:  MOVLB  4
097F2:  ADDWF  x34,W
097F4:  MOVWF  x35
097F6:  MOVLW  42
097F8:  MOVWF  FF6
097FA:  MOVLW  07
097FC:  MOVWF  FF7
097FE:  MOVLW  00
09800:  MOVWF  FF8
09802:  MOVLW  23
09804:  MOVLB  B
09806:  MOVWF  x1B
09808:  MOVLB  0
0980A:  CALL   1BE0
0980E:  MOVFF  435,436
09812:  MOVLW  18
09814:  MOVLB  4
09816:  MOVWF  x37
09818:  MOVLB  0
0981A:  CALL   907E
0981E:  MOVLW  0D
09820:  MOVLB  B
09822:  MOVWF  x6E
09824:  MOVLB  0
09826:  CALL   1B5E
0982A:  MOVLW  0A
0982C:  MOVLB  B
0982E:  MOVWF  x6E
09830:  MOVLB  0
09832:  CALL   1B5E
....................             break;
09836:  GOTO   9844
....................         }
0983A:  MOVLB  4
0983C:  INCF   x34,F
0983E:  MOVLB  0
09840:  GOTO   9734
....................     }
....................     if (!crc_valid)
09844:  MOVLB  4
09846:  BTFSS  x33.0
09848:  BRA    9850
0984A:  MOVLB  0
0984C:  GOTO   9892
09850:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
09852:  MOVLW  6A
09854:  MOVWF  FF6
09856:  MOVLW  07
09858:  MOVWF  FF7
0985A:  MOVLW  00
0985C:  MOVWF  FF8
0985E:  MOVLW  25
09860:  MOVLB  B
09862:  MOVWF  x1B
09864:  MOVLB  0
09866:  CALL   1BE0
0986A:  MOVLW  05
0986C:  MOVLB  4
0986E:  MOVWF  x36
09870:  MOVLW  18
09872:  MOVWF  x37
09874:  MOVLB  0
09876:  CALL   907E
0987A:  MOVLW  91
0987C:  MOVWF  FF6
0987E:  MOVLW  07
09880:  MOVWF  FF7
09882:  MOVLW  00
09884:  MOVWF  FF8
09886:  MOVLW  0B
09888:  MOVLB  B
0988A:  MOVWF  x1B
0988C:  MOVLB  0
0988E:  CALL   1BE0
....................         // return; 
....................     }
09892:  GOTO   A0D4 (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0989A:  MOVLW  9E
0989C:  MOVWF  FF6
0989E:  MOVLW  07
098A0:  MOVWF  FF7
098A2:  MOVLW  00
098A4:  MOVWF  FF8
098A6:  CALL   1BB0
....................     fprintf(PC, "_____Start copy_data____\r\n");
098AA:  MOVLW  B8
098AC:  MOVWF  FF6
098AE:  MOVLW  07
098B0:  MOVWF  FF7
098B2:  MOVLW  00
098B4:  MOVWF  FF8
098B6:  CALL   1BB0
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
098BA:  MOVLB  2
098BC:  MOVF   xC7,W
098BE:  MOVWF  FE9
098C0:  MOVF   xC8,W
098C2:  MOVWF  FEA
098C4:  MOVFF  FEF,3B1
098C8:  MOVFF  3B1,3BA
098CC:  MOVLB  0
098CE:  CALL   91F0
098D2:  MOVFF  02,03
098D6:  MOVF   01,W
098D8:  MOVWF  FE1
098DA:  MOVFF  03,FE2
098DE:  MOVLW  03
098E0:  MOVWF  FEA
098E2:  MOVLW  1E
098E4:  MOVWF  FE9
098E6:  MOVLW  08
098E8:  MOVWF  01
098EA:  MOVFF  FE6,FEE
098EE:  DECFSZ 01,F
098F0:  GOTO   98EA
098F4:  MOVFF  321,329
098F8:  MOVFF  320,328
098FC:  MOVFF  31F,327
09900:  MOVFF  31E,326
09904:  MOVFF  325,32D
09908:  MOVFF  324,32C
0990C:  MOVFF  323,32B
09910:  MOVFF  322,32A
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
09914:  MOVLW  03
09916:  MOVLB  2
09918:  ADDWF  xC7,W
0991A:  MOVWF  01
0991C:  MOVLW  00
0991E:  ADDWFC xC8,W
09920:  MOVWF  03
09922:  MOVF   01,W
09924:  MOVWF  FE9
09926:  MOVFF  03,FEA
0992A:  BTFSS  FEF.0
0992C:  BRA    9934
0992E:  MOVLB  0
09930:  GOTO   9984
09934:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
09936:  MOVLB  2
09938:  MOVF   xC7,W
0993A:  MOVWF  FE9
0993C:  MOVF   xC8,W
0993E:  MOVWF  FEA
09940:  MOVFF  FEF,3B1
09944:  MOVFF  3B1,3BA
09948:  MOVLB  0
0994A:  GOTO   9310
0994E:  MOVFF  02,03
09952:  MOVF   01,W
09954:  MOVWF  FE1
09956:  MOVFF  03,FE2
0995A:  MOVLW  03
0995C:  MOVWF  FEA
0995E:  MOVLW  36
09960:  MOVWF  FE9
09962:  MOVLW  08
09964:  MOVWF  01
09966:  MOVFF  FE6,FEE
0996A:  DECFSZ 01,F
0996C:  GOTO   9966
....................         write_src = misf_address.start_address;
09970:  MOVFF  339,331
09974:  MOVFF  338,330
09978:  MOVFF  337,32F
0997C:  MOVFF  336,32E
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
09980:  GOTO   99EE
09984:  MOVLW  03
09986:  MOVLB  2
09988:  ADDWF  xC7,W
0998A:  MOVWF  01
0998C:  MOVLW  00
0998E:  ADDWFC xC8,W
09990:  MOVWF  03
09992:  MOVF   01,W
09994:  MOVWF  FE9
09996:  MOVFF  03,FEA
0999A:  BTFSC  FEF.0
0999C:  BRA    99A4
0999E:  MOVLB  0
099A0:  GOTO   99EE
099A4:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
099A6:  MOVLW  04
099A8:  MOVLB  2
099AA:  ADDWF  xC7,W
099AC:  MOVWF  FE9
099AE:  MOVLW  00
099B0:  ADDWFC xC8,W
099B2:  MOVWF  FEA
099B4:  MOVFF  FEF,32E
099B8:  MOVFF  FEC,32F
099BC:  MOVFF  FEC,330
099C0:  MOVFF  FEC,331
099C4:  MOVF   FED,F
099C6:  MOVF   FED,F
099C8:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
099CA:  MOVLW  08
099CC:  ADDWF  xC7,W
099CE:  MOVWF  FE9
099D0:  MOVLW  00
099D2:  ADDWFC xC8,W
099D4:  MOVWF  FEA
099D6:  MOVFF  FEF,332
099DA:  MOVFF  FEC,333
099DE:  MOVFF  FEC,334
099E2:  MOVFF  FEC,335
099E6:  MOVF   FED,F
099E8:  MOVF   FED,F
099EA:  MOVF   FED,F
099EC:  MOVLB  0
....................     }
.................... 
....................     if (!is_connect(mis_fm))
099EE:  MOVFF  261,3B6
099F2:  MOVFF  260,3B5
099F6:  MOVFF  25F,3B4
099FA:  MOVFF  25E,3B3
099FE:  CALL   26CA
09A02:  MOVF   01,F
09A04:  BTFSS  FD8.2
09A06:  GOTO   9A1A
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
09A0A:  MOVLW  D4
09A0C:  MOVWF  FF6
09A0E:  MOVLW  07
09A10:  MOVWF  FF7
09A12:  MOVLW  00
09A14:  MOVWF  FF8
09A16:  CALL   1BB0
....................     }    
....................     if (!is_connect(smf))
09A1A:  MOVFF  265,3B6
09A1E:  MOVFF  264,3B5
09A22:  MOVFF  263,3B4
09A26:  MOVFF  262,3B3
09A2A:  CALL   26CA
09A2E:  MOVF   01,F
09A30:  BTFSS  FD8.2
09A32:  GOTO   9A46
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
09A36:  MOVLW  F6
09A38:  MOVWF  FF6
09A3A:  MOVLW  07
09A3C:  MOVWF  FF7
09A3E:  MOVLW  00
09A40:  MOVWF  FF8
09A42:  CALL   1BB0
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
09A46:  MOVLW  02
09A48:  MOVLB  3
09A4A:  MOVWF  xB4
09A4C:  MOVLW  DE
09A4E:  MOVWF  xB3
09A50:  MOVLB  0
09A52:  GOTO   9456
.................... 
....................     // PartitionParamから値を取得
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
09A56:  MOVFF  2A4,341
09A5A:  MOVFF  2A3,340
09A5E:  MOVFF  2A2,33F
09A62:  MOVFF  2A1,33E
09A66:  MOVFF  2A5,342
....................     fprintf(PC, "Size area read\r\n");
09A6A:  MOVLW  14
09A6C:  MOVWF  FF6
09A6E:  MOVLW  08
09A70:  MOVWF  FF7
09A72:  MOVLW  00
09A74:  MOVWF  FF8
09A76:  CALL   1BB0
....................     fprintf(PC, "used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
09A7A:  MOVLW  26
09A7C:  MOVWF  FF6
09A7E:  MOVLW  08
09A80:  MOVWF  FF7
09A82:  MOVLW  00
09A84:  MOVWF  FF8
09A86:  MOVLW  0C
09A88:  MOVLB  B
09A8A:  MOVWF  x1B
09A8C:  MOVLB  0
09A8E:  CALL   1BE0
09A92:  MOVLW  41
09A94:  MOVWF  FE9
09A96:  MOVFF  341,3B6
09A9A:  MOVFF  340,3B5
09A9E:  MOVFF  33F,3B4
09AA2:  MOVFF  33E,3B3
09AA6:  CALL   9586
09AAA:  MOVLW  35
09AAC:  MOVWF  FF6
09AAE:  MOVLW  08
09AB0:  MOVWF  FF7
09AB2:  MOVLW  00
09AB4:  MOVWF  FF8
09AB6:  MOVLW  08
09AB8:  MOVLB  B
09ABA:  MOVWF  x1B
09ABC:  MOVLB  0
09ABE:  CALL   1BE0
09AC2:  MOVFF  329,B1B
09AC6:  MOVLW  37
09AC8:  MOVLB  B
09ACA:  MOVWF  x1C
09ACC:  MOVLB  0
09ACE:  CALL   1E34
09AD2:  MOVFF  328,B1B
09AD6:  MOVLW  37
09AD8:  MOVLB  B
09ADA:  MOVWF  x1C
09ADC:  MOVLB  0
09ADE:  CALL   1E34
09AE2:  MOVFF  327,B1B
09AE6:  MOVLW  37
09AE8:  MOVLB  B
09AEA:  MOVWF  x1C
09AEC:  MOVLB  0
09AEE:  CALL   1E34
09AF2:  MOVFF  326,B1B
09AF6:  MOVLW  37
09AF8:  MOVLB  B
09AFA:  MOVWF  x1C
09AFC:  MOVLB  0
09AFE:  CALL   1E34
09B02:  MOVLW  42
09B04:  MOVWF  FF6
09B06:  MOVLW  08
09B08:  MOVWF  FF7
09B0A:  MOVLW  00
09B0C:  MOVWF  FF8
09B0E:  MOVLW  03
09B10:  MOVLB  B
09B12:  MOVWF  x1B
09B14:  MOVLB  0
09B16:  CALL   1BE0
....................     fprintf(PC, "loop count= %d  (src 0x%08LX)\r\n\r\n", loop_count, mis_start_address + 4);
09B1A:  MOVLW  04
09B1C:  MOVLB  3
09B1E:  ADDWF  x26,W
09B20:  MOVWF  xB1
09B22:  MOVLW  00
09B24:  ADDWFC x27,W
09B26:  MOVWF  xB2
09B28:  MOVLW  00
09B2A:  ADDWFC x28,W
09B2C:  MOVWF  xB3
09B2E:  MOVLW  00
09B30:  ADDWFC x29,W
09B32:  MOVWF  xB4
09B34:  MOVLW  46
09B36:  MOVWF  FF6
09B38:  MOVLW  08
09B3A:  MOVWF  FF7
09B3C:  MOVLW  00
09B3E:  MOVWF  FF8
09B40:  MOVLW  0C
09B42:  MOVLB  B
09B44:  MOVWF  x1B
09B46:  MOVLB  0
09B48:  CALL   1BE0
09B4C:  MOVFF  342,436
09B50:  MOVLW  18
09B52:  MOVLB  4
09B54:  MOVWF  x37
09B56:  MOVLB  0
09B58:  CALL   907E
09B5C:  MOVLW  54
09B5E:  MOVWF  FF6
09B60:  MOVLW  08
09B62:  MOVWF  FF7
09B64:  MOVLW  00
09B66:  MOVWF  FF8
09B68:  MOVLW  09
09B6A:  MOVLB  B
09B6C:  MOVWF  x1B
09B6E:  MOVLB  0
09B70:  CALL   1BE0
09B74:  MOVFF  3B4,B1B
09B78:  MOVLW  37
09B7A:  MOVLB  B
09B7C:  MOVWF  x1C
09B7E:  MOVLB  0
09B80:  CALL   1E34
09B84:  MOVFF  3B3,B1B
09B88:  MOVLW  37
09B8A:  MOVLB  B
09B8C:  MOVWF  x1C
09B8E:  MOVLB  0
09B90:  CALL   1E34
09B94:  MOVFF  3B2,B1B
09B98:  MOVLW  37
09B9A:  MOVLB  B
09B9C:  MOVWF  x1C
09B9E:  MOVLB  0
09BA0:  CALL   1E34
09BA4:  MOVFF  3B1,B1B
09BA8:  MOVLW  37
09BAA:  MOVLB  B
09BAC:  MOVWF  x1C
09BAE:  MOVLB  0
09BB0:  CALL   1E34
09BB4:  MOVLW  62
09BB6:  MOVWF  FF6
09BB8:  MOVLW  08
09BBA:  MOVWF  FF7
09BBC:  MOVLW  00
09BBE:  MOVWF  FF8
09BC0:  MOVLW  05
09BC2:  MOVLB  B
09BC4:  MOVWF  x1B
09BC6:  MOVLB  0
09BC8:  CALL   1BE0
....................     
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
09BCC:  MOVLB  3
09BCE:  MOVF   x26,W
09BD0:  MOVWF  x43
09BD2:  MOVLW  10
09BD4:  ADDWF  x27,W
09BD6:  MOVWF  x44
09BD8:  MOVLW  00
09BDA:  ADDWFC x28,W
09BDC:  MOVWF  x45
09BDE:  MOVLW  00
09BE0:  ADDWFC x29,W
09BE2:  MOVWF  x46
09BE4:  MOVFF  32D,34A
09BE8:  MOVFF  32C,349
09BEC:  MOVFF  32B,348
09BF0:  MOVFF  32A,347
09BF4:  MOVF   x43,W
09BF6:  SUBWF  x47,W
09BF8:  MOVWF  x4B
09BFA:  MOVF   x44,W
09BFC:  SUBWFB x48,W
09BFE:  MOVWF  x4C
09C00:  MOVF   x45,W
09C02:  SUBWFB x49,W
09C04:  MOVWF  x4D
09C06:  MOVF   x46,W
09C08:  SUBWFB x4A,W
09C0A:  MOVWF  x4E
09C0C:  MOVF   x3E,W
09C0E:  ADDWF  x43,W
09C10:  MOVWF  x4F
09C12:  MOVF   x3F,W
09C14:  ADDWFC x44,W
09C16:  MOVWF  x50
09C18:  MOVF   x40,W
09C1A:  ADDWFC x45,W
09C1C:  MOVWF  x51
09C1E:  MOVF   x41,W
09C20:  ADDWFC x46,W
09C22:  MOVWF  x52
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
09C24:  MOVF   x32,W
09C26:  ADDWF  x3E,W
09C28:  MOVWF  xB1
09C2A:  MOVF   x33,W
09C2C:  ADDWFC x3F,W
09C2E:  MOVWF  xB2
09C30:  MOVF   x34,W
09C32:  ADDWFC x40,W
09C34:  MOVWF  xB3
09C36:  MOVF   x35,W
09C38:  ADDWFC x41,W
09C3A:  MOVWF  xB4
09C3C:  MOVF   x4E,W
09C3E:  SUBWF  xB4,W
09C40:  BTFSC  FD8.0
09C42:  BRA    9C4A
09C44:  MOVLB  0
09C46:  GOTO   9D7A
09C4A:  MOVLB  0
09C4C:  BTFSS  FD8.2
09C4E:  GOTO   9C94
09C52:  MOVLB  3
09C54:  MOVF   x4D,W
09C56:  SUBWF  xB3,W
09C58:  BTFSC  FD8.0
09C5A:  BRA    9C62
09C5C:  MOVLB  0
09C5E:  GOTO   9D7A
09C62:  MOVLB  0
09C64:  BTFSS  FD8.2
09C66:  GOTO   9C94
09C6A:  MOVLB  3
09C6C:  MOVF   x4C,W
09C6E:  SUBWF  xB2,W
09C70:  BTFSC  FD8.0
09C72:  BRA    9C7A
09C74:  MOVLB  0
09C76:  GOTO   9D7A
09C7A:  MOVLB  0
09C7C:  BTFSS  FD8.2
09C7E:  GOTO   9C94
09C82:  MOVLB  3
09C84:  MOVF   xB1,W
09C86:  SUBWF  x4B,W
09C88:  BTFSS  FD8.0
09C8A:  BRA    9C92
09C8C:  MOVLB  0
09C8E:  GOTO   9D7A
09C92:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
09C94:  MOVLW  68
09C96:  MOVWF  FF6
09C98:  MOVLW  08
09C9A:  MOVWF  FF7
09C9C:  MOVLW  00
09C9E:  MOVWF  FF8
09CA0:  CALL   1BB0
....................         loop_count++;
09CA4:  MOVLB  3
09CA6:  INCF   x42,F
....................         used_size = 0;
09CA8:  CLRF   x41
09CAA:  CLRF   x40
09CAC:  CLRF   x3F
09CAE:  CLRF   x3E
....................         data_write_addr = data_region_start;
09CB0:  MOVFF  346,352
09CB4:  MOVFF  345,351
09CB8:  MOVFF  344,350
09CBC:  MOVFF  343,34F
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
09CC0:  MOVLB  2
09CC2:  MOVF   xC7,W
09CC4:  MOVWF  FE9
09CC6:  MOVF   xC8,W
09CC8:  MOVWF  FEA
09CCA:  MOVFF  FEF,3B1
09CCE:  MOVFF  3B1,3B4
09CD2:  MOVLB  0
09CD4:  GOTO   9702
....................         
....................         unsigned int32 erase_ptr = data_region_start;
09CD8:  MOVFF  346,356
09CDC:  MOVFF  345,355
09CE0:  MOVFF  344,354
09CE4:  MOVFF  343,353
....................         while (erase_ptr < data_region_end)
09CE8:  MOVLB  3
09CEA:  MOVF   x56,W
09CEC:  SUBWF  x4A,W
09CEE:  BTFSC  FD8.0
09CF0:  BRA    9CF8
09CF2:  MOVLB  0
09CF4:  GOTO   9D7A
09CF8:  MOVLB  0
09CFA:  BTFSS  FD8.2
09CFC:  GOTO   9D42
09D00:  MOVLB  3
09D02:  MOVF   x55,W
09D04:  SUBWF  x49,W
09D06:  BTFSC  FD8.0
09D08:  BRA    9D10
09D0A:  MOVLB  0
09D0C:  GOTO   9D7A
09D10:  MOVLB  0
09D12:  BTFSS  FD8.2
09D14:  GOTO   9D42
09D18:  MOVLB  3
09D1A:  MOVF   x54,W
09D1C:  SUBWF  x48,W
09D1E:  BTFSC  FD8.0
09D20:  BRA    9D28
09D22:  MOVLB  0
09D24:  GOTO   9D7A
09D28:  MOVLB  0
09D2A:  BTFSS  FD8.2
09D2C:  GOTO   9D42
09D30:  MOVLB  3
09D32:  MOVF   x47,W
09D34:  SUBWF  x53,W
09D36:  BTFSS  FD8.0
09D38:  BRA    9D40
09D3A:  MOVLB  0
09D3C:  GOTO   9D7A
09D40:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
09D42:  MOVFF  265,438
09D46:  MOVFF  264,437
09D4A:  MOVFF  263,436
09D4E:  MOVFF  262,435
09D52:  MOVFF  356,43C
09D56:  MOVFF  355,43B
09D5A:  MOVFF  354,43A
09D5E:  MOVFF  353,439
09D62:  CALL   4B38
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
09D66:  MOVLW  10
09D68:  MOVLB  3
09D6A:  ADDWF  x54,F
09D6C:  MOVLW  00
09D6E:  ADDWFC x55,F
09D70:  MOVLW  00
09D72:  ADDWFC x56,F
09D74:  MOVLB  0
09D76:  GOTO   9CE8
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
09D7A:  MOVLB  3
09D7C:  CLRF   x57
09D7E:  MOVF   x50,W
09D80:  ANDLW  F0
09D82:  MOVWF  x58
09D84:  CLRF   x59
09D86:  CLRF   x5A
09D88:  MOVF   x32,W
09D8A:  ADDWF  x4F,W
09D8C:  MOVWF  xB1
09D8E:  MOVF   x33,W
09D90:  ADDWFC x50,W
09D92:  MOVWF  xB2
09D94:  MOVF   x34,W
09D96:  ADDWFC x51,W
09D98:  MOVWF  xB3
09D9A:  MOVF   x35,W
09D9C:  ADDWFC x52,W
09D9E:  MOVWF  xB4
09DA0:  MOVLW  FF
09DA2:  ADDWF  xB1,F
09DA4:  MOVLW  0F
09DA6:  ADDWFC xB2,F
09DA8:  MOVLW  00
09DAA:  ADDWFC xB3,F
09DAC:  MOVLW  00
09DAE:  ADDWFC xB4,F
09DB0:  CLRF   x5B
09DB2:  MOVF   xB2,W
09DB4:  ANDLW  F0
09DB6:  MOVWF  x5C
09DB8:  CLRF   x5D
09DBA:  CLRF   x5E
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
09DBC:  MOVFF  35A,362
09DC0:  MOVFF  359,361
09DC4:  MOVFF  358,360
09DC8:  MOVFF  357,35F
09DCC:  MOVLB  0
09DCE:  MOVLB  3
09DD0:  MOVF   x62,W
09DD2:  SUBWF  x5E,W
09DD4:  BTFSC  FD8.0
09DD6:  BRA    9DDE
09DD8:  MOVLB  0
09DDA:  GOTO   9EBA
09DDE:  MOVLB  0
09DE0:  BTFSS  FD8.2
09DE2:  GOTO   9E28
09DE6:  MOVLB  3
09DE8:  MOVF   x61,W
09DEA:  SUBWF  x5D,W
09DEC:  BTFSC  FD8.0
09DEE:  BRA    9DF6
09DF0:  MOVLB  0
09DF2:  GOTO   9EBA
09DF6:  MOVLB  0
09DF8:  BTFSS  FD8.2
09DFA:  GOTO   9E28
09DFE:  MOVLB  3
09E00:  MOVF   x60,W
09E02:  SUBWF  x5C,W
09E04:  BTFSC  FD8.0
09E06:  BRA    9E0E
09E08:  MOVLB  0
09E0A:  GOTO   9EBA
09E0E:  MOVLB  0
09E10:  BTFSS  FD8.2
09E12:  GOTO   9E28
09E16:  MOVLB  3
09E18:  MOVF   x5B,W
09E1A:  SUBWF  x5F,W
09E1C:  BTFSS  FD8.0
09E1E:  BRA    9E26
09E20:  MOVLB  0
09E22:  GOTO   9EBA
09E26:  MOVLB  0
09E28:  MOVLB  3
09E2A:  MOVF   x62,W
09E2C:  SUBWF  x2D,W
09E2E:  BTFSC  FD8.0
09E30:  BRA    9E38
09E32:  MOVLB  0
09E34:  GOTO   9EBA
09E38:  MOVLB  0
09E3A:  BTFSS  FD8.2
09E3C:  GOTO   9E82
09E40:  MOVLB  3
09E42:  MOVF   x61,W
09E44:  SUBWF  x2C,W
09E46:  BTFSC  FD8.0
09E48:  BRA    9E50
09E4A:  MOVLB  0
09E4C:  GOTO   9EBA
09E50:  MOVLB  0
09E52:  BTFSS  FD8.2
09E54:  GOTO   9E82
09E58:  MOVLB  3
09E5A:  MOVF   x60,W
09E5C:  SUBWF  x2B,W
09E5E:  BTFSC  FD8.0
09E60:  BRA    9E68
09E62:  MOVLB  0
09E64:  GOTO   9EBA
09E68:  MOVLB  0
09E6A:  BTFSS  FD8.2
09E6C:  GOTO   9E82
09E70:  MOVLB  3
09E72:  MOVF   x2A,W
09E74:  SUBWF  x5F,W
09E76:  BTFSS  FD8.0
09E78:  BRA    9E80
09E7A:  MOVLB  0
09E7C:  GOTO   9EBA
09E80:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
09E82:  MOVFF  265,438
09E86:  MOVFF  264,437
09E8A:  MOVFF  263,436
09E8E:  MOVFF  262,435
09E92:  MOVFF  362,43C
09E96:  MOVFF  361,43B
09E9A:  MOVFF  360,43A
09E9E:  MOVFF  35F,439
09EA2:  CALL   4B38
09EA6:  MOVLW  10
09EA8:  MOVLB  3
09EAA:  ADDWF  x60,F
09EAC:  MOVLW  00
09EAE:  ADDWFC x61,F
09EB0:  MOVLW  00
09EB2:  ADDWFC x62,F
09EB4:  MOVLB  0
09EB6:  GOTO   9DCE
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
09EBA:  MOVFF  335,366
09EBE:  MOVFF  334,365
09EC2:  MOVFF  333,364
09EC6:  MOVFF  332,363
09ECA:  MOVFF  331,36A
09ECE:  MOVFF  330,369
09ED2:  MOVFF  32F,368
09ED6:  MOVFF  32E,367
....................     while (remaining > 0)
09EDA:  MOVLB  3
09EDC:  MOVF   x63,F
09EDE:  BTFSC  FD8.2
09EE0:  BRA    9EE8
09EE2:  MOVLB  0
09EE4:  GOTO   9F1A
09EE8:  MOVLB  0
09EEA:  MOVLB  3
09EEC:  MOVF   x64,F
09EEE:  BTFSC  FD8.2
09EF0:  BRA    9EF8
09EF2:  MOVLB  0
09EF4:  GOTO   9F1A
09EF8:  MOVLB  0
09EFA:  MOVLB  3
09EFC:  MOVF   x65,F
09EFE:  BTFSC  FD8.2
09F00:  BRA    9F08
09F02:  MOVLB  0
09F04:  GOTO   9F1A
09F08:  MOVLB  0
09F0A:  MOVLB  3
09F0C:  MOVF   x66,F
09F0E:  BTFSS  FD8.2
09F10:  BRA    9F18
09F12:  MOVLB  0
09F14:  GOTO   A0D0
09F18:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
09F1A:  MOVLB  3
09F1C:  MOVF   x66,F
09F1E:  BTFSC  FD8.2
09F20:  BRA    9F28
09F22:  MOVLB  0
09F24:  GOTO   9F5C
09F28:  MOVLB  0
09F2A:  MOVLB  3
09F2C:  MOVF   x65,F
09F2E:  BTFSC  FD8.2
09F30:  BRA    9F38
09F32:  MOVLB  0
09F34:  GOTO   9F5C
09F38:  MOVLB  0
09F3A:  MOVLB  3
09F3C:  MOVF   x64,F
09F3E:  BTFSC  FD8.2
09F40:  BRA    9F48
09F42:  MOVLB  0
09F44:  GOTO   9F5C
09F48:  MOVLB  0
09F4A:  MOVLB  3
09F4C:  MOVF   x63,W
09F4E:  SUBLW  40
09F50:  BTFSS  FD8.0
09F52:  BRA    9F5A
09F54:  MOVLB  0
09F56:  GOTO   9F64
09F5A:  MOVLB  0
09F5C:  CLRF   03
09F5E:  MOVLW  40
09F60:  GOTO   9F6E
09F64:  MOVFF  364,03
09F68:  MOVLB  3
09F6A:  MOVF   x63,W
09F6C:  MOVLB  0
09F6E:  MOVLB  3
09F70:  MOVWF  xAB
09F72:  MOVFF  03,3AC
09F76:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
09F78:  MOVFF  261,438
09F7C:  MOVFF  260,437
09F80:  MOVFF  25F,436
09F84:  MOVFF  25E,435
09F88:  MOVFF  36A,43C
09F8C:  MOVFF  369,43B
09F90:  MOVFF  368,43A
09F94:  MOVFF  367,439
09F98:  MOVLW  03
09F9A:  MOVLB  4
09F9C:  MOVWF  x3E
09F9E:  MOVLW  6B
09FA0:  MOVWF  x3D
09FA2:  CLRF   x42
09FA4:  CLRF   x41
09FA6:  MOVFF  3AC,440
09FAA:  MOVFF  3AB,43F
09FAE:  MOVLB  0
09FB0:  CALL   2792
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
09FB4:  MOVFF  265,BAE
09FB8:  MOVFF  264,BAD
09FBC:  MOVFF  263,BAC
09FC0:  MOVFF  262,BAB
09FC4:  MOVFF  352,BB2
09FC8:  MOVFF  351,BB1
09FCC:  MOVFF  350,BB0
09FD0:  MOVFF  34F,BAF
09FD4:  MOVLW  03
09FD6:  MOVLB  B
09FD8:  MOVWF  xB4
09FDA:  MOVLW  6B
09FDC:  MOVWF  xB3
09FDE:  MOVFF  3AC,BB6
09FE2:  MOVFF  3AB,BB5
09FE6:  MOVLB  0
09FE8:  CALL   367E
....................         for (unsigned int32 i = 0; i < chunk; i++)
09FEC:  MOVLB  3
09FEE:  CLRF   xB0
09FF0:  CLRF   xAF
09FF2:  CLRF   xAE
09FF4:  CLRF   xAD
09FF6:  MOVLB  0
09FF8:  MOVLB  3
09FFA:  MOVF   xB0,F
09FFC:  BTFSC  FD8.2
09FFE:  BRA    A006
0A000:  MOVLB  0
0A002:  GOTO   A088
0A006:  MOVLB  0
0A008:  MOVLB  3
0A00A:  MOVF   xAF,F
0A00C:  BTFSC  FD8.2
0A00E:  BRA    A016
0A010:  MOVLB  0
0A012:  GOTO   A088
0A016:  MOVLB  0
0A018:  MOVLB  3
0A01A:  MOVF   xAE,W
0A01C:  SUBWF  xAC,W
0A01E:  BTFSC  FD8.0
0A020:  BRA    A028
0A022:  MOVLB  0
0A024:  GOTO   A088
0A028:  MOVLB  0
0A02A:  BTFSS  FD8.2
0A02C:  GOTO   A042
0A030:  MOVLB  3
0A032:  MOVF   xAB,W
0A034:  SUBWF  xAD,W
0A036:  BTFSS  FD8.0
0A038:  BRA    A040
0A03A:  MOVLB  0
0A03C:  GOTO   A088
0A040:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A042:  MOVLW  6B
0A044:  MOVLB  3
0A046:  ADDWF  xAD,W
0A048:  MOVWF  FE9
0A04A:  MOVLW  03
0A04C:  ADDWFC xAE,W
0A04E:  MOVWF  FEA
0A050:  MOVFF  FEF,3B1
0A054:  MOVFF  3B1,B1B
0A058:  MOVLW  37
0A05A:  MOVLB  B
0A05C:  MOVWF  x1C
0A05E:  MOVLB  0
0A060:  CALL   1E34
0A064:  MOVLW  20
0A066:  MOVLB  B
0A068:  MOVWF  x6E
0A06A:  MOVLB  0
0A06C:  CALL   1B5E
0A070:  MOVLW  01
0A072:  MOVLB  3
0A074:  ADDWF  xAD,F
0A076:  BTFSC  FD8.0
0A078:  INCF   xAE,F
0A07A:  BTFSC  FD8.2
0A07C:  INCF   xAF,F
0A07E:  BTFSC  FD8.2
0A080:  INCF   xB0,F
0A082:  MOVLB  0
0A084:  GOTO   9FF8
....................         }
....................         src_addr += chunk;
0A088:  MOVLB  3
0A08A:  MOVF   xAB,W
0A08C:  ADDWF  x67,F
0A08E:  MOVF   xAC,W
0A090:  ADDWFC x68,F
0A092:  MOVLW  00
0A094:  ADDWFC x69,F
0A096:  MOVLW  00
0A098:  ADDWFC x6A,F
....................         data_write_addr += chunk;
0A09A:  MOVF   xAB,W
0A09C:  ADDWF  x4F,F
0A09E:  MOVF   xAC,W
0A0A0:  ADDWFC x50,F
0A0A2:  MOVLW  00
0A0A4:  ADDWFC x51,F
0A0A6:  MOVLW  00
0A0A8:  ADDWFC x52,F
....................         used_size += chunk;
0A0AA:  MOVF   xAB,W
0A0AC:  ADDWF  x3E,F
0A0AE:  MOVF   xAC,W
0A0B0:  ADDWFC x3F,F
0A0B2:  MOVLW  00
0A0B4:  ADDWFC x40,F
0A0B6:  MOVLW  00
0A0B8:  ADDWFC x41,F
....................         remaining -= chunk;
0A0BA:  MOVF   xAB,W
0A0BC:  SUBWF  x63,F
0A0BE:  MOVF   xAC,W
0A0C0:  SUBWFB x64,F
0A0C2:  MOVLW  00
0A0C4:  SUBWFB x65,F
0A0C6:  MOVLW  00
0A0C8:  SUBWFB x66,F
0A0CA:  MOVLB  0
0A0CC:  GOTO   9EDA
....................     }
....................     // write size area
....................     write_smf_header();
0A0D0:  GOTO   9706
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0A0D4:  MOVLB  2
0A0D6:  MOVF   xC7,W
0A0D8:  MOVWF  FE9
0A0DA:  MOVF   xC8,W
0A0DC:  MOVWF  FEA
0A0DE:  MOVFF  FEF,3B1
0A0E2:  MOVFF  3B1,3B4
0A0E6:  MOVFF  335,3B8
0A0EA:  MOVFF  334,3B7
0A0EE:  MOVFF  333,3B6
0A0F2:  MOVFF  332,3B5
0A0F6:  MOVLB  0
0A0F8:  GOTO   9896
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0A0FC:  MOVLW  9E
0A0FE:  MOVWF  FF6
0A100:  MOVLW  08
0A102:  MOVWF  FF7
0A104:  MOVLW  00
0A106:  MOVWF  FF8
0A108:  MOVLW  0C
0A10A:  MOVLB  B
0A10C:  MOVWF  x1B
0A10E:  MOVLB  0
0A110:  CALL   1BE0
0A114:  MOVLW  41
0A116:  MOVWF  FE9
0A118:  MOVFF  341,3B6
0A11C:  MOVFF  340,3B5
0A120:  MOVFF  33F,3B4
0A124:  MOVFF  33E,3B3
0A128:  CALL   9586
0A12C:  MOVLW  0D
0A12E:  MOVLB  B
0A130:  MOVWF  x6E
0A132:  MOVLB  0
0A134:  CALL   1B5E
0A138:  MOVLW  0A
0A13A:  MOVLB  B
0A13C:  MOVWF  x6E
0A13E:  MOVLB  0
0A140:  CALL   1B5E
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0A144:  MOVLW  B0
0A146:  MOVWF  FF6
0A148:  MOVLW  08
0A14A:  MOVWF  FF7
0A14C:  MOVLW  00
0A14E:  MOVWF  FF8
0A150:  MOVLW  0D
0A152:  MOVLB  B
0A154:  MOVWF  x1B
0A156:  MOVLB  0
0A158:  CALL   1BE0
0A15C:  MOVFF  342,3B7
0A160:  MOVLW  1B
0A162:  MOVLB  3
0A164:  MOVWF  xB8
0A166:  MOVLB  0
0A168:  CALL   6798
0A16C:  MOVLW  BF
0A16E:  MOVWF  FF6
0A170:  MOVLW  08
0A172:  MOVWF  FF7
0A174:  MOVLW  00
0A176:  MOVWF  FF8
0A178:  MOVLW  04
0A17A:  MOVLB  B
0A17C:  MOVWF  x1B
0A17E:  MOVLB  0
0A180:  CALL   1BE0
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0A184:  MOVLW  C4
0A186:  MOVWF  FF6
0A188:  MOVLW  08
0A18A:  MOVWF  FF7
0A18C:  MOVLW  00
0A18E:  MOVWF  FF8
0A190:  CALL   1BB0
....................     fprintf(PC, "____________________\r\n\r\n");
0A194:  MOVLW  DE
0A196:  MOVWF  FF6
0A198:  MOVLW  08
0A19A:  MOVWF  FF7
0A19C:  MOVLW  00
0A19E:  MOVWF  FF8
0A1A0:  CALL   1BB0
0A1A4:  GOTO   AC92 (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0A2A8:  MOVLW  F8
0A2AA:  MOVWF  FF6
0A2AC:  MOVLW  08
0A2AE:  MOVWF  FF7
0A2B0:  MOVLW  00
0A2B2:  MOVWF  FF8
0A2B4:  CALL   1BB0
....................     fprintf(PC, "___Start SMF Read____\r\n");
0A2B8:  MOVLW  12
0A2BA:  MOVWF  FF6
0A2BC:  MOVLW  09
0A2BE:  MOVWF  FF7
0A2C0:  MOVLW  00
0A2C2:  MOVWF  FF8
0A2C4:  CALL   1BB0
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0A2C8:  MOVLB  2
0A2CA:  MOVF   xDE,W
0A2CC:  MOVWF  FE9
0A2CE:  MOVF   xDF,W
0A2D0:  MOVWF  FEA
0A2D2:  MOVFF  FEF,338
0A2D6:  MOVFF  338,3BA
0A2DA:  MOVLB  0
0A2DC:  CALL   91F0
0A2E0:  MOVFF  02,03
0A2E4:  MOVF   01,W
0A2E6:  MOVWF  FE1
0A2E8:  MOVFF  03,FE2
0A2EC:  MOVLW  03
0A2EE:  MOVWF  FEA
0A2F0:  MOVLW  20
0A2F2:  MOVWF  FE9
0A2F4:  MOVLW  08
0A2F6:  MOVWF  01
0A2F8:  MOVFF  FE6,FEE
0A2FC:  DECFSZ 01,F
0A2FE:  GOTO   A2F8
0A302:  MOVLW  04
0A304:  MOVLB  2
0A306:  ADDWF  xDE,W
0A308:  MOVWF  FE9
0A30A:  MOVLW  00
0A30C:  ADDWFC xDF,W
0A30E:  MOVWF  FEA
0A310:  MOVFF  FEF,328
0A314:  MOVFF  FEC,329
0A318:  MOVFF  FEC,32A
0A31C:  MOVFF  FEC,32B
0A320:  MOVF   FED,F
0A322:  MOVF   FED,F
0A324:  MOVF   FED,F
0A326:  MOVLW  08
0A328:  ADDWF  xDE,W
0A32A:  MOVWF  FE9
0A32C:  MOVLW  00
0A32E:  ADDWFC xDF,W
0A330:  MOVWF  FEA
0A332:  MOVFF  FEF,32C
0A336:  MOVFF  FEC,32D
0A33A:  MOVFF  FEC,32E
0A33E:  MOVFF  FEC,32F
0A342:  MOVF   FED,F
0A344:  MOVF   FED,F
0A346:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0A348:  MOVLW  2A
0A34A:  MOVWF  FF6
0A34C:  MOVLW  09
0A34E:  MOVWF  FF7
0A350:  MOVLW  00
0A352:  MOVWF  FF8
0A354:  MOVLW  21
0A356:  MOVLB  B
0A358:  MOVWF  x1B
0A35A:  MOVLB  0
0A35C:  CALL   1BE0
0A360:  MOVFF  32B,B1B
0A364:  MOVLW  37
0A366:  MOVLB  B
0A368:  MOVWF  x1C
0A36A:  MOVLB  0
0A36C:  CALL   1E34
0A370:  MOVFF  32A,B1B
0A374:  MOVLW  37
0A376:  MOVLB  B
0A378:  MOVWF  x1C
0A37A:  MOVLB  0
0A37C:  CALL   1E34
0A380:  MOVFF  329,B1B
0A384:  MOVLW  37
0A386:  MOVLB  B
0A388:  MOVWF  x1C
0A38A:  MOVLB  0
0A38C:  CALL   1E34
0A390:  MOVFF  328,B1B
0A394:  MOVLW  37
0A396:  MOVLB  B
0A398:  MOVWF  x1C
0A39A:  MOVLB  0
0A39C:  CALL   1E34
0A3A0:  MOVLW  0D
0A3A2:  MOVLB  B
0A3A4:  MOVWF  x6E
0A3A6:  MOVLB  0
0A3A8:  CALL   1B5E
0A3AC:  MOVLW  0A
0A3AE:  MOVLB  B
0A3B0:  MOVWF  x6E
0A3B2:  MOVLB  0
0A3B4:  CALL   1B5E
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0A3B8:  MOVLW  52
0A3BA:  MOVWF  FF6
0A3BC:  MOVLW  09
0A3BE:  MOVWF  FF7
0A3C0:  MOVLW  00
0A3C2:  MOVWF  FF8
0A3C4:  MOVLW  21
0A3C6:  MOVLB  B
0A3C8:  MOVWF  x1B
0A3CA:  MOVLB  0
0A3CC:  CALL   1BE0
0A3D0:  MOVLW  41
0A3D2:  MOVWF  FE9
0A3D4:  MOVFF  32F,33B
0A3D8:  MOVFF  32E,33A
0A3DC:  MOVFF  32D,339
0A3E0:  MOVFF  32C,338
0A3E4:  CALL   A1A8
0A3E8:  MOVLW  76
0A3EA:  MOVWF  FF6
0A3EC:  MOVLW  09
0A3EE:  MOVWF  FF7
0A3F0:  MOVLW  00
0A3F2:  MOVWF  FF8
0A3F4:  MOVLW  04
0A3F6:  MOVLB  B
0A3F8:  MOVWF  x1B
0A3FA:  MOVLB  0
0A3FC:  CALL   1BE0
0A400:  MOVFF  32F,B1B
0A404:  MOVLW  57
0A406:  MOVLB  B
0A408:  MOVWF  x1C
0A40A:  MOVLB  0
0A40C:  CALL   1E34
0A410:  MOVFF  32E,B1B
0A414:  MOVLW  57
0A416:  MOVLB  B
0A418:  MOVWF  x1C
0A41A:  MOVLB  0
0A41C:  CALL   1E34
0A420:  MOVFF  32D,B1B
0A424:  MOVLW  57
0A426:  MOVLB  B
0A428:  MOVWF  x1C
0A42A:  MOVLB  0
0A42C:  CALL   1E34
0A430:  MOVFF  32C,B1B
0A434:  MOVLW  57
0A436:  MOVLB  B
0A438:  MOVWF  x1C
0A43A:  MOVLB  0
0A43C:  CALL   1E34
0A440:  MOVLW  7D
0A442:  MOVWF  FF6
0A444:  MOVLW  09
0A446:  MOVWF  FF7
0A448:  MOVLW  00
0A44A:  MOVWF  FF8
0A44C:  MOVLW  05
0A44E:  MOVLB  B
0A450:  MOVWF  x1B
0A452:  MOVLB  0
0A454:  CALL   1BE0
.................... 
....................     if (!is_connect(smf)){
0A458:  MOVFF  265,3B6
0A45C:  MOVFF  264,3B5
0A460:  MOVFF  263,3B4
0A464:  MOVFF  262,3B3
0A468:  CALL   26CA
0A46C:  MOVF   01,F
0A46E:  BTFSS  FD8.2
0A470:  GOTO   A484
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A474:  MOVLW  84
0A476:  MOVWF  FF6
0A478:  MOVLW  09
0A47A:  MOVWF  FF7
0A47C:  MOVLW  00
0A47E:  MOVWF  FF8
0A480:  CALL   1BB0
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0A484:  MOVLW  A2
0A486:  MOVWF  FF6
0A488:  MOVLW  09
0A48A:  MOVWF  FF7
0A48C:  MOVLW  00
0A48E:  MOVWF  FF8
0A490:  CALL   1BB0
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0A494:  MOVFF  32B,333
0A498:  MOVFF  32A,332
0A49C:  MOVFF  329,331
0A4A0:  MOVFF  328,330
0A4A4:  MOVLB  3
0A4A6:  MOVF   x2C,W
0A4A8:  ADDWF  x28,W
0A4AA:  MOVWF  00
0A4AC:  MOVF   x2D,W
0A4AE:  ADDWFC x29,W
0A4B0:  MOVWF  01
0A4B2:  MOVF   x2E,W
0A4B4:  ADDWFC x2A,W
0A4B6:  MOVWF  02
0A4B8:  MOVF   x2F,W
0A4BA:  ADDWFC x2B,W
0A4BC:  MOVWF  03
0A4BE:  MOVF   x33,W
0A4C0:  SUBWF  03,W
0A4C2:  BTFSC  FD8.0
0A4C4:  BRA    A4CC
0A4C6:  MOVLB  0
0A4C8:  GOTO   A614
0A4CC:  MOVLB  0
0A4CE:  BTFSS  FD8.2
0A4D0:  GOTO   A516
0A4D4:  MOVLB  3
0A4D6:  MOVF   x32,W
0A4D8:  SUBWF  02,W
0A4DA:  BTFSC  FD8.0
0A4DC:  BRA    A4E4
0A4DE:  MOVLB  0
0A4E0:  GOTO   A614
0A4E4:  MOVLB  0
0A4E6:  BTFSS  FD8.2
0A4E8:  GOTO   A516
0A4EC:  MOVLB  3
0A4EE:  MOVF   x31,W
0A4F0:  SUBWF  01,W
0A4F2:  BTFSC  FD8.0
0A4F4:  BRA    A4FC
0A4F6:  MOVLB  0
0A4F8:  GOTO   A614
0A4FC:  MOVLB  0
0A4FE:  BTFSS  FD8.2
0A500:  GOTO   A516
0A504:  MOVF   00,W
0A506:  MOVLB  3
0A508:  SUBWF  x30,W
0A50A:  BTFSS  FD8.0
0A50C:  BRA    A514
0A50E:  MOVLB  0
0A510:  GOTO   A614
0A514:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0A516:  MOVFF  265,438
0A51A:  MOVFF  264,437
0A51E:  MOVFF  263,436
0A522:  MOVFF  262,435
0A526:  MOVFF  333,43C
0A52A:  MOVFF  332,43B
0A52E:  MOVFF  331,43A
0A532:  MOVFF  330,439
0A536:  MOVLW  02
0A538:  MOVLB  4
0A53A:  MOVWF  x3E
0A53C:  MOVLW  E0
0A53E:  MOVWF  x3D
0A540:  CLRF   x42
0A542:  CLRF   x41
0A544:  CLRF   x40
0A546:  MOVLW  40
0A548:  MOVWF  x3F
0A54A:  MOVLB  0
0A54C:  CALL   2792
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0A550:  MOVLB  3
0A552:  CLRF   x37
0A554:  CLRF   x36
0A556:  CLRF   x35
0A558:  CLRF   x34
0A55A:  MOVLB  0
0A55C:  MOVLB  3
0A55E:  MOVF   x37,F
0A560:  BTFSC  FD8.2
0A562:  BRA    A56A
0A564:  MOVLB  0
0A566:  GOTO   A5E4
0A56A:  MOVLB  0
0A56C:  MOVLB  3
0A56E:  MOVF   x36,F
0A570:  BTFSC  FD8.2
0A572:  BRA    A57A
0A574:  MOVLB  0
0A576:  GOTO   A5E4
0A57A:  MOVLB  0
0A57C:  MOVLB  3
0A57E:  MOVF   x35,F
0A580:  BTFSC  FD8.2
0A582:  BRA    A58A
0A584:  MOVLB  0
0A586:  GOTO   A5E4
0A58A:  MOVLB  0
0A58C:  MOVLB  3
0A58E:  MOVF   x34,W
0A590:  SUBLW  3F
0A592:  BTFSC  FD8.0
0A594:  BRA    A59C
0A596:  MOVLB  0
0A598:  GOTO   A5E4
0A59C:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A59E:  MOVLW  E0
0A5A0:  MOVLB  3
0A5A2:  ADDWF  x34,W
0A5A4:  MOVWF  FE9
0A5A6:  MOVLW  02
0A5A8:  ADDWFC x35,W
0A5AA:  MOVWF  FEA
0A5AC:  MOVFF  FEF,338
0A5B0:  MOVFF  338,B1B
0A5B4:  MOVLW  37
0A5B6:  MOVLB  B
0A5B8:  MOVWF  x1C
0A5BA:  MOVLB  0
0A5BC:  CALL   1E34
0A5C0:  MOVLW  20
0A5C2:  MOVLB  B
0A5C4:  MOVWF  x6E
0A5C6:  MOVLB  0
0A5C8:  CALL   1B5E
0A5CC:  MOVLW  01
0A5CE:  MOVLB  3
0A5D0:  ADDWF  x34,F
0A5D2:  BTFSC  FD8.0
0A5D4:  INCF   x35,F
0A5D6:  BTFSC  FD8.2
0A5D8:  INCF   x36,F
0A5DA:  BTFSC  FD8.2
0A5DC:  INCF   x37,F
0A5DE:  MOVLB  0
0A5E0:  GOTO   A55C
....................         }
....................         fprintf(PC, "\r\n");
0A5E4:  MOVLW  0D
0A5E6:  MOVLB  B
0A5E8:  MOVWF  x6E
0A5EA:  MOVLB  0
0A5EC:  CALL   1B5E
0A5F0:  MOVLW  0A
0A5F2:  MOVLB  B
0A5F4:  MOVWF  x6E
0A5F6:  MOVLB  0
0A5F8:  CALL   1B5E
0A5FC:  MOVLW  40
0A5FE:  MOVLB  3
0A600:  ADDWF  x30,F
0A602:  MOVLW  00
0A604:  ADDWFC x31,F
0A606:  MOVLW  00
0A608:  ADDWFC x32,F
0A60A:  MOVLW  00
0A60C:  ADDWFC x33,F
0A60E:  MOVLB  0
0A610:  GOTO   A4A4
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0A614:  MOVLW  BA
0A616:  MOVWF  FF6
0A618:  MOVLW  09
0A61A:  MOVWF  FF7
0A61C:  MOVLW  00
0A61E:  MOVWF  FF8
0A620:  CALL   1BB0
....................     fprintf(PC, "____________________\r\n\r\n");
0A624:  MOVLW  D2
0A626:  MOVWF  FF6
0A628:  MOVLW  09
0A62A:  MOVWF  FF7
0A62C:  MOVLW  00
0A62E:  MOVWF  FF8
0A630:  CALL   1BB0
0A634:  GOTO   ACC0 (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0A638:  MOVLW  EC
0A63A:  MOVWF  FF6
0A63C:  MOVLW  09
0A63E:  MOVWF  FF7
0A640:  MOVLW  00
0A642:  MOVWF  FF8
0A644:  CALL   1BB0
....................     fprintf(PC, "___Start smf_erase____\r\n");
0A648:  MOVLW  06
0A64A:  MOVWF  FF6
0A64C:  MOVLW  0A
0A64E:  MOVWF  FF7
0A650:  MOVLW  00
0A652:  MOVWF  FF8
0A654:  CALL   1BB0
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0A658:  MOVLB  2
0A65A:  MOVF   xDE,W
0A65C:  MOVWF  FE9
0A65E:  MOVF   xDF,W
0A660:  MOVWF  FEA
0A662:  MOVFF  FEF,2F0
0A666:  MOVFF  2F0,3BA
0A66A:  MOVLB  0
0A66C:  CALL   91F0
0A670:  MOVFF  02,03
0A674:  MOVF   01,W
0A676:  MOVWF  FE1
0A678:  MOVFF  03,FE2
0A67C:  MOVLW  02
0A67E:  MOVWF  FEA
0A680:  MOVLW  E0
0A682:  MOVWF  FE9
0A684:  MOVLW  08
0A686:  MOVWF  01
0A688:  MOVFF  FE6,FEE
0A68C:  DECFSZ 01,F
0A68E:  GOTO   A688
0A692:  MOVLW  04
0A694:  MOVLB  2
0A696:  ADDWF  xDE,W
0A698:  MOVWF  FE9
0A69A:  MOVLW  00
0A69C:  ADDWFC xDF,W
0A69E:  MOVWF  FEA
0A6A0:  MOVFF  FEF,2E8
0A6A4:  MOVFF  FEC,2E9
0A6A8:  MOVFF  FEC,2EA
0A6AC:  MOVFF  FEC,2EB
0A6B0:  MOVF   FED,F
0A6B2:  MOVF   FED,F
0A6B4:  MOVF   FED,F
0A6B6:  MOVLW  08
0A6B8:  ADDWF  xDE,W
0A6BA:  MOVWF  FE9
0A6BC:  MOVLW  00
0A6BE:  ADDWFC xDF,W
0A6C0:  MOVWF  FEA
0A6C2:  MOVFF  FEF,2EC
0A6C6:  MOVFF  FEC,2ED
0A6CA:  MOVFF  FEC,2EE
0A6CE:  MOVFF  FEC,2EF
0A6D2:  MOVF   FED,F
0A6D4:  MOVF   FED,F
0A6D6:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0A6D8:  MOVLW  20
0A6DA:  MOVWF  FF6
0A6DC:  MOVLW  0A
0A6DE:  MOVWF  FF7
0A6E0:  MOVLW  00
0A6E2:  MOVWF  FF8
0A6E4:  MOVLW  22
0A6E6:  MOVLB  B
0A6E8:  MOVWF  x1B
0A6EA:  MOVLB  0
0A6EC:  CALL   1BE0
0A6F0:  MOVFF  2EB,B1B
0A6F4:  MOVLW  37
0A6F6:  MOVLB  B
0A6F8:  MOVWF  x1C
0A6FA:  MOVLB  0
0A6FC:  CALL   1E34
0A700:  MOVFF  2EA,B1B
0A704:  MOVLW  37
0A706:  MOVLB  B
0A708:  MOVWF  x1C
0A70A:  MOVLB  0
0A70C:  CALL   1E34
0A710:  MOVFF  2E9,B1B
0A714:  MOVLW  37
0A716:  MOVLB  B
0A718:  MOVWF  x1C
0A71A:  MOVLB  0
0A71C:  CALL   1E34
0A720:  MOVFF  2E8,B1B
0A724:  MOVLW  37
0A726:  MOVLB  B
0A728:  MOVWF  x1C
0A72A:  MOVLB  0
0A72C:  CALL   1E34
0A730:  MOVLW  0D
0A732:  MOVLB  B
0A734:  MOVWF  x6E
0A736:  MOVLB  0
0A738:  CALL   1B5E
0A73C:  MOVLW  0A
0A73E:  MOVLB  B
0A740:  MOVWF  x6E
0A742:  MOVLB  0
0A744:  CALL   1B5E
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0A748:  MOVLW  48
0A74A:  MOVWF  FF6
0A74C:  MOVLW  0A
0A74E:  MOVWF  FF7
0A750:  MOVLW  00
0A752:  MOVWF  FF8
0A754:  MOVLW  22
0A756:  MOVLB  B
0A758:  MOVWF  x1B
0A75A:  MOVLB  0
0A75C:  CALL   1BE0
0A760:  MOVLW  41
0A762:  MOVWF  FE9
0A764:  MOVFF  2EF,33B
0A768:  MOVFF  2EE,33A
0A76C:  MOVFF  2ED,339
0A770:  MOVFF  2EC,338
0A774:  CALL   A1A8
0A778:  MOVLW  6D
0A77A:  MOVWF  FF6
0A77C:  MOVLW  0A
0A77E:  MOVWF  FF7
0A780:  MOVLW  00
0A782:  MOVWF  FF8
0A784:  MOVLW  04
0A786:  MOVLB  B
0A788:  MOVWF  x1B
0A78A:  MOVLB  0
0A78C:  CALL   1BE0
0A790:  MOVFF  2EF,B1B
0A794:  MOVLW  57
0A796:  MOVLB  B
0A798:  MOVWF  x1C
0A79A:  MOVLB  0
0A79C:  CALL   1E34
0A7A0:  MOVFF  2EE,B1B
0A7A4:  MOVLW  57
0A7A6:  MOVLB  B
0A7A8:  MOVWF  x1C
0A7AA:  MOVLB  0
0A7AC:  CALL   1E34
0A7B0:  MOVFF  2ED,B1B
0A7B4:  MOVLW  57
0A7B6:  MOVLB  B
0A7B8:  MOVWF  x1C
0A7BA:  MOVLB  0
0A7BC:  CALL   1E34
0A7C0:  MOVFF  2EC,B1B
0A7C4:  MOVLW  57
0A7C6:  MOVLB  B
0A7C8:  MOVWF  x1C
0A7CA:  MOVLB  0
0A7CC:  CALL   1E34
0A7D0:  MOVLW  74
0A7D2:  MOVWF  FF6
0A7D4:  MOVLW  0A
0A7D6:  MOVWF  FF7
0A7D8:  MOVLW  00
0A7DA:  MOVWF  FF8
0A7DC:  MOVLW  05
0A7DE:  MOVLB  B
0A7E0:  MOVWF  x1B
0A7E2:  MOVLB  0
0A7E4:  CALL   1BE0
.................... 
....................     if (!is_connect(smf)){
0A7E8:  MOVFF  265,3B6
0A7EC:  MOVFF  264,3B5
0A7F0:  MOVFF  263,3B4
0A7F4:  MOVFF  262,3B3
0A7F8:  CALL   26CA
0A7FC:  MOVF   01,F
0A7FE:  BTFSS  FD8.2
0A800:  GOTO   A818
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A804:  MOVLW  7A
0A806:  MOVWF  FF6
0A808:  MOVLW  0A
0A80A:  MOVWF  FF7
0A80C:  MOVLW  00
0A80E:  MOVWF  FF8
0A810:  CALL   1BB0
....................         return;
0A814:  GOTO   AB52
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0A818:  MOVLB  2
0A81A:  MOVF   xEB,W
0A81C:  SUBWF  xE3,W
0A81E:  BTFSC  FD8.0
0A820:  BRA    A828
0A822:  MOVLB  0
0A824:  GOTO   A872
0A828:  MOVLB  0
0A82A:  BTFSS  FD8.2
0A82C:  GOTO   A8CC
0A830:  MOVLB  2
0A832:  MOVF   xEA,W
0A834:  SUBWF  xE2,W
0A836:  BTFSC  FD8.0
0A838:  BRA    A840
0A83A:  MOVLB  0
0A83C:  GOTO   A872
0A840:  MOVLB  0
0A842:  BTFSS  FD8.2
0A844:  GOTO   A8CC
0A848:  MOVLB  2
0A84A:  MOVF   xE9,W
0A84C:  SUBWF  xE1,W
0A84E:  BTFSC  FD8.0
0A850:  BRA    A858
0A852:  MOVLB  0
0A854:  GOTO   A872
0A858:  MOVLB  0
0A85A:  BTFSS  FD8.2
0A85C:  GOTO   A8CC
0A860:  MOVLB  2
0A862:  MOVF   xE0,W
0A864:  SUBWF  xE8,W
0A866:  BTFSC  FD8.0
0A868:  BRA    A870
0A86A:  MOVLB  0
0A86C:  GOTO   A8CC
0A870:  MOVLB  0
0A872:  MOVLB  2
0A874:  MOVF   xE7,W
0A876:  SUBWF  xEB,W
0A878:  BTFSC  FD8.0
0A87A:  BRA    A882
0A87C:  MOVLB  0
0A87E:  GOTO   A9F0
0A882:  MOVLB  0
0A884:  BTFSS  FD8.2
0A886:  GOTO   A8CC
0A88A:  MOVLB  2
0A88C:  MOVF   xE6,W
0A88E:  SUBWF  xEA,W
0A890:  BTFSC  FD8.0
0A892:  BRA    A89A
0A894:  MOVLB  0
0A896:  GOTO   A9F0
0A89A:  MOVLB  0
0A89C:  BTFSS  FD8.2
0A89E:  GOTO   A8CC
0A8A2:  MOVLB  2
0A8A4:  MOVF   xE5,W
0A8A6:  SUBWF  xE9,W
0A8A8:  BTFSC  FD8.0
0A8AA:  BRA    A8B2
0A8AC:  MOVLB  0
0A8AE:  GOTO   A9F0
0A8B2:  MOVLB  0
0A8B4:  BTFSS  FD8.2
0A8B6:  GOTO   A8CC
0A8BA:  MOVLB  2
0A8BC:  MOVF   xE4,W
0A8BE:  SUBWF  xE8,W
0A8C0:  BTFSC  FD8.0
0A8C2:  BRA    A8CA
0A8C4:  MOVLB  0
0A8C6:  GOTO   A9F0
0A8CA:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0A8CC:  MOVLW  98
0A8CE:  MOVWF  FF6
0A8D0:  MOVLW  0A
0A8D2:  MOVWF  FF7
0A8D4:  MOVLW  00
0A8D6:  MOVWF  FF8
0A8D8:  MOVLW  1E
0A8DA:  MOVLB  B
0A8DC:  MOVWF  x1B
0A8DE:  MOVLB  0
0A8E0:  CALL   1BE0
0A8E4:  MOVFF  2EB,B1B
0A8E8:  MOVLW  37
0A8EA:  MOVLB  B
0A8EC:  MOVWF  x1C
0A8EE:  MOVLB  0
0A8F0:  CALL   1E34
0A8F4:  MOVFF  2EA,B1B
0A8F8:  MOVLW  37
0A8FA:  MOVLB  B
0A8FC:  MOVWF  x1C
0A8FE:  MOVLB  0
0A900:  CALL   1E34
0A904:  MOVFF  2E9,B1B
0A908:  MOVLW  37
0A90A:  MOVLB  B
0A90C:  MOVWF  x1C
0A90E:  MOVLB  0
0A910:  CALL   1E34
0A914:  MOVFF  2E8,B1B
0A918:  MOVLW  37
0A91A:  MOVLB  B
0A91C:  MOVWF  x1C
0A91E:  MOVLB  0
0A920:  CALL   1E34
0A924:  MOVLW  B9
0A926:  MOVWF  FF6
0A928:  MOVLW  0A
0A92A:  MOVWF  FF7
0A92C:  MOVLW  00
0A92E:  MOVWF  FF8
0A930:  MOVLW  1D
0A932:  MOVLB  B
0A934:  MOVWF  x1B
0A936:  MOVLB  0
0A938:  CALL   1BE0
0A93C:  MOVFF  2E3,B1B
0A940:  MOVLW  37
0A942:  MOVLB  B
0A944:  MOVWF  x1C
0A946:  MOVLB  0
0A948:  CALL   1E34
0A94C:  MOVFF  2E2,B1B
0A950:  MOVLW  37
0A952:  MOVLB  B
0A954:  MOVWF  x1C
0A956:  MOVLB  0
0A958:  CALL   1E34
0A95C:  MOVFF  2E1,B1B
0A960:  MOVLW  37
0A962:  MOVLB  B
0A964:  MOVWF  x1C
0A966:  MOVLB  0
0A968:  CALL   1E34
0A96C:  MOVFF  2E0,B1B
0A970:  MOVLW  37
0A972:  MOVLB  B
0A974:  MOVWF  x1C
0A976:  MOVLB  0
0A978:  CALL   1E34
0A97C:  MOVLW  D9
0A97E:  MOVWF  FF6
0A980:  MOVLW  0A
0A982:  MOVWF  FF7
0A984:  MOVLW  00
0A986:  MOVWF  FF8
0A988:  MOVLW  05
0A98A:  MOVLB  B
0A98C:  MOVWF  x1B
0A98E:  MOVLB  0
0A990:  CALL   1BE0
0A994:  MOVFF  2E7,B1B
0A998:  MOVLW  37
0A99A:  MOVLB  B
0A99C:  MOVWF  x1C
0A99E:  MOVLB  0
0A9A0:  CALL   1E34
0A9A4:  MOVFF  2E6,B1B
0A9A8:  MOVLW  37
0A9AA:  MOVLB  B
0A9AC:  MOVWF  x1C
0A9AE:  MOVLB  0
0A9B0:  CALL   1E34
0A9B4:  MOVFF  2E5,B1B
0A9B8:  MOVLW  37
0A9BA:  MOVLB  B
0A9BC:  MOVWF  x1C
0A9BE:  MOVLB  0
0A9C0:  CALL   1E34
0A9C4:  MOVFF  2E4,B1B
0A9C8:  MOVLW  37
0A9CA:  MOVLB  B
0A9CC:  MOVWF  x1C
0A9CE:  MOVLB  0
0A9D0:  CALL   1E34
0A9D4:  MOVLW  E1
0A9D6:  MOVWF  FF6
0A9D8:  MOVLW  0A
0A9DA:  MOVWF  FF7
0A9DC:  MOVLW  00
0A9DE:  MOVWF  FF8
0A9E0:  MOVLW  03
0A9E2:  MOVLB  B
0A9E4:  MOVWF  x1B
0A9E6:  MOVLB  0
0A9E8:  CALL   1BE0
....................         return;
0A9EC:  GOTO   AB52
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0A9F0:  MOVLB  2
0A9F2:  MOVF   xEC,W
0A9F4:  ADDWF  xE8,W
0A9F6:  MOVWF  xF0
0A9F8:  MOVF   xED,W
0A9FA:  ADDWFC xE9,W
0A9FC:  MOVWF  xF1
0A9FE:  MOVF   xEE,W
0AA00:  ADDWFC xEA,W
0AA02:  MOVWF  xF2
0AA04:  MOVF   xEF,W
0AA06:  ADDWFC xEB,W
0AA08:  MOVWF  xF3
0AA0A:  MOVF   xE7,W
0AA0C:  SUBWF  xF3,W
0AA0E:  BTFSC  FD8.0
0AA10:  BRA    AA18
0AA12:  MOVLB  0
0AA14:  GOTO   AAFE
0AA18:  MOVLB  0
0AA1A:  BTFSS  FD8.2
0AA1C:  GOTO   AA62
0AA20:  MOVLB  2
0AA22:  MOVF   xE6,W
0AA24:  SUBWF  xF2,W
0AA26:  BTFSC  FD8.0
0AA28:  BRA    AA30
0AA2A:  MOVLB  0
0AA2C:  GOTO   AAFE
0AA30:  MOVLB  0
0AA32:  BTFSS  FD8.2
0AA34:  GOTO   AA62
0AA38:  MOVLB  2
0AA3A:  MOVF   xE5,W
0AA3C:  SUBWF  xF1,W
0AA3E:  BTFSC  FD8.0
0AA40:  BRA    AA48
0AA42:  MOVLB  0
0AA44:  GOTO   AAFE
0AA48:  MOVLB  0
0AA4A:  BTFSS  FD8.2
0AA4C:  GOTO   AA62
0AA50:  MOVLB  2
0AA52:  MOVF   xF0,W
0AA54:  SUBWF  xE4,W
0AA56:  BTFSS  FD8.0
0AA58:  BRA    AA60
0AA5A:  MOVLB  0
0AA5C:  GOTO   AAFE
0AA60:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0AA62:  MOVLW  E6
0AA64:  MOVWF  FF6
0AA66:  MOVLW  0A
0AA68:  MOVWF  FF7
0AA6A:  MOVLW  00
0AA6C:  MOVWF  FF8
0AA6E:  MOVLW  3A
0AA70:  MOVLB  B
0AA72:  MOVWF  x1B
0AA74:  MOVLB  0
0AA76:  CALL   1BE0
0AA7A:  MOVFF  2E7,B1B
0AA7E:  MOVLW  37
0AA80:  MOVLB  B
0AA82:  MOVWF  x1C
0AA84:  MOVLB  0
0AA86:  CALL   1E34
0AA8A:  MOVFF  2E6,B1B
0AA8E:  MOVLW  37
0AA90:  MOVLB  B
0AA92:  MOVWF  x1C
0AA94:  MOVLB  0
0AA96:  CALL   1E34
0AA9A:  MOVFF  2E5,B1B
0AA9E:  MOVLW  37
0AAA0:  MOVLB  B
0AAA2:  MOVWF  x1C
0AAA4:  MOVLB  0
0AAA6:  CALL   1E34
0AAAA:  MOVFF  2E4,B1B
0AAAE:  MOVLW  37
0AAB0:  MOVLB  B
0AAB2:  MOVWF  x1C
0AAB4:  MOVLB  0
0AAB6:  CALL   1E34
0AABA:  MOVLW  0D
0AABC:  MOVLB  B
0AABE:  MOVWF  x6E
0AAC0:  MOVLB  0
0AAC2:  CALL   1B5E
0AAC6:  MOVLW  0A
0AAC8:  MOVLB  B
0AACA:  MOVWF  x6E
0AACC:  MOVLB  0
0AACE:  CALL   1B5E
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0AAD2:  MOVLW  26
0AAD4:  MOVWF  FF6
0AAD6:  MOVLW  0B
0AAD8:  MOVWF  FF7
0AADA:  MOVLW  00
0AADC:  MOVWF  FF8
0AADE:  CALL   1BB0
....................         erase_size = mission_type.end_address - erase_address;
0AAE2:  MOVLB  2
0AAE4:  MOVF   xE8,W
0AAE6:  SUBWF  xE4,W
0AAE8:  MOVWF  xEC
0AAEA:  MOVF   xE9,W
0AAEC:  SUBWFB xE5,W
0AAEE:  MOVWF  xED
0AAF0:  MOVF   xEA,W
0AAF2:  SUBWFB xE6,W
0AAF4:  MOVWF  xEE
0AAF6:  MOVF   xEB,W
0AAF8:  SUBWFB xE7,W
0AAFA:  MOVWF  xEF
0AAFC:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0AAFE:  MOVLW  5A
0AB00:  MOVWF  FF6
0AB02:  MOVLW  0B
0AB04:  MOVWF  FF7
0AB06:  MOVLW  00
0AB08:  MOVWF  FF8
0AB0A:  CALL   1BB0
....................     subsector_4kByte_erase(smf, erase_address);
0AB0E:  MOVFF  265,438
0AB12:  MOVFF  264,437
0AB16:  MOVFF  263,436
0AB1A:  MOVFF  262,435
0AB1E:  MOVFF  2EB,43C
0AB22:  MOVFF  2EA,43B
0AB26:  MOVFF  2E9,43A
0AB2A:  MOVFF  2E8,439
0AB2E:  CALL   4B38
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0AB32:  MOVLW  8C
0AB34:  MOVWF  FF6
0AB36:  MOVLW  0B
0AB38:  MOVWF  FF7
0AB3A:  MOVLW  00
0AB3C:  MOVWF  FF8
0AB3E:  CALL   1BB0
....................     fprintf(PC, "____________________\r\n\r\n");
0AB42:  MOVLW  A6
0AB44:  MOVWF  FF6
0AB46:  MOVLW  0B
0AB48:  MOVWF  FF7
0AB4A:  MOVLW  00
0AB4C:  MOVWF  FF8
0AB4E:  CALL   1BB0
0AB52:  GOTO   ACEE (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
09896:  GOTO   A0FC (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
09702:  GOTO   9CD8 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... 
.................... #include "../core/storage/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"                // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"             // ツールライブラリ
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
.................... 
.................... int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 frame[], int8 payload_size);        
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"              // SMFキュー管理
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
02FAA:  MOVLW  2C
02FAC:  MOVWF  FF6
02FAE:  MOVLW  0C
02FB0:  MOVWF  FF7
02FB2:  MOVLW  00
02FB4:  MOVWF  FF8
02FB6:  CALL   1BB0
....................     output_high(MIS_FM_CS);
02FBA:  MOVLW  DB
02FBC:  MOVWF  F92
02FBE:  BSF    F89.5
....................     output_high(SMF_CS);
02FC0:  MOVLW  DB
02FC2:  MOVWF  F92
02FC4:  BSF    F89.2
....................     delay_ms(100);
02FC6:  MOVLW  64
02FC8:  MOVLB  B
02FCA:  MOVWF  xC3
02FCC:  MOVLB  0
02FCE:  CALL   1B30
....................     //=== [MIS_FM] READ ID ===//
....................     READ_ID_DATA misf_read_id_data;
....................     int8 flash_cmd = CMD_READ_ID;
02FD2:  MOVLW  9F
02FD4:  MOVLB  3
02FD6:  MOVWF  x37
.................... 
....................     output_low(mis_fm.cs_pin);
02FD8:  MOVFF  260,BC9
02FDC:  MOVLB  B
02FDE:  CLRF   xCA
02FE0:  MOVLW  0F
02FE2:  MOVWF  xCC
02FE4:  MOVLW  89
02FE6:  MOVWF  xCB
02FE8:  MOVLB  0
02FEA:  CALL   234A
02FEE:  MOVFF  260,BC9
02FF2:  MOVLB  B
02FF4:  CLRF   xCA
02FF6:  MOVLW  0F
02FF8:  MOVWF  xCC
02FFA:  MOVLW  92
02FFC:  MOVWF  xCB
02FFE:  MOVLB  0
03000:  CALL   234A
....................     spi_xfer_and_read_select_stream(mis_fm, &flash_cmd, 1, misf_read_id_data.bytes, READ_ID_DATASIZE);
03004:  MOVFF  261,BCC
03008:  MOVFF  260,BCB
0300C:  MOVFF  25F,BCA
03010:  MOVFF  25E,BC9
03014:  MOVLW  03
03016:  MOVLB  B
03018:  MOVWF  xCE
0301A:  MOVLW  37
0301C:  MOVWF  xCD
0301E:  CLRF   xD0
03020:  MOVLW  01
03022:  MOVWF  xCF
03024:  MOVLW  03
03026:  MOVWF  xD2
03028:  MOVLW  23
0302A:  MOVWF  xD1
0302C:  CLRF   xD6
0302E:  CLRF   xD5
03030:  CLRF   xD4
03032:  MOVLW  14
03034:  MOVWF  xD3
03036:  MOVLB  0
03038:  CALL   2496
....................     output_high(mis_fm.cs_pin);
0303C:  MOVFF  260,BC9
03040:  MOVLW  01
03042:  MOVLB  B
03044:  MOVWF  xCA
03046:  MOVLW  0F
03048:  MOVWF  xCC
0304A:  MOVLW  89
0304C:  MOVWF  xCB
0304E:  MOVLB  0
03050:  CALL   234A
03054:  MOVFF  260,BC9
03058:  MOVLB  B
0305A:  CLRF   xCA
0305C:  MOVLW  0F
0305E:  MOVWF  xCC
03060:  MOVLW  92
03062:  MOVWF  xCB
03064:  MOVLB  0
03066:  CALL   234A
.................... 
....................     fprintf(PC, "\t[MIS FM] READ ID: ");
0306A:  MOVLW  48
0306C:  MOVWF  FF6
0306E:  MOVLW  0C
03070:  MOVWF  FF7
03072:  MOVLW  00
03074:  MOVWF  FF8
03076:  CALL   1BB0
....................     for (unsigned int8 i = 0; i < 4; i++) {
0307A:  MOVLB  3
0307C:  CLRF   x38
0307E:  MOVLB  0
03080:  MOVLB  3
03082:  MOVF   x38,W
03084:  SUBLW  03
03086:  BTFSC  FD8.0
03088:  BRA    3090
0308A:  MOVLB  0
0308C:  GOTO   30CC
03090:  MOVLB  0
....................         fprintf(PC, "%02X ", misf_read_id_data.bytes[i]);
03092:  CLRF   03
03094:  MOVLB  3
03096:  MOVF   x38,W
03098:  ADDLW  23
0309A:  MOVWF  FE9
0309C:  MOVLW  03
0309E:  ADDWFC 03,W
030A0:  MOVWF  FEA
030A2:  MOVFF  FEF,38E
030A6:  MOVFF  38E,B1B
030AA:  MOVLW  37
030AC:  MOVLB  B
030AE:  MOVWF  x1C
030B0:  MOVLB  0
030B2:  CALL   1E34
030B6:  MOVLW  20
030B8:  MOVLB  B
030BA:  MOVWF  x6E
030BC:  MOVLB  0
030BE:  CALL   1B5E
030C2:  MOVLB  3
030C4:  INCF   x38,F
030C6:  MOVLB  0
030C8:  GOTO   3080
....................     }
....................     fprintf(PC, "\r\n");
030CC:  MOVLW  0D
030CE:  MOVLB  B
030D0:  MOVWF  x6E
030D2:  MOVLB  0
030D4:  CALL   1B5E
030D8:  MOVLW  0A
030DA:  MOVLB  B
030DC:  MOVWF  x6E
030DE:  MOVLB  0
030E0:  CALL   1B5E
.................... 
....................     //=== [SMF] READ ID ===//
....................     READ_ID_DATA smf_read_id_data;
.................... 
....................     output_low(SMF_CS);
030E4:  MOVLW  DB
030E6:  MOVWF  F92
030E8:  BCF    F89.2
....................     delay_us(100); // 微小ディレイ
030EA:  MOVLW  85
030EC:  MOVWF  00
030EE:  DECFSZ 00,F
030F0:  BRA    30EE
....................     spi_xfer_and_read_select_stream(smf, &flash_cmd, 1, smf_read_id_data.bytes, READ_ID_DATASIZE);
030F2:  MOVFF  265,BCC
030F6:  MOVFF  264,BCB
030FA:  MOVFF  263,BCA
030FE:  MOVFF  262,BC9
03102:  MOVLW  03
03104:  MOVLB  B
03106:  MOVWF  xCE
03108:  MOVLW  37
0310A:  MOVWF  xCD
0310C:  CLRF   xD0
0310E:  MOVLW  01
03110:  MOVWF  xCF
03112:  MOVLW  03
03114:  MOVWF  xD2
03116:  MOVLW  39
03118:  MOVWF  xD1
0311A:  CLRF   xD6
0311C:  CLRF   xD5
0311E:  CLRF   xD4
03120:  MOVLW  14
03122:  MOVWF  xD3
03124:  MOVLB  0
03126:  CALL   2496
....................     output_high(SMF_CS);
0312A:  MOVLW  DB
0312C:  MOVWF  F92
0312E:  BSF    F89.2
.................... 
....................     fprintf(PC, "\t[SMF   ] READ ID: ");
03130:  MOVLW  5C
03132:  MOVWF  FF6
03134:  MOVLW  0C
03136:  MOVWF  FF7
03138:  MOVLW  00
0313A:  MOVWF  FF8
0313C:  CALL   1BB0
....................     for (unsigned int8 i = 0; i < 4; i++) {
03140:  MOVLB  3
03142:  CLRF   x4D
03144:  MOVLB  0
03146:  MOVLB  3
03148:  MOVF   x4D,W
0314A:  SUBLW  03
0314C:  BTFSC  FD8.0
0314E:  BRA    3156
03150:  MOVLB  0
03152:  GOTO   3192
03156:  MOVLB  0
....................         fprintf(PC, "%02X ", smf_read_id_data.bytes[i]);
03158:  CLRF   03
0315A:  MOVLB  3
0315C:  MOVF   x4D,W
0315E:  ADDLW  39
03160:  MOVWF  FE9
03162:  MOVLW  03
03164:  ADDWFC 03,W
03166:  MOVWF  FEA
03168:  MOVFF  FEF,38E
0316C:  MOVFF  38E,B1B
03170:  MOVLW  37
03172:  MOVLB  B
03174:  MOVWF  x1C
03176:  MOVLB  0
03178:  CALL   1E34
0317C:  MOVLW  20
0317E:  MOVLB  B
03180:  MOVWF  x6E
03182:  MOVLB  0
03184:  CALL   1B5E
03188:  MOVLB  3
0318A:  INCF   x4D,F
0318C:  MOVLB  0
0318E:  GOTO   3146
....................     }
....................     fprintf(PC, "\r\n");
03192:  MOVLW  0D
03194:  MOVLB  B
03196:  MOVWF  x6E
03198:  MOVLB  0
0319A:  CALL   1B5E
0319E:  MOVLW  0A
031A0:  MOVLB  B
031A2:  MOVWF  x6E
031A4:  MOVLB  0
031A6:  CALL   1B5E
.................... 
....................     //=== 接続確認 ===//
....................     if (!is_connect(smf)) {
031AA:  MOVFF  265,3B6
031AE:  MOVFF  264,3B5
031B2:  MOVFF  263,3B4
031B6:  MOVFF  262,3B3
031BA:  CALL   26CA
031BE:  MOVF   01,F
031C0:  BTFSS  FD8.2
031C2:  GOTO   31DA
....................         fprintf(PC, "\t[SMF   ] connect error!\r\n");
031C6:  MOVLW  70
031C8:  MOVWF  FF6
031CA:  MOVLW  0C
031CC:  MOVWF  FF7
031CE:  MOVLW  00
031D0:  MOVWF  FF8
031D2:  CALL   1BB0
....................     } else {
031D6:  GOTO   31EA
....................         fprintf(PC, "\t[SMF   ] is connected\r\n");
031DA:  MOVLW  8C
031DC:  MOVWF  FF6
031DE:  MOVLW  0C
031E0:  MOVWF  FF7
031E2:  MOVLW  00
031E4:  MOVWF  FF8
031E6:  CALL   1BB0
....................     }
.................... 
....................     delay_ms(100);
031EA:  MOVLW  64
031EC:  MOVLB  B
031EE:  MOVWF  xC3
031F0:  MOVLB  0
031F2:  CALL   1B30
.................... 
....................     if (!is_connect(mis_fm)) {
031F6:  MOVFF  261,3B6
031FA:  MOVFF  260,3B5
031FE:  MOVFF  25F,3B4
03202:  MOVFF  25E,3B3
03206:  CALL   26CA
0320A:  MOVF   01,F
0320C:  BTFSS  FD8.2
0320E:  GOTO   3226
....................         fprintf(PC, "\t[MIS FM] connect error!\r\n");
03212:  MOVLW  A6
03214:  MOVWF  FF6
03216:  MOVLW  0C
03218:  MOVWF  FF7
0321A:  MOVLW  00
0321C:  MOVWF  FF8
0321E:  CALL   1BB0
....................     } else {
03222:  GOTO   3236
....................         fprintf(PC, "\t[MIS FM] is connected\r\n");
03226:  MOVLW  C2
03228:  MOVWF  FF6
0322A:  MOVLW  0C
0322C:  MOVWF  FF7
0322E:  MOVLW  00
03230:  MOVWF  FF8
03232:  CALL   1BB0
....................     }
.................... 
....................     //=== MIS_FMからログ領域読み出し ===//
....................     FlashData_t flash_data;
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_END, flash_data.bytes, PACKET_SIZE);
03236:  MOVFF  261,438
0323A:  MOVFF  260,437
0323E:  MOVFF  25F,436
03242:  MOVFF  25E,435
03246:  MOVLB  4
03248:  CLRF   x3C
0324A:  CLRF   x3B
0324C:  SETF   x3A
0324E:  SETF   x39
03250:  MOVLW  03
03252:  MOVWF  x3E
03254:  MOVLW  4E
03256:  MOVWF  x3D
03258:  CLRF   x42
0325A:  CLRF   x41
0325C:  CLRF   x40
0325E:  MOVLW  40
03260:  MOVWF  x3F
03262:  MOVLB  0
03264:  CALL   2792
.................... 
....................     if (flash_data.packet.crc != calc_crc8(flash_data.bytes, PACKET_SIZE - 1)) {
03268:  MOVLW  03
0326A:  MOVLB  C
0326C:  MOVWF  x03
0326E:  MOVLW  4E
03270:  MOVWF  x02
03272:  MOVLW  3F
03274:  MOVWF  x04
03276:  MOVLB  0
03278:  CALL   29AA
0327C:  MOVF   01,W
0327E:  MOVLB  3
03280:  SUBWF  x76,W
03282:  BTFSS  FD8.2
03284:  BRA    328C
03286:  MOVLB  0
03288:  GOTO   32A2
0328C:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error!\r\n");
0328E:  MOVLW  DC
03290:  MOVWF  FF6
03292:  MOVLW  0C
03294:  MOVWF  FF7
03296:  MOVLW  00
03298:  MOVWF  FF8
0329A:  CALL   1BB0
....................         return;
0329E:  GOTO   335E
....................     }
.................... 
....................     //=== カウンタ情報の反映 ===//
....................     piclog_data       = *((Flash_t*)&flash_data.packet.payload.logdata.piclog);
032A2:  MOVLW  03
032A4:  MOVLB  3
032A6:  MOVWF  x8F
032A8:  MOVLW  4E
032AA:  MOVWF  x8E
032AC:  MOVFF  38F,03
032B0:  MOVF   x8E,W
032B2:  MOVWF  FE1
032B4:  MOVFF  03,FE2
032B8:  MOVLW  02
032BA:  MOVWF  FEA
032BC:  MOVLW  6E
032BE:  MOVWF  FE9
032C0:  MOVLW  0B
032C2:  MOVWF  01
032C4:  MOVLB  0
032C6:  MOVFF  FE6,FEE
032CA:  DECFSZ 01,F
032CC:  GOTO   32C6
....................     environment_data  = *((Flash_t*)&flash_data.packet.payload.logdata.environment);
032D0:  MOVLW  03
032D2:  MOVLB  3
032D4:  MOVWF  x8F
032D6:  MOVLW  58
032D8:  MOVWF  x8E
032DA:  MOVFF  38F,03
032DE:  MOVF   x8E,W
032E0:  MOVWF  FE1
032E2:  MOVFF  03,FE2
032E6:  MOVLW  02
032E8:  MOVWF  FEA
032EA:  MOVLW  79
032EC:  MOVWF  FE9
032EE:  MOVLW  0B
032F0:  MOVWF  01
032F2:  MOVLB  0
032F4:  MOVFF  FE6,FEE
032F8:  DECFSZ 01,F
032FA:  GOTO   32F4
....................     iv_header         = *((Flash_t*)&flash_data.packet.payload.logdata.iv_header);
032FE:  MOVLW  03
03300:  MOVLB  3
03302:  MOVWF  x8F
03304:  MOVLW  62
03306:  MOVWF  x8E
03308:  MOVFF  38F,03
0330C:  MOVF   x8E,W
0330E:  MOVWF  FE1
03310:  MOVFF  03,FE2
03314:  MOVLW  02
03316:  MOVWF  FEA
03318:  MOVLW  84
0331A:  MOVWF  FE9
0331C:  MOVLW  0B
0331E:  MOVWF  01
03320:  MOVLB  0
03322:  MOVFF  FE6,FEE
03326:  DECFSZ 01,F
03328:  GOTO   3322
....................     iv_data           = *((Flash_t*)&flash_data.packet.payload.logdata.iv_data);
0332C:  MOVLW  03
0332E:  MOVLB  3
03330:  MOVWF  x8F
03332:  MOVLW  6C
03334:  MOVWF  x8E
03336:  MOVFF  38F,03
0333A:  MOVF   x8E,W
0333C:  MOVWF  FE1
0333E:  MOVFF  03,FE2
03342:  MOVLW  02
03344:  MOVWF  FEA
03346:  MOVLW  8F
03348:  MOVWF  FE9
0334A:  MOVLW  0B
0334C:  MOVWF  01
0334E:  MOVLB  0
03350:  MOVFF  FE6,FEE
03354:  DECFSZ 01,F
03356:  GOTO   3350
....................     print_flash_status();
0335A:  GOTO   2A16
0335E:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table(void)
.................... {
....................     FlashData_t flash_data;
....................     memset(&flash_data, 0, sizeof(flash_data));
*
03A26:  MOVLW  0B
03A28:  MOVWF  FEA
03A2A:  MOVLW  B1
03A2C:  MOVWF  FE9
03A2E:  CLRF   00
03A30:  CLRF   02
03A32:  MOVLW  40
03A34:  MOVWF  01
03A36:  CALL   3A02
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv_header,
....................         &flash_data.packet.payload.logdata.iv_data
....................     };
03A3A:  MOVLW  0B
03A3C:  MOVLB  B
03A3E:  MOVWF  xF2
03A40:  MOVLW  B1
03A42:  MOVWF  xF1
03A44:  MOVLW  0B
03A46:  MOVWF  xF4
03A48:  MOVLW  BB
03A4A:  MOVWF  xF3
03A4C:  MOVLW  0B
03A4E:  MOVWF  xF6
03A50:  MOVLW  C5
03A52:  MOVWF  xF5
03A54:  MOVLW  0B
03A56:  MOVWF  xF8
03A58:  MOVLW  CF
03A5A:  MOVWF  xF7
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv_header,
....................         &iv_data
....................     };
03A5C:  MOVLW  02
03A5E:  MOVWF  xFA
03A60:  MOVLW  6E
03A62:  MOVWF  xF9
03A64:  MOVLW  02
03A66:  MOVWF  xFC
03A68:  MOVLW  79
03A6A:  MOVWF  xFB
03A6C:  MOVLW  02
03A6E:  MOVWF  xFE
03A70:  MOVLW  84
03A72:  MOVWF  xFD
03A74:  MOVLW  02
03A76:  MOVLB  C
03A78:  MOVWF  x00
03A7A:  MOVLW  8F
03A7C:  MOVLB  B
03A7E:  MOVWF  xFF
.................... 
....................     for(int i=0; i<4; i++){
03A80:  MOVLB  C
03A82:  CLRF   x01
03A84:  MOVLB  0
03A86:  MOVLB  C
03A88:  MOVF   x01,W
03A8A:  SUBLW  03
03A8C:  BTFSC  FD8.0
03A8E:  BRA    3A96
03A90:  MOVLB  0
03A92:  GOTO   3D4A
03A96:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
03A98:  CLRF   03
03A9A:  MOVLB  C
03A9C:  MOVF   x01,W
03A9E:  MOVWF  02
03AA0:  BCF    FD8.0
03AA2:  RLCF   02,F
03AA4:  RLCF   03,F
03AA6:  MOVF   02,W
03AA8:  ADDLW  F1
03AAA:  MOVWF  01
03AAC:  MOVLW  0B
03AAE:  ADDWFC 03,F
03AB0:  MOVF   01,W
03AB2:  MOVWF  x02
03AB4:  MOVFF  03,C03
03AB8:  MOVFF  C03,FEA
03ABC:  MOVFF  C02,FE9
03AC0:  MOVFF  FEC,C05
03AC4:  MOVF   FED,F
03AC6:  MOVFF  FEF,C04
03ACA:  MOVF   x04,W
03ACC:  MOVWF  01
03ACE:  MOVF   x05,W
03AD0:  MOVWF  03
03AD2:  MOVF   01,W
03AD4:  MOVWF  x06
03AD6:  MOVFF  03,C07
03ADA:  CLRF   03
03ADC:  MOVF   x01,W
03ADE:  MOVWF  02
03AE0:  BCF    FD8.0
03AE2:  RLCF   02,F
03AE4:  RLCF   03,F
03AE6:  MOVF   02,W
03AE8:  ADDLW  F9
03AEA:  MOVWF  01
03AEC:  MOVLW  0B
03AEE:  ADDWFC 03,F
03AF0:  MOVF   01,W
03AF2:  MOVWF  x08
03AF4:  MOVFF  03,C09
03AF8:  MOVFF  C09,FEA
03AFC:  MOVFF  C08,FE9
03B00:  MOVFF  FEC,C0B
03B04:  MOVF   FED,F
03B06:  MOVFF  FEF,C0A
03B0A:  MOVLW  01
03B0C:  ADDWF  x0A,W
03B0E:  MOVWF  FE9
03B10:  MOVLW  00
03B12:  ADDWFC x0B,W
03B14:  MOVWF  FEA
03B16:  MOVFF  FEF,00
03B1A:  MOVFF  FEC,01
03B1E:  MOVFF  FEC,02
03B22:  MOVFF  FEC,03
03B26:  MOVF   FED,F
03B28:  MOVF   FED,F
03B2A:  MOVF   FED,F
03B2C:  MOVFF  03,C0F
03B30:  MOVFF  02,C0E
03B34:  MOVFF  01,C0D
03B38:  MOVFF  00,C0C
03B3C:  MOVFF  C07,FEA
03B40:  MOVFF  C06,FE9
03B44:  MOVFF  C0C,FEF
03B48:  MOVFF  C0D,FEC
03B4C:  MOVFF  C0E,FEC
03B50:  MOVFF  C0F,FEC
03B54:  MOVF   FED,F
03B56:  MOVF   FED,F
03B58:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
03B5A:  CLRF   03
03B5C:  MOVF   x01,W
03B5E:  MOVWF  02
03B60:  BCF    FD8.0
03B62:  RLCF   02,F
03B64:  RLCF   03,F
03B66:  MOVF   02,W
03B68:  ADDLW  F1
03B6A:  MOVWF  01
03B6C:  MOVLW  0B
03B6E:  ADDWFC 03,F
03B70:  MOVF   01,W
03B72:  MOVWF  x02
03B74:  MOVFF  03,C03
03B78:  MOVFF  C03,FEA
03B7C:  MOVFF  C02,FE9
03B80:  MOVFF  FEC,C05
03B84:  MOVF   FED,F
03B86:  MOVFF  FEF,C04
03B8A:  MOVLW  04
03B8C:  ADDWF  x04,W
03B8E:  MOVWF  01
03B90:  MOVLW  00
03B92:  ADDWFC x05,W
03B94:  MOVWF  03
03B96:  MOVF   01,W
03B98:  MOVWF  x06
03B9A:  MOVFF  03,C07
03B9E:  CLRF   03
03BA0:  MOVF   x01,W
03BA2:  MOVWF  02
03BA4:  BCF    FD8.0
03BA6:  RLCF   02,F
03BA8:  RLCF   03,F
03BAA:  MOVF   02,W
03BAC:  ADDLW  F9
03BAE:  MOVWF  01
03BB0:  MOVLW  0B
03BB2:  ADDWFC 03,F
03BB4:  MOVF   01,W
03BB6:  MOVWF  x08
03BB8:  MOVFF  03,C09
03BBC:  MOVFF  C09,FEA
03BC0:  MOVFF  C08,FE9
03BC4:  MOVFF  FEC,C0B
03BC8:  MOVF   FED,F
03BCA:  MOVFF  FEF,C0A
03BCE:  MOVLW  05
03BD0:  ADDWF  x0A,W
03BD2:  MOVWF  FE9
03BD4:  MOVLW  00
03BD6:  ADDWFC x0B,W
03BD8:  MOVWF  FEA
03BDA:  MOVFF  FEF,00
03BDE:  MOVFF  FEC,01
03BE2:  MOVFF  FEC,02
03BE6:  MOVFF  FEC,03
03BEA:  MOVF   FED,F
03BEC:  MOVF   FED,F
03BEE:  MOVF   FED,F
03BF0:  MOVFF  03,C0F
03BF4:  MOVFF  02,C0E
03BF8:  MOVFF  01,C0D
03BFC:  MOVFF  00,C0C
03C00:  MOVFF  C07,FEA
03C04:  MOVFF  C06,FE9
03C08:  MOVFF  C0C,FEF
03C0C:  MOVFF  C0D,FEC
03C10:  MOVFF  C0E,FEC
03C14:  MOVFF  C0F,FEC
03C18:  MOVF   FED,F
03C1A:  MOVF   FED,F
03C1C:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
03C1E:  CLRF   03
03C20:  MOVF   x01,W
03C22:  MOVWF  02
03C24:  BCF    FD8.0
03C26:  RLCF   02,F
03C28:  RLCF   03,F
03C2A:  MOVF   02,W
03C2C:  ADDLW  F1
03C2E:  MOVWF  01
03C30:  MOVLW  0B
03C32:  ADDWFC 03,F
03C34:  MOVF   01,W
03C36:  MOVWF  x02
03C38:  MOVFF  03,C03
03C3C:  MOVFF  C03,FEA
03C40:  MOVFF  C02,FE9
03C44:  MOVFF  FEC,C05
03C48:  MOVF   FED,F
03C4A:  MOVFF  FEF,C04
03C4E:  MOVLW  08
03C50:  ADDWF  x04,W
03C52:  MOVWF  01
03C54:  MOVLW  00
03C56:  ADDWFC x05,W
03C58:  MOVWF  03
03C5A:  MOVF   01,W
03C5C:  MOVWF  x06
03C5E:  MOVFF  03,C07
03C62:  CLRF   03
03C64:  MOVF   x01,W
03C66:  MOVWF  02
03C68:  BCF    FD8.0
03C6A:  RLCF   02,F
03C6C:  RLCF   03,F
03C6E:  MOVF   02,W
03C70:  ADDLW  F9
03C72:  MOVWF  01
03C74:  MOVLW  0B
03C76:  ADDWFC 03,F
03C78:  MOVF   01,W
03C7A:  MOVWF  x08
03C7C:  MOVFF  03,C09
03C80:  MOVFF  C09,FEA
03C84:  MOVFF  C08,FE9
03C88:  MOVFF  FEC,C0B
03C8C:  MOVF   FED,F
03C8E:  MOVFF  FEF,C0A
03C92:  MOVLW  09
03C94:  ADDWF  x0A,W
03C96:  MOVWF  FE9
03C98:  MOVLW  00
03C9A:  ADDWFC x0B,W
03C9C:  MOVWF  FEA
03C9E:  MOVF   FEF,W
03CA0:  MOVWF  x0C
03CA2:  MOVFF  C07,FEA
03CA6:  MOVFF  C06,FE9
03CAA:  MOVFF  C0C,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
03CAE:  CLRF   03
03CB0:  MOVF   x01,W
03CB2:  MOVWF  02
03CB4:  BCF    FD8.0
03CB6:  RLCF   02,F
03CB8:  RLCF   03,F
03CBA:  MOVF   02,W
03CBC:  ADDLW  F1
03CBE:  MOVWF  01
03CC0:  MOVLW  0B
03CC2:  ADDWFC 03,F
03CC4:  MOVF   01,W
03CC6:  MOVWF  x02
03CC8:  MOVFF  03,C03
03CCC:  MOVFF  C03,FEA
03CD0:  MOVFF  C02,FE9
03CD4:  MOVFF  FEC,C05
03CD8:  MOVF   FED,F
03CDA:  MOVFF  FEF,C04
03CDE:  MOVLW  09
03CE0:  ADDWF  x04,W
03CE2:  MOVWF  01
03CE4:  MOVLW  00
03CE6:  ADDWFC x05,W
03CE8:  MOVWF  03
03CEA:  MOVF   01,W
03CEC:  MOVWF  x06
03CEE:  MOVFF  03,C07
03CF2:  CLRF   03
03CF4:  MOVF   x01,W
03CF6:  MOVWF  02
03CF8:  BCF    FD8.0
03CFA:  RLCF   02,F
03CFC:  RLCF   03,F
03CFE:  MOVF   02,W
03D00:  ADDLW  F9
03D02:  MOVWF  01
03D04:  MOVLW  0B
03D06:  ADDWFC 03,F
03D08:  MOVF   01,W
03D0A:  MOVWF  x08
03D0C:  MOVFF  03,C09
03D10:  MOVFF  C09,FEA
03D14:  MOVFF  C08,FE9
03D18:  MOVFF  FEC,C0B
03D1C:  MOVF   FED,F
03D1E:  MOVFF  FEF,C0A
03D22:  MOVLW  0A
03D24:  ADDWF  x0A,W
03D26:  MOVWF  FE9
03D28:  MOVLW  00
03D2A:  ADDWFC x0B,W
03D2C:  MOVWF  FEA
03D2E:  MOVF   FEF,W
03D30:  MOVWF  x0C
03D32:  MOVFF  C07,FEA
03D36:  MOVFF  C06,FE9
03D3A:  MOVFF  C0C,FEF
03D3E:  MOVLB  0
03D40:  MOVLB  C
03D42:  INCF   x01,F
03D44:  MOVLB  0
03D46:  GOTO   3A86
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
03D4A:  MOVLW  0B
03D4C:  MOVLB  C
03D4E:  MOVWF  x03
03D50:  MOVLW  B1
03D52:  MOVWF  x02
03D54:  MOVLW  3F
03D56:  MOVWF  x04
03D58:  MOVLB  0
03D5A:  CALL   29AA
03D5E:  MOVFF  01,BD9
....................     return flash_data;
03D62:  MOVLW  B1
03D64:  MOVWF  01
03D66:  MOVLW  0B
03D68:  MOVWF  02
03D6A:  RETURN 0
.................... }
.................... 
.................... void write_misf_address_area(void)
03D6C:  CALL   3A26
03D70:  MOVFF  02,03
03D74:  MOVF   01,W
03D76:  MOVWF  FE1
03D78:  MOVFF  03,FE2
03D7C:  MOVLW  0B
03D7E:  MOVWF  FEA
03D80:  MOVLW  6B
03D82:  MOVWF  FE9
03D84:  MOVLW  40
03D86:  MOVWF  01
03D88:  MOVFF  FE6,FEE
03D8C:  DECFSZ 01,F
03D8E:  GOTO   3D88
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
.................... 
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_END, flash_data.bytes, PACKET_SIZE);
03D92:  MOVFF  261,BAE
03D96:  MOVFF  260,BAD
03D9A:  MOVFF  25F,BAC
03D9E:  MOVFF  25E,BAB
03DA2:  MOVLB  B
03DA4:  CLRF   xB2
03DA6:  CLRF   xB1
03DA8:  SETF   xB0
03DAA:  SETF   xAF
03DAC:  MOVLW  0B
03DAE:  MOVWF  xB4
03DB0:  MOVLW  6B
03DB2:  MOVWF  xB3
03DB4:  CLRF   xB6
03DB6:  MOVLW  40
03DB8:  MOVWF  xB5
03DBA:  MOVLB  0
03DBC:  CALL   367E
03DC0:  RETURN 0
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG    | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02A16:  MOVLW  F4
02A18:  MOVWF  FF6
02A1A:  MOVLW  0C
02A1C:  MOVWF  FF7
02A1E:  MOVLW  00
02A20:  MOVWF  FF8
02A22:  MOVLW  2B
02A24:  MOVLB  B
02A26:  MOVWF  x1B
02A28:  MOVLB  0
02A2A:  CALL   1BE0
02A2E:  MOVFF  272,B1B
02A32:  MOVLW  37
02A34:  MOVLB  B
02A36:  MOVWF  x1C
02A38:  MOVLB  0
02A3A:  CALL   1E34
02A3E:  MOVFF  271,B1B
02A42:  MOVLW  37
02A44:  MOVLB  B
02A46:  MOVWF  x1C
02A48:  MOVLB  0
02A4A:  CALL   1E34
02A4E:  MOVFF  270,B1B
02A52:  MOVLW  37
02A54:  MOVLB  B
02A56:  MOVWF  x1C
02A58:  MOVLB  0
02A5A:  CALL   1E34
02A5E:  MOVFF  26F,B1B
02A62:  MOVLW  37
02A64:  MOVLB  B
02A66:  MOVWF  x1C
02A68:  MOVLB  0
02A6A:  CALL   1E34
02A6E:  MOVLW  0D
02A70:  MOVLB  B
02A72:  MOVWF  x6E
02A74:  MOVLB  0
02A76:  CALL   1B5E
02A7A:  MOVLW  0A
02A7C:  MOVLB  B
02A7E:  MOVWF  x6E
02A80:  MOVLB  0
02A82:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | PICLOG    | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02A86:  MOVLW  28
02A88:  MOVWF  FF6
02A8A:  MOVLW  0D
02A8C:  MOVWF  FF7
02A8E:  MOVLW  00
02A90:  MOVWF  FF8
02A92:  MOVLW  2B
02A94:  MOVLB  B
02A96:  MOVWF  x1B
02A98:  MOVLB  0
02A9A:  CALL   1BE0
02A9E:  MOVFF  276,B1B
02AA2:  MOVLW  37
02AA4:  MOVLB  B
02AA6:  MOVWF  x1C
02AA8:  MOVLB  0
02AAA:  CALL   1E34
02AAE:  MOVFF  275,B1B
02AB2:  MOVLW  37
02AB4:  MOVLB  B
02AB6:  MOVWF  x1C
02AB8:  MOVLB  0
02ABA:  CALL   1E34
02ABE:  MOVFF  274,B1B
02AC2:  MOVLW  37
02AC4:  MOVLB  B
02AC6:  MOVWF  x1C
02AC8:  MOVLB  0
02ACA:  CALL   1E34
02ACE:  MOVFF  273,B1B
02AD2:  MOVLW  37
02AD4:  MOVLB  B
02AD6:  MOVWF  x1C
02AD8:  MOVLB  0
02ADA:  CALL   1E34
02ADE:  MOVLW  0D
02AE0:  MOVLB  B
02AE2:  MOVWF  x6E
02AE4:  MOVLB  0
02AE6:  CALL   1B5E
02AEA:  MOVLW  0A
02AEC:  MOVLB  B
02AEE:  MOVWF  x6E
02AF0:  MOVLB  0
02AF2:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02AF6:  MOVLW  5C
02AF8:  MOVWF  FF6
02AFA:  MOVLW  0D
02AFC:  MOVWF  FF7
02AFE:  MOVLW  00
02B00:  MOVWF  FF8
02B02:  MOVLW  2B
02B04:  MOVLB  B
02B06:  MOVWF  x1B
02B08:  MOVLB  0
02B0A:  CALL   1BE0
02B0E:  MOVFF  277,B1B
02B12:  MOVLW  37
02B14:  MOVLB  B
02B16:  MOVWF  x1C
02B18:  MOVLB  0
02B1A:  CALL   1E34
02B1E:  MOVLW  0D
02B20:  MOVLB  B
02B22:  MOVWF  x6E
02B24:  MOVLB  0
02B26:  CALL   1B5E
02B2A:  MOVLW  0A
02B2C:  MOVLB  B
02B2E:  MOVWF  x6E
02B30:  MOVLB  0
02B32:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02B36:  MOVLW  8E
02B38:  MOVWF  FF6
02B3A:  MOVLW  0D
02B3C:  MOVWF  FF7
02B3E:  MOVLW  00
02B40:  MOVWF  FF8
02B42:  MOVLW  2B
02B44:  MOVLB  B
02B46:  MOVWF  x1B
02B48:  MOVLB  0
02B4A:  CALL   1BE0
02B4E:  MOVFF  278,B1B
02B52:  MOVLW  37
02B54:  MOVLB  B
02B56:  MOVWF  x1C
02B58:  MOVLB  0
02B5A:  CALL   1E34
02B5E:  MOVLW  0D
02B60:  MOVLB  B
02B62:  MOVWF  x6E
02B64:  MOVLB  0
02B66:  CALL   1B5E
02B6A:  MOVLW  0A
02B6C:  MOVLB  B
02B6E:  MOVWF  x6E
02B70:  MOVLB  0
02B72:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02B76:  MOVLW  C0
02B78:  MOVWF  FF6
02B7A:  MOVLW  0D
02B7C:  MOVWF  FF7
02B7E:  MOVLW  00
02B80:  MOVWF  FF8
02B82:  MOVLW  2B
02B84:  MOVLB  B
02B86:  MOVWF  x1B
02B88:  MOVLB  0
02B8A:  CALL   1BE0
02B8E:  MOVFF  27D,B1B
02B92:  MOVLW  37
02B94:  MOVLB  B
02B96:  MOVWF  x1C
02B98:  MOVLB  0
02B9A:  CALL   1E34
02B9E:  MOVFF  27C,B1B
02BA2:  MOVLW  37
02BA4:  MOVLB  B
02BA6:  MOVWF  x1C
02BA8:  MOVLB  0
02BAA:  CALL   1E34
02BAE:  MOVFF  27B,B1B
02BB2:  MOVLW  37
02BB4:  MOVLB  B
02BB6:  MOVWF  x1C
02BB8:  MOVLB  0
02BBA:  CALL   1E34
02BBE:  MOVFF  27A,B1B
02BC2:  MOVLW  37
02BC4:  MOVLB  B
02BC6:  MOVWF  x1C
02BC8:  MOVLB  0
02BCA:  CALL   1E34
02BCE:  MOVLW  0D
02BD0:  MOVLB  B
02BD2:  MOVWF  x6E
02BD4:  MOVLB  0
02BD6:  CALL   1B5E
02BDA:  MOVLW  0A
02BDC:  MOVLB  B
02BDE:  MOVWF  x6E
02BE0:  MOVLB  0
02BE2:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02BE6:  MOVLW  F4
02BE8:  MOVWF  FF6
02BEA:  MOVLW  0D
02BEC:  MOVWF  FF7
02BEE:  MOVLW  00
02BF0:  MOVWF  FF8
02BF2:  MOVLW  2B
02BF4:  MOVLB  B
02BF6:  MOVWF  x1B
02BF8:  MOVLB  0
02BFA:  CALL   1BE0
02BFE:  MOVFF  281,B1B
02C02:  MOVLW  37
02C04:  MOVLB  B
02C06:  MOVWF  x1C
02C08:  MOVLB  0
02C0A:  CALL   1E34
02C0E:  MOVFF  280,B1B
02C12:  MOVLW  37
02C14:  MOVLB  B
02C16:  MOVWF  x1C
02C18:  MOVLB  0
02C1A:  CALL   1E34
02C1E:  MOVFF  27F,B1B
02C22:  MOVLW  37
02C24:  MOVLB  B
02C26:  MOVWF  x1C
02C28:  MOVLB  0
02C2A:  CALL   1E34
02C2E:  MOVFF  27E,B1B
02C32:  MOVLW  37
02C34:  MOVLB  B
02C36:  MOVWF  x1C
02C38:  MOVLB  0
02C3A:  CALL   1E34
02C3E:  MOVLW  0D
02C40:  MOVLB  B
02C42:  MOVWF  x6E
02C44:  MOVLB  0
02C46:  CALL   1B5E
02C4A:  MOVLW  0A
02C4C:  MOVLB  B
02C4E:  MOVWF  x6E
02C50:  MOVLB  0
02C52:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02C56:  MOVLW  28
02C58:  MOVWF  FF6
02C5A:  MOVLW  0E
02C5C:  MOVWF  FF7
02C5E:  MOVLW  00
02C60:  MOVWF  FF8
02C62:  MOVLW  2B
02C64:  MOVLB  B
02C66:  MOVWF  x1B
02C68:  MOVLB  0
02C6A:  CALL   1BE0
02C6E:  MOVFF  282,B1B
02C72:  MOVLW  37
02C74:  MOVLB  B
02C76:  MOVWF  x1C
02C78:  MOVLB  0
02C7A:  CALL   1E34
02C7E:  MOVLW  0D
02C80:  MOVLB  B
02C82:  MOVWF  x6E
02C84:  MOVLB  0
02C86:  CALL   1B5E
02C8A:  MOVLW  0A
02C8C:  MOVLB  B
02C8E:  MOVWF  x6E
02C90:  MOVLB  0
02C92:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02C96:  MOVLW  5A
02C98:  MOVWF  FF6
02C9A:  MOVLW  0E
02C9C:  MOVWF  FF7
02C9E:  MOVLW  00
02CA0:  MOVWF  FF8
02CA2:  MOVLW  2B
02CA4:  MOVLB  B
02CA6:  MOVWF  x1B
02CA8:  MOVLB  0
02CAA:  CALL   1BE0
02CAE:  MOVFF  283,B1B
02CB2:  MOVLW  37
02CB4:  MOVLB  B
02CB6:  MOVWF  x1C
02CB8:  MOVLB  0
02CBA:  CALL   1E34
02CBE:  MOVLW  0D
02CC0:  MOVLB  B
02CC2:  MOVWF  x6E
02CC4:  MOVLB  0
02CC6:  CALL   1B5E
02CCA:  MOVLW  0A
02CCC:  MOVLB  B
02CCE:  MOVWF  x6E
02CD0:  MOVLB  0
02CD2:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV HEADER | Use Counter      : 0x%08LX\r\n", iv_header.used_counter);
02CD6:  MOVLW  8C
02CD8:  MOVWF  FF6
02CDA:  MOVLW  0E
02CDC:  MOVWF  FF7
02CDE:  MOVLW  00
02CE0:  MOVWF  FF8
02CE2:  MOVLW  2B
02CE4:  MOVLB  B
02CE6:  MOVWF  x1B
02CE8:  MOVLB  0
02CEA:  CALL   1BE0
02CEE:  MOVFF  288,B1B
02CF2:  MOVLW  37
02CF4:  MOVLB  B
02CF6:  MOVWF  x1C
02CF8:  MOVLB  0
02CFA:  CALL   1E34
02CFE:  MOVFF  287,B1B
02D02:  MOVLW  37
02D04:  MOVLB  B
02D06:  MOVWF  x1C
02D08:  MOVLB  0
02D0A:  CALL   1E34
02D0E:  MOVFF  286,B1B
02D12:  MOVLW  37
02D14:  MOVLB  B
02D16:  MOVWF  x1C
02D18:  MOVLB  0
02D1A:  CALL   1E34
02D1E:  MOVFF  285,B1B
02D22:  MOVLW  37
02D24:  MOVLB  B
02D26:  MOVWF  x1C
02D28:  MOVLB  0
02D2A:  CALL   1E34
02D2E:  MOVLW  0D
02D30:  MOVLB  B
02D32:  MOVWF  x6E
02D34:  MOVLB  0
02D36:  CALL   1B5E
02D3A:  MOVLW  0A
02D3C:  MOVLB  B
02D3E:  MOVWF  x6E
02D40:  MOVLB  0
02D42:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV HEADER | Uncopyed Counter : 0x%08LX\r\n", iv_header.uncopied_counter);
02D46:  MOVLW  C0
02D48:  MOVWF  FF6
02D4A:  MOVLW  0E
02D4C:  MOVWF  FF7
02D4E:  MOVLW  00
02D50:  MOVWF  FF8
02D52:  MOVLW  2B
02D54:  MOVLB  B
02D56:  MOVWF  x1B
02D58:  MOVLB  0
02D5A:  CALL   1BE0
02D5E:  MOVFF  28C,B1B
02D62:  MOVLW  37
02D64:  MOVLB  B
02D66:  MOVWF  x1C
02D68:  MOVLB  0
02D6A:  CALL   1E34
02D6E:  MOVFF  28B,B1B
02D72:  MOVLW  37
02D74:  MOVLB  B
02D76:  MOVWF  x1C
02D78:  MOVLB  0
02D7A:  CALL   1E34
02D7E:  MOVFF  28A,B1B
02D82:  MOVLW  37
02D84:  MOVLB  B
02D86:  MOVWF  x1C
02D88:  MOVLB  0
02D8A:  CALL   1E34
02D8E:  MOVFF  289,B1B
02D92:  MOVLW  37
02D94:  MOVLB  B
02D96:  MOVWF  x1C
02D98:  MOVLB  0
02D9A:  CALL   1E34
02D9E:  MOVLW  0D
02DA0:  MOVLB  B
02DA2:  MOVWF  x6E
02DA4:  MOVLB  0
02DA6:  CALL   1B5E
02DAA:  MOVLW  0A
02DAC:  MOVLB  B
02DAE:  MOVWF  x6E
02DB0:  MOVLB  0
02DB2:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter1 : 0x%02X\r\n", iv_header.reserve_counter1);
02DB6:  MOVLW  F4
02DB8:  MOVWF  FF6
02DBA:  MOVLW  0E
02DBC:  MOVWF  FF7
02DBE:  MOVLW  00
02DC0:  MOVWF  FF8
02DC2:  MOVLW  2B
02DC4:  MOVLB  B
02DC6:  MOVWF  x1B
02DC8:  MOVLB  0
02DCA:  CALL   1BE0
02DCE:  MOVFF  28D,B1B
02DD2:  MOVLW  37
02DD4:  MOVLB  B
02DD6:  MOVWF  x1C
02DD8:  MOVLB  0
02DDA:  CALL   1E34
02DDE:  MOVLW  0D
02DE0:  MOVLB  B
02DE2:  MOVWF  x6E
02DE4:  MOVLB  0
02DE6:  CALL   1B5E
02DEA:  MOVLW  0A
02DEC:  MOVLB  B
02DEE:  MOVWF  x6E
02DF0:  MOVLB  0
02DF2:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter2 : 0x%02X\r\n", iv_header.reserve_counter2);
02DF6:  MOVLW  26
02DF8:  MOVWF  FF6
02DFA:  MOVLW  0F
02DFC:  MOVWF  FF7
02DFE:  MOVLW  00
02E00:  MOVWF  FF8
02E02:  MOVLW  2B
02E04:  MOVLB  B
02E06:  MOVWF  x1B
02E08:  MOVLB  0
02E0A:  CALL   1BE0
02E0E:  MOVFF  28E,B1B
02E12:  MOVLW  37
02E14:  MOVLB  B
02E16:  MOVWF  x1C
02E18:  MOVLB  0
02E1A:  CALL   1E34
02E1E:  MOVLW  0D
02E20:  MOVLB  B
02E22:  MOVWF  x6E
02E24:  MOVLB  0
02E26:  CALL   1B5E
02E2A:  MOVLW  0A
02E2C:  MOVLB  B
02E2E:  MOVWF  x6E
02E30:  MOVLB  0
02E32:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV DATA   | Use Counter      : 0x%08LX\r\n", iv_data.used_counter);
02E36:  MOVLW  58
02E38:  MOVWF  FF6
02E3A:  MOVLW  0F
02E3C:  MOVWF  FF7
02E3E:  MOVLW  00
02E40:  MOVWF  FF8
02E42:  MOVLW  2B
02E44:  MOVLB  B
02E46:  MOVWF  x1B
02E48:  MOVLB  0
02E4A:  CALL   1BE0
02E4E:  MOVFF  293,B1B
02E52:  MOVLW  37
02E54:  MOVLB  B
02E56:  MOVWF  x1C
02E58:  MOVLB  0
02E5A:  CALL   1E34
02E5E:  MOVFF  292,B1B
02E62:  MOVLW  37
02E64:  MOVLB  B
02E66:  MOVWF  x1C
02E68:  MOVLB  0
02E6A:  CALL   1E34
02E6E:  MOVFF  291,B1B
02E72:  MOVLW  37
02E74:  MOVLB  B
02E76:  MOVWF  x1C
02E78:  MOVLB  0
02E7A:  CALL   1E34
02E7E:  MOVFF  290,B1B
02E82:  MOVLW  37
02E84:  MOVLB  B
02E86:  MOVWF  x1C
02E88:  MOVLB  0
02E8A:  CALL   1E34
02E8E:  MOVLW  0D
02E90:  MOVLB  B
02E92:  MOVWF  x6E
02E94:  MOVLB  0
02E96:  CALL   1B5E
02E9A:  MOVLW  0A
02E9C:  MOVLB  B
02E9E:  MOVWF  x6E
02EA0:  MOVLB  0
02EA2:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV DATA   | Uncopyed Counter : 0x%08LX\r\n", iv_data.uncopied_counter);
02EA6:  MOVLW  8C
02EA8:  MOVWF  FF6
02EAA:  MOVLW  0F
02EAC:  MOVWF  FF7
02EAE:  MOVLW  00
02EB0:  MOVWF  FF8
02EB2:  MOVLW  2B
02EB4:  MOVLB  B
02EB6:  MOVWF  x1B
02EB8:  MOVLB  0
02EBA:  CALL   1BE0
02EBE:  MOVFF  297,B1B
02EC2:  MOVLW  37
02EC4:  MOVLB  B
02EC6:  MOVWF  x1C
02EC8:  MOVLB  0
02ECA:  CALL   1E34
02ECE:  MOVFF  296,B1B
02ED2:  MOVLW  37
02ED4:  MOVLB  B
02ED6:  MOVWF  x1C
02ED8:  MOVLB  0
02EDA:  CALL   1E34
02EDE:  MOVFF  295,B1B
02EE2:  MOVLW  37
02EE4:  MOVLB  B
02EE6:  MOVWF  x1C
02EE8:  MOVLB  0
02EEA:  CALL   1E34
02EEE:  MOVFF  294,B1B
02EF2:  MOVLW  37
02EF4:  MOVLB  B
02EF6:  MOVWF  x1C
02EF8:  MOVLB  0
02EFA:  CALL   1E34
02EFE:  MOVLW  0D
02F00:  MOVLB  B
02F02:  MOVWF  x6E
02F04:  MOVLB  0
02F06:  CALL   1B5E
02F0A:  MOVLW  0A
02F0C:  MOVLB  B
02F0E:  MOVWF  x6E
02F10:  MOVLB  0
02F12:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter1 : 0x%02X\r\n", iv_data.reserve_counter1);
02F16:  MOVLW  C0
02F18:  MOVWF  FF6
02F1A:  MOVLW  0F
02F1C:  MOVWF  FF7
02F1E:  MOVLW  00
02F20:  MOVWF  FF8
02F22:  MOVLW  2B
02F24:  MOVLB  B
02F26:  MOVWF  x1B
02F28:  MOVLB  0
02F2A:  CALL   1BE0
02F2E:  MOVFF  298,B1B
02F32:  MOVLW  37
02F34:  MOVLB  B
02F36:  MOVWF  x1C
02F38:  MOVLB  0
02F3A:  CALL   1E34
02F3E:  MOVLW  0D
02F40:  MOVLB  B
02F42:  MOVWF  x6E
02F44:  MOVLB  0
02F46:  CALL   1B5E
02F4A:  MOVLW  0A
02F4C:  MOVLB  B
02F4E:  MOVWF  x6E
02F50:  MOVLB  0
02F52:  CALL   1B5E
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter2 : 0x%02X\r\n", iv_data.reserve_counter2);
02F56:  MOVLW  F2
02F58:  MOVWF  FF6
02F5A:  MOVLW  0F
02F5C:  MOVWF  FF7
02F5E:  MOVLW  00
02F60:  MOVWF  FF8
02F62:  MOVLW  2B
02F64:  MOVLB  B
02F66:  MOVWF  x1B
02F68:  MOVLB  0
02F6A:  CALL   1BE0
02F6E:  MOVFF  299,B1B
02F72:  MOVLW  37
02F74:  MOVLB  B
02F76:  MOVWF  x1C
02F78:  MOVLB  0
02F7A:  CALL   1E34
02F7E:  MOVLW  0D
02F80:  MOVLB  B
02F82:  MOVWF  x6E
02F84:  MOVLB  0
02F86:  CALL   1B5E
02F8A:  MOVLW  0A
02F8C:  MOVLB  B
02F8E:  MOVWF  x6E
02F90:  MOVLB  0
02F92:  CALL   1B5E
....................     fprintf(PC, "\tComplete\r\n");
02F96:  MOVLW  24
02F98:  MOVWF  FF6
02F9A:  MOVLW  10
02F9C:  MOVWF  FF7
02F9E:  MOVLW  00
02FA0:  MOVWF  FF8
02FA2:  CALL   1BB0
02FA6:  GOTO   335E (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
09310:  MOVLB  3
09312:  CLRF   xBB
09314:  CLRF   xBC
09316:  CLRF   xBD
09318:  CLRF   xBE
0931A:  CLRF   xBF
0931C:  CLRF   xC0
0931E:  CLRF   xC1
09320:  CLRF   xC2
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
09322:  MOVF   xBA,F
09324:  BTFSC  FD8.2
09326:  BRA    932E
09328:  MOVLB  0
0932A:  GOTO   9348
0932E:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
09330:  MOVLB  3
09332:  CLRF   xBE
09334:  CLRF   xBD
09336:  CLRF   xBC
09338:  CLRF   xBB
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
0933A:  CLRF   xC2
0933C:  CLRF   xC1
0933E:  SETF   xC0
09340:  SETF   xBF
09342:  MOVLB  0
....................    }
09344:  GOTO   93FC
....................    else if (mission_id == CIGS_PICLOG_DATA)
09348:  MOVLB  3
0934A:  DECFSZ xBA,W
0934C:  BRA    9352
0934E:  BRA    9358
09350:  MOVLB  0
09352:  MOVLB  0
09354:  GOTO   9376
09358:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
0935A:  MOVLB  3
0935C:  CLRF   xBE
0935E:  MOVLW  01
09360:  MOVWF  xBD
09362:  CLRF   xBC
09364:  CLRF   xBB
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
09366:  CLRF   xC2
09368:  MOVLW  01
0936A:  MOVWF  xC1
0936C:  SETF   xC0
0936E:  SETF   xBF
09370:  MOVLB  0
....................    }
09372:  GOTO   93FC
....................    else if (mission_id == CIGS_ENVIRO_DATA)
09376:  MOVLB  3
09378:  MOVF   xBA,W
0937A:  SUBLW  02
0937C:  BTFSC  FD8.2
0937E:  BRA    9386
09380:  MOVLB  0
09382:  GOTO   93A4
09386:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
09388:  MOVLB  3
0938A:  CLRF   xBE
0938C:  MOVLW  02
0938E:  MOVWF  xBD
09390:  CLRF   xBC
09392:  CLRF   xBB
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
09394:  CLRF   xC2
09396:  MOVLW  02
09398:  MOVWF  xC1
0939A:  SETF   xC0
0939C:  SETF   xBF
0939E:  MOVLB  0
....................    }
093A0:  GOTO   93FC
....................    else if (mission_id == CIGS_IV_HEADER)
093A4:  MOVLB  3
093A6:  MOVF   xBA,W
093A8:  SUBLW  03
093AA:  BTFSC  FD8.2
093AC:  BRA    93B4
093AE:  MOVLB  0
093B0:  GOTO   93D2
093B4:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
093B6:  MOVLB  3
093B8:  CLRF   xBE
093BA:  MOVLW  03
093BC:  MOVWF  xBD
093BE:  CLRF   xBC
093C0:  CLRF   xBB
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
093C2:  CLRF   xC2
093C4:  MOVLW  03
093C6:  MOVWF  xC1
093C8:  SETF   xC0
093CA:  SETF   xBF
093CC:  MOVLB  0
....................    }
093CE:  GOTO   93FC
....................    else if (mission_id == CIGS_IV_DATA)
093D2:  MOVLB  3
093D4:  MOVF   xBA,W
093D6:  SUBLW  04
093D8:  BTFSC  FD8.2
093DA:  BRA    93E2
093DC:  MOVLB  0
093DE:  GOTO   93FC
093E2:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
093E4:  MOVLB  3
093E6:  CLRF   xBE
093E8:  MOVLW  04
093EA:  MOVWF  xBD
093EC:  CLRF   xBC
093EE:  CLRF   xBB
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
093F0:  CLRF   xC2
093F2:  MOVLW  04
093F4:  MOVWF  xC1
093F6:  SETF   xC0
093F8:  SETF   xBF
093FA:  MOVLB  0
....................    }
....................    return mis_struct;
093FC:  MOVLW  BB
093FE:  MOVWF  01
09400:  MOVLW  03
09402:  MOVWF  02
09404:  GOTO   994E (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv_header.used_counter - iv_header.uncopied_counter;
....................         mis_write_struct.size = iv_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter - iv_data.uncopied_counter;
....................         mis_write_struct.size = iv_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "../application/mission/mmj_cigs_excute_mission.c"
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                           //TX PIN EXT +/- 6v
....................     #pin_select RX3=PIN_F2                                                           //RX PIN EXT +/- 6V
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=1000000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
08D26:  MOVLB  2
08D28:  MOVF   xDC,W
08D2A:  MOVWF  FE9
08D2C:  MOVF   xDD,W
08D2E:  MOVWF  FEA
08D30:  MOVFF  FEF,2DE
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
08D34:  MOVLW  8C
08D36:  MOVWF  FF6
08D38:  MOVLW  10
08D3A:  MOVWF  FF7
08D3C:  MOVLW  00
08D3E:  MOVWF  FF8
08D40:  MOVLB  0
08D42:  CALL   1BB0
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
08D46:  MOVLW  D2
08D48:  MOVWF  FF6
08D4A:  MOVLW  10
08D4C:  MOVWF  FF7
08D4E:  MOVLW  00
08D50:  MOVWF  FF8
08D52:  MOVLW  0C
08D54:  MOVLB  B
08D56:  MOVWF  x1B
08D58:  MOVLB  0
08D5A:  CALL   1BE0
08D5E:  MOVFF  2DE,B1B
08D62:  MOVLW  37
08D64:  MOVLB  B
08D66:  MOVWF  x1C
08D68:  MOVLB  0
08D6A:  CALL   1E34
08D6E:  MOVLW  E0
08D70:  MOVWF  FF6
08D72:  MOVLW  10
08D74:  MOVWF  FF7
08D76:  MOVLW  00
08D78:  MOVWF  FF8
08D7A:  MOVLW  04
08D7C:  MOVLB  B
08D7E:  MOVWF  x1B
08D80:  MOVLB  0
08D82:  CALL   1BE0
....................    switch(command_id)
08D86:  MOVLB  2
08D88:  MOVF   xDE,W
08D8A:  XORLW  10
08D8C:  MOVLB  0
08D8E:  BTFSC  FD8.2
08D90:  GOTO   8E40
08D94:  XORLW  01
08D96:  BTFSC  FD8.2
08D98:  GOTO   8E44
08D9C:  XORLW  03
08D9E:  BTFSC  FD8.2
08DA0:  GOTO   8E48
08DA4:  XORLW  13
08DA6:  BTFSC  FD8.2
08DA8:  GOTO   8E4C
08DAC:  XORLW  12
08DAE:  BTFSC  FD8.2
08DB0:  GOTO   8E50
08DB4:  XORLW  93
08DB6:  BTFSC  FD8.2
08DB8:  GOTO   8E54
08DBC:  XORLW  01
08DBE:  BTFSC  FD8.2
08DC0:  GOTO   8E64
08DC4:  XORLW  03
08DC6:  BTFSC  FD8.2
08DC8:  GOTO   8E74
08DCC:  XORLW  01
08DCE:  BTFSC  FD8.2
08DD0:  GOTO   8E84
08DD4:  XORLW  07
08DD6:  BTFSC  FD8.2
08DD8:  GOTO   8E94
08DDC:  XORLW  01
08DDE:  BTFSC  FD8.2
08DE0:  GOTO   8EA4
08DE4:  XORLW  03
08DE6:  BTFSC  FD8.2
08DE8:  GOTO   8EB4
08DEC:  XORLW  01
08DEE:  BTFSC  FD8.2
08DF0:  GOTO   8EC4
08DF4:  XORLW  0F
08DF6:  BTFSC  FD8.2
08DF8:  GOTO   8ED4
08DFC:  XORLW  18
08DFE:  BTFSC  FD8.2
08E00:  GOTO   8EE4
08E04:  XORLW  01
08E06:  BTFSC  FD8.2
08E08:  GOTO   8EF4
08E0C:  XORLW  03
08E0E:  BTFSC  FD8.2
08E10:  GOTO   8F04
08E14:  XORLW  01
08E16:  BTFSC  FD8.2
08E18:  GOTO   8F14
08E1C:  XORLW  07
08E1E:  BTFSC  FD8.2
08E20:  GOTO   8F24
08E24:  XORLW  01
08E26:  BTFSC  FD8.2
08E28:  GOTO   8F34
08E2C:  XORLW  03
08E2E:  BTFSC  FD8.2
08E30:  GOTO   8F44
08E34:  XORLW  36
08E36:  BTFSC  FD8.2
08E38:  GOTO   8F54
08E3C:  GOTO   8F64
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
08E40:  GOTO   8F74
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
08E44:  GOTO   8F74
....................       case 0x12:
....................          // test_adc();
....................          break;
08E48:  GOTO   8F74
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
08E4C:  GOTO   8F74
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
08E50:  GOTO   8F74
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
08E54:  MOVFF  2DD,2E2
08E58:  MOVFF  2DC,2E1
08E5C:  CALL   48C4
....................          break;
08E60:  GOTO   8F74
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
08E64:  MOVFF  2DD,2E0
08E68:  MOVFF  2DC,2DF
08E6C:  GOTO   49A2
....................          break;
08E70:  GOTO   8F74
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
08E74:  MOVFF  2DD,2E0
08E78:  MOVFF  2DC,2DF
08E7C:  GOTO   4E94
....................          break;
08E80:  GOTO   8F74
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
08E84:  MOVFF  2DD,2E0
08E88:  MOVFF  2DC,2DF
08E8C:  GOTO   5026
....................          break;
08E90:  GOTO   8F74
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
08E94:  MOVFF  2DD,2E0
08E98:  MOVFF  2DC,2DF
08E9C:  GOTO   5198
....................          break;
08EA0:  GOTO   8F74
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
08EA4:  MOVFF  2DD,2E0
08EA8:  MOVFF  2DC,2DF
08EAC:  GOTO   55D0
....................          break;
08EB0:  GOTO   8F74
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
08EB4:  MOVFF  2DD,2E0
08EB8:  MOVFF  2DC,2DF
08EBC:  GOTO   5648
....................          break;
08EC0:  GOTO   8F74
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
08EC4:  MOVFF  2DD,2E0
08EC8:  MOVFF  2DC,2DF
08ECC:  GOTO   5B0C
....................          break;
08ED0:  GOTO   8F74
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
08ED4:  MOVFF  2DD,2E0
08ED8:  MOVFF  2DC,2DF
08EDC:  GOTO   5D2E
....................          break;
08EE0:  GOTO   8F74
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
08EE4:  MOVFF  2DD,2E0
08EE8:  MOVFF  2DC,2DF
08EEC:  GOTO   5D86
....................          break;
08EF0:  GOTO   8F74
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
08EF4:  MOVFF  2DD,2E0
08EF8:  MOVFF  2DC,2DF
08EFC:  GOTO   5E62
....................          break;
08F00:  GOTO   8F74
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
08F04:  MOVFF  2DD,2E0
08F08:  MOVFF  2DC,2DF
08F0C:  GOTO   5F1E
....................          break;
08F10:  GOTO   8F74
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
08F14:  MOVFF  2DD,2E0
08F18:  MOVFF  2DC,2DF
08F1C:  CALL   5F86
....................          break;
08F20:  GOTO   8F74
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
08F24:  MOVFF  2DD,2E0
08F28:  MOVFF  2DC,2DF
08F2C:  GOTO   6132
....................          break;
08F30:  GOTO   8F74
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
08F34:  MOVFF  2DD,2E0
08F38:  MOVFF  2DC,2DF
08F3C:  GOTO   6556
....................          break;
08F40:  GOTO   8F74
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
08F44:  MOVFF  2DD,2E0
08F48:  MOVFF  2DC,2DF
08F4C:  CALL   5F86
....................          break;
08F50:  GOTO   8F74
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
08F54:  MOVFF  2DD,2E0
08F58:  MOVFF  2DC,2DF
08F5C:  GOTO   896A
....................          break;
08F60:  GOTO   8F74
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
08F64:  MOVLW  E6
08F66:  MOVWF  FF6
08F68:  MOVLW  10
08F6A:  MOVWF  FF7
08F6C:  MOVLW  00
08F6E:  MOVWF  FF8
08F70:  CALL   1BB0
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
08F74:  MOVLW  FE
08F76:  MOVWF  FF6
08F78:  MOVLW  10
08F7A:  MOVWF  FF7
08F7C:  MOVLW  00
08F7E:  MOVWF  FF8
08F80:  CALL   1BB0
08F84:  GOTO   8FF2 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0AD8E:  MOVLW  44
0AD90:  MOVWF  FF6
0AD92:  MOVLW  11
0AD94:  MOVWF  FF7
0AD96:  MOVLW  00
0AD98:  MOVWF  FF8
0AD9A:  CALL   1BB0
....................    
....................    switch(command->frame_id)
0AD9E:  MOVLB  2
0ADA0:  MOVF   xD6,W
0ADA2:  MOVWF  FE9
0ADA4:  MOVF   xD7,W
0ADA6:  MOVWF  FEA
0ADA8:  MOVF   FEF,W
0ADAA:  XORLW  00
0ADAC:  MOVLB  0
0ADAE:  BTFSC  FD8.2
0ADB0:  GOTO   ADC8
0ADB4:  XORLW  01
0ADB6:  BTFSC  FD8.2
0ADB8:  GOTO   ADD8
0ADBC:  XORLW  03
0ADBE:  BTFSC  FD8.2
0ADC0:  GOTO   ADF8
0ADC4:  GOTO   AE08
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0ADC8:  MOVFF  2D7,2D9
0ADCC:  MOVFF  2D6,2D8
0ADD0:  GOTO   8FA6
....................          break;
0ADD4:  GOTO   AE08
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0ADD8:  MOVFF  2D7,2D9
0ADDC:  MOVFF  2D6,2D8
0ADE0:  GOTO   9028
0ADE4:  MOVF   01,F
0ADE6:  BTFSC  FD8.2
0ADE8:  GOTO   ADF4
....................             return TRUE; // if status is finished, return TRUE
0ADEC:  MOVLW  01
0ADEE:  MOVWF  01
0ADF0:  GOTO   AE0C
....................          }        
....................          break;
0ADF4:  GOTO   AE08
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0ADF8:  MOVFF  2D7,2D9
0ADFC:  MOVFF  2D6,2D8
0AE00:  GOTO   AB56
....................          break;
0AE04:  GOTO   AE08
....................    }
....................    return FALSE;
0AE08:  MOVLW  00
0AE0A:  MOVWF  01
0AE0C:  GOTO   B514 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
08FA6:  MOVLW  5C
08FA8:  MOVWF  FF6
08FAA:  MOVLW  11
08FAC:  MOVWF  FF7
08FAE:  MOVLW  00
08FB0:  MOVWF  FF8
08FB2:  CALL   1BB0
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
08FB6:  MOVLW  72
08FB8:  MOVWF  FF6
08FBA:  MOVLW  11
08FBC:  MOVWF  FF7
08FBE:  MOVLW  00
08FC0:  MOVWF  FF8
08FC2:  CALL   1BB0
....................    transmit_ack();
08FC6:  CALL   4554
.................... 
....................    status[0] = EXECUTING_MISSION;
08FCA:  MOVLW  02
08FCC:  MOVWF  48
....................    execute_mission(command->content);
08FCE:  MOVLW  03
08FD0:  MOVLB  2
08FD2:  ADDWF  xD8,W
08FD4:  MOVWF  01
08FD6:  MOVLW  00
08FD8:  ADDWFC xD9,W
08FDA:  MOVWF  03
08FDC:  MOVF   01,W
08FDE:  MOVWF  xDA
08FE0:  MOVFF  03,2DB
08FE4:  MOVFF  2DB,2DD
08FE8:  MOVFF  2DA,2DC
08FEC:  MOVLB  0
08FEE:  GOTO   8D26
....................    if (is_empty_flash_queue())
08FF2:  CALL   8F88
08FF6:  MOVF   01,F
08FF8:  BTFSC  FD8.2
08FFA:  GOTO   9006
....................       status[0] = FINISHED;
08FFE:  MOVLW  06
09000:  MOVWF  48
09002:  GOTO   900A
....................    else
....................       status[0] = SMF_USE_REQ;
09006:  MOVLW  04
09008:  MOVWF  48
0900A:  GOTO   ADD4 (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
09028:  MOVLW  8C
0902A:  MOVWF  FF6
0902C:  MOVLW  11
0902E:  MOVWF  FF7
09030:  MOVLW  00
09032:  MOVWF  FF8
09034:  CALL   1BB0
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
09038:  MOVLW  A0
0903A:  MOVWF  FF6
0903C:  MOVLW  11
0903E:  MOVWF  FF7
09040:  MOVLW  00
09042:  MOVWF  FF8
09044:  CALL   1BB0
....................    transmit_status();
09048:  GOTO   900E
....................    if (status[0] == FINISHED)
0904C:  MOVF   48,W
0904E:  SUBLW  06
09050:  BTFSS  FD8.2
09052:  GOTO   9072
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
09056:  MOVLW  BE
09058:  MOVWF  FF6
0905A:  MOVLW  11
0905C:  MOVWF  FF7
0905E:  MOVLW  00
09060:  MOVWF  FF8
09062:  CALL   1BB0
....................       return TRUE;
09066:  MOVLW  01
09068:  MOVWF  01
0906A:  GOTO   907A
....................    }
0906E:  GOTO   907A
....................    else{
....................       return FALSE;
09072:  MOVLW  00
09074:  MOVWF  01
09076:  GOTO   907A
....................    }
0907A:  GOTO   ADE4 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command) {
....................    fprintf(PC, "\t-> SMF available check\r\n");
*
0AB56:  MOVLW  DA
0AB58:  MOVWF  FF6
0AB5A:  MOVLW  11
0AB5C:  MOVWF  FF7
0AB5E:  MOVLW  00
0AB60:  MOVWF  FF8
0AB62:  CALL   1BB0
....................    fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0AB66:  MOVLW  F4
0AB68:  MOVWF  FF6
0AB6A:  MOVLW  11
0AB6C:  MOVWF  FF7
0AB6E:  MOVLW  00
0AB70:  MOVWF  FF8
0AB72:  CALL   1BB0
....................    transmit_ack();
0AB76:  CALL   4554
....................    
....................    if (command->content[0] == ALLOW) {
0AB7A:  MOVLW  03
0AB7C:  MOVLB  2
0AB7E:  ADDWF  xD8,W
0AB80:  MOVWF  FE9
0AB82:  MOVLW  00
0AB84:  ADDWFC xD9,W
0AB86:  MOVWF  FEA
0AB88:  DECFSZ FEF,W
0AB8A:  BRA    AB90
0AB8C:  BRA    AB96
0AB8E:  MOVLB  0
0AB90:  MOVLB  0
0AB92:  GOTO   AD7A
0AB96:  MOVLB  0
....................       fprintf(PC, "\t\t-> allowed\r\n");
0AB98:  MOVLW  14
0AB9A:  MOVWF  FF6
0AB9C:  MOVLW  12
0AB9E:  MOVWF  FF7
0ABA0:  MOVLW  00
0ABA2:  MOVWF  FF8
0ABA4:  CALL   1BB0
....................       status[0] = COPYING;
0ABA8:  MOVLW  05
0ABAA:  MOVWF  48
....................       
....................       // キューが空になるまでループ処理
....................       int8 processed_count = 0;
0ABAC:  MOVLB  2
0ABAE:  CLRF   xDA
0ABB0:  MOVLB  0
....................       while (!is_empty_flash_queue()) {
0ABB2:  CALL   8F88
0ABB6:  MOVF   01,F
0ABB8:  BTFSS  FD8.2
0ABBA:  GOTO   AD32
....................          fprintf(PC, "\t\t-> Processing SMF data [%d]\r\n", processed_count);
0ABBE:  MOVLW  24
0ABC0:  MOVWF  FF6
0ABC2:  MOVLW  12
0ABC4:  MOVWF  FF7
0ABC6:  MOVLW  00
0ABC8:  MOVWF  FF8
0ABCA:  MOVLW  1A
0ABCC:  MOVLB  B
0ABCE:  MOVWF  x1B
0ABD0:  MOVLB  0
0ABD2:  CALL   1BE0
0ABD6:  MOVFF  2DA,436
0ABDA:  MOVLW  18
0ABDC:  MOVLB  4
0ABDE:  MOVWF  x37
0ABE0:  MOVLB  0
0ABE2:  CALL   907E
0ABE6:  MOVLW  40
0ABE8:  MOVWF  FF6
0ABEA:  MOVLW  12
0ABEC:  MOVWF  FF7
0ABEE:  MOVLW  00
0ABF0:  MOVWF  FF8
0ABF2:  MOVLW  03
0ABF4:  MOVLB  B
0ABF6:  MOVWF  x1B
0ABF8:  MOVLB  0
0ABFA:  CALL   1BE0
....................          
....................          FlashOperationStruct *smf_data = dequeue_flash_operation();
0ABFE:  GOTO   918C
0AC02:  MOVFF  02,2DC
0AC06:  MOVFF  01,2DB
....................          if (smf_data != 0x00) {
0AC0A:  MOVLB  2
0AC0C:  MOVF   xDB,F
0AC0E:  BTFSC  FD8.2
0AC10:  BRA    AC18
0AC12:  MOVLB  0
0AC14:  GOTO   AC2A
0AC18:  MOVLB  0
0AC1A:  MOVLB  2
0AC1C:  MOVF   xDC,F
0AC1E:  BTFSS  FD8.2
0AC20:  BRA    AC28
0AC22:  MOVLB  0
0AC24:  GOTO   AD1A
0AC28:  MOVLB  0
....................             int8 func_type = smf_data->func_type;
0AC2A:  MOVLW  01
0AC2C:  MOVLB  2
0AC2E:  ADDWF  xDB,W
0AC30:  MOVWF  FE9
0AC32:  MOVLW  00
0AC34:  ADDWFC xDC,W
0AC36:  MOVWF  FEA
0AC38:  MOVFF  FEF,2DD
0AC3C:  MOVLB  0
....................             fprintf(PC, "func type : 0x%02X",func_type);
0AC3E:  MOVLW  44
0AC40:  MOVWF  FF6
0AC42:  MOVLW  12
0AC44:  MOVWF  FF7
0AC46:  MOVLW  00
0AC48:  MOVWF  FF8
0AC4A:  MOVLW  0E
0AC4C:  MOVLB  B
0AC4E:  MOVWF  x1B
0AC50:  MOVLB  0
0AC52:  CALL   1BE0
0AC56:  MOVFF  2DD,B1B
0AC5A:  MOVLW  37
0AC5C:  MOVLB  B
0AC5E:  MOVWF  x1C
0AC60:  MOVLB  0
0AC62:  CALL   1E34
....................             if (func_type == 0x00) {  // SMF_WRITE
0AC66:  MOVLB  2
0AC68:  MOVF   xDD,F
0AC6A:  BTFSC  FD8.2
0AC6C:  BRA    AC74
0AC6E:  MOVLB  0
0AC70:  GOTO   AC92
0AC74:  MOVLB  0
....................                fprintf(PC, "\t\t-> Executing SMF WRITE (single)\r\n");
0AC76:  MOVLW  58
0AC78:  MOVWF  FF6
0AC7A:  MOVLW  12
0AC7C:  MOVWF  FF7
0AC7E:  MOVLW  00
0AC80:  MOVWF  FF8
0AC82:  CALL   1BB0
....................                smf_write(smf_data);
0AC86:  MOVFF  2DC,2C8
0AC8A:  MOVFF  2DB,2C7
0AC8E:  GOTO   989A
....................             }
....................             if (func_type == 0x01) {  // SMF_READ
0AC92:  MOVLB  2
0AC94:  DECFSZ xDD,W
0AC96:  BRA    AC9C
0AC98:  BRA    ACA2
0AC9A:  MOVLB  0
0AC9C:  MOVLB  0
0AC9E:  GOTO   ACC0
0ACA2:  MOVLB  0
....................                fprintf(PC, "\t\t-> Executing SMF READ (single)\r\n");
0ACA4:  MOVLW  7C
0ACA6:  MOVWF  FF6
0ACA8:  MOVLW  12
0ACAA:  MOVWF  FF7
0ACAC:  MOVLW  00
0ACAE:  MOVWF  FF8
0ACB0:  CALL   1BB0
....................                smf_read(smf_data);
0ACB4:  MOVFF  2DC,2DF
0ACB8:  MOVFF  2DB,2DE
0ACBC:  GOTO   A2A8
....................             }
.................... 
....................             if (func_type == 0x02) {  // SMF_ERASE
0ACC0:  MOVLB  2
0ACC2:  MOVF   xDD,W
0ACC4:  SUBLW  02
0ACC6:  BTFSC  FD8.2
0ACC8:  BRA    ACD0
0ACCA:  MOVLB  0
0ACCC:  GOTO   ACEE
0ACD0:  MOVLB  0
....................                fprintf(PC, "\t\t-> Executing SMF ERASE (single)\r\n");
0ACD2:  MOVLW  A0
0ACD4:  MOVWF  FF6
0ACD6:  MOVLW  12
0ACD8:  MOVWF  FF7
0ACDA:  MOVLW  00
0ACDC:  MOVWF  FF8
0ACDE:  CALL   1BB0
....................                smf_erase(smf_data);
0ACE2:  MOVFF  2DC,2DF
0ACE6:  MOVFF  2DB,2DE
0ACEA:  GOTO   A638
....................             }
....................             if (func_type > 2) {
0ACEE:  MOVLB  2
0ACF0:  MOVF   xDD,W
0ACF2:  SUBLW  02
0ACF4:  BTFSS  FD8.0
0ACF6:  BRA    ACFE
0ACF8:  MOVLB  0
0ACFA:  GOTO   AD10
0ACFE:  MOVLB  0
....................                fprintf(PC, "\t\t-> Unknown SMF function type\r\n");
0AD00:  MOVLW  C4
0AD02:  MOVWF  FF6
0AD04:  MOVLW  12
0AD06:  MOVWF  FF7
0AD08:  MOVLW  00
0AD0A:  MOVWF  FF8
0AD0C:  CALL   1BB0
....................             }
....................             processed_count++;
0AD10:  MOVLB  2
0AD12:  INCF   xDA,F
0AD14:  MOVLB  0
....................          } else {
0AD16:  GOTO   AD2E
....................             fprintf(PC, "\t\t-> Error: Failed to dequeue SMF data\r\n");
0AD1A:  MOVLW  E6
0AD1C:  MOVWF  FF6
0AD1E:  MOVLW  12
0AD20:  MOVWF  FF7
0AD22:  MOVLW  00
0AD24:  MOVWF  FF8
0AD26:  CALL   1BB0
....................             break;
0AD2A:  GOTO   AD32
....................          }
0AD2E:  GOTO   ABB2
....................       }
....................       
....................       fprintf(PC, "\t\t-> Completed processing %d SMF operations\r\n", processed_count);
0AD32:  MOVLW  10
0AD34:  MOVWF  FF6
0AD36:  MOVLW  13
0AD38:  MOVWF  FF7
0AD3A:  MOVLW  00
0AD3C:  MOVWF  FF8
0AD3E:  MOVLW  1A
0AD40:  MOVLB  B
0AD42:  MOVWF  x1B
0AD44:  MOVLB  0
0AD46:  CALL   1BE0
0AD4A:  MOVFF  2DA,436
0AD4E:  MOVLW  18
0AD50:  MOVLB  4
0AD52:  MOVWF  x37
0AD54:  MOVLB  0
0AD56:  CALL   907E
0AD5A:  MOVLW  2C
0AD5C:  MOVWF  FF6
0AD5E:  MOVLW  13
0AD60:  MOVWF  FF7
0AD62:  MOVLW  00
0AD64:  MOVWF  FF8
0AD66:  MOVLW  11
0AD68:  MOVLB  B
0AD6A:  MOVWF  x1B
0AD6C:  MOVLB  0
0AD6E:  CALL   1BE0
....................       
....................       status[0] = FINISHED;
0AD72:  MOVLW  06
0AD74:  MOVWF  48
....................    } else {
0AD76:  GOTO   AD8A
....................       fprintf(PC, "\t\t-> denied\r\n");
0AD7A:  MOVLW  3E
0AD7C:  MOVWF  FF6
0AD7E:  MOVLW  13
0AD80:  MOVWF  FF7
0AD82:  MOVLW  00
0AD84:  MOVWF  FF8
0AD86:  CALL   1BB0
....................    }
0AD8A:  GOTO   AE04 (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[])
.................... {
....................    unsigned int8 measurement_step = uplinkcmd[1]; // Get the measurement step from the parameter array
....................    fprintf(PC, "Start MODE TEST IV\r\n");
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(uplinkcmd); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
.................... //!   sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
0896A:  MOVLW  F0
0896C:  MOVWF  FF6
0896E:  MOVLW  13
08970:  MOVWF  FF7
08972:  MOVLW  00
08974:  MOVWF  FF8
08976:  CALL   1BB0
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
0897A:  MOVFF  2E0,304
0897E:  MOVFF  2DF,303
08982:  GOTO   6642
08986:  MOVFF  02,03
0898A:  MOVF   01,W
0898C:  MOVWF  FE1
0898E:  MOVFF  03,FE2
08992:  MOVLW  02
08994:  MOVWF  FEA
08996:  MOVLW  E1
08998:  MOVWF  FE9
0899A:  MOVLW  0C
0899C:  MOVWF  01
0899E:  MOVFF  FE6,FEE
089A2:  DECFSZ 01,F
089A4:  GOTO   899E
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
089A8:  MOVLW  06
089AA:  MOVWF  FF6
089AC:  MOVLW  14
089AE:  MOVWF  FF7
089B0:  MOVLW  00
089B2:  MOVWF  FF8
089B4:  MOVLW  05
089B6:  MOVLB  B
089B8:  MOVWF  x1B
089BA:  MOVLB  0
089BC:  CALL   1BE0
089C0:  MOVFF  2E1,B1B
089C4:  MOVLW  37
089C6:  MOVLB  B
089C8:  MOVWF  x1C
089CA:  MOVLB  0
089CC:  CALL   1E34
089D0:  MOVLW  0D
089D2:  MOVLB  B
089D4:  MOVWF  x6E
089D6:  MOVLB  0
089D8:  CALL   1B5E
089DC:  MOVLW  0A
089DE:  MOVLB  B
089E0:  MOVWF  x6E
089E2:  MOVLB  0
089E4:  CALL   1B5E
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
089E8:  MOVLW  12
089EA:  MOVWF  FF6
089EC:  MOVLW  14
089EE:  MOVWF  FF7
089F0:  MOVLW  00
089F2:  MOVWF  FF8
089F4:  MOVLW  0D
089F6:  MOVLB  B
089F8:  MOVWF  x1B
089FA:  MOVLB  0
089FC:  CALL   1BE0
08A00:  MOVFF  2E3,B1B
08A04:  MOVLW  37
08A06:  MOVLB  B
08A08:  MOVWF  x1C
08A0A:  MOVLB  0
08A0C:  CALL   1E34
08A10:  MOVFF  2E2,B1B
08A14:  MOVLW  37
08A16:  MOVLB  B
08A18:  MOVWF  x1C
08A1A:  MOVLB  0
08A1C:  CALL   1E34
08A20:  MOVLW  24
08A22:  MOVWF  FF6
08A24:  MOVLW  14
08A26:  MOVWF  FF7
08A28:  MOVLW  00
08A2A:  MOVWF  FF8
08A2C:  MOVLW  05
08A2E:  MOVLB  B
08A30:  MOVWF  x1B
08A32:  MOVLB  0
08A34:  CALL   1BE0
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
08A38:  MOVLW  2A
08A3A:  MOVWF  FF6
08A3C:  MOVLW  14
08A3E:  MOVWF  FF7
08A40:  MOVLW  00
08A42:  MOVWF  FF8
08A44:  MOVLW  14
08A46:  MOVLB  B
08A48:  MOVWF  x1B
08A4A:  MOVLB  0
08A4C:  CALL   1BE0
08A50:  MOVFF  2E5,B1B
08A54:  MOVLW  37
08A56:  MOVLB  B
08A58:  MOVWF  x1C
08A5A:  MOVLB  0
08A5C:  CALL   1E34
08A60:  MOVFF  2E4,B1B
08A64:  MOVLW  37
08A66:  MOVLB  B
08A68:  MOVWF  x1C
08A6A:  MOVLB  0
08A6C:  CALL   1E34
08A70:  MOVLW  43
08A72:  MOVWF  FF6
08A74:  MOVLW  14
08A76:  MOVWF  FF7
08A78:  MOVLW  00
08A7A:  MOVWF  FF8
08A7C:  MOVLW  05
08A7E:  MOVLB  B
08A80:  MOVWF  x1B
08A82:  MOVLB  0
08A84:  CALL   1BE0
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
08A88:  MOVLW  4A
08A8A:  MOVWF  FF6
08A8C:  MOVLW  14
08A8E:  MOVWF  FF7
08A90:  MOVLW  00
08A92:  MOVWF  FF8
08A94:  MOVLW  0F
08A96:  MOVLB  B
08A98:  MOVWF  x1B
08A9A:  MOVLB  0
08A9C:  CALL   1BE0
08AA0:  MOVFF  2E7,B1B
08AA4:  MOVLW  37
08AA6:  MOVLB  B
08AA8:  MOVWF  x1C
08AAA:  MOVLB  0
08AAC:  CALL   1E34
08AB0:  MOVFF  2E6,B1B
08AB4:  MOVLW  37
08AB6:  MOVLB  B
08AB8:  MOVWF  x1C
08ABA:  MOVLB  0
08ABC:  CALL   1E34
08AC0:  MOVLW  5E
08AC2:  MOVWF  FF6
08AC4:  MOVLW  14
08AC6:  MOVWF  FF7
08AC8:  MOVLW  00
08ACA:  MOVWF  FF8
08ACC:  MOVLW  05
08ACE:  MOVLB  B
08AD0:  MOVWF  x1B
08AD2:  MOVLB  0
08AD4:  CALL   1BE0
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
08AD8:  MOVLW  64
08ADA:  MOVWF  FF6
08ADC:  MOVLW  14
08ADE:  MOVWF  FF7
08AE0:  MOVLW  00
08AE2:  MOVWF  FF8
08AE4:  MOVLW  10
08AE6:  MOVLB  B
08AE8:  MOVWF  x1B
08AEA:  MOVLB  0
08AEC:  CALL   1BE0
08AF0:  MOVFF  2E9,B1B
08AF4:  MOVLW  37
08AF6:  MOVLB  B
08AF8:  MOVWF  x1C
08AFA:  MOVLB  0
08AFC:  CALL   1E34
08B00:  MOVFF  2E8,B1B
08B04:  MOVLW  37
08B06:  MOVLB  B
08B08:  MOVWF  x1C
08B0A:  MOVLB  0
08B0C:  CALL   1E34
08B10:  MOVLW  79
08B12:  MOVWF  FF6
08B14:  MOVLW  14
08B16:  MOVWF  FF7
08B18:  MOVLW  00
08B1A:  MOVWF  FF8
08B1C:  MOVLW  05
08B1E:  MOVLB  B
08B20:  MOVWF  x1B
08B22:  MOVLB  0
08B24:  CALL   1BE0
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
08B28:  MOVLW  80
08B2A:  MOVWF  FF6
08B2C:  MOVLW  14
08B2E:  MOVWF  FF7
08B30:  MOVLW  00
08B32:  MOVWF  FF8
08B34:  MOVLW  13
08B36:  MOVLB  B
08B38:  MOVWF  x1B
08B3A:  MOVLB  0
08B3C:  CALL   1BE0
08B40:  MOVFF  2EB,B1B
08B44:  MOVLW  37
08B46:  MOVLB  B
08B48:  MOVWF  x1C
08B4A:  MOVLB  0
08B4C:  CALL   1E34
08B50:  MOVFF  2EA,B1B
08B54:  MOVLW  37
08B56:  MOVLB  B
08B58:  MOVWF  x1C
08B5A:  MOVLB  0
08B5C:  CALL   1E34
08B60:  MOVLW  98
08B62:  MOVWF  FF6
08B64:  MOVLW  14
08B66:  MOVWF  FF7
08B68:  MOVLW  00
08B6A:  MOVWF  FF8
08B6C:  MOVLW  04
08B6E:  MOVLB  B
08B70:  MOVWF  x1B
08B72:  MOVLB  0
08B74:  CALL   1BE0
....................    fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
08B78:  MOVLW  9E
08B7A:  MOVWF  FF6
08B7C:  MOVLW  14
08B7E:  MOVWF  FF7
08B80:  MOVLW  00
08B82:  MOVWF  FF8
08B84:  MOVLW  0E
08B86:  MOVLB  B
08B88:  MOVWF  x1B
08B8A:  MOVLB  0
08B8C:  CALL   1BE0
08B90:  MOVFF  2EC,3B7
08B94:  MOVLW  1B
08B96:  MOVLB  3
08B98:  MOVWF  xB8
08B9A:  MOVLB  0
08B9C:  CALL   6798
08BA0:  MOVLW  0D
08BA2:  MOVLB  B
08BA4:  MOVWF  x6E
08BA6:  MOVLB  0
08BA8:  CALL   1B5E
08BAC:  MOVLW  0A
08BAE:  MOVLB  B
08BB0:  MOVWF  x6E
08BB2:  MOVLB  0
08BB4:  CALL   1B5E
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
08BB8:  MOVFF  2E1,332
08BBC:  MOVLB  3
08BBE:  CLRF   x33
08BC0:  MOVLB  0
08BC2:  CALL   3DC2
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
08BC6:  CALL   3360
08BCA:  MOVFF  01,2EE
08BCE:  MOVFF  00,2ED
08BD2:  MOVLB  2
08BD4:  CLRF   xF0
08BD6:  CLRF   xEF
08BD8:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
08BDA:  CALL   3360
08BDE:  MOVFF  03,300
08BE2:  MOVFF  02,2FF
08BE6:  MOVFF  01,2FE
08BEA:  MOVFF  00,2FD
08BEE:  MOVLB  2
08BF0:  MOVF   xED,W
08BF2:  SUBWF  xFD,F
08BF4:  MOVF   xEE,W
08BF6:  SUBWFB xFE,F
08BF8:  MOVLW  00
08BFA:  SUBWFB xFF,F
08BFC:  MOVLW  00
08BFE:  MOVLB  3
08C00:  SUBWFB x00,F
08C02:  MOVF   x00,F
08C04:  BTFSC  FD8.2
08C06:  BRA    8C0E
08C08:  MOVLB  0
08C0A:  GOTO   8CD8
08C0E:  MOVLB  0
08C10:  MOVLB  2
08C12:  MOVF   xFF,F
08C14:  BTFSC  FD8.2
08C16:  BRA    8C1E
08C18:  MOVLB  0
08C1A:  GOTO   8CD8
08C1E:  MOVLB  0
08C20:  MOVLB  2
08C22:  MOVF   xFE,W
08C24:  SUBWF  xEB,W
08C26:  BTFSC  FD8.0
08C28:  BRA    8C30
08C2A:  MOVLB  0
08C2C:  GOTO   8CD8
08C30:  MOVLB  0
08C32:  BTFSS  FD8.2
08C34:  GOTO   8C4A
08C38:  MOVLB  2
08C3A:  MOVF   xEA,W
08C3C:  SUBWF  xFD,W
08C3E:  BTFSS  FD8.0
08C40:  BRA    8C48
08C42:  MOVLB  0
08C44:  GOTO   8CD8
08C48:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
08C4A:  CALL   3360
08C4E:  MOVFF  01,2F0
08C52:  MOVFF  00,2EF
....................       if (current_sec - start_time >= cmd.meas_time) {
08C56:  MOVLB  2
08C58:  MOVF   xED,W
08C5A:  SUBWF  xEF,W
08C5C:  MOVWF  xFD
08C5E:  MOVF   xEE,W
08C60:  SUBWFB xF0,W
08C62:  MOVWF  xFE
08C64:  MOVF   xEB,W
08C66:  SUBWF  xFE,W
08C68:  BTFSC  FD8.0
08C6A:  BRA    8C72
08C6C:  MOVLB  0
08C6E:  GOTO   8C90
08C72:  MOVLB  0
08C74:  BTFSS  FD8.2
08C76:  GOTO   8C8C
08C7A:  MOVLB  2
08C7C:  MOVF   xEA,W
08C7E:  SUBWF  xFD,W
08C80:  BTFSC  FD8.0
08C82:  BRA    8C8A
08C84:  MOVLB  0
08C86:  GOTO   8C90
08C8A:  MOVLB  0
....................           break;
08C8C:  GOTO   8CD8
....................       }
....................       sweep_with_threshold(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
08C90:  MOVFF  2E5,2FE
08C94:  MOVFF  2E4,2FD
08C98:  MOVFF  2E7,300
08C9C:  MOVFF  2E6,2FF
08CA0:  MOVFF  2E9,302
08CA4:  MOVFF  2E8,301
08CA8:  GOTO   7138
....................       // Sleep for the specified time
....................       delay_ms(cmd.sleep_time);
08CAC:  MOVFF  2E3,2FD
08CB0:  MOVLB  2
08CB2:  INCF   xFD,F
08CB4:  MOVLB  0
08CB6:  MOVLB  2
08CB8:  DECFSZ xFD,F
08CBA:  BRA    8CC0
08CBC:  MOVLB  0
08CBE:  BRA    8CCC
08CC0:  MOVLB  B
08CC2:  SETF   xC3
08CC4:  MOVLB  0
08CC6:  CALL   1B30
08CCA:  BRA    8CB6
08CCC:  MOVFF  2E2,BC3
08CD0:  CALL   1B30
08CD4:  GOTO   8BDA
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
08CD8:  MOVFF  2E1,332
08CDC:  MOVLB  3
08CDE:  SETF   x33
08CE0:  MOVLB  0
08CE2:  CALL   3DC2
.................... 
....................    FlashOperationStruct data;
....................    data.func_type = SMF_WRITE;
08CE6:  CLRF   03
08CE8:  MOVLW  00
08CEA:  MOVWF  02
08CEC:  MOVLW  98
08CEE:  MOVWF  01
08CF0:  MOVLW  9A
08CF2:  MOVWF  00
08CF4:  MOVFF  00,2F2
....................    data.mission_id = 0x01; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
08CF8:  MOVLW  01
08CFA:  MOVLB  2
08CFC:  MOVWF  xF1
....................    data.write_mode = SMF_WRITE_CIRCULAR;
08CFE:  MOVLW  02
08D00:  MOVWF  xF3
....................    data.source_type = SOURCE_MISF_UNCOPIED;
08D02:  BCF    xF4.0
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
08D04:  MOVLW  02
08D06:  MOVWF  xFE
08D08:  MOVLW  F1
08D0A:  MOVWF  xFD
08D0C:  MOVLB  0
08D0E:  GOTO   86EC
.................... 
....................    fprintf(PC, "End MODE MEAS IV\r\n");
08D12:  MOVLW  B2
08D14:  MOVWF  FF6
08D16:  MOVLW  14
08D18:  MOVWF  FF7
08D1A:  MOVLW  00
08D1C:  MOVWF  FF8
08D1E:  CALL   1BB0
08D22:  GOTO   8F60 (RETURN)
.................... }
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
06642:  MOVLB  3
06644:  MOVF   x03,W
06646:  MOVWF  FE9
06648:  MOVF   x04,W
0664A:  MOVWF  FEA
0664C:  MOVFF  FEF,305
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
06650:  MOVLW  01
06652:  ADDWF  x03,W
06654:  MOVWF  FE9
06656:  MOVLW  00
06658:  ADDWFC x04,W
0665A:  MOVWF  FEA
0665C:  MOVF   FEF,W
0665E:  CLRF   x12
06660:  MOVWF  x11
06662:  MOVFF  311,312
06666:  CLRF   x11
06668:  MOVLW  02
0666A:  ADDWF  x03,W
0666C:  MOVWF  FE9
0666E:  MOVLW  00
06670:  ADDWFC x04,W
06672:  MOVWF  FEA
06674:  MOVF   FEF,W
06676:  CLRF   03
06678:  IORWF  x11,W
0667A:  MOVWF  x06
0667C:  MOVF   03,W
0667E:  IORWF  x12,W
06680:  MOVWF  x07
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
06682:  MOVLW  03
06684:  ADDWF  x03,W
06686:  MOVWF  FE9
06688:  MOVLW  00
0668A:  ADDWFC x04,W
0668C:  MOVWF  FEA
0668E:  MOVF   FEF,W
06690:  CLRF   x12
06692:  MOVWF  x11
06694:  RLCF   x11,W
06696:  MOVWF  x08
06698:  RLCF   x12,W
0669A:  MOVWF  x09
0669C:  RLCF   x08,F
0669E:  RLCF   x09,F
066A0:  RLCF   x08,F
066A2:  RLCF   x09,F
066A4:  RLCF   x08,F
066A6:  RLCF   x09,F
066A8:  MOVLW  F0
066AA:  ANDWF  x08,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
066AC:  MOVLW  04
066AE:  ADDWF  x03,W
066B0:  MOVWF  FE9
066B2:  MOVLW  00
066B4:  ADDWFC x04,W
066B6:  MOVWF  FEA
066B8:  MOVF   FEF,W
066BA:  CLRF   x12
066BC:  MOVWF  x11
066BE:  RLCF   x11,W
066C0:  MOVWF  x0A
066C2:  RLCF   x12,W
066C4:  MOVWF  x0B
066C6:  RLCF   x0A,F
066C8:  RLCF   x0B,F
066CA:  RLCF   x0A,F
066CC:  RLCF   x0B,F
066CE:  RLCF   x0A,F
066D0:  RLCF   x0B,F
066D2:  MOVLW  F0
066D4:  ANDWF  x0A,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
066D6:  MOVLW  05
066D8:  ADDWF  x03,W
066DA:  MOVWF  FE9
066DC:  MOVLW  00
066DE:  ADDWFC x04,W
066E0:  MOVWF  FEA
066E2:  MOVF   FEF,W
066E4:  CLRF   x12
066E6:  MOVWF  x11
066E8:  RLCF   x11,W
066EA:  MOVWF  x0C
066EC:  RLCF   x12,W
066EE:  MOVWF  x0D
066F0:  RLCF   x0C,F
066F2:  RLCF   x0D,F
066F4:  RLCF   x0C,F
066F6:  RLCF   x0D,F
066F8:  RLCF   x0C,F
066FA:  RLCF   x0D,F
066FC:  MOVLW  F0
066FE:  ANDWF  x0C,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
06700:  MOVLW  06
06702:  ADDWF  x03,W
06704:  MOVWF  FE9
06706:  MOVLW  00
06708:  ADDWFC x04,W
0670A:  MOVWF  FEA
0670C:  MOVF   FEF,W
0670E:  CLRF   x12
06710:  MOVWF  x11
06712:  MOVFF  311,312
06716:  CLRF   x11
06718:  MOVLW  07
0671A:  ADDWF  x03,W
0671C:  MOVWF  FE9
0671E:  MOVLW  00
06720:  ADDWFC x04,W
06722:  MOVWF  FEA
06724:  MOVF   FEF,W
06726:  CLRF   03
06728:  IORWF  x11,W
0672A:  MOVWF  x0E
0672C:  MOVF   03,W
0672E:  IORWF  x12,W
06730:  MOVWF  x0F
....................    cmd.is_finished = uplinkcmd[8];
06732:  MOVLW  08
06734:  ADDWF  x03,W
06736:  MOVWF  FE9
06738:  MOVLW  00
0673A:  ADDWFC x04,W
0673C:  MOVWF  FEA
0673E:  MOVFF  FEF,310
....................    return cmd;
06742:  MOVLW  05
06744:  MOVWF  01
06746:  MOVLW  03
06748:  MOVWF  02
0674A:  MOVLB  0
0674C:  GOTO   8986 (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    SMF_WRITE = 0x00,    // SMF書き込み操作
....................    SMF_READ = 0x01,     // SMF読み込み操作
....................    SMF_ERASE = 0x02     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... // MISF/SMF統合管理構造体
.................... typedef struct {
....................    // MISF情報
....................    int32 misf_start_addr;          // MISF開始アドレス
....................    int32 misf_end_addr;            // MISF終了アドレス
....................    int32 misf_current_write_addr;  // MISF現在の書き込み位置
....................    int32 misf_uncopied_count;      // MISF未コピーデータ数
....................    int32 misf_total_size;          // MISF総サイズ
....................    
....................    // SMF情報
....................    int32 smf_start_addr;           // SMF開始アドレス
....................    int32 smf_end_addr;             // SMF終了アドレス
....................    int32 smf_current_write_addr;   // SMF現在の書き込み位置
....................    int32 smf_copied_count;         // SMFコピー済みデータ数
....................    int32 smf_total_size;           // SMF総サイズ
....................    
....................    // 管理情報
....................    int8 mission_id;                // ミッションID
....................    int1 is_full;                   // MISFフル状態フラグ
....................    int1 transfer_in_progress;      // 転送進行中フラグ
.................... } MisfSmfManagerStruct;
.................... 
.................... /*
....................  * 使用例:
....................  * 
....................  * 1. ミッション初期化:
....................  * init_misf_smf_manager(0x01, 0x160000, 0x10000, 0x200000, 0x20000);
....................  * 
....................  * 2. MISFにデータ追加時:
....................  * update_misf_data(0x01, 256);  // 256バイトのデータを追加
....................  * 
....................  * 3. 未コピーデータの自動転送:
....................  * enqueue_auto_transfer(0x01);  // 未コピーデータを自動的にSMFに転送キュー
....................  * 
....................  * 4. 転送完了時:
....................  * complete_transfer_and_update_counter(0x01, 256);  // 256バイト転送完了、カウンタ更新
....................  * 
....................  * 5. 従来の使用例（下位互換）:
....................  * FlashOperationStruct uncopied_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_CIRCULAR,
....................  *     .source_type = SOURCE_MISF_UNCOPIED,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  * 
....................  * 6. 指定アドレスの上書き:
....................  * FlashOperationStruct manual_data = {
....................  *     .mission_id = 0x01,
....................  *     .func_type = SMF_WRITE,
....................  *     .write_mode = SMF_WRITE_OVERWRITE,
....................  *     .source_type = SOURCE_MISF_MANUAL,
....................  *     .misf_start_addr = 0x160000,
....................  *     .misf_size = 1024,
....................  *     .manager = get_misf_smf_manager(0x01)
....................  * };
....................  */
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 start_address;
....................    int32 size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x0000FFFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x0001FFFF
.................... #define MISF_CIGS_ENVIRO_START    0x00020000
.................... #define MISF_CIGS_ENVIRO_END      0x0002FFFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00030000
.................... #define MISF_CIGS_IV_HEADER_END   0x0003FFFF
.................... #define MISF_CIGS_IV_DATA_START   0x00040000
.................... #define MISF_CIGS_IV_DATA_END     0x0004FFFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         struct {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;
....................         } payload;
....................         unsigned int8 crc;
....................     } packet;
....................     unsigned int8 bytes[PACKET_SIZE];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data;
.................... Flash_t environment_data;
.................... Flash_t iv_header;
.................... Flash_t iv_data;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
048C4:  MOVLW  C6
048C6:  MOVWF  FF6
048C8:  MOVLW  14
048CA:  MOVWF  FF7
048CC:  MOVLW  00
048CE:  MOVWF  FF8
048D0:  CALL   1BB0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
048D4:  MOVLB  2
048D6:  MOVF   xE1,W
048D8:  MOVWF  FE9
048DA:  MOVF   xE2,W
048DC:  MOVWF  FEA
048DE:  MOVFF  FEF,2E3
....................    piclog_make(cmd, 0x00); // Log the command execution
048E2:  MOVFF  2E3,332
048E6:  MOVLB  3
048E8:  CLRF   x33
048EA:  MOVLB  0
048EC:  CALL   3DC2
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
048F0:  MOVLB  2
048F2:  CLRF   xE7
048F4:  CLRF   xE6
048F6:  CLRF   xE5
048F8:  CLRF   xE4
048FA:  MOVLB  0
048FC:  MOVLB  2
048FE:  MOVF   xE7,F
04900:  BTFSC  FD8.2
04902:  BRA    490A
04904:  MOVLB  0
04906:  GOTO   4982
0490A:  MOVLB  0
0490C:  MOVLB  2
0490E:  MOVF   xE6,W
04910:  SUBLW  0F
04912:  BTFSC  FD8.0
04914:  BRA    491C
04916:  MOVLB  0
04918:  GOTO   4982
0491C:  MOVLB  0
0491E:  BTFSS  FD8.2
04920:  GOTO   494E
04924:  MOVLB  2
04926:  MOVF   xE5,W
04928:  SUBLW  FF
0492A:  BTFSC  FD8.0
0492C:  BRA    4934
0492E:  MOVLB  0
04930:  GOTO   4982
04934:  MOVLB  0
04936:  BTFSS  FD8.2
04938:  GOTO   494E
0493C:  MOVLB  2
0493E:  MOVF   xE4,W
04940:  SUBLW  FE
04942:  BTFSC  FD8.0
04944:  BRA    494C
04946:  MOVLB  0
04948:  GOTO   4982
0494C:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
0494E:  MOVFF  261,328
04952:  MOVFF  260,327
04956:  MOVFF  25F,326
0495A:  MOVFF  25E,325
0495E:  MOVFF  2E7,32C
04962:  MOVFF  2E6,32B
04966:  MOVFF  2E5,32A
0496A:  MOVFF  2E4,329
0496E:  CALL   4568
04972:  MOVLW  01
04974:  MOVLB  2
04976:  ADDWF  xE6,F
04978:  MOVLW  00
0497A:  ADDWFC xE7,F
0497C:  MOVLB  0
0497E:  GOTO   48FC
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04982:  MOVFF  2E3,332
04986:  MOVLB  3
04988:  SETF   x33
0498A:  MOVLB  0
0498C:  CALL   3DC2
....................    printf("End Flash Erase All\r\n");
04990:  MOVLW  DE
04992:  MOVWF  FF6
04994:  MOVLW  14
04996:  MOVWF  FF7
04998:  MOVLW  00
0499A:  MOVWF  FF8
0499C:  CALL   1BB0
049A0:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
049A2:  MOVLW  F4
049A4:  MOVWF  FF6
049A6:  MOVLW  14
049A8:  MOVWF  FF7
049AA:  MOVLW  00
049AC:  MOVWF  FF8
049AE:  CALL   1BB0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
049B2:  MOVLB  2
049B4:  MOVF   xDF,W
049B6:  MOVWF  FE9
049B8:  MOVF   xE0,W
049BA:  MOVWF  FEA
049BC:  MOVFF  FEF,2E1
049C0:  MOVLW  01
049C2:  ADDWF  xDF,W
049C4:  MOVWF  FE9
049C6:  MOVLW  00
049C8:  ADDWFC xE0,W
049CA:  MOVWF  FEA
049CC:  MOVF   FEF,W
049CE:  CLRF   xE9
049D0:  CLRF   xE8
049D2:  CLRF   xE7
049D4:  MOVWF  xE6
049D6:  MOVFF  2E6,2E9
049DA:  CLRF   xE6
049DC:  CLRF   xE7
049DE:  CLRF   xE8
049E0:  MOVLW  02
049E2:  ADDWF  xDF,W
049E4:  MOVWF  FE9
049E6:  MOVLW  00
049E8:  ADDWFC xE0,W
049EA:  MOVWF  FEA
049EC:  MOVF   FEF,W
049EE:  CLRF   xEE
049F0:  CLRF   xED
049F2:  CLRF   xEC
049F4:  MOVWF  xEB
049F6:  MOVFF  2EC,03
049FA:  MOVFF  2EB,02
049FE:  CLRF   00
04A00:  CLRF   01
04A02:  MOVF   00,W
04A04:  IORWF  xE6,F
04A06:  MOVF   01,W
04A08:  IORWF  xE7,F
04A0A:  MOVF   02,W
04A0C:  IORWF  xE8,F
04A0E:  MOVF   03,W
04A10:  IORWF  xE9,F
04A12:  MOVLW  03
04A14:  ADDWF  xDF,W
04A16:  MOVWF  FE9
04A18:  MOVLW  00
04A1A:  ADDWFC xE0,W
04A1C:  MOVWF  FEA
04A1E:  MOVF   FEF,W
04A20:  CLRF   xEE
04A22:  CLRF   xED
04A24:  CLRF   xEC
04A26:  MOVWF  xEB
04A28:  MOVFF  2ED,03
04A2C:  MOVFF  2EC,02
04A30:  MOVFF  2EB,01
04A34:  CLRF   00
04A36:  MOVF   00,W
04A38:  IORWF  xE6,F
04A3A:  MOVF   01,W
04A3C:  IORWF  xE7,F
04A3E:  MOVF   02,W
04A40:  IORWF  xE8,F
04A42:  MOVF   03,W
04A44:  IORWF  xE9,F
04A46:  MOVLW  04
04A48:  ADDWF  xDF,W
04A4A:  MOVWF  FE9
04A4C:  MOVLW  00
04A4E:  ADDWFC xE0,W
04A50:  MOVWF  FEA
04A52:  MOVF   FEF,W
04A54:  MOVWF  00
04A56:  CLRF   01
04A58:  CLRF   02
04A5A:  CLRF   03
04A5C:  MOVF   00,W
04A5E:  IORWF  xE6,W
04A60:  MOVWF  xE2
04A62:  MOVF   01,W
04A64:  IORWF  xE7,W
04A66:  MOVWF  xE3
04A68:  MOVF   02,W
04A6A:  IORWF  xE8,W
04A6C:  MOVWF  xE4
04A6E:  MOVF   03,W
04A70:  IORWF  xE9,W
04A72:  MOVWF  xE5
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
04A74:  MOVLW  12
04A76:  MOVWF  FF6
04A78:  MOVLW  15
04A7A:  MOVWF  FF7
04A7C:  MOVLW  00
04A7E:  MOVWF  FF8
04A80:  MOVLW  13
04A82:  MOVLB  B
04A84:  MOVWF  x1B
04A86:  MOVLB  0
04A88:  CALL   1BE0
04A8C:  MOVFF  2E5,B1B
04A90:  MOVLW  37
04A92:  MOVLB  B
04A94:  MOVWF  x1C
04A96:  MOVLB  0
04A98:  CALL   1E34
04A9C:  MOVFF  2E4,B1B
04AA0:  MOVLW  37
04AA2:  MOVLB  B
04AA4:  MOVWF  x1C
04AA6:  MOVLB  0
04AA8:  CALL   1E34
04AAC:  MOVFF  2E3,B1B
04AB0:  MOVLW  37
04AB2:  MOVLB  B
04AB4:  MOVWF  x1C
04AB6:  MOVLB  0
04AB8:  CALL   1E34
04ABC:  MOVFF  2E2,B1B
04AC0:  MOVLW  37
04AC2:  MOVLB  B
04AC4:  MOVWF  x1C
04AC6:  MOVLB  0
04AC8:  CALL   1E34
04ACC:  MOVLW  0D
04ACE:  MOVLB  B
04AD0:  MOVWF  x6E
04AD2:  MOVLB  0
04AD4:  CALL   1B5E
04AD8:  MOVLW  0A
04ADA:  MOVLB  B
04ADC:  MOVWF  x6E
04ADE:  MOVLB  0
04AE0:  CALL   1B5E
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04AE4:  MOVFF  2E1,332
04AE8:  MOVLB  3
04AEA:  CLRF   x33
04AEC:  MOVLB  0
04AEE:  CALL   3DC2
....................    
....................    sector_erase(mis_fm, sector_address);
04AF2:  MOVFF  261,328
04AF6:  MOVFF  260,327
04AFA:  MOVFF  25F,326
04AFE:  MOVFF  25E,325
04B02:  MOVFF  2E5,32C
04B06:  MOVFF  2E4,32B
04B0A:  MOVFF  2E3,32A
04B0E:  MOVFF  2E2,329
04B12:  CALL   4568
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04B16:  MOVFF  2E1,332
04B1A:  MOVLB  3
04B1C:  SETF   x33
04B1E:  MOVLB  0
04B20:  CALL   3DC2
....................    printf("End Flash Erase 1 Sector\r\n");
04B24:  MOVLW  2E
04B26:  MOVWF  FF6
04B28:  MOVLW  15
04B2A:  MOVWF  FF7
04B2C:  MOVLW  00
04B2E:  MOVWF  FF8
04B30:  CALL   1BB0
04B34:  GOTO   8E70 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
04E94:  MOVLW  4A
04E96:  MOVWF  FF6
04E98:  MOVLW  15
04E9A:  MOVWF  FF7
04E9C:  MOVLW  00
04E9E:  MOVWF  FF8
04EA0:  CALL   1BB0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
04EA4:  MOVLB  2
04EA6:  MOVF   xDF,W
04EA8:  MOVWF  FE9
04EAA:  MOVF   xE0,W
04EAC:  MOVWF  FEA
04EAE:  MOVFF  FEF,2E1
04EB2:  MOVLW  01
04EB4:  ADDWF  xDF,W
04EB6:  MOVWF  FE9
04EB8:  MOVLW  00
04EBA:  ADDWFC xE0,W
04EBC:  MOVWF  FEA
04EBE:  MOVF   FEF,W
04EC0:  CLRF   xE9
04EC2:  CLRF   xE8
04EC4:  CLRF   xE7
04EC6:  MOVWF  xE6
04EC8:  MOVFF  2E6,2E9
04ECC:  CLRF   xE6
04ECE:  CLRF   xE7
04ED0:  CLRF   xE8
04ED2:  MOVLW  02
04ED4:  ADDWF  xDF,W
04ED6:  MOVWF  FE9
04ED8:  MOVLW  00
04EDA:  ADDWFC xE0,W
04EDC:  MOVWF  FEA
04EDE:  MOVF   FEF,W
04EE0:  CLRF   xEE
04EE2:  CLRF   xED
04EE4:  CLRF   xEC
04EE6:  MOVWF  xEB
04EE8:  MOVFF  2EC,03
04EEC:  MOVFF  2EB,02
04EF0:  CLRF   00
04EF2:  CLRF   01
04EF4:  MOVF   00,W
04EF6:  IORWF  xE6,F
04EF8:  MOVF   01,W
04EFA:  IORWF  xE7,F
04EFC:  MOVF   02,W
04EFE:  IORWF  xE8,F
04F00:  MOVF   03,W
04F02:  IORWF  xE9,F
04F04:  MOVLW  03
04F06:  ADDWF  xDF,W
04F08:  MOVWF  FE9
04F0A:  MOVLW  00
04F0C:  ADDWFC xE0,W
04F0E:  MOVWF  FEA
04F10:  MOVF   FEF,W
04F12:  CLRF   xEE
04F14:  CLRF   xED
04F16:  CLRF   xEC
04F18:  MOVWF  xEB
04F1A:  MOVFF  2ED,03
04F1E:  MOVFF  2EC,02
04F22:  MOVFF  2EB,01
04F26:  CLRF   00
04F28:  MOVF   00,W
04F2A:  IORWF  xE6,F
04F2C:  MOVF   01,W
04F2E:  IORWF  xE7,F
04F30:  MOVF   02,W
04F32:  IORWF  xE8,F
04F34:  MOVF   03,W
04F36:  IORWF  xE9,F
04F38:  MOVLW  04
04F3A:  ADDWF  xDF,W
04F3C:  MOVWF  FE9
04F3E:  MOVLW  00
04F40:  ADDWFC xE0,W
04F42:  MOVWF  FEA
04F44:  MOVF   FEF,W
04F46:  MOVWF  00
04F48:  CLRF   01
04F4A:  CLRF   02
04F4C:  CLRF   03
04F4E:  MOVF   00,W
04F50:  IORWF  xE6,W
04F52:  MOVWF  xE2
04F54:  MOVF   01,W
04F56:  IORWF  xE7,W
04F58:  MOVWF  xE3
04F5A:  MOVF   02,W
04F5C:  IORWF  xE8,W
04F5E:  MOVWF  xE4
04F60:  MOVF   03,W
04F62:  IORWF  xE9,W
04F64:  MOVWF  xE5
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
04F66:  MOVLW  66
04F68:  MOVWF  FF6
04F6A:  MOVLW  15
04F6C:  MOVWF  FF7
04F6E:  MOVLW  00
04F70:  MOVWF  FF8
04F72:  MOVLW  16
04F74:  MOVLB  B
04F76:  MOVWF  x1B
04F78:  MOVLB  0
04F7A:  CALL   1BE0
04F7E:  MOVFF  2E5,B1B
04F82:  MOVLW  37
04F84:  MOVLB  B
04F86:  MOVWF  x1C
04F88:  MOVLB  0
04F8A:  CALL   1E34
04F8E:  MOVFF  2E4,B1B
04F92:  MOVLW  37
04F94:  MOVLB  B
04F96:  MOVWF  x1C
04F98:  MOVLB  0
04F9A:  CALL   1E34
04F9E:  MOVFF  2E3,B1B
04FA2:  MOVLW  37
04FA4:  MOVLB  B
04FA6:  MOVWF  x1C
04FA8:  MOVLB  0
04FAA:  CALL   1E34
04FAE:  MOVFF  2E2,B1B
04FB2:  MOVLW  37
04FB4:  MOVLB  B
04FB6:  MOVWF  x1C
04FB8:  MOVLB  0
04FBA:  CALL   1E34
04FBE:  MOVLW  0D
04FC0:  MOVLB  B
04FC2:  MOVWF  x6E
04FC4:  MOVLB  0
04FC6:  CALL   1B5E
04FCA:  MOVLW  0A
04FCC:  MOVLB  B
04FCE:  MOVWF  x6E
04FD0:  MOVLB  0
04FD2:  CALL   1B5E
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04FD6:  MOVFF  2E1,332
04FDA:  MOVLB  3
04FDC:  CLRF   x33
04FDE:  MOVLB  0
04FE0:  CALL   3DC2
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
04FE4:  MOVFF  261,438
04FE8:  MOVFF  260,437
04FEC:  MOVFF  25F,436
04FF0:  MOVFF  25E,435
04FF4:  MOVLB  4
04FF6:  CLRF   x3C
04FF8:  CLRF   x3B
04FFA:  CLRF   x3A
04FFC:  CLRF   x39
04FFE:  MOVLB  0
05000:  CALL   4B38
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05004:  MOVFF  2E1,332
05008:  MOVLB  3
0500A:  SETF   x33
0500C:  MOVLB  0
0500E:  CALL   3DC2
....................    printf("End Flash Copy 1 Sector\r\n");
05012:  MOVLW  84
05014:  MOVWF  FF6
05016:  MOVLW  15
05018:  MOVWF  FF7
0501A:  MOVLW  00
0501C:  MOVWF  FF8
0501E:  CALL   1BB0
05022:  GOTO   8E80 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
05026:  MOVLW  9E
05028:  MOVWF  FF6
0502A:  MOVLW  15
0502C:  MOVWF  FF7
0502E:  MOVLW  00
05030:  MOVWF  FF8
05032:  CALL   1BB0
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
05036:  MOVLB  2
05038:  MOVF   xDF,W
0503A:  MOVWF  FE9
0503C:  MOVF   xE0,W
0503E:  MOVWF  FEA
05040:  MOVFF  FEF,2E1
05044:  MOVLW  01
05046:  ADDWF  xDF,W
05048:  MOVWF  FE9
0504A:  MOVLW  00
0504C:  ADDWFC xE0,W
0504E:  MOVWF  FEA
05050:  MOVF   FEF,W
05052:  CLRF   xE9
05054:  CLRF   xE8
05056:  CLRF   xE7
05058:  MOVWF  xE6
0505A:  MOVFF  2E6,2E9
0505E:  CLRF   xE6
05060:  CLRF   xE7
05062:  CLRF   xE8
05064:  MOVLW  02
05066:  ADDWF  xDF,W
05068:  MOVWF  FE9
0506A:  MOVLW  00
0506C:  ADDWFC xE0,W
0506E:  MOVWF  FEA
05070:  MOVF   FEF,W
05072:  CLRF   xEE
05074:  CLRF   xED
05076:  CLRF   xEC
05078:  MOVWF  xEB
0507A:  MOVFF  2EC,03
0507E:  MOVFF  2EB,02
05082:  CLRF   00
05084:  CLRF   01
05086:  MOVF   00,W
05088:  IORWF  xE6,F
0508A:  MOVF   01,W
0508C:  IORWF  xE7,F
0508E:  MOVF   02,W
05090:  IORWF  xE8,F
05092:  MOVF   03,W
05094:  IORWF  xE9,F
05096:  MOVLW  03
05098:  ADDWF  xDF,W
0509A:  MOVWF  FE9
0509C:  MOVLW  00
0509E:  ADDWFC xE0,W
050A0:  MOVWF  FEA
050A2:  MOVF   FEF,W
050A4:  CLRF   xEE
050A6:  CLRF   xED
050A8:  CLRF   xEC
050AA:  MOVWF  xEB
050AC:  MOVFF  2ED,03
050B0:  MOVFF  2EC,02
050B4:  MOVFF  2EB,01
050B8:  CLRF   00
050BA:  MOVF   00,W
050BC:  IORWF  xE6,F
050BE:  MOVF   01,W
050C0:  IORWF  xE7,F
050C2:  MOVF   02,W
050C4:  IORWF  xE8,F
050C6:  MOVF   03,W
050C8:  IORWF  xE9,F
050CA:  MOVLW  04
050CC:  ADDWF  xDF,W
050CE:  MOVWF  FE9
050D0:  MOVLW  00
050D2:  ADDWFC xE0,W
050D4:  MOVWF  FEA
050D6:  MOVF   FEF,W
050D8:  MOVWF  00
050DA:  CLRF   01
050DC:  CLRF   02
050DE:  CLRF   03
050E0:  MOVF   00,W
050E2:  IORWF  xE6,W
050E4:  MOVWF  xE2
050E6:  MOVF   01,W
050E8:  IORWF  xE7,W
050EA:  MOVWF  xE3
050EC:  MOVF   02,W
050EE:  IORWF  xE8,W
050F0:  MOVWF  xE4
050F2:  MOVF   03,W
050F4:  IORWF  xE9,W
050F6:  MOVWF  xE5
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
050F8:  MOVLW  C4
050FA:  MOVWF  FF6
050FC:  MOVLW  15
050FE:  MOVWF  FF7
05100:  MOVLW  00
05102:  MOVWF  FF8
05104:  MOVLW  16
05106:  MOVLB  B
05108:  MOVWF  x1B
0510A:  MOVLB  0
0510C:  CALL   1BE0
05110:  MOVFF  2E5,B1B
05114:  MOVLW  37
05116:  MOVLB  B
05118:  MOVWF  x1C
0511A:  MOVLB  0
0511C:  CALL   1E34
05120:  MOVFF  2E4,B1B
05124:  MOVLW  37
05126:  MOVLB  B
05128:  MOVWF  x1C
0512A:  MOVLB  0
0512C:  CALL   1E34
05130:  MOVFF  2E3,B1B
05134:  MOVLW  37
05136:  MOVLB  B
05138:  MOVWF  x1C
0513A:  MOVLB  0
0513C:  CALL   1E34
05140:  MOVFF  2E2,B1B
05144:  MOVLW  37
05146:  MOVLB  B
05148:  MOVWF  x1C
0514A:  MOVLB  0
0514C:  CALL   1E34
05150:  MOVLW  0D
05152:  MOVLB  B
05154:  MOVWF  x6E
05156:  MOVLB  0
05158:  CALL   1B5E
0515C:  MOVLW  0A
0515E:  MOVLB  B
05160:  MOVWF  x6E
05162:  MOVLB  0
05164:  CALL   1B5E
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05168:  MOVFF  2E1,332
0516C:  MOVLB  3
0516E:  CLRF   x33
05170:  MOVLB  0
05172:  CALL   3DC2
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05176:  MOVFF  2E1,332
0517A:  MOVLB  3
0517C:  SETF   x33
0517E:  MOVLB  0
05180:  CALL   3DC2
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
05184:  MOVLW  E2
05186:  MOVWF  FF6
05188:  MOVLW  15
0518A:  MOVWF  FF7
0518C:  MOVLW  00
0518E:  MOVWF  FF8
05190:  CALL   1BB0
05194:  GOTO   8E90 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
05198:  MOVLW  06
0519A:  MOVWF  FF6
0519C:  MOVLW  16
0519E:  MOVWF  FF7
051A0:  MOVLW  00
051A2:  MOVWF  FF8
051A4:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
051A8:  MOVLB  2
051AA:  MOVF   xDF,W
051AC:  MOVWF  FE9
051AE:  MOVF   xE0,W
051B0:  MOVWF  FEA
051B2:  MOVFF  FEF,331
051B6:  MOVFF  331,332
051BA:  MOVLB  3
051BC:  CLRF   x33
051BE:  MOVLB  0
051C0:  CALL   3DC2
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
051C4:  MOVLB  2
051C6:  CLRF   xE1
051C8:  CLRF   xE2
051CA:  CLRF   xE3
051CC:  CLRF   xE4
051CE:  CLRF   xE5
051D0:  CLRF   xE6
051D2:  CLRF   xE7
....................    
....................    flash_write_param.id = parameter[0];
051D4:  MOVF   xDF,W
051D6:  MOVWF  FE9
051D8:  MOVF   xE0,W
051DA:  MOVWF  FEA
051DC:  MOVFF  FEF,2E1
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
051E0:  MOVLW  01
051E2:  ADDWF  xDF,W
051E4:  MOVWF  FE9
051E6:  MOVLW  00
051E8:  ADDWFC xE0,W
051EA:  MOVWF  FEA
051EC:  MOVF   FEF,W
051EE:  MOVLB  3
051F0:  CLRF   x34
051F2:  CLRF   x33
051F4:  CLRF   x32
051F6:  MOVWF  x31
051F8:  MOVFF  331,334
051FC:  CLRF   x31
051FE:  CLRF   x32
05200:  CLRF   x33
05202:  MOVLW  02
05204:  MOVLB  2
05206:  ADDWF  xDF,W
05208:  MOVWF  FE9
0520A:  MOVLW  00
0520C:  ADDWFC xE0,W
0520E:  MOVWF  FEA
05210:  MOVF   FEF,W
05212:  MOVLB  3
05214:  CLRF   x39
05216:  CLRF   x38
05218:  CLRF   x37
0521A:  MOVWF  x36
0521C:  MOVFF  337,03
05220:  MOVFF  336,02
05224:  CLRF   00
05226:  CLRF   01
05228:  MOVF   00,W
0522A:  IORWF  x31,F
0522C:  MOVF   01,W
0522E:  IORWF  x32,F
05230:  MOVF   02,W
05232:  IORWF  x33,F
05234:  MOVF   03,W
05236:  IORWF  x34,F
05238:  MOVLW  03
0523A:  MOVLB  2
0523C:  ADDWF  xDF,W
0523E:  MOVWF  FE9
05240:  MOVLW  00
05242:  ADDWFC xE0,W
05244:  MOVWF  FEA
05246:  MOVF   FEF,W
05248:  MOVLB  3
0524A:  CLRF   x39
0524C:  CLRF   x38
0524E:  CLRF   x37
05250:  MOVWF  x36
05252:  MOVFF  338,03
05256:  MOVFF  337,02
0525A:  MOVFF  336,01
0525E:  CLRF   00
05260:  MOVF   00,W
05262:  IORWF  x31,F
05264:  MOVF   01,W
05266:  IORWF  x32,F
05268:  MOVF   02,W
0526A:  IORWF  x33,F
0526C:  MOVF   03,W
0526E:  IORWF  x34,F
05270:  MOVLW  04
05272:  MOVLB  2
05274:  ADDWF  xDF,W
05276:  MOVWF  FE9
05278:  MOVLW  00
0527A:  ADDWFC xE0,W
0527C:  MOVWF  FEA
0527E:  MOVF   FEF,W
05280:  MOVWF  00
05282:  CLRF   01
05284:  CLRF   02
05286:  CLRF   03
05288:  MOVF   00,W
0528A:  MOVLB  3
0528C:  IORWF  x31,W
0528E:  MOVLB  2
05290:  MOVWF  xE2
05292:  MOVF   01,W
05294:  MOVLB  3
05296:  IORWF  x32,W
05298:  MOVLB  2
0529A:  MOVWF  xE3
0529C:  MOVF   02,W
0529E:  MOVLB  3
052A0:  IORWF  x33,W
052A2:  MOVLB  2
052A4:  MOVWF  xE4
052A6:  MOVF   03,W
052A8:  MOVLB  3
052AA:  IORWF  x34,W
052AC:  MOVLB  2
052AE:  MOVWF  xE5
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
052B0:  MOVLW  07
052B2:  ADDWF  xDF,W
052B4:  MOVWF  FE9
052B6:  MOVLW  00
052B8:  ADDWFC xE0,W
052BA:  MOVWF  FEA
052BC:  MOVF   FEF,W
052BE:  MOVLB  3
052C0:  CLRF   x32
052C2:  MOVWF  x31
052C4:  MOVFF  331,332
052C8:  CLRF   x31
052CA:  MOVLW  08
052CC:  MOVLB  2
052CE:  ADDWF  xDF,W
052D0:  MOVWF  FE9
052D2:  MOVLW  00
052D4:  ADDWFC xE0,W
052D6:  MOVWF  FEA
052D8:  MOVF   FEF,W
052DA:  CLRF   03
052DC:  MOVLB  3
052DE:  IORWF  x31,W
052E0:  MOVLB  2
052E2:  MOVWF  xE6
052E4:  MOVF   03,W
052E6:  MOVLB  3
052E8:  IORWF  x32,W
052EA:  MOVLB  2
052EC:  MOVWF  xE7
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
052EE:  MOVLW  20
052F0:  MOVWF  FF6
052F2:  MOVLW  16
052F4:  MOVWF  FF7
052F6:  MOVLW  00
052F8:  MOVWF  FF8
052FA:  MOVLW  0C
052FC:  MOVLB  B
052FE:  MOVWF  x1B
05300:  MOVLB  0
05302:  CALL   1BE0
05306:  MOVFF  2E1,B1B
0530A:  MOVLW  37
0530C:  MOVLB  B
0530E:  MOVWF  x1C
05310:  MOVLB  0
05312:  CALL   1E34
05316:  MOVLW  0D
05318:  MOVLB  B
0531A:  MOVWF  x6E
0531C:  MOVLB  0
0531E:  CALL   1B5E
05322:  MOVLW  0A
05324:  MOVLB  B
05326:  MOVWF  x6E
05328:  MOVLB  0
0532A:  CALL   1B5E
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
0532E:  MOVLW  34
05330:  MOVWF  FF6
05332:  MOVLW  16
05334:  MOVWF  FF7
05336:  MOVLW  00
05338:  MOVWF  FF8
0533A:  MOVLW  0E
0533C:  MOVLB  B
0533E:  MOVWF  x1B
05340:  MOVLB  0
05342:  CALL   1BE0
05346:  MOVFF  2E5,B1B
0534A:  MOVLW  37
0534C:  MOVLB  B
0534E:  MOVWF  x1C
05350:  MOVLB  0
05352:  CALL   1E34
05356:  MOVFF  2E4,B1B
0535A:  MOVLW  37
0535C:  MOVLB  B
0535E:  MOVWF  x1C
05360:  MOVLB  0
05362:  CALL   1E34
05366:  MOVFF  2E3,B1B
0536A:  MOVLW  37
0536C:  MOVLB  B
0536E:  MOVWF  x1C
05370:  MOVLB  0
05372:  CALL   1E34
05376:  MOVFF  2E2,B1B
0537A:  MOVLW  37
0537C:  MOVLB  B
0537E:  MOVWF  x1C
05380:  MOVLB  0
05382:  CALL   1E34
05386:  MOVLW  0D
05388:  MOVLB  B
0538A:  MOVWF  x6E
0538C:  MOVLB  0
0538E:  CALL   1B5E
05392:  MOVLW  0A
05394:  MOVLB  B
05396:  MOVWF  x6E
05398:  MOVLB  0
0539A:  CALL   1B5E
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
0539E:  MOVLW  4A
053A0:  MOVWF  FF6
053A2:  MOVLW  16
053A4:  MOVWF  FF7
053A6:  MOVLW  00
053A8:  MOVWF  FF8
053AA:  MOVLW  0E
053AC:  MOVLB  B
053AE:  MOVWF  x1B
053B0:  MOVLB  0
053B2:  CALL   1BE0
053B6:  MOVFF  2E7,B1B
053BA:  MOVLW  37
053BC:  MOVLB  B
053BE:  MOVWF  x1C
053C0:  MOVLB  0
053C2:  CALL   1E34
053C6:  MOVFF  2E6,B1B
053CA:  MOVLW  37
053CC:  MOVLB  B
053CE:  MOVWF  x1C
053D0:  MOVLB  0
053D2:  CALL   1E34
053D6:  MOVLW  0D
053D8:  MOVLB  B
053DA:  MOVWF  x6E
053DC:  MOVLB  0
053DE:  CALL   1B5E
053E2:  MOVLW  0A
053E4:  MOVLB  B
053E6:  MOVWF  x6E
053E8:  MOVLB  0
053EA:  CALL   1B5E
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
053EE:  MOVFF  2E1,332
053F2:  MOVLB  3
053F4:  CLRF   x33
053F6:  MOVLB  0
053F8:  CALL   3DC2
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
053FC:  MOVLW  60
053FE:  MOVWF  FF6
05400:  MOVLW  16
05402:  MOVWF  FF7
05404:  MOVLW  00
05406:  MOVWF  FF8
05408:  CALL   1BB0
....................    for (p = 0; p < flash_write_param.packetnum; p++)
0540C:  MOVLB  3
0540E:  CLRF   x29
05410:  CLRF   x28
05412:  MOVLB  0
05414:  MOVLB  3
05416:  MOVF   x29,W
05418:  MOVLB  2
0541A:  SUBWF  xE7,W
0541C:  BTFSC  FD8.0
0541E:  BRA    5426
05420:  MOVLB  0
05422:  GOTO   5566
05426:  MOVLB  0
05428:  BTFSS  FD8.2
0542A:  GOTO   5442
0542E:  MOVLB  2
05430:  MOVF   xE6,W
05432:  MOVLB  3
05434:  SUBWF  x28,W
05436:  BTFSS  FD8.0
05438:  BRA    5440
0543A:  MOVLB  0
0543C:  GOTO   5566
05440:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
05442:  MOVLB  3
05444:  RLCF   x28,W
05446:  MOVWF  x2A
05448:  RLCF   x29,W
0544A:  MOVWF  x2B
0544C:  RLCF   x2A,F
0544E:  RLCF   x2B,F
05450:  RLCF   x2A,F
05452:  RLCF   x2B,F
05454:  RLCF   x2A,F
05456:  RLCF   x2B,F
05458:  RLCF   x2A,F
0545A:  RLCF   x2B,F
0545C:  RLCF   x2A,F
0545E:  RLCF   x2B,F
05460:  MOVLW  C0
05462:  ANDWF  x2A,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
05464:  CLRF   x2C
05466:  MOVLB  0
05468:  MOVLB  3
0546A:  MOVF   x2C,W
0546C:  SUBLW  3F
0546E:  BTFSC  FD8.0
05470:  BRA    5478
05472:  MOVLB  0
05474:  GOTO   54D8
05478:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
0547A:  CLRF   03
0547C:  MOVLB  3
0547E:  MOVF   x2C,W
05480:  ADDLW  E8
05482:  MOVWF  FE9
05484:  MOVLW  02
05486:  ADDWFC 03,W
05488:  MOVWF  FEA
0548A:  MOVF   x2C,W
0548C:  ADDWF  x2A,W
0548E:  MOVWF  x33
05490:  MOVLW  00
05492:  ADDWFC x2B,W
05494:  MOVWF  x34
05496:  MOVF   x33,W
05498:  MOVWF  00
0549A:  CLRF   03
0549C:  MOVF   00,W
0549E:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
054A0:  CLRF   03
054A2:  MOVF   x2C,W
054A4:  ADDLW  E8
054A6:  MOVWF  FE9
054A8:  MOVLW  02
054AA:  ADDWFC 03,W
054AC:  MOVWF  FEA
054AE:  MOVFF  FEF,331
054B2:  MOVFF  331,B1B
054B6:  MOVLW  37
054B8:  MOVLB  B
054BA:  MOVWF  x1C
054BC:  MOVLB  0
054BE:  CALL   1E34
054C2:  MOVLW  20
054C4:  MOVLB  B
054C6:  MOVWF  x6E
054C8:  MOVLB  0
054CA:  CALL   1B5E
054CE:  MOVLB  3
054D0:  INCF   x2C,F
054D2:  MOVLB  0
054D4:  GOTO   5468
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
054D8:  MOVLB  3
054DA:  RLCF   x28,W
054DC:  MOVWF  02
054DE:  RLCF   x29,W
054E0:  MOVWF  03
054E2:  RLCF   02,F
054E4:  RLCF   03,F
054E6:  RLCF   02,F
054E8:  RLCF   03,F
054EA:  RLCF   02,F
054EC:  RLCF   03,F
054EE:  RLCF   02,F
054F0:  RLCF   03,F
054F2:  RLCF   02,F
054F4:  RLCF   03,F
054F6:  MOVLW  C0
054F8:  ANDWF  02,F
054FA:  MOVF   02,W
054FC:  MOVLB  2
054FE:  ADDWF  xE2,W
05500:  MOVLB  3
05502:  MOVWF  x2D
05504:  MOVF   03,W
05506:  MOVLB  2
05508:  ADDWFC xE3,W
0550A:  MOVLB  3
0550C:  MOVWF  x2E
0550E:  MOVLW  00
05510:  MOVLB  2
05512:  ADDWFC xE4,W
05514:  MOVLB  3
05516:  MOVWF  x2F
05518:  MOVLW  00
0551A:  MOVLB  2
0551C:  ADDWFC xE5,W
0551E:  MOVLB  3
05520:  MOVWF  x30
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
05522:  MOVFF  261,BAE
05526:  MOVFF  260,BAD
0552A:  MOVFF  25F,BAC
0552E:  MOVFF  25E,BAB
05532:  MOVFF  330,BB2
05536:  MOVFF  32F,BB1
0553A:  MOVFF  32E,BB0
0553E:  MOVFF  32D,BAF
05542:  MOVLW  02
05544:  MOVLB  B
05546:  MOVWF  xB4
05548:  MOVLW  E8
0554A:  MOVWF  xB3
0554C:  CLRF   xB6
0554E:  MOVLW  40
05550:  MOVWF  xB5
05552:  MOVLB  0
05554:  CALL   367E
05558:  MOVLB  3
0555A:  INCF   x28,F
0555C:  BTFSC  FD8.2
0555E:  INCF   x29,F
05560:  MOVLB  0
05562:  GOTO   5414
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
05566:  MOVFF  2E1,332
0556A:  MOVLB  3
0556C:  SETF   x33
0556E:  MOVLB  0
05570:  CALL   3DC2
....................    fprintf(PC, "\r\n");
05574:  MOVLW  0D
05576:  MOVLB  B
05578:  MOVWF  x6E
0557A:  MOVLB  0
0557C:  CALL   1B5E
05580:  MOVLW  0A
05582:  MOVLB  B
05584:  MOVWF  x6E
05586:  MOVLB  0
05588:  CALL   1B5E
....................    fprintf(PC, "End Flash Write Demo\r\n");
0558C:  MOVLW  6E
0558E:  MOVWF  FF6
05590:  MOVLW  16
05592:  MOVWF  FF7
05594:  MOVLW  00
05596:  MOVWF  FF8
05598:  CALL   1BB0
0559C:  GOTO   8EA0 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
055D0:  MOVLW  86
055D2:  MOVWF  FF6
055D4:  MOVLW  16
055D6:  MOVWF  FF7
055D8:  MOVLW  00
055DA:  MOVWF  FF8
055DC:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
055E0:  MOVLB  2
055E2:  MOVF   xDF,W
055E4:  MOVWF  FE9
055E6:  MOVF   xE0,W
055E8:  MOVWF  FEA
055EA:  MOVFF  FEF,2E5
055EE:  MOVFF  2E5,332
055F2:  MOVLB  3
055F4:  CLRF   x33
055F6:  MOVLB  0
055F8:  CALL   3DC2
....................    flash_setting(mis_fm);
055FC:  MOVFF  261,3ED
05600:  MOVFF  260,3EC
05604:  MOVFF  25F,3EB
05608:  MOVFF  25E,3EA
0560C:  CALL   55A0
....................    unsigned int32 write_address = 0x00000000;
05610:  MOVLB  2
05612:  CLRF   xE4
05614:  CLRF   xE3
05616:  CLRF   xE2
05618:  CLRF   xE1
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
0561A:  MOVF   xDF,W
0561C:  MOVWF  FE9
0561E:  MOVF   xE0,W
05620:  MOVWF  FEA
05622:  MOVFF  FEF,2E5
05626:  MOVFF  2E5,332
0562A:  MOVLB  3
0562C:  SETF   x33
0562E:  MOVLB  0
05630:  CALL   3DC2
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
05634:  MOVLW  AC
05636:  MOVWF  FF6
05638:  MOVLW  16
0563A:  MOVWF  FF7
0563C:  MOVLW  00
0563E:  MOVWF  FF8
05640:  CALL   1BB0
05644:  GOTO   8EB0 (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
05648:  MOVLW  D0
0564A:  MOVWF  FF6
0564C:  MOVLW  16
0564E:  MOVWF  FF7
05650:  MOVLW  00
05652:  MOVWF  FF8
05654:  CALL   1BB0
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
05658:  MOVLB  2
0565A:  MOVF   xDF,W
0565C:  MOVWF  FE9
0565E:  MOVF   xE0,W
05660:  MOVWF  FEA
05662:  MOVFF  FEF,331
05666:  MOVFF  331,332
0566A:  MOVLB  3
0566C:  CLRF   x33
0566E:  MOVLB  0
05670:  CALL   3DC2
....................    FLASH_PARAM flash_param = {0};
05674:  MOVLB  2
05676:  CLRF   xE1
05678:  CLRF   xE2
0567A:  CLRF   xE3
0567C:  CLRF   xE4
0567E:  CLRF   xE5
05680:  CLRF   xE6
05682:  CLRF   xE7
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
05684:  MOVF   xDF,W
05686:  MOVWF  FE9
05688:  MOVF   xE0,W
0568A:  MOVWF  FEA
0568C:  MOVFF  FEF,2E1
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
05690:  MOVLW  01
05692:  ADDWF  xDF,W
05694:  MOVWF  FE9
05696:  MOVLW  00
05698:  ADDWFC xE0,W
0569A:  MOVWF  FEA
0569C:  MOVF   FEF,W
0569E:  MOVLB  3
056A0:  CLRF   x34
056A2:  CLRF   x33
056A4:  CLRF   x32
056A6:  MOVWF  x31
056A8:  MOVFF  331,334
056AC:  CLRF   x31
056AE:  CLRF   x32
056B0:  CLRF   x33
056B2:  MOVLW  02
056B4:  MOVLB  2
056B6:  ADDWF  xDF,W
056B8:  MOVWF  FE9
056BA:  MOVLW  00
056BC:  ADDWFC xE0,W
056BE:  MOVWF  FEA
056C0:  MOVF   FEF,W
056C2:  MOVLB  3
056C4:  CLRF   x39
056C6:  CLRF   x38
056C8:  CLRF   x37
056CA:  MOVWF  x36
056CC:  MOVFF  337,03
056D0:  MOVFF  336,02
056D4:  CLRF   00
056D6:  CLRF   01
056D8:  MOVF   00,W
056DA:  IORWF  x31,F
056DC:  MOVF   01,W
056DE:  IORWF  x32,F
056E0:  MOVF   02,W
056E2:  IORWF  x33,F
056E4:  MOVF   03,W
056E6:  IORWF  x34,F
056E8:  MOVLW  03
056EA:  MOVLB  2
056EC:  ADDWF  xDF,W
056EE:  MOVWF  FE9
056F0:  MOVLW  00
056F2:  ADDWFC xE0,W
056F4:  MOVWF  FEA
056F6:  MOVF   FEF,W
056F8:  MOVLB  3
056FA:  CLRF   x39
056FC:  CLRF   x38
056FE:  CLRF   x37
05700:  MOVWF  x36
05702:  MOVFF  338,03
05706:  MOVFF  337,02
0570A:  MOVFF  336,01
0570E:  CLRF   00
05710:  MOVF   00,W
05712:  IORWF  x31,F
05714:  MOVF   01,W
05716:  IORWF  x32,F
05718:  MOVF   02,W
0571A:  IORWF  x33,F
0571C:  MOVF   03,W
0571E:  IORWF  x34,F
05720:  MOVLW  04
05722:  MOVLB  2
05724:  ADDWF  xDF,W
05726:  MOVWF  FE9
05728:  MOVLW  00
0572A:  ADDWFC xE0,W
0572C:  MOVWF  FEA
0572E:  MOVF   FEF,W
05730:  MOVWF  00
05732:  CLRF   01
05734:  CLRF   02
05736:  CLRF   03
05738:  MOVF   00,W
0573A:  MOVLB  3
0573C:  IORWF  x31,W
0573E:  MOVLB  2
05740:  MOVWF  xE4
05742:  MOVF   01,W
05744:  MOVLB  3
05746:  IORWF  x32,W
05748:  MOVLB  2
0574A:  MOVWF  xE5
0574C:  MOVF   02,W
0574E:  MOVLB  3
05750:  IORWF  x33,W
05752:  MOVLB  2
05754:  MOVWF  xE6
05756:  MOVF   03,W
05758:  MOVLB  3
0575A:  IORWF  x34,W
0575C:  MOVLB  2
0575E:  MOVWF  xE7
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
05760:  MOVLW  07
05762:  ADDWF  xDF,W
05764:  MOVWF  FE9
05766:  MOVLW  00
05768:  ADDWFC xE0,W
0576A:  MOVWF  FEA
0576C:  MOVF   FEF,W
0576E:  MOVLB  3
05770:  CLRF   x32
05772:  MOVWF  x31
05774:  MOVFF  331,332
05778:  CLRF   x31
0577A:  MOVLW  08
0577C:  MOVLB  2
0577E:  ADDWF  xDF,W
05780:  MOVWF  FE9
05782:  MOVLW  00
05784:  ADDWFC xE0,W
05786:  MOVWF  FEA
05788:  MOVF   FEF,W
0578A:  CLRF   03
0578C:  MOVLB  3
0578E:  IORWF  x31,W
05790:  MOVLB  2
05792:  MOVWF  xE2
05794:  MOVF   03,W
05796:  MOVLB  3
05798:  IORWF  x32,W
0579A:  MOVLB  2
0579C:  MOVWF  xE3
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
0579E:  MOVLW  E4
057A0:  MOVWF  FF6
057A2:  MOVLW  16
057A4:  MOVWF  FF7
057A6:  MOVLW  00
057A8:  MOVWF  FF8
057AA:  MOVLW  0C
057AC:  MOVLB  B
057AE:  MOVWF  x1B
057B0:  MOVLB  0
057B2:  CALL   1BE0
057B6:  MOVFF  2E1,B1B
057BA:  MOVLW  37
057BC:  MOVLB  B
057BE:  MOVWF  x1C
057C0:  MOVLB  0
057C2:  CALL   1E34
057C6:  MOVLW  0D
057C8:  MOVLB  B
057CA:  MOVWF  x6E
057CC:  MOVLB  0
057CE:  CALL   1B5E
057D2:  MOVLW  0A
057D4:  MOVLB  B
057D6:  MOVWF  x6E
057D8:  MOVLB  0
057DA:  CALL   1B5E
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
057DE:  MOVLW  F8
057E0:  MOVWF  FF6
057E2:  MOVLW  16
057E4:  MOVWF  FF7
057E6:  MOVLW  00
057E8:  MOVWF  FF8
057EA:  MOVLW  0E
057EC:  MOVLB  B
057EE:  MOVWF  x1B
057F0:  MOVLB  0
057F2:  CALL   1BE0
057F6:  MOVFF  2E7,B1B
057FA:  MOVLW  37
057FC:  MOVLB  B
057FE:  MOVWF  x1C
05800:  MOVLB  0
05802:  CALL   1E34
05806:  MOVFF  2E6,B1B
0580A:  MOVLW  37
0580C:  MOVLB  B
0580E:  MOVWF  x1C
05810:  MOVLB  0
05812:  CALL   1E34
05816:  MOVFF  2E5,B1B
0581A:  MOVLW  37
0581C:  MOVLB  B
0581E:  MOVWF  x1C
05820:  MOVLB  0
05822:  CALL   1E34
05826:  MOVFF  2E4,B1B
0582A:  MOVLW  37
0582C:  MOVLB  B
0582E:  MOVWF  x1C
05830:  MOVLB  0
05832:  CALL   1E34
05836:  MOVLW  0D
05838:  MOVLB  B
0583A:  MOVWF  x6E
0583C:  MOVLB  0
0583E:  CALL   1B5E
05842:  MOVLW  0A
05844:  MOVLB  B
05846:  MOVWF  x6E
05848:  MOVLB  0
0584A:  CALL   1B5E
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
0584E:  MOVLW  0E
05850:  MOVWF  FF6
05852:  MOVLW  17
05854:  MOVWF  FF7
05856:  MOVLW  00
05858:  MOVWF  FF8
0585A:  MOVLW  0E
0585C:  MOVLB  B
0585E:  MOVWF  x1B
05860:  MOVLB  0
05862:  CALL   1BE0
05866:  MOVFF  2E3,B1B
0586A:  MOVLW  37
0586C:  MOVLB  B
0586E:  MOVWF  x1C
05870:  MOVLB  0
05872:  CALL   1E34
05876:  MOVFF  2E2,B1B
0587A:  MOVLW  37
0587C:  MOVLB  B
0587E:  MOVWF  x1C
05880:  MOVLB  0
05882:  CALL   1E34
05886:  MOVLW  0D
05888:  MOVLB  B
0588A:  MOVWF  x6E
0588C:  MOVLB  0
0588E:  CALL   1B5E
05892:  MOVLW  0A
05894:  MOVLB  B
05896:  MOVWF  x6E
05898:  MOVLB  0
0589A:  CALL   1B5E
....................    
....................    piclog_make(flash_param.id, 0x00);
0589E:  MOVFF  2E1,332
058A2:  MOVLB  3
058A4:  CLRF   x33
058A6:  MOVLB  0
058A8:  CALL   3DC2
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
058AC:  MOVLB  2
058AE:  CLRF   xE8
058B0:  CLRF   xE9
058B2:  CLRF   xEA
058B4:  CLRF   xEB
058B6:  CLRF   xEC
058B8:  CLRF   xED
058BA:  CLRF   xEE
058BC:  CLRF   xEF
058BE:  CLRF   xF0
058C0:  CLRF   xF1
058C2:  CLRF   xF2
058C4:  CLRF   xF3
058C6:  CLRF   xF4
058C8:  CLRF   xF5
058CA:  CLRF   xF6
058CC:  CLRF   xF7
058CE:  CLRF   xF8
058D0:  CLRF   xF9
058D2:  CLRF   xFA
058D4:  CLRF   xFB
058D6:  CLRF   xFC
058D8:  CLRF   xFD
058DA:  CLRF   xFE
058DC:  CLRF   xFF
058DE:  MOVLB  3
058E0:  CLRF   x00
058E2:  CLRF   x01
058E4:  CLRF   x02
058E6:  CLRF   x03
058E8:  CLRF   x04
058EA:  CLRF   x05
058EC:  CLRF   x06
058EE:  CLRF   x07
058F0:  CLRF   x08
058F2:  CLRF   x09
058F4:  CLRF   x0A
058F6:  CLRF   x0B
058F8:  CLRF   x0C
058FA:  CLRF   x0D
058FC:  CLRF   x0E
058FE:  CLRF   x0F
05900:  CLRF   x10
05902:  CLRF   x11
05904:  CLRF   x12
05906:  CLRF   x13
05908:  CLRF   x14
0590A:  CLRF   x15
0590C:  CLRF   x16
0590E:  CLRF   x17
05910:  CLRF   x18
05912:  CLRF   x19
05914:  CLRF   x1A
05916:  CLRF   x1B
05918:  CLRF   x1C
0591A:  CLRF   x1D
0591C:  CLRF   x1E
0591E:  CLRF   x1F
05920:  CLRF   x20
05922:  CLRF   x21
05924:  CLRF   x22
05926:  CLRF   x23
05928:  CLRF   x24
0592A:  CLRF   x25
0592C:  CLRF   x26
0592E:  CLRF   x27
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
05930:  MOVLW  24
05932:  MOVWF  FF6
05934:  MOVLW  17
05936:  MOVWF  FF7
05938:  MOVLW  00
0593A:  MOVWF  FF8
0593C:  MOVLB  0
0593E:  CALL   1BB0
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
05942:  MOVFF  261,3B6
05946:  MOVFF  260,3B5
0594A:  MOVFF  25F,3B4
0594E:  MOVFF  25E,3B3
05952:  CALL   26CA
05956:  MOVF   01,F
05958:  BTFSS  FD8.2
0595A:  GOTO   596E
....................       fprintf(PC, "Mission Flash is not connected\r\n");
0595E:  MOVLW  30
05960:  MOVWF  FF6
05962:  MOVLW  17
05964:  MOVWF  FF7
05966:  MOVLW  00
05968:  MOVWF  FF8
0596A:  CALL   1BB0
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
0596E:  MOVLB  3
05970:  CLRF   x2F
05972:  CLRF   x2E
05974:  CLRF   x2D
05976:  CLRF   x2C
05978:  MOVLB  0
0597A:  MOVLB  3
0597C:  MOVF   x2F,F
0597E:  BTFSC  FD8.2
05980:  BRA    5988
05982:  MOVLB  0
05984:  GOTO   5AEA
05988:  MOVLB  0
0598A:  MOVLB  3
0598C:  MOVF   x2E,F
0598E:  BTFSC  FD8.2
05990:  BRA    5998
05992:  MOVLB  0
05994:  GOTO   5AEA
05998:  MOVLB  0
0599A:  MOVLB  3
0599C:  MOVF   x2D,W
0599E:  MOVLB  2
059A0:  SUBWF  xE3,W
059A2:  BTFSC  FD8.0
059A4:  BRA    59AC
059A6:  MOVLB  0
059A8:  GOTO   5AEA
059AC:  MOVLB  0
059AE:  BTFSS  FD8.2
059B0:  GOTO   59C8
059B4:  MOVLB  2
059B6:  MOVF   xE2,W
059B8:  MOVLB  3
059BA:  SUBWF  x2C,W
059BC:  BTFSS  FD8.0
059BE:  BRA    59C6
059C0:  MOVLB  0
059C2:  GOTO   5AEA
059C6:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
059C8:  MOVLB  3
059CA:  RLCF   x2C,W
059CC:  MOVWF  00
059CE:  RLCF   x2D,W
059D0:  MOVWF  01
059D2:  RLCF   x2E,W
059D4:  MOVWF  02
059D6:  RLCF   x2F,W
059D8:  MOVWF  03
059DA:  RLCF   00,F
059DC:  RLCF   01,F
059DE:  RLCF   02,F
059E0:  RLCF   03,F
059E2:  RLCF   00,F
059E4:  RLCF   01,F
059E6:  RLCF   02,F
059E8:  RLCF   03,F
059EA:  RLCF   00,F
059EC:  RLCF   01,F
059EE:  RLCF   02,F
059F0:  RLCF   03,F
059F2:  RLCF   00,F
059F4:  RLCF   01,F
059F6:  RLCF   02,F
059F8:  RLCF   03,F
059FA:  RLCF   00,F
059FC:  RLCF   01,F
059FE:  RLCF   02,F
05A00:  RLCF   03,F
05A02:  MOVLW  C0
05A04:  ANDWF  00,F
05A06:  MOVF   00,W
05A08:  MOVLB  2
05A0A:  ADDWF  xE4,W
05A0C:  MOVLB  3
05A0E:  MOVWF  x28
05A10:  MOVF   01,W
05A12:  MOVLB  2
05A14:  ADDWFC xE5,W
05A16:  MOVLB  3
05A18:  MOVWF  x29
05A1A:  MOVF   02,W
05A1C:  MOVLB  2
05A1E:  ADDWFC xE6,W
05A20:  MOVLB  3
05A22:  MOVWF  x2A
05A24:  MOVF   03,W
05A26:  MOVLB  2
05A28:  ADDWFC xE7,W
05A2A:  MOVLB  3
05A2C:  MOVWF  x2B
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
05A2E:  MOVFF  261,438
05A32:  MOVFF  260,437
05A36:  MOVFF  25F,436
05A3A:  MOVFF  25E,435
05A3E:  MOVFF  32B,43C
05A42:  MOVFF  32A,43B
05A46:  MOVFF  329,43A
05A4A:  MOVFF  328,439
05A4E:  MOVLW  02
05A50:  MOVLB  4
05A52:  MOVWF  x3E
05A54:  MOVLW  E8
05A56:  MOVWF  x3D
05A58:  CLRF   x42
05A5A:  CLRF   x41
05A5C:  CLRF   x40
05A5E:  MOVLW  40
05A60:  MOVWF  x3F
05A62:  MOVLB  0
05A64:  CALL   2792
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
05A68:  MOVLB  3
05A6A:  CLRF   x30
05A6C:  MOVLB  0
05A6E:  MOVLB  3
05A70:  MOVF   x30,W
05A72:  SUBLW  3F
05A74:  BTFSC  FD8.0
05A76:  BRA    5A7E
05A78:  MOVLB  0
05A7A:  GOTO   5ABA
05A7E:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
05A80:  CLRF   03
05A82:  MOVLB  3
05A84:  MOVF   x30,W
05A86:  ADDLW  E8
05A88:  MOVWF  FE9
05A8A:  MOVLW  02
05A8C:  ADDWFC 03,W
05A8E:  MOVWF  FEA
05A90:  MOVFF  FEF,331
05A94:  MOVFF  331,B1B
05A98:  MOVLW  37
05A9A:  MOVLB  B
05A9C:  MOVWF  x1C
05A9E:  MOVLB  0
05AA0:  CALL   1E34
05AA4:  MOVLW  20
05AA6:  MOVLB  B
05AA8:  MOVWF  x6E
05AAA:  MOVLB  0
05AAC:  CALL   1B5E
05AB0:  MOVLB  3
05AB2:  INCF   x30,F
05AB4:  MOVLB  0
05AB6:  GOTO   5A6E
....................       }
....................       fprintf(PC,"\r\n");
05ABA:  MOVLW  0D
05ABC:  MOVLB  B
05ABE:  MOVWF  x6E
05AC0:  MOVLB  0
05AC2:  CALL   1B5E
05AC6:  MOVLW  0A
05AC8:  MOVLB  B
05ACA:  MOVWF  x6E
05ACC:  MOVLB  0
05ACE:  CALL   1B5E
05AD2:  MOVLW  01
05AD4:  MOVLB  3
05AD6:  ADDWF  x2C,F
05AD8:  BTFSC  FD8.0
05ADA:  INCF   x2D,F
05ADC:  BTFSC  FD8.2
05ADE:  INCF   x2E,F
05AE0:  BTFSC  FD8.2
05AE2:  INCF   x2F,F
05AE4:  MOVLB  0
05AE6:  GOTO   597A
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
05AEA:  MOVFF  2E1,332
05AEE:  MOVLB  3
05AF0:  SETF   x33
05AF2:  MOVLB  0
05AF4:  CALL   3DC2
....................    fprintf(PC, "End Flash Read\r\n");
05AF8:  MOVLW  52
05AFA:  MOVWF  FF6
05AFC:  MOVLW  17
05AFE:  MOVWF  FF7
05B00:  MOVLW  00
05B02:  MOVWF  FF8
05B04:  CALL   1BB0
05B08:  GOTO   8EC0 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
05B0C:  MOVLW  64
05B0E:  MOVWF  FF6
05B10:  MOVLW  17
05B12:  MOVWF  FF7
05B14:  MOVLW  00
05B16:  MOVWF  FF8
05B18:  CALL   1BB0
....................    flash_setting(mis_fm);
05B1C:  MOVFF  261,3ED
05B20:  MOVFF  260,3EC
05B24:  MOVFF  25F,3EB
05B28:  MOVFF  25E,3EA
05B2C:  CALL   55A0
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
05B30:  MOVLB  2
05B32:  CLRF   xE4
05B34:  CLRF   xE3
05B36:  CLRF   xE2
05B38:  CLRF   xE1
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
05B3A:  MOVFF  261,438
05B3E:  MOVFF  260,437
05B42:  MOVFF  25F,436
05B46:  MOVFF  25E,435
05B4A:  MOVFF  2E4,43C
05B4E:  MOVFF  2E3,43B
05B52:  MOVFF  2E2,43A
05B56:  MOVFF  2E1,439
05B5A:  MOVLW  02
05B5C:  MOVLB  4
05B5E:  MOVWF  x3E
05B60:  MOVLW  E5
05B62:  MOVWF  x3D
05B64:  CLRF   x42
05B66:  CLRF   x41
05B68:  CLRF   x40
05B6A:  MOVLW  04
05B6C:  MOVWF  x3F
05B6E:  MOVLB  0
05B70:  CALL   2792
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
05B74:  MOVLW  80
05B76:  MOVWF  FF6
05B78:  MOVLW  17
05B7A:  MOVWF  FF7
05B7C:  MOVLW  00
05B7E:  MOVWF  FF8
05B80:  MOVLW  0B
05B82:  MOVLB  B
05B84:  MOVWF  x1B
05B86:  MOVLB  0
05B88:  CALL   1BE0
05B8C:  MOVFF  2E5,B1B
05B90:  MOVLW  37
05B92:  MOVLB  B
05B94:  MOVWF  x1C
05B96:  MOVLB  0
05B98:  CALL   1E34
05B9C:  MOVLW  20
05B9E:  MOVLB  B
05BA0:  MOVWF  x6E
05BA2:  MOVLB  0
05BA4:  CALL   1B5E
05BA8:  MOVFF  2E6,B1B
05BAC:  MOVLW  37
05BAE:  MOVLB  B
05BB0:  MOVWF  x1C
05BB2:  MOVLB  0
05BB4:  CALL   1E34
05BB8:  MOVLW  20
05BBA:  MOVLB  B
05BBC:  MOVWF  x6E
05BBE:  MOVLB  0
05BC0:  CALL   1B5E
05BC4:  MOVFF  2E7,B1B
05BC8:  MOVLW  37
05BCA:  MOVLB  B
05BCC:  MOVWF  x1C
05BCE:  MOVLB  0
05BD0:  CALL   1E34
05BD4:  MOVLW  20
05BD6:  MOVLB  B
05BD8:  MOVWF  x6E
05BDA:  MOVLB  0
05BDC:  CALL   1B5E
05BE0:  MOVFF  2E8,B1B
05BE4:  MOVLW  37
05BE6:  MOVLB  B
05BE8:  MOVWF  x1C
05BEA:  MOVLB  0
05BEC:  CALL   1E34
05BF0:  MOVLW  0D
05BF2:  MOVLB  B
05BF4:  MOVWF  x6E
05BF6:  MOVLB  0
05BF8:  CALL   1B5E
05BFC:  MOVLW  0A
05BFE:  MOVLB  B
05C00:  MOVWF  x6E
05C02:  MOVLB  0
05C04:  CALL   1B5E
....................    fprintf(PC, "End Flash Read Address\r\n");
05C08:  MOVLW  A2
05C0A:  MOVWF  FF6
05C0C:  MOVLW  17
05C0E:  MOVWF  FF7
05C10:  MOVLW  00
05C12:  MOVWF  FF8
05C14:  CALL   1BB0
05C18:  GOTO   8ED0 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
05D2E:  MOVLW  BC
05D30:  MOVWF  FF6
05D32:  MOVLW  17
05D34:  MOVWF  FF7
05D36:  MOVLW  00
05D38:  MOVWF  FF8
05D3A:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05D3E:  MOVLB  2
05D40:  MOVF   xDF,W
05D42:  MOVWF  FE9
05D44:  MOVF   xE0,W
05D46:  MOVWF  FEA
05D48:  MOVFF  FEF,2E1
05D4C:  MOVFF  2E1,332
05D50:  MOVLB  3
05D52:  CLRF   x33
05D54:  MOVLB  0
05D56:  CALL   3DC2
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
05D5A:  MOVFF  2E0,2E2
05D5E:  MOVFF  2DF,2E1
05D62:  CALL   48C4
....................    mode_misf_address_reset(parameter); // Reset the address area
05D66:  MOVFF  2E0,2E2
05D6A:  MOVFF  2DF,2E1
05D6E:  GOTO   5C1C
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
05D72:  MOVLW  DA
05D74:  MOVWF  FF6
05D76:  MOVLW  17
05D78:  MOVWF  FF7
05D7A:  MOVLW  00
05D7C:  MOVWF  FF8
05D7E:  CALL   1BB0
05D82:  GOTO   8EE0 (RETURN)
.................... }
.................... 
.................... void mode_flash_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    unsigned int8 writedata[PACKET_SIZE] = {0x00}; // Initialize write data to zero
....................    
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, writedata, PACKET_SIZE);
....................    misf_init(); // Update the address area after writing
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End Flash Address Reset\r\n");
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
05D86:  MOVLW  2C
05D88:  MOVWF  FF6
05D8A:  MOVLW  18
05D8C:  MOVWF  FF7
05D8E:  MOVLW  00
05D90:  MOVWF  FF8
05D92:  CALL   1BB0
....................    flash_setting(mis_fm);
05D96:  MOVFF  261,3ED
05D9A:  MOVFF  260,3EC
05D9E:  MOVFF  25F,3EB
05DA2:  MOVFF  25E,3EA
05DA6:  CALL   55A0
....................    flash_setting(smf);
05DAA:  MOVFF  265,3ED
05DAE:  MOVFF  264,3EC
05DB2:  MOVFF  263,3EB
05DB6:  MOVFF  262,3EA
05DBA:  CALL   55A0
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
05DBE:  MOVLB  2
05DC0:  MOVF   xDF,W
05DC2:  MOVWF  FE9
05DC4:  MOVF   xE0,W
05DC6:  MOVWF  FEA
05DC8:  MOVFF  FEF,2E1
05DCC:  CLRF   xE5
05DCE:  CLRF   xE4
05DD0:  CLRF   xE3
05DD2:  CLRF   xE2
05DD4:  CLRF   xE9
05DD6:  CLRF   xE8
05DD8:  MOVLW  10
05DDA:  MOVWF  xE7
05DDC:  CLRF   xE6
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
05DDE:  MOVFF  261,438
05DE2:  MOVFF  260,437
05DE6:  MOVFF  25F,436
05DEA:  MOVFF  25E,435
05DEE:  MOVFF  2E5,43C
05DF2:  MOVFF  2E4,43B
05DF6:  MOVFF  2E3,43A
05DFA:  MOVFF  2E2,439
05DFE:  MOVLW  02
05E00:  MOVLB  4
05E02:  MOVWF  x3E
05E04:  MOVLW  EA
05E06:  MOVWF  x3D
05E08:  CLRF   x42
05E0A:  CLRF   x41
05E0C:  MOVLW  01
05E0E:  MOVWF  x40
05E10:  CLRF   x3F
05E12:  MOVLB  0
05E14:  CALL   2792
....................    write_data_bytes(smf, dest_address, read_data, 256);
05E18:  MOVFF  265,BAE
05E1C:  MOVFF  264,BAD
05E20:  MOVFF  263,BAC
05E24:  MOVFF  262,BAB
05E28:  MOVFF  2E9,BB2
05E2C:  MOVFF  2E8,BB1
05E30:  MOVFF  2E7,BB0
05E34:  MOVFF  2E6,BAF
05E38:  MOVLW  02
05E3A:  MOVLB  B
05E3C:  MOVWF  xB4
05E3E:  MOVLW  EA
05E40:  MOVWF  xB3
05E42:  MOVLW  01
05E44:  MOVWF  xB6
05E46:  CLRF   xB5
05E48:  MOVLB  0
05E4A:  CALL   367E
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
05E4E:  MOVLW  44
05E50:  MOVWF  FF6
05E52:  MOVLW  18
05E54:  MOVWF  FF7
05E56:  MOVLW  00
05E58:  MOVWF  FF8
05E5A:  CALL   1BB0
05E5E:  GOTO   8EF0 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
05E62:  MOVLW  5A
05E64:  MOVWF  FF6
05E66:  MOVLW  18
05E68:  MOVWF  FF7
05E6A:  MOVLW  00
05E6C:  MOVWF  FF8
05E6E:  CALL   1BB0
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
05E72:  MOVFF  265,438
05E76:  MOVFF  264,437
05E7A:  MOVFF  263,436
05E7E:  MOVFF  262,435
05E82:  MOVLB  4
05E84:  CLRF   x3C
05E86:  CLRF   x3B
05E88:  MOVLW  02
05E8A:  MOVWF  x3A
05E8C:  MOVLW  E1
05E8E:  MOVWF  x39
05E90:  MOVLW  02
05E92:  MOVWF  x3E
05E94:  MOVLW  E1
05E96:  MOVWF  x3D
05E98:  CLRF   x42
05E9A:  CLRF   x41
05E9C:  CLRF   x40
05E9E:  MOVLW  40
05EA0:  MOVWF  x3F
05EA2:  MOVLB  0
05EA4:  CALL   2792
....................    fprintf(PC, "Read Data: ");
05EA8:  MOVLW  72
05EAA:  MOVWF  FF6
05EAC:  MOVLW  18
05EAE:  MOVWF  FF7
05EB0:  MOVLW  00
05EB2:  MOVWF  FF8
05EB4:  CALL   1BB0
....................    for (int i = 0; i < PACKET_SIZE; i++)
05EB8:  MOVLB  3
05EBA:  CLRF   x21
05EBC:  MOVLB  0
05EBE:  MOVLB  3
05EC0:  MOVF   x21,W
05EC2:  SUBLW  3F
05EC4:  BTFSC  FD8.0
05EC6:  BRA    5ECE
05EC8:  MOVLB  0
05ECA:  GOTO   5F0A
05ECE:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
05ED0:  CLRF   03
05ED2:  MOVLB  3
05ED4:  MOVF   x21,W
05ED6:  ADDLW  E1
05ED8:  MOVWF  FE9
05EDA:  MOVLW  02
05EDC:  ADDWFC 03,W
05EDE:  MOVWF  FEA
05EE0:  MOVFF  FEF,322
05EE4:  MOVFF  322,B1B
05EE8:  MOVLW  37
05EEA:  MOVLB  B
05EEC:  MOVWF  x1C
05EEE:  MOVLB  0
05EF0:  CALL   1E34
05EF4:  MOVLW  20
05EF6:  MOVLB  B
05EF8:  MOVWF  x6E
05EFA:  MOVLB  0
05EFC:  CALL   1B5E
05F00:  MOVLB  3
05F02:  INCF   x21,F
05F04:  MOVLB  0
05F06:  GOTO   5EBE
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
05F0A:  MOVLW  7E
05F0C:  MOVWF  FF6
05F0E:  MOVLW  18
05F10:  MOVWF  FF7
05F12:  MOVLW  00
05F14:  MOVWF  FF8
05F16:  CALL   1BB0
05F1A:  GOTO   8F00 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
05F1E:  MOVLW  96
05F20:  MOVWF  FF6
05F22:  MOVLW  18
05F24:  MOVWF  FF7
05F26:  MOVLW  00
05F28:  MOVWF  FF8
05F2A:  CALL   1BB0
....................    flash_setting(smf);
05F2E:  MOVFF  265,3ED
05F32:  MOVFF  264,3EC
05F36:  MOVFF  263,3EB
05F3A:  MOVFF  262,3EA
05F3E:  CALL   55A0
....................    unsigned int32 erase_address = 0x00000000; // Example address
05F42:  MOVLB  2
05F44:  CLRF   xE4
05F46:  CLRF   xE3
05F48:  CLRF   xE2
05F4A:  CLRF   xE1
....................    sector_erase(smf, erase_address); // Erase the sector
05F4C:  MOVFF  265,328
05F50:  MOVFF  264,327
05F54:  MOVFF  263,326
05F58:  MOVFF  262,325
05F5C:  MOVFF  2E4,32C
05F60:  MOVFF  2E3,32B
05F64:  MOVFF  2E2,32A
05F68:  MOVFF  2E1,329
05F6C:  MOVLB  0
05F6E:  CALL   4568
....................    fprintf(PC, "End Flash SMF Erase\r\n");
05F72:  MOVLW  AE
05F74:  MOVWF  FF6
05F76:  MOVLW  18
05F78:  MOVWF  FF7
05F7A:  MOVLW  00
05F7C:  MOVWF  FF8
05F7E:  CALL   1BB0
05F82:  GOTO   8F10 (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
05C1C:  MOVLW  C4
05C1E:  MOVWF  FF6
05C20:  MOVLW  18
05C22:  MOVWF  FF7
05C24:  MOVLW  00
05C26:  MOVWF  FF8
05C28:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05C2C:  MOVLB  2
05C2E:  MOVF   xE1,W
05C30:  MOVWF  FE9
05C32:  MOVF   xE2,W
05C34:  MOVWF  FEA
05C36:  MOVFF  FEF,323
05C3A:  MOVFF  323,332
05C3E:  MOVLB  3
05C40:  CLRF   x33
05C42:  MOVLB  0
05C44:  CALL   3DC2
....................    unsigned int8 writedata[PACKET_SIZE] = {0x00}; // Initialize write data to zero
05C48:  MOVLB  2
05C4A:  CLRF   xE3
05C4C:  CLRF   xE4
05C4E:  CLRF   xE5
05C50:  CLRF   xE6
05C52:  CLRF   xE7
05C54:  CLRF   xE8
05C56:  CLRF   xE9
05C58:  CLRF   xEA
05C5A:  CLRF   xEB
05C5C:  CLRF   xEC
05C5E:  CLRF   xED
05C60:  CLRF   xEE
05C62:  CLRF   xEF
05C64:  CLRF   xF0
05C66:  CLRF   xF1
05C68:  CLRF   xF2
05C6A:  CLRF   xF3
05C6C:  CLRF   xF4
05C6E:  CLRF   xF5
05C70:  CLRF   xF6
05C72:  CLRF   xF7
05C74:  CLRF   xF8
05C76:  CLRF   xF9
05C78:  CLRF   xFA
05C7A:  CLRF   xFB
05C7C:  CLRF   xFC
05C7E:  CLRF   xFD
05C80:  CLRF   xFE
05C82:  CLRF   xFF
05C84:  MOVLB  3
05C86:  CLRF   x00
05C88:  CLRF   x01
05C8A:  CLRF   x02
05C8C:  CLRF   x03
05C8E:  CLRF   x04
05C90:  CLRF   x05
05C92:  CLRF   x06
05C94:  CLRF   x07
05C96:  CLRF   x08
05C98:  CLRF   x09
05C9A:  CLRF   x0A
05C9C:  CLRF   x0B
05C9E:  CLRF   x0C
05CA0:  CLRF   x0D
05CA2:  CLRF   x0E
05CA4:  CLRF   x0F
05CA6:  CLRF   x10
05CA8:  CLRF   x11
05CAA:  CLRF   x12
05CAC:  CLRF   x13
05CAE:  CLRF   x14
05CB0:  CLRF   x15
05CB2:  CLRF   x16
05CB4:  CLRF   x17
05CB6:  CLRF   x18
05CB8:  CLRF   x19
05CBA:  CLRF   x1A
05CBC:  CLRF   x1B
05CBE:  CLRF   x1C
05CC0:  CLRF   x1D
05CC2:  CLRF   x1E
05CC4:  CLRF   x1F
05CC6:  CLRF   x20
05CC8:  CLRF   x21
05CCA:  CLRF   x22
....................    
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, writedata, PACKET_SIZE);
05CCC:  MOVFF  261,BAE
05CD0:  MOVFF  260,BAD
05CD4:  MOVFF  25F,BAC
05CD8:  MOVFF  25E,BAB
05CDC:  MOVLB  B
05CDE:  CLRF   xB2
05CE0:  CLRF   xB1
05CE2:  CLRF   xB0
05CE4:  CLRF   xAF
05CE6:  MOVLW  02
05CE8:  MOVWF  xB4
05CEA:  MOVLW  E3
05CEC:  MOVWF  xB3
05CEE:  CLRF   xB6
05CF0:  MOVLW  40
05CF2:  MOVWF  xB5
05CF4:  MOVLB  0
05CF6:  CALL   367E
....................    misf_init(); // Update the address area after writing
05CFA:  CALL   2FAA
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05CFE:  MOVLB  2
05D00:  MOVF   xE1,W
05D02:  MOVWF  FE9
05D04:  MOVF   xE2,W
05D06:  MOVWF  FEA
05D08:  MOVFF  FEF,323
05D0C:  MOVFF  323,332
05D10:  MOVLB  3
05D12:  SETF   x33
05D14:  MOVLB  0
05D16:  CALL   3DC2
....................    fprintf(PC, "End Flash Address Reset\r\n");
05D1A:  MOVLW  E0
05D1C:  MOVWF  FF6
05D1E:  MOVLW  18
05D20:  MOVWF  FF7
05D22:  MOVLW  00
05D24:  MOVWF  FF8
05D26:  CALL   1BB0
05D2A:  GOTO   5D72 (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
06132:  MOVLW  01
06134:  MOVLB  2
06136:  ADDWF  xDF,W
06138:  MOVWF  FE9
0613A:  MOVLW  00
0613C:  ADDWFC xE0,W
0613E:  MOVWF  FEA
06140:  MOVF   FEF,W
06142:  MOVLB  3
06144:  CLRF   x31
06146:  CLRF   x30
06148:  CLRF   x2F
0614A:  MOVWF  x2E
0614C:  MOVFF  32E,331
06150:  CLRF   x2E
06152:  CLRF   x2F
06154:  CLRF   x30
06156:  MOVLW  02
06158:  MOVLB  2
0615A:  ADDWF  xDF,W
0615C:  MOVWF  FE9
0615E:  MOVLW  00
06160:  ADDWFC xE0,W
06162:  MOVWF  FEA
06164:  MOVF   FEF,W
06166:  MOVLB  3
06168:  CLRF   x36
0616A:  CLRF   x35
0616C:  CLRF   x34
0616E:  MOVWF  x33
06170:  MOVFF  334,03
06174:  MOVFF  333,02
06178:  CLRF   00
0617A:  CLRF   01
0617C:  MOVF   00,W
0617E:  IORWF  x2E,F
06180:  MOVF   01,W
06182:  IORWF  x2F,F
06184:  MOVF   02,W
06186:  IORWF  x30,F
06188:  MOVF   03,W
0618A:  IORWF  x31,F
0618C:  MOVLW  03
0618E:  MOVLB  2
06190:  ADDWF  xDF,W
06192:  MOVWF  FE9
06194:  MOVLW  00
06196:  ADDWFC xE0,W
06198:  MOVWF  FEA
0619A:  MOVF   FEF,W
0619C:  MOVLB  3
0619E:  CLRF   x36
061A0:  CLRF   x35
061A2:  CLRF   x34
061A4:  MOVWF  x33
061A6:  MOVFF  335,03
061AA:  MOVFF  334,02
061AE:  MOVFF  333,01
061B2:  CLRF   00
061B4:  MOVF   00,W
061B6:  IORWF  x2E,F
061B8:  MOVF   01,W
061BA:  IORWF  x2F,F
061BC:  MOVF   02,W
061BE:  IORWF  x30,F
061C0:  MOVF   03,W
061C2:  IORWF  x31,F
061C4:  MOVLW  04
061C6:  MOVLB  2
061C8:  ADDWF  xDF,W
061CA:  MOVWF  FE9
061CC:  MOVLW  00
061CE:  ADDWFC xE0,W
061D0:  MOVWF  FEA
061D2:  MOVF   FEF,W
061D4:  MOVWF  00
061D6:  CLRF   01
061D8:  CLRF   02
061DA:  CLRF   03
061DC:  MOVF   00,W
061DE:  MOVLB  3
061E0:  IORWF  x2E,W
061E2:  MOVLB  2
061E4:  MOVWF  xE1
061E6:  MOVF   01,W
061E8:  MOVLB  3
061EA:  IORWF  x2F,W
061EC:  MOVLB  2
061EE:  MOVWF  xE2
061F0:  MOVF   02,W
061F2:  MOVLB  3
061F4:  IORWF  x30,W
061F6:  MOVLB  2
061F8:  MOVWF  xE3
061FA:  MOVF   03,W
061FC:  MOVLB  3
061FE:  IORWF  x31,W
06200:  MOVLB  2
06202:  MOVWF  xE4
06204:  MOVLW  07
06206:  ADDWF  xDF,W
06208:  MOVWF  FE9
0620A:  MOVLW  00
0620C:  ADDWFC xE0,W
0620E:  MOVWF  FEA
06210:  MOVF   FEF,W
06212:  MOVLB  3
06214:  CLRF   x2F
06216:  MOVWF  x2E
06218:  MOVFF  32E,32F
0621C:  CLRF   x2E
0621E:  MOVLW  08
06220:  MOVLB  2
06222:  ADDWF  xDF,W
06224:  MOVWF  FE9
06226:  MOVLW  00
06228:  ADDWFC xE0,W
0622A:  MOVWF  FEA
0622C:  MOVF   FEF,W
0622E:  CLRF   03
06230:  MOVLB  3
06232:  IORWF  x2E,W
06234:  MOVLB  2
06236:  MOVWF  xE5
06238:  MOVF   03,W
0623A:  MOVLB  3
0623C:  IORWF  x2F,W
0623E:  MOVLB  2
06240:  MOVWF  xE6
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
06242:  CLRF   xE7
06244:  CLRF   xE8
06246:  CLRF   xE9
06248:  CLRF   xEA
0624A:  CLRF   xEB
0624C:  CLRF   xEC
0624E:  CLRF   xED
06250:  CLRF   xEE
06252:  CLRF   xEF
06254:  CLRF   xF0
06256:  CLRF   xF1
06258:  CLRF   xF2
0625A:  CLRF   xF3
0625C:  CLRF   xF4
0625E:  CLRF   xF5
06260:  CLRF   xF6
06262:  CLRF   xF7
06264:  CLRF   xF8
06266:  CLRF   xF9
06268:  CLRF   xFA
0626A:  CLRF   xFB
0626C:  CLRF   xFC
0626E:  CLRF   xFD
06270:  CLRF   xFE
06272:  CLRF   xFF
06274:  MOVLB  3
06276:  CLRF   x00
06278:  CLRF   x01
0627A:  CLRF   x02
0627C:  CLRF   x03
0627E:  CLRF   x04
06280:  CLRF   x05
06282:  CLRF   x06
06284:  CLRF   x07
06286:  CLRF   x08
06288:  CLRF   x09
0628A:  CLRF   x0A
0628C:  CLRF   x0B
0628E:  CLRF   x0C
06290:  CLRF   x0D
06292:  CLRF   x0E
06294:  CLRF   x0F
06296:  CLRF   x10
06298:  CLRF   x11
0629A:  CLRF   x12
0629C:  CLRF   x13
0629E:  CLRF   x14
062A0:  CLRF   x15
062A2:  CLRF   x16
062A4:  CLRF   x17
062A6:  CLRF   x18
062A8:  CLRF   x19
062AA:  CLRF   x1A
062AC:  CLRF   x1B
062AE:  CLRF   x1C
062B0:  CLRF   x1D
062B2:  CLRF   x1E
062B4:  CLRF   x1F
062B6:  CLRF   x20
062B8:  CLRF   x21
062BA:  CLRF   x22
062BC:  CLRF   x23
062BE:  CLRF   x24
062C0:  CLRF   x25
062C2:  CLRF   x26
....................    if(!is_connect(smf)) {
062C4:  MOVFF  265,3B6
062C8:  MOVFF  264,3B5
062CC:  MOVFF  263,3B4
062D0:  MOVFF  262,3B3
062D4:  MOVLB  0
062D6:  CALL   26CA
062DA:  MOVF   01,F
062DC:  BTFSS  FD8.2
062DE:  GOTO   62F6
....................       printf("SMF is not connected\r\n");
062E2:  MOVLW  FA
062E4:  MOVWF  FF6
062E6:  MOVLW  18
062E8:  MOVWF  FF7
062EA:  MOVLW  00
062EC:  MOVWF  FF8
062EE:  CALL   1BB0
....................       return;
062F2:  GOTO   6552
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
062F6:  MOVLW  12
062F8:  MOVWF  FF6
062FA:  MOVLW  19
062FC:  MOVWF  FF7
062FE:  MOVLW  00
06300:  MOVWF  FF8
06302:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
06306:  MOVLB  2
06308:  MOVF   xDF,W
0630A:  MOVWF  FE9
0630C:  MOVF   xE0,W
0630E:  MOVWF  FEA
06310:  MOVFF  FEF,32E
06314:  MOVFF  32E,332
06318:  MOVLB  3
0631A:  CLRF   x33
0631C:  MOVLB  0
0631E:  CALL   3DC2
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
06322:  MOVLW  30
06324:  MOVWF  FF6
06326:  MOVLW  19
06328:  MOVWF  FF7
0632A:  MOVLW  00
0632C:  MOVWF  FF8
0632E:  MOVLW  0E
06330:  MOVLB  B
06332:  MOVWF  x1B
06334:  MOVLB  0
06336:  CALL   1BE0
0633A:  MOVFF  2E4,B1B
0633E:  MOVLW  37
06340:  MOVLB  B
06342:  MOVWF  x1C
06344:  MOVLB  0
06346:  CALL   1E34
0634A:  MOVFF  2E3,B1B
0634E:  MOVLW  37
06350:  MOVLB  B
06352:  MOVWF  x1C
06354:  MOVLB  0
06356:  CALL   1E34
0635A:  MOVFF  2E2,B1B
0635E:  MOVLW  37
06360:  MOVLB  B
06362:  MOVWF  x1C
06364:  MOVLB  0
06366:  CALL   1E34
0636A:  MOVFF  2E1,B1B
0636E:  MOVLW  37
06370:  MOVLB  B
06372:  MOVWF  x1C
06374:  MOVLB  0
06376:  CALL   1E34
0637A:  MOVLW  0D
0637C:  MOVLB  B
0637E:  MOVWF  x6E
06380:  MOVLB  0
06382:  CALL   1B5E
06386:  MOVLW  0A
06388:  MOVLB  B
0638A:  MOVWF  x6E
0638C:  MOVLB  0
0638E:  CALL   1B5E
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
06392:  MOVLW  46
06394:  MOVWF  FF6
06396:  MOVLW  19
06398:  MOVWF  FF7
0639A:  MOVLW  00
0639C:  MOVWF  FF8
0639E:  MOVLW  0E
063A0:  MOVLB  B
063A2:  MOVWF  x1B
063A4:  MOVLB  0
063A6:  CALL   1BE0
063AA:  MOVFF  2E6,B1B
063AE:  MOVLW  37
063B0:  MOVLB  B
063B2:  MOVWF  x1C
063B4:  MOVLB  0
063B6:  CALL   1E34
063BA:  MOVFF  2E5,B1B
063BE:  MOVLW  37
063C0:  MOVLB  B
063C2:  MOVWF  x1C
063C4:  MOVLB  0
063C6:  CALL   1E34
063CA:  MOVLW  0D
063CC:  MOVLB  B
063CE:  MOVWF  x6E
063D0:  MOVLB  0
063D2:  CALL   1B5E
063D6:  MOVLW  0A
063D8:  MOVLB  B
063DA:  MOVWF  x6E
063DC:  MOVLB  0
063DE:  CALL   1B5E
....................    printf("read data\r\n");
063E2:  MOVLW  5C
063E4:  MOVWF  FF6
063E6:  MOVLW  19
063E8:  MOVWF  FF7
063EA:  MOVLW  00
063EC:  MOVWF  FF8
063EE:  CALL   1BB0
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
063F2:  MOVLB  3
063F4:  CLRF   x28
063F6:  CLRF   x27
063F8:  MOVLB  0
063FA:  MOVLB  3
063FC:  MOVF   x28,W
063FE:  MOVLB  2
06400:  SUBWF  xE6,W
06402:  BTFSC  FD8.0
06404:  BRA    640C
06406:  MOVLB  0
06408:  GOTO   6526
0640C:  MOVLB  0
0640E:  BTFSS  FD8.2
06410:  GOTO   6428
06414:  MOVLB  2
06416:  MOVF   xE5,W
06418:  MOVLB  3
0641A:  SUBWF  x27,W
0641C:  BTFSS  FD8.0
0641E:  BRA    6426
06420:  MOVLB  0
06422:  GOTO   6526
06426:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
06428:  MOVLB  3
0642A:  RLCF   x27,W
0642C:  MOVWF  02
0642E:  RLCF   x28,W
06430:  MOVWF  03
06432:  RLCF   02,F
06434:  RLCF   03,F
06436:  RLCF   02,F
06438:  RLCF   03,F
0643A:  RLCF   02,F
0643C:  RLCF   03,F
0643E:  RLCF   02,F
06440:  RLCF   03,F
06442:  RLCF   02,F
06444:  RLCF   03,F
06446:  MOVLW  C0
06448:  ANDWF  02,F
0644A:  MOVF   02,W
0644C:  MOVLB  2
0644E:  ADDWF  xE1,W
06450:  MOVLB  3
06452:  MOVWF  x29
06454:  MOVF   03,W
06456:  MOVLB  2
06458:  ADDWFC xE2,W
0645A:  MOVLB  3
0645C:  MOVWF  x2A
0645E:  MOVLW  00
06460:  MOVLB  2
06462:  ADDWFC xE3,W
06464:  MOVLB  3
06466:  MOVWF  x2B
06468:  MOVLW  00
0646A:  MOVLB  2
0646C:  ADDWFC xE4,W
0646E:  MOVLB  3
06470:  MOVWF  x2C
06472:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
06474:  MOVFF  265,438
06478:  MOVFF  264,437
0647C:  MOVFF  263,436
06480:  MOVFF  262,435
06484:  MOVFF  32C,43C
06488:  MOVFF  32B,43B
0648C:  MOVFF  32A,43A
06490:  MOVFF  329,439
06494:  MOVLW  02
06496:  MOVLB  4
06498:  MOVWF  x3E
0649A:  MOVLW  E7
0649C:  MOVWF  x3D
0649E:  CLRF   x42
064A0:  CLRF   x41
064A2:  CLRF   x40
064A4:  MOVLW  40
064A6:  MOVWF  x3F
064A8:  MOVLB  0
064AA:  CALL   2792
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
064AE:  MOVLB  3
064B0:  CLRF   x2D
064B2:  MOVLB  0
064B4:  MOVLB  3
064B6:  MOVF   x2D,W
064B8:  SUBLW  3F
064BA:  BTFSC  FD8.0
064BC:  BRA    64C4
064BE:  MOVLB  0
064C0:  GOTO   6500
064C4:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
064C6:  CLRF   03
064C8:  MOVLB  3
064CA:  MOVF   x2D,W
064CC:  ADDLW  E7
064CE:  MOVWF  FE9
064D0:  MOVLW  02
064D2:  ADDWFC 03,W
064D4:  MOVWF  FEA
064D6:  MOVFF  FEF,32E
064DA:  MOVFF  32E,B1B
064DE:  MOVLW  37
064E0:  MOVLB  B
064E2:  MOVWF  x1C
064E4:  MOVLB  0
064E6:  CALL   1E34
064EA:  MOVLW  20
064EC:  MOVLB  B
064EE:  MOVWF  x6E
064F0:  MOVLB  0
064F2:  CALL   1B5E
064F6:  MOVLB  3
064F8:  INCF   x2D,F
064FA:  MOVLB  0
064FC:  GOTO   64B4
....................       }
....................       printf("\r\n");
06500:  MOVLW  0D
06502:  MOVLB  B
06504:  MOVWF  x6E
06506:  MOVLB  0
06508:  CALL   1B5E
0650C:  MOVLW  0A
0650E:  MOVLB  B
06510:  MOVWF  x6E
06512:  MOVLB  0
06514:  CALL   1B5E
06518:  MOVLB  3
0651A:  INCF   x27,F
0651C:  BTFSC  FD8.2
0651E:  INCF   x28,F
06520:  MOVLB  0
06522:  GOTO   63FA
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
06526:  MOVLW  68
06528:  MOVWF  FF6
0652A:  MOVLW  19
0652C:  MOVWF  FF7
0652E:  MOVLW  00
06530:  MOVWF  FF8
06532:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06536:  MOVLB  2
06538:  MOVF   xDF,W
0653A:  MOVWF  FE9
0653C:  MOVF   xE0,W
0653E:  MOVWF  FEA
06540:  MOVFF  FEF,32E
06544:  MOVFF  32E,332
06548:  MOVLB  3
0654A:  SETF   x33
0654C:  MOVLB  0
0654E:  CALL   3DC2
06552:  GOTO   8F30 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
06556:  MOVLW  86
06558:  MOVWF  FF6
0655A:  MOVLW  19
0655C:  MOVWF  FF7
0655E:  MOVLW  00
06560:  MOVWF  FF8
06562:  CALL   1BB0
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
06566:  MOVLB  2
06568:  MOVF   xDF,W
0656A:  MOVWF  FE9
0656C:  MOVF   xE0,W
0656E:  MOVWF  FEA
06570:  MOVFF  FEF,2E1
....................    piclog_make(cmd, 0x00); // Log the command execution
06574:  MOVFF  2E1,332
06578:  MOVLB  3
0657A:  CLRF   x33
0657C:  MOVLB  0
0657E:  CALL   3DC2
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
06582:  MOVLW  06
06584:  MOVLB  2
06586:  MOVWF  xE5
06588:  MOVLW  AA
0658A:  MOVWF  xE4
0658C:  CLRF   xE3
0658E:  CLRF   xE2
06590:  MOVLB  0
06592:  MOVLB  2
06594:  MOVF   xE5,W
06596:  SUBLW  07
06598:  BTFSC  FD8.0
0659A:  BRA    65A2
0659C:  MOVLB  0
0659E:  GOTO   6620
065A2:  MOVLB  0
065A4:  BTFSS  FD8.2
065A6:  GOTO   65EC
065AA:  MOVLB  2
065AC:  MOVF   xE4,W
065AE:  SUBLW  AA
065B0:  BTFSC  FD8.0
065B2:  BRA    65BA
065B4:  MOVLB  0
065B6:  GOTO   6620
065BA:  MOVLB  0
065BC:  BTFSS  FD8.2
065BE:  GOTO   65EC
065C2:  MOVLB  2
065C4:  MOVF   xE3,W
065C6:  SUBLW  1F
065C8:  BTFSC  FD8.0
065CA:  BRA    65D2
065CC:  MOVLB  0
065CE:  GOTO   6620
065D2:  MOVLB  0
065D4:  BTFSS  FD8.2
065D6:  GOTO   65EC
065DA:  MOVLB  2
065DC:  MOVF   xE2,W
065DE:  SUBLW  FE
065E0:  BTFSC  FD8.0
065E2:  BRA    65EA
065E4:  MOVLB  0
065E6:  GOTO   6620
065EA:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
065EC:  MOVFF  265,328
065F0:  MOVFF  264,327
065F4:  MOVFF  263,326
065F8:  MOVFF  262,325
065FC:  MOVFF  2E5,32C
06600:  MOVFF  2E4,32B
06604:  MOVFF  2E3,32A
06608:  MOVFF  2E2,329
0660C:  CALL   4568
06610:  MOVLW  01
06612:  MOVLB  2
06614:  ADDWF  xE4,F
06616:  MOVLW  00
06618:  ADDWFC xE5,F
0661A:  MOVLB  0
0661C:  GOTO   6592
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
06620:  MOVFF  2E1,332
06624:  MOVLB  3
06626:  SETF   x33
06628:  MOVLB  0
0662A:  CALL   3DC2
....................    printf("End SMF Erase All\r\n");
0662E:  MOVLW  9C
06630:  MOVWF  FF6
06632:  MOVLW  19
06634:  MOVWF  FF7
06636:  MOVLW  00
06638:  MOVWF  FF8
0663A:  CALL   1BB0
0663E:  GOTO   8F40 (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
05F86:  MOVLW  B0
05F88:  MOVWF  FF6
05F8A:  MOVLW  19
05F8C:  MOVWF  FF7
05F8E:  MOVLW  00
05F90:  MOVWF  FF8
05F92:  CALL   1BB0
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
05F96:  MOVLB  2
05F98:  MOVF   xDF,W
05F9A:  MOVWF  FE9
05F9C:  MOVF   xE0,W
05F9E:  MOVWF  FEA
05FA0:  MOVFF  FEF,325
05FA4:  MOVFF  325,332
05FA8:  MOVLB  3
05FAA:  CLRF   x33
05FAC:  MOVLB  0
05FAE:  CALL   3DC2
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
05FB2:  MOVLB  2
05FB4:  CLRF   xE1
05FB6:  CLRF   xE2
05FB8:  CLRF   xE3
05FBA:  CLRF   xE4
05FBC:  CLRF   xE5
05FBE:  CLRF   xE6
05FC0:  CLRF   xE7
05FC2:  CLRF   xE8
05FC4:  CLRF   xE9
05FC6:  CLRF   xEA
05FC8:  CLRF   xEB
05FCA:  CLRF   xEC
05FCC:  CLRF   xED
05FCE:  CLRF   xEE
05FD0:  CLRF   xEF
05FD2:  CLRF   xF0
05FD4:  CLRF   xF1
05FD6:  CLRF   xF2
05FD8:  CLRF   xF3
05FDA:  CLRF   xF4
05FDC:  CLRF   xF5
05FDE:  CLRF   xF6
05FE0:  CLRF   xF7
05FE2:  CLRF   xF8
05FE4:  CLRF   xF9
05FE6:  CLRF   xFA
05FE8:  CLRF   xFB
05FEA:  CLRF   xFC
05FEC:  CLRF   xFD
05FEE:  CLRF   xFE
05FF0:  CLRF   xFF
05FF2:  MOVLB  3
05FF4:  CLRF   x00
05FF6:  CLRF   x01
05FF8:  CLRF   x02
05FFA:  CLRF   x03
05FFC:  CLRF   x04
05FFE:  CLRF   x05
06000:  CLRF   x06
06002:  CLRF   x07
06004:  CLRF   x08
06006:  CLRF   x09
06008:  CLRF   x0A
0600A:  CLRF   x0B
0600C:  CLRF   x0C
0600E:  CLRF   x0D
06010:  CLRF   x0E
06012:  CLRF   x0F
06014:  CLRF   x10
06016:  CLRF   x11
06018:  CLRF   x12
0601A:  CLRF   x13
0601C:  CLRF   x14
0601E:  CLRF   x15
06020:  CLRF   x16
06022:  CLRF   x17
06024:  CLRF   x18
06026:  CLRF   x19
06028:  CLRF   x1A
0602A:  CLRF   x1B
0602C:  CLRF   x1C
0602E:  CLRF   x1D
06030:  CLRF   x1E
06032:  CLRF   x1F
06034:  CLRF   x20
....................    for (int32 address = 0x04EC0000; address < 0x056BFFFF; address += SECTOR_64K_BYTE) {
06036:  MOVLW  04
06038:  MOVWF  x24
0603A:  MOVLW  EC
0603C:  MOVWF  x23
0603E:  CLRF   x22
06040:  CLRF   x21
06042:  MOVLB  0
06044:  MOVLB  3
06046:  MOVF   x24,W
06048:  SUBLW  05
0604A:  BTFSC  FD8.0
0604C:  BRA    6054
0604E:  MOVLB  0
06050:  GOTO   60D2
06054:  MOVLB  0
06056:  BTFSS  FD8.2
06058:  GOTO   609E
0605C:  MOVLB  3
0605E:  MOVF   x23,W
06060:  SUBLW  6B
06062:  BTFSC  FD8.0
06064:  BRA    606C
06066:  MOVLB  0
06068:  GOTO   60D2
0606C:  MOVLB  0
0606E:  BTFSS  FD8.2
06070:  GOTO   609E
06074:  MOVLB  3
06076:  MOVF   x22,W
06078:  SUBLW  FF
0607A:  BTFSC  FD8.0
0607C:  BRA    6084
0607E:  MOVLB  0
06080:  GOTO   60D2
06084:  MOVLB  0
06086:  BTFSS  FD8.2
06088:  GOTO   609E
0608C:  MOVLB  3
0608E:  MOVF   x21,W
06090:  SUBLW  FE
06092:  BTFSC  FD8.0
06094:  BRA    609C
06096:  MOVLB  0
06098:  GOTO   60D2
0609C:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
0609E:  MOVFF  265,328
060A2:  MOVFF  264,327
060A6:  MOVFF  263,326
060AA:  MOVFF  262,325
060AE:  MOVFF  324,32C
060B2:  MOVFF  323,32B
060B6:  MOVFF  322,32A
060BA:  MOVFF  321,329
060BE:  CALL   4568
060C2:  MOVLW  01
060C4:  MOVLB  3
060C6:  ADDWF  x23,F
060C8:  MOVLW  00
060CA:  ADDWFC x24,F
060CC:  MOVLB  0
060CE:  GOTO   6044
....................    }
.................... 
....................    write_data_bytes(smf, 0x04EC0000, writedata, PACKET_SIZE);
060D2:  MOVFF  265,BAE
060D6:  MOVFF  264,BAD
060DA:  MOVFF  263,BAC
060DE:  MOVFF  262,BAB
060E2:  MOVLW  04
060E4:  MOVLB  B
060E6:  MOVWF  xB2
060E8:  MOVLW  EC
060EA:  MOVWF  xB1
060EC:  CLRF   xB0
060EE:  CLRF   xAF
060F0:  MOVLW  02
060F2:  MOVWF  xB4
060F4:  MOVLW  E1
060F6:  MOVWF  xB3
060F8:  CLRF   xB6
060FA:  MOVLW  40
060FC:  MOVWF  xB5
060FE:  MOVLB  0
06100:  CALL   367E
....................    //smf_init(); // Update the address area after writing
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06104:  MOVLB  2
06106:  MOVF   xDF,W
06108:  MOVWF  FE9
0610A:  MOVF   xE0,W
0610C:  MOVWF  FEA
0610E:  MOVFF  FEF,325
06112:  MOVFF  325,332
06116:  MOVLB  3
06118:  SETF   x33
0611A:  MOVLB  0
0611C:  CALL   3DC2
....................    printf("End SMF Reset\r\n");
06120:  MOVLW  C2
06122:  MOVWF  FF6
06124:  MOVLW  19
06126:  MOVWF  FF7
06128:  MOVLW  00
0612A:  MOVWF  FF8
0612C:  CALL   1BB0
06130:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0AE10:  CLRF   FF8
0AE12:  BCF    FD0.7
0AE14:  BSF    07.7
0AE16:  MOVLB  E
0AE18:  MOVLW  55
0AE1A:  MOVWF  F7E
0AE1C:  MOVLW  AA
0AE1E:  MOVWF  F7E
0AE20:  BCF    F66.6
0AE22:  MOVLW  F9
0AE24:  MOVWF  x2C
0AE26:  MOVLW  0F
0AE28:  MOVWF  x2E
0AE2A:  MOVLW  40
0AE2C:  MOVWF  x12
0AE2E:  MOVLW  30
0AE30:  MOVWF  x13
0AE32:  MOVLW  20
0AE34:  MOVWF  x22
0AE36:  MOVLW  55
0AE38:  MOVWF  F7E
0AE3A:  MOVLW  AA
0AE3C:  MOVWF  F7E
0AE3E:  BSF    F66.6
0AE40:  CLRF   F9B
0AE42:  CLRF   F64
0AE44:  CLRF   F65
0AE46:  CLRF   F66
0AE48:  MOVLW  02
0AE4A:  MOVWF  FD3
0AE4C:  CLRF   1B
0AE4E:  MOVLB  F
0AE50:  BSF    x2D.3
0AE52:  MOVLW  A0
0AE54:  MOVWF  x2B
0AE56:  MOVLW  01
0AE58:  MOVWF  x2C
0AE5A:  MOVLW  A6
0AE5C:  MOVWF  x2E
0AE5E:  MOVLW  90
0AE60:  MOVWF  x2F
0AE62:  BCF    F93.6
0AE64:  BSF    F8A.6
0AE66:  BSF    F92.1
0AE68:  BCF    F92.0
0AE6A:  BCF    F92.3
0AE6C:  BCF    F89.3
0AE6E:  BSF    F96.0
0AE70:  BCF    F96.6
0AE72:  BCF    F96.1
0AE74:  BCF    F8D.1
0AE76:  BSF    F93.4
0AE78:  BCF    F93.5
0AE7A:  BCF    F93.2
0AE7C:  BSF    F8A.2
0AE7E:  CLRF   1F
0AE80:  CLRF   1E
0AE82:  CLRF   1D
0AE84:  CLRF   1C
0AE86:  CLRF   23
0AE88:  CLRF   22
0AE8A:  CLRF   21
0AE8C:  CLRF   20
0AE8E:  CLRF   25
0AE90:  CLRF   24
0AE92:  CLRF   46
0AE94:  BCF    47.0
0AE96:  MOVLW  1E
0AE98:  MOVLB  2
0AE9A:  MOVWF  x9E
0AE9C:  CLRF   xA0
0AE9E:  CLRF   x9F
0AEA0:  MOVLB  E
0AEA2:  CLRF   xD9
0AEA4:  CLRF   xDA
0AEA6:  CLRF   xCE
0AEA8:  CLRF   xCF
0AEAA:  CLRF   xD0
0AEAC:  CLRF   xD1
0AEAE:  CLRF   xD2
0AEB0:  CLRF   xD3
0AEB2:  CLRF   xD4
0AEB4:  CLRF   xD5
0AEB6:  CLRF   x45
0AEB8:  CLRF   x46
0AEBA:  CLRF   x47
0AEBC:  BCF    x8D.7
0AEBE:  BCF    x8D.6
0AEC0:  BCF    x8D.5
0AEC2:  MOVLB  F
0AEC4:  CLRF   x53
0AEC6:  CLRF   x38
0AEC8:  CLRF   x37
0AECA:  MOVLB  0
0AECC:  CLRF   26
0AECE:  CLRF   27
0AED0:  CLRF   28
0AED2:  CLRF   29
0AED4:  CLRF   2A
0AED6:  CLRF   2B
0AED8:  CLRF   2C
0AEDA:  CLRF   2D
0AEDC:  CLRF   2E
0AEDE:  CLRF   2F
0AEE0:  CLRF   30
0AEE2:  CLRF   31
0AEE4:  CLRF   32
0AEE6:  CLRF   33
0AEE8:  CLRF   34
0AEEA:  CLRF   35
0AEEC:  CLRF   36
0AEEE:  CLRF   37
0AEF0:  CLRF   38
0AEF2:  CLRF   39
0AEF4:  CLRF   3A
0AEF6:  CLRF   3B
0AEF8:  CLRF   3C
0AEFA:  CLRF   3D
0AEFC:  CLRF   3E
0AEFE:  CLRF   3F
0AF00:  CLRF   40
0AF02:  CLRF   41
0AF04:  CLRF   42
0AF06:  CLRF   43
0AF08:  CLRF   44
0AF0A:  CLRF   45
0AF0C:  MOVLW  03
0AF0E:  MOVWF  48
0AF10:  CLRF   49
0AF12:  CLRF   4A
0AF14:  CLRF   4B
0AF16:  CLRF   4C
0AF18:  CLRF   4D
0AF1A:  CLRF   4E
0AF1C:  CLRF   4F
0AF1E:  CLRF   50
0AF20:  CLRF   51
0AF22:  CLRF   52
0AF24:  CLRF   53
0AF26:  CLRF   54
0AF28:  CLRF   55
0AF2A:  CLRF   56
0AF2C:  CLRF   57
0AF2E:  CLRF   58
0AF30:  CLRF   59
0AF32:  CLRF   5A
0AF34:  CLRF   5B
0AF36:  CLRF   5C
0AF38:  CLRF   5D
0AF3A:  CLRF   5E
0AF3C:  CLRF   5F
0AF3E:  CLRF   x60
0AF40:  CLRF   x61
0AF42:  CLRF   x62
0AF44:  CLRF   x63
0AF46:  CLRF   x64
0AF48:  CLRF   x65
0AF4A:  CLRF   x66
0AF4C:  CLRF   x67
0AF4E:  CLRF   x68
0AF50:  CLRF   x69
0AF52:  CLRF   x6A
0AF54:  CLRF   x6B
0AF56:  CLRF   x6C
0AF58:  CLRF   x6D
0AF5A:  CLRF   x6E
0AF5C:  CLRF   x6F
0AF5E:  CLRF   x70
0AF60:  CLRF   x71
0AF62:  CLRF   x72
0AF64:  CLRF   x73
0AF66:  CLRF   x74
0AF68:  CLRF   x75
0AF6A:  CLRF   x76
0AF6C:  CLRF   x77
0AF6E:  CLRF   x78
0AF70:  CLRF   x79
0AF72:  CLRF   x7A
0AF74:  CLRF   x7B
0AF76:  CLRF   x7C
0AF78:  CLRF   x7D
0AF7A:  CLRF   x7E
0AF7C:  CLRF   x7F
0AF7E:  CLRF   x80
0AF80:  CLRF   x81
0AF82:  CLRF   x82
0AF84:  CLRF   x83
0AF86:  CLRF   x84
0AF88:  CLRF   x85
0AF8A:  CLRF   x86
0AF8C:  CLRF   x87
0AF8E:  CLRF   x88
0AF90:  CLRF   x89
0AF92:  CLRF   x8A
0AF94:  CLRF   x8B
0AF96:  CLRF   x8C
0AF98:  CLRF   x8D
0AF9A:  CLRF   x8E
0AF9C:  CLRF   x8F
0AF9E:  CLRF   x90
0AFA0:  CLRF   x91
0AFA2:  CLRF   x92
0AFA4:  CLRF   x93
0AFA6:  CLRF   x94
0AFA8:  CLRF   x95
0AFAA:  CLRF   x96
0AFAC:  CLRF   x97
0AFAE:  CLRF   x98
0AFB0:  CLRF   x99
0AFB2:  CLRF   x9A
0AFB4:  CLRF   x9B
0AFB6:  CLRF   x9C
0AFB8:  CLRF   x9D
0AFBA:  CLRF   x9E
0AFBC:  CLRF   x9F
0AFBE:  CLRF   xA0
0AFC0:  CLRF   xA1
0AFC2:  CLRF   xA2
0AFC4:  CLRF   xA3
0AFC6:  CLRF   xA4
0AFC8:  CLRF   xA5
0AFCA:  CLRF   xA6
0AFCC:  CLRF   xA7
0AFCE:  CLRF   xA8
0AFD0:  CLRF   xA9
0AFD2:  CLRF   xAA
0AFD4:  CLRF   xAB
0AFD6:  CLRF   xAC
0AFD8:  CLRF   xAD
0AFDA:  CLRF   xAE
0AFDC:  CLRF   xAF
0AFDE:  CLRF   xB0
0AFE0:  CLRF   xB1
0AFE2:  CLRF   xB2
0AFE4:  CLRF   xB3
0AFE6:  CLRF   xB4
0AFE8:  CLRF   xB5
0AFEA:  CLRF   xB6
0AFEC:  CLRF   xB7
0AFEE:  CLRF   xB8
0AFF0:  CLRF   xB9
0AFF2:  CLRF   xBA
0AFF4:  CLRF   xBB
0AFF6:  CLRF   xBC
0AFF8:  CLRF   xBD
0AFFA:  CLRF   xBE
0AFFC:  CLRF   xBF
0AFFE:  CLRF   xC0
0B000:  CLRF   xC1
0B002:  CLRF   xC2
0B004:  CLRF   xC3
0B006:  CLRF   xC4
0B008:  CLRF   xC5
0B00A:  CLRF   xC6
0B00C:  CLRF   xC7
0B00E:  CLRF   xC8
0B010:  CLRF   xC9
0B012:  CLRF   xCA
0B014:  CLRF   xCB
0B016:  CLRF   xCC
0B018:  CLRF   xCD
0B01A:  CLRF   xCE
0B01C:  CLRF   xCF
0B01E:  CLRF   xD0
0B020:  CLRF   xD1
0B022:  CLRF   xD2
0B024:  CLRF   xD3
0B026:  CLRF   xD4
0B028:  CLRF   xD5
0B02A:  CLRF   xD6
0B02C:  CLRF   xD7
0B02E:  CLRF   xD8
0B030:  CLRF   xD9
0B032:  CLRF   xDA
0B034:  CLRF   xDB
0B036:  CLRF   xDC
0B038:  CLRF   xDD
0B03A:  CLRF   xDE
0B03C:  CLRF   xDF
0B03E:  CLRF   xE0
0B040:  CLRF   xE1
0B042:  CLRF   xE2
0B044:  CLRF   xE3
0B046:  CLRF   xE4
0B048:  CLRF   xE5
0B04A:  CLRF   xE6
0B04C:  CLRF   xE7
0B04E:  CLRF   xE8
0B050:  CLRF   xE9
0B052:  CLRF   xEA
0B054:  CLRF   xEB
0B056:  CLRF   xEC
0B058:  CLRF   xED
0B05A:  CLRF   xEE
0B05C:  CLRF   xEF
0B05E:  CLRF   xF0
0B060:  CLRF   xF1
0B062:  CLRF   xF2
0B064:  CLRF   xF3
0B066:  CLRF   xF4
0B068:  CLRF   xF5
0B06A:  CLRF   xF6
0B06C:  CLRF   xF7
0B06E:  CLRF   xF8
0B070:  CLRF   xF9
0B072:  CLRF   xFA
0B074:  CLRF   xFB
0B076:  CLRF   xFC
0B078:  CLRF   xFD
0B07A:  CLRF   xFE
0B07C:  CLRF   xFF
0B07E:  MOVLB  1
0B080:  CLRF   x00
0B082:  CLRF   x01
0B084:  CLRF   x02
0B086:  CLRF   x03
0B088:  CLRF   x04
0B08A:  CLRF   x05
0B08C:  CLRF   x06
0B08E:  CLRF   x07
0B090:  CLRF   x08
0B092:  CLRF   x09
0B094:  CLRF   x0A
0B096:  CLRF   x0B
0B098:  CLRF   x0C
0B09A:  CLRF   x0D
0B09C:  CLRF   x0E
0B09E:  CLRF   x0F
0B0A0:  CLRF   x10
0B0A2:  CLRF   x11
0B0A4:  CLRF   x12
0B0A6:  CLRF   x13
0B0A8:  CLRF   x14
0B0AA:  CLRF   x15
0B0AC:  CLRF   x16
0B0AE:  CLRF   x17
0B0B0:  CLRF   x18
0B0B2:  CLRF   x19
0B0B4:  CLRF   x1A
0B0B6:  CLRF   x1B
0B0B8:  CLRF   x1C
0B0BA:  CLRF   x1D
0B0BC:  CLRF   x1E
0B0BE:  CLRF   x1F
0B0C0:  CLRF   x20
0B0C2:  CLRF   x21
0B0C4:  CLRF   x22
0B0C6:  CLRF   x23
0B0C8:  CLRF   x24
0B0CA:  CLRF   x25
0B0CC:  CLRF   x26
0B0CE:  CLRF   x27
0B0D0:  CLRF   x28
0B0D2:  CLRF   x29
0B0D4:  CLRF   x2A
0B0D6:  CLRF   x2B
0B0D8:  CLRF   x2C
0B0DA:  CLRF   x2D
0B0DC:  CLRF   x2E
0B0DE:  CLRF   x2F
0B0E0:  CLRF   x30
0B0E2:  CLRF   x31
0B0E4:  CLRF   x32
0B0E6:  CLRF   x33
0B0E8:  CLRF   x34
0B0EA:  CLRF   x35
0B0EC:  CLRF   x36
0B0EE:  CLRF   x37
0B0F0:  CLRF   x38
0B0F2:  CLRF   x39
0B0F4:  CLRF   x3A
0B0F6:  CLRF   x3B
0B0F8:  CLRF   x3C
0B0FA:  CLRF   x3D
0B0FC:  CLRF   x3E
0B0FE:  CLRF   x3F
0B100:  CLRF   x40
0B102:  CLRF   x41
0B104:  CLRF   x42
0B106:  CLRF   x43
0B108:  CLRF   x44
0B10A:  CLRF   x45
0B10C:  CLRF   x46
0B10E:  CLRF   x47
0B110:  CLRF   x48
0B112:  CLRF   x49
0B114:  CLRF   x4A
0B116:  CLRF   x4B
0B118:  CLRF   x4C
0B11A:  CLRF   x4D
0B11C:  CLRF   x4E
0B11E:  CLRF   x4F
0B120:  CLRF   x50
0B122:  CLRF   x51
0B124:  CLRF   x52
0B126:  CLRF   x53
0B128:  CLRF   x54
0B12A:  CLRF   x55
0B12C:  CLRF   x56
0B12E:  CLRF   x57
0B130:  CLRF   x58
0B132:  CLRF   x59
0B134:  CLRF   x5A
0B136:  CLRF   x5B
0B138:  CLRF   x5C
0B13A:  CLRF   x5D
0B13C:  CLRF   x5E
0B13E:  CLRF   x5F
0B140:  CLRF   x60
0B142:  CLRF   x61
0B144:  CLRF   x62
0B146:  CLRF   x63
0B148:  CLRF   x64
0B14A:  CLRF   x65
0B14C:  CLRF   x66
0B14E:  CLRF   x67
0B150:  CLRF   x68
0B152:  CLRF   x69
0B154:  CLRF   x6A
0B156:  CLRF   x6B
0B158:  CLRF   x6C
0B15A:  CLRF   x6D
0B15C:  CLRF   x6E
0B15E:  CLRF   x6F
0B160:  CLRF   x70
0B162:  CLRF   x71
0B164:  CLRF   x72
0B166:  CLRF   x73
0B168:  CLRF   x74
0B16A:  CLRF   x75
0B16C:  CLRF   x76
0B16E:  CLRF   x77
0B170:  CLRF   x78
0B172:  CLRF   x79
0B174:  CLRF   x7A
0B176:  CLRF   x7B
0B178:  CLRF   x7C
0B17A:  CLRF   x7D
0B17C:  CLRF   x7E
0B17E:  CLRF   x7F
0B180:  CLRF   x80
0B182:  CLRF   x81
0B184:  CLRF   x82
0B186:  CLRF   x83
0B188:  CLRF   x84
0B18A:  CLRF   x85
0B18C:  CLRF   x86
0B18E:  CLRF   x87
0B190:  CLRF   x88
0B192:  CLRF   x89
0B194:  CLRF   x8A
0B196:  CLRF   x8B
0B198:  CLRF   x8C
0B19A:  CLRF   x8D
0B19C:  CLRF   x8E
0B19E:  CLRF   x8F
0B1A0:  CLRF   x90
0B1A2:  CLRF   x91
0B1A4:  CLRF   x92
0B1A6:  CLRF   x93
0B1A8:  CLRF   x94
0B1AA:  CLRF   x95
0B1AC:  CLRF   x96
0B1AE:  CLRF   x97
0B1B0:  CLRF   x98
0B1B2:  CLRF   x99
0B1B4:  CLRF   x9A
0B1B6:  CLRF   x9B
0B1B8:  CLRF   x9C
0B1BA:  CLRF   x9D
0B1BC:  CLRF   x9E
0B1BE:  CLRF   x9F
0B1C0:  CLRF   xA0
0B1C2:  CLRF   xA1
0B1C4:  CLRF   xA2
0B1C6:  CLRF   xA3
0B1C8:  CLRF   xA4
0B1CA:  CLRF   xA5
0B1CC:  CLRF   xA6
0B1CE:  CLRF   xA7
0B1D0:  CLRF   xA8
0B1D2:  CLRF   xA9
0B1D4:  CLRF   xAA
0B1D6:  CLRF   xAB
0B1D8:  CLRF   xAC
0B1DA:  CLRF   xAD
0B1DC:  CLRF   xAE
0B1DE:  CLRF   xAF
0B1E0:  CLRF   xB0
0B1E2:  CLRF   xB1
0B1E4:  CLRF   xB2
0B1E6:  CLRF   xB3
0B1E8:  CLRF   xB4
0B1EA:  CLRF   xB5
0B1EC:  CLRF   xB6
0B1EE:  CLRF   xB7
0B1F0:  CLRF   xB8
0B1F2:  CLRF   xB9
0B1F4:  CLRF   xBA
0B1F6:  CLRF   xBB
0B1F8:  CLRF   xBC
0B1FA:  CLRF   xBD
0B1FC:  CLRF   xBE
0B1FE:  CLRF   xBF
0B200:  CLRF   xC0
0B202:  CLRF   xC1
0B204:  CLRF   xC2
0B206:  CLRF   xC3
0B208:  CLRF   xC4
0B20A:  CLRF   xC5
0B20C:  CLRF   xC6
0B20E:  CLRF   xC7
0B210:  CLRF   xC8
0B212:  CLRF   xC9
0B214:  CLRF   xCA
0B216:  CLRF   xCB
0B218:  CLRF   xCC
0B21A:  CLRF   xCD
0B21C:  CLRF   xCE
0B21E:  CLRF   xCF
0B220:  CLRF   xD0
0B222:  CLRF   xD1
0B224:  CLRF   xD2
0B226:  CLRF   xD3
0B228:  CLRF   xD4
0B22A:  CLRF   xD5
0B22C:  CLRF   xD6
0B22E:  CLRF   xD7
0B230:  CLRF   xD8
0B232:  CLRF   xD9
0B234:  CLRF   xDA
0B236:  CLRF   xDB
0B238:  CLRF   xDC
0B23A:  CLRF   xDD
0B23C:  CLRF   xDE
0B23E:  CLRF   xDF
0B240:  CLRF   xE0
0B242:  CLRF   xE1
0B244:  CLRF   xE2
0B246:  CLRF   xE3
0B248:  CLRF   xE4
0B24A:  CLRF   xE5
0B24C:  CLRF   xE6
0B24E:  CLRF   xE7
0B250:  CLRF   xE8
0B252:  CLRF   xE9
0B254:  CLRF   xEA
0B256:  CLRF   xEB
0B258:  CLRF   xEC
0B25A:  CLRF   xED
0B25C:  CLRF   xEE
0B25E:  CLRF   xEF
0B260:  CLRF   xF0
0B262:  CLRF   xF1
0B264:  CLRF   xF2
0B266:  CLRF   xF3
0B268:  CLRF   xF4
0B26A:  CLRF   xF5
0B26C:  CLRF   xF6
0B26E:  CLRF   xF7
0B270:  CLRF   xF8
0B272:  CLRF   xF9
0B274:  CLRF   xFA
0B276:  CLRF   xFB
0B278:  CLRF   xFC
0B27A:  CLRF   xFD
0B27C:  CLRF   xFE
0B27E:  CLRF   xFF
0B280:  MOVLB  2
0B282:  CLRF   x00
0B284:  CLRF   x01
0B286:  CLRF   x02
0B288:  CLRF   x03
0B28A:  CLRF   x04
0B28C:  CLRF   x05
0B28E:  CLRF   x06
0B290:  CLRF   x07
0B292:  CLRF   x08
0B294:  CLRF   x09
0B296:  CLRF   x0A
0B298:  CLRF   x0B
0B29A:  CLRF   x0C
0B29C:  CLRF   x0D
0B29E:  CLRF   x0E
0B2A0:  CLRF   x0F
0B2A2:  CLRF   x10
0B2A4:  CLRF   x11
0B2A6:  CLRF   x12
0B2A8:  CLRF   x13
0B2AA:  CLRF   x14
0B2AC:  CLRF   x15
0B2AE:  CLRF   x16
0B2B0:  CLRF   x17
0B2B2:  CLRF   x18
0B2B4:  CLRF   x19
0B2B6:  CLRF   x1A
0B2B8:  CLRF   x1B
0B2BA:  CLRF   x1C
0B2BC:  CLRF   x1D
0B2BE:  CLRF   x1E
0B2C0:  CLRF   x1F
0B2C2:  CLRF   x20
0B2C4:  CLRF   x21
0B2C6:  CLRF   x22
0B2C8:  CLRF   x23
0B2CA:  CLRF   x24
0B2CC:  CLRF   x25
0B2CE:  CLRF   x26
0B2D0:  CLRF   x27
0B2D2:  CLRF   x28
0B2D4:  CLRF   x29
0B2D6:  CLRF   x2A
0B2D8:  CLRF   x2B
0B2DA:  CLRF   x2C
0B2DC:  CLRF   x2D
0B2DE:  CLRF   x2E
0B2E0:  CLRF   x2F
0B2E2:  CLRF   x30
0B2E4:  CLRF   x31
0B2E6:  CLRF   x32
0B2E8:  CLRF   x33
0B2EA:  CLRF   x34
0B2EC:  CLRF   x35
0B2EE:  CLRF   x36
0B2F0:  CLRF   x37
0B2F2:  CLRF   x38
0B2F4:  CLRF   x39
0B2F6:  CLRF   x3A
0B2F8:  CLRF   x3B
0B2FA:  CLRF   x3C
0B2FC:  CLRF   x3D
0B2FE:  CLRF   x3E
0B300:  CLRF   x3F
0B302:  CLRF   x40
0B304:  CLRF   x41
0B306:  CLRF   x42
0B308:  CLRF   x43
0B30A:  CLRF   x44
0B30C:  CLRF   x45
0B30E:  CLRF   x46
0B310:  CLRF   x47
0B312:  CLRF   x48
0B314:  CLRF   x49
0B316:  CLRF   x4A
0B318:  CLRF   x4B
0B31A:  CLRF   x4C
0B31C:  CLRF   x4D
0B31E:  CLRF   x4E
0B320:  CLRF   x4F
0B322:  CLRF   x50
0B324:  CLRF   x51
0B326:  CLRF   x52
0B328:  CLRF   x53
0B32A:  CLRF   x54
0B32C:  CLRF   x55
0B32E:  CLRF   x56
0B330:  CLRF   x57
0B332:  CLRF   x58
0B334:  CLRF   x59
0B336:  CLRF   x5A
0B338:  CLRF   x5B
0B33A:  CLRF   x5C
0B33C:  CLRF   x5D
0B33E:  CLRF   x5E
0B340:  CLRF   x5F
0B342:  MOVLW  05
0B344:  MOVWF  x60
0B346:  MOVLW  7C
0B348:  MOVWF  x61
0B34A:  MOVLW  01
0B34C:  MOVWF  x62
0B34E:  MOVLW  01
0B350:  MOVWF  x63
0B352:  MOVLW  02
0B354:  MOVWF  x64
0B356:  MOVLW  7C
0B358:  MOVWF  x65
0B35A:  CLRF   x66
0B35C:  MOVLW  09
0B35E:  MOVWF  x67
0B360:  MOVLW  01
0B362:  MOVWF  x68
0B364:  CLRF   x69
0B366:  MOVLW  02
0B368:  MOVWF  x6A
0B36A:  MOVLW  01
0B36C:  MOVWF  x6B
0B36E:  CLRF   x6C
0B370:  CLRF   x6D
0B372:  CLRF   xA1
0B374:  CLRF   xA2
0B376:  CLRF   xA3
0B378:  CLRF   xA4
0B37A:  CLRF   xA5
0B37C:  CLRF   xA6
0B37E:  CLRF   xA7
0B380:  CLRF   xA8
0B382:  CLRF   xA9
0B384:  CLRF   xAA
0B386:  CLRF   xAB
0B388:  CLRF   xAC
0B38A:  CLRF   xAD
0B38C:  CLRF   xAE
0B38E:  CLRF   xAF
0B390:  CLRF   xB0
0B392:  CLRF   xB1
0B394:  CLRF   xB2
0B396:  CLRF   xB3
0B398:  CLRF   xB4
0B39A:  CLRF   xB5
0B39C:  CLRF   xB6
0B39E:  CLRF   xB7
0B3A0:  CLRF   xB8
0B3A2:  CLRF   xB9
0B3A4:  CLRF   xBA
0B3A6:  CLRF   xBB
0B3A8:  CLRF   xBC
0B3AA:  CLRF   xBD
0B3AC:  CLRF   xBE
0B3AE:  CLRF   xBF
0B3B0:  CLRF   xC0
0B3B2:  CLRF   xC1
0B3B4:  CLRF   xC2
0B3B6:  CLRF   xC3
0B3B8:  CLRF   xC4
0B3BA:  CLRF   xC5
0B3BC:  CLRF   xC6
0B3BE:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0B3C0:  MOVLW  64
0B3C2:  MOVLB  B
0B3C4:  MOVWF  xC3
0B3C6:  MOVLB  0
0B3C8:  CALL   1B30
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0B3CC:  MOVLW  D2
0B3CE:  MOVWF  FF6
0B3D0:  MOVLW  19
0B3D2:  MOVWF  FF7
0B3D4:  MOVLW  00
0B3D6:  MOVWF  FF8
0B3D8:  CALL   1BB0
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0B3DC:  MOVLW  18
0B3DE:  MOVWF  FF6
0B3E0:  MOVLW  1A
0B3E2:  MOVWF  FF7
0B3E4:  MOVLW  00
0B3E6:  MOVWF  FF8
0B3E8:  CALL   1BB0
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0B3EC:  MOVLW  46
0B3EE:  MOVWF  FF6
0B3F0:  MOVLW  1A
0B3F2:  MOVWF  FF7
0B3F4:  MOVLW  00
0B3F6:  MOVWF  FF8
0B3F8:  MOVLW  10
0B3FA:  MOVLB  B
0B3FC:  MOVWF  x1B
0B3FE:  MOVLB  0
0B400:  CALL   1BE0
0B404:  MOVLW  6C
0B406:  MOVWF  FF6
0B408:  MOVLW  1A
0B40A:  MOVWF  FF7
0B40C:  MOVLW  00
0B40E:  MOVWF  FF8
0B410:  CALL   1BB0
0B414:  MOVLW  20
0B416:  MOVLB  B
0B418:  MOVWF  x6E
0B41A:  MOVLB  0
0B41C:  CALL   1B5E
0B420:  MOVLW  76
0B422:  MOVWF  FF6
0B424:  MOVLW  1A
0B426:  MOVWF  FF7
0B428:  MOVLW  00
0B42A:  MOVWF  FF8
0B42C:  CALL   1BB0
0B430:  MOVLW  5B
0B432:  MOVWF  FF6
0B434:  MOVLW  1A
0B436:  MOVWF  FF7
0B438:  MOVLW  00
0B43A:  MOVWF  FF8
0B43C:  MOVLW  0F
0B43E:  MOVLB  B
0B440:  MOVWF  x1B
0B442:  MOVLB  0
0B444:  CALL   1BE0
....................    
....................    io_init();
0B448:  GOTO   1C16
....................    setup_uart_to_boss();
0B44C:  GOTO   1C64
....................    setup_timer();
0B450:  GOTO   1C8E
....................    ad7490_init();
0B454:  GOTO   1EA4
....................    mcp4901_init();
0B458:  GOTO   2182
....................    misf_init();
0B45C:  CALL   2FAA
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0B460:  MOVLB  3
0B462:  CLRF   x32
0B464:  CLRF   x33
0B466:  MOVLB  0
0B468:  CALL   3DC2
.................... 
....................    int1 is_finished = FALSE;
0B46C:  MOVLB  2
0B46E:  BCF    xC9.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0B470:  MOVLW  80
0B472:  MOVWF  FF6
0B474:  MOVLW  1A
0B476:  MOVWF  FF7
0B478:  MOVLW  00
0B47A:  MOVWF  FF8
0B47C:  MOVLB  0
0B47E:  CALL   1BB0
....................    
....................    output_low(EN_NPWR);
0B482:  MOVLW  5E
0B484:  MOVWF  F94
0B486:  BCF    F8B.7
....................    
....................    
....................    fprintf(PC,"waiting for BOSS PIC command");
0B488:  MOVLW  A6
0B48A:  MOVWF  FF6
0B48C:  MOVLW  1A
0B48E:  MOVWF  FF7
0B490:  MOVLW  00
0B492:  MOVWF  FF8
0B494:  CALL   1BB0
....................    
....................    //Start loop
....................    while(!is_finished)
0B498:  MOVLB  2
0B49A:  BTFSS  xC9.0
0B49C:  BRA    B4A4
0B49E:  MOVLB  0
0B4A0:  GOTO   B572
0B4A4:  MOVLB  0
....................    {
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0B4A6:  MOVF   46,F
0B4A8:  BTFSC  FD8.2
0B4AA:  GOTO   B52E
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0B4AE:  MOVLB  2
0B4B0:  CLRF   xDD
0B4B2:  MOVLW  26
0B4B4:  MOVWF  xDC
0B4B6:  MOVFF  46,2DE
0B4BA:  MOVLB  0
0B4BC:  GOTO   41BE
0B4C0:  MOVFF  02,03
0B4C4:  MOVF   01,W
0B4C6:  MOVWF  FE1
0B4C8:  MOVFF  03,FE2
0B4CC:  MOVLW  02
0B4CE:  MOVWF  FEA
0B4D0:  MOVLW  CA
0B4D2:  MOVWF  FE9
0B4D4:  MOVLW  0C
0B4D6:  MOVWF  01
0B4D8:  MOVFF  FE6,FEE
0B4DC:  DECFSZ 01,F
0B4DE:  GOTO   B4D8
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0B4E2:  MOVLB  2
0B4E4:  CLRF   xD7
0B4E6:  MOVLW  26
0B4E8:  MOVWF  xD6
0B4EA:  CLRF   xD9
0B4EC:  MOVLW  46
0B4EE:  MOVWF  xD8
0B4F0:  MOVLB  0
0B4F2:  GOTO   43BA
....................          
....................          if(recieve_cmd.is_exist)
0B4F6:  MOVLB  2
0B4F8:  BTFSC  xCC.0
0B4FA:  BRA    B502
0B4FC:  MOVLB  0
0B4FE:  GOTO   B51E
0B502:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0B504:  MOVLW  02
0B506:  MOVLB  2
0B508:  MOVWF  xD7
0B50A:  MOVLW  CA
0B50C:  MOVWF  xD6
0B50E:  MOVLB  0
0B510:  GOTO   AD8E
0B514:  MOVLB  2
0B516:  BCF    xC9.1
0B518:  BTFSC  01.0
0B51A:  BSF    xC9.1
0B51C:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0B51E:  MOVLW  C4
0B520:  MOVWF  FF6
0B522:  MOVLW  1A
0B524:  MOVWF  FF7
0B526:  MOVLW  00
0B528:  MOVWF  FF8
0B52A:  CALL   1BB0
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0B52E:  MOVLB  2
0B530:  BTFSC  xC9.0
0B532:  BRA    B53A
0B534:  MOVLB  0
0B536:  GOTO   B540
0B53A:  MOVLB  0
....................          break;
0B53C:  GOTO   B572
....................          
....................       delay_ms(400);
0B540:  MOVLW  02
0B542:  MOVLB  2
0B544:  MOVWF  xD6
0B546:  MOVLB  0
0B548:  MOVLW  C8
0B54A:  MOVLB  B
0B54C:  MOVWF  xC3
0B54E:  MOVLB  0
0B550:  CALL   1B30
0B554:  MOVLB  2
0B556:  DECFSZ xD6,F
0B558:  BRA    B55E
0B55A:  BRA    B562
0B55C:  MOVLB  0
0B55E:  MOVLB  0
0B560:  BRA    B548
....................       fprintf(PC, ".");
0B562:  MOVLW  2E
0B564:  MOVLB  B
0B566:  MOVWF  x6E
0B568:  MOVLB  0
0B56A:  CALL   1B5E
0B56E:  GOTO   B498
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0B572:  MOVLW  E4
0B574:  MOVWF  FF6
0B576:  MOVLW  1A
0B578:  MOVWF  FF7
0B57A:  MOVLW  00
0B57C:  MOVWF  FF8
0B57E:  CALL   1BB0
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0B582:  MOVLW  2E
0B584:  MOVLB  B
0B586:  MOVWF  x6E
0B588:  MOVLB  0
0B58A:  CALL   1B5E
....................       delay_ms(1000);
0B58E:  MOVLW  04
0B590:  MOVLB  2
0B592:  MOVWF  xD6
0B594:  MOVLB  0
0B596:  MOVLW  FA
0B598:  MOVLB  B
0B59A:  MOVWF  xC3
0B59C:  MOVLB  0
0B59E:  CALL   1B30
0B5A2:  MOVLB  2
0B5A4:  DECFSZ xD6,F
0B5A6:  BRA    B5AC
0B5A8:  BRA    B5B0
0B5AA:  MOVLB  0
0B5AC:  MOVLB  0
0B5AE:  BRA    B596
0B5B0:  MOVLB  0
0B5B2:  GOTO   B582
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0B5B6:  MOVLW  24
0B5B8:  MOVWF  FF6
0B5BA:  MOVLW  1B
0B5BC:  MOVWF  FF7
0B5BE:  MOVLW  00
0B5C0:  MOVWF  FF8
0B5C2:  CALL   1BB0
....................    
.................... }
.................... // Enf of files
0B5C6:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
