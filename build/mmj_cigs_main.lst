CCS PCH C Compiler, Version 5.104, 57077               24-8-25 16:24

               Filename:   build\mmj_cigs_main.lst

               ROM used:   47008 bytes (36%)
                           Largest free fragment is 65520
               RAM used:   389 (11%) at main() level
                           2751 (77%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   B22E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "cigs/system/mmj_cigs_main.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 45,6E
0028C:  DATA 71,75
0028E:  DATA 65,75
00290:  DATA 65,20
00292:  DATA 46,6C
00294:  DATA 61,73
00296:  DATA 68,20
00298:  DATA 4F,70
0029A:  DATA 65,72
0029C:  DATA 61,74
0029E:  DATA 69,6F
002A0:  DATA 6E,0D
002A2:  DATA 0A,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,66
002B4:  DATA 75,6C
002B6:  DATA 6C,21
002B8:  DATA 21,21
002BA:  DATA 0D,0A
002BC:  DATA 00,00
002BE:  DATA 46,6C
002C0:  DATA 61,73
002C2:  DATA 68,20
002C4:  DATA 71,75
002C6:  DATA 65,75
002C8:  DATA 65,20
002CA:  DATA 69,73
002CC:  DATA 20,65
002CE:  DATA 6D,70
002D0:  DATA 74,79
002D2:  DATA 0D,0A
002D4:  DATA 00,00
002D6:  DATA 0D,0A
002D8:  DATA 53,74
002DA:  DATA 61,72
002DC:  DATA 74,20
002DE:  DATA 6D,61
002E0:  DATA 6B,65
002E2:  DATA 5F,72
002E4:  DATA 65,63
002E6:  DATA 65,69
002E8:  DATA 76,65
002EA:  DATA 5F,63
002EC:  DATA 6F,6D
002EE:  DATA 6D,61
002F0:  DATA 6E,64
002F2:  DATA 0D,0A
002F4:  DATA 00,00
002F6:  DATA 09,5B
002F8:  DATA 42,4F
002FA:  DATA 53,53
002FC:  DATA 5D,20
002FE:  DATA 3E,3E
00300:  DATA 3E,20
00302:  DATA 00,00
00304:  DATA 45,6E
00306:  DATA 64,20
00308:  DATA 6D,61
0030A:  DATA 6B,65
0030C:  DATA 5F,72
0030E:  DATA 65,63
00310:  DATA 69,76
00312:  DATA 65,5F
00314:  DATA 63,6F
00316:  DATA 6D,6D
00318:  DATA 61,6E
0031A:  DATA 64,0D
0031C:  DATA 0A,0D
0031E:  DATA 0A,00
00320:  DATA 73,69
00322:  DATA 67,6E
00324:  DATA 61,6C
00326:  DATA 20,65
00328:  DATA 6E,64
0032A:  DATA 20,77
0032C:  DATA 69,74
0032E:  DATA 68,20
00330:  DATA 53,46
00332:  DATA 44,0D
00334:  DATA 0A,00
00336:  DATA 64,6F
00338:  DATA 6E,27
0033A:  DATA 74,20
0033C:  DATA 66,69
0033E:  DATA 6E,64
00340:  DATA 20,53
00342:  DATA 46,44
00344:  DATA 0D,0A
00346:  DATA 00,00
00348:  DATA 09,2D
0034A:  DATA 3E,20
0034C:  DATA 49,6E
0034E:  DATA 76,61
00350:  DATA 6C,69
00352:  DATA 64,20
00354:  DATA 46,72
00356:  DATA 61,6D
00358:  DATA 65,20
0035A:  DATA 49,44
0035C:  DATA 20,72
0035E:  DATA 65,63
00360:  DATA 65,69
00362:  DATA 76,65
00364:  DATA 64,3A
00366:  DATA 20,25
00368:  DATA 58,0D
0036A:  DATA 0A,00
0036C:  DATA 09,2D
0036E:  DATA 3E,20
00370:  DATA 43,52
00372:  DATA 43,20
00374:  DATA 65,72
00376:  DATA 72,6F
00378:  DATA 72,21
0037A:  DATA 0D,0A
0037C:  DATA 00,00
0037E:  DATA 09,09
00380:  DATA 2D,3E
00382:  DATA 20,72
00384:  DATA 65,63
00386:  DATA 65,69
00388:  DATA 76,65
0038A:  DATA 64,20
0038C:  DATA 43,52
0038E:  DATA 43,3A
00390:  DATA 20,25
00392:  DATA 58,0D
00394:  DATA 0A,00
00396:  DATA 09,09
00398:  DATA 20,20
0039A:  DATA 20,63
0039C:  DATA 6F,6C
0039E:  DATA 6C,65
003A0:  DATA 63,74
003A2:  DATA 20,43
003A4:  DATA 52,43
003A6:  DATA 20,3A
003A8:  DATA 20,25
003AA:  DATA 58,0D
003AC:  DATA 0A,00
003AE:  DATA 09,2D
003B0:  DATA 3E,20
003B2:  DATA 49,6E
003B4:  DATA 76,61
003B6:  DATA 6C,69
003B8:  DATA 64,20
003BA:  DATA 64,65
003BC:  DATA 76,69
003BE:  DATA 63,65
003C0:  DATA 20,49
003C2:  DATA 44,20
003C4:  DATA 72,65
003C6:  DATA 63,65
003C8:  DATA 69,76
003CA:  DATA 65,64
003CC:  DATA 0D,0A
003CE:  DATA 00,00
003D0:  DATA 09,09
003D2:  DATA 2D,3E
003D4:  DATA 20,72
003D6:  DATA 65,63
003D8:  DATA 65,69
003DA:  DATA 76,65
003DC:  DATA 64,3A
003DE:  DATA 20,20
003E0:  DATA 20,20
003E2:  DATA 20,25
003E4:  DATA 58,0D
003E6:  DATA 0A,00
003E8:  DATA 09,09
003EA:  DATA 20,20
003EC:  DATA 20,4D
003EE:  DATA 79,20
003F0:  DATA 64,65
003F2:  DATA 76,69
003F4:  DATA 63,65
003F6:  DATA 20,49
003F8:  DATA 44,3A
003FA:  DATA 20,25
003FC:  DATA 58,0D
003FE:  DATA 0A,00
00400:  DATA 09,5B
00402:  DATA 42,4F
00404:  DATA 53,53
00406:  DATA 5D,20
00408:  DATA 3C,3C
0040A:  DATA 3C,20
0040C:  DATA 00,00
0040E:  DATA 53,74
00410:  DATA 61,72
00412:  DATA 74,20
00414:  DATA 53,4D
00416:  DATA 46,20
00418:  DATA 75,73
0041A:  DATA 69,6E
0041C:  DATA 67,20
0041E:  DATA 72,65
00420:  DATA 71,65
00422:  DATA 73,74
00424:  DATA 20,73
00426:  DATA 65,61
00428:  DATA 71,75
0042A:  DATA 65,6E
0042C:  DATA 63,65
0042E:  DATA 0D,0A
00430:  DATA 00,00
00432:  DATA 45,72
00434:  DATA 72,6F
00436:  DATA 72,21
00438:  DATA 20,52
0043A:  DATA 65,63
0043C:  DATA 65,69
0043E:  DATA 76,69
00440:  DATA 6E,67
00442:  DATA 20,63
00444:  DATA 6F,6D
00446:  DATA 6D,61
00448:  DATA 6E,64
0044A:  DATA 20,69
0044C:  DATA 6E,63
0044E:  DATA 6F,6E
00450:  DATA 73,69
00452:  DATA 73,74
00454:  DATA 65,6E
00456:  DATA 74,20
00458:  DATA 77,69
0045A:  DATA 74,68
0045C:  DATA 20,74
0045E:  DATA 68,65
00460:  DATA 20,64
00462:  DATA 65,73
00464:  DATA 69,67
00466:  DATA 6E,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 61,6C
0047C:  DATA 6C,6F
0047E:  DATA 77,65
00480:  DATA 64,0D
00482:  DATA 0A,00
00484:  DATA 53,4D
00486:  DATA 46,20
00488:  DATA 75,73
0048A:  DATA 65,20
0048C:  DATA 72,65
0048E:  DATA 71,75
00490:  DATA 65,73
00492:  DATA 74,20
00494:  DATA 64,65
00496:  DATA 6E,79
00498:  DATA 65,64
0049A:  DATA 0D,0A
0049C:  DATA 00,00
0049E:  DATA 52,65
004A0:  DATA 74,72
004A2:  DATA 79,20
004A4:  DATA 72,65
004A6:  DATA 71,75
004A8:  DATA 65,73
004AA:  DATA 74,20
004AC:  DATA 74,6F
004AE:  DATA 20,42
004B0:  DATA 4F,53
004B2:  DATA 53,20
004B4:  DATA 50,49
004B6:  DATA 43,0D
004B8:  DATA 0A,00
004BA:  DATA 45,72
004BC:  DATA 72,6F
004BE:  DATA 72,21
004C0:  DATA 20,52
004C2:  DATA 65,63
004C4:  DATA 65,69
004C6:  DATA 76,69
004C8:  DATA 6E,67
004CA:  DATA 20,63
004CC:  DATA 6F,6D
004CE:  DATA 6D,61
004D0:  DATA 6E,64
004D2:  DATA 20,69
004D4:  DATA 6E,63
004D6:  DATA 6F,6E
004D8:  DATA 73,69
004DA:  DATA 73,74
004DC:  DATA 65,6E
004DE:  DATA 74,20
004E0:  DATA 77,69
004E2:  DATA 74,68
004E4:  DATA 20,74
004E6:  DATA 68,65
004E8:  DATA 20,64
004EA:  DATA 65,73
004EC:  DATA 69,67
004EE:  DATA 6E,0D
004F0:  DATA 0A,00
004F2:  DATA 45,6E
004F4:  DATA 64,20
004F6:  DATA 53,4D
004F8:  DATA 46,20
004FA:  DATA 75,73
004FC:  DATA 69,6E
004FE:  DATA 67,20
00500:  DATA 72,65
00502:  DATA 71,65
00504:  DATA 73,74
00506:  DATA 20,73
00508:  DATA 65,61
0050A:  DATA 71,75
0050C:  DATA 65,6E
0050E:  DATA 63,65
00510:  DATA 0D,0A
00512:  DATA 00,00
00514:  DATA 49,4F
00516:  DATA 20,49
00518:  DATA 6E,69
0051A:  DATA 74,69
0051C:  DATA 61,6C
0051E:  DATA 69,7A
00520:  DATA 65,0D
00522:  DATA 0A,00
00524:  DATA 09,43
00526:  DATA 6F,6D
00528:  DATA 70,6C
0052A:  DATA 65,74
0052C:  DATA 65,0D
0052E:  DATA 0A,00
00530:  DATA 53,74
00532:  DATA 61,72
00534:  DATA 74,20
00536:  DATA 54,45
00538:  DATA 53,54
0053A:  DATA 20,53
0053C:  DATA 57,45
0053E:  DATA 45,50
00540:  DATA 0D,0A
00542:  DATA 00,00
00544:  DATA 73,74
00546:  DATA 65,70
00548:  DATA 2C,20
0054A:  DATA 76,6F
0054C:  DATA 6C,74
0054E:  DATA 61,67
00550:  DATA 65,2C
00552:  DATA 20,63
00554:  DATA 75,72
00556:  DATA 72,65
00558:  DATA 6E,74
0055A:  DATA 0D,0A
0055C:  DATA 00,00
0055E:  DATA 53,74
00560:  DATA 61,72
00562:  DATA 74,20
00564:  DATA 41,44
00566:  DATA 43,20
00568:  DATA 54,45
0056A:  DATA 53,54
0056C:  DATA 0D,0A
0056E:  DATA 00,00
00570:  DATA 41,44
00572:  DATA 43,20
00574:  DATA 56,6F
00576:  DATA 6C,74
00578:  DATA 61,67
0057A:  DATA 65,3A
0057C:  DATA 20,25
0057E:  DATA 30,34
00580:  DATA 4C,58
00582:  DATA 0D,0A
00584:  DATA 00,00
00586:  DATA 41,44
00588:  DATA 43,20
0058A:  DATA 43,75
0058C:  DATA 72,72
0058E:  DATA 65,6E
00590:  DATA 74,3A
00592:  DATA 20,25
00594:  DATA 30,34
00596:  DATA 4C,58
00598:  DATA 0D,0A
0059A:  DATA 00,00
0059C:  DATA 41,44
0059E:  DATA 43,20
005A0:  DATA 43,49
005A2:  DATA 47,53
005A4:  DATA 31,20
005A6:  DATA 41,6D
005A8:  DATA 70,3A
005AA:  DATA 20,25
005AC:  DATA 30,34
005AE:  DATA 4C,58
005B0:  DATA 0D,0A
005B2:  DATA 00,00
005B4:  DATA 41,44
005B6:  DATA 43,20
005B8:  DATA 43,49
005BA:  DATA 47,53
005BC:  DATA 31,20
005BE:  DATA 56,52
005C0:  DATA 45,46
005C2:  DATA 3A,20
005C4:  DATA 25,30
005C6:  DATA 34,4C
005C8:  DATA 58,0D
005CA:  DATA 0A,00
005CC:  DATA 53,74
005CE:  DATA 61,72
005D0:  DATA 74,20
005D2:  DATA 53,57
005D4:  DATA 45,45
005D6:  DATA 50,20
005D8:  DATA 32,70
005DA:  DATA 6F,72
005DC:  DATA 74,73
005DE:  DATA 0D,0A
005E0:  DATA 00,00
005E2:  DATA 09,53
005E4:  DATA 77,65
005E6:  DATA 65,70
005E8:  DATA 20,73
005EA:  DATA 74,65
005EC:  DATA 70,20
005EE:  DATA 3A,20
005F0:  DATA 25,75
005F2:  DATA 0D,0A
005F4:  DATA 00,00
005F6:  DATA 45,4E
005F8:  DATA 44,20
005FA:  DATA 53,57
005FC:  DATA 45,45
005FE:  DATA 50,20
00600:  DATA 32,70
00602:  DATA 6F,72
00604:  DATA 74,0D
00606:  DATA 0A,00
00608:  DATA 53,74
0060A:  DATA 61,72
0060C:  DATA 74,20
0060E:  DATA 43,49
00610:  DATA 47,53
00612:  DATA 20,64
00614:  DATA 61,74
00616:  DATA 61,20
00618:  DATA 63,6F
0061A:  DATA 6E,76
0061C:  DATA 65,72
0061E:  DATA 73,69
00620:  DATA 6F,6E
00622:  DATA 0D,0A
00624:  DATA 00,00
00626:  DATA 53,74
00628:  DATA 61,72
0062A:  DATA 74,20
0062C:  DATA 53,57
0062E:  DATA 45,45
00630:  DATA 50,20
00632:  DATA 77,69
00634:  DATA 74,68
00636:  DATA 20,74
00638:  DATA 68,72
0063A:  DATA 65,73
0063C:  DATA 68,6F
0063E:  DATA 6C,64
00640:  DATA 0D,0A
00642:  DATA 00,00
00644:  DATA 4D,61
00646:  DATA 78,69
00648:  DATA 6D,75
0064A:  DATA 6D,20
0064C:  DATA 73,74
0064E:  DATA 65,70
00650:  DATA 20,63
00652:  DATA 6F,75
00654:  DATA 6E,74
00656:  DATA 20,72
00658:  DATA 65,61
0065A:  DATA 63,68
0065C:  DATA 65,64
0065E:  DATA 3A,20
00660:  DATA 25,6C
00662:  DATA 64,0D
00664:  DATA 0A,00
00666:  DATA 43,49
00668:  DATA 47,53
0066A:  DATA 31,20
0066C:  DATA 63,75
0066E:  DATA 72,72
00670:  DATA 65,6E
00672:  DATA 74,20
00674:  DATA 6C,69
00676:  DATA 6D,69
00678:  DATA 74,20
0067A:  DATA 72,65
0067C:  DATA 61,63
0067E:  DATA 68,65
00680:  DATA 64,3A
00682:  DATA 00,00
00684:  DATA 43,49
00686:  DATA 47,53
00688:  DATA 31,20
0068A:  DATA 63,75
0068C:  DATA 72,72
0068E:  DATA 65,6E
00690:  DATA 74,20
00692:  DATA 62,65
00694:  DATA 6C,6F
00696:  DATA 77,20
00698:  DATA 74,68
0069A:  DATA 72,65
0069C:  DATA 73,68
0069E:  DATA 6F,6C
006A0:  DATA 64,00
006A2:  DATA 43,49
006A4:  DATA 47,53
006A6:  DATA 32,20
006A8:  DATA 63,75
006AA:  DATA 72,72
006AC:  DATA 65,6E
006AE:  DATA 74,20
006B0:  DATA 6C,69
006B2:  DATA 6D,69
006B4:  DATA 74,20
006B6:  DATA 72,65
006B8:  DATA 61,63
006BA:  DATA 68,65
006BC:  DATA 64,3A
006BE:  DATA 20,00
006C0:  DATA 43,49
006C2:  DATA 47,53
006C4:  DATA 32,20
006C6:  DATA 63,75
006C8:  DATA 72,72
006CA:  DATA 65,6E
006CC:  DATA 74,20
006CE:  DATA 62,65
006D0:  DATA 6C,6F
006D2:  DATA 77,20
006D4:  DATA 74,68
006D6:  DATA 72,65
006D8:  DATA 73,68
006DA:  DATA 6F,6C
006DC:  DATA 64,3A
006DE:  DATA 00,00
006E0:  DATA 45,6E
006E2:  DATA 64,20
006E4:  DATA 53,57
006E6:  DATA 45,45
006E8:  DATA 50,20
006EA:  DATA 77,69
006EC:  DATA 74,68
006EE:  DATA 20,74
006F0:  DATA 68,72
006F2:  DATA 65,73
006F4:  DATA 68,6F
006F6:  DATA 6C,64
006F8:  DATA 0D,0A
006FA:  DATA 00,00
006FC:  DATA 45,6E
006FE:  DATA 64,20
00700:  DATA 43,49
00702:  DATA 47,53
00704:  DATA 20,64
00706:  DATA 61,74
00708:  DATA 61,20
0070A:  DATA 63,6F
0070C:  DATA 6E,76
0070E:  DATA 65,72
00710:  DATA 73,69
00712:  DATA 6F,6E
00714:  DATA 0D,0A
00716:  DATA 00,00
00718:  DATA 09,5B
0071A:  DATA 50,49
0071C:  DATA 43,4C
0071E:  DATA 4F,47
00720:  DATA 5D,20
00722:  DATA 3A,20
00724:  DATA 00,00
00726:  DATA 43,52
00728:  DATA 43,20
0072A:  DATA 76,65
0072C:  DATA 72,69
0072E:  DATA 66,69
00730:  DATA 63,61
00732:  DATA 74,69
00734:  DATA 6F,6E
00736:  DATA 20,70
00738:  DATA 61,73
0073A:  DATA 73,65
0073C:  DATA 64,20
0073E:  DATA 6F,6E
00740:  DATA 20,61
00742:  DATA 74,74
00744:  DATA 65,6D
00746:  DATA 70,74
00748:  DATA 20,25
0074A:  DATA 75,0D
0074C:  DATA 0A,00
0074E:  DATA 43,52
00750:  DATA 43,20
00752:  DATA 76,65
00754:  DATA 72,69
00756:  DATA 66,69
00758:  DATA 63,61
0075A:  DATA 74,69
0075C:  DATA 6F,6E
0075E:  DATA 20,70
00760:  DATA 61,73
00762:  DATA 73,65
00764:  DATA 64,20
00766:  DATA 6F,6E
00768:  DATA 20,61
0076A:  DATA 74,74
0076C:  DATA 65,6D
0076E:  DATA 70,74
00770:  DATA 20,25
00772:  DATA 64,0D
00774:  DATA 0A,00
00776:  DATA 45,72
00778:  DATA 72,6F
0077A:  DATA 72,3A
0077C:  DATA 20,43
0077E:  DATA 52,43
00780:  DATA 20,76
00782:  DATA 65,72
00784:  DATA 69,66
00786:  DATA 69,63
00788:  DATA 61,74
0078A:  DATA 69,6F
0078C:  DATA 6E,20
0078E:  DATA 66,61
00790:  DATA 69,6C
00792:  DATA 65,64
00794:  DATA 20,61
00796:  DATA 66,74
00798:  DATA 65,72
0079A:  DATA 20,25
0079C:  DATA 64,20
0079E:  DATA 61,74
007A0:  DATA 74,65
007A2:  DATA 6D,70
007A4:  DATA 74,73
007A6:  DATA 0D,0A
007A8:  DATA 00,00
007AA:  DATA 0D,0A
007AC:  DATA 5F,5F
007AE:  DATA 5F,5F
007B0:  DATA 5F,5F
007B2:  DATA 5F,5F
007B4:  DATA 5F,5F
007B6:  DATA 5F,5F
007B8:  DATA 5F,5F
007BA:  DATA 5F,5F
007BC:  DATA 5F,5F
007BE:  DATA 5F,5F
007C0:  DATA 0D,0A
007C2:  DATA 00,00
007C4:  DATA 5F,5F
007C6:  DATA 5F,5F
007C8:  DATA 5F,53
007CA:  DATA 74,61
007CC:  DATA 72,74
007CE:  DATA 20,63
007D0:  DATA 6F,70
007D2:  DATA 79,5F
007D4:  DATA 64,61
007D6:  DATA 74,61
007D8:  DATA 5F,5F
007DA:  DATA 5F,5F
007DC:  DATA 0D,0A
007DE:  DATA 00,00
007E0:  DATA 45,72
007E2:  DATA 72,6F
007E4:  DATA 72,3A
007E6:  DATA 20,4D
007E8:  DATA 49,53
007EA:  DATA 20,46
007EC:  DATA 4D,20
007EE:  DATA 69,73
007F0:  DATA 20,6E
007F2:  DATA 6F,74
007F4:  DATA 20,63
007F6:  DATA 6F,6E
007F8:  DATA 6E,65
007FA:  DATA 63,74
007FC:  DATA 65,64
007FE:  DATA 0D,0A
00800:  DATA 00,00
00802:  DATA 45,72
00804:  DATA 72,6F
00806:  DATA 72,3A
00808:  DATA 20,53
0080A:  DATA 4D,46
0080C:  DATA 20,69
0080E:  DATA 73,20
00810:  DATA 6E,6F
00812:  DATA 74,20
00814:  DATA 63,6F
00816:  DATA 6E,6E
00818:  DATA 65,63
0081A:  DATA 74,65
0081C:  DATA 64,0D
0081E:  DATA 0A,00
00820:  DATA 53,69
00822:  DATA 7A,65
00824:  DATA 20,61
00826:  DATA 72,65
00828:  DATA 61,20
0082A:  DATA 72,65
0082C:  DATA 61,64
0082E:  DATA 0D,0A
00830:  DATA 00,00
00832:  DATA 73,6D
00834:  DATA 66,5F
00836:  DATA 75,73
00838:  DATA 65,64
0083A:  DATA 5F,73
0083C:  DATA 69,7A
0083E:  DATA 65,20
00840:  DATA 3D,20
00842:  DATA 25,6C
00844:  DATA 64,20
00846:  DATA 28,73
00848:  DATA 72,63
0084A:  DATA 20,30
0084C:  DATA 78,25
0084E:  DATA 30,38
00850:  DATA 4C,58
00852:  DATA 29,0D
00854:  DATA 0A,00
00856:  DATA 73,6D
00858:  DATA 66,5F
0085A:  DATA 6C,6F
0085C:  DATA 6F,70
0085E:  DATA 20,63
00860:  DATA 6F,75
00862:  DATA 6E,74
00864:  DATA 3D,20
00866:  DATA 25,64
00868:  DATA 20,20
0086A:  DATA 28,73
0086C:  DATA 72,63
0086E:  DATA 20,30
00870:  DATA 78,25
00872:  DATA 30,38
00874:  DATA 4C,58
00876:  DATA 29,0D
00878:  DATA 0A,00
0087A:  DATA 6D,69
0087C:  DATA 73,66
0087E:  DATA 5F,77
00880:  DATA 72,69
00882:  DATA 74,65
00884:  DATA 5F,73
00886:  DATA 6F,75
00888:  DATA 72,63
0088A:  DATA 65,20
0088C:  DATA 3D,20
0088E:  DATA 30,78
00890:  DATA 25,30
00892:  DATA 38,4C
00894:  DATA 58,0D
00896:  DATA 0A,00
00898:  DATA 6D,69
0089A:  DATA 73,66
0089C:  DATA 5F,77
0089E:  DATA 72,69
008A0:  DATA 74,65
008A2:  DATA 5F,73
008A4:  DATA 69,7A
008A6:  DATA 65,20
008A8:  DATA 3D,20
008AA:  DATA 30,78
008AC:  DATA 25,30
008AE:  DATA 38,4C
008B0:  DATA 58,0D
008B2:  DATA 0A,00
008B4:  DATA 57,72
008B6:  DATA 61,70
008B8:  DATA 20,74
008BA:  DATA 72,69
008BC:  DATA 67,67
008BE:  DATA 65,72
008C0:  DATA 65,64
008C2:  DATA 3A,20
008C4:  DATA 52,65
008C6:  DATA 73,65
008C8:  DATA 74,74
008CA:  DATA 69,6E
008CC:  DATA 67,20
008CE:  DATA 64,61
008D0:  DATA 74,61
008D2:  DATA 5F,77
008D4:  DATA 72,69
008D6:  DATA 74,65
008D8:  DATA 5F,61
008DA:  DATA 64,64
008DC:  DATA 72,20
008DE:  DATA 74,6F
008E0:  DATA 20,73
008E2:  DATA 74,61
008E4:  DATA 72,74
008E6:  DATA 0D,0A
008E8:  DATA 00,00
008EA:  DATA 75,73
008EC:  DATA 65,64
008EE:  DATA 5F,73
008F0:  DATA 69,7A
008F2:  DATA 65,20
008F4:  DATA 3D,20
008F6:  DATA 25,6C
008F8:  DATA 64,0D
008FA:  DATA 0A,00
008FC:  DATA 6C,6F
008FE:  DATA 6F,70
00900:  DATA 5F,63
00902:  DATA 6F,75
00904:  DATA 6E,74
00906:  DATA 20,3D
00908:  DATA 20,25
0090A:  DATA 75,0D
0090C:  DATA 0A,0D
0090E:  DATA 0A,00
00910:  DATA 0D,0A
00912:  DATA 5F,5F
00914:  DATA 5F,45
00916:  DATA 6E,64
00918:  DATA 20,63
0091A:  DATA 6F,70
0091C:  DATA 79,5F
0091E:  DATA 64,61
00920:  DATA 74,61
00922:  DATA 5F,5F
00924:  DATA 5F,5F
00926:  DATA 0D,0A
00928:  DATA 00,00
0092A:  DATA 5F,5F
0092C:  DATA 5F,5F
0092E:  DATA 5F,5F
00930:  DATA 5F,5F
00932:  DATA 5F,5F
00934:  DATA 5F,5F
00936:  DATA 5F,5F
00938:  DATA 5F,5F
0093A:  DATA 5F,5F
0093C:  DATA 5F,5F
0093E:  DATA 0D,0A
00940:  DATA 0D,0A
00942:  DATA 00,00
00944:  DATA 0D,0A
00946:  DATA 5F,5F
00948:  DATA 5F,5F
0094A:  DATA 5F,5F
0094C:  DATA 5F,5F
0094E:  DATA 5F,5F
00950:  DATA 5F,5F
00952:  DATA 5F,5F
00954:  DATA 5F,5F
00956:  DATA 5F,5F
00958:  DATA 5F,5F
0095A:  DATA 0D,0A
0095C:  DATA 00,00
0095E:  DATA 5F,5F
00960:  DATA 5F,53
00962:  DATA 74,61
00964:  DATA 72,74
00966:  DATA 20,53
00968:  DATA 4D,46
0096A:  DATA 20,52
0096C:  DATA 65,61
0096E:  DATA 64,5F
00970:  DATA 5F,5F
00972:  DATA 5F,0D
00974:  DATA 0A,00
00976:  DATA 49,6E
00978:  DATA 20,53
0097A:  DATA 4D,46
0097C:  DATA 20,52
0097E:  DATA 65,61
00980:  DATA 64,20
00982:  DATA 73,6F
00984:  DATA 75,72
00986:  DATA 63,65
00988:  DATA 20,64
0098A:  DATA 61,74
0098C:  DATA 61,20
0098E:  DATA 61,64
00990:  DATA 64,72
00992:  DATA 65,73
00994:  DATA 73,3A
00996:  DATA 20,25
00998:  DATA 4C,58
0099A:  DATA 0D,0A
0099C:  DATA 00,00
0099E:  DATA 49,6E
009A0:  DATA 20,53
009A2:  DATA 4D,46
009A4:  DATA 20,52
009A6:  DATA 65,61
009A8:  DATA 64,20
009AA:  DATA 64,61
009AC:  DATA 74,61
009AE:  DATA 20,73
009B0:  DATA 69,7A
009B2:  DATA 65,20
009B4:  DATA 20,20
009B6:  DATA 20,20
009B8:  DATA 20,20
009BA:  DATA 20,20
009BC:  DATA 20,3A
009BE:  DATA 20,25
009C0:  DATA 6C,75
009C2:  DATA 20,28
009C4:  DATA 30,78
009C6:  DATA 25,6C
009C8:  DATA 78,29
009CA:  DATA 0D,0A
009CC:  DATA 0D,0A
009CE:  DATA 00,00
009D0:  DATA 45,72
009D2:  DATA 72,6F
009D4:  DATA 72,3A
009D6:  DATA 20,53
009D8:  DATA 4D,46
009DA:  DATA 20,69
009DC:  DATA 73,20
009DE:  DATA 6E,6F
009E0:  DATA 74,20
009E2:  DATA 63,6F
009E4:  DATA 6E,6E
009E6:  DATA 65,63
009E8:  DATA 74,65
009EA:  DATA 64,0D
009EC:  DATA 0A,00
009EE:  DATA 52,45
009F0:  DATA 41,44
009F2:  DATA 20,44
009F4:  DATA 41,54
009F6:  DATA 41,20
009F8:  DATA 46,52
009FA:  DATA 4F,4D
009FC:  DATA 20,53
009FE:  DATA 4D,46
00A00:  DATA 2E,2E
00A02:  DATA 2E,0D
00A04:  DATA 0A,00
00A06:  DATA 0D,0A
00A08:  DATA 5F,5F
00A0A:  DATA 5F,45
00A0C:  DATA 6E,64
00A0E:  DATA 20,53
00A10:  DATA 4D,46
00A12:  DATA 20,52
00A14:  DATA 65,61
00A16:  DATA 64,5F
00A18:  DATA 5F,5F
00A1A:  DATA 5F,0D
00A1C:  DATA 0A,00
00A1E:  DATA 5F,5F
00A20:  DATA 5F,5F
00A22:  DATA 5F,5F
00A24:  DATA 5F,5F
00A26:  DATA 5F,5F
00A28:  DATA 5F,5F
00A2A:  DATA 5F,5F
00A2C:  DATA 5F,5F
00A2E:  DATA 5F,5F
00A30:  DATA 5F,5F
00A32:  DATA 0D,0A
00A34:  DATA 0D,0A
00A36:  DATA 00,00
00A38:  DATA 0D,0A
00A3A:  DATA 5F,5F
00A3C:  DATA 5F,5F
00A3E:  DATA 5F,5F
00A40:  DATA 5F,5F
00A42:  DATA 5F,5F
00A44:  DATA 5F,5F
00A46:  DATA 5F,5F
00A48:  DATA 5F,5F
00A4A:  DATA 5F,5F
00A4C:  DATA 5F,5F
00A4E:  DATA 0D,0A
00A50:  DATA 00,00
00A52:  DATA 5F,5F
00A54:  DATA 5F,53
00A56:  DATA 74,61
00A58:  DATA 72,74
00A5A:  DATA 20,73
00A5C:  DATA 6D,66
00A5E:  DATA 5F,65
00A60:  DATA 72,61
00A62:  DATA 73,65
00A64:  DATA 5F,5F
00A66:  DATA 5F,5F
00A68:  DATA 0D,0A
00A6A:  DATA 00,00
00A6C:  DATA 49,6E
00A6E:  DATA 20,53
00A70:  DATA 4D,46
00A72:  DATA 20,45
00A74:  DATA 72,61
00A76:  DATA 73,65
00A78:  DATA 20,73
00A7A:  DATA 6F,75
00A7C:  DATA 72,63
00A7E:  DATA 65,20
00A80:  DATA 64,61
00A82:  DATA 74,61
00A84:  DATA 20,61
00A86:  DATA 64,64
00A88:  DATA 72,65
00A8A:  DATA 73,73
00A8C:  DATA 3A,20
00A8E:  DATA 25,4C
00A90:  DATA 58,0D
00A92:  DATA 0A,00
00A94:  DATA 49,6E
00A96:  DATA 20,53
00A98:  DATA 4D,46
00A9A:  DATA 20,45
00A9C:  DATA 72,61
00A9E:  DATA 73,65
00AA0:  DATA 20,64
00AA2:  DATA 61,74
00AA4:  DATA 61,20
00AA6:  DATA 73,69
00AA8:  DATA 7A,65
00AAA:  DATA 20,20
00AAC:  DATA 20,20
00AAE:  DATA 20,20
00AB0:  DATA 20,20
00AB2:  DATA 20,20
00AB4:  DATA 3A,20
00AB6:  DATA 25,6C
00AB8:  DATA 75,20
00ABA:  DATA 28,30
00ABC:  DATA 78,25
00ABE:  DATA 6C,78
00AC0:  DATA 29,0D
00AC2:  DATA 0A,0D
00AC4:  DATA 0A,00
00AC6:  DATA 45,72
00AC8:  DATA 72,6F
00ACA:  DATA 72,3A
00ACC:  DATA 20,53
00ACE:  DATA 4D,46
00AD0:  DATA 20,69
00AD2:  DATA 73,20
00AD4:  DATA 6E,6F
00AD6:  DATA 74,20
00AD8:  DATA 63,6F
00ADA:  DATA 6E,6E
00ADC:  DATA 65,63
00ADE:  DATA 74,65
00AE0:  DATA 64,0D
00AE2:  DATA 0A,00
00AE4:  DATA 45,72
00AE6:  DATA 72,6F
00AE8:  DATA 72,3A
00AEA:  DATA 20,45
00AEC:  DATA 72,61
00AEE:  DATA 73,65
00AF0:  DATA 20,73
00AF2:  DATA 6F,75
00AF4:  DATA 72,63
00AF6:  DATA 65,20
00AF8:  DATA 61,64
00AFA:  DATA 64,72
00AFC:  DATA 65,73
00AFE:  DATA 73,20
00B00:  DATA 30,78
00B02:  DATA 25,4C
00B04:  DATA 58,20
00B06:  DATA 69,73
00B08:  DATA 20,6F
00B0A:  DATA 75,74
00B0C:  DATA 73,69
00B0E:  DATA 64,65
00B10:  DATA 20,6D
00B12:  DATA 69,73
00B14:  DATA 73,69
00B16:  DATA 6F,6E
00B18:  DATA 20,72
00B1A:  DATA 61,6E
00B1C:  DATA 67,65
00B1E:  DATA 20,5B
00B20:  DATA 30,78
00B22:  DATA 25,4C
00B24:  DATA 58,20
00B26:  DATA 2D,20
00B28:  DATA 30,78
00B2A:  DATA 25,4C
00B2C:  DATA 58,5D
00B2E:  DATA 0D,0A
00B30:  DATA 00,00
00B32:  DATA 45,72
00B34:  DATA 72,6F
00B36:  DATA 72,3A
00B38:  DATA 20,45
00B3A:  DATA 72,61
00B3C:  DATA 73,65
00B3E:  DATA 20,6F
00B40:  DATA 70,65
00B42:  DATA 72,61
00B44:  DATA 74,69
00B46:  DATA 6F,6E
00B48:  DATA 20,77
00B4A:  DATA 6F,75
00B4C:  DATA 6C,64
00B4E:  DATA 20,65
00B50:  DATA 78,63
00B52:  DATA 65,65
00B54:  DATA 64,20
00B56:  DATA 6D,69
00B58:  DATA 73,73
00B5A:  DATA 69,6F
00B5C:  DATA 6E,20
00B5E:  DATA 65,6E
00B60:  DATA 64,20
00B62:  DATA 61,64
00B64:  DATA 64,72
00B66:  DATA 65,73
00B68:  DATA 73,20
00B6A:  DATA 30,78
00B6C:  DATA 25,4C
00B6E:  DATA 58,0D
00B70:  DATA 0A,00
00B72:  DATA 4C,69
00B74:  DATA 6D,69
00B76:  DATA 74,69
00B78:  DATA 6E,67
00B7A:  DATA 20,65
00B7C:  DATA 72,61
00B7E:  DATA 73,65
00B80:  DATA 20,73
00B82:  DATA 69,7A
00B84:  DATA 65,20
00B86:  DATA 74,6F
00B88:  DATA 20,73
00B8A:  DATA 74,61
00B8C:  DATA 79,20
00B8E:  DATA 77,69
00B90:  DATA 74,68
00B92:  DATA 69,6E
00B94:  DATA 20,6D
00B96:  DATA 69,73
00B98:  DATA 73,69
00B9A:  DATA 6F,6E
00B9C:  DATA 20,62
00B9E:  DATA 6F,75
00BA0:  DATA 6E,64
00BA2:  DATA 73,0D
00BA4:  DATA 0A,00
00BA6:  DATA 45,72
00BA8:  DATA 61,73
00BAA:  DATA 65,20
00BAC:  DATA 6F,70
00BAE:  DATA 65,72
00BB0:  DATA 61,74
00BB2:  DATA 69,6F
00BB4:  DATA 6E,20
00BB6:  DATA 76,61
00BB8:  DATA 6C,69
00BBA:  DATA 64,61
00BBC:  DATA 74,65
00BBE:  DATA 64,20
00BC0:  DATA 77,69
00BC2:  DATA 74,68
00BC4:  DATA 69,6E
00BC6:  DATA 20,6D
00BC8:  DATA 69,73
00BCA:  DATA 73,69
00BCC:  DATA 6F,6E
00BCE:  DATA 20,72
00BD0:  DATA 61,6E
00BD2:  DATA 67,65
00BD4:  DATA 0D,0A
00BD6:  DATA 00,00
00BD8:  DATA 0D,0A
00BDA:  DATA 5F,5F
00BDC:  DATA 5F,45
00BDE:  DATA 6E,64
00BE0:  DATA 20,73
00BE2:  DATA 6D,66
00BE4:  DATA 5F,65
00BE6:  DATA 72,61
00BE8:  DATA 73,65
00BEA:  DATA 5F,5F
00BEC:  DATA 5F,5F
00BEE:  DATA 0D,0A
00BF0:  DATA 00,00
00BF2:  DATA 5F,5F
00BF4:  DATA 5F,5F
00BF6:  DATA 5F,5F
00BF8:  DATA 5F,5F
00BFA:  DATA 5F,5F
00BFC:  DATA 5F,5F
00BFE:  DATA 5F,5F
00C00:  DATA 5F,5F
00C02:  DATA 5F,5F
00C04:  DATA 5F,5F
00C06:  DATA 0D,0A
00C08:  DATA 0D,0A
00C0A:  DATA 00,00
00C0C:  DATA 45,72
00C0E:  DATA 72,6F
00C10:  DATA 72,3A
00C12:  DATA 20,55
00C14:  DATA 6E,6B
00C16:  DATA 6E,6F
00C18:  DATA 77,6E
00C1A:  DATA 20,6D
00C1C:  DATA 69,73
00C1E:  DATA 73,69
00C20:  DATA 6F,6E
00C22:  DATA 5F,69
00C24:  DATA 64,3A
00C26:  DATA 20,25
00C28:  DATA 30,32
00C2A:  DATA 58,0D
00C2C:  DATA 0A,00
00C2E:  DATA 55,70
00C30:  DATA 64,61
00C32:  DATA 74,65
00C34:  DATA 64,20
00C36:  DATA 70,61
00C38:  DATA 72,74
00C3A:  DATA 69,74
00C3C:  DATA 69,6F
00C3E:  DATA 6E,20
00C40:  DATA 66,6F
00C42:  DATA 72,20
00C44:  DATA 6D,69
00C46:  DATA 73,73
00C48:  DATA 69,6F
00C4A:  DATA 6E,5F
00C4C:  DATA 69,64
00C4E:  DATA 20,25
00C50:  DATA 30,32
00C52:  DATA 58,3A
00C54:  DATA 20,75
00C56:  DATA 73,65
00C58:  DATA 64,5F
00C5A:  DATA 73,69
00C5C:  DATA 7A,65
00C5E:  DATA 3D,25
00C60:  DATA 6C,64
00C62:  DATA 2C,20
00C64:  DATA 6C,6F
00C66:  DATA 6F,70
00C68:  DATA 5F,63
00C6A:  DATA 6F,75
00C6C:  DATA 6E,74
00C6E:  DATA 65,72
00C70:  DATA 3D,25
00C72:  DATA 6C,64
00C74:  DATA 0D,0A
00C76:  DATA 00,00
00C78:  DATA 4D,49
00C7A:  DATA 53,53
00C7C:  DATA 49,4F
00C7E:  DATA 4E,20
00C80:  DATA 46,4C
00C82:  DATA 41,53
00C84:  DATA 48,20
00C86:  DATA 49,6E
00C88:  DATA 69,74
00C8A:  DATA 69,61
00C8C:  DATA 6C,69
00C8E:  DATA 7A,65
00C90:  DATA 0D,0A
00C92:  DATA 00,00
00C94:  DATA 09,5B
00C96:  DATA 4D,49
00C98:  DATA 53,20
00C9A:  DATA 46,4D
00C9C:  DATA 5D,20
00C9E:  DATA 43,6F
00CA0:  DATA 6E,6E
00CA2:  DATA 65,63
00CA4:  DATA 74,65
00CA6:  DATA 64,0D
00CA8:  DATA 0A,00
00CAA:  DATA 09,5B
00CAC:  DATA 4D,49
00CAE:  DATA 53,20
00CB0:  DATA 46,4D
00CB2:  DATA 5D,20
00CB4:  DATA 4E,6F
00CB6:  DATA 74,20
00CB8:  DATA 43,6F
00CBA:  DATA 6E,6E
00CBC:  DATA 65,63
00CBE:  DATA 74,65
00CC0:  DATA 64,0D
00CC2:  DATA 0A,00
00CC4:  DATA 09,5B
00CC6:  DATA 53,4D
00CC8:  DATA 46,5D
00CCA:  DATA 20,43
00CCC:  DATA 6F,6E
00CCE:  DATA 6E,65
00CD0:  DATA 63,74
00CD2:  DATA 65,64
00CD4:  DATA 0D,0A
00CD6:  DATA 00,00
00CD8:  DATA 09,5B
00CDA:  DATA 53,4D
00CDC:  DATA 46,5D
00CDE:  DATA 20,4E
00CE0:  DATA 6F,74
00CE2:  DATA 20,43
00CE4:  DATA 6F,6E
00CE6:  DATA 6E,65
00CE8:  DATA 63,74
00CEA:  DATA 65,64
00CEC:  DATA 0D,0A
00CEE:  DATA 00,00
00CF0:  DATA 09,5B
00CF2:  DATA 4D,49
00CF4:  DATA 53,20
00CF6:  DATA 46,4D
00CF8:  DATA 5D,20
00CFA:  DATA 43,52
00CFC:  DATA 43,20
00CFE:  DATA 65,72
00D00:  DATA 72,6F
00D02:  DATA 72,20
00D04:  DATA 2D,3E
00D06:  DATA 20,69
00D08:  DATA 6E,69
00D0A:  DATA 74,69
00D0C:  DATA 61,6C
00D0E:  DATA 69,7A
00D10:  DATA 65,20
00D12:  DATA 63,6F
00D14:  DATA 75,6E
00D16:  DATA 74,65
00D18:  DATA 72,73
00D1A:  DATA 0D,0A
00D1C:  DATA 00,00
00D1E:  DATA 09,7C
00D20:  DATA 20,4D
00D22:  DATA 49,53
00D24:  DATA 46,20
00D26:  DATA 7C,20
00D28:  DATA 50,49
00D2A:  DATA 43,4C
00D2C:  DATA 4F,47
00D2E:  DATA 20,20
00D30:  DATA 20,20
00D32:  DATA 7C,20
00D34:  DATA 55,73
00D36:  DATA 65,20
00D38:  DATA 43,6F
00D3A:  DATA 75,6E
00D3C:  DATA 74,65
00D3E:  DATA 72,20
00D40:  DATA 20,20
00D42:  DATA 20,20
00D44:  DATA 20,3A
00D46:  DATA 20,30
00D48:  DATA 78,25
00D4A:  DATA 30,38
00D4C:  DATA 4C,58
00D4E:  DATA 0D,0A
00D50:  DATA 00,00
00D52:  DATA 09,7C
00D54:  DATA 20,4D
00D56:  DATA 49,53
00D58:  DATA 46,20
00D5A:  DATA 7C,20
00D5C:  DATA 50,49
00D5E:  DATA 43,4C
00D60:  DATA 4F,47
00D62:  DATA 20,20
00D64:  DATA 20,20
00D66:  DATA 7C,20
00D68:  DATA 55,6E
00D6A:  DATA 63,6F
00D6C:  DATA 70,79
00D6E:  DATA 65,64
00D70:  DATA 20,43
00D72:  DATA 6F,75
00D74:  DATA 6E,74
00D76:  DATA 65,72
00D78:  DATA 20,3A
00D7A:  DATA 20,30
00D7C:  DATA 78,25
00D7E:  DATA 30,38
00D80:  DATA 4C,58
00D82:  DATA 0D,0A
00D84:  DATA 00,00
00D86:  DATA 09,7C
00D88:  DATA 20,4D
00D8A:  DATA 49,53
00D8C:  DATA 46,20
00D8E:  DATA 7C,20
00D90:  DATA 50,49
00D92:  DATA 43,4C
00D94:  DATA 4F,47
00D96:  DATA 20,20
00D98:  DATA 20,20
00D9A:  DATA 7C,20
00D9C:  DATA 52,65
00D9E:  DATA 73,65
00DA0:  DATA 72,76
00DA2:  DATA 65,20
00DA4:  DATA 43,6F
00DA6:  DATA 75,6E
00DA8:  DATA 74,65
00DAA:  DATA 72,31
00DAC:  DATA 20,3A
00DAE:  DATA 20,30
00DB0:  DATA 78,25
00DB2:  DATA 30,32
00DB4:  DATA 58,0D
00DB6:  DATA 0A,00
00DB8:  DATA 09,7C
00DBA:  DATA 20,4D
00DBC:  DATA 49,53
00DBE:  DATA 46,20
00DC0:  DATA 7C,20
00DC2:  DATA 50,49
00DC4:  DATA 43,4C
00DC6:  DATA 4F,47
00DC8:  DATA 20,20
00DCA:  DATA 20,20
00DCC:  DATA 7C,20
00DCE:  DATA 52,65
00DD0:  DATA 73,65
00DD2:  DATA 72,76
00DD4:  DATA 65,20
00DD6:  DATA 43,6F
00DD8:  DATA 75,6E
00DDA:  DATA 74,65
00DDC:  DATA 72,32
00DDE:  DATA 20,3A
00DE0:  DATA 20,30
00DE2:  DATA 78,25
00DE4:  DATA 30,32
00DE6:  DATA 58,0D
00DE8:  DATA 0A,00
00DEA:  DATA 09,7C
00DEC:  DATA 20,4D
00DEE:  DATA 49,53
00DF0:  DATA 46,20
00DF2:  DATA 7C,20
00DF4:  DATA 45,4E
00DF6:  DATA 56,49
00DF8:  DATA 52,4F
00DFA:  DATA 20,20
00DFC:  DATA 20,20
00DFE:  DATA 7C,20
00E00:  DATA 55,73
00E02:  DATA 65,20
00E04:  DATA 43,6F
00E06:  DATA 75,6E
00E08:  DATA 74,65
00E0A:  DATA 72,20
00E0C:  DATA 20,20
00E0E:  DATA 20,20
00E10:  DATA 20,3A
00E12:  DATA 20,30
00E14:  DATA 78,25
00E16:  DATA 30,38
00E18:  DATA 4C,58
00E1A:  DATA 0D,0A
00E1C:  DATA 00,00
00E1E:  DATA 09,7C
00E20:  DATA 20,4D
00E22:  DATA 49,53
00E24:  DATA 46,20
00E26:  DATA 7C,20
00E28:  DATA 45,4E
00E2A:  DATA 56,49
00E2C:  DATA 52,4F
00E2E:  DATA 20,20
00E30:  DATA 20,20
00E32:  DATA 7C,20
00E34:  DATA 55,6E
00E36:  DATA 63,6F
00E38:  DATA 70,79
00E3A:  DATA 65,64
00E3C:  DATA 20,43
00E3E:  DATA 6F,75
00E40:  DATA 6E,74
00E42:  DATA 65,72
00E44:  DATA 20,3A
00E46:  DATA 20,30
00E48:  DATA 78,25
00E4A:  DATA 30,38
00E4C:  DATA 4C,58
00E4E:  DATA 0D,0A
00E50:  DATA 00,00
00E52:  DATA 09,7C
00E54:  DATA 20,4D
00E56:  DATA 49,53
00E58:  DATA 46,20
00E5A:  DATA 7C,20
00E5C:  DATA 45,4E
00E5E:  DATA 56,49
00E60:  DATA 52,4F
00E62:  DATA 20,20
00E64:  DATA 20,20
00E66:  DATA 7C,20
00E68:  DATA 52,65
00E6A:  DATA 73,65
00E6C:  DATA 72,76
00E6E:  DATA 65,20
00E70:  DATA 43,6F
00E72:  DATA 75,6E
00E74:  DATA 74,65
00E76:  DATA 72,31
00E78:  DATA 20,3A
00E7A:  DATA 20,30
00E7C:  DATA 78,25
00E7E:  DATA 30,32
00E80:  DATA 58,0D
00E82:  DATA 0A,00
00E84:  DATA 09,7C
00E86:  DATA 20,4D
00E88:  DATA 49,53
00E8A:  DATA 46,20
00E8C:  DATA 7C,20
00E8E:  DATA 45,4E
00E90:  DATA 56,49
00E92:  DATA 52,4F
00E94:  DATA 20,20
00E96:  DATA 20,20
00E98:  DATA 7C,20
00E9A:  DATA 52,65
00E9C:  DATA 73,65
00E9E:  DATA 72,76
00EA0:  DATA 65,20
00EA2:  DATA 43,6F
00EA4:  DATA 75,6E
00EA6:  DATA 74,65
00EA8:  DATA 72,32
00EAA:  DATA 20,3A
00EAC:  DATA 20,30
00EAE:  DATA 78,25
00EB0:  DATA 30,32
00EB2:  DATA 58,0D
00EB4:  DATA 0A,00
00EB6:  DATA 09,7C
00EB8:  DATA 20,4D
00EBA:  DATA 49,53
00EBC:  DATA 46,20
00EBE:  DATA 7C,20
00EC0:  DATA 49,56
00EC2:  DATA 20,48
00EC4:  DATA 45,41
00EC6:  DATA 44,45
00EC8:  DATA 52,20
00ECA:  DATA 7C,20
00ECC:  DATA 55,73
00ECE:  DATA 65,20
00ED0:  DATA 43,6F
00ED2:  DATA 75,6E
00ED4:  DATA 74,65
00ED6:  DATA 72,20
00ED8:  DATA 20,20
00EDA:  DATA 20,20
00EDC:  DATA 20,3A
00EDE:  DATA 20,30
00EE0:  DATA 78,25
00EE2:  DATA 30,38
00EE4:  DATA 4C,58
00EE6:  DATA 0D,0A
00EE8:  DATA 00,00
00EEA:  DATA 09,7C
00EEC:  DATA 20,4D
00EEE:  DATA 49,53
00EF0:  DATA 46,20
00EF2:  DATA 7C,20
00EF4:  DATA 49,56
00EF6:  DATA 20,48
00EF8:  DATA 45,41
00EFA:  DATA 44,45
00EFC:  DATA 52,20
00EFE:  DATA 7C,20
00F00:  DATA 55,6E
00F02:  DATA 63,6F
00F04:  DATA 70,79
00F06:  DATA 65,64
00F08:  DATA 20,43
00F0A:  DATA 6F,75
00F0C:  DATA 6E,74
00F0E:  DATA 65,72
00F10:  DATA 20,3A
00F12:  DATA 20,30
00F14:  DATA 78,25
00F16:  DATA 30,38
00F18:  DATA 4C,58
00F1A:  DATA 0D,0A
00F1C:  DATA 00,00
00F1E:  DATA 09,7C
00F20:  DATA 20,4D
00F22:  DATA 49,53
00F24:  DATA 46,20
00F26:  DATA 7C,20
00F28:  DATA 49,56
00F2A:  DATA 20,48
00F2C:  DATA 45,41
00F2E:  DATA 44,45
00F30:  DATA 52,20
00F32:  DATA 7C,20
00F34:  DATA 52,65
00F36:  DATA 73,65
00F38:  DATA 72,76
00F3A:  DATA 65,20
00F3C:  DATA 43,6F
00F3E:  DATA 75,6E
00F40:  DATA 74,65
00F42:  DATA 72,31
00F44:  DATA 20,3A
00F46:  DATA 20,30
00F48:  DATA 78,25
00F4A:  DATA 30,32
00F4C:  DATA 58,0D
00F4E:  DATA 0A,00
00F50:  DATA 09,7C
00F52:  DATA 20,4D
00F54:  DATA 49,53
00F56:  DATA 46,20
00F58:  DATA 7C,20
00F5A:  DATA 49,56
00F5C:  DATA 20,48
00F5E:  DATA 45,41
00F60:  DATA 44,45
00F62:  DATA 52,20
00F64:  DATA 7C,20
00F66:  DATA 52,65
00F68:  DATA 73,65
00F6A:  DATA 72,76
00F6C:  DATA 65,20
00F6E:  DATA 43,6F
00F70:  DATA 75,6E
00F72:  DATA 74,65
00F74:  DATA 72,32
00F76:  DATA 20,3A
00F78:  DATA 20,30
00F7A:  DATA 78,25
00F7C:  DATA 30,32
00F7E:  DATA 58,0D
00F80:  DATA 0A,00
00F82:  DATA 09,7C
00F84:  DATA 20,4D
00F86:  DATA 49,53
00F88:  DATA 46,20
00F8A:  DATA 7C,20
00F8C:  DATA 49,56
00F8E:  DATA 20,44
00F90:  DATA 41,54
00F92:  DATA 41,20
00F94:  DATA 20,20
00F96:  DATA 7C,20
00F98:  DATA 55,73
00F9A:  DATA 65,20
00F9C:  DATA 43,6F
00F9E:  DATA 75,6E
00FA0:  DATA 74,65
00FA2:  DATA 72,20
00FA4:  DATA 20,20
00FA6:  DATA 20,20
00FA8:  DATA 20,3A
00FAA:  DATA 20,30
00FAC:  DATA 78,25
00FAE:  DATA 30,38
00FB0:  DATA 4C,58
00FB2:  DATA 0D,0A
00FB4:  DATA 00,00
00FB6:  DATA 09,7C
00FB8:  DATA 20,4D
00FBA:  DATA 49,53
00FBC:  DATA 46,20
00FBE:  DATA 7C,20
00FC0:  DATA 49,56
00FC2:  DATA 20,44
00FC4:  DATA 41,54
00FC6:  DATA 41,20
00FC8:  DATA 20,20
00FCA:  DATA 7C,20
00FCC:  DATA 55,6E
00FCE:  DATA 63,6F
00FD0:  DATA 70,79
00FD2:  DATA 65,64
00FD4:  DATA 20,43
00FD6:  DATA 6F,75
00FD8:  DATA 6E,74
00FDA:  DATA 65,72
00FDC:  DATA 20,3A
00FDE:  DATA 20,30
00FE0:  DATA 78,25
00FE2:  DATA 30,38
00FE4:  DATA 4C,58
00FE6:  DATA 0D,0A
00FE8:  DATA 00,00
00FEA:  DATA 09,7C
00FEC:  DATA 20,4D
00FEE:  DATA 49,53
00FF0:  DATA 46,20
00FF2:  DATA 7C,20
00FF4:  DATA 49,56
00FF6:  DATA 20,44
00FF8:  DATA 41,54
00FFA:  DATA 41,20
00FFC:  DATA 20,20
00FFE:  DATA 7C,20
01000:  DATA 52,65
01002:  DATA 73,65
01004:  DATA 72,76
01006:  DATA 65,20
01008:  DATA 43,6F
0100A:  DATA 75,6E
0100C:  DATA 74,65
0100E:  DATA 72,31
01010:  DATA 20,3A
01012:  DATA 20,30
01014:  DATA 78,25
01016:  DATA 30,32
01018:  DATA 58,0D
0101A:  DATA 0A,00
0101C:  DATA 09,7C
0101E:  DATA 20,4D
01020:  DATA 49,53
01022:  DATA 46,20
01024:  DATA 7C,20
01026:  DATA 49,56
01028:  DATA 20,44
0102A:  DATA 41,54
0102C:  DATA 41,20
0102E:  DATA 20,20
01030:  DATA 7C,20
01032:  DATA 52,65
01034:  DATA 73,65
01036:  DATA 72,76
01038:  DATA 65,20
0103A:  DATA 43,6F
0103C:  DATA 75,6E
0103E:  DATA 74,65
01040:  DATA 72,32
01042:  DATA 20,3A
01044:  DATA 20,30
01046:  DATA 78,25
01048:  DATA 30,32
0104A:  DATA 58,0D
0104C:  DATA 0A,00
0104E:  DATA 09,43
01050:  DATA 6F,6D
01052:  DATA 70,6C
01054:  DATA 65,74
01056:  DATA 65,0D
01058:  DATA 0A,00
0105A:  DATA 43,52
0105C:  DATA 43,20
0105E:  DATA 76,65
01060:  DATA 72,69
01062:  DATA 66,69
01064:  DATA 63,61
01066:  DATA 74,69
01068:  DATA 6F,6E
0106A:  DATA 20,70
0106C:  DATA 61,73
0106E:  DATA 73,65
01070:  DATA 64,20
01072:  DATA 6F,6E
01074:  DATA 20,61
01076:  DATA 74,74
01078:  DATA 65,6D
0107A:  DATA 70,74
0107C:  DATA 20,25
0107E:  DATA 64,0D
01080:  DATA 0A,00
01082:  DATA 45,72
01084:  DATA 72,6F
01086:  DATA 72,3A
01088:  DATA 20,43
0108A:  DATA 52,43
0108C:  DATA 20,76
0108E:  DATA 65,72
01090:  DATA 69,66
01092:  DATA 69,63
01094:  DATA 61,74
01096:  DATA 69,6F
01098:  DATA 6E,20
0109A:  DATA 66,61
0109C:  DATA 69,6C
0109E:  DATA 65,64
010A0:  DATA 20,61
010A2:  DATA 66,74
010A4:  DATA 65,72
010A6:  DATA 20,25
010A8:  DATA 64,20
010AA:  DATA 61,74
010AC:  DATA 74,65
010AE:  DATA 6D,70
010B0:  DATA 74,73
010B2:  DATA 0D,0A
010B4:  DATA 00,00
010B6:  DATA 0D,0A
010B8:  DATA 5F,5F
010BA:  DATA 5F,5F
010BC:  DATA 5F,5F
010BE:  DATA 5F,5F
010C0:  DATA 5F,5F
010C2:  DATA 5F,5F
010C4:  DATA 5F,5F
010C6:  DATA 5F,5F
010C8:  DATA 5F,5F
010CA:  DATA 5F,5F
010CC:  DATA 5F,5F
010CE:  DATA 5F,5F
010D0:  DATA 5F,5F
010D2:  DATA 5F,5F
010D4:  DATA 5F,5F
010D6:  DATA 0D,0A
010D8:  DATA 5F,5F
010DA:  DATA 5F,5F
010DC:  DATA 5F,53
010DE:  DATA 74,61
010E0:  DATA 72,74
010E2:  DATA 20,65
010E4:  DATA 78,65
010E6:  DATA 63,75
010E8:  DATA 74,65
010EA:  DATA 5F,6D
010EC:  DATA 69,73
010EE:  DATA 73,69
010F0:  DATA 6F,6E
010F2:  DATA 5F,5F
010F4:  DATA 5F,5F
010F6:  DATA 5F,0D
010F8:  DATA 0A,0D
010FA:  DATA 0A,00
010FC:  DATA 43,6F
010FE:  DATA 6D,6D
01100:  DATA 61,6E
01102:  DATA 64,20
01104:  DATA 49,44
01106:  DATA 3A,20
01108:  DATA 25,58
0110A:  DATA 0D,0A
0110C:  DATA 0D,0A
0110E:  DATA 00,00
01110:  DATA 09,09
01112:  DATA 2D,3E
01114:  DATA 20,49
01116:  DATA 6E,76
01118:  DATA 61,6C
0111A:  DATA 69,64
0111C:  DATA 20,43
0111E:  DATA 4D,44
01120:  DATA 20,49
01122:  DATA 44,21
01124:  DATA 0D,0A
01126:  DATA 00,00
01128:  DATA 0D,0A
0112A:  DATA 5F,5F
0112C:  DATA 5F,5F
0112E:  DATA 5F,5F
01130:  DATA 45,6E
01132:  DATA 64,20
01134:  DATA 65,78
01136:  DATA 65,63
01138:  DATA 75,74
0113A:  DATA 65,5F
0113C:  DATA 6D,69
0113E:  DATA 73,73
01140:  DATA 69,6F
01142:  DATA 6E,5F
01144:  DATA 5F,5F
01146:  DATA 5F,5F
01148:  DATA 5F,0D
0114A:  DATA 0A,5F
0114C:  DATA 5F,5F
0114E:  DATA 5F,5F
01150:  DATA 5F,5F
01152:  DATA 5F,5F
01154:  DATA 5F,5F
01156:  DATA 5F,5F
01158:  DATA 5F,5F
0115A:  DATA 5F,5F
0115C:  DATA 5F,5F
0115E:  DATA 5F,5F
01160:  DATA 5F,5F
01162:  DATA 5F,5F
01164:  DATA 5F,5F
01166:  DATA 5F,5F
01168:  DATA 5F,5F
0116A:  DATA 0D,0A
0116C:  DATA 00,00
0116E:  DATA 53,74
01170:  DATA 61,72
01172:  DATA 74,20
01174:  DATA 65,78
01176:  DATA 65,63
01178:  DATA 75,74
0117A:  DATA 65,5F
0117C:  DATA 63,6F
0117E:  DATA 6D,6D
01180:  DATA 61,6E
01182:  DATA 64,0D
01184:  DATA 0A,00
01186:  DATA 09,2D
01188:  DATA 3E,20
0118A:  DATA 55,70
0118C:  DATA 6C,69
0118E:  DATA 6E,6B
01190:  DATA 20,63
01192:  DATA 6F,6D
01194:  DATA 6D,61
01196:  DATA 6E,64
01198:  DATA 0D,0A
0119A:  DATA 00,00
0119C:  DATA 09,20
0119E:  DATA 20,20
011A0:  DATA 54,72
011A2:  DATA 61,6E
011A4:  DATA 73,6D
011A6:  DATA 69,74
011A8:  DATA 20,41
011AA:  DATA 63,6B
011AC:  DATA 6E,6F
011AE:  DATA 6C,65
011B0:  DATA 67,64
011B2:  DATA 65,0D
011B4:  DATA 0A,00
011B6:  DATA 09,2D
011B8:  DATA 3E,20
011BA:  DATA 53,74
011BC:  DATA 61,74
011BE:  DATA 75,73
011C0:  DATA 20,63
011C2:  DATA 68,65
011C4:  DATA 63,6B
011C6:  DATA 0D,0A
011C8:  DATA 00,00
011CA:  DATA 09,20
011CC:  DATA 20,20
011CE:  DATA 54,72
011D0:  DATA 61,6E
011D2:  DATA 73,6D
011D4:  DATA 69,74
011D6:  DATA 20,4D
011D8:  DATA 49,53
011DA:  DATA 20,4D
011DC:  DATA 43,55
011DE:  DATA 20,53
011E0:  DATA 74,61
011E2:  DATA 74,75
011E4:  DATA 73,0D
011E6:  DATA 0A,00
011E8:  DATA 66,69
011EA:  DATA 6E,69
011EC:  DATA 73,68
011EE:  DATA 65,64
011F0:  DATA 20,69
011F2:  DATA 6E,20
011F4:  DATA 73,74
011F6:  DATA 61,74
011F8:  DATA 75,73
011FA:  DATA 5F,63
011FC:  DATA 68,65
011FE:  DATA 63,6B
01200:  DATA 0D,0A
01202:  DATA 00,00
01204:  DATA 09,2D
01206:  DATA 3E,20
01208:  DATA 53,4D
0120A:  DATA 46,20
0120C:  DATA 61,76
0120E:  DATA 61,69
01210:  DATA 6C,61
01212:  DATA 62,6C
01214:  DATA 65,20
01216:  DATA 63,68
01218:  DATA 65,63
0121A:  DATA 6B,0D
0121C:  DATA 0A,00
0121E:  DATA 09,20
01220:  DATA 20,20
01222:  DATA 54,72
01224:  DATA 61,6E
01226:  DATA 73,6D
01228:  DATA 69,74
0122A:  DATA 20,41
0122C:  DATA 63,6B
0122E:  DATA 6E,6F
01230:  DATA 77,6C
01232:  DATA 65,64
01234:  DATA 67,65
01236:  DATA 6D,65
01238:  DATA 6E,74
0123A:  DATA 0D,0A
0123C:  DATA 00,00
0123E:  DATA 09,09
01240:  DATA 2D,3E
01242:  DATA 20,64
01244:  DATA 65,6E
01246:  DATA 69,65
01248:  DATA 64,0D
0124A:  DATA 0A,00
0124C:  DATA 09,09
0124E:  DATA 2D,3E
01250:  DATA 20,61
01252:  DATA 6C,6C
01254:  DATA 6F,77
01256:  DATA 65,64
01258:  DATA 0D,0A
0125A:  DATA 00,00
0125C:  DATA 09,09
0125E:  DATA 2D,3E
01260:  DATA 20,64
01262:  DATA 65,71
01264:  DATA 75,65
01266:  DATA 75,65
01268:  DATA 20,4E
0126A:  DATA 55,4C
0126C:  DATA 4C,20
0126E:  DATA 28,62
01270:  DATA 72,65
01272:  DATA 61,6B
01274:  DATA 29,0D
01276:  DATA 0A,00
01278:  DATA 09,09
0127A:  DATA 2D,3E
0127C:  DATA 20,44
0127E:  DATA 65,71
01280:  DATA 75,65
01282:  DATA 75,65
01284:  DATA 64,3A
01286:  DATA 20,66
01288:  DATA 75,6E
0128A:  DATA 63,3D
0128C:  DATA 25,75
0128E:  DATA 20,6D
01290:  DATA 69,73
01292:  DATA 73,69
01294:  DATA 6F,6E
01296:  DATA 3D,25
01298:  DATA 75,20
0129A:  DATA 73,69
0129C:  DATA 7A,65
0129E:  DATA 3D,25
012A0:  DATA 6C,64
012A2:  DATA 20,61
012A4:  DATA 64,64
012A6:  DATA 72,3D
012A8:  DATA 25,6C
012AA:  DATA 64,0D
012AC:  DATA 0A,00
012AE:  DATA 09,09
012B0:  DATA 20,20
012B2:  DATA 20,55
012B4:  DATA 6E,6B
012B6:  DATA 6E,6F
012B8:  DATA 77,6E
012BA:  DATA 20,66
012BC:  DATA 75,6E
012BE:  DATA 63,5F
012C0:  DATA 74,79
012C2:  DATA 70,65
012C4:  DATA 3D,25
012C6:  DATA 75,0D
012C8:  DATA 0A,00
012CA:  DATA 09,09
012CC:  DATA 2D,3E
012CE:  DATA 20,43
012D0:  DATA 6F,6D
012D2:  DATA 70,6C
012D4:  DATA 65,74
012D6:  DATA 65,64
012D8:  DATA 20,25
012DA:  DATA 75,20
012DC:  DATA 6F,70
012DE:  DATA 65,72
012E0:  DATA 61,74
012E2:  DATA 69,6F
012E4:  DATA 6E,73
012E6:  DATA 0D,0A
012E8:  DATA 00,00
012EA:  DATA 53,74
012EC:  DATA 61,72
012EE:  DATA 74,20
012F0:  DATA 4D,4F
012F2:  DATA 44,45
012F4:  DATA 20,44
012F6:  DATA 55,4D
012F8:  DATA 4D,59
012FA:  DATA 0D,0A
012FC:  DATA 00,00
012FE:  DATA 09,4D
01300:  DATA 4F,44
01302:  DATA 45,20
01304:  DATA 20,20
01306:  DATA 20,20
01308:  DATA 3A,20
0130A:  DATA 25,30
0130C:  DATA 32,58
0130E:  DATA 0D,0A
01310:  DATA 00,00
01312:  DATA 09,50
01314:  DATA 61,72
01316:  DATA 61,6D
01318:  DATA 31,20
0131A:  DATA 20,20
0131C:  DATA 3A,20
0131E:  DATA 30,78
01320:  DATA 25,30
01322:  DATA 38,4C
01324:  DATA 58,0D
01326:  DATA 0A,00
01328:  DATA 09,50
0132A:  DATA 61,72
0132C:  DATA 61,6D
0132E:  DATA 32,20
01330:  DATA 20,20
01332:  DATA 3A,20
01334:  DATA 30,78
01336:  DATA 25,30
01338:  DATA 34,4C
0133A:  DATA 58,0D
0133C:  DATA 0A,00
0133E:  DATA 45,6E
01340:  DATA 64,20
01342:  DATA 4D,4F
01344:  DATA 44,45
01346:  DATA 20,44
01348:  DATA 55,4D
0134A:  DATA 4D,59
0134C:  DATA 0D,0A
0134E:  DATA 00,00
01350:  DATA 53,74
01352:  DATA 61,72
01354:  DATA 74,20
01356:  DATA 4D,4F
01358:  DATA 44,45
0135A:  DATA 20,54
0135C:  DATA 45,53
0135E:  DATA 54,20
01360:  DATA 49,56
01362:  DATA 0D,0A
01364:  DATA 00,00
01366:  DATA 09,53
01368:  DATA 77,65
0136A:  DATA 65,70
0136C:  DATA 20,73
0136E:  DATA 74,65
01370:  DATA 70,20
01372:  DATA 3A,20
01374:  DATA 25,75
01376:  DATA 0D,0A
01378:  DATA 00,00
0137A:  DATA 45,6E
0137C:  DATA 64,20
0137E:  DATA 4D,4F
01380:  DATA 44,45
01382:  DATA 20,54
01384:  DATA 45,53
01386:  DATA 54,20
01388:  DATA 49,56
0138A:  DATA 0D,0A
0138C:  DATA 00,00
0138E:  DATA 53,74
01390:  DATA 61,72
01392:  DATA 74,20
01394:  DATA 4D,4F
01396:  DATA 44,45
01398:  DATA 20,4D
0139A:  DATA 45,41
0139C:  DATA 53,20
0139E:  DATA 49,56
013A0:  DATA 0D,0A
013A2:  DATA 00,00
013A4:  DATA 09,49
013A6:  DATA 44,3A
013A8:  DATA 20,25
013AA:  DATA 30,32
013AC:  DATA 58,0D
013AE:  DATA 0A,00
013B0:  DATA 09,53
013B2:  DATA 6C,65
013B4:  DATA 65,70
013B6:  DATA 20,54
013B8:  DATA 69,6D
013BA:  DATA 65,3A
013BC:  DATA 20,25
013BE:  DATA 30,34
013C0:  DATA 4C,58
013C2:  DATA 20,6D
013C4:  DATA 73,0D
013C6:  DATA 0A,00
013C8:  DATA 09,43
013CA:  DATA 75,72
013CC:  DATA 72,65
013CE:  DATA 6E,74
013D0:  DATA 20,54
013D2:  DATA 68,72
013D4:  DATA 65,73
013D6:  DATA 68,6F
013D8:  DATA 6C,64
013DA:  DATA 3A,20
013DC:  DATA 25,30
013DE:  DATA 34,4C
013E0:  DATA 58,20
013E2:  DATA 6D,41
013E4:  DATA 0D,0A
013E6:  DATA 00,00
013E8:  DATA 09,50
013EA:  DATA 44,20
013EC:  DATA 54,68
013EE:  DATA 72,65
013F0:  DATA 73,68
013F2:  DATA 6F,6C
013F4:  DATA 64,3A
013F6:  DATA 20,25
013F8:  DATA 30,34
013FA:  DATA 4C,58
013FC:  DATA 20,6D
013FE:  DATA 41,0D
01400:  DATA 0A,00
01402:  DATA 09,43
01404:  DATA 75,72
01406:  DATA 72,65
01408:  DATA 6E,74
0140A:  DATA 20,4C
0140C:  DATA 69,6D
0140E:  DATA 69,74
01410:  DATA 3A,20
01412:  DATA 25,30
01414:  DATA 34,4C
01416:  DATA 58,20
01418:  DATA 6D,41
0141A:  DATA 0D,0A
0141C:  DATA 00,00
0141E:  DATA 09,4D
01420:  DATA 65,61
01422:  DATA 73,75
01424:  DATA 72,65
01426:  DATA 6D,65
01428:  DATA 6E,74
0142A:  DATA 20,54
0142C:  DATA 69,6D
0142E:  DATA 65,3A
01430:  DATA 20,25
01432:  DATA 30,34
01434:  DATA 4C,58
01436:  DATA 20,73
01438:  DATA 0D,0A
0143A:  DATA 00,00
0143C:  DATA 09,49
0143E:  DATA 73,20
01440:  DATA 46,69
01442:  DATA 6E,69
01444:  DATA 73,68
01446:  DATA 65,64
01448:  DATA 3A,20
0144A:  DATA 25,75
0144C:  DATA 0D,0A
0144E:  DATA 00,00
01450:  DATA 45,6E
01452:  DATA 71,75
01454:  DATA 65,75
01456:  DATA 65,20
01458:  DATA 46,6C
0145A:  DATA 61,73
0145C:  DATA 68,20
0145E:  DATA 4F,70
01460:  DATA 65,72
01462:  DATA 61,74
01464:  DATA 69,6F
01466:  DATA 6E,0D
01468:  DATA 0A,00
0146A:  DATA 4D,69
0146C:  DATA 73,73
0146E:  DATA 69,6F
01470:  DATA 6E,20
01472:  DATA 49,44
01474:  DATA 3A,20
01476:  DATA 20,20
01478:  DATA 25,30
0147A:  DATA 32,58
0147C:  DATA 0D,0A
0147E:  DATA 00,00
01480:  DATA 46,75
01482:  DATA 6E,63
01484:  DATA 74,69
01486:  DATA 6F,6E
01488:  DATA 20,54
0148A:  DATA 79,70
0148C:  DATA 65,3A
0148E:  DATA 25,30
01490:  DATA 32,58
01492:  DATA 0D,0A
01494:  DATA 00,00
01496:  DATA 57,72
01498:  DATA 69,74
0149A:  DATA 65,20
0149C:  DATA 4D,6F
0149E:  DATA 64,65
014A0:  DATA 3A,20
014A2:  DATA 20,20
014A4:  DATA 25,30
014A6:  DATA 32,58
014A8:  DATA 0D,0A
014AA:  DATA 00,00
014AC:  DATA 53,6F
014AE:  DATA 75,72
014B0:  DATA 63,65
014B2:  DATA 20,54
014B4:  DATA 79,70
014B6:  DATA 65,3A
014B8:  DATA 20,20
014BA:  DATA 25,30
014BC:  DATA 32,58
014BE:  DATA 0D,0A
014C0:  DATA 00,00
014C2:  DATA 53,74
014C4:  DATA 61,72
014C6:  DATA 74,20
014C8:  DATA 41,64
014CA:  DATA 64,72
014CC:  DATA 65,73
014CE:  DATA 73,3A
014D0:  DATA 25,30
014D2:  DATA 34,58
014D4:  DATA 0D,0A
014D6:  DATA 00,00
014D8:  DATA 53,69
014DA:  DATA 7A,65
014DC:  DATA 3A,20
014DE:  DATA 20,20
014E0:  DATA 20,20
014E2:  DATA 20,20
014E4:  DATA 20,20
014E6:  DATA 25,30
014E8:  DATA 34,58
014EA:  DATA 0D,0A
014EC:  DATA 00,00
014EE:  DATA 45,6E
014F0:  DATA 64,20
014F2:  DATA 4D,4F
014F4:  DATA 44,45
014F6:  DATA 20,4D
014F8:  DATA 45,41
014FA:  DATA 53,20
014FC:  DATA 49,56
014FE:  DATA 20,6D
01500:  DATA 69,73
01502:  DATA 73,69
01504:  DATA 6F,6E
01506:  DATA 0D,0A
01508:  DATA 00,00
0150A:  DATA 53,74
0150C:  DATA 61,72
0150E:  DATA 74,20
01510:  DATA 46,6C
01512:  DATA 61,73
01514:  DATA 68,20
01516:  DATA 45,72
01518:  DATA 61,73
0151A:  DATA 65,20
0151C:  DATA 41,6C
0151E:  DATA 6C,0D
01520:  DATA 0A,00
01522:  DATA 45,6E
01524:  DATA 64,20
01526:  DATA 46,6C
01528:  DATA 61,73
0152A:  DATA 68,20
0152C:  DATA 45,72
0152E:  DATA 61,73
01530:  DATA 65,20
01532:  DATA 41,6C
01534:  DATA 6C,0D
01536:  DATA 0A,00
01538:  DATA 53,74
0153A:  DATA 61,72
0153C:  DATA 74,20
0153E:  DATA 46,6C
01540:  DATA 61,73
01542:  DATA 68,20
01544:  DATA 45,72
01546:  DATA 61,73
01548:  DATA 65,20
0154A:  DATA 31,20
0154C:  DATA 53,65
0154E:  DATA 63,74
01550:  DATA 6F,72
01552:  DATA 0D,0A
01554:  DATA 00,00
01556:  DATA 09,53
01558:  DATA 65,63
0155A:  DATA 74,6F
0155C:  DATA 72,20
0155E:  DATA 41,64
01560:  DATA 64,72
01562:  DATA 65,73
01564:  DATA 73,3A
01566:  DATA 20,30
01568:  DATA 78,25
0156A:  DATA 30,38
0156C:  DATA 4C,58
0156E:  DATA 0D,0A
01570:  DATA 00,00
01572:  DATA 45,6E
01574:  DATA 64,20
01576:  DATA 46,6C
01578:  DATA 61,73
0157A:  DATA 68,20
0157C:  DATA 45,72
0157E:  DATA 61,73
01580:  DATA 65,20
01582:  DATA 31,20
01584:  DATA 53,65
01586:  DATA 63,74
01588:  DATA 6F,72
0158A:  DATA 0D,0A
0158C:  DATA 00,00
0158E:  DATA 53,74
01590:  DATA 61,72
01592:  DATA 74,20
01594:  DATA 46,6C
01596:  DATA 61,73
01598:  DATA 68,20
0159A:  DATA 43,6F
0159C:  DATA 70,79
0159E:  DATA 20,31
015A0:  DATA 20,53
015A2:  DATA 65,63
015A4:  DATA 74,6F
015A6:  DATA 72,0D
015A8:  DATA 0A,00
015AA:  DATA 09,53
015AC:  DATA 75,62
015AE:  DATA 73,65
015B0:  DATA 63,74
015B2:  DATA 6F,72
015B4:  DATA 20,41
015B6:  DATA 64,64
015B8:  DATA 72,65
015BA:  DATA 73,73
015BC:  DATA 3A,20
015BE:  DATA 30,78
015C0:  DATA 25,30
015C2:  DATA 38,4C
015C4:  DATA 58,0D
015C6:  DATA 0A,00
015C8:  DATA 45,6E
015CA:  DATA 64,20
015CC:  DATA 46,6C
015CE:  DATA 61,73
015D0:  DATA 68,20
015D2:  DATA 43,6F
015D4:  DATA 70,79
015D6:  DATA 20,31
015D8:  DATA 20,53
015DA:  DATA 65,63
015DC:  DATA 74,6F
015DE:  DATA 72,0D
015E0:  DATA 0A,00
015E2:  DATA 53,74
015E4:  DATA 61,72
015E6:  DATA 74,20
015E8:  DATA 46,6C
015EA:  DATA 61,73
015EC:  DATA 68,20
015EE:  DATA 45,72
015F0:  DATA 61,73
015F2:  DATA 65,20
015F4:  DATA 36,34
015F6:  DATA 6B,42
015F8:  DATA 79,74
015FA:  DATA 65,20
015FC:  DATA 53,75
015FE:  DATA 62,73
01600:  DATA 65,63
01602:  DATA 74,6F
01604:  DATA 72,0D
01606:  DATA 0A,00
01608:  DATA 09,53
0160A:  DATA 75,62
0160C:  DATA 73,65
0160E:  DATA 63,74
01610:  DATA 6F,72
01612:  DATA 20,41
01614:  DATA 64,64
01616:  DATA 72,65
01618:  DATA 73,73
0161A:  DATA 3A,20
0161C:  DATA 30,78
0161E:  DATA 25,30
01620:  DATA 38,4C
01622:  DATA 58,0D
01624:  DATA 0A,00
01626:  DATA 45,6E
01628:  DATA 64,20
0162A:  DATA 46,6C
0162C:  DATA 61,73
0162E:  DATA 68,20
01630:  DATA 45,72
01632:  DATA 61,73
01634:  DATA 65,20
01636:  DATA 36,34
01638:  DATA 6B,42
0163A:  DATA 79,74
0163C:  DATA 65,20
0163E:  DATA 53,75
01640:  DATA 62,73
01642:  DATA 65,63
01644:  DATA 74,6F
01646:  DATA 72,0D
01648:  DATA 0A,00
0164A:  DATA 53,74
0164C:  DATA 61,72
0164E:  DATA 74,20
01650:  DATA 46,6C
01652:  DATA 61,73
01654:  DATA 68,20
01656:  DATA 57,72
01658:  DATA 69,74
0165A:  DATA 65,20
0165C:  DATA 44,65
0165E:  DATA 6D,6F
01660:  DATA 0D,0A
01662:  DATA 00,00
01664:  DATA 09,4D
01666:  DATA 4F,44
01668:  DATA 45,20
0166A:  DATA 20,20
0166C:  DATA 20,20
0166E:  DATA 3A,20
01670:  DATA 25,30
01672:  DATA 32,58
01674:  DATA 0D,0A
01676:  DATA 00,00
01678:  DATA 09,41
0167A:  DATA 64,64
0167C:  DATA 72,65
0167E:  DATA 73,73
01680:  DATA 20,20
01682:  DATA 3A,20
01684:  DATA 30,78
01686:  DATA 25,30
01688:  DATA 38,4C
0168A:  DATA 58,0D
0168C:  DATA 0A,00
0168E:  DATA 09,50
01690:  DATA 61,63
01692:  DATA 6B,65
01694:  DATA 74,4E
01696:  DATA 75,6D
01698:  DATA 3A,20
0169A:  DATA 30,78
0169C:  DATA 25,30
0169E:  DATA 34,4C
016A0:  DATA 58,0D
016A2:  DATA 0A,00
016A4:  DATA 57,72
016A6:  DATA 69,74
016A8:  DATA 65,20
016AA:  DATA 44,61
016AC:  DATA 74,61
016AE:  DATA 0D,0A
016B0:  DATA 00,00
016B2:  DATA 45,6E
016B4:  DATA 64,20
016B6:  DATA 46,6C
016B8:  DATA 61,73
016BA:  DATA 68,20
016BC:  DATA 57,72
016BE:  DATA 69,74
016C0:  DATA 65,20
016C2:  DATA 44,65
016C4:  DATA 6D,6F
016C6:  DATA 0D,0A
016C8:  DATA 00,00
016CA:  DATA 53,74
016CC:  DATA 61,72
016CE:  DATA 74,20
016D0:  DATA 46,6C
016D2:  DATA 61,73
016D4:  DATA 68,20
016D6:  DATA 57,72
016D8:  DATA 69,74
016DA:  DATA 65,20
016DC:  DATA 34,6B
016DE:  DATA 42,79
016E0:  DATA 74,65
016E2:  DATA 20,53
016E4:  DATA 75,62
016E6:  DATA 73,65
016E8:  DATA 63,74
016EA:  DATA 6F,72
016EC:  DATA 0D,0A
016EE:  DATA 00,00
016F0:  DATA 45,6E
016F2:  DATA 64,20
016F4:  DATA 46,6C
016F6:  DATA 61,73
016F8:  DATA 68,20
016FA:  DATA 57,72
016FC:  DATA 69,74
016FE:  DATA 65,20
01700:  DATA 34,6B
01702:  DATA 42,79
01704:  DATA 74,65
01706:  DATA 20,53
01708:  DATA 75,62
0170A:  DATA 73,65
0170C:  DATA 63,74
0170E:  DATA 6F,72
01710:  DATA 0D,0A
01712:  DATA 00,00
01714:  DATA 53,74
01716:  DATA 61,72
01718:  DATA 74,20
0171A:  DATA 46,6C
0171C:  DATA 61,73
0171E:  DATA 68,20
01720:  DATA 52,65
01722:  DATA 61,64
01724:  DATA 0D,0A
01726:  DATA 00,00
01728:  DATA 09,4D
0172A:  DATA 4F,44
0172C:  DATA 45,20
0172E:  DATA 20,20
01730:  DATA 20,20
01732:  DATA 3A,20
01734:  DATA 25,30
01736:  DATA 32,58
01738:  DATA 0D,0A
0173A:  DATA 00,00
0173C:  DATA 09,41
0173E:  DATA 64,64
01740:  DATA 72,65
01742:  DATA 73,73
01744:  DATA 20,20
01746:  DATA 3A,20
01748:  DATA 30,78
0174A:  DATA 25,30
0174C:  DATA 38,4C
0174E:  DATA 58,0D
01750:  DATA 0A,00
01752:  DATA 09,50
01754:  DATA 61,63
01756:  DATA 6B,65
01758:  DATA 74,4E
0175A:  DATA 75,6D
0175C:  DATA 3A,20
0175E:  DATA 30,78
01760:  DATA 25,30
01762:  DATA 34,4C
01764:  DATA 58,0D
01766:  DATA 0A,00
01768:  DATA 52,45
0176A:  DATA 41,44
0176C:  DATA 20,44
0176E:  DATA 41,54
01770:  DATA 41,0D
01772:  DATA 0A,00
01774:  DATA 4D,69
01776:  DATA 73,73
01778:  DATA 69,6F
0177A:  DATA 6E,20
0177C:  DATA 46,6C
0177E:  DATA 61,73
01780:  DATA 68,20
01782:  DATA 69,73
01784:  DATA 20,6E
01786:  DATA 6F,74
01788:  DATA 20,63
0178A:  DATA 6F,6E
0178C:  DATA 6E,65
0178E:  DATA 63,74
01790:  DATA 65,64
01792:  DATA 0D,0A
01794:  DATA 00,00
01796:  DATA 45,6E
01798:  DATA 64,20
0179A:  DATA 46,6C
0179C:  DATA 61,73
0179E:  DATA 68,20
017A0:  DATA 52,65
017A2:  DATA 61,64
017A4:  DATA 0D,0A
017A6:  DATA 00,00
017A8:  DATA 53,74
017AA:  DATA 61,72
017AC:  DATA 74,20
017AE:  DATA 46,6C
017B0:  DATA 61,73
017B2:  DATA 68,20
017B4:  DATA 52,65
017B6:  DATA 61,64
017B8:  DATA 20,41
017BA:  DATA 64,64
017BC:  DATA 72,65
017BE:  DATA 73,73
017C0:  DATA 0D,0A
017C2:  DATA 00,00
017C4:  DATA 52,65
017C6:  DATA 61,64
017C8:  DATA 20,44
017CA:  DATA 61,74
017CC:  DATA 61,3A
017CE:  DATA 20,25
017D0:  DATA 30,32
017D2:  DATA 58,20
017D4:  DATA 25,30
017D6:  DATA 32,58
017D8:  DATA 20,25
017DA:  DATA 30,32
017DC:  DATA 58,20
017DE:  DATA 25,30
017E0:  DATA 32,58
017E2:  DATA 0D,0A
017E4:  DATA 00,00
017E6:  DATA 45,6E
017E8:  DATA 64,20
017EA:  DATA 46,6C
017EC:  DATA 61,73
017EE:  DATA 68,20
017F0:  DATA 52,65
017F2:  DATA 61,64
017F4:  DATA 20,41
017F6:  DATA 64,64
017F8:  DATA 72,65
017FA:  DATA 73,73
017FC:  DATA 0D,0A
017FE:  DATA 00,00
01800:  DATA 53,74
01802:  DATA 61,72
01804:  DATA 74,20
01806:  DATA 46,6C
01808:  DATA 61,73
0180A:  DATA 68,20
0180C:  DATA 45,72
0180E:  DATA 61,73
01810:  DATA 65,20
01812:  DATA 61,6E
01814:  DATA 64,20
01816:  DATA 52,65
01818:  DATA 73,65
0181A:  DATA 74,0D
0181C:  DATA 0A,00
0181E:  DATA 45,6E
01820:  DATA 64,20
01822:  DATA 46,6C
01824:  DATA 61,73
01826:  DATA 68,20
01828:  DATA 45,72
0182A:  DATA 61,73
0182C:  DATA 65,20
0182E:  DATA 61,6E
01830:  DATA 64,20
01832:  DATA 52,65
01834:  DATA 73,65
01836:  DATA 74,0D
01838:  DATA 0A,00
0183A:  DATA 53,74
0183C:  DATA 61,72
0183E:  DATA 74,20
01840:  DATA 46,6C
01842:  DATA 61,73
01844:  DATA 68,20
01846:  DATA 53,4D
01848:  DATA 46,20
0184A:  DATA 43,6F
0184C:  DATA 70,79
0184E:  DATA 0D,0A
01850:  DATA 00,00
01852:  DATA 45,6E
01854:  DATA 64,20
01856:  DATA 46,6C
01858:  DATA 61,73
0185A:  DATA 68,20
0185C:  DATA 53,4D
0185E:  DATA 46,20
01860:  DATA 43,6F
01862:  DATA 70,79
01864:  DATA 0D,0A
01866:  DATA 00,00
01868:  DATA 53,74
0186A:  DATA 61,72
0186C:  DATA 74,20
0186E:  DATA 46,6C
01870:  DATA 61,73
01872:  DATA 68,20
01874:  DATA 53,4D
01876:  DATA 46,20
01878:  DATA 52,65
0187A:  DATA 61,64
0187C:  DATA 0D,0A
0187E:  DATA 00,00
01880:  DATA 52,65
01882:  DATA 61,64
01884:  DATA 20,44
01886:  DATA 61,74
01888:  DATA 61,3A
0188A:  DATA 20,00
0188C:  DATA 0D,0A
0188E:  DATA 45,6E
01890:  DATA 64,20
01892:  DATA 46,6C
01894:  DATA 61,73
01896:  DATA 68,20
01898:  DATA 53,4D
0189A:  DATA 46,20
0189C:  DATA 52,65
0189E:  DATA 61,64
018A0:  DATA 0D,0A
018A2:  DATA 00,00
018A4:  DATA 53,74
018A6:  DATA 61,72
018A8:  DATA 74,20
018AA:  DATA 46,6C
018AC:  DATA 61,73
018AE:  DATA 68,20
018B0:  DATA 53,4D
018B2:  DATA 46,20
018B4:  DATA 45,72
018B6:  DATA 61,73
018B8:  DATA 65,0D
018BA:  DATA 0A,00
018BC:  DATA 45,6E
018BE:  DATA 64,20
018C0:  DATA 46,6C
018C2:  DATA 61,73
018C4:  DATA 68,20
018C6:  DATA 53,4D
018C8:  DATA 46,20
018CA:  DATA 45,72
018CC:  DATA 61,73
018CE:  DATA 65,0D
018D0:  DATA 0A,00
018D2:  DATA 53,74
018D4:  DATA 61,72
018D6:  DATA 74,20
018D8:  DATA 46,6C
018DA:  DATA 61,73
018DC:  DATA 68,20
018DE:  DATA 41,64
018E0:  DATA 64,72
018E2:  DATA 65,73
018E4:  DATA 73,20
018E6:  DATA 52,65
018E8:  DATA 73,65
018EA:  DATA 74,0D
018EC:  DATA 0A,00
018EE:  DATA 45,6E
018F0:  DATA 64,20
018F2:  DATA 46,6C
018F4:  DATA 61,73
018F6:  DATA 68,20
018F8:  DATA 41,64
018FA:  DATA 64,72
018FC:  DATA 65,73
018FE:  DATA 73,20
01900:  DATA 52,65
01902:  DATA 73,65
01904:  DATA 74,0D
01906:  DATA 0A,00
01908:  DATA 53,4D
0190A:  DATA 46,20
0190C:  DATA 69,73
0190E:  DATA 20,6E
01910:  DATA 6F,74
01912:  DATA 20,63
01914:  DATA 6F,6E
01916:  DATA 6E,65
01918:  DATA 63,74
0191A:  DATA 65,64
0191C:  DATA 0D,0A
0191E:  DATA 00,00
01920:  DATA 53,74
01922:  DATA 61,72
01924:  DATA 74,20
01926:  DATA 46,6C
01928:  DATA 61,73
0192A:  DATA 68,20
0192C:  DATA 53,4D
0192E:  DATA 46,20
01930:  DATA 52,65
01932:  DATA 61,64
01934:  DATA 20,46
01936:  DATA 6F,72
01938:  DATA 63,65
0193A:  DATA 0D,0A
0193C:  DATA 00,00
0193E:  DATA 09,41
01940:  DATA 64,64
01942:  DATA 72,65
01944:  DATA 73,73
01946:  DATA 20,20
01948:  DATA 3A,20
0194A:  DATA 30,78
0194C:  DATA 25,30
0194E:  DATA 38,4C
01950:  DATA 58,0D
01952:  DATA 0A,00
01954:  DATA 09,50
01956:  DATA 61,63
01958:  DATA 6B,65
0195A:  DATA 74,4E
0195C:  DATA 75,6D
0195E:  DATA 3A,20
01960:  DATA 30,78
01962:  DATA 25,30
01964:  DATA 34,4C
01966:  DATA 58,0D
01968:  DATA 0A,00
0196A:  DATA 72,65
0196C:  DATA 61,64
0196E:  DATA 20,64
01970:  DATA 61,74
01972:  DATA 61,0D
01974:  DATA 0A,00
01976:  DATA 0D,0A
01978:  DATA 45,6E
0197A:  DATA 64,20
0197C:  DATA 46,6C
0197E:  DATA 61,73
01980:  DATA 68,20
01982:  DATA 53,4D
01984:  DATA 46,20
01986:  DATA 52,65
01988:  DATA 61,64
0198A:  DATA 20,46
0198C:  DATA 6F,72
0198E:  DATA 63,65
01990:  DATA 0D,0A
01992:  DATA 00,00
01994:  DATA 53,74
01996:  DATA 61,72
01998:  DATA 74,20
0199A:  DATA 53,4D
0199C:  DATA 46,20
0199E:  DATA 45,72
019A0:  DATA 61,73
019A2:  DATA 65,20
019A4:  DATA 41,6C
019A6:  DATA 6C,0D
019A8:  DATA 0A,00
019AA:  DATA 45,6E
019AC:  DATA 64,20
019AE:  DATA 53,4D
019B0:  DATA 46,20
019B2:  DATA 45,72
019B4:  DATA 61,73
019B6:  DATA 65,20
019B8:  DATA 41,6C
019BA:  DATA 6C,0D
019BC:  DATA 0A,00
019BE:  DATA 53,74
019C0:  DATA 61,72
019C2:  DATA 74,20
019C4:  DATA 53,4D
019C6:  DATA 46,20
019C8:  DATA 52,65
019CA:  DATA 73,65
019CC:  DATA 74,0D
019CE:  DATA 0A,00
019D0:  DATA 45,6E
019D2:  DATA 64,20
019D4:  DATA 53,4D
019D6:  DATA 46,20
019D8:  DATA 52,65
019DA:  DATA 73,65
019DC:  DATA 74,0D
019DE:  DATA 0A,00
019E0:  DATA 0D,0A
019E2:  DATA 0D,0A
019E4:  DATA 0D,0A
019E6:  DATA 3D,3D
019E8:  DATA 3D,3D
019EA:  DATA 3D,3D
019EC:  DATA 3D,3D
019EE:  DATA 3D,3D
019F0:  DATA 3D,3D
019F2:  DATA 3D,3D
019F4:  DATA 3D,3D
019F6:  DATA 3D,3D
019F8:  DATA 3D,3D
019FA:  DATA 3D,3D
019FC:  DATA 3D,3D
019FE:  DATA 3D,3D
01A00:  DATA 3D,3D
01A02:  DATA 3D,3D
01A04:  DATA 3D,3D
01A06:  DATA 3D,3D
01A08:  DATA 3D,3D
01A0A:  DATA 3D,3D
01A0C:  DATA 3D,3D
01A0E:  DATA 3D,3D
01A10:  DATA 3D,3D
01A12:  DATA 3D,3D
01A14:  DATA 3D,3D
01A16:  DATA 3D,3D
01A18:  DATA 3D,3D
01A1A:  DATA 3D,3D
01A1C:  DATA 3D,3D
01A1E:  DATA 3D,3D
01A20:  DATA 3D,3D
01A22:  DATA 0D,0A
01A24:  DATA 00,00
01A26:  DATA 54,68
01A28:  DATA 69,73
01A2A:  DATA 20,69
01A2C:  DATA 73,20
01A2E:  DATA 4D,4F
01A30:  DATA 4D,49
01A32:  DATA 4A,49
01A34:  DATA 20,43
01A36:  DATA 49,47
01A38:  DATA 53,20
01A3A:  DATA 50,49
01A3C:  DATA 43,20
01A3E:  DATA 42,42
01A40:  DATA 4D,20
01A42:  DATA 66,6F
01A44:  DATA 72,20
01A46:  DATA 4D,49
01A48:  DATA 53,37
01A4A:  DATA 5F,42
01A4C:  DATA 42,4D
01A4E:  DATA 34,2E
01A50:  DATA 0D,0A
01A52:  DATA 00,00
01A54:  DATA 4C,61
01A56:  DATA 73,74
01A58:  DATA 20,75
01A5A:  DATA 70,64
01A5C:  DATA 61,74
01A5E:  DATA 65,64
01A60:  DATA 20,6F
01A62:  DATA 6E,20
01A64:  DATA 25,73
01A66:  DATA 20,25
01A68:  DATA 73,2C
01A6A:  DATA 20,62
01A6C:  DATA 79,20
01A6E:  DATA 49,6E
01A70:  DATA 6F,75
01A72:  DATA 65,2E
01A74:  DATA 0D,0A
01A76:  DATA 0D,0A
01A78:  DATA 00,00
01A7A:  DATA 32,34
01A7C:  DATA 2D,41
01A7E:  DATA 75,67
01A80:  DATA 2D,32
01A82:  DATA 35,00
01A84:  DATA 31,36
01A86:  DATA 3A,32
01A88:  DATA 34,3A
01A8A:  DATA 33,32
01A8C:  DATA 00,00
01A8E:  DATA 5F,5F
01A90:  DATA 5F,5F
01A92:  DATA 43,49
01A94:  DATA 47,53
01A96:  DATA 20,50
01A98:  DATA 49,43
01A9A:  DATA 20,53
01A9C:  DATA 74,61
01A9E:  DATA 72,74
01AA0:  DATA 20,4F
01AA2:  DATA 70,65
01AA4:  DATA 72,61
01AA6:  DATA 74,69
01AA8:  DATA 6F,6E
01AAA:  DATA 5F,5F
01AAC:  DATA 5F,5F
01AAE:  DATA 5F,0D
01AB0:  DATA 0A,0D
01AB2:  DATA 0A,00
01AB4:  DATA 77,61
01AB6:  DATA 69,74
01AB8:  DATA 69,6E
01ABA:  DATA 67,20
01ABC:  DATA 66,6F
01ABE:  DATA 72,20
01AC0:  DATA 42,4F
01AC2:  DATA 53,53
01AC4:  DATA 20,50
01AC6:  DATA 49,43
01AC8:  DATA 20,63
01ACA:  DATA 6F,6D
01ACC:  DATA 6D,61
01ACE:  DATA 6E,64
01AD0:  DATA 00,00
01AD2:  DATA 0D,0A
01AD4:  DATA 77,61
01AD6:  DATA 69,74
01AD8:  DATA 69,6E
01ADA:  DATA 67,20
01ADC:  DATA 66,6F
01ADE:  DATA 72,20
01AE0:  DATA 42,4F
01AE2:  DATA 53,53
01AE4:  DATA 20,50
01AE6:  DATA 49,43
01AE8:  DATA 20,63
01AEA:  DATA 6F,6D
01AEC:  DATA 6D,61
01AEE:  DATA 6E,64
01AF0:  DATA 00,00
01AF2:  DATA 0D,0A
01AF4:  DATA 0D,0A
01AF6:  DATA 3D,3D
01AF8:  DATA 3D,3D
01AFA:  DATA 3D,3D
01AFC:  DATA 0D,0A
01AFE:  DATA 0D,0A
01B00:  DATA 46,69
01B02:  DATA 6E,69
01B04:  DATA 73,68
01B06:  DATA 65,64
01B08:  DATA 20,70
01B0A:  DATA 72,6F
01B0C:  DATA 63,65
01B0E:  DATA 73,73
01B10:  DATA 2E,0D
01B12:  DATA 0A,57
01B14:  DATA 61,69
01B16:  DATA 74,20
01B18:  DATA 66,6F
01B1A:  DATA 72,20
01B1C:  DATA 42,4F
01B1E:  DATA 53,53
01B20:  DATA 20,50
01B22:  DATA 49,43
01B24:  DATA 20,74
01B26:  DATA 75,72
01B28:  DATA 6E,20
01B2A:  DATA 6F,66
01B2C:  DATA 66,20
01B2E:  DATA 6D,65
01B30:  DATA 00,00
01B32:  DATA 45,6E
01B34:  DATA 64,20
01B36:  DATA 6D,61
01B38:  DATA 69,6E
01B3A:  DATA 0D,0A
01B3C:  DATA 00,00
*
01BBE:  TBLRD*+
01BC0:  MOVF   FF5,F
01BC2:  BTFSC  FD8.2
01BC4:  GOTO   1BEC
01BC8:  MOVFF  FF6,A16
01BCC:  MOVFF  FF7,A17
01BD0:  MOVFF  FF8,A18
01BD4:  MOVFF  FF5,AAD
01BD8:  CALL   1B6C
01BDC:  MOVFF  A16,FF6
01BE0:  MOVFF  A17,FF7
01BE4:  MOVFF  A18,FF8
01BE8:  GOTO   1BBE
01BEC:  RETURN 0
01BEE:  TBLRD*+
01BF0:  MOVFF  FF6,9C3
01BF4:  MOVFF  FF7,9C4
01BF8:  MOVFF  FF8,9C5
01BFC:  MOVFF  FF5,AAD
01C00:  CALL   1B6C
01C04:  MOVFF  9C3,FF6
01C08:  MOVFF  9C4,FF7
01C0C:  MOVFF  9C5,FF8
01C10:  MOVLB  9
01C12:  DECFSZ xC2,F
01C14:  BRA    1C1A
01C16:  BRA    1C20
01C18:  MOVLB  0
01C1A:  MOVLB  0
01C1C:  GOTO   1BEE
01C20:  MOVLB  0
01C22:  RETURN 0
*
01E42:  MOVLB  2
01E44:  BTFSS  x65.7
01E46:  BRA    1E4E
01E48:  MOVLB  0
01E4A:  GOTO   1E7E
01E4E:  MOVLW  0F
01E50:  MOVWF  00
01E52:  SWAPF  x64,W
01E54:  ANDWF  00,F
01E56:  MOVLW  0A
01E58:  SUBWF  00,W
01E5A:  BTFSS  FD8.0
01E5C:  BRA    1E64
01E5E:  MOVLB  0
01E60:  GOTO   1E6E
01E64:  MOVLW  30
01E66:  ADDWF  00,F
01E68:  MOVLB  0
01E6A:  GOTO   1E76
01E6E:  MOVLB  2
01E70:  MOVF   x65,W
01E72:  ADDWF  00,F
01E74:  MOVLB  0
01E76:  MOVFF  00,AAD
01E7A:  CALL   1B6C
01E7E:  MOVLW  0F
01E80:  MOVLB  2
01E82:  ANDWF  x64,F
01E84:  MOVLW  0A
01E86:  SUBWF  x64,W
01E88:  BTFSS  FD8.0
01E8A:  BRA    1E92
01E8C:  MOVLB  0
01E8E:  GOTO   1E9A
01E92:  MOVLW  30
01E94:  MOVLB  0
01E96:  GOTO   1EA2
01E9A:  MOVLB  2
01E9C:  BCF    x65.7
01E9E:  MOVF   x65,W
01EA0:  MOVLB  0
01EA2:  MOVLB  2
01EA4:  ADDWF  x64,F
01EA6:  MOVFF  264,AAD
01EAA:  MOVLB  0
01EAC:  CALL   1B6C
01EB0:  RETURN 0
*
02358:  MOVLB  A
0235A:  MOVF   x74,W
0235C:  ANDLW  07
0235E:  MOVWF  00
02360:  RRCF   x74,W
02362:  MOVWF  01
02364:  RRCF   01,F
02366:  RRCF   01,F
02368:  MOVLW  1F
0236A:  ANDWF  01,F
0236C:  MOVF   01,W
0236E:  ADDWF  x76,W
02370:  MOVWF  FE9
02372:  MOVLW  00
02374:  ADDWFC x77,W
02376:  MOVWF  FEA
02378:  CLRF   01
0237A:  INCF   01,F
0237C:  INCF   00,F
0237E:  MOVLB  0
02380:  GOTO   2386
02384:  RLCF   01,F
02386:  DECFSZ 00,F
02388:  GOTO   2384
0238C:  MOVLB  A
0238E:  MOVF   x75,F
02390:  BTFSS  FD8.2
02392:  BRA    239A
02394:  MOVLB  0
02396:  GOTO   23A4
0239A:  MOVF   01,W
0239C:  IORWF  FEF,F
0239E:  MOVLB  0
023A0:  GOTO   23AA
023A4:  COMF   01,F
023A6:  MOVF   01,W
023A8:  ANDWF  FEF,F
023AA:  RETURN 0
*
027A0:  TSTFSZ 01
027A2:  GOTO   27B0
027A6:  TSTFSZ 02
027A8:  GOTO   27B2
027AC:  GOTO   27C2
027B0:  INCF   02,F
027B2:  MOVFF  00,FEE
027B6:  DECFSZ 01,F
027B8:  GOTO   27B2
027BC:  DECFSZ 02,F
027BE:  GOTO   27B2
027C2:  RETURN 0
*
06340:  MOVLB  2
06342:  MOVF   xEA,W
06344:  CLRF   01
06346:  SUBWF  xE9,W
06348:  BTFSS  FD8.0
0634A:  BRA    6352
0634C:  MOVLB  0
0634E:  GOTO   635C
06352:  MOVF   xE9,W
06354:  MOVWF  00
06356:  MOVLB  0
06358:  GOTO   6386
0635C:  CLRF   00
0635E:  MOVLW  08
06360:  MOVLB  2
06362:  MOVWF  xEB
06364:  MOVLB  0
06366:  MOVLB  2
06368:  RLCF   xE9,F
0636A:  RLCF   00,F
0636C:  MOVF   xEA,W
0636E:  SUBWF  00,W
06370:  BTFSC  FD8.0
06372:  MOVWF  00
06374:  RLCF   01,F
06376:  DECFSZ xEB,F
06378:  BRA    637E
0637A:  BRA    6384
0637C:  MOVLB  0
0637E:  MOVLB  0
06380:  GOTO   6366
06384:  MOVLB  0
06386:  RETURN 0
06388:  MOVF   01,W
0638A:  MOVFF  264,2E9
0638E:  MOVLW  64
06390:  MOVLB  2
06392:  MOVWF  xEA
06394:  MOVLB  0
06396:  CALL   6340
0639A:  MOVFF  00,264
0639E:  MOVF   01,W
063A0:  MOVLW  30
063A2:  BTFSS  FD8.2
063A4:  GOTO   63C8
063A8:  MOVLB  2
063AA:  BTFSC  x65.1
063AC:  BRA    63B4
063AE:  MOVLB  0
063B0:  GOTO   63DC
063B4:  BTFSS  x65.3
063B6:  BRA    63BE
063B8:  MOVLB  0
063BA:  GOTO   63DC
063BE:  BTFSC  x65.4
063C0:  MOVLW  20
063C2:  MOVLB  0
063C4:  GOTO   63D2
063C8:  MOVLB  2
063CA:  BCF    x65.3
063CC:  BCF    x65.4
063CE:  BSF    x65.0
063D0:  MOVLB  0
063D2:  ADDWF  01,F
063D4:  MOVFF  01,AAD
063D8:  CALL   1B6C
063DC:  MOVFF  264,2E9
063E0:  MOVLW  0A
063E2:  MOVLB  2
063E4:  MOVWF  xEA
063E6:  MOVLB  0
063E8:  CALL   6340
063EC:  MOVFF  00,264
063F0:  MOVF   01,W
063F2:  MOVLW  30
063F4:  BTFSS  FD8.2
063F6:  GOTO   6416
063FA:  MOVLB  2
063FC:  BTFSS  x65.3
063FE:  BRA    6406
06400:  MOVLB  0
06402:  GOTO   6420
06406:  BTFSC  x65.0
06408:  BRA    6410
0640A:  MOVLB  0
0640C:  GOTO   6420
06410:  BTFSC  x65.4
06412:  MOVLW  20
06414:  MOVLB  0
06416:  ADDWF  01,F
06418:  MOVFF  01,AAD
0641C:  CALL   1B6C
06420:  MOVLW  30
06422:  MOVLB  2
06424:  ADDWF  x64,F
06426:  MOVFF  264,AAD
0642A:  MOVLB  0
0642C:  CALL   1B6C
06430:  RETURN 0
06432:  BTFSC  FD8.1
06434:  GOTO   6440
06438:  MOVLW  09
0643A:  MOVWF  FEA
0643C:  MOVLW  DF
0643E:  MOVWF  FE9
06440:  CLRF   00
06442:  CLRF   01
06444:  CLRF   02
06446:  CLRF   03
06448:  MOVLB  9
0644A:  CLRF   xDF
0644C:  CLRF   xE0
0644E:  CLRF   xE1
06450:  CLRF   xE2
06452:  MOVF   xDE,W
06454:  IORWF  xDD,W
06456:  IORWF  xDC,W
06458:  IORWF  xDB,W
0645A:  BTFSS  FD8.2
0645C:  BRA    6464
0645E:  MOVLB  0
06460:  GOTO   64F4
06464:  MOVLB  0
06466:  MOVLW  20
06468:  MOVLB  9
0646A:  MOVWF  xE3
0646C:  MOVLB  0
0646E:  BCF    FD8.0
06470:  MOVLB  9
06472:  RLCF   xD7,F
06474:  RLCF   xD8,F
06476:  RLCF   xD9,F
06478:  RLCF   xDA,F
0647A:  RLCF   xDF,F
0647C:  RLCF   xE0,F
0647E:  RLCF   xE1,F
06480:  RLCF   xE2,F
06482:  MOVF   xDE,W
06484:  SUBWF  xE2,W
06486:  BTFSC  FD8.2
06488:  BRA    6490
0648A:  MOVLB  0
0648C:  GOTO   64B2
06490:  MOVF   xDD,W
06492:  SUBWF  xE1,W
06494:  BTFSC  FD8.2
06496:  BRA    649E
06498:  MOVLB  0
0649A:  GOTO   64B2
0649E:  MOVF   xDC,W
064A0:  SUBWF  xE0,W
064A2:  BTFSC  FD8.2
064A4:  BRA    64AC
064A6:  MOVLB  0
064A8:  GOTO   64B2
064AC:  MOVF   xDB,W
064AE:  SUBWF  xDF,W
064B0:  MOVLB  0
064B2:  BTFSS  FD8.0
064B4:  GOTO   64DA
064B8:  MOVLB  9
064BA:  MOVF   xDB,W
064BC:  SUBWF  xDF,F
064BE:  MOVF   xDC,W
064C0:  BTFSS  FD8.0
064C2:  INCFSZ xDC,W
064C4:  SUBWF  xE0,F
064C6:  MOVF   xDD,W
064C8:  BTFSS  FD8.0
064CA:  INCFSZ xDD,W
064CC:  SUBWF  xE1,F
064CE:  MOVF   xDE,W
064D0:  BTFSS  FD8.0
064D2:  INCFSZ xDE,W
064D4:  SUBWF  xE2,F
064D6:  BSF    FD8.0
064D8:  MOVLB  0
064DA:  RLCF   00,F
064DC:  RLCF   01,F
064DE:  RLCF   02,F
064E0:  RLCF   03,F
064E2:  MOVLB  9
064E4:  DECFSZ xE3,F
064E6:  BRA    64EC
064E8:  BRA    64F2
064EA:  MOVLB  0
064EC:  MOVLB  0
064EE:  GOTO   646E
064F2:  MOVLB  0
064F4:  MOVFF  9DF,FEF
064F8:  MOVFF  9E0,FEC
064FC:  MOVFF  9E1,FEC
06500:  MOVFF  9E2,FEC
06504:  MOVF   FED,F
06506:  MOVF   FED,F
06508:  MOVF   FED,F
0650A:  RETURN 0
*
065C6:  MOVFF  FEA,9CA
065CA:  MOVFF  FE9,9C9
065CE:  MOVLB  9
065D0:  BTFSC  xC3.7
065D2:  BRA    65DA
065D4:  MOVLB  0
065D6:  GOTO   65EC
065DA:  BSF    xC9.7
065DC:  BTFSS  xC9.4
065DE:  INCF   xC9,F
065E0:  COMF   xC2,F
065E2:  COMF   xC3,F
065E4:  INCF   xC2,F
065E6:  BTFSC  FD8.2
065E8:  INCF   xC3,F
065EA:  MOVLB  0
065EC:  MOVLB  9
065EE:  SWAPF  xC3,W
065F0:  IORLW  F0
065F2:  MOVWF  xC5
065F4:  ADDWF  xC5,F
065F6:  ADDLW  E2
065F8:  MOVWF  xC6
065FA:  ADDLW  32
065FC:  MOVWF  xC8
065FE:  MOVF   xC3,W
06600:  ANDLW  0F
06602:  ADDWF  xC6,F
06604:  ADDWF  xC6,F
06606:  ADDWF  xC8,F
06608:  ADDLW  E9
0660A:  MOVWF  xC7
0660C:  ADDWF  xC7,F
0660E:  ADDWF  xC7,F
06610:  SWAPF  xC2,W
06612:  ANDLW  0F
06614:  ADDWF  xC7,F
06616:  ADDWF  xC8,F
06618:  RLCF   xC7,F
0661A:  RLCF   xC8,F
0661C:  COMF   xC8,F
0661E:  RLCF   xC8,F
06620:  MOVF   xC2,W
06622:  ANDLW  0F
06624:  ADDWF  xC8,F
06626:  RLCF   xC5,F
06628:  MOVLW  07
0662A:  MOVWF  xC4
0662C:  MOVLW  0A
0662E:  MOVLB  0
06630:  MOVLB  9
06632:  DECF   xC7,F
06634:  ADDWF  xC8,F
06636:  BTFSC  FD8.0
06638:  BRA    6640
0663A:  MOVLB  0
0663C:  GOTO   6630
06640:  MOVLB  0
06642:  MOVLB  9
06644:  DECF   xC6,F
06646:  ADDWF  xC7,F
06648:  BTFSC  FD8.0
0664A:  BRA    6652
0664C:  MOVLB  0
0664E:  GOTO   6642
06652:  MOVLB  0
06654:  MOVLB  9
06656:  DECF   xC5,F
06658:  ADDWF  xC6,F
0665A:  BTFSC  FD8.0
0665C:  BRA    6664
0665E:  MOVLB  0
06660:  GOTO   6654
06664:  MOVLB  0
06666:  MOVLB  9
06668:  DECF   xC4,F
0666A:  ADDWF  xC5,F
0666C:  BTFSC  FD8.0
0666E:  BRA    6676
06670:  MOVLB  0
06672:  GOTO   6666
06676:  MOVLW  09
06678:  MOVWF  FEA
0667A:  MOVLW  C4
0667C:  MOVWF  FE9
0667E:  MOVLW  07
06680:  ANDWF  xC9,W
06682:  BCF    xC9.6
06684:  MOVF   FED,F
06686:  ANDWF  xC9,W
06688:  BTFSC  FD8.2
0668A:  BRA    6692
0668C:  MOVLB  0
0668E:  GOTO   66AA
06692:  BTFSC  xC9.4
06694:  MOVF   FEE,F
06696:  BTFSS  xC9.4
06698:  BRA    66A0
0669A:  MOVLB  0
0669C:  GOTO   66AA
066A0:  MOVLW  20
066A2:  MOVWF  00
066A4:  MOVLB  0
066A6:  GOTO   6724
066AA:  ADDWF  FE9,F
066AC:  MOVLW  00
066AE:  ADDWFC FEA,F
066B0:  MOVF   FE9,W
066B2:  SUBLW  C8
066B4:  BTFSS  FD8.2
066B6:  GOTO   66CA
066BA:  MOVF   FEA,W
066BC:  SUBLW  09
066BE:  BTFSS  FD8.2
066C0:  GOTO   66CA
066C4:  MOVLB  9
066C6:  BSF    xC9.6
066C8:  MOVLB  0
066CA:  MOVF   FEF,W
066CC:  MOVWF  00
066CE:  BTFSS  FD8.2
066D0:  GOTO   66FC
066D4:  MOVLB  9
066D6:  BTFSS  xC9.6
066D8:  BRA    66E0
066DA:  MOVLB  0
066DC:  GOTO   66FC
066E0:  BTFSS  xC9.4
066E2:  BRA    66EA
066E4:  MOVLB  0
066E6:  GOTO   673C
066EA:  BTFSS  xC9.3
066EC:  BRA    66F4
066EE:  MOVLB  0
066F0:  GOTO   66FC
066F4:  MOVLW  20
066F6:  MOVLB  0
066F8:  GOTO   6722
066FC:  MOVLB  9
066FE:  BTFSC  xC9.7
06700:  BRA    6708
06702:  MOVLB  0
06704:  GOTO   6718
06708:  MOVLW  2D
0670A:  MOVWF  00
0670C:  MOVF   FED,W
0670E:  BCF    xC9.6
06710:  BCF    xC9.7
06712:  MOVLB  0
06714:  GOTO   6724
06718:  MOVLB  9
0671A:  BSF    xC9.3
0671C:  BCF    xC9.4
0671E:  MOVLW  30
06720:  MOVLB  0
06722:  ADDWF  00,F
06724:  MOVFF  FEA,9C3
06728:  MOVFF  FE9,9C2
0672C:  MOVFF  00,AAD
06730:  CALL   1B6C
06734:  MOVFF  9C3,FEA
06738:  MOVFF  9C2,FE9
0673C:  MOVF   FEE,W
0673E:  MOVLB  9
06740:  BTFSC  xC9.6
06742:  BRA    674A
06744:  MOVLB  0
06746:  GOTO   66B0
0674A:  MOVLB  0
0674C:  GOTO   84C0 (RETURN)
*
092F0:  MOVF   FE9,W
092F2:  MOVLB  2
092F4:  MOVWF  x64
092F6:  BTFSC  x63.7
092F8:  BRA    9300
092FA:  MOVLB  0
092FC:  GOTO   931C
09300:  DECF   x64,F
09302:  BSF    x64.5
09304:  COMF   x60,F
09306:  COMF   x61,F
09308:  COMF   x62,F
0930A:  COMF   x63,F
0930C:  INCF   x60,F
0930E:  BTFSC  FD8.2
09310:  INCF   x61,F
09312:  BTFSC  FD8.2
09314:  INCF   x62,F
09316:  BTFSC  FD8.2
09318:  INCF   x63,F
0931A:  MOVLB  0
0931C:  MOVLW  3B
0931E:  MOVLB  2
09320:  MOVWF  x6B
09322:  MOVLW  9A
09324:  MOVWF  x6A
09326:  MOVLW  CA
09328:  MOVWF  x69
0932A:  CLRF   x68
0932C:  MOVLW  0A
0932E:  MOVWF  x66
09330:  MOVLB  0
09332:  BSF    FD8.1
09334:  MOVLW  02
09336:  MOVWF  FEA
09338:  MOVLW  60
0933A:  MOVWF  FE9
0933C:  MOVFF  263,9DA
09340:  MOVFF  262,9D9
09344:  MOVFF  261,9D8
09348:  MOVFF  260,9D7
0934C:  MOVFF  26B,9DE
09350:  MOVFF  26A,9DD
09354:  MOVFF  269,9DC
09358:  MOVFF  268,9DB
0935C:  CALL   6432
09360:  MOVF   01,W
09362:  MOVF   00,F
09364:  BTFSS  FD8.2
09366:  GOTO   93BE
0936A:  MOVLB  2
0936C:  MOVF   x66,W
0936E:  XORLW  01
09370:  BTFSS  FD8.2
09372:  BRA    937A
09374:  MOVLB  0
09376:  GOTO   93BE
0937A:  MOVF   x64,W
0937C:  BTFSS  FD8.2
0937E:  BRA    9386
09380:  MOVLB  0
09382:  GOTO   93C6
09386:  ANDLW  0F
09388:  SUBWF  x66,W
0938A:  BTFSS  FD8.2
0938C:  BRA    9394
0938E:  MOVLB  0
09390:  GOTO   93A0
09394:  BTFSS  FD8.0
09396:  BRA    939E
09398:  MOVLB  0
0939A:  GOTO   9424
0939E:  MOVLB  0
093A0:  MOVLB  2
093A2:  BTFSS  x64.7
093A4:  BRA    93AC
093A6:  MOVLB  0
093A8:  GOTO   9424
093AC:  BTFSS  x64.6
093AE:  BRA    93B6
093B0:  MOVLB  0
093B2:  GOTO   93C6
093B6:  MOVLW  20
093B8:  MOVLB  0
093BA:  GOTO   941A
093BE:  MOVLW  20
093C0:  MOVLB  2
093C2:  ANDWF  x64,F
093C4:  MOVLB  0
093C6:  MOVLB  2
093C8:  BTFSC  x64.5
093CA:  BRA    93D2
093CC:  MOVLB  0
093CE:  GOTO   93EE
093D2:  BCF    x64.5
093D4:  MOVF   00,W
093D6:  MOVWF  x64
093D8:  MOVLW  2D
093DA:  MOVLB  A
093DC:  MOVWF  xAD
093DE:  MOVLB  0
093E0:  CALL   1B6C
093E4:  MOVLB  2
093E6:  MOVF   x64,W
093E8:  MOVWF  00
093EA:  CLRF   x64
093EC:  MOVLB  0
093EE:  MOVLW  30
093F0:  MOVLB  2
093F2:  BTFSC  x64.5
093F4:  BRA    93FC
093F6:  MOVLB  0
093F8:  GOTO   941A
093FC:  BCF    x64.5
093FE:  MOVF   00,W
09400:  MOVWF  x64
09402:  MOVLW  2D
09404:  MOVLB  A
09406:  MOVWF  xAD
09408:  MOVLB  0
0940A:  CALL   1B6C
0940E:  MOVLB  2
09410:  MOVF   x64,W
09412:  MOVWF  00
09414:  CLRF   x64
09416:  MOVLW  30
09418:  MOVLB  0
0941A:  ADDWF  00,F
0941C:  MOVFF  00,AAD
09420:  CALL   1B6C
09424:  BCF    FD8.1
09426:  MOVFF  26B,9DA
0942A:  MOVFF  26A,9D9
0942E:  MOVFF  269,9D8
09432:  MOVFF  268,9D7
09436:  MOVLB  9
09438:  CLRF   xDE
0943A:  CLRF   xDD
0943C:  CLRF   xDC
0943E:  MOVLW  0A
09440:  MOVWF  xDB
09442:  MOVLB  0
09444:  CALL   6432
09448:  MOVFF  03,26B
0944C:  MOVFF  02,26A
09450:  MOVFF  01,269
09454:  MOVFF  00,268
09458:  MOVLB  2
0945A:  DECFSZ x66,F
0945C:  BRA    9462
0945E:  BRA    9468
09460:  MOVLB  0
09462:  MOVLB  0
09464:  GOTO   9332
09468:  MOVLB  0
0946A:  RETURN 0
*
0980C:  MOVLW  20
0980E:  MOVLB  2
09810:  BTFSS  xE4.4
09812:  MOVLW  30
09814:  MOVWF  xE5
09816:  MOVFF  2E3,00
0981A:  BTFSC  00.7
0981C:  BRA    9824
0981E:  MOVLB  0
09820:  GOTO   9836
09824:  COMF   00,F
09826:  INCF   00,F
09828:  MOVFF  00,2E3
0982C:  MOVLW  2D
0982E:  MOVWF  xE5
09830:  BSF    xE4.7
09832:  BSF    xE4.0
09834:  MOVLB  0
09836:  MOVF   01,W
09838:  MOVFF  2E3,2E9
0983C:  MOVLW  64
0983E:  MOVLB  2
09840:  MOVWF  xEA
09842:  MOVLB  0
09844:  CALL   6340
09848:  MOVFF  00,2E3
0984C:  MOVLW  30
0984E:  ADDWF  01,W
09850:  MOVLB  2
09852:  MOVWF  xE6
09854:  MOVFF  2E3,2E9
09858:  MOVLW  0A
0985A:  MOVWF  xEA
0985C:  MOVLB  0
0985E:  CALL   6340
09862:  MOVLW  30
09864:  ADDWF  00,W
09866:  MOVLB  2
09868:  MOVWF  xE8
0986A:  MOVLW  30
0986C:  ADDWF  01,W
0986E:  MOVWF  xE7
09870:  MOVFF  2E5,00
09874:  MOVLB  0
09876:  MOVLW  30
09878:  MOVLB  2
0987A:  SUBWF  xE6,W
0987C:  BTFSS  FD8.2
0987E:  BRA    9886
09880:  MOVLB  0
09882:  GOTO   9892
09886:  BSF    xE4.1
09888:  BTFSC  xE4.7
0988A:  BSF    xE4.2
0988C:  MOVLB  0
0988E:  GOTO   98D2
09892:  MOVFF  2E5,2E6
09896:  MOVLW  20
09898:  MOVLB  2
0989A:  MOVWF  xE5
0989C:  MOVLW  30
0989E:  SUBWF  xE7,W
098A0:  BTFSS  FD8.2
098A2:  BRA    98AA
098A4:  MOVLB  0
098A6:  GOTO   98B6
098AA:  BSF    xE4.0
098AC:  BTFSC  xE4.7
098AE:  BSF    xE4.1
098B0:  MOVLB  0
098B2:  GOTO   98D2
098B6:  BTFSC  FD8.2
098B8:  BRA    98C0
098BA:  MOVLB  2
098BC:  BSF    xE4.0
098BE:  MOVLB  0
098C0:  BTFSS  FD8.2
098C2:  GOTO   98D2
098C6:  MOVFF  2E6,2E7
098CA:  MOVLW  20
098CC:  MOVLB  2
098CE:  MOVWF  xE6
098D0:  MOVLB  0
098D2:  MOVLB  2
098D4:  BTFSS  xE4.2
098D6:  BRA    98DE
098D8:  MOVLB  0
098DA:  GOTO   98F8
098DE:  BTFSS  xE4.1
098E0:  BRA    98E8
098E2:  MOVLB  0
098E4:  GOTO   9900
098E8:  BTFSS  xE4.0
098EA:  BRA    98F2
098EC:  MOVLB  0
098EE:  GOTO   9908
098F2:  MOVLB  0
098F4:  GOTO   9910
098F8:  MOVFF  2E5,AAD
098FC:  CALL   1B6C
09900:  MOVFF  2E6,AAD
09904:  CALL   1B6C
09908:  MOVFF  2E7,AAD
0990C:  CALL   1B6C
09910:  MOVFF  2E8,AAD
09914:  CALL   1B6C
09918:  RETURN 0
*
0A50E:  MOVF   FE9,W
0A510:  MOVLB  1
0A512:  MOVWF  xE9
0A514:  MOVLW  3B
0A516:  MOVWF  xF0
0A518:  MOVLW  9A
0A51A:  MOVWF  xEF
0A51C:  MOVLW  CA
0A51E:  MOVWF  xEE
0A520:  CLRF   xED
0A522:  MOVLW  0A
0A524:  MOVWF  xEB
0A526:  MOVLB  0
0A528:  BSF    FD8.1
0A52A:  MOVLW  01
0A52C:  MOVWF  FEA
0A52E:  MOVLW  E5
0A530:  MOVWF  FE9
0A532:  MOVFF  1E8,9DA
0A536:  MOVFF  1E7,9D9
0A53A:  MOVFF  1E6,9D8
0A53E:  MOVFF  1E5,9D7
0A542:  MOVFF  1F0,9DE
0A546:  MOVFF  1EF,9DD
0A54A:  MOVFF  1EE,9DC
0A54E:  MOVFF  1ED,9DB
0A552:  CALL   6432
0A556:  MOVF   01,W
0A558:  MOVF   00,F
0A55A:  BTFSS  FD8.2
0A55C:  GOTO   A5B4
0A560:  MOVLB  1
0A562:  MOVF   xEB,W
0A564:  XORLW  01
0A566:  BTFSS  FD8.2
0A568:  BRA    A570
0A56A:  MOVLB  0
0A56C:  GOTO   A5B4
0A570:  MOVF   xE9,W
0A572:  BTFSS  FD8.2
0A574:  BRA    A57C
0A576:  MOVLB  0
0A578:  GOTO   A5BA
0A57C:  ANDLW  0F
0A57E:  SUBWF  xEB,W
0A580:  BTFSS  FD8.2
0A582:  BRA    A58A
0A584:  MOVLB  0
0A586:  GOTO   A596
0A58A:  BTFSS  FD8.0
0A58C:  BRA    A594
0A58E:  MOVLB  0
0A590:  GOTO   A5C6
0A594:  MOVLB  0
0A596:  MOVLB  1
0A598:  BTFSS  xE9.7
0A59A:  BRA    A5A2
0A59C:  MOVLB  0
0A59E:  GOTO   A5C6
0A5A2:  BTFSS  xE9.6
0A5A4:  BRA    A5AC
0A5A6:  MOVLB  0
0A5A8:  GOTO   A5BA
0A5AC:  MOVLW  20
0A5AE:  MOVLB  0
0A5B0:  GOTO   A5BC
0A5B4:  MOVLB  1
0A5B6:  CLRF   xE9
0A5B8:  MOVLB  0
0A5BA:  MOVLW  30
0A5BC:  ADDWF  00,F
0A5BE:  MOVFF  00,AAD
0A5C2:  CALL   1B6C
0A5C6:  BCF    FD8.1
0A5C8:  MOVFF  1F0,9DA
0A5CC:  MOVFF  1EF,9D9
0A5D0:  MOVFF  1EE,9D8
0A5D4:  MOVFF  1ED,9D7
0A5D8:  MOVLB  9
0A5DA:  CLRF   xDE
0A5DC:  CLRF   xDD
0A5DE:  CLRF   xDC
0A5E0:  MOVLW  0A
0A5E2:  MOVWF  xDB
0A5E4:  MOVLB  0
0A5E6:  CALL   6432
0A5EA:  MOVFF  03,1F0
0A5EE:  MOVFF  02,1EF
0A5F2:  MOVFF  01,1EE
0A5F6:  MOVFF  00,1ED
0A5FA:  MOVLB  1
0A5FC:  DECFSZ xEB,F
0A5FE:  BRA    A604
0A600:  BRA    A60A
0A602:  MOVLB  0
0A604:  MOVLB  0
0A606:  GOTO   A528
0A60A:  MOVLB  0
0A60C:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01B3E:  MOVLW  0A
01B40:  MOVWF  FEA
01B42:  MOVLW  6E
01B44:  MOVWF  FE9
01B46:  MOVF   FEF,W
01B48:  BTFSC  FD8.2
01B4A:  GOTO   1B6A
01B4E:  MOVLW  05
01B50:  MOVWF  01
01B52:  CLRF   00
01B54:  DECFSZ 00,F
01B56:  BRA    1B54
01B58:  DECFSZ 01,F
01B5A:  BRA    1B52
01B5C:  MOVLW  2E
01B5E:  MOVWF  00
01B60:  DECFSZ 00,F
01B62:  BRA    1B60
01B64:  BRA    1B66
01B66:  DECFSZ FEF,F
01B68:  BRA    1B4E
01B6A:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
03F46:  BTFSS  FA6.4
03F48:  GOTO   3F46
03F4C:  MOVLB  F
03F4E:  MOVWF  x29
03F50:  MOVLB  0
03F52:  GOTO   3F88 (RETURN)
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01B6C:  BCF    F93.6
01B6E:  BCF    F8A.6
01B70:  MOVLW  08
01B72:  MOVWF  01
01B74:  BRA    1B76
01B76:  NOP   
01B78:  BSF    01.7
01B7A:  GOTO   1BA2
01B7E:  BCF    01.7
01B80:  MOVLB  A
01B82:  RRCF   xAD,F
01B84:  MOVLB  0
01B86:  BTFSC  FD8.0
01B88:  BSF    F8A.6
01B8A:  BTFSS  FD8.0
01B8C:  BCF    F8A.6
01B8E:  BSF    01.6
01B90:  GOTO   1BA2
01B94:  BCF    01.6
01B96:  DECFSZ 01,F
01B98:  GOTO   1B80
01B9C:  BRA    1B9E
01B9E:  NOP   
01BA0:  BSF    F8A.6
01BA2:  MOVLW  84
01BA4:  MOVWF  FE9
01BA6:  DECFSZ FE9,F
01BA8:  GOTO   1BA6
01BAC:  BRA    1BAE
01BAE:  NOP   
01BB0:  BTFSC  01.7
01BB2:  GOTO   1B7E
01BB6:  BTFSC  01.6
01BB8:  GOTO   1B94
01BBC:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
02428:  MOVLB  A
0242A:  MOVF   x91,W
0242C:  SUBLW  08
0242E:  BTFSS  FD8.2
02430:  BRA    2438
02432:  MOVLB  0
02434:  GOTO   2450
02438:  MOVWF  x93
0243A:  MOVLB  0
0243C:  MOVLB  A
0243E:  RLCF   x90,F
02440:  DECFSZ x93,F
02442:  BRA    2448
02444:  BRA    244E
02446:  MOVLB  0
02448:  MOVLB  0
0244A:  GOTO   243C
0244E:  MOVLB  0
02450:  BSF    F92.1
02452:  BCF    F92.0
02454:  BCF    F92.3
02456:  BCF    F89.3
02458:  MOVFF  A91,A93
0245C:  MOVLB  A
0245E:  BTFSS  x90.7
02460:  BCF    F89.0
02462:  BTFSC  x90.7
02464:  BSF    F89.0
02466:  RLCF   x90,F
02468:  BSF    F89.3
0246A:  MOVLW  02
0246C:  MOVWF  x94
0246E:  MOVLB  0
02470:  MOVLB  A
02472:  DECFSZ x94,F
02474:  BRA    247A
02476:  BRA    2480
02478:  MOVLB  0
0247A:  MOVLB  0
0247C:  GOTO   2470
02480:  RLCF   01,F
02482:  BTFSS  F80.1
02484:  BCF    01.0
02486:  BTFSC  F80.1
02488:  BSF    01.0
0248A:  BCF    F89.3
0248C:  MOVLB  0
0248E:  BRA    2490
02490:  MOVLB  A
02492:  DECFSZ x93,F
02494:  BRA    249A
02496:  BRA    24A0
02498:  MOVLB  0
0249A:  MOVLB  0
0249C:  GOTO   245C
024A0:  MOVLB  0
024A2:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
023AC:  MOVLB  A
023AE:  MOVF   x91,W
023B0:  SUBLW  08
023B2:  BTFSS  FD8.2
023B4:  BRA    23BC
023B6:  MOVLB  0
023B8:  GOTO   23D4
023BC:  MOVWF  x93
023BE:  MOVLB  0
023C0:  MOVLB  A
023C2:  RLCF   x90,F
023C4:  DECFSZ x93,F
023C6:  BRA    23CC
023C8:  BRA    23D2
023CA:  MOVLB  0
023CC:  MOVLB  0
023CE:  GOTO   23C0
023D2:  MOVLB  0
023D4:  BSF    F96.0
023D6:  BCF    F96.6
023D8:  BCF    F96.1
023DA:  BCF    F8D.1
023DC:  MOVFF  A91,A93
023E0:  MOVLB  A
023E2:  BTFSS  x90.7
023E4:  BCF    F8D.6
023E6:  BTFSC  x90.7
023E8:  BSF    F8D.6
023EA:  RLCF   x90,F
023EC:  BSF    F8D.1
023EE:  MOVLW  02
023F0:  MOVWF  x94
023F2:  MOVLB  0
023F4:  MOVLB  A
023F6:  DECFSZ x94,F
023F8:  BRA    23FE
023FA:  BRA    2404
023FC:  MOVLB  0
023FE:  MOVLB  0
02400:  GOTO   23F4
02404:  RLCF   01,F
02406:  BTFSS  F84.0
02408:  BCF    01.0
0240A:  BTFSC  F84.0
0240C:  BSF    01.0
0240E:  BCF    F8D.1
02410:  MOVLB  0
02412:  BRA    2414
02414:  MOVLB  A
02416:  DECFSZ x93,F
02418:  BRA    241E
0241A:  BRA    2424
0241C:  MOVLB  0
0241E:  MOVLB  0
02420:  GOTO   23E0
02424:  MOVLB  0
02426:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01D48:  MOVLB  9
01D4A:  MOVF   xE0,W
01D4C:  SUBLW  10
01D4E:  BTFSS  FD8.2
01D50:  BRA    1D58
01D52:  MOVLB  0
01D54:  GOTO   1D72
01D58:  MOVWF  xE2
01D5A:  MOVLB  0
01D5C:  MOVLB  9
01D5E:  RLCF   xDE,F
01D60:  RLCF   xDF,F
01D62:  DECFSZ xE2,F
01D64:  BRA    1D6A
01D66:  BRA    1D70
01D68:  MOVLB  0
01D6A:  MOVLB  0
01D6C:  GOTO   1D5C
01D70:  MOVLB  0
01D72:  BSF    F93.4
01D74:  BCF    F93.5
01D76:  BCF    F93.2
01D78:  BSF    F8A.2
01D7A:  MOVFF  9E0,9E2
01D7E:  MOVLB  9
01D80:  BTFSS  xDF.7
01D82:  BCF    F8A.5
01D84:  BTFSC  xDF.7
01D86:  BSF    F8A.5
01D88:  RLCF   xDE,F
01D8A:  RLCF   xDF,F
01D8C:  BCF    F8A.2
01D8E:  RLCF   01,F
01D90:  RLCF   02,F
01D92:  BTFSS  F81.4
01D94:  BCF    01.0
01D96:  BTFSC  F81.4
01D98:  BSF    01.0
01D9A:  BSF    F8A.2
01D9C:  DECFSZ xE2,F
01D9E:  BRA    1DA4
01DA0:  BRA    1DAA
01DA2:  MOVLB  0
01DA4:  MOVLB  0
01DA6:  GOTO   1D7E
01DAA:  MOVLB  0
01DAC:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/mcu/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/devices/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "../core/measurement/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/storage/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../../system/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "../application/mission/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... #include "../hardware/mcu/src/timer.c"
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
*
000CA:  MOVLW  80
000CC:  MOVWF  FCF
000CE:  MOVLW  12
000D0:  MOVWF  FCE
000D2:  NOP   
....................    sec++;
000D4:  MOVLW  01
000D6:  ADDWF  20,F
000D8:  BTFSC  FD8.0
000DA:  INCF   21,F
000DC:  BTFSC  FD8.2
000DE:  INCF   22,F
000E0:  BTFSC  FD8.2
000E2:  INCF   23,F
....................    /*
....................    if (++subsec >= 100)
....................    {
....................       subsec = 0;
....................       sec++;
.................... 
....................       if (sec >= SEC_IN_A_DAY)
....................       {
....................          day++;
....................       }
....................    }*/
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01C9C:  MOVLW  EA
01C9E:  MOVWF  FF6
01CA0:  MOVLW  00
01CA2:  MOVWF  FF7
01CA4:  MOVLW  00
01CA6:  MOVWF  FF8
01CA8:  CALL   1BBE
....................    clear_interrupt(INT_TIMER1);
01CAC:  BCF    F9E.0
....................    //sec = 0;
....................    // 外部クロックをT1CKIピンから入力、プリスケーラなし
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01CAE:  MOVLW  8F
01CB0:  MOVWF  FCD
01CB2:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01CB4:  MOVLW  80
01CB6:  MOVWF  FCF
01CB8:  MOVLW  12
01CBA:  MOVWF  FCE
01CBC:  NOP   
....................    //set_timer1(0);  // タイマーカウント初期値設定
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);   
01CBE:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01CC0:  MOVLW  C0
01CC2:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CC4:  MOVLW  FE
01CC6:  MOVWF  FF6
01CC8:  MOVLW  00
01CCA:  MOVWF  FF7
01CCC:  MOVLW  00
01CCE:  MOVWF  FF8
01CD0:  CALL   1BBE
01CD4:  GOTO   B62E (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
031C0:  MOVFF  20,00
031C4:  MOVFF  21,01
031C8:  MOVFF  22,02
031CC:  MOVFF  23,03
031D0:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
*
0650C:  BCF    FD8.1
0650E:  MOVFF  1F,9DA
06512:  MOVFF  1E,9D9
06516:  MOVFF  1D,9D8
0651A:  MOVFF  1C,9D7
0651E:  MOVLB  9
06520:  CLRF   xDE
06522:  CLRF   xDD
06524:  CLRF   xDC
06526:  MOVLW  0A
06528:  MOVWF  xDB
0652A:  MOVLB  0
0652C:  CALL   6432
06530:  MOVF   01,W
06532:  MOVWF  02
06534:  MOVF   00,W
06536:  MOVWF  01
06538:  GOTO   6554 (RETURN)
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/mcu/src/uart.c"
.................... #INT_RDA3
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  47.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   46,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   46,W
0014C:  INCF   46,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  26
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,ABE
00160:  MOVFF  FE9,ABD
00164:  GOTO   010A
00168:  MOVFF  ABE,FEA
0016C:  MOVFF  ABD,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
.................... 
....................    // fprintf(PC, "RDA Interrupt: %d bytes received\r\n", boss_receive_buffer_size);
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01C72:  MOVLW  7A
01C74:  MOVWF  FF6
01C76:  MOVLW  01
01C78:  MOVWF  FF7
01C7A:  MOVLW  00
01C7C:  MOVWF  FF8
01C7E:  CALL   1BBE
....................    enable_interrupts(INT_RDA3);
01C82:  BSF    F61.5
....................    enable_interrupts(global);
01C84:  MOVLW  C0
01C86:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01C88:  MOVLW  8C
01C8A:  MOVWF  FF6
01C8C:  MOVLW  01
01C8E:  MOVWF  FF7
01C90:  MOVLW  00
01C92:  MOVWF  FF8
01C94:  CALL   1BBE
01C98:  GOTO   B62A (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
03F08:  MOVFF  187,03
03F0C:  MOVLB  1
03F0E:  MOVF   x86,W
03F10:  MOVWF  FE9
03F12:  MOVFF  03,FEA
03F16:  MOVFF  FEF,188
03F1A:  MOVFF  185,FEA
03F1E:  MOVFF  184,FE9
03F22:  CLRF   00
03F24:  CLRF   02
03F26:  MOVFF  188,01
03F2A:  MOVLB  0
03F2C:  CALL   27A0
....................    *receive_signal_size = 0;
03F30:  MOVFF  187,03
03F34:  MOVLB  1
03F36:  MOVF   x86,W
03F38:  MOVWF  FE9
03F3A:  MOVFF  03,FEA
03F3E:  CLRF   FEF
03F40:  MOVLB  0
03F42:  GOTO   B6D0 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/ad7490_driver.c"
.................... #include "../ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01EB2:  MOVLW  98
01EB4:  MOVWF  FF6
01EB6:  MOVLW  01
01EB8:  MOVWF  FF7
01EBA:  MOVLW  00
01EBC:  MOVWF  FF8
01EBE:  CALL   1BBE
....................     output_high(ADC_CS); // Set CS pin high to deselect the ADC
01EC2:  MOVLW  F4
01EC4:  MOVWF  F93
01EC6:  BSF    F8A.1
....................     delay_ms(10); // Wait for the ADC to stabilize
01EC8:  MOVLW  0A
01ECA:  MOVLB  A
01ECC:  MOVWF  x6E
01ECE:  MOVLB  0
01ED0:  CALL   1B3E
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR); // Read a dummy value to initialize the ADC
01ED4:  MOVLW  05
01ED6:  MOVLB  9
01ED8:  MOVWF  xD7
01EDA:  MOVLB  0
01EDC:  CALL   1DAE
01EE0:  MOVFF  02,185
01EE4:  MOVFF  01,184
....................     delay_ms(1); // Wait for the ADC to stabilize after reading
01EE8:  MOVLW  01
01EEA:  MOVLB  A
01EEC:  MOVWF  x6E
01EEE:  MOVLB  0
01EF0:  CALL   1B3E
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01EF4:  MOVLW  09
01EF6:  MOVLB  A
01EF8:  MOVWF  xAD
01EFA:  MOVLB  0
01EFC:  CALL   1B6C
01F00:  MOVFF  185,264
01F04:  MOVLW  37
01F06:  MOVLB  2
01F08:  MOVWF  x65
01F0A:  MOVLB  0
01F0C:  CALL   1E42
01F10:  MOVFF  184,264
01F14:  MOVLW  37
01F16:  MOVLB  2
01F18:  MOVWF  x65
01F1A:  MOVLB  0
01F1C:  CALL   1E42
01F20:  MOVLW  0D
01F22:  MOVLB  A
01F24:  MOVWF  xAD
01F26:  MOVLB  0
01F28:  CALL   1B6C
01F2C:  MOVLW  0A
01F2E:  MOVLB  A
01F30:  MOVWF  xAD
01F32:  MOVLB  0
01F34:  CALL   1B6C
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F38:  MOVLB  1
01F3A:  INCFSZ x84,W
01F3C:  BRA    1F42
01F3E:  BRA    1F48
01F40:  MOVLB  0
01F42:  MOVLB  0
01F44:  GOTO   1F60
01F48:  MOVLB  0
01F4A:  MOVLB  1
01F4C:  INCFSZ x85,W
01F4E:  BRA    1F54
01F50:  BRA    1F5A
01F52:  MOVLB  0
01F54:  MOVLB  0
01F56:  GOTO   1F60
01F5A:  MOVLB  0
01F5C:  GOTO   1F80
01F60:  MOVLB  1
01F62:  MOVF   x84,F
01F64:  BTFSC  FD8.2
01F66:  BRA    1F6E
01F68:  MOVLB  0
01F6A:  GOTO   1F94
01F6E:  MOVLB  0
01F70:  MOVLB  1
01F72:  MOVF   x85,F
01F74:  BTFSC  FD8.2
01F76:  BRA    1F7E
01F78:  MOVLB  0
01F7A:  GOTO   1F94
01F7E:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01F80:  MOVLW  AC
01F82:  MOVWF  FF6
01F84:  MOVLW  01
01F86:  MOVWF  FF7
01F88:  MOVLW  00
01F8A:  MOVWF  FF8
01F8C:  CALL   1BBE
....................     } else {
01F90:  GOTO   1FA4
....................         fprintf(PC, "\tConnect successful\r\n");
01F94:  MOVLW  BE
01F96:  MOVWF  FF6
01F98:  MOVLW  01
01F9A:  MOVWF  FF7
01F9C:  MOVLW  00
01F9E:  MOVWF  FF8
01FA0:  CALL   1BBE
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01FA4:  MOVLW  D4
01FA6:  MOVWF  FF6
01FA8:  MOVLW  01
01FAA:  MOVWF  FF7
01FAC:  MOVLW  00
01FAE:  MOVWF  FF8
01FB0:  CALL   1BBE
01FB4:  GOTO   B632 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01DAE:  MOVFF  9D7,9DE
01DB2:  GOTO   1CD8
01DB6:  MOVFF  02,9D9
01DBA:  MOVFF  01,9D8
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     // Send the command to the ADC
....................     output_low(ADC_CS); // Set CS pin low to select the ADC
01DBE:  MOVLW  F4
01DC0:  MOVWF  F93
01DC2:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01DC4:  MOVLW  0D
01DC6:  MOVWF  00
01DC8:  DECFSZ 00,F
01DCA:  BRA    1DC8
....................     spi_xfer(ADC_STREAM, cmd); // Dummy transfer to start communication
01DCC:  MOVFF  9D9,9DF
01DD0:  MOVFF  9D8,9DE
01DD4:  MOVLW  10
01DD6:  MOVLB  9
01DD8:  MOVWF  xE0
01DDA:  MOVLW  01
01DDC:  MOVWF  xE1
01DDE:  MOVLB  0
01DE0:  CALL   1D48
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     delay_us(10); // Wait for the ADC to process the command
01DE4:  MOVLW  0D
01DE6:  MOVWF  00
01DE8:  DECFSZ 00,F
01DEA:  BRA    1DE8
....................     output_high(ADC_CS); // Set CS pin high to end communication
01DEC:  MOVLW  F4
01DEE:  MOVWF  F93
01DF0:  BSF    F8A.1
....................     delay_us(10); // Wait for the ADC to process the command
01DF2:  MOVLW  0D
01DF4:  MOVWF  00
01DF6:  DECFSZ 00,F
01DF8:  BRA    1DF6
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01DFA:  MOVLW  F4
01DFC:  MOVWF  F93
01DFE:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01E00:  MOVLW  0D
01E02:  MOVWF  00
01E04:  DECFSZ 00,F
01E06:  BRA    1E04
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000); // Read data from ADC
01E08:  MOVLB  9
01E0A:  CLRF   xDF
01E0C:  CLRF   xDE
01E0E:  MOVLW  10
01E10:  MOVWF  xE0
01E12:  MOVLW  01
01E14:  MOVWF  xE1
01E16:  MOVLB  0
01E18:  CALL   1D48
01E1C:  MOVFF  02,9DB
01E20:  MOVFF  01,9DA
....................     output_high(ADC_CS); 
01E24:  MOVLW  F4
01E26:  MOVWF  F93
01E28:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E2A:  MOVLB  9
01E2C:  MOVF   xDA,W
01E2E:  MOVWF  xDC
01E30:  MOVF   xDB,W
01E32:  ANDLW  0F
01E34:  MOVWF  xDD
....................     
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E36:  MOVF   xDC,W
01E38:  MOVWF  01
01E3A:  MOVF   xDD,W
01E3C:  MOVWF  02
01E3E:  MOVLB  0
01E40:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/mcp4901_driver.c"
.................... #include "../mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
02190:  MOVLW  E0
02192:  MOVWF  FF6
02194:  MOVLW  01
02196:  MOVWF  FF7
02198:  MOVLW  00
0219A:  MOVWF  FF8
0219C:  CALL   1BBE
....................     output_high(DAC1_CS); 
021A0:  MOVLW  F4
021A2:  MOVWF  F93
021A4:  BSF    F8A.3
....................     output_high(DAC2_CS); 
021A6:  MOVLW  F4
021A8:  MOVWF  F93
021AA:  BSF    F8A.0
....................     delay_ms(10); 
021AC:  MOVLW  0A
021AE:  MOVLB  A
021B0:  MOVWF  x6E
021B2:  MOVLB  0
021B4:  CALL   1B3E
....................     mcp4901_1_write(10); 
021B8:  MOVLB  9
021BA:  CLRF   xC3
021BC:  MOVLW  0A
021BE:  MOVWF  xC2
021C0:  MOVLB  0
021C2:  CALL   210C
....................     mcp4901_2_write(10); 
021C6:  MOVLB  9
021C8:  CLRF   xC3
021CA:  MOVLW  0A
021CC:  MOVWF  xC2
021CE:  MOVLB  0
021D0:  CALL   214E
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
021D4:  MOVLW  08
021D6:  MOVLB  9
021D8:  MOVWF  xD7
021DA:  MOVLB  0
021DC:  CALL   1DAE
021E0:  MOVFF  02,185
021E4:  MOVFF  01,184
....................     fprintf(PC, "%04LX\r\n", readdata);
021E8:  MOVFF  185,264
021EC:  MOVLW  37
021EE:  MOVLB  2
021F0:  MOVWF  x65
021F2:  MOVLB  0
021F4:  CALL   1E42
021F8:  MOVFF  184,264
021FC:  MOVLW  37
021FE:  MOVLB  2
02200:  MOVWF  x65
02202:  MOVLB  0
02204:  CALL   1E42
02208:  MOVLW  0D
0220A:  MOVLB  A
0220C:  MOVWF  xAD
0220E:  MOVLB  0
02210:  CALL   1B6C
02214:  MOVLW  0A
02216:  MOVLB  A
02218:  MOVWF  xAD
0221A:  MOVLB  0
0221C:  CALL   1B6C
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
02220:  MOVLB  1
02222:  INCFSZ x84,W
02224:  BRA    222A
02226:  BRA    2230
02228:  MOVLB  0
0222A:  MOVLB  0
0222C:  GOTO   2248
02230:  MOVLB  0
02232:  MOVLB  1
02234:  INCFSZ x85,W
02236:  BRA    223C
02238:  BRA    2242
0223A:  MOVLB  0
0223C:  MOVLB  0
0223E:  GOTO   2248
02242:  MOVLB  0
02244:  GOTO   2268
02248:  MOVLB  1
0224A:  MOVF   x84,F
0224C:  BTFSC  FD8.2
0224E:  BRA    2256
02250:  MOVLB  0
02252:  GOTO   227C
02256:  MOVLB  0
02258:  MOVLB  1
0225A:  MOVF   x85,F
0225C:  BTFSC  FD8.2
0225E:  BRA    2266
02260:  MOVLB  0
02262:  GOTO   227C
02266:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
02268:  MOVLW  F6
0226A:  MOVWF  FF6
0226C:  MOVLW  01
0226E:  MOVWF  FF7
02270:  MOVLW  00
02272:  MOVWF  FF8
02274:  CALL   1BBE
....................     } else {
02278:  GOTO   228C
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
0227C:  MOVLW  16
0227E:  MOVWF  FF6
02280:  MOVLW  02
02282:  MOVWF  FF7
02284:  MOVLW  00
02286:  MOVWF  FF8
02288:  CALL   1BBE
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
0228C:  MOVFF  185,264
02290:  MOVLW  37
02292:  MOVLB  2
02294:  MOVWF  x65
02296:  MOVLB  0
02298:  CALL   1E42
0229C:  MOVFF  184,264
022A0:  MOVLW  37
022A2:  MOVLB  2
022A4:  MOVWF  x65
022A6:  MOVLB  0
022A8:  CALL   1E42
022AC:  MOVLW  0D
022AE:  MOVLB  A
022B0:  MOVWF  xAD
022B2:  MOVLB  0
022B4:  CALL   1B6C
022B8:  MOVLW  0A
022BA:  MOVLB  A
022BC:  MOVWF  xAD
022BE:  MOVLB  0
022C0:  CALL   1B6C
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
022C4:  MOVLW  09
022C6:  MOVLB  9
022C8:  MOVWF  xD7
022CA:  MOVLB  0
022CC:  CALL   1DAE
022D0:  MOVFF  02,185
022D4:  MOVFF  01,184
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
022D8:  MOVLB  1
022DA:  INCFSZ x84,W
022DC:  BRA    22E2
022DE:  BRA    22E8
022E0:  MOVLB  0
022E2:  MOVLB  0
022E4:  GOTO   2300
022E8:  MOVLB  0
022EA:  MOVLB  1
022EC:  INCFSZ x85,W
022EE:  BRA    22F4
022F0:  BRA    22FA
022F2:  MOVLB  0
022F4:  MOVLB  0
022F6:  GOTO   2300
022FA:  MOVLB  0
022FC:  GOTO   2320
02300:  MOVLB  1
02302:  MOVF   x84,F
02304:  BTFSC  FD8.2
02306:  BRA    230E
02308:  MOVLB  0
0230A:  GOTO   2334
0230E:  MOVLB  0
02310:  MOVLB  1
02312:  MOVF   x85,F
02314:  BTFSC  FD8.2
02316:  BRA    231E
02318:  MOVLB  0
0231A:  GOTO   2334
0231E:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
02320:  MOVLW  3A
02322:  MOVWF  FF6
02324:  MOVLW  02
02326:  MOVWF  FF7
02328:  MOVLW  00
0232A:  MOVWF  FF8
0232C:  CALL   1BBE
....................     } else {
02330:  GOTO   2344
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02334:  MOVLW  5A
02336:  MOVWF  FF6
02338:  MOVLW  02
0233A:  MOVWF  FF7
0233C:  MOVLW  00
0233E:  MOVWF  FF8
02340:  CALL   1BBE
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02344:  MOVLW  7E
02346:  MOVWF  FF6
02348:  MOVLW  02
0234A:  MOVWF  FF7
0234C:  MOVLW  00
0234E:  MOVWF  FF8
02350:  CALL   1BBE
02354:  GOTO   B636 (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
0210C:  MOVFF  9C3,9C7
02110:  MOVFF  9C2,9C6
02114:  CALL   1FB8
02118:  MOVFF  02,9C5
0211C:  MOVFF  01,9C4
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
02120:  MOVLW  F4
02122:  MOVWF  F93
02124:  BCF    F8A.3
....................    delay_us(10); 
02126:  MOVLW  0D
02128:  MOVWF  00
0212A:  DECFSZ 00,F
0212C:  BRA    212A
....................    spi_xfer(ADCDAC_STREAM, cmd); 
0212E:  MOVFF  9C5,9DF
02132:  MOVFF  9C4,9DE
02136:  MOVLW  10
02138:  MOVLB  9
0213A:  MOVWF  xE0
0213C:  MOVLW  01
0213E:  MOVWF  xE1
02140:  MOVLB  0
02142:  CALL   1D48
....................    output_high(DAC1_CS); 
02146:  MOVLW  F4
02148:  MOVWF  F93
0214A:  BSF    F8A.3
0214C:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
0214E:  MOVFF  9C3,9C7
02152:  MOVFF  9C2,9C6
02156:  CALL   1FB8
0215A:  MOVFF  02,9C5
0215E:  MOVFF  01,9C4
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
02162:  MOVLW  F4
02164:  MOVWF  F93
02166:  BCF    F8A.0
....................    delay_us(10); 
02168:  MOVLW  0D
0216A:  MOVWF  00
0216C:  DECFSZ 00,F
0216E:  BRA    216C
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02170:  MOVFF  9C5,9DF
02174:  MOVFF  9C4,9DE
02178:  MOVLW  10
0217A:  MOVLB  9
0217C:  MOVWF  xE0
0217E:  MOVLW  01
02180:  MOVWF  xE1
02182:  MOVLB  0
02184:  CALL   1D48
....................    output_high(DAC2_CS); 
02188:  MOVLW  F4
0218A:  MOVWF  F93
0218C:  BSF    F8A.0
0218E:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01CD8:  MOVLB  9
01CDA:  BCF    xDF.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01CDC:  BCF    xDF.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01CDE:  BCF    xDF.2
....................     cmd.fields.reserved3 = 0;
01CE0:  BCF    xDF.3
....................     cmd.fields.coding = 1; 
01CE2:  BSF    xDF.4
....................     cmd.fields.range = 0; 
01CE4:  BCF    xDF.5
....................     cmd.fields.weak_tri = 0; 
01CE6:  BCF    xDF.6
....................     cmd.fields.shadow = 0; 
01CE8:  BCF    xDF.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01CEA:  BSF    xE0.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01CEC:  BSF    xE0.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01CEE:  MOVF   xDE,W
01CF0:  ANDLW  01
01CF2:  MOVWF  01
01CF4:  BCF    xE0.2
01CF6:  BTFSC  01.0
01CF8:  BSF    xE0.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01CFA:  BCF    FD8.0
01CFC:  RRCF   xDE,W
01CFE:  ANDLW  01
01D00:  MOVWF  01
01D02:  BCF    xE0.3
01D04:  BTFSC  01.0
01D06:  BSF    xE0.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01D08:  RRCF   xDE,W
01D0A:  MOVWF  00
01D0C:  RRCF   00,F
01D0E:  MOVLW  3F
01D10:  ANDWF  00,F
01D12:  MOVF   00,W
01D14:  ANDLW  01
01D16:  MOVWF  01
01D18:  BCF    xE0.4
01D1A:  BTFSC  01.0
01D1C:  BSF    xE0.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D1E:  RRCF   xDE,W
01D20:  MOVWF  00
01D22:  RRCF   00,F
01D24:  RRCF   00,F
01D26:  MOVLW  1F
01D28:  ANDWF  00,F
01D2A:  MOVF   00,W
01D2C:  ANDLW  01
01D2E:  MOVWF  01
01D30:  BCF    xE0.5
01D32:  BTFSC  01.0
01D34:  BSF    xE0.5
....................     cmd.fields.seq = 0; // Random mode
01D36:  BCF    xE0.6
....................     cmd.fields.write = 1; // Read operation
01D38:  BSF    xE0.7
.................... 
.................... 
....................     return cmd.value;
01D3A:  MOVF   xDF,W
01D3C:  MOVWF  01
01D3E:  MOVF   xE0,W
01D40:  MOVWF  02
01D42:  MOVLB  0
01D44:  GOTO   1DB6 (RETURN)
.................... }
.................... 
.................... #include "../../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
01FB8:  MOVLB  9
01FBA:  BCF    xC9.7
....................    cmd.fields.buffer = 1; // Buffer used
01FBC:  BSF    xC9.6
....................    cmd.fields.gain = 1; // Gain 1x
01FBE:  BSF    xC9.5
....................    cmd.fields.shutdown = 1; // Normal operation
01FC0:  BSF    xC9.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
01FC2:  RRCF   xC7,W
01FC4:  MOVWF  xCB
01FC6:  RRCF   xC6,W
01FC8:  MOVWF  xCA
01FCA:  RRCF   xCB,F
01FCC:  RRCF   xCA,F
01FCE:  RRCF   xCB,F
01FD0:  RRCF   xCA,F
01FD2:  RRCF   xCB,F
01FD4:  RRCF   xCA,F
01FD6:  RRCF   xCB,F
01FD8:  RRCF   xCA,F
01FDA:  RRCF   xCB,F
01FDC:  RRCF   xCA,F
01FDE:  RRCF   xCB,F
01FE0:  RRCF   xCA,F
01FE2:  MOVLW  01
01FE4:  ANDWF  xCB,F
01FE6:  MOVF   xCA,W
01FE8:  ANDLW  01
01FEA:  MOVWF  00
01FEC:  CLRF   03
01FEE:  MOVF   00,W
01FF0:  MOVWF  01
01FF2:  BCF    xC9.3
01FF4:  BTFSC  01.0
01FF6:  BSF    xC9.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
01FF8:  RRCF   xC7,W
01FFA:  MOVWF  xCB
01FFC:  RRCF   xC6,W
01FFE:  MOVWF  xCA
02000:  RRCF   xCB,F
02002:  RRCF   xCA,F
02004:  RRCF   xCB,F
02006:  RRCF   xCA,F
02008:  RRCF   xCB,F
0200A:  RRCF   xCA,F
0200C:  RRCF   xCB,F
0200E:  RRCF   xCA,F
02010:  RRCF   xCB,F
02012:  RRCF   xCA,F
02014:  MOVLW  03
02016:  ANDWF  xCB,F
02018:  MOVF   xCA,W
0201A:  ANDLW  01
0201C:  MOVWF  00
0201E:  CLRF   03
02020:  MOVF   00,W
02022:  MOVWF  01
02024:  BCF    xC9.2
02026:  BTFSC  01.0
02028:  BSF    xC9.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
0202A:  RRCF   xC7,W
0202C:  MOVWF  xCB
0202E:  RRCF   xC6,W
02030:  MOVWF  xCA
02032:  RRCF   xCB,F
02034:  RRCF   xCA,F
02036:  RRCF   xCB,F
02038:  RRCF   xCA,F
0203A:  RRCF   xCB,F
0203C:  RRCF   xCA,F
0203E:  RRCF   xCB,F
02040:  RRCF   xCA,F
02042:  MOVLW  07
02044:  ANDWF  xCB,F
02046:  MOVF   xCA,W
02048:  ANDLW  01
0204A:  MOVWF  00
0204C:  CLRF   03
0204E:  MOVF   00,W
02050:  MOVWF  01
02052:  BCF    xC9.1
02054:  BTFSC  01.0
02056:  BSF    xC9.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
02058:  RRCF   xC7,W
0205A:  MOVWF  xCB
0205C:  RRCF   xC6,W
0205E:  MOVWF  xCA
02060:  RRCF   xCB,F
02062:  RRCF   xCA,F
02064:  RRCF   xCB,F
02066:  RRCF   xCA,F
02068:  RRCF   xCB,F
0206A:  RRCF   xCA,F
0206C:  MOVLW  0F
0206E:  ANDWF  xCB,F
02070:  MOVF   xCA,W
02072:  ANDLW  01
02074:  MOVWF  00
02076:  CLRF   03
02078:  MOVF   00,W
0207A:  MOVWF  01
0207C:  BCF    xC9.0
0207E:  BTFSC  01.0
02080:  BSF    xC9.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
02082:  RRCF   xC7,W
02084:  MOVWF  xCB
02086:  RRCF   xC6,W
02088:  MOVWF  xCA
0208A:  RRCF   xCB,F
0208C:  RRCF   xCA,F
0208E:  RRCF   xCB,F
02090:  RRCF   xCA,F
02092:  MOVLW  1F
02094:  ANDWF  xCB,F
02096:  MOVF   xCA,W
02098:  ANDLW  01
0209A:  MOVWF  00
0209C:  CLRF   03
0209E:  MOVF   00,W
020A0:  MOVWF  01
020A2:  BCF    xC8.7
020A4:  BTFSC  01.0
020A6:  BSF    xC8.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
020A8:  RRCF   xC7,W
020AA:  MOVWF  xCB
020AC:  RRCF   xC6,W
020AE:  MOVWF  xCA
020B0:  RRCF   xCB,F
020B2:  RRCF   xCA,F
020B4:  MOVLW  3F
020B6:  ANDWF  xCB,F
020B8:  MOVF   xCA,W
020BA:  ANDLW  01
020BC:  MOVWF  00
020BE:  CLRF   03
020C0:  MOVF   00,W
020C2:  MOVWF  01
020C4:  BCF    xC8.6
020C6:  BTFSC  01.0
020C8:  BSF    xC8.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
020CA:  BCF    FD8.0
020CC:  RRCF   xC7,W
020CE:  MOVWF  xCB
020D0:  RRCF   xC6,W
020D2:  MOVWF  xCA
020D4:  MOVF   xCA,W
020D6:  ANDLW  01
020D8:  MOVWF  00
020DA:  CLRF   03
020DC:  MOVF   00,W
020DE:  MOVWF  01
020E0:  BCF    xC8.5
020E2:  BTFSC  01.0
020E4:  BSF    xC8.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
020E6:  MOVF   xC6,W
020E8:  ANDLW  01
020EA:  MOVWF  00
020EC:  CLRF   03
020EE:  MOVF   00,W
020F0:  MOVWF  01
020F2:  BCF    xC8.4
020F4:  BTFSC  01.0
020F6:  BSF    xC8.4
....................    cmd.fields.reserved = 0; // Reserved bits
020F8:  BCF    xC8.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
020FA:  BCF    xC8.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
020FC:  BCF    xC8.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
020FE:  BCF    xC8.0
.................... 
....................    return cmd.value;
02100:  MOVF   xC8,W
02102:  MOVWF  01
02104:  MOVF   xC9,W
02106:  MOVWF  02
02108:  MOVLB  0
0210A:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
031D2:  MOVLB  A
031D4:  MOVF   x6E,W
031D6:  XORLW  00
031D8:  MOVLB  0
031DA:  BTFSC  FD8.2
031DC:  GOTO   31EC
031E0:  XORLW  01
031E2:  BTFSC  FD8.2
031E4:  GOTO   3254
031E8:  GOTO   32BC
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
031EC:  MOVLB  A
031EE:  CLRF   x77
031F0:  CLRF   x76
031F2:  MOVLB  0
031F4:  MOVLB  A
031F6:  MOVF   x77,W
031F8:  SUBWF  x75,W
031FA:  BTFSC  FD8.0
031FC:  BRA    3204
031FE:  MOVLB  0
03200:  GOTO   3250
03204:  MOVLB  0
03206:  BTFSS  FD8.2
03208:  GOTO   321E
0320C:  MOVLB  A
0320E:  MOVF   x74,W
03210:  SUBWF  x76,W
03212:  BTFSS  FD8.0
03214:  BRA    321C
03216:  MOVLB  0
03218:  GOTO   3250
0321C:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
0321E:  MOVLB  A
03220:  MOVF   x72,W
03222:  ADDWF  x76,W
03224:  MOVWF  FE9
03226:  MOVF   x73,W
03228:  ADDWFC x77,W
0322A:  MOVWF  FEA
0322C:  MOVFF  FEF,A7A
03230:  MOVFF  A7A,A90
03234:  MOVLW  08
03236:  MOVWF  x91
03238:  MOVLW  01
0323A:  MOVWF  x92
0323C:  MOVLB  0
0323E:  CALL   23AC
03242:  MOVLB  A
03244:  INCF   x76,F
03246:  BTFSC  FD8.2
03248:  INCF   x77,F
0324A:  MOVLB  0
0324C:  GOTO   31F4
....................          break;
03250:  GOTO   32C0
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03254:  MOVLB  A
03256:  CLRF   x79
03258:  CLRF   x78
0325A:  MOVLB  0
0325C:  MOVLB  A
0325E:  MOVF   x79,W
03260:  SUBWF  x75,W
03262:  BTFSC  FD8.0
03264:  BRA    326C
03266:  MOVLB  0
03268:  GOTO   32B8
0326C:  MOVLB  0
0326E:  BTFSS  FD8.2
03270:  GOTO   3286
03274:  MOVLB  A
03276:  MOVF   x74,W
03278:  SUBWF  x78,W
0327A:  BTFSS  FD8.0
0327C:  BRA    3284
0327E:  MOVLB  0
03280:  GOTO   32B8
03284:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
03286:  MOVLB  A
03288:  MOVF   x72,W
0328A:  ADDWF  x78,W
0328C:  MOVWF  FE9
0328E:  MOVF   x73,W
03290:  ADDWFC x79,W
03292:  MOVWF  FEA
03294:  MOVFF  FEF,A7A
03298:  MOVFF  A7A,A90
0329C:  MOVLW  08
0329E:  MOVWF  x91
032A0:  MOVLW  01
032A2:  MOVWF  x92
032A4:  MOVLB  0
032A6:  CALL   2428
032AA:  MOVLB  A
032AC:  INCF   x78,F
032AE:  BTFSC  FD8.2
032B0:  INCF   x79,F
032B2:  MOVLB  0
032B4:  GOTO   325C
....................          break;
032B8:  GOTO   32C0
....................          
....................       default:
....................          break;
032BC:  GOTO   32C0
....................    }
....................    return;
032C0:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
024A4:  MOVLB  A
024A6:  MOVF   x74,W
024A8:  XORLW  00
024AA:  MOVLB  0
024AC:  BTFSC  FD8.2
024AE:  GOTO   24BE
024B2:  XORLW  01
024B4:  BTFSC  FD8.2
024B6:  GOTO   25C8
024BA:  GOTO   26D2
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
024BE:  MOVLB  A
024C0:  CLRF   x83
024C2:  CLRF   x82
024C4:  MOVLB  0
024C6:  MOVLB  A
024C8:  MOVF   x83,W
024CA:  SUBWF  x7B,W
024CC:  BTFSC  FD8.0
024CE:  BRA    24D6
024D0:  MOVLB  0
024D2:  GOTO   2522
024D6:  MOVLB  0
024D8:  BTFSS  FD8.2
024DA:  GOTO   24F0
024DE:  MOVLB  A
024E0:  MOVF   x7A,W
024E2:  SUBWF  x82,W
024E4:  BTFSS  FD8.0
024E6:  BRA    24EE
024E8:  MOVLB  0
024EA:  GOTO   2522
024EE:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
024F0:  MOVLB  A
024F2:  MOVF   x78,W
024F4:  ADDWF  x82,W
024F6:  MOVWF  FE9
024F8:  MOVF   x79,W
024FA:  ADDWFC x83,W
024FC:  MOVWF  FEA
024FE:  MOVFF  FEF,A8E
02502:  MOVFF  A8E,A90
02506:  MOVLW  08
02508:  MOVWF  x91
0250A:  MOVLW  01
0250C:  MOVWF  x92
0250E:  MOVLB  0
02510:  CALL   23AC
02514:  MOVLB  A
02516:  INCF   x82,F
02518:  BTFSC  FD8.2
0251A:  INCF   x83,F
0251C:  MOVLB  0
0251E:  GOTO   24C6
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02522:  MOVLB  A
02524:  CLRF   x87
02526:  CLRF   x86
02528:  CLRF   x85
0252A:  CLRF   x84
0252C:  MOVLB  0
0252E:  MOVLB  A
02530:  MOVF   x87,W
02532:  SUBWF  x81,W
02534:  BTFSC  FD8.0
02536:  BRA    253E
02538:  MOVLB  0
0253A:  GOTO   25C4
0253E:  MOVLB  0
02540:  BTFSS  FD8.2
02542:  GOTO   2588
02546:  MOVLB  A
02548:  MOVF   x86,W
0254A:  SUBWF  x80,W
0254C:  BTFSC  FD8.0
0254E:  BRA    2556
02550:  MOVLB  0
02552:  GOTO   25C4
02556:  MOVLB  0
02558:  BTFSS  FD8.2
0255A:  GOTO   2588
0255E:  MOVLB  A
02560:  MOVF   x85,W
02562:  SUBWF  x7F,W
02564:  BTFSC  FD8.0
02566:  BRA    256E
02568:  MOVLB  0
0256A:  GOTO   25C4
0256E:  MOVLB  0
02570:  BTFSS  FD8.2
02572:  GOTO   2588
02576:  MOVLB  A
02578:  MOVF   x7E,W
0257A:  SUBWF  x84,W
0257C:  BTFSS  FD8.0
0257E:  BRA    2586
02580:  MOVLB  0
02582:  GOTO   25C4
02586:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
02588:  MOVLB  A
0258A:  MOVF   x7C,W
0258C:  ADDWF  x84,W
0258E:  MOVWF  FE9
02590:  MOVF   x7D,W
02592:  ADDWFC x85,W
02594:  MOVWF  FEA
02596:  MOVLW  02
02598:  MOVWF  x90
0259A:  MOVLW  08
0259C:  MOVWF  x91
0259E:  MOVLW  01
025A0:  MOVWF  x92
025A2:  MOVLB  0
025A4:  CALL   23AC
025A8:  MOVFF  01,FEF
025AC:  MOVLW  01
025AE:  MOVLB  A
025B0:  ADDWF  x84,F
025B2:  BTFSC  FD8.0
025B4:  INCF   x85,F
025B6:  BTFSC  FD8.2
025B8:  INCF   x86,F
025BA:  BTFSC  FD8.2
025BC:  INCF   x87,F
025BE:  MOVLB  0
025C0:  GOTO   252E
....................          break;
025C4:  GOTO   26D6
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025C8:  MOVLB  A
025CA:  CLRF   x89
025CC:  CLRF   x88
025CE:  MOVLB  0
025D0:  MOVLB  A
025D2:  MOVF   x89,W
025D4:  SUBWF  x7B,W
025D6:  BTFSC  FD8.0
025D8:  BRA    25E0
025DA:  MOVLB  0
025DC:  GOTO   262C
025E0:  MOVLB  0
025E2:  BTFSS  FD8.2
025E4:  GOTO   25FA
025E8:  MOVLB  A
025EA:  MOVF   x7A,W
025EC:  SUBWF  x88,W
025EE:  BTFSS  FD8.0
025F0:  BRA    25F8
025F2:  MOVLB  0
025F4:  GOTO   262C
025F8:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
025FA:  MOVLB  A
025FC:  MOVF   x78,W
025FE:  ADDWF  x88,W
02600:  MOVWF  FE9
02602:  MOVF   x79,W
02604:  ADDWFC x89,W
02606:  MOVWF  FEA
02608:  MOVFF  FEF,A8E
0260C:  MOVFF  A8E,A90
02610:  MOVLW  08
02612:  MOVWF  x91
02614:  MOVLW  01
02616:  MOVWF  x92
02618:  MOVLB  0
0261A:  CALL   2428
0261E:  MOVLB  A
02620:  INCF   x88,F
02622:  BTFSC  FD8.2
02624:  INCF   x89,F
02626:  MOVLB  0
02628:  GOTO   25D0
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0262C:  MOVLB  A
0262E:  CLRF   x8D
02630:  CLRF   x8C
02632:  CLRF   x8B
02634:  CLRF   x8A
02636:  MOVLB  0
02638:  MOVLB  A
0263A:  MOVF   x8D,W
0263C:  SUBWF  x81,W
0263E:  BTFSC  FD8.0
02640:  BRA    2648
02642:  MOVLB  0
02644:  GOTO   26CE
02648:  MOVLB  0
0264A:  BTFSS  FD8.2
0264C:  GOTO   2692
02650:  MOVLB  A
02652:  MOVF   x8C,W
02654:  SUBWF  x80,W
02656:  BTFSC  FD8.0
02658:  BRA    2660
0265A:  MOVLB  0
0265C:  GOTO   26CE
02660:  MOVLB  0
02662:  BTFSS  FD8.2
02664:  GOTO   2692
02668:  MOVLB  A
0266A:  MOVF   x8B,W
0266C:  SUBWF  x7F,W
0266E:  BTFSC  FD8.0
02670:  BRA    2678
02672:  MOVLB  0
02674:  GOTO   26CE
02678:  MOVLB  0
0267A:  BTFSS  FD8.2
0267C:  GOTO   2692
02680:  MOVLB  A
02682:  MOVF   x7E,W
02684:  SUBWF  x8A,W
02686:  BTFSS  FD8.0
02688:  BRA    2690
0268A:  MOVLB  0
0268C:  GOTO   26CE
02690:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
02692:  MOVLB  A
02694:  MOVF   x7C,W
02696:  ADDWF  x8A,W
02698:  MOVWF  FE9
0269A:  MOVF   x7D,W
0269C:  ADDWFC x8B,W
0269E:  MOVWF  FEA
026A0:  MOVLW  01
026A2:  MOVWF  x90
026A4:  MOVLW  08
026A6:  MOVWF  x91
026A8:  MOVLW  01
026AA:  MOVWF  x92
026AC:  MOVLB  0
026AE:  CALL   2428
026B2:  MOVFF  01,FEF
026B6:  MOVLW  01
026B8:  MOVLB  A
026BA:  ADDWF  x8A,F
026BC:  BTFSC  FD8.0
026BE:  INCF   x8B,F
026C0:  BTFSC  FD8.2
026C2:  INCF   x8C,F
026C4:  BTFSC  FD8.2
026C6:  INCF   x8D,F
026C8:  MOVLB  0
026CA:  GOTO   2638
....................          break;
026CE:  GOTO   26D6
....................    
....................          
....................       default:
....................          break;
026D2:  GOTO   26D6
....................    }
....................    return;
026D6:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
032C2:  MOVLB  A
032C4:  MOVF   x6E,W
032C6:  XORLW  00
032C8:  MOVLB  0
032CA:  BTFSC  FD8.2
032CC:  GOTO   32DC
032D0:  XORLW  01
032D2:  BTFSC  FD8.2
032D4:  GOTO   338A
032D8:  GOTO   3438
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
032DC:  MOVLB  A
032DE:  CLRF   x79
032E0:  MOVLB  0
032E2:  MOVLB  A
032E4:  MOVF   x74,W
032E6:  SUBWF  x79,W
032E8:  BTFSS  FD8.0
032EA:  BRA    32F2
032EC:  MOVLB  0
032EE:  GOTO   3322
032F2:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
032F4:  MOVLB  A
032F6:  MOVF   x79,W
032F8:  ADDWF  x72,W
032FA:  MOVWF  FE9
032FC:  MOVLW  00
032FE:  ADDWFC x73,W
03300:  MOVWF  FEA
03302:  MOVFF  FEF,A7F
03306:  MOVFF  A7F,A90
0330A:  MOVLW  08
0330C:  MOVWF  x91
0330E:  MOVLW  01
03310:  MOVWF  x92
03312:  MOVLB  0
03314:  CALL   23AC
03318:  MOVLB  A
0331A:  INCF   x79,F
0331C:  MOVLB  0
0331E:  GOTO   32E2
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03322:  MOVLB  A
03324:  CLRF   x7B
03326:  CLRF   x7A
03328:  MOVLB  0
0332A:  MOVLB  A
0332C:  MOVF   x7B,W
0332E:  SUBWF  x78,W
03330:  BTFSC  FD8.0
03332:  BRA    333A
03334:  MOVLB  0
03336:  GOTO   3386
0333A:  MOVLB  0
0333C:  BTFSS  FD8.2
0333E:  GOTO   3354
03342:  MOVLB  A
03344:  MOVF   x77,W
03346:  SUBWF  x7A,W
03348:  BTFSS  FD8.0
0334A:  BRA    3352
0334C:  MOVLB  0
0334E:  GOTO   3386
03352:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
03354:  MOVLB  A
03356:  MOVF   x75,W
03358:  ADDWF  x7A,W
0335A:  MOVWF  FE9
0335C:  MOVF   x76,W
0335E:  ADDWFC x7B,W
03360:  MOVWF  FEA
03362:  MOVFF  FEF,A7F
03366:  MOVFF  A7F,A90
0336A:  MOVLW  08
0336C:  MOVWF  x91
0336E:  MOVLW  01
03370:  MOVWF  x92
03372:  MOVLB  0
03374:  CALL   23AC
03378:  MOVLB  A
0337A:  INCF   x7A,F
0337C:  BTFSC  FD8.2
0337E:  INCF   x7B,F
03380:  MOVLB  0
03382:  GOTO   332A
....................          break;
03386:  GOTO   343C
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
0338A:  MOVLB  A
0338C:  CLRF   x7C
0338E:  MOVLB  0
03390:  MOVLB  A
03392:  MOVF   x74,W
03394:  SUBWF  x7C,W
03396:  BTFSS  FD8.0
03398:  BRA    33A0
0339A:  MOVLB  0
0339C:  GOTO   33D0
033A0:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
033A2:  MOVLB  A
033A4:  MOVF   x7C,W
033A6:  ADDWF  x72,W
033A8:  MOVWF  FE9
033AA:  MOVLW  00
033AC:  ADDWFC x73,W
033AE:  MOVWF  FEA
033B0:  MOVFF  FEF,A7F
033B4:  MOVFF  A7F,A90
033B8:  MOVLW  08
033BA:  MOVWF  x91
033BC:  MOVLW  01
033BE:  MOVWF  x92
033C0:  MOVLB  0
033C2:  CALL   2428
033C6:  MOVLB  A
033C8:  INCF   x7C,F
033CA:  MOVLB  0
033CC:  GOTO   3390
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
033D0:  MOVLB  A
033D2:  CLRF   x7E
033D4:  CLRF   x7D
033D6:  MOVLB  0
033D8:  MOVLB  A
033DA:  MOVF   x7E,W
033DC:  SUBWF  x78,W
033DE:  BTFSC  FD8.0
033E0:  BRA    33E8
033E2:  MOVLB  0
033E4:  GOTO   3434
033E8:  MOVLB  0
033EA:  BTFSS  FD8.2
033EC:  GOTO   3402
033F0:  MOVLB  A
033F2:  MOVF   x77,W
033F4:  SUBWF  x7D,W
033F6:  BTFSS  FD8.0
033F8:  BRA    3400
033FA:  MOVLB  0
033FC:  GOTO   3434
03400:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
03402:  MOVLB  A
03404:  MOVF   x75,W
03406:  ADDWF  x7D,W
03408:  MOVWF  FE9
0340A:  MOVF   x76,W
0340C:  ADDWFC x7E,W
0340E:  MOVWF  FEA
03410:  MOVFF  FEF,A7F
03414:  MOVFF  A7F,A90
03418:  MOVLW  08
0341A:  MOVWF  x91
0341C:  MOVLW  01
0341E:  MOVWF  x92
03420:  MOVLB  0
03422:  CALL   2428
03426:  MOVLB  A
03428:  INCF   x7D,F
0342A:  BTFSC  FD8.2
0342C:  INCF   x7E,F
0342E:  MOVLB  0
03430:  GOTO   33D8
....................          break;
03434:  GOTO   343C
....................          
....................       default:
....................          break;
03438:  GOTO   343C
....................    }
....................    return;
0343C:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
050AA:  MOVFF  29A,A74
050AE:  MOVLW  01
050B0:  MOVLB  A
050B2:  MOVWF  x75
050B4:  MOVLW  0F
050B6:  MOVWF  x77
050B8:  MOVLW  89
050BA:  MOVWF  x76
050BC:  MOVLB  0
050BE:  CALL   2358
050C2:  MOVFF  29A,A74
050C6:  MOVLB  A
050C8:  CLRF   x75
050CA:  MOVLW  0F
050CC:  MOVWF  x77
050CE:  MOVLW  92
050D0:  MOVWF  x76
050D2:  MOVLB  0
050D4:  CALL   2358
050D8:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
0343E:  MOVLW  05
03440:  MOVLB  A
03442:  MOVWF  x72
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
03444:  MOVFF  A70,A74
03448:  CLRF   x75
0344A:  MOVLW  0F
0344C:  MOVWF  x77
0344E:  MOVLW  89
03450:  MOVWF  x76
03452:  MOVLB  0
03454:  CALL   2358
03458:  MOVFF  A70,A74
0345C:  MOVLB  A
0345E:  CLRF   x75
03460:  MOVLW  0F
03462:  MOVWF  x77
03464:  MOVLW  92
03466:  MOVWF  x76
03468:  MOVLB  0
0346A:  CALL   2358
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
0346E:  MOVFF  A71,A77
03472:  MOVFF  A70,A76
03476:  MOVFF  A6F,A75
0347A:  MOVFF  A6E,A74
0347E:  MOVLW  0A
03480:  MOVLB  A
03482:  MOVWF  x79
03484:  MOVLW  72
03486:  MOVWF  x78
03488:  CLRF   x7B
0348A:  MOVLW  01
0348C:  MOVWF  x7A
0348E:  MOVLW  0A
03490:  MOVWF  x7D
03492:  MOVLW  73
03494:  MOVWF  x7C
03496:  CLRF   x81
03498:  CLRF   x80
0349A:  CLRF   x7F
0349C:  MOVLW  01
0349E:  MOVWF  x7E
034A0:  MOVLB  0
034A2:  CALL   24A4
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
034A6:  MOVFF  A70,A74
034AA:  MOVLW  01
034AC:  MOVLB  A
034AE:  MOVWF  x75
034B0:  MOVLW  0F
034B2:  MOVWF  x77
034B4:  MOVLW  89
034B6:  MOVWF  x76
034B8:  MOVLB  0
034BA:  CALL   2358
034BE:  MOVFF  A70,A74
034C2:  MOVLB  A
034C4:  CLRF   x75
034C6:  MOVLW  0F
034C8:  MOVWF  x77
034CA:  MOVLW  92
034CC:  MOVWF  x76
034CE:  MOVLB  0
034D0:  CALL   2358
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
034D4:  MOVLB  A
034D6:  MOVF   x73,W
034D8:  MOVWF  01
034DA:  MOVLB  0
034DC:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
040B6:  MOVLB  A
040B8:  MOVF   x57,F
040BA:  BTFSC  FD8.2
040BC:  BRA    40C4
040BE:  MOVLB  0
040C0:  GOTO   421A
040C4:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
040C6:  MOVLW  06
040C8:  MOVLB  A
040CA:  MOVWF  x5E
040CC:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
040CE:  MOVLW  D8
040D0:  MOVLB  A
040D2:  MOVWF  x5F
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
040D4:  MOVFF  A5C,A6B
040D8:  MOVFF  A5D,A6C
040DC:  CLRF   x6D
040DE:  CLRF   x6E
040E0:  MOVF   x6B,W
040E2:  MOVWF  00
040E4:  CLRF   01
040E6:  CLRF   02
040E8:  CLRF   03
040EA:  MOVFF  00,A60
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
040EE:  MOVFF  A5B,A6B
040F2:  MOVFF  A5C,A6C
040F6:  MOVFF  A5D,A6D
040FA:  CLRF   x6E
040FC:  MOVF   x6B,W
040FE:  MOVWF  00
04100:  CLRF   01
04102:  CLRF   02
04104:  CLRF   03
04106:  MOVFF  00,A61
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
0410A:  MOVF   x5A,W
0410C:  MOVWF  00
0410E:  CLRF   01
04110:  CLRF   02
04112:  CLRF   03
04114:  MOVFF  00,A62
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04118:  MOVFF  A58,A74
0411C:  CLRF   x75
0411E:  MOVLW  0F
04120:  MOVWF  x77
04122:  MOVLW  89
04124:  MOVWF  x76
04126:  MOVLB  0
04128:  CALL   2358
0412C:  MOVFF  A58,A74
04130:  MOVLB  A
04132:  CLRF   x75
04134:  MOVLW  0F
04136:  MOVWF  x77
04138:  MOVLW  92
0413A:  MOVWF  x76
0413C:  MOVLB  0
0413E:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04142:  MOVFF  A59,A71
04146:  MOVFF  A58,A70
0414A:  MOVFF  A57,A6F
0414E:  MOVFF  A56,A6E
04152:  MOVLW  0A
04154:  MOVLB  A
04156:  MOVWF  x73
04158:  MOVLW  5E
0415A:  MOVWF  x72
0415C:  CLRF   x75
0415E:  MOVLW  01
04160:  MOVWF  x74
04162:  MOVLB  0
04164:  CALL   31D2
....................       output_high(flash_stream.cs_pin);
04168:  MOVFF  A58,A74
0416C:  MOVLW  01
0416E:  MOVLB  A
04170:  MOVWF  x75
04172:  MOVLW  0F
04174:  MOVWF  x77
04176:  MOVLW  89
04178:  MOVWF  x76
0417A:  MOVLB  0
0417C:  CALL   2358
04180:  MOVFF  A58,A74
04184:  MOVLB  A
04186:  CLRF   x75
04188:  MOVLW  0F
0418A:  MOVWF  x77
0418C:  MOVLW  92
0418E:  MOVWF  x76
04190:  MOVLB  0
04192:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04196:  MOVFF  A58,A74
0419A:  MOVLB  A
0419C:  CLRF   x75
0419E:  MOVLW  0F
041A0:  MOVWF  x77
041A2:  MOVLW  89
041A4:  MOVWF  x76
041A6:  MOVLB  0
041A8:  CALL   2358
041AC:  MOVFF  A58,A74
041B0:  MOVLB  A
041B2:  CLRF   x75
041B4:  MOVLW  0F
041B6:  MOVWF  x77
041B8:  MOVLW  92
041BA:  MOVWF  x76
041BC:  MOVLB  0
041BE:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
041C2:  MOVFF  A59,A71
041C6:  MOVFF  A58,A70
041CA:  MOVFF  A57,A6F
041CE:  MOVFF  A56,A6E
041D2:  MOVLW  0A
041D4:  MOVLB  A
041D6:  MOVWF  x73
041D8:  MOVLW  5F
041DA:  MOVWF  x72
041DC:  CLRF   x75
041DE:  MOVLW  04
041E0:  MOVWF  x74
041E2:  MOVLB  0
041E4:  CALL   31D2
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
041E8:  MOVFF  A58,A74
041EC:  MOVLW  01
041EE:  MOVLB  A
041F0:  MOVWF  x75
041F2:  MOVLW  0F
041F4:  MOVWF  x77
041F6:  MOVLW  89
041F8:  MOVWF  x76
041FA:  MOVLB  0
041FC:  CALL   2358
04200:  MOVFF  A58,A74
04204:  MOVLB  A
04206:  CLRF   x75
04208:  MOVLW  0F
0420A:  MOVWF  x77
0420C:  MOVLW  92
0420E:  MOVWF  x76
04210:  MOVLB  0
04212:  CALL   2358
....................    }
04216:  GOTO   4398
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
0421A:  MOVLB  A
0421C:  DECFSZ x57,W
0421E:  BRA    4224
04220:  BRA    422A
04222:  MOVLB  0
04224:  MOVLB  0
04226:  GOTO   4398
0422A:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
0422C:  MOVLW  06
0422E:  MOVLB  A
04230:  MOVWF  x63
04232:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
04234:  MOVLW  DC
04236:  MOVLB  A
04238:  MOVWF  x64
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
0423A:  MOVFF  A5D,A6B
0423E:  CLRF   x6C
04240:  CLRF   x6D
04242:  CLRF   x6E
04244:  MOVF   x6B,W
04246:  MOVWF  00
04248:  CLRF   01
0424A:  CLRF   02
0424C:  CLRF   03
0424E:  MOVFF  00,A65
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04252:  MOVFF  A5C,A6B
04256:  MOVFF  A5D,A6C
0425A:  CLRF   x6D
0425C:  CLRF   x6E
0425E:  MOVF   x6B,W
04260:  MOVWF  00
04262:  CLRF   01
04264:  CLRF   02
04266:  CLRF   03
04268:  MOVFF  00,A66
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0426C:  MOVFF  A5B,A6B
04270:  MOVFF  A5C,A6C
04274:  MOVFF  A5D,A6D
04278:  CLRF   x6E
0427A:  MOVF   x6B,W
0427C:  MOVWF  00
0427E:  CLRF   01
04280:  CLRF   02
04282:  CLRF   03
04284:  MOVFF  00,A67
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
04288:  MOVF   x5A,W
0428A:  MOVWF  00
0428C:  CLRF   01
0428E:  CLRF   02
04290:  CLRF   03
04292:  MOVFF  00,A68
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04296:  MOVFF  A58,A74
0429A:  CLRF   x75
0429C:  MOVLW  0F
0429E:  MOVWF  x77
042A0:  MOVLW  89
042A2:  MOVWF  x76
042A4:  MOVLB  0
042A6:  CALL   2358
042AA:  MOVFF  A58,A74
042AE:  MOVLB  A
042B0:  CLRF   x75
042B2:  MOVLW  0F
042B4:  MOVWF  x77
042B6:  MOVLW  92
042B8:  MOVWF  x76
042BA:  MOVLB  0
042BC:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
042C0:  MOVFF  A59,A71
042C4:  MOVFF  A58,A70
042C8:  MOVFF  A57,A6F
042CC:  MOVFF  A56,A6E
042D0:  MOVLW  0A
042D2:  MOVLB  A
042D4:  MOVWF  x73
042D6:  MOVLW  63
042D8:  MOVWF  x72
042DA:  CLRF   x75
042DC:  MOVLW  01
042DE:  MOVWF  x74
042E0:  MOVLB  0
042E2:  CALL   31D2
....................       output_high(flash_stream.cs_pin);
042E6:  MOVFF  A58,A74
042EA:  MOVLW  01
042EC:  MOVLB  A
042EE:  MOVWF  x75
042F0:  MOVLW  0F
042F2:  MOVWF  x77
042F4:  MOVLW  89
042F6:  MOVWF  x76
042F8:  MOVLB  0
042FA:  CALL   2358
042FE:  MOVFF  A58,A74
04302:  MOVLB  A
04304:  CLRF   x75
04306:  MOVLW  0F
04308:  MOVWF  x77
0430A:  MOVLW  92
0430C:  MOVWF  x76
0430E:  MOVLB  0
04310:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04314:  MOVFF  A58,A74
04318:  MOVLB  A
0431A:  CLRF   x75
0431C:  MOVLW  0F
0431E:  MOVWF  x77
04320:  MOVLW  89
04322:  MOVWF  x76
04324:  MOVLB  0
04326:  CALL   2358
0432A:  MOVFF  A58,A74
0432E:  MOVLB  A
04330:  CLRF   x75
04332:  MOVLW  0F
04334:  MOVWF  x77
04336:  MOVLW  92
04338:  MOVWF  x76
0433A:  MOVLB  0
0433C:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04340:  MOVFF  A59,A71
04344:  MOVFF  A58,A70
04348:  MOVFF  A57,A6F
0434C:  MOVFF  A56,A6E
04350:  MOVLW  0A
04352:  MOVLB  A
04354:  MOVWF  x73
04356:  MOVLW  64
04358:  MOVWF  x72
0435A:  CLRF   x75
0435C:  MOVLW  05
0435E:  MOVWF  x74
04360:  MOVLB  0
04362:  CALL   31D2
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04366:  MOVFF  A58,A74
0436A:  MOVLW  01
0436C:  MOVLB  A
0436E:  MOVWF  x75
04370:  MOVLW  0F
04372:  MOVWF  x77
04374:  MOVLW  89
04376:  MOVWF  x76
04378:  MOVLB  0
0437A:  CALL   2358
0437E:  MOVFF  A58,A74
04382:  MOVLB  A
04384:  CLRF   x75
04386:  MOVLW  0F
04388:  MOVWF  x77
0438A:  MOVLW  92
0438C:  MOVWF  x76
0438E:  MOVLB  0
04390:  CALL   2358
....................    }
04394:  GOTO   4398
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04398:  MOVLB  A
0439A:  CLRF   x69
0439C:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
0439E:  MOVFF  A59,A71
043A2:  MOVFF  A58,A70
043A6:  MOVFF  A57,A6F
043AA:  MOVFF  A56,A6E
043AE:  CALL   343E
043B2:  MOVF   01,W
043B4:  ANDLW  01
043B6:  SUBLW  01
043B8:  BTFSS  FD8.2
043BA:  GOTO   440C
....................       if(timeout_counter > 10)
043BE:  MOVLB  A
043C0:  MOVF   x69,W
043C2:  SUBLW  0A
043C4:  BTFSS  FD8.0
043C6:  BRA    43CE
043C8:  MOVLB  0
043CA:  GOTO   43E0
043CE:  MOVLB  0
....................          delay_ms(200);
043D0:  MOVLW  C8
043D2:  MOVLB  A
043D4:  MOVWF  x6E
043D6:  MOVLB  0
043D8:  CALL   1B3E
043DC:  GOTO   43EC
....................       else
....................          delay_ms(10);   
043E0:  MOVLW  0A
043E2:  MOVLB  A
043E4:  MOVWF  x6E
043E6:  MOVLB  0
043E8:  CALL   1B3E
....................       
....................       if(timeout_counter > 100){
043EC:  MOVLB  A
043EE:  MOVF   x69,W
043F0:  SUBLW  64
043F2:  BTFSS  FD8.0
043F4:  BRA    43FC
043F6:  MOVLB  0
043F8:  GOTO   4402
043FC:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
043FE:  GOTO   440C
....................       }  
....................       timeout_counter++;
04402:  MOVLB  A
04404:  INCF   x69,F
04406:  MOVLB  0
04408:  GOTO   439E
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
0440C:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
04680:  MOVLB  2
04682:  MOVF   xE3,F
04684:  BTFSC  FD8.2
04686:  BRA    468E
04688:  MOVLB  0
0468A:  GOTO   47E6
0468E:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
04690:  MOVLW  06
04692:  MOVLB  2
04694:  MOVWF  xEA
04696:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
04698:  MOVLW  20
0469A:  MOVLB  2
0469C:  MOVWF  xEB
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0469E:  MOVFF  2E8,2F7
046A2:  MOVFF  2E9,2F8
046A6:  CLRF   xF9
046A8:  CLRF   xFA
046AA:  MOVF   xF7,W
046AC:  MOVWF  00
046AE:  CLRF   01
046B0:  CLRF   02
046B2:  CLRF   03
046B4:  MOVFF  00,2EC
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
046B8:  MOVFF  2E7,2F7
046BC:  MOVFF  2E8,2F8
046C0:  MOVFF  2E9,2F9
046C4:  CLRF   xFA
046C6:  MOVF   xF7,W
046C8:  MOVWF  00
046CA:  CLRF   01
046CC:  CLRF   02
046CE:  CLRF   03
046D0:  MOVFF  00,2ED
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
046D4:  MOVF   xE6,W
046D6:  MOVWF  00
046D8:  CLRF   01
046DA:  CLRF   02
046DC:  CLRF   03
046DE:  MOVFF  00,2EE
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
046E2:  MOVFF  2E4,A74
046E6:  MOVLB  A
046E8:  CLRF   x75
046EA:  MOVLW  0F
046EC:  MOVWF  x77
046EE:  MOVLW  89
046F0:  MOVWF  x76
046F2:  MOVLB  0
046F4:  CALL   2358
046F8:  MOVFF  2E4,A74
046FC:  MOVLB  A
046FE:  CLRF   x75
04700:  MOVLW  0F
04702:  MOVWF  x77
04704:  MOVLW  92
04706:  MOVWF  x76
04708:  MOVLB  0
0470A:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0470E:  MOVFF  2E5,A71
04712:  MOVFF  2E4,A70
04716:  MOVFF  2E3,A6F
0471A:  MOVFF  2E2,A6E
0471E:  MOVLW  02
04720:  MOVLB  A
04722:  MOVWF  x73
04724:  MOVLW  EA
04726:  MOVWF  x72
04728:  CLRF   x75
0472A:  MOVLW  01
0472C:  MOVWF  x74
0472E:  MOVLB  0
04730:  CALL   31D2
....................       output_high(flash_stream.cs_pin);
04734:  MOVFF  2E4,A74
04738:  MOVLW  01
0473A:  MOVLB  A
0473C:  MOVWF  x75
0473E:  MOVLW  0F
04740:  MOVWF  x77
04742:  MOVLW  89
04744:  MOVWF  x76
04746:  MOVLB  0
04748:  CALL   2358
0474C:  MOVFF  2E4,A74
04750:  MOVLB  A
04752:  CLRF   x75
04754:  MOVLW  0F
04756:  MOVWF  x77
04758:  MOVLW  92
0475A:  MOVWF  x76
0475C:  MOVLB  0
0475E:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04762:  MOVFF  2E4,A74
04766:  MOVLB  A
04768:  CLRF   x75
0476A:  MOVLW  0F
0476C:  MOVWF  x77
0476E:  MOVLW  89
04770:  MOVWF  x76
04772:  MOVLB  0
04774:  CALL   2358
04778:  MOVFF  2E4,A74
0477C:  MOVLB  A
0477E:  CLRF   x75
04780:  MOVLW  0F
04782:  MOVWF  x77
04784:  MOVLW  92
04786:  MOVWF  x76
04788:  MOVLB  0
0478A:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
0478E:  MOVFF  2E5,A71
04792:  MOVFF  2E4,A70
04796:  MOVFF  2E3,A6F
0479A:  MOVFF  2E2,A6E
0479E:  MOVLW  02
047A0:  MOVLB  A
047A2:  MOVWF  x73
047A4:  MOVLW  EB
047A6:  MOVWF  x72
047A8:  CLRF   x75
047AA:  MOVLW  04
047AC:  MOVWF  x74
047AE:  MOVLB  0
047B0:  CALL   31D2
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
047B4:  MOVFF  2E4,A74
047B8:  MOVLW  01
047BA:  MOVLB  A
047BC:  MOVWF  x75
047BE:  MOVLW  0F
047C0:  MOVWF  x77
047C2:  MOVLW  89
047C4:  MOVWF  x76
047C6:  MOVLB  0
047C8:  CALL   2358
047CC:  MOVFF  2E4,A74
047D0:  MOVLB  A
047D2:  CLRF   x75
047D4:  MOVLW  0F
047D6:  MOVWF  x77
047D8:  MOVLW  92
047DA:  MOVWF  x76
047DC:  MOVLB  0
047DE:  CALL   2358
....................    }
047E2:  GOTO   4966
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
047E6:  MOVLB  2
047E8:  DECFSZ xE3,W
047EA:  BRA    47F0
047EC:  BRA    47F6
047EE:  MOVLB  0
047F0:  MOVLB  0
047F2:  GOTO   4966
047F6:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
047F8:  MOVLW  06
047FA:  MOVLB  2
047FC:  MOVWF  xEF
047FE:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
04800:  MOVLW  21
04802:  MOVLB  2
04804:  MOVWF  xF0
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04806:  MOVFF  2E9,2F7
0480A:  CLRF   xF8
0480C:  CLRF   xF9
0480E:  CLRF   xFA
04810:  MOVF   xF7,W
04812:  MOVWF  00
04814:  CLRF   01
04816:  CLRF   02
04818:  CLRF   03
0481A:  MOVFF  00,2F1
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0481E:  MOVFF  2E8,2F7
04822:  MOVFF  2E9,2F8
04826:  CLRF   xF9
04828:  CLRF   xFA
0482A:  MOVF   xF7,W
0482C:  MOVWF  00
0482E:  CLRF   01
04830:  CLRF   02
04832:  CLRF   03
04834:  MOVFF  00,2F2
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04838:  MOVFF  2E7,2F7
0483C:  MOVFF  2E8,2F8
04840:  MOVFF  2E9,2F9
04844:  CLRF   xFA
04846:  MOVF   xF7,W
04848:  MOVWF  00
0484A:  CLRF   01
0484C:  CLRF   02
0484E:  CLRF   03
04850:  MOVFF  00,2F3
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04854:  MOVF   xE6,W
04856:  MOVWF  00
04858:  CLRF   01
0485A:  CLRF   02
0485C:  CLRF   03
0485E:  MOVFF  00,2F4
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04862:  MOVFF  2E4,A74
04866:  MOVLB  A
04868:  CLRF   x75
0486A:  MOVLW  0F
0486C:  MOVWF  x77
0486E:  MOVLW  89
04870:  MOVWF  x76
04872:  MOVLB  0
04874:  CALL   2358
04878:  MOVFF  2E4,A74
0487C:  MOVLB  A
0487E:  CLRF   x75
04880:  MOVLW  0F
04882:  MOVWF  x77
04884:  MOVLW  92
04886:  MOVWF  x76
04888:  MOVLB  0
0488A:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0488E:  MOVFF  2E5,A71
04892:  MOVFF  2E4,A70
04896:  MOVFF  2E3,A6F
0489A:  MOVFF  2E2,A6E
0489E:  MOVLW  02
048A0:  MOVLB  A
048A2:  MOVWF  x73
048A4:  MOVLW  EF
048A6:  MOVWF  x72
048A8:  CLRF   x75
048AA:  MOVLW  01
048AC:  MOVWF  x74
048AE:  MOVLB  0
048B0:  CALL   31D2
....................       output_high(flash_stream.cs_pin);
048B4:  MOVFF  2E4,A74
048B8:  MOVLW  01
048BA:  MOVLB  A
048BC:  MOVWF  x75
048BE:  MOVLW  0F
048C0:  MOVWF  x77
048C2:  MOVLW  89
048C4:  MOVWF  x76
048C6:  MOVLB  0
048C8:  CALL   2358
048CC:  MOVFF  2E4,A74
048D0:  MOVLB  A
048D2:  CLRF   x75
048D4:  MOVLW  0F
048D6:  MOVWF  x77
048D8:  MOVLW  92
048DA:  MOVWF  x76
048DC:  MOVLB  0
048DE:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
048E2:  MOVFF  2E4,A74
048E6:  MOVLB  A
048E8:  CLRF   x75
048EA:  MOVLW  0F
048EC:  MOVWF  x77
048EE:  MOVLW  89
048F0:  MOVWF  x76
048F2:  MOVLB  0
048F4:  CALL   2358
048F8:  MOVFF  2E4,A74
048FC:  MOVLB  A
048FE:  CLRF   x75
04900:  MOVLW  0F
04902:  MOVWF  x77
04904:  MOVLW  92
04906:  MOVWF  x76
04908:  MOVLB  0
0490A:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
0490E:  MOVFF  2E5,A71
04912:  MOVFF  2E4,A70
04916:  MOVFF  2E3,A6F
0491A:  MOVFF  2E2,A6E
0491E:  MOVLW  02
04920:  MOVLB  A
04922:  MOVWF  x73
04924:  MOVLW  F0
04926:  MOVWF  x72
04928:  CLRF   x75
0492A:  MOVLW  05
0492C:  MOVWF  x74
0492E:  MOVLB  0
04930:  CALL   31D2
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04934:  MOVFF  2E4,A74
04938:  MOVLW  01
0493A:  MOVLB  A
0493C:  MOVWF  x75
0493E:  MOVLW  0F
04940:  MOVWF  x77
04942:  MOVLW  89
04944:  MOVWF  x76
04946:  MOVLB  0
04948:  CALL   2358
0494C:  MOVFF  2E4,A74
04950:  MOVLB  A
04952:  CLRF   x75
04954:  MOVLW  0F
04956:  MOVWF  x77
04958:  MOVLW  92
0495A:  MOVWF  x76
0495C:  MOVLB  0
0495E:  CALL   2358
....................    }
04962:  GOTO   4966
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04966:  MOVLB  2
04968:  CLRF   xF5
0496A:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
0496C:  MOVFF  2E5,A71
04970:  MOVFF  2E4,A70
04974:  MOVFF  2E3,A6F
04978:  MOVFF  2E2,A6E
0497C:  CALL   343E
04980:  MOVF   01,W
04982:  ANDLW  01
04984:  SUBLW  01
04986:  BTFSS  FD8.2
04988:  GOTO   49DA
....................       if(timeout_counter > 10)
0498C:  MOVLB  2
0498E:  MOVF   xF5,W
04990:  SUBLW  0A
04992:  BTFSS  FD8.0
04994:  BRA    499C
04996:  MOVLB  0
04998:  GOTO   49AE
0499C:  MOVLB  0
....................          delay_ms(200);
0499E:  MOVLW  C8
049A0:  MOVLB  A
049A2:  MOVWF  x6E
049A4:  MOVLB  0
049A6:  CALL   1B3E
049AA:  GOTO   49BA
....................       else
....................          delay_ms(10);   
049AE:  MOVLW  0A
049B0:  MOVLB  A
049B2:  MOVWF  x6E
049B4:  MOVLB  0
049B6:  CALL   1B3E
....................       
....................       if(timeout_counter > 100){
049BA:  MOVLB  2
049BC:  MOVF   xF5,W
049BE:  SUBLW  64
049C0:  BTFSS  FD8.0
049C2:  BRA    49CA
049C4:  MOVLB  0
049C6:  GOTO   49D0
049CA:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
049CC:  GOTO   49DA
....................       }  
....................       timeout_counter++;
049D0:  MOVLB  2
049D2:  INCF   xF5,F
049D4:  MOVLB  0
049D6:  GOTO   496C
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
049DA:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
027C4:  MOVLB  2
027C6:  MOVF   xE3,F
027C8:  BTFSC  FD8.2
027CA:  BRA    27D2
027CC:  MOVLB  0
027CE:  GOTO   28C4
027D2:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
027D4:  MOVLW  03
027D6:  MOVLB  2
027D8:  MOVWF  xF0
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
027DA:  MOVFF  2E8,2FA
027DE:  MOVFF  2E9,2FB
027E2:  CLRF   xFC
027E4:  CLRF   xFD
027E6:  MOVF   xFA,W
027E8:  MOVWF  00
027EA:  CLRF   01
027EC:  CLRF   02
027EE:  CLRF   03
027F0:  MOVFF  00,2F1
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
027F4:  MOVFF  2E7,2FA
027F8:  MOVFF  2E8,2FB
027FC:  MOVFF  2E9,2FC
02800:  CLRF   xFD
02802:  MOVF   xFA,W
02804:  MOVWF  00
02806:  CLRF   01
02808:  CLRF   02
0280A:  CLRF   03
0280C:  MOVFF  00,2F2
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02810:  MOVF   xE6,W
02812:  MOVWF  00
02814:  CLRF   01
02816:  CLRF   02
02818:  CLRF   03
0281A:  MOVFF  00,2F3
....................             
....................       output_low(flash_stream.cs_pin);
0281E:  MOVFF  2E4,A74
02822:  MOVLB  A
02824:  CLRF   x75
02826:  MOVLW  0F
02828:  MOVWF  x77
0282A:  MOVLW  89
0282C:  MOVWF  x76
0282E:  MOVLB  0
02830:  CALL   2358
02834:  MOVFF  2E4,A74
02838:  MOVLB  A
0283A:  CLRF   x75
0283C:  MOVLW  0F
0283E:  MOVWF  x77
02840:  MOVLW  92
02842:  MOVWF  x76
02844:  MOVLB  0
02846:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
0284A:  MOVFF  2E5,A77
0284E:  MOVFF  2E4,A76
02852:  MOVFF  2E3,A75
02856:  MOVFF  2E2,A74
0285A:  MOVLW  02
0285C:  MOVLB  A
0285E:  MOVWF  x79
02860:  MOVLW  F0
02862:  MOVWF  x78
02864:  CLRF   x7B
02866:  MOVLW  04
02868:  MOVWF  x7A
0286A:  MOVFF  2EB,A7D
0286E:  MOVFF  2EA,A7C
02872:  MOVFF  2EF,A81
02876:  MOVFF  2EE,A80
0287A:  MOVFF  2ED,A7F
0287E:  MOVFF  2EC,A7E
02882:  MOVLB  0
02884:  CALL   24A4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
02888:  MOVLW  02
0288A:  MOVWF  00
0288C:  DECFSZ 00,F
0288E:  BRA    288C
02890:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
02892:  MOVFF  2E4,A74
02896:  MOVLW  01
02898:  MOVLB  A
0289A:  MOVWF  x75
0289C:  MOVLW  0F
0289E:  MOVWF  x77
028A0:  MOVLW  89
028A2:  MOVWF  x76
028A4:  MOVLB  0
028A6:  CALL   2358
028AA:  MOVFF  2E4,A74
028AE:  MOVLB  A
028B0:  CLRF   x75
028B2:  MOVLW  0F
028B4:  MOVWF  x77
028B6:  MOVLW  92
028B8:  MOVWF  x76
028BA:  MOVLB  0
028BC:  CALL   2358
....................    }
028C0:  GOTO   29DA
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
028C4:  MOVLB  2
028C6:  DECFSZ xE3,W
028C8:  BRA    28CE
028CA:  BRA    28D4
028CC:  MOVLB  0
028CE:  MOVLB  0
028D0:  GOTO   29DA
028D4:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
028D6:  MOVLW  13
028D8:  MOVLB  2
028DA:  MOVWF  xF4
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
028DC:  MOVFF  2E9,2FA
028E0:  CLRF   xFB
028E2:  CLRF   xFC
028E4:  CLRF   xFD
028E6:  MOVF   xFA,W
028E8:  MOVWF  00
028EA:  CLRF   01
028EC:  CLRF   02
028EE:  CLRF   03
028F0:  MOVFF  00,2F5
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
028F4:  MOVFF  2E8,2FA
028F8:  MOVFF  2E9,2FB
028FC:  CLRF   xFC
028FE:  CLRF   xFD
02900:  MOVF   xFA,W
02902:  MOVWF  00
02904:  CLRF   01
02906:  CLRF   02
02908:  CLRF   03
0290A:  MOVFF  00,2F6
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0290E:  MOVFF  2E7,2FA
02912:  MOVFF  2E8,2FB
02916:  MOVFF  2E9,2FC
0291A:  CLRF   xFD
0291C:  MOVF   xFA,W
0291E:  MOVWF  00
02920:  CLRF   01
02922:  CLRF   02
02924:  CLRF   03
02926:  MOVFF  00,2F7
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
0292A:  MOVF   xE6,W
0292C:  MOVWF  00
0292E:  CLRF   01
02930:  CLRF   02
02932:  CLRF   03
02934:  MOVFF  00,2F8
....................    
....................       output_low(flash_stream.cs_pin);
02938:  MOVFF  2E4,A74
0293C:  MOVLB  A
0293E:  CLRF   x75
02940:  MOVLW  0F
02942:  MOVWF  x77
02944:  MOVLW  89
02946:  MOVWF  x76
02948:  MOVLB  0
0294A:  CALL   2358
0294E:  MOVFF  2E4,A74
02952:  MOVLB  A
02954:  CLRF   x75
02956:  MOVLW  0F
02958:  MOVWF  x77
0295A:  MOVLW  92
0295C:  MOVWF  x76
0295E:  MOVLB  0
02960:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02964:  MOVFF  2E5,A77
02968:  MOVFF  2E4,A76
0296C:  MOVFF  2E3,A75
02970:  MOVFF  2E2,A74
02974:  MOVLW  02
02976:  MOVLB  A
02978:  MOVWF  x79
0297A:  MOVLW  F4
0297C:  MOVWF  x78
0297E:  CLRF   x7B
02980:  MOVLW  05
02982:  MOVWF  x7A
02984:  MOVFF  2EB,A7D
02988:  MOVFF  2EA,A7C
0298C:  MOVFF  2EF,A81
02990:  MOVFF  2EE,A80
02994:  MOVFF  2ED,A7F
02998:  MOVFF  2EC,A7E
0299C:  MOVLB  0
0299E:  CALL   24A4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029A2:  MOVLW  02
029A4:  MOVWF  00
029A6:  DECFSZ 00,F
029A8:  BRA    29A6
029AA:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029AC:  MOVFF  2E4,A74
029B0:  MOVLW  01
029B2:  MOVLB  A
029B4:  MOVWF  x75
029B6:  MOVLW  0F
029B8:  MOVWF  x77
029BA:  MOVLW  89
029BC:  MOVWF  x76
029BE:  MOVLB  0
029C0:  CALL   2358
029C4:  MOVFF  2E4,A74
029C8:  MOVLB  A
029CA:  CLRF   x75
029CC:  MOVLW  0F
029CE:  MOVWF  x77
029D0:  MOVLW  92
029D2:  MOVWF  x76
029D4:  MOVLB  0
029D6:  CALL   2358
....................    }
....................    return;
029DA:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
034DE:  MOVLB  A
034E0:  MOVF   x57,F
034E2:  BTFSC  FD8.2
034E4:  BRA    34EC
034E6:  MOVLB  0
034E8:  GOTO   365A
034EC:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
034EE:  MOVLW  06
034F0:  MOVLB  A
034F2:  MOVWF  x62
034F4:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
034F6:  MOVLW  02
034F8:  MOVLB  A
034FA:  MOVWF  x63
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
034FC:  MOVFF  A5C,A6F
03500:  MOVFF  A5D,A70
03504:  CLRF   x71
03506:  CLRF   x72
03508:  MOVF   x6F,W
0350A:  MOVWF  00
0350C:  CLRF   01
0350E:  CLRF   02
03510:  CLRF   03
03512:  MOVFF  00,A64
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03516:  MOVFF  A5B,A6F
0351A:  MOVFF  A5C,A70
0351E:  MOVFF  A5D,A71
03522:  CLRF   x72
03524:  MOVF   x6F,W
03526:  MOVWF  00
03528:  CLRF   01
0352A:  CLRF   02
0352C:  CLRF   03
0352E:  MOVFF  00,A65
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
03532:  MOVF   x5A,W
03534:  MOVWF  00
03536:  CLRF   01
03538:  CLRF   02
0353A:  CLRF   03
0353C:  MOVFF  00,A66
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03540:  MOVFF  A58,A74
03544:  CLRF   x75
03546:  MOVLW  0F
03548:  MOVWF  x77
0354A:  MOVLW  89
0354C:  MOVWF  x76
0354E:  MOVLB  0
03550:  CALL   2358
03554:  MOVFF  A58,A74
03558:  MOVLB  A
0355A:  CLRF   x75
0355C:  MOVLW  0F
0355E:  MOVWF  x77
03560:  MOVLW  92
03562:  MOVWF  x76
03564:  MOVLB  0
03566:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0356A:  MOVFF  A59,A71
0356E:  MOVFF  A58,A70
03572:  MOVFF  A57,A6F
03576:  MOVFF  A56,A6E
0357A:  MOVLW  0A
0357C:  MOVLB  A
0357E:  MOVWF  x73
03580:  MOVLW  62
03582:  MOVWF  x72
03584:  CLRF   x75
03586:  MOVLW  01
03588:  MOVWF  x74
0358A:  MOVLB  0
0358C:  CALL   31D2
....................       output_high(flash_stream.cs_pin);
03590:  MOVFF  A58,A74
03594:  MOVLW  01
03596:  MOVLB  A
03598:  MOVWF  x75
0359A:  MOVLW  0F
0359C:  MOVWF  x77
0359E:  MOVLW  89
035A0:  MOVWF  x76
035A2:  MOVLB  0
035A4:  CALL   2358
035A8:  MOVFF  A58,A74
035AC:  MOVLB  A
035AE:  CLRF   x75
035B0:  MOVLW  0F
035B2:  MOVWF  x77
035B4:  MOVLW  92
035B6:  MOVWF  x76
035B8:  MOVLB  0
035BA:  CALL   2358
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
035BE:  MOVFF  A58,A74
035C2:  MOVLB  A
035C4:  CLRF   x75
035C6:  MOVLW  0F
035C8:  MOVWF  x77
035CA:  MOVLW  89
035CC:  MOVWF  x76
035CE:  MOVLB  0
035D0:  CALL   2358
035D4:  MOVFF  A58,A74
035D8:  MOVLB  A
035DA:  CLRF   x75
035DC:  MOVLW  0F
035DE:  MOVWF  x77
035E0:  MOVLW  92
035E2:  MOVWF  x76
035E4:  MOVLB  0
035E6:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
035EA:  MOVFF  A59,A71
035EE:  MOVFF  A58,A70
035F2:  MOVFF  A57,A6F
035F6:  MOVFF  A56,A6E
035FA:  MOVLW  0A
035FC:  MOVLB  A
035FE:  MOVWF  x73
03600:  MOVLW  63
03602:  MOVWF  x72
03604:  MOVLW  04
03606:  MOVWF  x74
03608:  MOVFF  A5F,A76
0360C:  MOVFF  A5E,A75
03610:  MOVFF  A61,A78
03614:  MOVFF  A60,A77
03618:  MOVLB  0
0361A:  CALL   32C2
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
0361E:  MOVLW  02
03620:  MOVWF  00
03622:  DECFSZ 00,F
03624:  BRA    3622
03626:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03628:  MOVFF  A58,A74
0362C:  MOVLW  01
0362E:  MOVLB  A
03630:  MOVWF  x75
03632:  MOVLW  0F
03634:  MOVWF  x77
03636:  MOVLW  89
03638:  MOVWF  x76
0363A:  MOVLB  0
0363C:  CALL   2358
03640:  MOVFF  A58,A74
03644:  MOVLB  A
03646:  CLRF   x75
03648:  MOVLW  0F
0364A:  MOVWF  x77
0364C:  MOVLW  92
0364E:  MOVWF  x76
03650:  MOVLB  0
03652:  CALL   2358
....................    }
03656:  GOTO   37EC
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
0365A:  MOVLB  A
0365C:  DECFSZ x57,W
0365E:  BRA    3664
03660:  BRA    366A
03662:  MOVLB  0
03664:  MOVLB  0
03666:  GOTO   37EC
0366A:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
0366C:  MOVLW  06
0366E:  MOVLB  A
03670:  MOVWF  x67
03672:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
03674:  MOVLW  12
03676:  MOVLB  A
03678:  MOVWF  x68
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
0367A:  MOVFF  A5D,A6F
0367E:  CLRF   x70
03680:  CLRF   x71
03682:  CLRF   x72
03684:  MOVF   x6F,W
03686:  MOVWF  00
03688:  CLRF   01
0368A:  CLRF   02
0368C:  CLRF   03
0368E:  MOVFF  00,A69
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03692:  MOVFF  A5C,A6F
03696:  MOVFF  A5D,A70
0369A:  CLRF   x71
0369C:  CLRF   x72
0369E:  MOVF   x6F,W
036A0:  MOVWF  00
036A2:  CLRF   01
036A4:  CLRF   02
036A6:  CLRF   03
036A8:  MOVFF  00,A6A
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
036AC:  MOVFF  A5B,A6F
036B0:  MOVFF  A5C,A70
036B4:  MOVFF  A5D,A71
036B8:  CLRF   x72
036BA:  MOVF   x6F,W
036BC:  MOVWF  00
036BE:  CLRF   01
036C0:  CLRF   02
036C2:  CLRF   03
036C4:  MOVFF  00,A6B
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
036C8:  MOVF   x5A,W
036CA:  MOVWF  00
036CC:  CLRF   01
036CE:  CLRF   02
036D0:  CLRF   03
036D2:  MOVFF  00,A6C
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
036D6:  MOVFF  A58,A74
036DA:  CLRF   x75
036DC:  MOVLW  0F
036DE:  MOVWF  x77
036E0:  MOVLW  89
036E2:  MOVWF  x76
036E4:  MOVLB  0
036E6:  CALL   2358
036EA:  MOVFF  A58,A74
036EE:  MOVLB  A
036F0:  CLRF   x75
036F2:  MOVLW  0F
036F4:  MOVWF  x77
036F6:  MOVLW  92
036F8:  MOVWF  x76
036FA:  MOVLB  0
036FC:  CALL   2358
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03700:  MOVFF  A59,A71
03704:  MOVFF  A58,A70
03708:  MOVFF  A57,A6F
0370C:  MOVFF  A56,A6E
03710:  MOVLW  0A
03712:  MOVLB  A
03714:  MOVWF  x73
03716:  MOVLW  67
03718:  MOVWF  x72
0371A:  CLRF   x75
0371C:  MOVLW  01
0371E:  MOVWF  x74
03720:  MOVLB  0
03722:  CALL   31D2
....................       output_high(flash_stream.cs_pin);
03726:  MOVFF  A58,A74
0372A:  MOVLW  01
0372C:  MOVLB  A
0372E:  MOVWF  x75
03730:  MOVLW  0F
03732:  MOVWF  x77
03734:  MOVLW  89
03736:  MOVWF  x76
03738:  MOVLB  0
0373A:  CALL   2358
0373E:  MOVFF  A58,A74
03742:  MOVLB  A
03744:  CLRF   x75
03746:  MOVLW  0F
03748:  MOVWF  x77
0374A:  MOVLW  92
0374C:  MOVWF  x76
0374E:  MOVLB  0
03750:  CALL   2358
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
03754:  MOVFF  A58,A74
03758:  MOVLB  A
0375A:  CLRF   x75
0375C:  MOVLW  0F
0375E:  MOVWF  x77
03760:  MOVLW  89
03762:  MOVWF  x76
03764:  MOVLB  0
03766:  CALL   2358
0376A:  MOVFF  A58,A74
0376E:  MOVLB  A
03770:  CLRF   x75
03772:  MOVLW  0F
03774:  MOVWF  x77
03776:  MOVLW  92
03778:  MOVWF  x76
0377A:  MOVLB  0
0377C:  CALL   2358
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
03780:  MOVFF  A59,A71
03784:  MOVFF  A58,A70
03788:  MOVFF  A57,A6F
0378C:  MOVFF  A56,A6E
03790:  MOVLW  0A
03792:  MOVLB  A
03794:  MOVWF  x73
03796:  MOVLW  68
03798:  MOVWF  x72
0379A:  MOVLW  05
0379C:  MOVWF  x74
0379E:  MOVFF  A5F,A76
037A2:  MOVFF  A5E,A75
037A6:  MOVFF  A61,A78
037AA:  MOVFF  A60,A77
037AE:  MOVLB  0
037B0:  CALL   32C2
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
037B4:  MOVLW  02
037B6:  MOVWF  00
037B8:  DECFSZ 00,F
037BA:  BRA    37B8
037BC:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
037BE:  MOVFF  A58,A74
037C2:  MOVLW  01
037C4:  MOVLB  A
037C6:  MOVWF  x75
037C8:  MOVLW  0F
037CA:  MOVWF  x77
037CC:  MOVLW  89
037CE:  MOVWF  x76
037D0:  MOVLB  0
037D2:  CALL   2358
037D6:  MOVFF  A58,A74
037DA:  MOVLB  A
037DC:  CLRF   x75
037DE:  MOVLW  0F
037E0:  MOVWF  x77
037E2:  MOVLW  92
037E4:  MOVWF  x76
037E6:  MOVLB  0
037E8:  CALL   2358
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
037EC:  MOVLB  A
037EE:  CLRF   x6D
037F0:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
037F2:  MOVFF  A59,A71
037F6:  MOVFF  A58,A70
037FA:  MOVFF  A57,A6F
037FE:  MOVFF  A56,A6E
03802:  CALL   343E
03806:  MOVF   01,W
03808:  ANDLW  01
0380A:  SUBLW  01
0380C:  BTFSS  FD8.2
0380E:  GOTO   3860
....................       if(timeout_counter > 10)
03812:  MOVLB  A
03814:  MOVF   x6D,W
03816:  SUBLW  0A
03818:  BTFSS  FD8.0
0381A:  BRA    3822
0381C:  MOVLB  0
0381E:  GOTO   3834
03822:  MOVLB  0
....................          delay_ms(200);
03824:  MOVLW  C8
03826:  MOVLB  A
03828:  MOVWF  x6E
0382A:  MOVLB  0
0382C:  CALL   1B3E
03830:  GOTO   3840
....................       else
....................          delay_ms(10);   
03834:  MOVLW  0A
03836:  MOVLB  A
03838:  MOVWF  x6E
0383A:  MOVLB  0
0383C:  CALL   1B3E
....................       
....................       if(timeout_counter > 100){
03840:  MOVLB  A
03842:  MOVF   x6D,W
03844:  SUBLW  64
03846:  BTFSS  FD8.0
03848:  BRA    3850
0384A:  MOVLB  0
0384C:  GOTO   3856
03850:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
03852:  GOTO   3860
....................       }  
....................       timeout_counter++;
03856:  MOVLB  A
03858:  INCF   x6D,F
0385A:  MOVLB  0
0385C:  GOTO   37F2
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
03860:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
026D8:  MOVLW  9F
026DA:  MOVLB  2
026DC:  MOVWF  x78
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
026DE:  MOVFF  262,A74
026E2:  MOVLB  A
026E4:  CLRF   x75
026E6:  MOVLW  0F
026E8:  MOVWF  x77
026EA:  MOVLW  89
026EC:  MOVWF  x76
026EE:  MOVLB  0
026F0:  CALL   2358
026F4:  MOVFF  262,A74
026F8:  MOVLB  A
026FA:  CLRF   x75
026FC:  MOVLW  0F
026FE:  MOVWF  x77
02700:  MOVLW  92
02702:  MOVWF  x76
02704:  MOVLB  0
02706:  CALL   2358
....................    delay_us(10);  
0270A:  MOVLW  0D
0270C:  MOVWF  00
0270E:  DECFSZ 00,F
02710:  BRA    270E
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
02712:  MOVFF  263,A77
02716:  MOVFF  262,A76
0271A:  MOVFF  261,A75
0271E:  MOVFF  260,A74
02722:  MOVLW  02
02724:  MOVLB  A
02726:  MOVWF  x79
02728:  MOVLW  78
0272A:  MOVWF  x78
0272C:  CLRF   x7B
0272E:  MOVLW  01
02730:  MOVWF  x7A
02732:  MOVLW  02
02734:  MOVWF  x7D
02736:  MOVLW  64
02738:  MOVWF  x7C
0273A:  CLRF   x81
0273C:  CLRF   x80
0273E:  CLRF   x7F
02740:  MOVLW  14
02742:  MOVWF  x7E
02744:  MOVLB  0
02746:  CALL   24A4
....................    output_high(flash_stream.cs_pin);
0274A:  MOVFF  262,A74
0274E:  MOVLW  01
02750:  MOVLB  A
02752:  MOVWF  x75
02754:  MOVLW  0F
02756:  MOVWF  x77
02758:  MOVLW  89
0275A:  MOVWF  x76
0275C:  MOVLB  0
0275E:  CALL   2358
02762:  MOVFF  262,A74
02766:  MOVLB  A
02768:  CLRF   x75
0276A:  MOVLW  0F
0276C:  MOVWF  x77
0276E:  MOVLW  92
02770:  MOVWF  x76
02772:  MOVLB  0
02774:  CALL   2358
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
02778:  MOVLB  2
0277A:  MOVF   x64,W
0277C:  SUBLW  20
0277E:  BTFSC  FD8.2
02780:  BRA    2788
02782:  MOVLB  0
02784:  GOTO   2796
02788:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
0278A:  MOVLW  01
0278C:  MOVWF  01
0278E:  GOTO   279E
....................    }
02792:  GOTO   279E
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
02796:  MOVLW  00
02798:  MOVWF  01
0279A:  GOTO   279E
....................    }
0279E:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
029DC:  MOVLB  A
029DE:  MOVF   xAF,F
029E0:  BTFSC  FD8.2
029E2:  BRA    29EA
029E4:  MOVLB  0
029E6:  GOTO   29F4
029EA:  MOVLB  0
029EC:  MOVLW  00
029EE:  MOVWF  01
029F0:  GOTO   2A46
.................... 
....................    unsigned int8 crc = *frame++;
029F4:  MOVLB  A
029F6:  MOVF   xAE,W
029F8:  MOVWF  03
029FA:  MOVF   xAD,W
029FC:  INCF   xAD,F
029FE:  BTFSC  FD8.2
02A00:  INCF   xAE,F
02A02:  MOVWF  FE9
02A04:  MOVFF  03,FEA
02A08:  MOVFF  FEF,AB0
02A0C:  MOVLB  0
....................    while (--payload_size > 0)
02A0E:  MOVLB  A
02A10:  DECF   xAF,F
02A12:  MOVF   xAF,F
02A14:  BTFSS  FD8.2
02A16:  BRA    2A1E
02A18:  MOVLB  0
02A1A:  GOTO   2A3E
02A1E:  MOVLB  0
....................       crc ^= *frame++;
02A20:  MOVLB  A
02A22:  MOVF   xAE,W
02A24:  MOVWF  03
02A26:  MOVF   xAD,W
02A28:  INCF   xAD,F
02A2A:  BTFSC  FD8.2
02A2C:  INCF   xAE,F
02A2E:  MOVWF  FE9
02A30:  MOVFF  03,FEA
02A34:  MOVF   FEF,W
02A36:  XORWF  xB0,F
02A38:  MOVLB  0
02A3A:  GOTO   2A0E
.................... 
....................    return crc;
02A3E:  MOVLB  A
02A40:  MOVF   xB0,W
02A42:  MOVWF  01
02A44:  MOVLB  0
02A46:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
09694:  MOVLW  01
09696:  MOVLB  2
09698:  SUBWF  xE4,W
0969A:  ADDWF  xE2,W
0969C:  MOVWF  FE9
0969E:  MOVLW  00
096A0:  ADDWFC xE3,W
096A2:  MOVWF  FEA
096A4:  MOVFF  FEF,2E5
096A8:  MOVLW  01
096AA:  SUBWF  xE4,W
096AC:  MOVWF  xE7
096AE:  MOVFF  2E3,AAE
096B2:  MOVFF  2E2,AAD
096B6:  MOVFF  2E7,AAF
096BA:  MOVLB  0
096BC:  CALL   29DC
096C0:  MOVFF  01,2E6
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
096C4:  MOVLB  2
096C6:  MOVF   xE6,W
096C8:  SUBWF  xE5,W
096CA:  BTFSS  FD8.2
096CC:  BRA    96D4
096CE:  MOVLB  0
096D0:  GOTO   96DC
096D4:  MOVLB  0
096D6:  MOVLW  00
096D8:  GOTO   96DE
096DC:  MOVLW  01
096DE:  MOVWF  01
096E0:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
.................... {   
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
*
0872C:  MOVLW  8A
0872E:  MOVWF  FF6
08730:  MOVLW  02
08732:  MOVWF  FF7
08734:  MOVLW  00
08736:  MOVWF  FF8
08738:  CALL   1BBE
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
0873C:  MOVLW  01
0873E:  MOVLB  1
08740:  ADDWF  x0D,W
08742:  ANDLW  0F
08744:  MOVWF  xAD
.................... 
....................    if(next_tail == flash_queue.head_index)
08746:  MOVF   x0C,W
08748:  SUBWF  xAD,W
0874A:  BTFSC  FD8.2
0874C:  BRA    8754
0874E:  MOVLB  0
08750:  GOTO   876A
08754:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
08756:  MOVLW  A4
08758:  MOVWF  FF6
0875A:  MOVLW  02
0875C:  MOVWF  FF7
0875E:  MOVLW  00
08760:  MOVWF  FF8
08762:  CALL   1BBE
08766:  GOTO   8988
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
0876A:  MOVLB  1
0876C:  MOVF   x0D,W
0876E:  MULLW  0C
08770:  MOVF   FF3,W
08772:  CLRF   xAF
08774:  MOVWF  xAE
08776:  MOVLW  4C
08778:  ADDWF  xAE,W
0877A:  MOVWF  01
0877C:  MOVLW  00
0877E:  ADDWFC xAF,W
08780:  MOVWF  03
08782:  MOVF   01,W
08784:  MOVWF  xB0
08786:  MOVFF  03,1B1
0878A:  MOVF   xAB,W
0878C:  MOVWF  FE9
0878E:  MOVF   xAC,W
08790:  MOVWF  FEA
08792:  MOVF   FEF,W
08794:  MOVWF  xB2
08796:  MOVFF  1B1,FEA
0879A:  MOVFF  1B0,FE9
0879E:  MOVFF  1B2,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
087A2:  MOVF   x0D,W
087A4:  MULLW  0C
087A6:  MOVF   FF3,W
087A8:  CLRF   xAF
087AA:  MOVWF  xAE
087AC:  MOVLW  01
087AE:  ADDWF  xAE,W
087B0:  MOVWF  01
087B2:  MOVLW  00
087B4:  ADDWFC xAF,W
087B6:  MOVWF  03
087B8:  MOVF   01,W
087BA:  ADDLW  4C
087BC:  MOVWF  01
087BE:  MOVLW  00
087C0:  ADDWFC 03,F
087C2:  MOVF   01,W
087C4:  MOVWF  xAE
087C6:  MOVFF  03,1AF
087CA:  MOVLW  01
087CC:  ADDWF  xAB,W
087CE:  MOVWF  FE9
087D0:  MOVLW  00
087D2:  ADDWFC xAC,W
087D4:  MOVWF  FEA
087D6:  MOVF   FEF,W
087D8:  MOVWF  xB0
087DA:  MOVFF  1AF,FEA
087DE:  MOVFF  1AE,FE9
087E2:  MOVFF  1B0,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
087E6:  MOVF   x0D,W
087E8:  MULLW  0C
087EA:  MOVF   FF3,W
087EC:  CLRF   xAF
087EE:  MOVWF  xAE
087F0:  MOVLW  02
087F2:  ADDWF  xAE,W
087F4:  MOVWF  01
087F6:  MOVLW  00
087F8:  ADDWFC xAF,W
087FA:  MOVWF  03
087FC:  MOVF   01,W
087FE:  ADDLW  4C
08800:  MOVWF  01
08802:  MOVLW  00
08804:  ADDWFC 03,F
08806:  MOVF   01,W
08808:  MOVWF  xAE
0880A:  MOVFF  03,1AF
0880E:  MOVLW  02
08810:  ADDWF  xAB,W
08812:  MOVWF  FE9
08814:  MOVLW  00
08816:  ADDWFC xAC,W
08818:  MOVWF  FEA
0881A:  MOVF   FEF,W
0881C:  MOVWF  xB0
0881E:  MOVFF  1AF,FEA
08822:  MOVFF  1AE,FE9
08826:  MOVFF  1B0,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
0882A:  MOVF   x0D,W
0882C:  MULLW  0C
0882E:  MOVF   FF3,W
08830:  CLRF   xAF
08832:  MOVWF  xAE
08834:  MOVLW  03
08836:  ADDWF  xAE,W
08838:  MOVWF  01
0883A:  MOVLW  00
0883C:  ADDWFC xAF,W
0883E:  MOVWF  03
08840:  MOVF   01,W
08842:  ADDLW  4C
08844:  MOVWF  01
08846:  MOVLW  00
08848:  ADDWFC 03,F
0884A:  MOVF   01,W
0884C:  MOVWF  xAE
0884E:  MOVFF  03,1AF
08852:  MOVLW  03
08854:  ADDWF  xAB,W
08856:  MOVWF  01
08858:  MOVLW  00
0885A:  ADDWFC xAC,W
0885C:  MOVWF  03
0885E:  MOVF   01,W
08860:  MOVWF  FE9
08862:  MOVFF  03,FEA
08866:  MOVLW  00
08868:  BTFSC  FEF.0
0886A:  MOVLW  01
0886C:  MOVWF  01
0886E:  BTFSS  01.0
08870:  BRA    8878
08872:  MOVLB  0
08874:  GOTO   8888
08878:  MOVLB  0
0887A:  MOVFF  1AF,FEA
0887E:  MOVFF  1AE,FE9
08882:  BCF    FEF.0
08884:  GOTO   8892
08888:  MOVFF  1AF,FEA
0888C:  MOVFF  1AE,FE9
08890:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
08892:  MOVLB  1
08894:  MOVF   x0D,W
08896:  MULLW  0C
08898:  MOVF   FF3,W
0889A:  CLRF   xAF
0889C:  MOVWF  xAE
0889E:  MOVLW  04
088A0:  ADDWF  xAE,W
088A2:  MOVWF  01
088A4:  MOVLW  00
088A6:  ADDWFC xAF,W
088A8:  MOVWF  03
088AA:  MOVF   01,W
088AC:  ADDLW  4C
088AE:  MOVWF  01
088B0:  MOVLW  00
088B2:  ADDWFC 03,F
088B4:  MOVF   01,W
088B6:  MOVWF  xAE
088B8:  MOVFF  03,1AF
088BC:  MOVLW  04
088BE:  ADDWF  xAB,W
088C0:  MOVWF  FE9
088C2:  MOVLW  00
088C4:  ADDWFC xAC,W
088C6:  MOVWF  FEA
088C8:  MOVFF  FEF,00
088CC:  MOVFF  FEC,01
088D0:  MOVFF  FEC,02
088D4:  MOVFF  FEC,03
088D8:  MOVF   FED,F
088DA:  MOVF   FED,F
088DC:  MOVF   FED,F
088DE:  MOVFF  03,1B3
088E2:  MOVFF  02,1B2
088E6:  MOVFF  01,1B1
088EA:  MOVFF  00,1B0
088EE:  MOVFF  1AF,FEA
088F2:  MOVFF  1AE,FE9
088F6:  MOVFF  1B0,FEF
088FA:  MOVFF  1B1,FEC
088FE:  MOVFF  1B2,FEC
08902:  MOVFF  1B3,FEC
08906:  MOVF   FED,F
08908:  MOVF   FED,F
0890A:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
0890C:  MOVF   x0D,W
0890E:  MULLW  0C
08910:  MOVF   FF3,W
08912:  CLRF   xAF
08914:  MOVWF  xAE
08916:  MOVLW  08
08918:  ADDWF  xAE,W
0891A:  MOVWF  01
0891C:  MOVLW  00
0891E:  ADDWFC xAF,W
08920:  MOVWF  03
08922:  MOVF   01,W
08924:  ADDLW  4C
08926:  MOVWF  01
08928:  MOVLW  00
0892A:  ADDWFC 03,F
0892C:  MOVF   01,W
0892E:  MOVWF  xAE
08930:  MOVFF  03,1AF
08934:  MOVLW  08
08936:  ADDWF  xAB,W
08938:  MOVWF  FE9
0893A:  MOVLW  00
0893C:  ADDWFC xAC,W
0893E:  MOVWF  FEA
08940:  MOVFF  FEF,00
08944:  MOVFF  FEC,01
08948:  MOVFF  FEC,02
0894C:  MOVFF  FEC,03
08950:  MOVF   FED,F
08952:  MOVF   FED,F
08954:  MOVF   FED,F
08956:  MOVFF  03,1B3
0895A:  MOVFF  02,1B2
0895E:  MOVFF  01,1B1
08962:  MOVFF  00,1B0
08966:  MOVFF  1AF,FEA
0896A:  MOVFF  1AE,FE9
0896E:  MOVFF  1B0,FEF
08972:  MOVFF  1B1,FEC
08976:  MOVFF  1B2,FEC
0897A:  MOVFF  1B3,FEC
0897E:  MOVF   FED,F
08980:  MOVF   FED,F
08982:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
08984:  MOVFF  1AD,10D
08988:  MOVLB  0
....................    }
0898A:  GOTO   8F22 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
0928E:  MOVLB  1
09290:  MOVF   x0D,W
09292:  SUBWF  x0C,W
09294:  BTFSC  FD8.2
09296:  BRA    929E
09298:  MOVLB  0
0929A:  GOTO   92C0
0929E:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
092A0:  MOVLW  BE
092A2:  MOVWF  FF6
092A4:  MOVLW  02
092A6:  MOVWF  FF7
092A8:  MOVLW  00
092AA:  MOVWF  FF8
092AC:  CALL   1BBE
....................       return 0x00;
092B0:  MOVLW  00
092B2:  MOVWF  01
092B4:  MOVLW  00
092B6:  MOVWF  02
092B8:  GOTO   92EC
....................    }
092BC:  GOTO   92EC
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
092C0:  MOVFF  10C,18B
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
092C4:  MOVLW  01
092C6:  MOVLB  1
092C8:  ADDWF  x0C,W
092CA:  ANDLW  0F
092CC:  MOVWF  x0C
.................... 
.................... 
....................       return &flash_queue.entries[current_head];
092CE:  MOVF   x8B,W
092D0:  MULLW  0C
092D2:  MOVF   FF3,W
092D4:  CLRF   03
092D6:  ADDLW  4C
092D8:  MOVWF  01
092DA:  MOVLW  00
092DC:  ADDWFC 03,F
092DE:  MOVF   01,W
092E0:  MOVWF  01
092E2:  MOVF   03,W
092E4:  MOVWF  02
092E6:  MOVLB  0
092E8:  GOTO   92EC
....................    }
092EC:  GOTO   AF40 (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
09198:  MOVLB  1
0919A:  MOVF   x0D,W
0919C:  SUBWF  x0C,W
0919E:  BTFSS  FD8.2
091A0:  BRA    91A8
091A2:  MOVLB  0
091A4:  GOTO   91B0
091A8:  MOVLB  0
091AA:  MOVLW  00
091AC:  GOTO   91B2
091B0:  MOVLW  01
091B2:  MOVWF  01
091B4:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
0946C:  MOVLB  2
0946E:  CLRF   x68
09470:  CLRF   x69
09472:  CLRF   x6A
09474:  CLRF   x6B
09476:  CLRF   x6C
09478:  CLRF   x6D
0947A:  CLRF   x6E
0947C:  CLRF   x6F
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0947E:  MOVF   x67,F
09480:  BTFSC  FD8.2
09482:  BRA    948A
09484:  MOVLB  0
09486:  GOTO   94AE
0948A:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
0948C:  MOVLW  06
0948E:  MOVLB  2
09490:  MOVWF  x6B
09492:  MOVLW  AA
09494:  MOVWF  x6A
09496:  CLRF   x69
09498:  CLRF   x68
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
0949A:  MOVLW  06
0949C:  MOVWF  x6F
0949E:  MOVLW  AA
094A0:  MOVWF  x6E
094A2:  MOVLW  0F
094A4:  MOVWF  x6D
094A6:  SETF   x6C
094A8:  MOVLB  0
....................    }
094AA:  GOTO   9582
....................    else if (mission_id == CIGS_PICLOG_DATA)
094AE:  MOVLB  2
094B0:  DECFSZ x67,W
094B2:  BRA    94B8
094B4:  BRA    94BE
094B6:  MOVLB  0
094B8:  MOVLB  0
094BA:  GOTO   94E4
094BE:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
094C0:  MOVLW  06
094C2:  MOVLB  2
094C4:  MOVWF  x6B
094C6:  MOVLW  AA
094C8:  MOVWF  x6A
094CA:  MOVLW  10
094CC:  MOVWF  x69
094CE:  CLRF   x68
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
094D0:  MOVLW  06
094D2:  MOVWF  x6F
094D4:  MOVLW  AA
094D6:  MOVWF  x6E
094D8:  MOVLW  1F
094DA:  MOVWF  x6D
094DC:  SETF   x6C
094DE:  MOVLB  0
....................    }
094E0:  GOTO   9582
....................    else if (mission_id == CIGS_ENVIRO_DATA)
094E4:  MOVLB  2
094E6:  MOVF   x67,W
094E8:  SUBLW  02
094EA:  BTFSC  FD8.2
094EC:  BRA    94F4
094EE:  MOVLB  0
094F0:  GOTO   951A
094F4:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
094F6:  MOVLW  06
094F8:  MOVLB  2
094FA:  MOVWF  x6B
094FC:  MOVLW  AA
094FE:  MOVWF  x6A
09500:  MOVLW  10
09502:  MOVWF  x69
09504:  CLRF   x68
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
09506:  MOVLW  06
09508:  MOVWF  x6F
0950A:  MOVLW  AA
0950C:  MOVWF  x6E
0950E:  MOVLW  1F
09510:  MOVWF  x6D
09512:  SETF   x6C
09514:  MOVLB  0
....................    }
09516:  GOTO   9582
....................    else if (mission_id == CIGS_IV_HEADER)
0951A:  MOVLB  2
0951C:  MOVF   x67,W
0951E:  SUBLW  03
09520:  BTFSC  FD8.2
09522:  BRA    952A
09524:  MOVLB  0
09526:  GOTO   9550
0952A:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_HEADER_START_ADDRESS;
0952C:  MOVLW  06
0952E:  MOVLB  2
09530:  MOVWF  x6B
09532:  MOVLW  B4
09534:  MOVWF  x6A
09536:  MOVLW  20
09538:  MOVWF  x69
0953A:  CLRF   x68
....................       mis_struct.end_address   = CIGS_IV1_HEADER_END_ADDRESS;
0953C:  MOVLW  06
0953E:  MOVWF  x6F
09540:  MOVLW  BE
09542:  MOVWF  x6E
09544:  MOVLW  1F
09546:  MOVWF  x6D
09548:  SETF   x6C
0954A:  MOVLB  0
....................    }
0954C:  GOTO   9582
....................    else if (mission_id == CIGS_IV_DATA)
09550:  MOVLB  2
09552:  MOVF   x67,W
09554:  SUBLW  04
09556:  BTFSC  FD8.2
09558:  BRA    9560
0955A:  MOVLB  0
0955C:  GOTO   9582
09560:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_DATA_START_ADDRESS;
09562:  MOVLW  06
09564:  MOVLB  2
09566:  MOVWF  x6B
09568:  MOVLW  BE
0956A:  MOVWF  x6A
0956C:  MOVLW  20
0956E:  MOVWF  x69
09570:  CLRF   x68
....................       mis_struct.end_address   = CIGS_IV1_DATA_END_ADDRESS;
09572:  MOVLW  06
09574:  MOVWF  x6F
09576:  MOVLW  FE
09578:  MOVWF  x6E
0957A:  MOVLW  2F
0957C:  MOVWF  x6D
0957E:  SETF   x6C
09580:  MOVLB  0
....................    }
....................    return mis_struct;
09582:  MOVLW  68
09584:  MOVWF  01
09586:  MOVLW  02
09588:  MOVWF  02
0958A:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
03D0C:  MOVLB  1
03D0E:  CLRF   x8D
03D10:  CLRF   x8E
03D12:  CLRF   x8F
03D14:  CLRF   x90
03D16:  CLRF   x91
03D18:  CLRF   x92
03D1A:  CLRF   x93
03D1C:  CLRF   x94
03D1E:  CLRF   x95
03D20:  CLRF   x96
03D22:  CLRF   x97
03D24:  CLRF   x98
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
03D26:  MOVLW  D6
03D28:  MOVWF  FF6
03D2A:  MOVLW  02
03D2C:  MOVWF  FF7
03D2E:  MOVLW  00
03D30:  MOVWF  FF8
03D32:  MOVLB  0
03D34:  CALL   1BBE
....................    fprintf(PC, "\t[BOSS] >>> ");
03D38:  MOVLW  F6
03D3A:  MOVWF  FF6
03D3C:  MOVLW  02
03D3E:  MOVWF  FF7
03D40:  MOVLW  00
03D42:  MOVWF  FF8
03D44:  CALL   1BBE
....................    for (int8 i = 0; i < receive_signal_size; i++)
03D48:  MOVLB  1
03D4A:  CLRF   x99
03D4C:  MOVLB  0
03D4E:  MOVLB  1
03D50:  MOVF   x8C,W
03D52:  SUBWF  x99,W
03D54:  BTFSS  FD8.0
03D56:  BRA    3D5E
03D58:  MOVLB  0
03D5A:  GOTO   3D98
03D5E:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
03D60:  MOVLB  1
03D62:  MOVF   x99,W
03D64:  ADDWF  x8A,W
03D66:  MOVWF  FE9
03D68:  MOVLW  00
03D6A:  ADDWFC x8B,W
03D6C:  MOVWF  FEA
03D6E:  MOVFF  FEF,1A0
03D72:  MOVFF  1A0,264
03D76:  MOVLW  37
03D78:  MOVLB  2
03D7A:  MOVWF  x65
03D7C:  MOVLB  0
03D7E:  CALL   1E42
03D82:  MOVLW  20
03D84:  MOVLB  A
03D86:  MOVWF  xAD
03D88:  MOVLB  0
03D8A:  CALL   1B6C
03D8E:  MOVLB  1
03D90:  INCF   x99,F
03D92:  MOVLB  0
03D94:  GOTO   3D4E
....................    fprintf(PC, "\r\n");
03D98:  MOVLW  0D
03D9A:  MOVLB  A
03D9C:  MOVWF  xAD
03D9E:  MOVLB  0
03DA0:  CALL   1B6C
03DA4:  MOVLW  0A
03DA6:  MOVLB  A
03DA8:  MOVWF  xAD
03DAA:  MOVLB  0
03DAC:  CALL   1B6C
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
03DB0:  MOVFF  18B,1A1
03DB4:  MOVFF  18A,1A0
03DB8:  MOVFF  18C,1A2
03DBC:  GOTO   3A04
03DC0:  MOVFF  01,19A
....................    if (frame_start_position == -1)
03DC4:  MOVLB  1
03DC6:  MOVF   x9A,W
03DC8:  SUBLW  FF
03DCA:  BTFSC  FD8.2
03DCC:  BRA    3DD4
03DCE:  MOVLB  0
03DD0:  GOTO   3DE2
03DD4:  MOVLB  0
....................       return command;
03DD6:  MOVLW  8D
03DD8:  MOVWF  01
03DDA:  MOVLW  01
03DDC:  MOVWF  02
03DDE:  GOTO   3F04
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
03DE2:  MOVLB  1
03DE4:  MOVF   x9A,W
03DE6:  ADDWF  x8A,W
03DE8:  MOVWF  01
03DEA:  MOVLW  00
03DEC:  ADDWFC x8B,W
03DEE:  MOVWF  03
03DF0:  MOVF   01,W
03DF2:  MOVWF  x9B
03DF4:  MOVFF  03,19C
03DF8:  MOVF   x9B,W
03DFA:  MOVWF  FE9
03DFC:  MOVF   x9C,W
03DFE:  MOVWF  FEA
03E00:  MOVF   FEF,W
03E02:  ANDLW  0F
03E04:  MOVWF  x9D
03E06:  MOVFF  19D,1A0
03E0A:  MOVLB  0
03E0C:  GOTO   3AAC
03E10:  MOVFF  01,19E
....................    if (content_size == -1)
03E14:  MOVLB  1
03E16:  MOVF   x9E,W
03E18:  SUBLW  FF
03E1A:  BTFSC  FD8.2
03E1C:  BRA    3E24
03E1E:  MOVLB  0
03E20:  GOTO   3E32
03E24:  MOVLB  0
....................       return command;
03E26:  MOVLW  8D
03E28:  MOVWF  01
03E2A:  MOVLW  01
03E2C:  MOVWF  02
03E2E:  GOTO   3F04
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
03E32:  MOVLB  1
03E34:  MOVF   x9A,W
03E36:  SUBWF  x8C,W
03E38:  MOVWF  x9F
....................    
....................    if (!check_crc(frame, receive_frame_size))
03E3A:  MOVFF  19C,1A1
03E3E:  MOVFF  19B,1A0
03E42:  MOVFF  19F,1A2
03E46:  MOVLB  0
03E48:  GOTO   3B68
03E4C:  MOVF   01,F
03E4E:  BTFSS  FD8.2
03E50:  GOTO   3E60
....................       return command;
03E54:  MOVLW  8D
03E56:  MOVWF  01
03E58:  MOVLW  01
03E5A:  MOVWF  02
03E5C:  GOTO   3F04
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
03E60:  MOVLB  1
03E62:  MOVF   x9B,W
03E64:  MOVWF  FE9
03E66:  MOVF   x9C,W
03E68:  MOVWF  FEA
03E6A:  MOVF   FEF,W
03E6C:  ANDLW  F0
03E6E:  MOVWF  00
03E70:  SWAPF  00,W
03E72:  MOVWF  xA0
03E74:  MOVLW  0F
03E76:  ANDWF  xA0,F
03E78:  MOVFF  1A0,1A1
03E7C:  MOVLB  0
03E7E:  GOTO   3C52
03E82:  MOVF   01,F
03E84:  BTFSS  FD8.2
03E86:  GOTO   3E96
....................       return command;
03E8A:  MOVLW  8D
03E8C:  MOVWF  01
03E8E:  MOVLW  01
03E90:  MOVWF  02
03E92:  GOTO   3F04
.................... 
....................    command.frame_id = frame_id;
03E96:  MOVFF  19D,18D
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
03E9A:  MOVLW  01
03E9C:  MOVLB  1
03E9E:  ADDWF  x9B,W
03EA0:  MOVWF  01
03EA2:  MOVLW  00
03EA4:  ADDWFC x9C,W
03EA6:  MOVWF  03
03EA8:  MOVF   01,W
03EAA:  MOVWF  xA0
03EAC:  MOVFF  03,1A1
03EB0:  MOVLW  02
03EB2:  SUBWF  x9F,W
03EB4:  MOVWF  xA2
03EB6:  MOVLW  01
03EB8:  MOVWF  FEA
03EBA:  MOVLW  90
03EBC:  MOVWF  FE9
03EBE:  MOVFF  1A1,FE2
03EC2:  MOVFF  1A0,FE1
03EC6:  MOVF   xA2,W
03EC8:  MOVWF  01
03ECA:  BTFSS  FD8.2
03ECC:  BRA    3ED4
03ECE:  MOVLB  0
03ED0:  GOTO   3EE0
03ED4:  MOVLB  0
03ED6:  MOVFF  FE6,FEE
03EDA:  DECFSZ 01,F
03EDC:  GOTO   3ED6
....................    command.size = receive_frame_size-2;
03EE0:  MOVLW  02
03EE2:  MOVLB  1
03EE4:  SUBWF  x9F,W
03EE6:  MOVWF  x8E
....................    command.is_exist = TRUE;
03EE8:  BSF    x8F.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
03EEA:  MOVLW  04
03EEC:  MOVWF  FF6
03EEE:  MOVLW  03
03EF0:  MOVWF  FF7
03EF2:  MOVLW  00
03EF4:  MOVWF  FF8
03EF6:  MOVLB  0
03EF8:  CALL   1BBE
....................    return command;
03EFC:  MOVLW  8D
03EFE:  MOVWF  01
03F00:  MOVLW  01
03F02:  MOVWF  02
03F04:  GOTO   B69A (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
03A04:  MOVLB  1
03A06:  CLRF   xA3
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
03A08:  CLRF   xA3
03A0A:  MOVLB  0
03A0C:  MOVLW  01
03A0E:  MOVLB  1
03A10:  SUBWF  xA2,W
03A12:  SUBWF  xA3,W
03A14:  BTFSS  FD8.0
03A16:  BRA    3A1E
03A18:  MOVLB  0
03A1A:  GOTO   3A56
03A1E:  MOVLB  0
....................       if(receive_signal[i] == SFD)
03A20:  MOVLB  1
03A22:  MOVF   xA3,W
03A24:  ADDWF  xA0,W
03A26:  MOVWF  FE9
03A28:  MOVLW  00
03A2A:  ADDWFC xA1,W
03A2C:  MOVWF  FEA
03A2E:  MOVF   FEF,W
03A30:  SUBLW  AA
03A32:  BTFSC  FD8.2
03A34:  BRA    3A3C
03A36:  MOVLB  0
03A38:  GOTO   3A4C
03A3C:  MOVLB  0
....................          return i+1;
03A3E:  MOVLW  01
03A40:  MOVLB  1
03A42:  ADDWF  xA3,W
03A44:  MOVWF  01
03A46:  MOVLB  0
03A48:  GOTO   3AA8
03A4C:  MOVLB  1
03A4E:  INCF   xA3,F
03A50:  MOVLB  0
03A52:  GOTO   3A0C
....................    if (receive_signal[i] == SFD)
03A56:  MOVLB  1
03A58:  MOVF   xA3,W
03A5A:  ADDWF  xA0,W
03A5C:  MOVWF  FE9
03A5E:  MOVLW  00
03A60:  ADDWFC xA1,W
03A62:  MOVWF  FEA
03A64:  MOVF   FEF,W
03A66:  SUBLW  AA
03A68:  BTFSC  FD8.2
03A6A:  BRA    3A72
03A6C:  MOVLB  0
03A6E:  GOTO   3A90
03A72:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
03A74:  MOVLW  20
03A76:  MOVWF  FF6
03A78:  MOVLW  03
03A7A:  MOVWF  FF7
03A7C:  MOVLW  00
03A7E:  MOVWF  FF8
03A80:  CALL   1BBE
....................       return -1;
03A84:  MOVLW  FF
03A86:  MOVWF  01
03A88:  GOTO   3AA8
....................    }
03A8C:  GOTO   3AA8
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
03A90:  MOVLW  36
03A92:  MOVWF  FF6
03A94:  MOVLW  03
03A96:  MOVWF  FF7
03A98:  MOVLW  00
03A9A:  MOVWF  FF8
03A9C:  CALL   1BBE
....................       return -1;
03AA0:  MOVLW  FF
03AA2:  MOVWF  01
03AA4:  GOTO   3AA8
....................    }
03AA8:  GOTO   3DC0 (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
03AAC:  MOVLB  1
03AAE:  CLRF   xA1
03AB0:  MOVLB  0
03AB2:  MOVLB  1
03AB4:  MOVF   xA1,W
03AB6:  SUBLW  02
03AB8:  BTFSC  FD8.0
03ABA:  BRA    3AC2
03ABC:  MOVLB  0
03ABE:  GOTO   3B20
03AC2:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
03AC4:  BCF    FD8.0
03AC6:  MOVLB  1
03AC8:  RLCF   xA1,W
03ACA:  CLRF   xA3
03ACC:  MOVWF  xA2
03ACE:  MOVLW  16
03AD0:  ADDWF  xA2,W
03AD2:  MOVWF  FE9
03AD4:  MOVLW  01
03AD6:  ADDWFC xA3,W
03AD8:  MOVWF  FEA
03ADA:  MOVF   FEF,W
03ADC:  SUBWF  xA0,W
03ADE:  BTFSC  FD8.2
03AE0:  BRA    3AE8
03AE2:  MOVLB  0
03AE4:  GOTO   3B16
03AE8:  MOVLB  0
....................          return frame_ids[i].length;
03AEA:  BCF    FD8.0
03AEC:  MOVLB  1
03AEE:  RLCF   xA1,W
03AF0:  CLRF   xA3
03AF2:  MOVWF  xA2
03AF4:  MOVLW  01
03AF6:  ADDWF  xA2,W
03AF8:  MOVWF  01
03AFA:  MOVLW  00
03AFC:  ADDWFC xA3,W
03AFE:  MOVWF  03
03B00:  MOVF   01,W
03B02:  ADDLW  16
03B04:  MOVWF  FE9
03B06:  MOVLW  01
03B08:  ADDWFC 03,W
03B0A:  MOVWF  FEA
03B0C:  MOVF   FEF,W
03B0E:  MOVWF  01
03B10:  MOVLB  0
03B12:  GOTO   3B64
03B16:  MOVLB  1
03B18:  INCF   xA1,F
03B1A:  MOVLB  0
03B1C:  GOTO   3AB2
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
03B20:  MOVLW  48
03B22:  MOVWF  FF6
03B24:  MOVLW  03
03B26:  MOVWF  FF7
03B28:  MOVLW  00
03B2A:  MOVWF  FF8
03B2C:  MOVLW  1F
03B2E:  MOVLB  9
03B30:  MOVWF  xC2
03B32:  MOVLB  0
03B34:  CALL   1BEE
03B38:  MOVFF  1A0,264
03B3C:  MOVLW  37
03B3E:  MOVLB  2
03B40:  MOVWF  x65
03B42:  MOVLB  0
03B44:  CALL   1E42
03B48:  MOVLW  0D
03B4A:  MOVLB  A
03B4C:  MOVWF  xAD
03B4E:  MOVLB  0
03B50:  CALL   1B6C
03B54:  MOVLW  0A
03B56:  MOVLB  A
03B58:  MOVWF  xAD
03B5A:  MOVLB  0
03B5C:  CALL   1B6C
....................    return -1;
03B60:  MOVLW  FF
03B62:  MOVWF  01
03B64:  GOTO   3E10 (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
03B68:  MOVLW  01
03B6A:  MOVLB  1
03B6C:  SUBWF  xA2,W
03B6E:  ADDWF  xA0,W
03B70:  MOVWF  FE9
03B72:  MOVLW  00
03B74:  ADDWFC xA1,W
03B76:  MOVWF  FEA
03B78:  MOVFF  FEF,1A3
03B7C:  MOVLW  01
03B7E:  SUBWF  xA2,W
03B80:  MOVWF  xA5
03B82:  MOVFF  1A1,AAE
03B86:  MOVFF  1A0,AAD
03B8A:  MOVFF  1A5,AAF
03B8E:  MOVLB  0
03B90:  CALL   29DC
03B94:  MOVFF  01,1A4
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
03B98:  MOVLB  1
03B9A:  MOVF   xA4,W
03B9C:  SUBWF  xA3,W
03B9E:  BTFSC  FD8.2
03BA0:  BRA    3BA8
03BA2:  MOVLB  0
03BA4:  GOTO   3BB6
03BA8:  MOVLB  0
....................       return TRUE;
03BAA:  MOVLW  01
03BAC:  MOVWF  01
03BAE:  GOTO   3C4E
03BB2:  GOTO   3C4E
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
03BB6:  MOVLW  6C
03BB8:  MOVWF  FF6
03BBA:  MOVLW  03
03BBC:  MOVWF  FF7
03BBE:  MOVLW  00
03BC0:  MOVWF  FF8
03BC2:  CALL   1BBE
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
03BC6:  MOVLW  7E
03BC8:  MOVWF  FF6
03BCA:  MOVLW  03
03BCC:  MOVWF  FF7
03BCE:  MOVLW  00
03BD0:  MOVWF  FF8
03BD2:  MOVLW  13
03BD4:  MOVLB  9
03BD6:  MOVWF  xC2
03BD8:  MOVLB  0
03BDA:  CALL   1BEE
03BDE:  MOVFF  1A3,264
03BE2:  MOVLW  37
03BE4:  MOVLB  2
03BE6:  MOVWF  x65
03BE8:  MOVLB  0
03BEA:  CALL   1E42
03BEE:  MOVLW  0D
03BF0:  MOVLB  A
03BF2:  MOVWF  xAD
03BF4:  MOVLB  0
03BF6:  CALL   1B6C
03BFA:  MOVLW  0A
03BFC:  MOVLB  A
03BFE:  MOVWF  xAD
03C00:  MOVLB  0
03C02:  CALL   1B6C
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
03C06:  MOVLW  96
03C08:  MOVWF  FF6
03C0A:  MOVLW  03
03C0C:  MOVWF  FF7
03C0E:  MOVLW  00
03C10:  MOVWF  FF8
03C12:  MOVLW  13
03C14:  MOVLB  9
03C16:  MOVWF  xC2
03C18:  MOVLB  0
03C1A:  CALL   1BEE
03C1E:  MOVFF  1A4,264
03C22:  MOVLW  37
03C24:  MOVLB  2
03C26:  MOVWF  x65
03C28:  MOVLB  0
03C2A:  CALL   1E42
03C2E:  MOVLW  0D
03C30:  MOVLB  A
03C32:  MOVWF  xAD
03C34:  MOVLB  0
03C36:  CALL   1B6C
03C3A:  MOVLW  0A
03C3C:  MOVLB  A
03C3E:  MOVWF  xAD
03C40:  MOVLB  0
03C42:  CALL   1B6C
....................       return FALSE;
03C46:  MOVLW  00
03C48:  MOVWF  01
03C4A:  GOTO   3C4E
....................    }
03C4E:  GOTO   3E4C (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
03C52:  MOVLB  1
03C54:  MOVF   xA1,W
03C56:  SUBLW  0C
03C58:  BTFSC  FD8.2
03C5A:  BRA    3C62
03C5C:  MOVLB  0
03C5E:  GOTO   3C70
03C62:  MOVLB  0
....................       return TRUE;
03C64:  MOVLW  01
03C66:  MOVWF  01
03C68:  GOTO   3D08
03C6C:  GOTO   3D08
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
03C70:  MOVLW  AE
03C72:  MOVWF  FF6
03C74:  MOVLW  03
03C76:  MOVWF  FF7
03C78:  MOVLW  00
03C7A:  MOVWF  FF8
03C7C:  CALL   1BBE
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
03C80:  MOVLW  D0
03C82:  MOVWF  FF6
03C84:  MOVLW  03
03C86:  MOVWF  FF7
03C88:  MOVLW  00
03C8A:  MOVWF  FF8
03C8C:  MOVLW  13
03C8E:  MOVLB  9
03C90:  MOVWF  xC2
03C92:  MOVLB  0
03C94:  CALL   1BEE
03C98:  MOVFF  1A1,264
03C9C:  MOVLW  37
03C9E:  MOVLB  2
03CA0:  MOVWF  x65
03CA2:  MOVLB  0
03CA4:  CALL   1E42
03CA8:  MOVLW  0D
03CAA:  MOVLB  A
03CAC:  MOVWF  xAD
03CAE:  MOVLB  0
03CB0:  CALL   1B6C
03CB4:  MOVLW  0A
03CB6:  MOVLB  A
03CB8:  MOVWF  xAD
03CBA:  MOVLB  0
03CBC:  CALL   1B6C
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
03CC0:  MOVLW  E8
03CC2:  MOVWF  FF6
03CC4:  MOVLW  03
03CC6:  MOVWF  FF7
03CC8:  MOVLW  00
03CCA:  MOVWF  FF8
03CCC:  MOVLW  13
03CCE:  MOVLB  9
03CD0:  MOVWF  xC2
03CD2:  MOVLB  0
03CD4:  CALL   1BEE
03CD8:  MOVLW  0C
03CDA:  MOVLB  2
03CDC:  MOVWF  x64
03CDE:  MOVLW  37
03CE0:  MOVWF  x65
03CE2:  MOVLB  0
03CE4:  CALL   1E42
03CE8:  MOVLW  0D
03CEA:  MOVLB  A
03CEC:  MOVWF  xAD
03CEE:  MOVLB  0
03CF0:  CALL   1B6C
03CF4:  MOVLW  0A
03CF6:  MOVLB  A
03CF8:  MOVWF  xAD
03CFA:  MOVLB  0
03CFC:  CALL   1B6C
....................       return FALSE;  
03D00:  MOVLW  00
03D02:  MOVWF  01
03D04:  GOTO   3D08
....................    }
03D08:  GOTO   3E82 (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
0400E:  MOVLW  AA
04010:  MOVLB  1
04012:  MOVWF  x8F
....................    data[1] = (BOSS_PIC << 4) | frame_id;
04014:  MOVF   x8B,W
04016:  IORLW  50
04018:  MOVWF  x90
....................    memcpy(&data[2], content, size);
0401A:  MOVLW  01
0401C:  MOVWF  FEA
0401E:  MOVLW  91
04020:  MOVWF  FE9
04022:  MOVFF  18D,FE2
04026:  MOVFF  18C,FE1
0402A:  MOVF   x8E,W
0402C:  MOVWF  01
0402E:  BTFSS  FD8.2
04030:  BRA    4038
04032:  MOVLB  0
04034:  GOTO   4044
04038:  MOVLB  0
0403A:  MOVFF  FE6,FEE
0403E:  DECFSZ 01,F
04040:  GOTO   403A
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
04044:  MOVLW  02
04046:  MOVLB  1
04048:  ADDWF  x8E,W
0404A:  MOVWF  x9F
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
0404C:  CLRF   03
0404E:  MOVF   x9F,W
04050:  ADDLW  8F
04052:  MOVWF  01
04054:  MOVLW  01
04056:  ADDWFC 03,F
04058:  MOVF   01,W
0405A:  MOVWF  xA1
0405C:  MOVFF  03,1A2
04060:  MOVLW  01
04062:  SUBWF  x9F,W
04064:  MOVWF  xA3
04066:  MOVLW  01
04068:  MOVLB  A
0406A:  MOVWF  xAE
0406C:  MOVLW  90
0406E:  MOVWF  xAD
04070:  MOVFF  1A3,AAF
04074:  MOVLB  0
04076:  CALL   29DC
0407A:  MOVFF  1A2,FEA
0407E:  MOVFF  1A1,FE9
04082:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
04086:  MOVLW  01
04088:  MOVLB  1
0408A:  ADDWF  x9F,W
0408C:  MOVWF  xA0
....................    
....................    transmit(data, data_size);
0408E:  MOVLW  01
04090:  MOVWF  xA2
04092:  MOVLW  8F
04094:  MOVWF  xA1
04096:  MOVFF  1A0,1A3
0409A:  MOVLB  0
0409C:  GOTO   3F56
040A0:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
03F56:  MOVLB  1
03F58:  CLRF   xA4
03F5A:  MOVLB  0
03F5C:  MOVLB  1
03F5E:  MOVF   xA3,W
03F60:  SUBWF  xA4,W
03F62:  BTFSS  FD8.0
03F64:  BRA    3F6C
03F66:  MOVLB  0
03F68:  GOTO   3F92
03F6C:  MOVLB  0
....................       fputc(data[i], BOSS);
03F6E:  MOVLB  1
03F70:  MOVF   xA4,W
03F72:  ADDWF  xA1,W
03F74:  MOVWF  FE9
03F76:  MOVLW  00
03F78:  ADDWFC xA2,W
03F7A:  MOVWF  FEA
03F7C:  MOVFF  FEF,1A6
03F80:  MOVF   xA6,W
03F82:  MOVLB  0
03F84:  GOTO   3F46
03F88:  MOVLB  1
03F8A:  INCF   xA4,F
03F8C:  MOVLB  0
03F8E:  GOTO   3F5C
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
03F92:  MOVLW  00
03F94:  MOVWF  FF6
03F96:  MOVLW  04
03F98:  MOVWF  FF7
03F9A:  MOVLW  00
03F9C:  MOVWF  FF8
03F9E:  CALL   1BBE
....................    for(int i = 0; i < data_size; i++)
03FA2:  MOVLB  1
03FA4:  CLRF   xA5
03FA6:  MOVLB  0
03FA8:  MOVLB  1
03FAA:  MOVF   xA3,W
03FAC:  SUBWF  xA5,W
03FAE:  BTFSS  FD8.0
03FB0:  BRA    3FB8
03FB2:  MOVLB  0
03FB4:  GOTO   3FF2
03FB8:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
03FBA:  MOVLB  1
03FBC:  MOVF   xA5,W
03FBE:  ADDWF  xA1,W
03FC0:  MOVWF  FE9
03FC2:  MOVLW  00
03FC4:  ADDWFC xA2,W
03FC6:  MOVWF  FEA
03FC8:  MOVFF  FEF,1A6
03FCC:  MOVFF  1A6,264
03FD0:  MOVLW  37
03FD2:  MOVLB  2
03FD4:  MOVWF  x65
03FD6:  MOVLB  0
03FD8:  CALL   1E42
03FDC:  MOVLW  20
03FDE:  MOVLB  A
03FE0:  MOVWF  xAD
03FE2:  MOVLB  0
03FE4:  CALL   1B6C
03FE8:  MOVLB  1
03FEA:  INCF   xA5,F
03FEC:  MOVLB  0
03FEE:  GOTO   3FA8
....................    fprintf(PC, "\r\n");
03FF2:  MOVLW  0D
03FF4:  MOVLB  A
03FF6:  MOVWF  xAD
03FF8:  MOVLB  0
03FFA:  CALL   1B6C
03FFE:  MOVLW  0A
04000:  MOVLB  A
04002:  MOVWF  xAD
04004:  MOVLB  0
04006:  CALL   1B6C
0400A:  GOTO   40A0 (RETURN)
.................... }
.................... 
.................... #include "../../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
040A2:  MOVLW  0F
040A4:  MOVLB  1
040A6:  MOVWF  x8B
040A8:  CLRF   x8D
040AA:  CLRF   x8C
040AC:  CLRF   x8E
040AE:  MOVLB  0
040B0:  CALL   400E
040B4:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
0921E:  MOVLW  03
09220:  MOVLB  1
09222:  MOVWF  x8B
09224:  CLRF   x8D
09226:  MOVLW  48
09228:  MOVWF  x8C
0922A:  MOVLW  04
0922C:  MOVWF  x8E
0922E:  MOVLB  0
09230:  CALL   400E
09234:  GOTO   925C (RETURN)
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "../core/measurement/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../storage/mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
01C24:  MOVLW  14
01C26:  MOVWF  FF6
01C28:  MOVLW  05
01C2A:  MOVWF  FF7
01C2C:  MOVLW  00
01C2E:  MOVWF  FF8
01C30:  CALL   1BBE
....................     // output_high(ADC_CS); // ADC Chip Select
....................     output_high(MIS_FM_CS); // DAC Chip Select
01C34:  MOVLW  DB
01C36:  MOVWF  F92
01C38:  BSF    F89.5
....................     output_high(SMF_CS); // SMF Chip Select
01C3A:  MOVLW  DB
01C3C:  MOVWF  F92
01C3E:  BSF    F89.2
....................     output_low(CONNECT_CIGS1);
01C40:  MOVLW  5E
01C42:  MOVWF  F94
01C44:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
01C46:  MOVLW  5E
01C48:  MOVWF  F94
01C4A:  BCF    F8B.5
....................     output_high(EN_NPWR);
01C4C:  MOVLW  5E
01C4E:  MOVWF  F94
01C50:  BSF    F8B.7
....................     delay_ms(1);
01C52:  MOVLW  01
01C54:  MOVLB  A
01C56:  MOVWF  x6E
01C58:  MOVLB  0
01C5A:  CALL   1B3E
....................     fprintf(PC, "\tComplete\r\n");
01C5E:  MOVLW  24
01C60:  MOVWF  FF6
01C62:  MOVLW  05
01C64:  MOVWF  FF7
01C66:  MOVLW  00
01C68:  MOVWF  FF8
01C6A:  CALL   1BBE
01C6E:  GOTO   B626 (RETURN)
.................... }
.................... 
.................... 
.................... void test_sweep(unsigned int8 sweep_step)
.................... {
....................     fprintf(PC, "Start TEST SWEEP\r\n");
....................     output_high(CONNECT_CIGS1);
....................     output_low(EN_NPWR); // Enable power to CIGS
....................     delay_us(100); // wait for the CIGS to stabilize
....................     fprintf(PC, "step, voltage, current\r\n");
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     delay_ms(100); // wait for the DAC to stabilize
.................... 
.................... 
....................     unsigned int16 volt;
....................     unsigned int16 curr;
....................     for (unsigned int8 count = 0; count < sweep_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
.................... 
....................         volt = ad7490_read(ADC_CIGS1_AMP); // read CIGS voltage
....................         curr = ad7490_read(ADC_CIGS1_CURR); // read CIGS current
....................         
....................         fprintf(PC, "%u, %lu, %lu\r\n", count, volt, curr);
....................         delay_ms(1); // wait for the ADC to stabilize
....................     }
.................... }
.................... 
.................... void test_adc()
.................... {
....................     unsigned int16 ans;
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     fprintf(PC, "Start ADC TEST\r\n");
....................     ans = ad7490_read(ADC_CIGS1_VOLT);
....................     fprintf(PC, "ADC Voltage: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_CURR);
....................     fprintf(PC, "ADC Current: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_AMP);
....................     fprintf(PC, "ADC CIGS1 Amp: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_VREF);
....................     fprintf(PC, "ADC CIGS1 VREF: %04LX\r\n", ans);
.................... }
.................... 
.................... void sweep_2ports(unsigned int8 measurement_step)
.................... { 
....................     fprintf(PC, "Start SWEEP 2ports\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1 and CIGS2
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
....................     unsigned int16 cigs2_buffer[2][0xFF];
.................... 
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_VOLT);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP 2port\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... 
.................... 
.................... /*
.................... void add_smf_queue_data()
.................... {
....................     SmfDataStruct smf_data;
....................     smf_data.type = SMF_DATA_TYPE_CIGS;
....................     smf_data.length = PACKET_SIZE;
....................     memcpy(smf_data.data, packetdata, PACKET_SIZE);
....................     enqueue_smf_data(&smf_data);
.................... }
.................... */
.................... void add_smf_queue_piclog()
.................... {}
.................... 
.................... void convert_datas(MEASUREMENT_DATA measured_data, )
.................... {
....................     
.................... }
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, "Start SWEEP with threshold\r\n");
*
07146:  MOVLW  26
07148:  MOVWF  FF6
0714A:  MOVLW  06
0714C:  MOVWF  FF7
0714E:  MOVLW  00
07150:  MOVWF  FF8
07152:  CALL   1BBE
....................    
....................     // Enable both CIGS ports
....................     output_low(EN_NPWR);
07156:  MOVLW  5E
07158:  MOVWF  F94
0715A:  BCF    F8B.7
....................     output_high(CONNECT_CIGS1);
0715C:  MOVLW  5E
0715E:  MOVWF  F94
07160:  BSF    F8B.0
....................     output_high(CONNECT_CIGS2);
07162:  MOVLW  5E
07164:  MOVWF  F94
07166:  BSF    F8B.5
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     SWEEP_CONFIG port1 = {0};
07168:  MOVLB  1
0716A:  CLRF   xB1
0716C:  CLRF   xB2
0716E:  CLRF   xB3
07170:  CLRF   xB4
07172:  CLRF   xB5
07174:  CLRF   xB6
07176:  CLRF   xB7
07178:  CLRF   xB8
0717A:  CLRF   xB9
0717C:  CLRF   xBA
0717E:  CLRF   xBB
07180:  CLRF   xBC
07182:  CLRF   xBD
07184:  CLRF   xBE
07186:  CLRF   xBF
07188:  CLRF   xC0
0718A:  CLRF   xC1
0718C:  CLRF   xC2
0718E:  CLRF   xC3
07190:  CLRF   xC4
07192:  CLRF   xC5
07194:  CLRF   xC6
07196:  CLRF   xC7
07198:  CLRF   xC8
0719A:  CLRF   xC9
0719C:  CLRF   xCA
0719E:  CLRF   xCB
071A0:  CLRF   xCC
071A2:  CLRF   xCD
071A4:  CLRF   xCE
071A6:  CLRF   xCF
071A8:  CLRF   xD0
071AA:  CLRF   xD1
071AC:  CLRF   xD2
071AE:  CLRF   xD3
071B0:  CLRF   xD4
071B2:  CLRF   xD5
071B4:  CLRF   xD6
071B6:  CLRF   xD7
071B8:  CLRF   xD8
071BA:  CLRF   xD9
071BC:  CLRF   xDA
071BE:  CLRF   xDB
071C0:  CLRF   xDC
071C2:  CLRF   xDD
071C4:  CLRF   xDE
071C6:  CLRF   xDF
071C8:  CLRF   xE0
071CA:  CLRF   xE1
071CC:  CLRF   xE2
071CE:  CLRF   xE3
071D0:  CLRF   xE4
071D2:  CLRF   xE5
071D4:  CLRF   xE6
071D6:  CLRF   xE7
071D8:  CLRF   xE8
071DA:  CLRF   xE9
071DC:  CLRF   xEA
071DE:  CLRF   xEB
071E0:  CLRF   xEC
071E2:  CLRF   xED
071E4:  CLRF   xEE
071E6:  CLRF   xEF
071E8:  CLRF   xF0
071EA:  CLRF   xF1
071EC:  CLRF   xF2
071EE:  CLRF   xF3
071F0:  CLRF   xF4
071F2:  CLRF   xF5
071F4:  CLRF   xF6
071F6:  CLRF   xF7
071F8:  CLRF   xF8
071FA:  CLRF   xF9
071FC:  CLRF   xFA
071FE:  CLRF   xFB
07200:  CLRF   xFC
07202:  CLRF   xFD
07204:  CLRF   xFE
07206:  CLRF   xFF
07208:  MOVLB  2
0720A:  CLRF   x00
0720C:  CLRF   x01
0720E:  CLRF   x02
07210:  CLRF   x03
07212:  CLRF   x04
07214:  CLRF   x05
07216:  CLRF   x06
07218:  CLRF   x07
0721A:  CLRF   x08
0721C:  CLRF   x09
0721E:  CLRF   x0A
07220:  CLRF   x0B
07222:  CLRF   x0C
07224:  CLRF   x0D
07226:  CLRF   x0E
07228:  CLRF   x0F
0722A:  CLRF   x10
0722C:  CLRF   x11
0722E:  CLRF   x12
07230:  CLRF   x13
07232:  CLRF   x14
07234:  CLRF   x15
07236:  CLRF   x16
07238:  CLRF   x17
0723A:  CLRF   x18
0723C:  CLRF   x19
0723E:  CLRF   x1A
07240:  CLRF   x1B
07242:  CLRF   x1C
07244:  CLRF   x1D
07246:  CLRF   x1E
07248:  CLRF   x1F
0724A:  CLRF   x20
0724C:  CLRF   x21
0724E:  CLRF   x22
07250:  CLRF   x23
07252:  CLRF   x24
07254:  CLRF   x25
07256:  CLRF   x26
07258:  CLRF   x27
0725A:  CLRF   x28
0725C:  CLRF   x29
0725E:  CLRF   x2A
07260:  CLRF   x2B
07262:  CLRF   x2C
07264:  CLRF   x2D
07266:  CLRF   x2E
07268:  CLRF   x2F
0726A:  CLRF   x30
0726C:  CLRF   x31
0726E:  CLRF   x32
07270:  CLRF   x33
07272:  CLRF   x34
07274:  CLRF   x35
07276:  CLRF   x36
07278:  CLRF   x37
0727A:  CLRF   x38
0727C:  CLRF   x39
0727E:  CLRF   x3A
07280:  CLRF   x3B
07282:  CLRF   x3C
07284:  CLRF   x3D
07286:  CLRF   x3E
07288:  CLRF   x3F
0728A:  CLRF   x40
0728C:  CLRF   x41
0728E:  CLRF   x42
07290:  CLRF   x43
07292:  CLRF   x44
07294:  CLRF   x45
07296:  CLRF   x46
07298:  CLRF   x47
0729A:  CLRF   x48
0729C:  CLRF   x49
0729E:  CLRF   x4A
072A0:  CLRF   x4B
072A2:  CLRF   x4C
072A4:  CLRF   x4D
072A6:  CLRF   x4E
072A8:  CLRF   x4F
072AA:  CLRF   x50
072AC:  CLRF   x51
072AE:  CLRF   x52
072B0:  CLRF   x53
072B2:  CLRF   x54
072B4:  CLRF   x55
072B6:  CLRF   x56
072B8:  CLRF   x57
072BA:  CLRF   x58
072BC:  CLRF   x59
072BE:  CLRF   x5A
072C0:  CLRF   x5B
072C2:  CLRF   x5C
072C4:  CLRF   x5D
072C6:  CLRF   x5E
072C8:  CLRF   x5F
072CA:  CLRF   x60
072CC:  CLRF   x61
072CE:  CLRF   x62
072D0:  CLRF   x63
072D2:  CLRF   x64
072D4:  CLRF   x65
072D6:  CLRF   x66
072D8:  CLRF   x67
072DA:  CLRF   x68
072DC:  CLRF   x69
072DE:  CLRF   x6A
072E0:  CLRF   x6B
072E2:  CLRF   x6C
072E4:  CLRF   x6D
072E6:  CLRF   x6E
072E8:  CLRF   x6F
072EA:  CLRF   x70
072EC:  CLRF   x71
072EE:  CLRF   x72
072F0:  CLRF   x73
072F2:  CLRF   x74
072F4:  CLRF   x75
072F6:  CLRF   x76
072F8:  CLRF   x77
072FA:  CLRF   x78
072FC:  CLRF   x79
072FE:  CLRF   x7A
07300:  CLRF   x7B
07302:  CLRF   x7C
07304:  CLRF   x7D
07306:  CLRF   x7E
07308:  CLRF   x7F
0730A:  CLRF   x80
0730C:  CLRF   x81
0730E:  CLRF   x82
07310:  CLRF   x83
07312:  CLRF   x84
07314:  CLRF   x85
07316:  CLRF   x86
07318:  CLRF   x87
0731A:  CLRF   x88
0731C:  CLRF   x89
0731E:  CLRF   x8A
07320:  CLRF   x8B
07322:  CLRF   x8C
07324:  CLRF   x8D
07326:  CLRF   x8E
07328:  CLRF   x8F
0732A:  CLRF   x90
0732C:  CLRF   x91
0732E:  CLRF   x92
07330:  CLRF   x93
07332:  CLRF   x94
07334:  CLRF   x95
07336:  CLRF   x96
07338:  CLRF   x97
0733A:  CLRF   x98
0733C:  CLRF   x99
0733E:  CLRF   x9A
07340:  CLRF   x9B
07342:  CLRF   x9C
07344:  CLRF   x9D
07346:  CLRF   x9E
07348:  CLRF   x9F
0734A:  CLRF   xA0
0734C:  CLRF   xA1
0734E:  CLRF   xA2
07350:  CLRF   xA3
07352:  CLRF   xA4
07354:  CLRF   xA5
07356:  CLRF   xA6
07358:  CLRF   xA7
0735A:  CLRF   xA8
0735C:  CLRF   xA9
0735E:  CLRF   xAA
07360:  CLRF   xAB
07362:  CLRF   xAC
07364:  CLRF   xAD
07366:  CLRF   xAE
07368:  CLRF   xAF
0736A:  CLRF   xB0
0736C:  CLRF   xB1
0736E:  CLRF   xB2
07370:  CLRF   xB3
07372:  CLRF   xB4
07374:  CLRF   xB5
07376:  CLRF   xB6
07378:  CLRF   xB7
0737A:  CLRF   xB8
0737C:  CLRF   xB9
0737E:  CLRF   xBA
07380:  CLRF   xBB
07382:  CLRF   xBC
07384:  CLRF   xBD
07386:  CLRF   xBE
07388:  CLRF   xBF
0738A:  CLRF   xC0
0738C:  CLRF   xC1
0738E:  CLRF   xC2
07390:  CLRF   xC3
07392:  CLRF   xC4
07394:  CLRF   xC5
07396:  CLRF   xC6
07398:  CLRF   xC7
0739A:  CLRF   xC8
0739C:  CLRF   xC9
0739E:  CLRF   xCA
073A0:  CLRF   xCB
073A2:  CLRF   xCC
073A4:  CLRF   xCD
073A6:  CLRF   xCE
073A8:  CLRF   xCF
073AA:  CLRF   xD0
073AC:  CLRF   xD1
073AE:  CLRF   xD2
073B0:  CLRF   xD3
073B2:  CLRF   xD4
073B4:  CLRF   xD5
073B6:  CLRF   xD6
073B8:  CLRF   xD7
073BA:  CLRF   xD8
073BC:  CLRF   xD9
073BE:  CLRF   xDA
073C0:  CLRF   xDB
073C2:  CLRF   xDC
073C4:  CLRF   xDD
073C6:  CLRF   xDE
073C8:  CLRF   xDF
073CA:  CLRF   xE0
073CC:  CLRF   xE1
073CE:  CLRF   xE2
073D0:  CLRF   xE3
073D2:  CLRF   xE4
073D4:  CLRF   xE5
073D6:  CLRF   xE6
073D8:  CLRF   xE7
073DA:  CLRF   xE8
073DC:  CLRF   xE9
073DE:  CLRF   xEA
073E0:  CLRF   xEB
073E2:  CLRF   xEC
073E4:  CLRF   xED
073E6:  CLRF   xEE
073E8:  CLRF   xEF
073EA:  CLRF   xF0
073EC:  CLRF   xF1
073EE:  CLRF   xF2
073F0:  CLRF   xF3
073F2:  CLRF   xF4
073F4:  CLRF   xF5
073F6:  CLRF   xF6
073F8:  CLRF   xF7
073FA:  CLRF   xF8
073FC:  CLRF   xF9
073FE:  CLRF   xFA
07400:  CLRF   xFB
07402:  CLRF   xFC
07404:  CLRF   xFD
07406:  CLRF   xFE
07408:  CLRF   xFF
0740A:  MOVLB  3
0740C:  CLRF   x00
0740E:  CLRF   x01
07410:  CLRF   x02
07412:  CLRF   x03
07414:  CLRF   x04
07416:  CLRF   x05
07418:  CLRF   x06
0741A:  CLRF   x07
0741C:  CLRF   x08
0741E:  CLRF   x09
07420:  CLRF   x0A
07422:  CLRF   x0B
07424:  CLRF   x0C
07426:  CLRF   x0D
07428:  CLRF   x0E
0742A:  CLRF   x0F
0742C:  CLRF   x10
0742E:  CLRF   x11
07430:  CLRF   x12
07432:  CLRF   x13
07434:  CLRF   x14
07436:  CLRF   x15
07438:  CLRF   x16
0743A:  CLRF   x17
0743C:  CLRF   x18
0743E:  CLRF   x19
07440:  CLRF   x1A
07442:  CLRF   x1B
07444:  CLRF   x1C
07446:  CLRF   x1D
07448:  CLRF   x1E
0744A:  CLRF   x1F
0744C:  CLRF   x20
0744E:  CLRF   x21
07450:  CLRF   x22
07452:  CLRF   x23
07454:  CLRF   x24
07456:  CLRF   x25
07458:  CLRF   x26
0745A:  CLRF   x27
0745C:  CLRF   x28
0745E:  CLRF   x29
07460:  CLRF   x2A
07462:  CLRF   x2B
07464:  CLRF   x2C
07466:  CLRF   x2D
07468:  CLRF   x2E
0746A:  CLRF   x2F
0746C:  CLRF   x30
0746E:  CLRF   x31
07470:  CLRF   x32
07472:  CLRF   x33
07474:  CLRF   x34
07476:  CLRF   x35
07478:  CLRF   x36
0747A:  CLRF   x37
0747C:  CLRF   x38
0747E:  CLRF   x39
07480:  CLRF   x3A
07482:  CLRF   x3B
07484:  CLRF   x3C
07486:  CLRF   x3D
07488:  CLRF   x3E
0748A:  CLRF   x3F
0748C:  CLRF   x40
0748E:  CLRF   x41
07490:  CLRF   x42
07492:  CLRF   x43
07494:  CLRF   x44
07496:  CLRF   x45
07498:  CLRF   x46
0749A:  CLRF   x47
0749C:  CLRF   x48
0749E:  CLRF   x49
074A0:  CLRF   x4A
074A2:  CLRF   x4B
074A4:  CLRF   x4C
074A6:  CLRF   x4D
074A8:  CLRF   x4E
074AA:  CLRF   x4F
074AC:  CLRF   x50
074AE:  CLRF   x51
074B0:  CLRF   x52
074B2:  CLRF   x53
074B4:  CLRF   x54
074B6:  CLRF   x55
074B8:  CLRF   x56
074BA:  CLRF   x57
074BC:  CLRF   x58
074BE:  CLRF   x59
074C0:  CLRF   x5A
074C2:  CLRF   x5B
074C4:  CLRF   x5C
074C6:  CLRF   x5D
074C8:  CLRF   x5E
074CA:  CLRF   x5F
074CC:  CLRF   x60
074CE:  CLRF   x61
074D0:  CLRF   x62
074D2:  CLRF   x63
074D4:  CLRF   x64
074D6:  CLRF   x65
074D8:  CLRF   x66
074DA:  CLRF   x67
074DC:  CLRF   x68
074DE:  CLRF   x69
074E0:  CLRF   x6A
074E2:  CLRF   x6B
074E4:  CLRF   x6C
074E6:  CLRF   x6D
074E8:  CLRF   x6E
074EA:  CLRF   x6F
074EC:  CLRF   x70
074EE:  CLRF   x71
074F0:  CLRF   x72
074F2:  CLRF   x73
074F4:  CLRF   x74
074F6:  CLRF   x75
074F8:  CLRF   x76
074FA:  CLRF   x77
074FC:  CLRF   x78
074FE:  CLRF   x79
07500:  CLRF   x7A
07502:  CLRF   x7B
07504:  CLRF   x7C
07506:  CLRF   x7D
07508:  CLRF   x7E
0750A:  CLRF   x7F
0750C:  CLRF   x80
0750E:  CLRF   x81
07510:  CLRF   x82
07512:  CLRF   x83
07514:  CLRF   x84
07516:  CLRF   x85
07518:  CLRF   x86
0751A:  CLRF   x87
0751C:  CLRF   x88
0751E:  CLRF   x89
07520:  CLRF   x8A
07522:  CLRF   x8B
07524:  CLRF   x8C
07526:  CLRF   x8D
07528:  CLRF   x8E
0752A:  CLRF   x8F
0752C:  CLRF   x90
0752E:  CLRF   x91
07530:  CLRF   x92
07532:  CLRF   x93
07534:  CLRF   x94
07536:  CLRF   x95
07538:  CLRF   x96
0753A:  CLRF   x97
0753C:  CLRF   x98
0753E:  CLRF   x99
07540:  CLRF   x9A
07542:  CLRF   x9B
07544:  CLRF   x9C
07546:  CLRF   x9D
07548:  CLRF   x9E
0754A:  CLRF   x9F
0754C:  CLRF   xA0
0754E:  CLRF   xA1
07550:  CLRF   xA2
07552:  CLRF   xA3
07554:  CLRF   xA4
07556:  CLRF   xA5
07558:  CLRF   xA6
0755A:  CLRF   xA7
0755C:  CLRF   xA8
0755E:  CLRF   xA9
07560:  CLRF   xAA
07562:  CLRF   xAB
07564:  CLRF   xAC
07566:  CLRF   xAD
07568:  CLRF   xAE
0756A:  CLRF   xAF
0756C:  CLRF   xB0
0756E:  CLRF   xB1
07570:  CLRF   xB2
07572:  CLRF   xB3
07574:  CLRF   xB4
07576:  CLRF   xB5
07578:  CLRF   xB6
0757A:  CLRF   xB7
0757C:  CLRF   xB8
0757E:  CLRF   xB9
07580:  CLRF   xBA
07582:  CLRF   xBB
07584:  CLRF   xBC
07586:  CLRF   xBD
07588:  CLRF   xBE
0758A:  CLRF   xBF
0758C:  CLRF   xC0
0758E:  CLRF   xC1
07590:  CLRF   xC2
07592:  CLRF   xC3
07594:  CLRF   xC4
07596:  CLRF   xC5
07598:  CLRF   xC6
0759A:  CLRF   xC7
0759C:  CLRF   xC8
0759E:  CLRF   xC9
075A0:  CLRF   xCA
075A2:  CLRF   xCB
075A4:  CLRF   xCC
075A6:  CLRF   xCD
075A8:  CLRF   xCE
075AA:  CLRF   xCF
075AC:  CLRF   xD0
075AE:  CLRF   xD1
075B0:  CLRF   xD2
075B2:  CLRF   xD3
075B4:  CLRF   xD4
075B6:  CLRF   xD5
075B8:  CLRF   xD6
075BA:  CLRF   xD7
075BC:  CLRF   xD8
075BE:  CLRF   xD9
075C0:  CLRF   xDA
075C2:  CLRF   xDB
075C4:  CLRF   xDC
075C6:  CLRF   xDD
075C8:  CLRF   xDE
075CA:  CLRF   xDF
075CC:  CLRF   xE0
075CE:  CLRF   xE1
075D0:  CLRF   xE2
075D2:  CLRF   xE3
075D4:  CLRF   xE4
075D6:  CLRF   xE5
075D8:  CLRF   xE6
075DA:  CLRF   xE7
075DC:  CLRF   xE8
075DE:  CLRF   xE9
075E0:  CLRF   xEA
075E2:  CLRF   xEB
075E4:  CLRF   xEC
075E6:  CLRF   xED
075E8:  CLRF   xEE
075EA:  CLRF   xEF
075EC:  CLRF   xF0
075EE:  CLRF   xF1
075F0:  CLRF   xF2
075F2:  CLRF   xF3
075F4:  CLRF   xF4
075F6:  CLRF   xF5
075F8:  CLRF   xF6
075FA:  CLRF   xF7
075FC:  CLRF   xF8
075FE:  CLRF   xF9
07600:  CLRF   xFA
07602:  CLRF   xFB
07604:  CLRF   xFC
07606:  CLRF   xFD
07608:  CLRF   xFE
0760A:  CLRF   xFF
0760C:  MOVLB  4
0760E:  CLRF   x00
07610:  CLRF   x01
07612:  CLRF   x02
07614:  CLRF   x03
07616:  CLRF   x04
07618:  CLRF   x05
0761A:  CLRF   x06
0761C:  CLRF   x07
0761E:  CLRF   x08
07620:  CLRF   x09
07622:  CLRF   x0A
07624:  CLRF   x0B
07626:  CLRF   x0C
07628:  CLRF   x0D
0762A:  CLRF   x0E
0762C:  CLRF   x0F
0762E:  CLRF   x10
07630:  CLRF   x11
07632:  CLRF   x12
07634:  CLRF   x13
07636:  CLRF   x14
07638:  CLRF   x15
0763A:  CLRF   x16
0763C:  CLRF   x17
0763E:  CLRF   x18
07640:  CLRF   x19
07642:  CLRF   x1A
07644:  CLRF   x1B
07646:  CLRF   x1C
07648:  CLRF   x1D
0764A:  CLRF   x1E
0764C:  CLRF   x1F
0764E:  CLRF   x20
07650:  CLRF   x21
07652:  CLRF   x22
07654:  CLRF   x23
07656:  CLRF   x24
07658:  CLRF   x25
0765A:  CLRF   x26
0765C:  CLRF   x27
0765E:  CLRF   x28
07660:  CLRF   x29
07662:  CLRF   x2A
07664:  CLRF   x2B
07666:  CLRF   x2C
07668:  CLRF   x2D
0766A:  CLRF   x2E
0766C:  CLRF   x2F
0766E:  CLRF   x30
07670:  CLRF   x31
07672:  CLRF   x32
07674:  CLRF   x33
07676:  CLRF   x34
07678:  CLRF   x35
0767A:  CLRF   x36
0767C:  CLRF   x37
0767E:  CLRF   x38
07680:  CLRF   x39
07682:  CLRF   x3A
07684:  CLRF   x3B
07686:  CLRF   x3C
07688:  CLRF   x3D
0768A:  CLRF   x3E
0768C:  CLRF   x3F
0768E:  CLRF   x40
07690:  CLRF   x41
07692:  CLRF   x42
07694:  CLRF   x43
07696:  CLRF   x44
07698:  CLRF   x45
0769A:  CLRF   x46
0769C:  CLRF   x47
0769E:  CLRF   x48
076A0:  CLRF   x49
076A2:  CLRF   x4A
076A4:  CLRF   x4B
076A6:  CLRF   x4C
076A8:  CLRF   x4D
076AA:  CLRF   x4E
076AC:  CLRF   x4F
076AE:  CLRF   x50
076B0:  CLRF   x51
076B2:  CLRF   x52
076B4:  CLRF   x53
076B6:  CLRF   x54
076B8:  CLRF   x55
076BA:  CLRF   x56
076BC:  CLRF   x57
076BE:  CLRF   x58
076C0:  CLRF   x59
076C2:  CLRF   x5A
076C4:  CLRF   x5B
076C6:  CLRF   x5C
076C8:  CLRF   x5D
076CA:  CLRF   x5E
076CC:  CLRF   x5F
076CE:  CLRF   x60
076D0:  CLRF   x61
076D2:  CLRF   x62
076D4:  CLRF   x63
076D6:  CLRF   x64
076D8:  CLRF   x65
076DA:  CLRF   x66
076DC:  CLRF   x67
076DE:  CLRF   x68
076E0:  CLRF   x69
076E2:  CLRF   x6A
076E4:  CLRF   x6B
076E6:  CLRF   x6C
076E8:  CLRF   x6D
076EA:  CLRF   x6E
076EC:  CLRF   x6F
076EE:  CLRF   x70
076F0:  CLRF   x71
076F2:  CLRF   x72
076F4:  CLRF   x73
076F6:  CLRF   x74
076F8:  CLRF   x75
076FA:  CLRF   x76
076FC:  CLRF   x77
076FE:  CLRF   x78
07700:  CLRF   x79
07702:  CLRF   x7A
07704:  CLRF   x7B
07706:  CLRF   x7C
07708:  CLRF   x7D
0770A:  CLRF   x7E
0770C:  CLRF   x7F
0770E:  CLRF   x80
07710:  CLRF   x81
07712:  CLRF   x82
07714:  CLRF   x83
07716:  CLRF   x84
07718:  CLRF   x85
0771A:  CLRF   x86
0771C:  CLRF   x87
0771E:  CLRF   x88
07720:  CLRF   x89
07722:  CLRF   x8A
07724:  CLRF   x8B
07726:  CLRF   x8C
07728:  CLRF   x8D
0772A:  CLRF   x8E
0772C:  CLRF   x8F
0772E:  CLRF   x90
07730:  CLRF   x91
07732:  CLRF   x92
07734:  CLRF   x93
07736:  CLRF   x94
07738:  CLRF   x95
0773A:  CLRF   x96
0773C:  CLRF   x97
0773E:  CLRF   x98
07740:  CLRF   x99
07742:  CLRF   x9A
07744:  CLRF   x9B
07746:  CLRF   x9C
07748:  CLRF   x9D
0774A:  CLRF   x9E
0774C:  CLRF   x9F
0774E:  CLRF   xA0
07750:  CLRF   xA1
07752:  CLRF   xA2
07754:  CLRF   xA3
07756:  CLRF   xA4
07758:  CLRF   xA5
0775A:  CLRF   xA6
0775C:  CLRF   xA7
0775E:  CLRF   xA8
07760:  CLRF   xA9
07762:  CLRF   xAA
07764:  CLRF   xAB
07766:  CLRF   xAC
07768:  CLRF   xAD
0776A:  CLRF   xAE
0776C:  CLRF   xAF
0776E:  CLRF   xB0
07770:  CLRF   xB1
07772:  CLRF   xB2
07774:  CLRF   xB3
07776:  CLRF   xB4
07778:  CLRF   xB5
0777A:  CLRF   xB6
0777C:  CLRF   xB7
0777E:  CLRF   xB8
07780:  CLRF   xB9
07782:  CLRF   xBA
07784:  CLRF   xBB
07786:  CLRF   xBC
07788:  CLRF   xBD
0778A:  CLRF   xBE
0778C:  CLRF   xBF
0778E:  CLRF   xC0
07790:  CLRF   xC1
07792:  CLRF   xC2
07794:  CLRF   xC3
07796:  CLRF   xC4
07798:  CLRF   xC5
0779A:  CLRF   xC6
0779C:  CLRF   xC7
0779E:  CLRF   xC8
077A0:  CLRF   xC9
077A2:  CLRF   xCA
077A4:  CLRF   xCB
077A6:  CLRF   xCC
077A8:  CLRF   xCD
077AA:  CLRF   xCE
077AC:  CLRF   xCF
077AE:  CLRF   xD0
077B0:  CLRF   xD1
077B2:  CLRF   xD2
077B4:  CLRF   xD3
077B6:  CLRF   xD4
077B8:  CLRF   xD5
077BA:  CLRF   xD6
077BC:  CLRF   xD7
077BE:  CLRF   xD8
077C0:  CLRF   xD9
077C2:  CLRF   xDA
077C4:  CLRF   xDB
077C6:  CLRF   xDC
077C8:  CLRF   xDD
077CA:  CLRF   xDE
077CC:  CLRF   xDF
077CE:  CLRF   xE0
077D0:  CLRF   xE1
077D2:  CLRF   xE2
077D4:  CLRF   xE3
077D6:  CLRF   xE4
077D8:  CLRF   xE5
077DA:  CLRF   xE6
077DC:  CLRF   xE7
077DE:  CLRF   xE8
077E0:  CLRF   xE9
077E2:  CLRF   xEA
077E4:  CLRF   xEB
077E6:  CLRF   xEC
077E8:  CLRF   xED
077EA:  CLRF   xEE
077EC:  CLRF   xEF
077EE:  CLRF   xF0
077F0:  CLRF   xF1
077F2:  CLRF   xF2
077F4:  CLRF   xF3
077F6:  CLRF   xF4
077F8:  CLRF   xF5
077FA:  CLRF   xF6
077FC:  CLRF   xF7
077FE:  CLRF   xF8
07800:  CLRF   xF9
07802:  CLRF   xFA
07804:  CLRF   xFB
07806:  CLRF   xFC
07808:  CLRF   xFD
0780A:  CLRF   xFE
0780C:  CLRF   xFF
0780E:  MOVLB  5
07810:  CLRF   x00
07812:  CLRF   x01
07814:  CLRF   x02
07816:  CLRF   x03
07818:  CLRF   x04
0781A:  CLRF   x05
0781C:  CLRF   x06
0781E:  CLRF   x07
07820:  CLRF   x08
07822:  CLRF   x09
07824:  CLRF   x0A
07826:  CLRF   x0B
07828:  CLRF   x0C
0782A:  CLRF   x0D
0782C:  CLRF   x0E
0782E:  CLRF   x0F
07830:  CLRF   x10
07832:  CLRF   x11
07834:  CLRF   x12
07836:  CLRF   x13
07838:  CLRF   x14
0783A:  CLRF   x15
0783C:  CLRF   x16
0783E:  CLRF   x17
07840:  CLRF   x18
07842:  CLRF   x19
07844:  CLRF   x1A
07846:  CLRF   x1B
07848:  CLRF   x1C
0784A:  CLRF   x1D
0784C:  CLRF   x1E
0784E:  CLRF   x1F
07850:  CLRF   x20
07852:  CLRF   x21
07854:  CLRF   x22
07856:  CLRF   x23
07858:  CLRF   x24
0785A:  CLRF   x25
0785C:  CLRF   x26
0785E:  CLRF   x27
07860:  CLRF   x28
07862:  CLRF   x29
07864:  CLRF   x2A
07866:  CLRF   x2B
07868:  CLRF   x2C
0786A:  CLRF   x2D
0786C:  CLRF   x2E
0786E:  CLRF   x2F
07870:  CLRF   x30
07872:  CLRF   x31
07874:  CLRF   x32
07876:  CLRF   x33
07878:  CLRF   x34
0787A:  CLRF   x35
0787C:  CLRF   x36
0787E:  CLRF   x37
07880:  CLRF   x38
07882:  CLRF   x39
07884:  CLRF   x3A
07886:  CLRF   x3B
07888:  CLRF   x3C
0788A:  CLRF   x3D
0788C:  CLRF   x3E
0788E:  CLRF   x3F
07890:  CLRF   x40
07892:  CLRF   x41
07894:  CLRF   x42
07896:  CLRF   x43
07898:  CLRF   x44
0789A:  CLRF   x45
0789C:  CLRF   x46
0789E:  CLRF   x47
078A0:  CLRF   x48
078A2:  CLRF   x49
078A4:  CLRF   x4A
078A6:  CLRF   x4B
078A8:  CLRF   x4C
078AA:  CLRF   x4D
078AC:  CLRF   x4E
078AE:  CLRF   x4F
078B0:  CLRF   x50
078B2:  CLRF   x51
078B4:  CLRF   x52
078B6:  CLRF   x53
078B8:  CLRF   x54
078BA:  CLRF   x55
078BC:  CLRF   x56
078BE:  CLRF   x57
078C0:  CLRF   x58
078C2:  CLRF   x59
078C4:  CLRF   x5A
078C6:  CLRF   x5B
078C8:  CLRF   x5C
078CA:  CLRF   x5D
078CC:  CLRF   x5E
078CE:  CLRF   x5F
078D0:  CLRF   x60
078D2:  CLRF   x61
078D4:  CLRF   x62
078D6:  CLRF   x63
078D8:  CLRF   x64
078DA:  CLRF   x65
078DC:  CLRF   x66
078DE:  CLRF   x67
078E0:  CLRF   x68
078E2:  CLRF   x69
078E4:  CLRF   x6A
078E6:  CLRF   x6B
078E8:  CLRF   x6C
078EA:  CLRF   x6D
078EC:  CLRF   x6E
078EE:  CLRF   x6F
078F0:  CLRF   x70
078F2:  CLRF   x71
078F4:  CLRF   x72
078F6:  CLRF   x73
078F8:  CLRF   x74
078FA:  CLRF   x75
078FC:  CLRF   x76
078FE:  CLRF   x77
07900:  CLRF   x78
07902:  CLRF   x79
07904:  CLRF   x7A
07906:  CLRF   x7B
07908:  CLRF   x7C
0790A:  CLRF   x7D
0790C:  CLRF   x7E
0790E:  CLRF   x7F
07910:  CLRF   x80
07912:  CLRF   x81
07914:  CLRF   x82
07916:  CLRF   x83
07918:  CLRF   x84
0791A:  CLRF   x85
0791C:  CLRF   x86
0791E:  CLRF   x87
07920:  CLRF   x88
07922:  CLRF   x89
07924:  CLRF   x8A
07926:  CLRF   x8B
07928:  CLRF   x8C
0792A:  CLRF   x8D
0792C:  CLRF   x8E
0792E:  CLRF   x8F
07930:  CLRF   x90
07932:  CLRF   x91
07934:  CLRF   x92
07936:  CLRF   x93
07938:  CLRF   x94
0793A:  CLRF   x95
0793C:  CLRF   x96
0793E:  CLRF   x97
07940:  CLRF   x98
07942:  CLRF   x99
07944:  CLRF   x9A
07946:  CLRF   x9B
07948:  CLRF   x9C
0794A:  CLRF   x9D
0794C:  CLRF   x9E
0794E:  CLRF   x9F
07950:  CLRF   xA0
07952:  CLRF   xA1
07954:  CLRF   xA2
07956:  CLRF   xA3
07958:  CLRF   xA4
0795A:  CLRF   xA5
0795C:  CLRF   xA6
0795E:  CLRF   xA7
07960:  CLRF   xA8
07962:  CLRF   xA9
07964:  CLRF   xAA
07966:  CLRF   xAB
07968:  CLRF   xAC
0796A:  CLRF   xAD
0796C:  CLRF   xAE
0796E:  CLRF   xAF
07970:  CLRF   xB0
....................     port1.port_num = 1;
07972:  MOVLW  01
07974:  MOVLB  1
07976:  MOVWF  xB1
....................     port1.sweep_step = 0;
07978:  CLRF   xB3
0797A:  CLRF   xB2
....................     port1.active = 1;
0797C:  MOVLB  5
0797E:  BSF    xB0.0
.................... 
....................     // Init Port2
....................     SWEEP_CONFIG port2 = {0};
07980:  CLRF   xB1
07982:  CLRF   xB2
07984:  CLRF   xB3
07986:  CLRF   xB4
07988:  CLRF   xB5
0798A:  CLRF   xB6
0798C:  CLRF   xB7
0798E:  CLRF   xB8
07990:  CLRF   xB9
07992:  CLRF   xBA
07994:  CLRF   xBB
07996:  CLRF   xBC
07998:  CLRF   xBD
0799A:  CLRF   xBE
0799C:  CLRF   xBF
0799E:  CLRF   xC0
079A0:  CLRF   xC1
079A2:  CLRF   xC2
079A4:  CLRF   xC3
079A6:  CLRF   xC4
079A8:  CLRF   xC5
079AA:  CLRF   xC6
079AC:  CLRF   xC7
079AE:  CLRF   xC8
079B0:  CLRF   xC9
079B2:  CLRF   xCA
079B4:  CLRF   xCB
079B6:  CLRF   xCC
079B8:  CLRF   xCD
079BA:  CLRF   xCE
079BC:  CLRF   xCF
079BE:  CLRF   xD0
079C0:  CLRF   xD1
079C2:  CLRF   xD2
079C4:  CLRF   xD3
079C6:  CLRF   xD4
079C8:  CLRF   xD5
079CA:  CLRF   xD6
079CC:  CLRF   xD7
079CE:  CLRF   xD8
079D0:  CLRF   xD9
079D2:  CLRF   xDA
079D4:  CLRF   xDB
079D6:  CLRF   xDC
079D8:  CLRF   xDD
079DA:  CLRF   xDE
079DC:  CLRF   xDF
079DE:  CLRF   xE0
079E0:  CLRF   xE1
079E2:  CLRF   xE2
079E4:  CLRF   xE3
079E6:  CLRF   xE4
079E8:  CLRF   xE5
079EA:  CLRF   xE6
079EC:  CLRF   xE7
079EE:  CLRF   xE8
079F0:  CLRF   xE9
079F2:  CLRF   xEA
079F4:  CLRF   xEB
079F6:  CLRF   xEC
079F8:  CLRF   xED
079FA:  CLRF   xEE
079FC:  CLRF   xEF
079FE:  CLRF   xF0
07A00:  CLRF   xF1
07A02:  CLRF   xF2
07A04:  CLRF   xF3
07A06:  CLRF   xF4
07A08:  CLRF   xF5
07A0A:  CLRF   xF6
07A0C:  CLRF   xF7
07A0E:  CLRF   xF8
07A10:  CLRF   xF9
07A12:  CLRF   xFA
07A14:  CLRF   xFB
07A16:  CLRF   xFC
07A18:  CLRF   xFD
07A1A:  CLRF   xFE
07A1C:  CLRF   xFF
07A1E:  MOVLB  6
07A20:  CLRF   x00
07A22:  CLRF   x01
07A24:  CLRF   x02
07A26:  CLRF   x03
07A28:  CLRF   x04
07A2A:  CLRF   x05
07A2C:  CLRF   x06
07A2E:  CLRF   x07
07A30:  CLRF   x08
07A32:  CLRF   x09
07A34:  CLRF   x0A
07A36:  CLRF   x0B
07A38:  CLRF   x0C
07A3A:  CLRF   x0D
07A3C:  CLRF   x0E
07A3E:  CLRF   x0F
07A40:  CLRF   x10
07A42:  CLRF   x11
07A44:  CLRF   x12
07A46:  CLRF   x13
07A48:  CLRF   x14
07A4A:  CLRF   x15
07A4C:  CLRF   x16
07A4E:  CLRF   x17
07A50:  CLRF   x18
07A52:  CLRF   x19
07A54:  CLRF   x1A
07A56:  CLRF   x1B
07A58:  CLRF   x1C
07A5A:  CLRF   x1D
07A5C:  CLRF   x1E
07A5E:  CLRF   x1F
07A60:  CLRF   x20
07A62:  CLRF   x21
07A64:  CLRF   x22
07A66:  CLRF   x23
07A68:  CLRF   x24
07A6A:  CLRF   x25
07A6C:  CLRF   x26
07A6E:  CLRF   x27
07A70:  CLRF   x28
07A72:  CLRF   x29
07A74:  CLRF   x2A
07A76:  CLRF   x2B
07A78:  CLRF   x2C
07A7A:  CLRF   x2D
07A7C:  CLRF   x2E
07A7E:  CLRF   x2F
07A80:  CLRF   x30
07A82:  CLRF   x31
07A84:  CLRF   x32
07A86:  CLRF   x33
07A88:  CLRF   x34
07A8A:  CLRF   x35
07A8C:  CLRF   x36
07A8E:  CLRF   x37
07A90:  CLRF   x38
07A92:  CLRF   x39
07A94:  CLRF   x3A
07A96:  CLRF   x3B
07A98:  CLRF   x3C
07A9A:  CLRF   x3D
07A9C:  CLRF   x3E
07A9E:  CLRF   x3F
07AA0:  CLRF   x40
07AA2:  CLRF   x41
07AA4:  CLRF   x42
07AA6:  CLRF   x43
07AA8:  CLRF   x44
07AAA:  CLRF   x45
07AAC:  CLRF   x46
07AAE:  CLRF   x47
07AB0:  CLRF   x48
07AB2:  CLRF   x49
07AB4:  CLRF   x4A
07AB6:  CLRF   x4B
07AB8:  CLRF   x4C
07ABA:  CLRF   x4D
07ABC:  CLRF   x4E
07ABE:  CLRF   x4F
07AC0:  CLRF   x50
07AC2:  CLRF   x51
07AC4:  CLRF   x52
07AC6:  CLRF   x53
07AC8:  CLRF   x54
07ACA:  CLRF   x55
07ACC:  CLRF   x56
07ACE:  CLRF   x57
07AD0:  CLRF   x58
07AD2:  CLRF   x59
07AD4:  CLRF   x5A
07AD6:  CLRF   x5B
07AD8:  CLRF   x5C
07ADA:  CLRF   x5D
07ADC:  CLRF   x5E
07ADE:  CLRF   x5F
07AE0:  CLRF   x60
07AE2:  CLRF   x61
07AE4:  CLRF   x62
07AE6:  CLRF   x63
07AE8:  CLRF   x64
07AEA:  CLRF   x65
07AEC:  CLRF   x66
07AEE:  CLRF   x67
07AF0:  CLRF   x68
07AF2:  CLRF   x69
07AF4:  CLRF   x6A
07AF6:  CLRF   x6B
07AF8:  CLRF   x6C
07AFA:  CLRF   x6D
07AFC:  CLRF   x6E
07AFE:  CLRF   x6F
07B00:  CLRF   x70
07B02:  CLRF   x71
07B04:  CLRF   x72
07B06:  CLRF   x73
07B08:  CLRF   x74
07B0A:  CLRF   x75
07B0C:  CLRF   x76
07B0E:  CLRF   x77
07B10:  CLRF   x78
07B12:  CLRF   x79
07B14:  CLRF   x7A
07B16:  CLRF   x7B
07B18:  CLRF   x7C
07B1A:  CLRF   x7D
07B1C:  CLRF   x7E
07B1E:  CLRF   x7F
07B20:  CLRF   x80
07B22:  CLRF   x81
07B24:  CLRF   x82
07B26:  CLRF   x83
07B28:  CLRF   x84
07B2A:  CLRF   x85
07B2C:  CLRF   x86
07B2E:  CLRF   x87
07B30:  CLRF   x88
07B32:  CLRF   x89
07B34:  CLRF   x8A
07B36:  CLRF   x8B
07B38:  CLRF   x8C
07B3A:  CLRF   x8D
07B3C:  CLRF   x8E
07B3E:  CLRF   x8F
07B40:  CLRF   x90
07B42:  CLRF   x91
07B44:  CLRF   x92
07B46:  CLRF   x93
07B48:  CLRF   x94
07B4A:  CLRF   x95
07B4C:  CLRF   x96
07B4E:  CLRF   x97
07B50:  CLRF   x98
07B52:  CLRF   x99
07B54:  CLRF   x9A
07B56:  CLRF   x9B
07B58:  CLRF   x9C
07B5A:  CLRF   x9D
07B5C:  CLRF   x9E
07B5E:  CLRF   x9F
07B60:  CLRF   xA0
07B62:  CLRF   xA1
07B64:  CLRF   xA2
07B66:  CLRF   xA3
07B68:  CLRF   xA4
07B6A:  CLRF   xA5
07B6C:  CLRF   xA6
07B6E:  CLRF   xA7
07B70:  CLRF   xA8
07B72:  CLRF   xA9
07B74:  CLRF   xAA
07B76:  CLRF   xAB
07B78:  CLRF   xAC
07B7A:  CLRF   xAD
07B7C:  CLRF   xAE
07B7E:  CLRF   xAF
07B80:  CLRF   xB0
07B82:  CLRF   xB1
07B84:  CLRF   xB2
07B86:  CLRF   xB3
07B88:  CLRF   xB4
07B8A:  CLRF   xB5
07B8C:  CLRF   xB6
07B8E:  CLRF   xB7
07B90:  CLRF   xB8
07B92:  CLRF   xB9
07B94:  CLRF   xBA
07B96:  CLRF   xBB
07B98:  CLRF   xBC
07B9A:  CLRF   xBD
07B9C:  CLRF   xBE
07B9E:  CLRF   xBF
07BA0:  CLRF   xC0
07BA2:  CLRF   xC1
07BA4:  CLRF   xC2
07BA6:  CLRF   xC3
07BA8:  CLRF   xC4
07BAA:  CLRF   xC5
07BAC:  CLRF   xC6
07BAE:  CLRF   xC7
07BB0:  CLRF   xC8
07BB2:  CLRF   xC9
07BB4:  CLRF   xCA
07BB6:  CLRF   xCB
07BB8:  CLRF   xCC
07BBA:  CLRF   xCD
07BBC:  CLRF   xCE
07BBE:  CLRF   xCF
07BC0:  CLRF   xD0
07BC2:  CLRF   xD1
07BC4:  CLRF   xD2
07BC6:  CLRF   xD3
07BC8:  CLRF   xD4
07BCA:  CLRF   xD5
07BCC:  CLRF   xD6
07BCE:  CLRF   xD7
07BD0:  CLRF   xD8
07BD2:  CLRF   xD9
07BD4:  CLRF   xDA
07BD6:  CLRF   xDB
07BD8:  CLRF   xDC
07BDA:  CLRF   xDD
07BDC:  CLRF   xDE
07BDE:  CLRF   xDF
07BE0:  CLRF   xE0
07BE2:  CLRF   xE1
07BE4:  CLRF   xE2
07BE6:  CLRF   xE3
07BE8:  CLRF   xE4
07BEA:  CLRF   xE5
07BEC:  CLRF   xE6
07BEE:  CLRF   xE7
07BF0:  CLRF   xE8
07BF2:  CLRF   xE9
07BF4:  CLRF   xEA
07BF6:  CLRF   xEB
07BF8:  CLRF   xEC
07BFA:  CLRF   xED
07BFC:  CLRF   xEE
07BFE:  CLRF   xEF
07C00:  CLRF   xF0
07C02:  CLRF   xF1
07C04:  CLRF   xF2
07C06:  CLRF   xF3
07C08:  CLRF   xF4
07C0A:  CLRF   xF5
07C0C:  CLRF   xF6
07C0E:  CLRF   xF7
07C10:  CLRF   xF8
07C12:  CLRF   xF9
07C14:  CLRF   xFA
07C16:  CLRF   xFB
07C18:  CLRF   xFC
07C1A:  CLRF   xFD
07C1C:  CLRF   xFE
07C1E:  CLRF   xFF
07C20:  MOVLB  7
07C22:  CLRF   x00
07C24:  CLRF   x01
07C26:  CLRF   x02
07C28:  CLRF   x03
07C2A:  CLRF   x04
07C2C:  CLRF   x05
07C2E:  CLRF   x06
07C30:  CLRF   x07
07C32:  CLRF   x08
07C34:  CLRF   x09
07C36:  CLRF   x0A
07C38:  CLRF   x0B
07C3A:  CLRF   x0C
07C3C:  CLRF   x0D
07C3E:  CLRF   x0E
07C40:  CLRF   x0F
07C42:  CLRF   x10
07C44:  CLRF   x11
07C46:  CLRF   x12
07C48:  CLRF   x13
07C4A:  CLRF   x14
07C4C:  CLRF   x15
07C4E:  CLRF   x16
07C50:  CLRF   x17
07C52:  CLRF   x18
07C54:  CLRF   x19
07C56:  CLRF   x1A
07C58:  CLRF   x1B
07C5A:  CLRF   x1C
07C5C:  CLRF   x1D
07C5E:  CLRF   x1E
07C60:  CLRF   x1F
07C62:  CLRF   x20
07C64:  CLRF   x21
07C66:  CLRF   x22
07C68:  CLRF   x23
07C6A:  CLRF   x24
07C6C:  CLRF   x25
07C6E:  CLRF   x26
07C70:  CLRF   x27
07C72:  CLRF   x28
07C74:  CLRF   x29
07C76:  CLRF   x2A
07C78:  CLRF   x2B
07C7A:  CLRF   x2C
07C7C:  CLRF   x2D
07C7E:  CLRF   x2E
07C80:  CLRF   x2F
07C82:  CLRF   x30
07C84:  CLRF   x31
07C86:  CLRF   x32
07C88:  CLRF   x33
07C8A:  CLRF   x34
07C8C:  CLRF   x35
07C8E:  CLRF   x36
07C90:  CLRF   x37
07C92:  CLRF   x38
07C94:  CLRF   x39
07C96:  CLRF   x3A
07C98:  CLRF   x3B
07C9A:  CLRF   x3C
07C9C:  CLRF   x3D
07C9E:  CLRF   x3E
07CA0:  CLRF   x3F
07CA2:  CLRF   x40
07CA4:  CLRF   x41
07CA6:  CLRF   x42
07CA8:  CLRF   x43
07CAA:  CLRF   x44
07CAC:  CLRF   x45
07CAE:  CLRF   x46
07CB0:  CLRF   x47
07CB2:  CLRF   x48
07CB4:  CLRF   x49
07CB6:  CLRF   x4A
07CB8:  CLRF   x4B
07CBA:  CLRF   x4C
07CBC:  CLRF   x4D
07CBE:  CLRF   x4E
07CC0:  CLRF   x4F
07CC2:  CLRF   x50
07CC4:  CLRF   x51
07CC6:  CLRF   x52
07CC8:  CLRF   x53
07CCA:  CLRF   x54
07CCC:  CLRF   x55
07CCE:  CLRF   x56
07CD0:  CLRF   x57
07CD2:  CLRF   x58
07CD4:  CLRF   x59
07CD6:  CLRF   x5A
07CD8:  CLRF   x5B
07CDA:  CLRF   x5C
07CDC:  CLRF   x5D
07CDE:  CLRF   x5E
07CE0:  CLRF   x5F
07CE2:  CLRF   x60
07CE4:  CLRF   x61
07CE6:  CLRF   x62
07CE8:  CLRF   x63
07CEA:  CLRF   x64
07CEC:  CLRF   x65
07CEE:  CLRF   x66
07CF0:  CLRF   x67
07CF2:  CLRF   x68
07CF4:  CLRF   x69
07CF6:  CLRF   x6A
07CF8:  CLRF   x6B
07CFA:  CLRF   x6C
07CFC:  CLRF   x6D
07CFE:  CLRF   x6E
07D00:  CLRF   x6F
07D02:  CLRF   x70
07D04:  CLRF   x71
07D06:  CLRF   x72
07D08:  CLRF   x73
07D0A:  CLRF   x74
07D0C:  CLRF   x75
07D0E:  CLRF   x76
07D10:  CLRF   x77
07D12:  CLRF   x78
07D14:  CLRF   x79
07D16:  CLRF   x7A
07D18:  CLRF   x7B
07D1A:  CLRF   x7C
07D1C:  CLRF   x7D
07D1E:  CLRF   x7E
07D20:  CLRF   x7F
07D22:  CLRF   x80
07D24:  CLRF   x81
07D26:  CLRF   x82
07D28:  CLRF   x83
07D2A:  CLRF   x84
07D2C:  CLRF   x85
07D2E:  CLRF   x86
07D30:  CLRF   x87
07D32:  CLRF   x88
07D34:  CLRF   x89
07D36:  CLRF   x8A
07D38:  CLRF   x8B
07D3A:  CLRF   x8C
07D3C:  CLRF   x8D
07D3E:  CLRF   x8E
07D40:  CLRF   x8F
07D42:  CLRF   x90
07D44:  CLRF   x91
07D46:  CLRF   x92
07D48:  CLRF   x93
07D4A:  CLRF   x94
07D4C:  CLRF   x95
07D4E:  CLRF   x96
07D50:  CLRF   x97
07D52:  CLRF   x98
07D54:  CLRF   x99
07D56:  CLRF   x9A
07D58:  CLRF   x9B
07D5A:  CLRF   x9C
07D5C:  CLRF   x9D
07D5E:  CLRF   x9E
07D60:  CLRF   x9F
07D62:  CLRF   xA0
07D64:  CLRF   xA1
07D66:  CLRF   xA2
07D68:  CLRF   xA3
07D6A:  CLRF   xA4
07D6C:  CLRF   xA5
07D6E:  CLRF   xA6
07D70:  CLRF   xA7
07D72:  CLRF   xA8
07D74:  CLRF   xA9
07D76:  CLRF   xAA
07D78:  CLRF   xAB
07D7A:  CLRF   xAC
07D7C:  CLRF   xAD
07D7E:  CLRF   xAE
07D80:  CLRF   xAF
07D82:  CLRF   xB0
07D84:  CLRF   xB1
07D86:  CLRF   xB2
07D88:  CLRF   xB3
07D8A:  CLRF   xB4
07D8C:  CLRF   xB5
07D8E:  CLRF   xB6
07D90:  CLRF   xB7
07D92:  CLRF   xB8
07D94:  CLRF   xB9
07D96:  CLRF   xBA
07D98:  CLRF   xBB
07D9A:  CLRF   xBC
07D9C:  CLRF   xBD
07D9E:  CLRF   xBE
07DA0:  CLRF   xBF
07DA2:  CLRF   xC0
07DA4:  CLRF   xC1
07DA6:  CLRF   xC2
07DA8:  CLRF   xC3
07DAA:  CLRF   xC4
07DAC:  CLRF   xC5
07DAE:  CLRF   xC6
07DB0:  CLRF   xC7
07DB2:  CLRF   xC8
07DB4:  CLRF   xC9
07DB6:  CLRF   xCA
07DB8:  CLRF   xCB
07DBA:  CLRF   xCC
07DBC:  CLRF   xCD
07DBE:  CLRF   xCE
07DC0:  CLRF   xCF
07DC2:  CLRF   xD0
07DC4:  CLRF   xD1
07DC6:  CLRF   xD2
07DC8:  CLRF   xD3
07DCA:  CLRF   xD4
07DCC:  CLRF   xD5
07DCE:  CLRF   xD6
07DD0:  CLRF   xD7
07DD2:  CLRF   xD8
07DD4:  CLRF   xD9
07DD6:  CLRF   xDA
07DD8:  CLRF   xDB
07DDA:  CLRF   xDC
07DDC:  CLRF   xDD
07DDE:  CLRF   xDE
07DE0:  CLRF   xDF
07DE2:  CLRF   xE0
07DE4:  CLRF   xE1
07DE6:  CLRF   xE2
07DE8:  CLRF   xE3
07DEA:  CLRF   xE4
07DEC:  CLRF   xE5
07DEE:  CLRF   xE6
07DF0:  CLRF   xE7
07DF2:  CLRF   xE8
07DF4:  CLRF   xE9
07DF6:  CLRF   xEA
07DF8:  CLRF   xEB
07DFA:  CLRF   xEC
07DFC:  CLRF   xED
07DFE:  CLRF   xEE
07E00:  CLRF   xEF
07E02:  CLRF   xF0
07E04:  CLRF   xF1
07E06:  CLRF   xF2
07E08:  CLRF   xF3
07E0A:  CLRF   xF4
07E0C:  CLRF   xF5
07E0E:  CLRF   xF6
07E10:  CLRF   xF7
07E12:  CLRF   xF8
07E14:  CLRF   xF9
07E16:  CLRF   xFA
07E18:  CLRF   xFB
07E1A:  CLRF   xFC
07E1C:  CLRF   xFD
07E1E:  CLRF   xFE
07E20:  CLRF   xFF
07E22:  MOVLB  8
07E24:  CLRF   x00
07E26:  CLRF   x01
07E28:  CLRF   x02
07E2A:  CLRF   x03
07E2C:  CLRF   x04
07E2E:  CLRF   x05
07E30:  CLRF   x06
07E32:  CLRF   x07
07E34:  CLRF   x08
07E36:  CLRF   x09
07E38:  CLRF   x0A
07E3A:  CLRF   x0B
07E3C:  CLRF   x0C
07E3E:  CLRF   x0D
07E40:  CLRF   x0E
07E42:  CLRF   x0F
07E44:  CLRF   x10
07E46:  CLRF   x11
07E48:  CLRF   x12
07E4A:  CLRF   x13
07E4C:  CLRF   x14
07E4E:  CLRF   x15
07E50:  CLRF   x16
07E52:  CLRF   x17
07E54:  CLRF   x18
07E56:  CLRF   x19
07E58:  CLRF   x1A
07E5A:  CLRF   x1B
07E5C:  CLRF   x1C
07E5E:  CLRF   x1D
07E60:  CLRF   x1E
07E62:  CLRF   x1F
07E64:  CLRF   x20
07E66:  CLRF   x21
07E68:  CLRF   x22
07E6A:  CLRF   x23
07E6C:  CLRF   x24
07E6E:  CLRF   x25
07E70:  CLRF   x26
07E72:  CLRF   x27
07E74:  CLRF   x28
07E76:  CLRF   x29
07E78:  CLRF   x2A
07E7A:  CLRF   x2B
07E7C:  CLRF   x2C
07E7E:  CLRF   x2D
07E80:  CLRF   x2E
07E82:  CLRF   x2F
07E84:  CLRF   x30
07E86:  CLRF   x31
07E88:  CLRF   x32
07E8A:  CLRF   x33
07E8C:  CLRF   x34
07E8E:  CLRF   x35
07E90:  CLRF   x36
07E92:  CLRF   x37
07E94:  CLRF   x38
07E96:  CLRF   x39
07E98:  CLRF   x3A
07E9A:  CLRF   x3B
07E9C:  CLRF   x3C
07E9E:  CLRF   x3D
07EA0:  CLRF   x3E
07EA2:  CLRF   x3F
07EA4:  CLRF   x40
07EA6:  CLRF   x41
07EA8:  CLRF   x42
07EAA:  CLRF   x43
07EAC:  CLRF   x44
07EAE:  CLRF   x45
07EB0:  CLRF   x46
07EB2:  CLRF   x47
07EB4:  CLRF   x48
07EB6:  CLRF   x49
07EB8:  CLRF   x4A
07EBA:  CLRF   x4B
07EBC:  CLRF   x4C
07EBE:  CLRF   x4D
07EC0:  CLRF   x4E
07EC2:  CLRF   x4F
07EC4:  CLRF   x50
07EC6:  CLRF   x51
07EC8:  CLRF   x52
07ECA:  CLRF   x53
07ECC:  CLRF   x54
07ECE:  CLRF   x55
07ED0:  CLRF   x56
07ED2:  CLRF   x57
07ED4:  CLRF   x58
07ED6:  CLRF   x59
07ED8:  CLRF   x5A
07EDA:  CLRF   x5B
07EDC:  CLRF   x5C
07EDE:  CLRF   x5D
07EE0:  CLRF   x5E
07EE2:  CLRF   x5F
07EE4:  CLRF   x60
07EE6:  CLRF   x61
07EE8:  CLRF   x62
07EEA:  CLRF   x63
07EEC:  CLRF   x64
07EEE:  CLRF   x65
07EF0:  CLRF   x66
07EF2:  CLRF   x67
07EF4:  CLRF   x68
07EF6:  CLRF   x69
07EF8:  CLRF   x6A
07EFA:  CLRF   x6B
07EFC:  CLRF   x6C
07EFE:  CLRF   x6D
07F00:  CLRF   x6E
07F02:  CLRF   x6F
07F04:  CLRF   x70
07F06:  CLRF   x71
07F08:  CLRF   x72
07F0A:  CLRF   x73
07F0C:  CLRF   x74
07F0E:  CLRF   x75
07F10:  CLRF   x76
07F12:  CLRF   x77
07F14:  CLRF   x78
07F16:  CLRF   x79
07F18:  CLRF   x7A
07F1A:  CLRF   x7B
07F1C:  CLRF   x7C
07F1E:  CLRF   x7D
07F20:  CLRF   x7E
07F22:  CLRF   x7F
07F24:  CLRF   x80
07F26:  CLRF   x81
07F28:  CLRF   x82
07F2A:  CLRF   x83
07F2C:  CLRF   x84
07F2E:  CLRF   x85
07F30:  CLRF   x86
07F32:  CLRF   x87
07F34:  CLRF   x88
07F36:  CLRF   x89
07F38:  CLRF   x8A
07F3A:  CLRF   x8B
07F3C:  CLRF   x8C
07F3E:  CLRF   x8D
07F40:  CLRF   x8E
07F42:  CLRF   x8F
07F44:  CLRF   x90
07F46:  CLRF   x91
07F48:  CLRF   x92
07F4A:  CLRF   x93
07F4C:  CLRF   x94
07F4E:  CLRF   x95
07F50:  CLRF   x96
07F52:  CLRF   x97
07F54:  CLRF   x98
07F56:  CLRF   x99
07F58:  CLRF   x9A
07F5A:  CLRF   x9B
07F5C:  CLRF   x9C
07F5E:  CLRF   x9D
07F60:  CLRF   x9E
07F62:  CLRF   x9F
07F64:  CLRF   xA0
07F66:  CLRF   xA1
07F68:  CLRF   xA2
07F6A:  CLRF   xA3
07F6C:  CLRF   xA4
07F6E:  CLRF   xA5
07F70:  CLRF   xA6
07F72:  CLRF   xA7
07F74:  CLRF   xA8
07F76:  CLRF   xA9
07F78:  CLRF   xAA
07F7A:  CLRF   xAB
07F7C:  CLRF   xAC
07F7E:  CLRF   xAD
07F80:  CLRF   xAE
07F82:  CLRF   xAF
07F84:  CLRF   xB0
07F86:  CLRF   xB1
07F88:  CLRF   xB2
07F8A:  CLRF   xB3
07F8C:  CLRF   xB4
07F8E:  CLRF   xB5
07F90:  CLRF   xB6
07F92:  CLRF   xB7
07F94:  CLRF   xB8
07F96:  CLRF   xB9
07F98:  CLRF   xBA
07F9A:  CLRF   xBB
07F9C:  CLRF   xBC
07F9E:  CLRF   xBD
07FA0:  CLRF   xBE
07FA2:  CLRF   xBF
07FA4:  CLRF   xC0
07FA6:  CLRF   xC1
07FA8:  CLRF   xC2
07FAA:  CLRF   xC3
07FAC:  CLRF   xC4
07FAE:  CLRF   xC5
07FB0:  CLRF   xC6
07FB2:  CLRF   xC7
07FB4:  CLRF   xC8
07FB6:  CLRF   xC9
07FB8:  CLRF   xCA
07FBA:  CLRF   xCB
07FBC:  CLRF   xCC
07FBE:  CLRF   xCD
07FC0:  CLRF   xCE
07FC2:  CLRF   xCF
07FC4:  CLRF   xD0
07FC6:  CLRF   xD1
07FC8:  CLRF   xD2
07FCA:  CLRF   xD3
07FCC:  CLRF   xD4
07FCE:  CLRF   xD5
07FD0:  CLRF   xD6
07FD2:  CLRF   xD7
07FD4:  CLRF   xD8
07FD6:  CLRF   xD9
07FD8:  CLRF   xDA
07FDA:  CLRF   xDB
07FDC:  CLRF   xDC
07FDE:  CLRF   xDD
07FE0:  CLRF   xDE
07FE2:  CLRF   xDF
07FE4:  CLRF   xE0
07FE6:  CLRF   xE1
07FE8:  CLRF   xE2
07FEA:  CLRF   xE3
07FEC:  CLRF   xE4
07FEE:  CLRF   xE5
07FF0:  CLRF   xE6
07FF2:  CLRF   xE7
07FF4:  CLRF   xE8
07FF6:  CLRF   xE9
07FF8:  CLRF   xEA
07FFA:  CLRF   xEB
07FFC:  CLRF   xEC
07FFE:  CLRF   xED
08000:  CLRF   xEE
08002:  CLRF   xEF
08004:  CLRF   xF0
08006:  CLRF   xF1
08008:  CLRF   xF2
0800A:  CLRF   xF3
0800C:  CLRF   xF4
0800E:  CLRF   xF5
08010:  CLRF   xF6
08012:  CLRF   xF7
08014:  CLRF   xF8
08016:  CLRF   xF9
08018:  CLRF   xFA
0801A:  CLRF   xFB
0801C:  CLRF   xFC
0801E:  CLRF   xFD
08020:  CLRF   xFE
08022:  CLRF   xFF
08024:  MOVLB  9
08026:  CLRF   x00
08028:  CLRF   x01
0802A:  CLRF   x02
0802C:  CLRF   x03
0802E:  CLRF   x04
08030:  CLRF   x05
08032:  CLRF   x06
08034:  CLRF   x07
08036:  CLRF   x08
08038:  CLRF   x09
0803A:  CLRF   x0A
0803C:  CLRF   x0B
0803E:  CLRF   x0C
08040:  CLRF   x0D
08042:  CLRF   x0E
08044:  CLRF   x0F
08046:  CLRF   x10
08048:  CLRF   x11
0804A:  CLRF   x12
0804C:  CLRF   x13
0804E:  CLRF   x14
08050:  CLRF   x15
08052:  CLRF   x16
08054:  CLRF   x17
08056:  CLRF   x18
08058:  CLRF   x19
0805A:  CLRF   x1A
0805C:  CLRF   x1B
0805E:  CLRF   x1C
08060:  CLRF   x1D
08062:  CLRF   x1E
08064:  CLRF   x1F
08066:  CLRF   x20
08068:  CLRF   x21
0806A:  CLRF   x22
0806C:  CLRF   x23
0806E:  CLRF   x24
08070:  CLRF   x25
08072:  CLRF   x26
08074:  CLRF   x27
08076:  CLRF   x28
08078:  CLRF   x29
0807A:  CLRF   x2A
0807C:  CLRF   x2B
0807E:  CLRF   x2C
08080:  CLRF   x2D
08082:  CLRF   x2E
08084:  CLRF   x2F
08086:  CLRF   x30
08088:  CLRF   x31
0808A:  CLRF   x32
0808C:  CLRF   x33
0808E:  CLRF   x34
08090:  CLRF   x35
08092:  CLRF   x36
08094:  CLRF   x37
08096:  CLRF   x38
08098:  CLRF   x39
0809A:  CLRF   x3A
0809C:  CLRF   x3B
0809E:  CLRF   x3C
080A0:  CLRF   x3D
080A2:  CLRF   x3E
080A4:  CLRF   x3F
080A6:  CLRF   x40
080A8:  CLRF   x41
080AA:  CLRF   x42
080AC:  CLRF   x43
080AE:  CLRF   x44
080B0:  CLRF   x45
080B2:  CLRF   x46
080B4:  CLRF   x47
080B6:  CLRF   x48
080B8:  CLRF   x49
080BA:  CLRF   x4A
080BC:  CLRF   x4B
080BE:  CLRF   x4C
080C0:  CLRF   x4D
080C2:  CLRF   x4E
080C4:  CLRF   x4F
080C6:  CLRF   x50
080C8:  CLRF   x51
080CA:  CLRF   x52
080CC:  CLRF   x53
080CE:  CLRF   x54
080D0:  CLRF   x55
080D2:  CLRF   x56
080D4:  CLRF   x57
080D6:  CLRF   x58
080D8:  CLRF   x59
080DA:  CLRF   x5A
080DC:  CLRF   x5B
080DE:  CLRF   x5C
080E0:  CLRF   x5D
080E2:  CLRF   x5E
080E4:  CLRF   x5F
080E6:  CLRF   x60
080E8:  CLRF   x61
080EA:  CLRF   x62
080EC:  CLRF   x63
080EE:  CLRF   x64
080F0:  CLRF   x65
080F2:  CLRF   x66
080F4:  CLRF   x67
080F6:  CLRF   x68
080F8:  CLRF   x69
080FA:  CLRF   x6A
080FC:  CLRF   x6B
080FE:  CLRF   x6C
08100:  CLRF   x6D
08102:  CLRF   x6E
08104:  CLRF   x6F
08106:  CLRF   x70
08108:  CLRF   x71
0810A:  CLRF   x72
0810C:  CLRF   x73
0810E:  CLRF   x74
08110:  CLRF   x75
08112:  CLRF   x76
08114:  CLRF   x77
08116:  CLRF   x78
08118:  CLRF   x79
0811A:  CLRF   x7A
0811C:  CLRF   x7B
0811E:  CLRF   x7C
08120:  CLRF   x7D
08122:  CLRF   x7E
08124:  CLRF   x7F
08126:  CLRF   x80
08128:  CLRF   x81
0812A:  CLRF   x82
0812C:  CLRF   x83
0812E:  CLRF   x84
08130:  CLRF   x85
08132:  CLRF   x86
08134:  CLRF   x87
08136:  CLRF   x88
08138:  CLRF   x89
0813A:  CLRF   x8A
0813C:  CLRF   x8B
0813E:  CLRF   x8C
08140:  CLRF   x8D
08142:  CLRF   x8E
08144:  CLRF   x8F
08146:  CLRF   x90
08148:  CLRF   x91
0814A:  CLRF   x92
0814C:  CLRF   x93
0814E:  CLRF   x94
08150:  CLRF   x95
08152:  CLRF   x96
08154:  CLRF   x97
08156:  CLRF   x98
08158:  CLRF   x99
0815A:  CLRF   x9A
0815C:  CLRF   x9B
0815E:  CLRF   x9C
08160:  CLRF   x9D
08162:  CLRF   x9E
08164:  CLRF   x9F
08166:  CLRF   xA0
08168:  CLRF   xA1
0816A:  CLRF   xA2
0816C:  CLRF   xA3
0816E:  CLRF   xA4
08170:  CLRF   xA5
08172:  CLRF   xA6
08174:  CLRF   xA7
08176:  CLRF   xA8
08178:  CLRF   xA9
0817A:  CLRF   xAA
0817C:  CLRF   xAB
0817E:  CLRF   xAC
08180:  CLRF   xAD
08182:  CLRF   xAE
08184:  CLRF   xAF
08186:  CLRF   xB0
....................     port2.port_num = 2;
08188:  MOVLW  02
0818A:  MOVLB  5
0818C:  MOVWF  xB1
....................     port2.sweep_step = 0;
0818E:  CLRF   xB3
08190:  CLRF   xB2
....................     port2.active = 1;
08192:  MOVLB  9
08194:  BSF    xB0.0
.................... 
....................     int16 count = 1;
08196:  CLRF   xB2
08198:  MOVLW  01
0819A:  MOVWF  xB1
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
0819C:  CLRF   xC3
0819E:  MOVLW  01
081A0:  MOVWF  xC2
081A2:  MOVLB  0
081A4:  CALL   210C
....................     mcp4901_2_write(1);
081A8:  MOVLB  9
081AA:  CLRF   xC3
081AC:  MOVLW  01
081AE:  MOVWF  xC2
081B0:  MOVLB  0
081B2:  CALL   214E
....................     ad7490_read(ADC_CIGS1_CURR);
081B6:  MOVLW  01
081B8:  MOVLB  9
081BA:  MOVWF  xD7
081BC:  MOVLB  0
081BE:  CALL   1DAE
....................     ad7490_read(ADC_CIGS1_CURR);
081C2:  MOVLW  01
081C4:  MOVLB  9
081C6:  MOVWF  xD7
081C8:  MOVLB  0
081CA:  CALL   1DAE
....................     ad7490_read(ADC_CIGS2_CURR);
081CE:  MOVLW  05
081D0:  MOVLB  9
081D2:  MOVWF  xD7
081D4:  MOVLB  0
081D6:  CALL   1DAE
....................     ad7490_read(ADC_CIGS2_CURR);
081DA:  MOVLW  05
081DC:  MOVLB  9
081DE:  MOVWF  xD7
081E0:  MOVLB  0
081E2:  CALL   1DAE
....................     delay_ms(200);
081E6:  MOVLW  C8
081E8:  MOVLB  A
081EA:  MOVWF  x6E
081EC:  MOVLB  0
081EE:  CALL   1B3E
.................... 
....................     // Read initial PD value
....................     MEASUREMENT_DATA measured_data = create_meas_data();
081F2:  GOTO   653C
081F6:  MOVFF  02,03
081FA:  MOVF   01,W
081FC:  MOVWF  FE1
081FE:  MOVFF  03,FE2
08202:  MOVLW  09
08204:  MOVWF  FEA
08206:  MOVLW  B3
08208:  MOVWF  FE9
0820A:  MOVLW  0F
0820C:  MOVWF  01
0820E:  MOVFF  FE6,FEE
08212:  DECFSZ 01,F
08214:  GOTO   820E
....................     // Continue measurement while at least one port is active
....................     while (port1.active || port2.active)
08218:  MOVLB  5
0821A:  BTFSS  xB0.0
0821C:  BRA    8224
0821E:  MOVLB  0
08220:  GOTO   8234
08224:  MOVLB  0
08226:  MOVLB  9
08228:  BTFSC  xB0.0
0822A:  BRA    8232
0822C:  MOVLB  0
0822E:  GOTO   86DC
08232:  MOVLB  0
....................     {
....................         // Set DAC values for both ports (synchronized timing)
....................         mcp4901_1_write(count);
08234:  MOVFF  9B2,9C3
08238:  MOVFF  9B1,9C2
0823C:  CALL   210C
....................         mcp4901_2_write(count);
08240:  MOVFF  9B2,9C3
08244:  MOVFF  9B1,9C2
08248:  CALL   214E
....................         delay_ms(1); // wait for DAC to stabilize
0824C:  MOVLW  01
0824E:  MOVLB  A
08250:  MOVWF  x6E
08252:  MOVLB  0
08254:  CALL   1B3E
.................... 
....................         // Read CIGS1 data (port1) only if still active
....................         if (port1.active) {
08258:  MOVLB  5
0825A:  BTFSC  xB0.0
0825C:  BRA    8264
0825E:  MOVLB  0
08260:  GOTO   8364
08264:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
08266:  BCF    FD8.0
08268:  MOVLB  9
0826A:  RLCF   xB1,W
0826C:  MOVWF  02
0826E:  RLCF   xB2,W
08270:  MOVWF  03
08272:  MOVF   02,W
08274:  ADDLW  B4
08276:  MOVWF  01
08278:  MOVLW  01
0827A:  ADDWFC 03,F
0827C:  MOVF   01,W
0827E:  MOVWF  xC2
08280:  MOVFF  03,9C3
08284:  MOVLW  02
08286:  MOVWF  xD7
08288:  MOVLB  0
0828A:  CALL   1DAE
0828E:  MOVFF  9C3,FEA
08292:  MOVFF  9C2,FE9
08296:  MOVFF  02,FEC
0829A:  MOVF   FED,F
0829C:  MOVFF  01,FEF
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
082A0:  BCF    FD8.0
082A2:  MOVLB  9
082A4:  RLCF   xB1,W
082A6:  MOVWF  02
082A8:  RLCF   xB2,W
082AA:  MOVWF  03
082AC:  MOVF   02,W
082AE:  ADDLW  B4
082B0:  MOVWF  01
082B2:  MOVLW  01
082B4:  ADDWFC 03,F
082B6:  MOVF   01,W
082B8:  MOVWF  xC2
082BA:  MOVFF  03,9C3
082BE:  MOVLW  02
082C0:  MOVWF  xD7
082C2:  MOVLB  0
082C4:  CALL   1DAE
082C8:  MOVFF  9C3,FEA
082CC:  MOVFF  9C2,FE9
082D0:  MOVFF  02,FEC
082D4:  MOVF   FED,F
082D6:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
082DA:  BCF    FD8.0
082DC:  MOVLB  9
082DE:  RLCF   xB1,W
082E0:  MOVWF  02
082E2:  RLCF   xB2,W
082E4:  MOVWF  03
082E6:  MOVF   02,W
082E8:  ADDLW  B2
082EA:  MOVWF  01
082EC:  MOVLW  03
082EE:  ADDWFC 03,F
082F0:  MOVF   01,W
082F2:  MOVWF  xC2
082F4:  MOVFF  03,9C3
082F8:  MOVLW  01
082FA:  MOVWF  xD7
082FC:  MOVLB  0
082FE:  CALL   1DAE
08302:  MOVFF  9C3,FEA
08306:  MOVFF  9C2,FE9
0830A:  MOVFF  02,FEC
0830E:  MOVF   FED,F
08310:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
08314:  BCF    FD8.0
08316:  MOVLB  9
08318:  RLCF   xB1,W
0831A:  MOVWF  02
0831C:  RLCF   xB2,W
0831E:  MOVWF  03
08320:  MOVF   02,W
08322:  ADDLW  B2
08324:  MOVWF  01
08326:  MOVLW  03
08328:  ADDWFC 03,F
0832A:  MOVF   01,W
0832C:  MOVWF  xC2
0832E:  MOVFF  03,9C3
08332:  MOVLW  01
08334:  MOVWF  xD7
08336:  MOVLB  0
08338:  CALL   1DAE
0833C:  MOVFF  9C3,FEA
08340:  MOVFF  9C2,FE9
08344:  MOVFF  02,FEC
08348:  MOVF   FED,F
0834A:  MOVFF  01,FEF
....................             // fprintf(PC, "CIGS1 data: %04LD, %04LD\r\n", port1.data_buffer[0][count], port1.data_buffer[1][count]);
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
0834E:  MOVLW  01
08350:  MOVLB  9
08352:  ADDWF  xB1,W
08354:  MOVLB  1
08356:  MOVWF  xB2
08358:  MOVLW  00
0835A:  MOVLB  9
0835C:  ADDWFC xB2,W
0835E:  MOVLB  1
08360:  MOVWF  xB3
08362:  MOVLB  0
....................         }
....................         
....................         // Read CIGS2 data (port2) only if still active
....................         if (port2.active) {
08364:  MOVLB  9
08366:  BTFSC  xB0.0
08368:  BRA    8370
0836A:  MOVLB  0
0836C:  GOTO   8470
08370:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
08372:  BCF    FD8.0
08374:  MOVLB  9
08376:  RLCF   xB1,W
08378:  MOVWF  02
0837A:  RLCF   xB2,W
0837C:  MOVWF  03
0837E:  MOVF   02,W
08380:  ADDLW  B4
08382:  MOVWF  01
08384:  MOVLW  05
08386:  ADDWFC 03,F
08388:  MOVF   01,W
0838A:  MOVWF  xC2
0838C:  MOVFF  03,9C3
08390:  MOVLW  06
08392:  MOVWF  xD7
08394:  MOVLB  0
08396:  CALL   1DAE
0839A:  MOVFF  9C3,FEA
0839E:  MOVFF  9C2,FE9
083A2:  MOVFF  02,FEC
083A6:  MOVF   FED,F
083A8:  MOVFF  01,FEF
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
083AC:  BCF    FD8.0
083AE:  MOVLB  9
083B0:  RLCF   xB1,W
083B2:  MOVWF  02
083B4:  RLCF   xB2,W
083B6:  MOVWF  03
083B8:  MOVF   02,W
083BA:  ADDLW  B4
083BC:  MOVWF  01
083BE:  MOVLW  05
083C0:  ADDWFC 03,F
083C2:  MOVF   01,W
083C4:  MOVWF  xC2
083C6:  MOVFF  03,9C3
083CA:  MOVLW  06
083CC:  MOVWF  xD7
083CE:  MOVLB  0
083D0:  CALL   1DAE
083D4:  MOVFF  9C3,FEA
083D8:  MOVFF  9C2,FE9
083DC:  MOVFF  02,FEC
083E0:  MOVF   FED,F
083E2:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
083E6:  BCF    FD8.0
083E8:  MOVLB  9
083EA:  RLCF   xB1,W
083EC:  MOVWF  02
083EE:  RLCF   xB2,W
083F0:  MOVWF  03
083F2:  MOVF   02,W
083F4:  ADDLW  B2
083F6:  MOVWF  01
083F8:  MOVLW  07
083FA:  ADDWFC 03,F
083FC:  MOVF   01,W
083FE:  MOVWF  xC2
08400:  MOVFF  03,9C3
08404:  MOVLW  05
08406:  MOVWF  xD7
08408:  MOVLB  0
0840A:  CALL   1DAE
0840E:  MOVFF  9C3,FEA
08412:  MOVFF  9C2,FE9
08416:  MOVFF  02,FEC
0841A:  MOVF   FED,F
0841C:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
08420:  BCF    FD8.0
08422:  MOVLB  9
08424:  RLCF   xB1,W
08426:  MOVWF  02
08428:  RLCF   xB2,W
0842A:  MOVWF  03
0842C:  MOVF   02,W
0842E:  ADDLW  B2
08430:  MOVWF  01
08432:  MOVLW  07
08434:  ADDWFC 03,F
08436:  MOVF   01,W
08438:  MOVWF  xC2
0843A:  MOVFF  03,9C3
0843E:  MOVLW  05
08440:  MOVWF  xD7
08442:  MOVLB  0
08444:  CALL   1DAE
08448:  MOVFF  9C3,FEA
0844C:  MOVFF  9C2,FE9
08450:  MOVFF  02,FEC
08454:  MOVF   FED,F
08456:  MOVFF  01,FEF
....................             // fprintf(PC, "CIGS2 data: %04LD, %04LD\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
0845A:  MOVLW  01
0845C:  MOVLB  9
0845E:  ADDWF  xB1,W
08460:  MOVLB  5
08462:  MOVWF  xB2
08464:  MOVLW  00
08466:  MOVLB  9
08468:  ADDWFC xB2,W
0846A:  MOVLB  5
0846C:  MOVWF  xB3
0846E:  MOVLB  0
....................         }
.................... 
....................         count++;
08470:  MOVLB  9
08472:  INCF   xB1,F
08474:  BTFSC  FD8.2
08476:  INCF   xB2,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
08478:  MOVF   xB2,F
0847A:  BTFSC  FD8.2
0847C:  BRA    8484
0847E:  MOVLB  0
08480:  GOTO   8498
08484:  MOVLB  0
08486:  MOVLB  9
08488:  MOVF   xB1,W
0848A:  SUBLW  FE
0848C:  BTFSS  FD8.0
0848E:  BRA    8496
08490:  MOVLB  0
08492:  GOTO   84DC
08496:  MOVLB  0
....................             fprintf(PC, "Maximum step count reached: %ld\r\n", count);
08498:  MOVLW  44
0849A:  MOVWF  FF6
0849C:  MOVLW  06
0849E:  MOVWF  FF7
084A0:  MOVLW  00
084A2:  MOVWF  FF8
084A4:  MOVLW  1C
084A6:  MOVLB  9
084A8:  MOVWF  xC2
084AA:  MOVLB  0
084AC:  CALL   1BEE
084B0:  MOVLW  10
084B2:  MOVWF  FE9
084B4:  MOVFF  9B2,9C3
084B8:  MOVFF  9B1,9C2
084BC:  GOTO   65C6
084C0:  MOVLW  0D
084C2:  MOVLB  A
084C4:  MOVWF  xAD
084C6:  MOVLB  0
084C8:  CALL   1B6C
084CC:  MOVLW  0A
084CE:  MOVLB  A
084D0:  MOVWF  xAD
084D2:  MOVLB  0
084D4:  CALL   1B6C
....................             break;
084D8:  GOTO   86DC
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
084DC:  MOVLB  5
084DE:  BTFSC  xB0.0
084E0:  BRA    84E8
084E2:  MOVLB  0
084E4:  GOTO   85DA
084E8:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
084EA:  MOVLW  01
084EC:  MOVLB  9
084EE:  SUBWF  xB1,W
084F0:  MOVWF  xC2
084F2:  MOVLW  00
084F4:  SUBWFB xB2,W
084F6:  MOVWF  xC3
084F8:  BCF    FD8.0
084FA:  RLCF   xC2,W
084FC:  MOVWF  02
084FE:  RLCF   xC3,W
08500:  MOVWF  03
08502:  MOVF   02,W
08504:  ADDLW  B2
08506:  MOVWF  FE9
08508:  MOVLW  03
0850A:  ADDWFC 03,W
0850C:  MOVWF  FEA
0850E:  MOVFF  FEC,9C3
08512:  MOVF   FED,F
08514:  MOVFF  FEF,9C2
08518:  MOVF   xC3,W
0851A:  MOVLB  1
0851C:  SUBWF  xB0,W
0851E:  BTFSC  FD8.0
08520:  BRA    8528
08522:  MOVLB  0
08524:  GOTO   8564
08528:  MOVLB  0
0852A:  BTFSS  FD8.2
0852C:  GOTO   8544
08530:  MOVLB  1
08532:  MOVF   xAF,W
08534:  MOVLB  9
08536:  SUBWF  xC2,W
08538:  BTFSS  FD8.0
0853A:  BRA    8542
0853C:  MOVLB  0
0853E:  GOTO   8564
08542:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current limit reached:");
08544:  MOVLW  66
08546:  MOVWF  FF6
08548:  MOVLW  06
0854A:  MOVWF  FF7
0854C:  MOVLW  00
0854E:  MOVWF  FF8
08550:  CALL   1BBE
....................                 port1.active = 0;
08554:  MOVLB  5
08556:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
08558:  MOVLW  5E
0855A:  MOVWF  F94
0855C:  BCF    F8B.0
0855E:  MOVLB  0
....................             }
08560:  GOTO   85DA
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
08564:  MOVLW  01
08566:  MOVLB  9
08568:  SUBWF  xB1,W
0856A:  MOVWF  xC2
0856C:  MOVLW  00
0856E:  SUBWFB xB2,W
08570:  MOVWF  xC3
08572:  BCF    FD8.0
08574:  RLCF   xC2,W
08576:  MOVWF  02
08578:  RLCF   xC3,W
0857A:  MOVWF  03
0857C:  MOVF   02,W
0857E:  ADDLW  B2
08580:  MOVWF  FE9
08582:  MOVLW  03
08584:  ADDWFC 03,W
08586:  MOVWF  FEA
08588:  MOVFF  FEC,9C3
0858C:  MOVF   FED,F
0858E:  MOVFF  FEF,9C2
08592:  MOVF   xC3,W
08594:  MOVLB  1
08596:  SUBWF  xAC,W
08598:  BTFSC  FD8.0
0859A:  BRA    85A2
0859C:  MOVLB  0
0859E:  GOTO   85DA
085A2:  MOVLB  0
085A4:  BTFSS  FD8.2
085A6:  GOTO   85BE
085AA:  MOVLB  1
085AC:  MOVF   xAB,W
085AE:  MOVLB  9
085B0:  SUBWF  xC2,W
085B2:  BTFSS  FD8.0
085B4:  BRA    85BC
085B6:  MOVLB  0
085B8:  GOTO   85DA
085BC:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current below threshold");
085BE:  MOVLW  84
085C0:  MOVWF  FF6
085C2:  MOVLW  06
085C4:  MOVWF  FF7
085C6:  MOVLW  00
085C8:  MOVWF  FF8
085CA:  CALL   1BBE
....................                 port1.active = 0;
085CE:  MOVLB  5
085D0:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
085D2:  MOVLW  5E
085D4:  MOVWF  F94
085D6:  BCF    F8B.0
085D8:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
085DA:  MOVLB  9
085DC:  BTFSC  xB0.0
085DE:  BRA    85E6
085E0:  MOVLB  0
085E2:  GOTO   86D8
085E6:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
085E8:  MOVLW  01
085EA:  MOVLB  9
085EC:  SUBWF  xB1,W
085EE:  MOVWF  xC2
085F0:  MOVLW  00
085F2:  SUBWFB xB2,W
085F4:  MOVWF  xC3
085F6:  BCF    FD8.0
085F8:  RLCF   xC2,W
085FA:  MOVWF  02
085FC:  RLCF   xC3,W
085FE:  MOVWF  03
08600:  MOVF   02,W
08602:  ADDLW  B2
08604:  MOVWF  FE9
08606:  MOVLW  07
08608:  ADDWFC 03,W
0860A:  MOVWF  FEA
0860C:  MOVFF  FEC,9C3
08610:  MOVF   FED,F
08612:  MOVFF  FEF,9C2
08616:  MOVF   xC3,W
08618:  MOVLB  1
0861A:  SUBWF  xB0,W
0861C:  BTFSC  FD8.0
0861E:  BRA    8626
08620:  MOVLB  0
08622:  GOTO   8662
08626:  MOVLB  0
08628:  BTFSS  FD8.2
0862A:  GOTO   8642
0862E:  MOVLB  1
08630:  MOVF   xAF,W
08632:  MOVLB  9
08634:  SUBWF  xC2,W
08636:  BTFSS  FD8.0
08638:  BRA    8640
0863A:  MOVLB  0
0863C:  GOTO   8662
08640:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current limit reached: ");
08642:  MOVLW  A2
08644:  MOVWF  FF6
08646:  MOVLW  06
08648:  MOVWF  FF7
0864A:  MOVLW  00
0864C:  MOVWF  FF8
0864E:  CALL   1BBE
....................                 port2.active = 0;
08652:  MOVLB  9
08654:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08656:  MOVLW  5E
08658:  MOVWF  F94
0865A:  BCF    F8B.5
0865C:  MOVLB  0
....................             }
0865E:  GOTO   86D8
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
08662:  MOVLW  01
08664:  MOVLB  9
08666:  SUBWF  xB1,W
08668:  MOVWF  xC2
0866A:  MOVLW  00
0866C:  SUBWFB xB2,W
0866E:  MOVWF  xC3
08670:  BCF    FD8.0
08672:  RLCF   xC2,W
08674:  MOVWF  02
08676:  RLCF   xC3,W
08678:  MOVWF  03
0867A:  MOVF   02,W
0867C:  ADDLW  B2
0867E:  MOVWF  FE9
08680:  MOVLW  07
08682:  ADDWFC 03,W
08684:  MOVWF  FEA
08686:  MOVFF  FEC,9C3
0868A:  MOVF   FED,F
0868C:  MOVFF  FEF,9C2
08690:  MOVF   xC3,W
08692:  MOVLB  1
08694:  SUBWF  xAC,W
08696:  BTFSC  FD8.0
08698:  BRA    86A0
0869A:  MOVLB  0
0869C:  GOTO   86D8
086A0:  MOVLB  0
086A2:  BTFSS  FD8.2
086A4:  GOTO   86BC
086A8:  MOVLB  1
086AA:  MOVF   xAB,W
086AC:  MOVLB  9
086AE:  SUBWF  xC2,W
086B0:  BTFSS  FD8.0
086B2:  BRA    86BA
086B4:  MOVLB  0
086B6:  GOTO   86D8
086BA:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current below threshold:");
086BC:  MOVLW  C0
086BE:  MOVWF  FF6
086C0:  MOVLW  06
086C2:  MOVWF  FF7
086C4:  MOVLW  00
086C6:  MOVWF  FF8
086C8:  CALL   1BBE
....................                 port2.active = 0;
086CC:  MOVLB  9
086CE:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
086D0:  MOVLW  5E
086D2:  MOVWF  F94
086D4:  BCF    F8B.5
086D6:  MOVLB  0
....................             }
....................         }
086D8:  GOTO   8218
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
086DC:  MOVLW  5E
086DE:  MOVWF  F94
086E0:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
086E2:  MOVLW  5E
086E4:  MOVWF  F94
086E6:  BCF    F8B.5
....................     // output_high(EN_NPWR);
.................... 
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
086E8:  MOVLW  09
086EA:  MOVLB  9
086EC:  MOVWF  xC3
086EE:  MOVLW  B3
086F0:  MOVWF  xC2
086F2:  MOVLW  01
086F4:  MOVWF  xC5
086F6:  MOVLW  B1
086F8:  MOVWF  xC4
086FA:  MOVLB  0
086FC:  CALL   6B20
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
08700:  MOVLW  09
08702:  MOVLB  9
08704:  MOVWF  xC3
08706:  MOVLW  B3
08708:  MOVWF  xC2
0870A:  MOVLW  05
0870C:  MOVWF  xC5
0870E:  MOVLW  B1
08710:  MOVWF  xC4
08712:  MOVLB  0
08714:  CALL   6B20
.................... 
....................     fprintf(PC, "End SWEEP with threshold\r\n");
08718:  MOVLW  E0
0871A:  MOVWF  FF6
0871C:  MOVLW  06
0871E:  MOVWF  FF7
08720:  MOVLW  00
08722:  MOVWF  FF8
08724:  CALL   1BBE
08728:  GOTO   8CCE (RETURN)
.................... }
.................... 
.................... 
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data)
*
06BA4:  CLRF   x06
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
*
06B20:  MOVLB  9
06B22:  CLRF   xC6
06B24:  CLRF   xC7
06B26:  CLRF   xC8
06B28:  CLRF   xC9
06B2A:  CLRF   xCA
06B2C:  CLRF   xCB
06B2E:  CLRF   xCC
06B30:  CLRF   xCD
06B32:  CLRF   xCE
06B34:  CLRF   xCF
06B36:  CLRF   xD0
06B38:  CLRF   xD1
06B3A:  CLRF   xD2
06B3C:  CLRF   xD3
06B3E:  CLRF   xD4
06B40:  CLRF   xD5
06B42:  CLRF   xD6
06B44:  CLRF   xD7
06B46:  CLRF   xD8
06B48:  CLRF   xD9
06B4A:  CLRF   xDA
06B4C:  CLRF   xDB
06B4E:  CLRF   xDC
06B50:  CLRF   xDD
06B52:  CLRF   xDE
06B54:  CLRF   xDF
06B56:  CLRF   xE0
06B58:  CLRF   xE1
06B5A:  CLRF   xE2
06B5C:  CLRF   xE3
06B5E:  CLRF   xE4
06B60:  CLRF   xE5
06B62:  CLRF   xE6
06B64:  CLRF   xE7
06B66:  CLRF   xE8
06B68:  CLRF   xE9
06B6A:  CLRF   xEA
06B6C:  CLRF   xEB
06B6E:  CLRF   xEC
06B70:  CLRF   xED
06B72:  CLRF   xEE
06B74:  CLRF   xEF
06B76:  CLRF   xF0
06B78:  CLRF   xF1
06B7A:  CLRF   xF2
06B7C:  CLRF   xF3
06B7E:  CLRF   xF4
06B80:  CLRF   xF5
06B82:  CLRF   xF6
06B84:  CLRF   xF7
06B86:  CLRF   xF8
06B88:  CLRF   xF9
06B8A:  CLRF   xFA
06B8C:  CLRF   xFB
06B8E:  CLRF   xFC
06B90:  CLRF   xFD
06B92:  CLRF   xFE
06B94:  CLRF   xFF
06B96:  MOVLB  A
06B98:  CLRF   x00
06B9A:  CLRF   x01
06B9C:  CLRF   x02
06B9E:  CLRF   x03
06BA0:  CLRF   x04
06BA2:  CLRF   x05
....................     unsigned int8 packetdata_index = 0; // Index for packet data
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
06BA6:  MOVLB  9
06BA8:  SETF   xC6
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data->port_num & 0x0F);
06BAA:  MOVF   xC4,W
06BAC:  MOVWF  FE9
06BAE:  MOVF   xC5,W
06BB0:  MOVWF  FEA
06BB2:  MOVF   FEF,W
06BB4:  ANDLW  0F
06BB6:  IORLW  F0
06BB8:  MOVWF  xC7
....................     packetdata[2] = measured_data->time_sec >> 24 & 0xFF;
06BBA:  MOVF   xC2,W
06BBC:  MOVWF  FE9
06BBE:  MOVF   xC3,W
06BC0:  MOVWF  FEA
06BC2:  MOVFF  FEF,A16
06BC6:  MOVFF  FEC,A17
06BCA:  MOVFF  FEC,A18
06BCE:  MOVFF  FEC,A19
06BD2:  MOVF   FED,F
06BD4:  MOVF   FED,F
06BD6:  MOVF   FED,F
06BD8:  MOVFF  A19,A16
06BDC:  MOVLB  A
06BDE:  CLRF   x17
06BE0:  CLRF   x18
06BE2:  CLRF   x19
06BE4:  MOVF   x16,W
06BE6:  MOVLB  9
06BE8:  MOVWF  xC8
....................     packetdata[3] = measured_data->time_sec >> 16 & 0xFF;
06BEA:  MOVF   xC2,W
06BEC:  MOVWF  FE9
06BEE:  MOVF   xC3,W
06BF0:  MOVWF  FEA
06BF2:  MOVFF  FEF,A16
06BF6:  MOVFF  FEC,A17
06BFA:  MOVFF  FEC,A18
06BFE:  MOVFF  FEC,A19
06C02:  MOVF   FED,F
06C04:  MOVF   FED,F
06C06:  MOVF   FED,F
06C08:  MOVFF  A18,A16
06C0C:  MOVFF  A19,A17
06C10:  MOVLB  A
06C12:  CLRF   x18
06C14:  CLRF   x19
06C16:  MOVF   x16,W
06C18:  MOVLB  9
06C1A:  MOVWF  xC9
....................     packetdata[4] = measured_data->time_sec >> 8 & 0xFF;
06C1C:  MOVF   xC2,W
06C1E:  MOVWF  FE9
06C20:  MOVF   xC3,W
06C22:  MOVWF  FEA
06C24:  MOVFF  FEF,A16
06C28:  MOVFF  FEC,A17
06C2C:  MOVFF  FEC,A18
06C30:  MOVFF  FEC,A19
06C34:  MOVF   FED,F
06C36:  MOVF   FED,F
06C38:  MOVF   FED,F
06C3A:  MOVFF  A17,A16
06C3E:  MOVFF  A18,A17
06C42:  MOVFF  A19,A18
06C46:  MOVLB  A
06C48:  CLRF   x19
06C4A:  MOVF   x16,W
06C4C:  MOVLB  9
06C4E:  MOVWF  xCA
....................     packetdata[5] = measured_data->time_sec & 0xFF;
06C50:  MOVF   xC2,W
06C52:  MOVWF  FE9
06C54:  MOVF   xC3,W
06C56:  MOVWF  FEA
06C58:  MOVFF  FEF,A16
06C5C:  MOVFF  FEC,A17
06C60:  MOVFF  FEC,A18
06C64:  MOVFF  FEC,A19
06C68:  MOVF   FED,F
06C6A:  MOVF   FED,F
06C6C:  MOVF   FED,F
06C6E:  MOVLB  A
06C70:  MOVF   x16,W
06C72:  MOVLB  9
06C74:  MOVWF  xCB
....................     packetdata[6] = (measured_data->time_msec & 0x0F) >>4 | measured_data->pd >> 8 & 0x0F;
06C76:  MOVLW  04
06C78:  ADDWF  xC2,W
06C7A:  MOVWF  FE9
06C7C:  MOVLW  00
06C7E:  ADDWFC xC3,W
06C80:  MOVWF  FEA
06C82:  MOVF   FEF,W
06C84:  ANDLW  0F
06C86:  MOVWF  00
06C88:  SWAPF  00,W
06C8A:  MOVLB  A
06C8C:  MOVWF  x16
06C8E:  MOVLW  0F
06C90:  ANDWF  x16,F
06C92:  MOVLW  0D
06C94:  MOVLB  9
06C96:  ADDWF  xC2,W
06C98:  MOVWF  FE9
06C9A:  MOVLW  00
06C9C:  ADDWFC xC3,W
06C9E:  MOVWF  FEA
06CA0:  MOVFF  FEC,A18
06CA4:  MOVF   FED,F
06CA6:  MOVFF  FEF,A17
06CAA:  MOVFF  A18,A17
06CAE:  MOVLB  A
06CB0:  CLRF   x18
06CB2:  MOVF   x17,W
06CB4:  ANDLW  0F
06CB6:  MOVWF  00
06CB8:  CLRF   03
06CBA:  MOVF   00,W
06CBC:  IORWF  x16,W
06CBE:  MOVLB  9
06CC0:  MOVWF  xCC
....................     packetdata[7] = measured_data->pd & 0xFF;
06CC2:  MOVLW  0D
06CC4:  ADDWF  xC2,W
06CC6:  MOVWF  FE9
06CC8:  MOVLW  00
06CCA:  ADDWFC xC3,W
06CCC:  MOVWF  FEA
06CCE:  MOVFF  FEC,A17
06CD2:  MOVF   FED,F
06CD4:  MOVFF  FEF,A16
06CD8:  MOVLB  A
06CDA:  MOVF   x16,W
06CDC:  MOVLB  9
06CDE:  MOVWF  xCD
....................     packetdata[8] = (measured_data->open_voltage >> 4) & 0xFF; // PD start low byte
06CE0:  MOVLW  05
06CE2:  ADDWF  xC2,W
06CE4:  MOVWF  FE9
06CE6:  MOVLW  00
06CE8:  ADDWFC xC3,W
06CEA:  MOVWF  FEA
06CEC:  MOVFF  FEC,A17
06CF0:  MOVF   FED,F
06CF2:  MOVFF  FEF,A16
06CF6:  MOVLB  A
06CF8:  RRCF   x17,F
06CFA:  RRCF   x16,F
06CFC:  RRCF   x17,F
06CFE:  RRCF   x16,F
06D00:  RRCF   x17,F
06D02:  RRCF   x16,F
06D04:  RRCF   x17,F
06D06:  RRCF   x16,F
06D08:  MOVLW  0F
06D0A:  ANDWF  x17,F
06D0C:  MOVF   x16,W
06D0E:  MOVLB  9
06D10:  MOVWF  xCE
....................     packetdata[9] = (measured_data->open_voltage & 0x0F) << 4 | (measured_data->temp_py_top >> 8) & 0x0F;
06D12:  MOVLW  05
06D14:  ADDWF  xC2,W
06D16:  MOVWF  FE9
06D18:  MOVLW  00
06D1A:  ADDWFC xC3,W
06D1C:  MOVWF  FEA
06D1E:  MOVFF  FEC,A17
06D22:  MOVF   FED,F
06D24:  MOVFF  FEF,A16
06D28:  MOVLW  0F
06D2A:  MOVLB  A
06D2C:  ANDWF  x16,F
06D2E:  CLRF   x17
06D30:  RLCF   x16,F
06D32:  RLCF   x17,F
06D34:  RLCF   x16,F
06D36:  RLCF   x17,F
06D38:  RLCF   x16,F
06D3A:  RLCF   x17,F
06D3C:  RLCF   x16,F
06D3E:  RLCF   x17,F
06D40:  MOVLW  F0
06D42:  ANDWF  x16,F
06D44:  MOVLW  07
06D46:  MOVLB  9
06D48:  ADDWF  xC2,W
06D4A:  MOVWF  FE9
06D4C:  MOVLW  00
06D4E:  ADDWFC xC3,W
06D50:  MOVWF  FEA
06D52:  MOVFF  FEC,A19
06D56:  MOVF   FED,F
06D58:  MOVFF  FEF,A18
06D5C:  MOVFF  A19,A18
06D60:  MOVLB  A
06D62:  CLRF   x19
06D64:  MOVF   x18,W
06D66:  ANDLW  0F
06D68:  MOVWF  00
06D6A:  CLRF   03
06D6C:  MOVF   00,W
06D6E:  IORWF  x16,W
06D70:  MOVLB  9
06D72:  MOVWF  xCF
....................     packetdata[10] = measured_data->temp_py_top & 0xFF;
06D74:  MOVLW  07
06D76:  ADDWF  xC2,W
06D78:  MOVWF  FE9
06D7A:  MOVLW  00
06D7C:  ADDWFC xC3,W
06D7E:  MOVWF  FEA
06D80:  MOVFF  FEC,A17
06D84:  MOVF   FED,F
06D86:  MOVFF  FEF,A16
06D8A:  MOVLB  A
06D8C:  MOVF   x16,W
06D8E:  MOVLB  9
06D90:  MOVWF  xD0
....................     packetdata[11] = (measured_data->temp_py_bot >> 4) & 0xFF; // PD start low byte
06D92:  MOVLW  09
06D94:  ADDWF  xC2,W
06D96:  MOVWF  FE9
06D98:  MOVLW  00
06D9A:  ADDWFC xC3,W
06D9C:  MOVWF  FEA
06D9E:  MOVFF  FEC,A17
06DA2:  MOVF   FED,F
06DA4:  MOVFF  FEF,A16
06DA8:  MOVLB  A
06DAA:  RRCF   x17,F
06DAC:  RRCF   x16,F
06DAE:  RRCF   x17,F
06DB0:  RRCF   x16,F
06DB2:  RRCF   x17,F
06DB4:  RRCF   x16,F
06DB6:  RRCF   x17,F
06DB8:  RRCF   x16,F
06DBA:  MOVLW  0F
06DBC:  ANDWF  x17,F
06DBE:  MOVF   x16,W
06DC0:  MOVLB  9
06DC2:  MOVWF  xD1
....................     packetdata[12] = (measured_data->temp_py_bot & 0x0F) << 4 | (measured_data->temp_mis7 >> 8) & 0x0F;
06DC4:  MOVLW  09
06DC6:  ADDWF  xC2,W
06DC8:  MOVWF  FE9
06DCA:  MOVLW  00
06DCC:  ADDWFC xC3,W
06DCE:  MOVWF  FEA
06DD0:  MOVFF  FEC,A17
06DD4:  MOVF   FED,F
06DD6:  MOVFF  FEF,A16
06DDA:  MOVLW  0F
06DDC:  MOVLB  A
06DDE:  ANDWF  x16,F
06DE0:  CLRF   x17
06DE2:  RLCF   x16,F
06DE4:  RLCF   x17,F
06DE6:  RLCF   x16,F
06DE8:  RLCF   x17,F
06DEA:  RLCF   x16,F
06DEC:  RLCF   x17,F
06DEE:  RLCF   x16,F
06DF0:  RLCF   x17,F
06DF2:  MOVLW  F0
06DF4:  ANDWF  x16,F
06DF6:  MOVLW  0B
06DF8:  MOVLB  9
06DFA:  ADDWF  xC2,W
06DFC:  MOVWF  FE9
06DFE:  MOVLW  00
06E00:  ADDWFC xC3,W
06E02:  MOVWF  FEA
06E04:  MOVFF  FEC,A19
06E08:  MOVF   FED,F
06E0A:  MOVFF  FEF,A18
06E0E:  MOVFF  A19,A18
06E12:  MOVLB  A
06E14:  CLRF   x19
06E16:  MOVF   x18,W
06E18:  ANDLW  0F
06E1A:  MOVWF  00
06E1C:  CLRF   03
06E1E:  MOVF   00,W
06E20:  IORWF  x16,W
06E22:  MOVLB  9
06E24:  MOVWF  xD2
....................     packetdata[13] = measured_data->temp_mis7 & 0xFF;
06E26:  MOVLW  0B
06E28:  ADDWF  xC2,W
06E2A:  MOVWF  FE9
06E2C:  MOVLW  00
06E2E:  ADDWFC xC3,W
06E30:  MOVWF  FEA
06E32:  MOVFF  FEC,A17
06E36:  MOVF   FED,F
06E38:  MOVFF  FEF,A16
06E3C:  MOVLB  A
06E3E:  MOVF   x16,W
06E40:  MOVLB  9
06E42:  MOVWF  xD3
.................... 
....................     packetdata_index = 14; // Start index for data
06E44:  MOVLW  0E
06E46:  MOVLB  A
06E48:  MOVWF  x06
.................... 
....................     for (unsigned int16 i = 0; i < port_data->sweep_step ; i++) {
06E4A:  CLRF   x08
06E4C:  CLRF   x07
06E4E:  MOVLB  0
06E50:  MOVLW  01
06E52:  MOVLB  9
06E54:  ADDWF  xC4,W
06E56:  MOVWF  FE9
06E58:  MOVLW  00
06E5A:  ADDWFC xC5,W
06E5C:  MOVWF  FEA
06E5E:  MOVFF  FEC,03
06E62:  MOVF   FED,F
06E64:  MOVF   FEF,W
06E66:  MOVWF  01
06E68:  MOVLB  A
06E6A:  MOVF   x08,W
06E6C:  SUBWF  03,W
06E6E:  BTFSC  FD8.0
06E70:  BRA    6E78
06E72:  MOVLB  0
06E74:  GOTO   7056
06E78:  MOVLB  0
06E7A:  BTFSS  FD8.2
06E7C:  GOTO   6E92
06E80:  MOVF   01,W
06E82:  MOVLB  A
06E84:  SUBWF  x07,W
06E86:  BTFSS  FD8.0
06E88:  BRA    6E90
06E8A:  MOVLB  0
06E8C:  GOTO   7056
06E90:  MOVLB  0
....................         unsigned int16 data0 = port_data->data_buffer[0][i];
....................         unsigned int16 data1 = port_data->data_buffer[1][i];
06E92:  BCF    FD8.0
06E94:  MOVLB  A
06E96:  RLCF   x07,W
06E98:  MOVWF  02
06E9A:  RLCF   x08,W
06E9C:  MOVWF  03
06E9E:  MOVF   02,W
06EA0:  ADDLW  03
06EA2:  MOVWF  01
06EA4:  MOVLW  00
06EA6:  ADDWFC 03,F
06EA8:  MOVF   01,W
06EAA:  MOVLB  9
06EAC:  ADDWF  xC4,W
06EAE:  MOVWF  FE9
06EB0:  MOVF   xC5,W
06EB2:  ADDWFC 03,W
06EB4:  MOVWF  FEA
06EB6:  MOVFF  FEC,A0A
06EBA:  MOVF   FED,F
06EBC:  MOVFF  FEF,A09
06EC0:  BCF    FD8.0
06EC2:  MOVLB  A
06EC4:  RLCF   x07,W
06EC6:  MOVWF  02
06EC8:  RLCF   x08,W
06ECA:  MOVWF  03
06ECC:  MOVF   02,W
06ECE:  ADDLW  01
06ED0:  MOVWF  01
06ED2:  MOVLW  02
06ED4:  ADDWFC 03,F
06ED6:  MOVF   01,W
06ED8:  MOVLB  9
06EDA:  ADDWF  xC4,W
06EDC:  MOVWF  FE9
06EDE:  MOVF   xC5,W
06EE0:  ADDWFC 03,W
06EE2:  MOVWF  FEA
06EE4:  MOVFF  FEC,A0C
06EE8:  MOVF   FED,F
06EEA:  MOVFF  FEF,A0B
06EEE:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
06EF0:  MOVLB  A
06EF2:  MOVF   x06,W
06EF4:  INCF   x06,F
06EF6:  CLRF   03
06EF8:  ADDLW  C6
06EFA:  MOVWF  FE9
06EFC:  MOVLW  09
06EFE:  ADDWFC 03,W
06F00:  MOVWF  FEA
06F02:  RRCF   x0A,W
06F04:  MOVWF  x19
06F06:  RRCF   x09,W
06F08:  MOVWF  x18
06F0A:  RRCF   x19,F
06F0C:  RRCF   x18,F
06F0E:  RRCF   x19,F
06F10:  RRCF   x18,F
06F12:  RRCF   x19,F
06F14:  RRCF   x18,F
06F16:  MOVLW  0F
06F18:  ANDWF  x19,F
06F1A:  MOVF   x18,W
06F1C:  MOVWF  00
06F1E:  CLRF   03
06F20:  MOVF   00,W
06F22:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
06F24:  MOVF   x06,W
06F26:  INCF   x06,F
06F28:  CLRF   03
06F2A:  ADDLW  C6
06F2C:  MOVWF  FE9
06F2E:  MOVLW  09
06F30:  ADDWFC 03,W
06F32:  MOVWF  FEA
06F34:  MOVF   x09,W
06F36:  ANDLW  0F
06F38:  MOVWF  x18
06F3A:  CLRF   x19
06F3C:  RLCF   x18,F
06F3E:  RLCF   x19,F
06F40:  RLCF   x18,F
06F42:  RLCF   x19,F
06F44:  RLCF   x18,F
06F46:  RLCF   x19,F
06F48:  RLCF   x18,F
06F4A:  RLCF   x19,F
06F4C:  MOVLW  F0
06F4E:  ANDWF  x18,F
06F50:  MOVFF  A0C,A1A
06F54:  CLRF   x1B
06F56:  MOVF   x1A,W
06F58:  ANDLW  0F
06F5A:  MOVWF  00
06F5C:  CLRF   03
06F5E:  MOVF   00,W
06F60:  IORWF  x18,W
06F62:  MOVWF  00
06F64:  MOVF   03,W
06F66:  IORWF  x19,W
06F68:  MOVWF  03
06F6A:  MOVF   00,W
06F6C:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
06F6E:  MOVF   x06,W
06F70:  INCF   x06,F
06F72:  CLRF   03
06F74:  ADDLW  C6
06F76:  MOVWF  FE9
06F78:  MOVLW  09
06F7A:  ADDWFC 03,W
06F7C:  MOVWF  FEA
06F7E:  MOVF   x0B,W
06F80:  MOVWF  00
06F82:  CLRF   03
06F84:  MOVF   00,W
06F86:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
06F88:  MOVLW  03
06F8A:  ADDWF  x06,W
06F8C:  SUBLW  3E
06F8E:  BTFSS  FD8.0
06F90:  BRA    6F98
06F92:  MOVLB  0
06F94:  GOTO   7048
06F98:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
06F9A:  MOVLW  09
06F9C:  MOVLB  A
06F9E:  MOVWF  xAE
06FA0:  MOVLW  C6
06FA2:  MOVWF  xAD
06FA4:  MOVLW  3F
06FA6:  MOVWF  xAF
06FA8:  MOVLB  0
06FAA:  CALL   29DC
06FAE:  MOVFF  01,A05
....................             unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
06FB2:  MOVLB  1
06FB4:  MOVF   x40,W
06FB6:  MOVLB  A
06FB8:  MOVWF  x0D
06FBA:  MOVLW  10
06FBC:  MOVLB  1
06FBE:  ADDWF  x41,W
06FC0:  MOVLB  A
06FC2:  MOVWF  x0E
06FC4:  MOVLW  7C
06FC6:  MOVLB  1
06FC8:  ADDWFC x42,W
06FCA:  MOVLB  A
06FCC:  MOVWF  x0F
06FCE:  MOVLW  00
06FD0:  MOVLB  1
06FD2:  ADDWFC x43,W
06FD4:  MOVLB  A
06FD6:  MOVWF  x10
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
06FD8:  MOVFF  111,A59
06FDC:  MOVFF  110,A58
06FE0:  MOVFF  10F,A57
06FE4:  MOVFF  10E,A56
06FE8:  MOVFF  A10,A5D
06FEC:  MOVFF  A0F,A5C
06FF0:  MOVFF  A0E,A5B
06FF4:  MOVFF  A0D,A5A
06FF8:  MOVLW  09
06FFA:  MOVWF  x5F
06FFC:  MOVLW  C6
06FFE:  MOVWF  x5E
07000:  CLRF   x61
07002:  MOVLW  40
07004:  MOVWF  x60
07006:  MOVLB  0
07008:  CALL   34DE
....................             iv_data.used_counter += PACKET_SIZE;
0700C:  MOVLW  40
0700E:  MOVLB  1
07010:  ADDWF  x40,F
07012:  MOVLW  00
07014:  ADDWFC x41,F
07016:  MOVLW  00
07018:  ADDWFC x42,F
0701A:  MOVLW  00
0701C:  ADDWFC x43,F
....................             iv_data.uncopied_counter += PACKET_SIZE;
0701E:  MOVLW  40
07020:  ADDWF  x44,F
07022:  MOVLW  00
07024:  ADDWFC x45,F
07026:  MOVLW  00
07028:  ADDWFC x46,F
0702A:  MOVLW  00
0702C:  ADDWFC x47,F
....................             packetdata_index = 0;
0702E:  MOVLB  A
07030:  CLRF   x06
....................             memset(packetdata, 0x00, PACKET_SIZE);
07032:  MOVLW  09
07034:  MOVWF  FEA
07036:  MOVLW  C6
07038:  MOVWF  FE9
0703A:  CLRF   00
0703C:  CLRF   02
0703E:  MOVLW  40
07040:  MOVWF  01
07042:  MOVLB  0
07044:  CALL   27A0
....................         }
07048:  MOVLB  A
0704A:  INCF   x07,F
0704C:  BTFSC  FD8.2
0704E:  INCF   x08,F
07050:  MOVLB  0
07052:  GOTO   6E50
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
07056:  MOVLB  A
07058:  MOVF   x06,F
0705A:  BTFSS  FD8.2
0705C:  BRA    7064
0705E:  MOVLB  0
07060:  GOTO   7130
07064:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
07066:  MOVFF  A06,A11
0706A:  MOVLB  A
0706C:  MOVF   x11,W
0706E:  SUBLW  3E
07070:  BTFSC  FD8.0
07072:  BRA    707A
07074:  MOVLB  0
07076:  GOTO   709A
0707A:  MOVLB  0
....................             packetdata[j] = 0x00;
0707C:  CLRF   03
0707E:  MOVLB  A
07080:  MOVF   x11,W
07082:  ADDLW  C6
07084:  MOVWF  FE9
07086:  MOVLW  09
07088:  ADDWFC 03,W
0708A:  MOVWF  FEA
0708C:  CLRF   FEF
0708E:  MOVLB  0
07090:  MOVLB  A
07092:  INCF   x11,F
07094:  MOVLB  0
07096:  GOTO   706A
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
0709A:  MOVLW  09
0709C:  MOVLB  A
0709E:  MOVWF  xAE
070A0:  MOVLW  C6
070A2:  MOVWF  xAD
070A4:  MOVLW  3F
070A6:  MOVWF  xAF
070A8:  MOVLB  0
070AA:  CALL   29DC
070AE:  MOVFF  01,A05
....................         unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
070B2:  MOVLB  1
070B4:  MOVF   x40,W
070B6:  MOVLB  A
070B8:  MOVWF  x12
070BA:  MOVLW  10
070BC:  MOVLB  1
070BE:  ADDWF  x41,W
070C0:  MOVLB  A
070C2:  MOVWF  x13
070C4:  MOVLW  7C
070C6:  MOVLB  1
070C8:  ADDWFC x42,W
070CA:  MOVLB  A
070CC:  MOVWF  x14
070CE:  MOVLW  00
070D0:  MOVLB  1
070D2:  ADDWFC x43,W
070D4:  MOVLB  A
070D6:  MOVWF  x15
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
070D8:  MOVFF  111,A59
070DC:  MOVFF  110,A58
070E0:  MOVFF  10F,A57
070E4:  MOVFF  10E,A56
070E8:  MOVFF  A15,A5D
070EC:  MOVFF  A14,A5C
070F0:  MOVFF  A13,A5B
070F4:  MOVFF  A12,A5A
070F8:  MOVLW  09
070FA:  MOVWF  x5F
070FC:  MOVLW  C6
070FE:  MOVWF  x5E
07100:  CLRF   x61
07102:  MOVLW  40
07104:  MOVWF  x60
07106:  MOVLB  0
07108:  CALL   34DE
....................         iv_data.used_counter += PACKET_SIZE;
0710C:  MOVLW  40
0710E:  MOVLB  1
07110:  ADDWF  x40,F
07112:  MOVLW  00
07114:  ADDWFC x41,F
07116:  MOVLW  00
07118:  ADDWFC x42,F
0711A:  MOVLW  00
0711C:  ADDWFC x43,F
....................         iv_data.uncopied_counter += PACKET_SIZE;
0711E:  MOVLW  40
07120:  ADDWF  x44,F
07122:  MOVLW  00
07124:  ADDWFC x45,F
07126:  MOVLW  00
07128:  ADDWFC x46,F
0712A:  MOVLW  00
0712C:  ADDWFC x47,F
0712E:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "End CIGS data conversion\r\n");
07130:  MOVLW  FC
07132:  MOVWF  FF6
07134:  MOVLW  06
07136:  MOVWF  FF7
07138:  MOVLW  00
0713A:  MOVWF  FF8
0713C:  CALL   1BBE
....................     write_misf_address_area(); // Write the mission flash address area
07140:  GOTO   6AA8
07144:  RETURN 0
.................... }
.................... 
.................... MEASUREMENT_DATA create_meas_data()
.................... {
....................     MEASUREMENT_DATA data;
....................     data.time_sec = get_current_sec();
*
0653C:  CALL   31C0
06540:  MOVFF  03,9CB
06544:  MOVFF  02,9CA
06548:  MOVFF  01,9C9
0654C:  MOVFF  00,9C8
....................     data.time_msec = get_current_msec();
06550:  GOTO   650C
06554:  MOVFF  01,9CC
....................     data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
06558:  MOVLW  0D
0655A:  MOVLB  9
0655C:  MOVWF  xD7
0655E:  MOVLB  0
06560:  CALL   1DAE
06564:  MOVFF  02,9D0
06568:  MOVFF  01,9CF
....................     data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
0656C:  MOVLW  0E
0656E:  MOVLB  9
06570:  MOVWF  xD7
06572:  MOVLB  0
06574:  CALL   1DAE
06578:  MOVFF  02,9D2
0657C:  MOVFF  01,9D1
....................     data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
06580:  MOVLW  0C
06582:  MOVLB  9
06584:  MOVWF  xD7
06586:  MOVLB  0
06588:  CALL   1DAE
0658C:  MOVFF  02,9D4
06590:  MOVFF  01,9D3
....................     data.pd = ad7490_read(ADC_PD);
06594:  MOVLW  0F
06596:  MOVLB  9
06598:  MOVWF  xD7
0659A:  MOVLB  0
0659C:  CALL   1DAE
065A0:  MOVFF  02,9D6
065A4:  MOVFF  01,9D5
....................     data.open_voltage = ad7490_read(ADC_CIGS1_VOLT); // Assuming this is the correct ADC channel for open voltage
065A8:  MOVLB  9
065AA:  CLRF   xD7
065AC:  MOVLB  0
065AE:  CALL   1DAE
065B2:  MOVFF  02,9CE
065B6:  MOVFF  01,9CD
....................     return data;
065BA:  MOVLW  C8
065BC:  MOVWF  01
065BE:  MOVLW  09
065C0:  MOVWF  02
065C2:  GOTO   81F6 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/mcu/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../storage/mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
.................... {
....................     PICLOG_t piclog;
....................     memset(piclog.bytes, 0, PICLOG_PACKET_SIZE);
*
03862:  MOVLW  01
03864:  MOVWF  FEA
03866:  MOVLW  E2
03868:  MOVWF  FE9
0386A:  CLRF   00
0386C:  CLRF   02
0386E:  MOVLW  06
03870:  MOVWF  01
03872:  CALL   27A0
....................     piclog.fields.time = get_current_sec();
03876:  CALL   31C0
0387A:  MOVFF  03,1E5
0387E:  MOVFF  02,1E4
03882:  MOVFF  01,1E3
03886:  MOVFF  00,1E2
....................     piclog.fields.function = function;
0388A:  MOVFF  1E0,1E6
....................     piclog.fields.parameter = parameter;
0388E:  MOVFF  1E1,1E7
.................... 
....................     printf("\t[PICLOG] : ");
03892:  MOVLW  18
03894:  MOVWF  FF6
03896:  MOVLW  07
03898:  MOVWF  FF7
0389A:  MOVLW  00
0389C:  MOVWF  FF8
0389E:  CALL   1BBE
....................     for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
038A2:  MOVLB  1
038A4:  CLRF   xE8
038A6:  MOVLB  0
038A8:  MOVLB  1
038AA:  MOVF   xE8,W
038AC:  SUBLW  05
038AE:  BTFSC  FD8.0
038B0:  BRA    38B8
038B2:  MOVLB  0
038B4:  GOTO   38F4
038B8:  MOVLB  0
....................         printf("%02X ", piclog.bytes[i]);
038BA:  CLRF   03
038BC:  MOVLB  1
038BE:  MOVF   xE8,W
038C0:  ADDLW  E2
038C2:  MOVWF  FE9
038C4:  MOVLW  01
038C6:  ADDWFC 03,W
038C8:  MOVWF  FEA
038CA:  MOVFF  FEF,1ED
038CE:  MOVFF  1ED,264
038D2:  MOVLW  37
038D4:  MOVLB  2
038D6:  MOVWF  x65
038D8:  MOVLB  0
038DA:  CALL   1E42
038DE:  MOVLW  20
038E0:  MOVLB  A
038E2:  MOVWF  xAD
038E4:  MOVLB  0
038E6:  CALL   1B6C
038EA:  MOVLB  1
038EC:  INCF   xE8,F
038EE:  MOVLB  0
038F0:  GOTO   38A8
....................     }
....................     printf("\r\n");
038F4:  MOVLW  0D
038F6:  MOVLB  A
038F8:  MOVWF  xAD
038FA:  MOVLB  0
038FC:  CALL   1B6C
03900:  MOVLW  0A
03902:  MOVLB  A
03904:  MOVWF  xAD
03906:  MOVLB  0
03908:  CALL   1B6C
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
0390C:  MOVLB  1
0390E:  MOVF   x1F,W
03910:  MOVWF  xE9
03912:  MOVF   x20,W
03914:  MOVWF  xEA
03916:  MOVLW  01
03918:  ADDWF  x21,W
0391A:  MOVWF  xEB
0391C:  MOVLW  00
0391E:  ADDWFC x22,W
03920:  MOVWF  xEC
....................     write_data_bytes(mis_fm, write_address, piclog.bytes, PICLOG_PACKET_SIZE);
03922:  MOVFF  111,A59
03926:  MOVFF  110,A58
0392A:  MOVFF  10F,A57
0392E:  MOVFF  10E,A56
03932:  MOVFF  1EC,A5D
03936:  MOVFF  1EB,A5C
0393A:  MOVFF  1EA,A5B
0393E:  MOVFF  1E9,A5A
03942:  MOVLW  01
03944:  MOVLB  A
03946:  MOVWF  x5F
03948:  MOVLW  E2
0394A:  MOVWF  x5E
0394C:  CLRF   x61
0394E:  MOVLW  06
03950:  MOVWF  x60
03952:  MOVLB  0
03954:  CALL   34DE
.................... 
....................     piclog_data.used_counter += PICLOG_PACKET_SIZE;
03958:  MOVLW  06
0395A:  MOVLB  1
0395C:  ADDWF  x1F,F
0395E:  MOVLW  00
03960:  ADDWFC x20,F
03962:  MOVLW  00
03964:  ADDWFC x21,F
03966:  MOVLW  00
03968:  ADDWFC x22,F
....................     piclog_data.uncopied_counter += PICLOG_PACKET_SIZE;
0396A:  MOVLW  06
0396C:  ADDWF  x23,F
0396E:  MOVLW  00
03970:  ADDWFC x24,F
03972:  MOVLW  00
03974:  ADDWFC x25,F
03976:  MOVLW  00
03978:  ADDWFC x26,F
....................     piclog_data.reserve_counter1 += PICLOG_PACKET_SIZE;
0397A:  MOVLW  06
0397C:  ADDWF  x27,F
.................... 
....................     // Next Packet
....................     if (piclog_data.reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
0397E:  MOVLW  06
03980:  ADDWF  x27,W
03982:  SUBLW  3F
03984:  BTFSS  FD8.0
03986:  BRA    398E
03988:  MOVLB  0
0398A:  GOTO   3A02
0398E:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
03990:  MOVLB  1
03992:  MOVF   x1F,W
03994:  MOVWF  xE9
03996:  MOVF   x20,W
03998:  MOVWF  xEA
0399A:  MOVLW  01
0399C:  ADDWF  x21,W
0399E:  MOVWF  xEB
039A0:  MOVLW  00
039A2:  ADDWFC x22,W
039A4:  MOVWF  xEC
....................         write_data_bytes(mis_fm, write_address, PICLOG_BLANK_DATA, sizeof(PICLOG_BLANK_DATA));
039A6:  MOVFF  111,A59
039AA:  MOVFF  110,A58
039AE:  MOVFF  10F,A57
039B2:  MOVFF  10E,A56
039B6:  MOVFF  1EC,A5D
039BA:  MOVFF  1EB,A5C
039BE:  MOVFF  1EA,A5B
039C2:  MOVFF  1E9,A5A
039C6:  MOVLW  01
039C8:  MOVLB  A
039CA:  MOVWF  x5F
039CC:  MOVLW  4A
039CE:  MOVWF  x5E
039D0:  CLRF   x61
039D2:  MOVLW  04
039D4:  MOVWF  x60
039D6:  MOVLB  0
039D8:  CALL   34DE
....................         piclog_data.used_counter += sizeof(PICLOG_BLANK_DATA);
039DC:  MOVLW  04
039DE:  MOVLB  1
039E0:  ADDWF  x1F,F
039E2:  MOVLW  00
039E4:  ADDWFC x20,F
039E6:  MOVLW  00
039E8:  ADDWFC x21,F
039EA:  MOVLW  00
039EC:  ADDWFC x22,F
....................         piclog_data.uncopied_counter += sizeof(PICLOG_BLANK_DATA);
039EE:  MOVLW  04
039F0:  ADDWF  x23,F
039F2:  MOVLW  00
039F4:  ADDWFC x24,F
039F6:  MOVLW  00
039F8:  ADDWFC x25,F
039FA:  MOVLW  00
039FC:  ADDWFC x26,F
....................         piclog_data.reserve_counter1 = 0;
039FE:  CLRF   x27
03A00:  MOVLB  0
....................     }
.................... 
....................     // write_misf_address_area(); // Update the address area after writing
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
....................     #ifdef PICLOG_DEBUG
03A02:  RETURN 0
....................         //fprintf(PC, "PICLOG written: %02X %02X %02X %02X %02X %02X\r\n", piclog_data.bytes[0], data[1], data[2], data[3], data[4], data[5]);
....................     #endif
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
*
05B20:  MOVLB  1
05B22:  CLRF   xD3
05B24:  CLRF   xD4
05B26:  CLRF   xD5
05B28:  CLRF   xD6
05B2A:  CLRF   xD7
05B2C:  CLRF   xD8
05B2E:  CLRF   xD9
05B30:  CLRF   xDA
05B32:  CLRF   xDB
05B34:  CLRF   xDC
05B36:  CLRF   xDD
05B38:  CLRF   xDE
05B3A:  CLRF   xDF
05B3C:  CLRF   xE0
05B3E:  CLRF   xE1
05B40:  CLRF   xE2
05B42:  CLRF   xE3
05B44:  CLRF   xE4
05B46:  CLRF   xE5
05B48:  CLRF   xE6
05B4A:  CLRF   xE7
05B4C:  CLRF   xE8
05B4E:  CLRF   xE9
05B50:  CLRF   xEA
05B52:  CLRF   xEB
05B54:  CLRF   xEC
05B56:  CLRF   xED
05B58:  CLRF   xEE
05B5A:  CLRF   xEF
05B5C:  CLRF   xF0
05B5E:  CLRF   xF1
05B60:  CLRF   xF2
05B62:  CLRF   xF3
05B64:  CLRF   xF4
05B66:  CLRF   xF5
05B68:  CLRF   xF6
05B6A:  CLRF   xF7
05B6C:  CLRF   xF8
05B6E:  CLRF   xF9
05B70:  CLRF   xFA
05B72:  CLRF   xFB
05B74:  CLRF   xFC
05B76:  CLRF   xFD
05B78:  CLRF   xFE
05B7A:  CLRF   xFF
05B7C:  MOVLB  2
05B7E:  CLRF   x00
05B80:  CLRF   x01
05B82:  CLRF   x02
05B84:  CLRF   x03
05B86:  CLRF   x04
05B88:  CLRF   x05
05B8A:  CLRF   x06
05B8C:  CLRF   x07
05B8E:  CLRF   x08
05B90:  CLRF   x09
05B92:  CLRF   x0A
05B94:  CLRF   x0B
05B96:  CLRF   x0C
05B98:  CLRF   x0D
05B9A:  CLRF   x0E
05B9C:  CLRF   x0F
05B9E:  CLRF   x10
05BA0:  CLRF   x11
05BA2:  CLRF   x12
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
05BA4:  MOVLW  01
05BA6:  MOVLB  A
05BA8:  MOVWF  xAE
05BAA:  MOVLW  D3
05BAC:  MOVWF  xAD
05BAE:  MOVLW  3F
05BB0:  MOVWF  xAF
05BB2:  MOVLB  0
05BB4:  CALL   29DC
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
05BB8:  MOVFF  115,A59
05BBC:  MOVFF  114,A58
05BC0:  MOVFF  113,A57
05BC4:  MOVFF  112,A56
05BC8:  MOVLW  06
05BCA:  MOVLB  A
05BCC:  MOVWF  x5D
05BCE:  MOVLW  AA
05BD0:  MOVWF  x5C
05BD2:  CLRF   x5B
05BD4:  CLRF   x5A
05BD6:  MOVLW  01
05BD8:  MOVWF  x5F
05BDA:  MOVLW  D3
05BDC:  MOVWF  x5E
05BDE:  CLRF   x61
05BE0:  MOVLW  40
05BE2:  MOVWF  x60
05BE4:  MOVLB  0
05BE6:  CALL   34DE
05BEA:  GOTO   5D3A (RETURN)
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
096E2:  MOVLB  2
096E4:  MOVF   x60,W
096E6:  MOVWF  01
096E8:  MOVF   x61,W
096EA:  MOVWF  03
096EC:  MOVF   01,W
096EE:  MOVWF  x63
096F0:  MOVFF  03,264
096F4:  MOVFF  115,2E5
096F8:  MOVFF  114,2E4
096FC:  MOVFF  113,2E3
09700:  MOVFF  112,2E2
09704:  MOVLW  06
09706:  MOVWF  xE9
09708:  MOVLW  AA
0970A:  MOVWF  xE8
0970C:  CLRF   xE7
0970E:  CLRF   xE6
09710:  MOVFF  264,2EB
09714:  MOVFF  263,2EA
09718:  CLRF   xEF
0971A:  CLRF   xEE
0971C:  CLRF   xED
0971E:  MOVLW  40
09720:  MOVWF  xEC
09722:  MOVLB  0
09724:  CALL   27C4
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
09728:  MOVLB  2
0972A:  CLRF   x62
0972C:  MOVLB  0
0972E:  MOVLB  2
09730:  MOVF   x62,W
09732:  SUBLW  04
09734:  BTFSC  FD8.0
09736:  BRA    973E
09738:  MOVLB  0
0973A:  GOTO   9808
0973E:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
09740:  MOVLB  2
09742:  MOVF   x60,W
09744:  MOVWF  01
09746:  MOVF   x61,W
09748:  MOVWF  03
0974A:  MOVF   01,W
0974C:  MOVWF  x63
0974E:  MOVFF  03,264
09752:  MOVFF  115,2E5
09756:  MOVFF  114,2E4
0975A:  MOVFF  113,2E3
0975E:  MOVFF  112,2E2
09762:  MOVLW  06
09764:  MOVWF  xE9
09766:  MOVLW  AA
09768:  MOVWF  xE8
0976A:  CLRF   xE7
0976C:  CLRF   xE6
0976E:  MOVFF  264,2EB
09772:  MOVFF  263,2EA
09776:  CLRF   xEF
09778:  CLRF   xEE
0977A:  CLRF   xED
0977C:  MOVLW  40
0977E:  MOVWF  xEC
09780:  MOVLB  0
09782:  CALL   27C4
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
09786:  MOVLB  2
09788:  MOVF   x60,W
0978A:  MOVWF  01
0978C:  MOVF   x61,W
0978E:  MOVWF  03
09790:  MOVF   01,W
09792:  MOVWF  x63
09794:  MOVFF  03,264
09798:  MOVFF  264,2E3
0979C:  MOVFF  263,2E2
097A0:  MOVLW  3F
097A2:  MOVWF  xE4
097A4:  MOVLB  0
097A6:  CALL   9694
097AA:  MOVF   01,F
097AC:  BTFSC  FD8.2
097AE:  GOTO   97FE
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
097B2:  MOVLW  01
097B4:  MOVLB  2
097B6:  ADDWF  x62,W
097B8:  MOVWF  x63
097BA:  MOVLW  26
097BC:  MOVWF  FF6
097BE:  MOVLW  07
097C0:  MOVWF  FF7
097C2:  MOVLW  00
097C4:  MOVWF  FF8
097C6:  MOVLW  23
097C8:  MOVLB  9
097CA:  MOVWF  xC2
097CC:  MOVLB  0
097CE:  CALL   1BEE
097D2:  MOVFF  263,264
097D6:  MOVLW  1B
097D8:  MOVLB  2
097DA:  MOVWF  x65
097DC:  MOVLB  0
097DE:  CALL   6388
097E2:  MOVLW  0D
097E4:  MOVLB  A
097E6:  MOVWF  xAD
097E8:  MOVLB  0
097EA:  CALL   1B6C
097EE:  MOVLW  0A
097F0:  MOVLB  A
097F2:  MOVWF  xAD
097F4:  MOVLB  0
097F6:  CALL   1B6C
....................             break;
097FA:  GOTO   9808
....................         }
097FE:  MOVLB  2
09800:  INCF   x62,F
09802:  MOVLB  0
09804:  GOTO   972E
....................     }
09808:  GOTO   9C7E (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
0991E:  CALL   6750
09922:  MOVFF  02,03
09926:  MOVF   01,W
09928:  MOVWF  FE1
0992A:  MOVFF  03,FE2
0992E:  MOVLW  02
09930:  MOVWF  FEA
09932:  MOVLW  60
09934:  MOVWF  FE9
09936:  MOVLW  40
09938:  MOVWF  01
0993A:  MOVFF  FE6,FEE
0993E:  DECFSZ 01,F
09940:  GOTO   993A
09944:  MOVLB  2
09946:  BCF    xE0.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
09948:  CLRF   xE1
0994A:  MOVLB  0
0994C:  MOVLB  2
0994E:  MOVF   xE1,W
09950:  SUBLW  04
09952:  BTFSC  FD8.0
09954:  BRA    995C
09956:  MOVLB  0
09958:  GOTO   9A5C
0995C:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
0995E:  MOVFF  115,2E5
09962:  MOVFF  114,2E4
09966:  MOVFF  113,2E3
0996A:  MOVFF  112,2E2
0996E:  MOVLW  06
09970:  MOVLB  2
09972:  MOVWF  xE9
09974:  MOVLW  AA
09976:  MOVWF  xE8
09978:  CLRF   xE7
0997A:  CLRF   xE6
0997C:  MOVLB  0
0997E:  CALL   4680
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
09982:  MOVFF  115,A59
09986:  MOVFF  114,A58
0998A:  MOVFF  113,A57
0998E:  MOVFF  112,A56
09992:  MOVLW  06
09994:  MOVLB  A
09996:  MOVWF  x5D
09998:  MOVLW  AA
0999A:  MOVWF  x5C
0999C:  CLRF   x5B
0999E:  CLRF   x5A
099A0:  MOVLW  02
099A2:  MOVWF  x5F
099A4:  MOVLW  60
099A6:  MOVWF  x5E
099A8:  CLRF   x61
099AA:  MOVLW  40
099AC:  MOVWF  x60
099AE:  MOVLB  0
099B0:  CALL   34DE
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
099B4:  MOVFF  115,2E5
099B8:  MOVFF  114,2E4
099BC:  MOVFF  113,2E3
099C0:  MOVFF  112,2E2
099C4:  MOVLW  06
099C6:  MOVLB  2
099C8:  MOVWF  xE9
099CA:  MOVLW  AA
099CC:  MOVWF  xE8
099CE:  CLRF   xE7
099D0:  CLRF   xE6
099D2:  MOVLW  02
099D4:  MOVWF  xEB
099D6:  MOVLW  A0
099D8:  MOVWF  xEA
099DA:  CLRF   xEF
099DC:  CLRF   xEE
099DE:  CLRF   xED
099E0:  MOVLW  40
099E2:  MOVWF  xEC
099E4:  MOVLB  0
099E6:  CALL   27C4
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
099EA:  MOVLW  02
099EC:  MOVLB  2
099EE:  MOVWF  xE3
099F0:  MOVLW  A0
099F2:  MOVWF  xE2
099F4:  MOVLW  3F
099F6:  MOVWF  xE4
099F8:  MOVLB  0
099FA:  CALL   9694
099FE:  MOVF   01,F
09A00:  BTFSC  FD8.2
09A02:  GOTO   9A52
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
09A06:  MOVLW  01
09A08:  MOVLB  2
09A0A:  ADDWF  xE1,W
09A0C:  MOVWF  xE2
09A0E:  MOVLW  4E
09A10:  MOVWF  FF6
09A12:  MOVLW  07
09A14:  MOVWF  FF7
09A16:  MOVLW  00
09A18:  MOVWF  FF8
09A1A:  MOVLW  23
09A1C:  MOVLB  9
09A1E:  MOVWF  xC2
09A20:  MOVLB  0
09A22:  CALL   1BEE
09A26:  MOVFF  2E2,2E3
09A2A:  MOVLW  18
09A2C:  MOVLB  2
09A2E:  MOVWF  xE4
09A30:  MOVLB  0
09A32:  CALL   980C
09A36:  MOVLW  0D
09A38:  MOVLB  A
09A3A:  MOVWF  xAD
09A3C:  MOVLB  0
09A3E:  CALL   1B6C
09A42:  MOVLW  0A
09A44:  MOVLB  A
09A46:  MOVWF  xAD
09A48:  MOVLB  0
09A4A:  CALL   1B6C
....................             break;
09A4E:  GOTO   9A5C
....................         }
09A52:  MOVLB  2
09A54:  INCF   xE1,F
09A56:  MOVLB  0
09A58:  GOTO   994C
....................     }
....................     if (!crc_valid)
09A5C:  MOVLB  2
09A5E:  BTFSS  xE0.0
09A60:  BRA    9A68
09A62:  MOVLB  0
09A64:  GOTO   9AAA
09A68:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
09A6A:  MOVLW  76
09A6C:  MOVWF  FF6
09A6E:  MOVLW  07
09A70:  MOVWF  FF7
09A72:  MOVLW  00
09A74:  MOVWF  FF8
09A76:  MOVLW  25
09A78:  MOVLB  9
09A7A:  MOVWF  xC2
09A7C:  MOVLB  0
09A7E:  CALL   1BEE
09A82:  MOVLW  05
09A84:  MOVLB  2
09A86:  MOVWF  xE3
09A88:  MOVLW  18
09A8A:  MOVWF  xE4
09A8C:  MOVLB  0
09A8E:  CALL   980C
09A92:  MOVLW  9D
09A94:  MOVWF  FF6
09A96:  MOVLW  07
09A98:  MOVWF  FF7
09A9A:  MOVLW  00
09A9C:  MOVWF  FF8
09A9E:  MOVLW  0B
09AA0:  MOVLB  9
09AA2:  MOVWF  xC2
09AA4:  MOVLB  0
09AA6:  CALL   1BEE
....................         // return; 
....................     }
09AAA:  GOTO   A43A (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
09AB2:  MOVLW  AA
09AB4:  MOVWF  FF6
09AB6:  MOVLW  07
09AB8:  MOVWF  FF7
09ABA:  MOVLW  00
09ABC:  MOVWF  FF8
09ABE:  CALL   1BBE
....................     fprintf(PC, "_____Start copy_data____\r\n");
09AC2:  MOVLW  C4
09AC4:  MOVWF  FF6
09AC6:  MOVLW  07
09AC8:  MOVWF  FF7
09ACA:  MOVLW  00
09ACC:  MOVWF  FF8
09ACE:  CALL   1BBE
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
.................... 
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
09AD2:  MOVLB  1
09AD4:  MOVF   x8B,W
09AD6:  MOVWF  FE9
09AD8:  MOVF   x8C,W
09ADA:  MOVWF  FEA
09ADC:  MOVFF  FEF,260
09AE0:  MOVFF  260,267
09AE4:  MOVLB  0
09AE6:  CALL   946C
09AEA:  MOVFF  02,03
09AEE:  MOVF   01,W
09AF0:  MOVWF  FE1
09AF2:  MOVFF  03,FE2
09AF6:  MOVLW  01
09AF8:  MOVWF  FEA
09AFA:  MOVLW  CD
09AFC:  MOVWF  FE9
09AFE:  MOVLW  08
09B00:  MOVWF  01
09B02:  MOVFF  FE6,FEE
09B06:  DECFSZ 01,F
09B08:  GOTO   9B02
09B0C:  MOVFF  1D0,1D8
09B10:  MOVFF  1CF,1D7
09B14:  MOVFF  1CE,1D6
09B18:  MOVFF  1CD,1D5
09B1C:  MOVFF  1D4,1DC
09B20:  MOVFF  1D3,1DB
09B24:  MOVFF  1D2,1DA
09B28:  MOVFF  1D1,1D9
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
09B2C:  MOVLW  03
09B2E:  MOVLB  1
09B30:  ADDWF  x8B,W
09B32:  MOVWF  01
09B34:  MOVLW  00
09B36:  ADDWFC x8C,W
09B38:  MOVWF  03
09B3A:  MOVF   01,W
09B3C:  MOVWF  FE9
09B3E:  MOVFF  03,FEA
09B42:  BTFSS  FEF.0
09B44:  BRA    9B4C
09B46:  MOVLB  0
09B48:  GOTO   9BAC
09B4C:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
09B4E:  MOVLB  1
09B50:  MOVF   x8B,W
09B52:  MOVWF  FE9
09B54:  MOVF   x8C,W
09B56:  MOVWF  FEA
09B58:  MOVFF  FEF,260
09B5C:  MOVFF  260,267
09B60:  MOVLB  0
09B62:  GOTO   958C
09B66:  MOVFF  02,03
09B6A:  MOVF   01,W
09B6C:  MOVWF  FE1
09B6E:  MOVFF  03,FE2
09B72:  MOVLW  01
09B74:  MOVWF  FEA
09B76:  MOVLW  E5
09B78:  MOVWF  FE9
09B7A:  MOVLW  08
09B7C:  MOVWF  01
09B7E:  MOVFF  FE6,FEE
09B82:  DECFSZ 01,F
09B84:  GOTO   9B7E
....................         write_src = misf_address.start_address;
09B88:  MOVFF  1E8,1E0
09B8C:  MOVFF  1E7,1DF
09B90:  MOVFF  1E6,1DE
09B94:  MOVFF  1E5,1DD
....................         write_size = iv_data.uncopied_counter;
09B98:  MOVFF  147,1E4
09B9C:  MOVFF  146,1E3
09BA0:  MOVFF  145,1E2
09BA4:  MOVFF  144,1E1
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
09BA8:  GOTO   9C16
09BAC:  MOVLW  03
09BAE:  MOVLB  1
09BB0:  ADDWF  x8B,W
09BB2:  MOVWF  01
09BB4:  MOVLW  00
09BB6:  ADDWFC x8C,W
09BB8:  MOVWF  03
09BBA:  MOVF   01,W
09BBC:  MOVWF  FE9
09BBE:  MOVFF  03,FEA
09BC2:  BTFSC  FEF.0
09BC4:  BRA    9BCC
09BC6:  MOVLB  0
09BC8:  GOTO   9C16
09BCC:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
09BCE:  MOVLW  04
09BD0:  MOVLB  1
09BD2:  ADDWF  x8B,W
09BD4:  MOVWF  FE9
09BD6:  MOVLW  00
09BD8:  ADDWFC x8C,W
09BDA:  MOVWF  FEA
09BDC:  MOVFF  FEF,1DD
09BE0:  MOVFF  FEC,1DE
09BE4:  MOVFF  FEC,1DF
09BE8:  MOVFF  FEC,1E0
09BEC:  MOVF   FED,F
09BEE:  MOVF   FED,F
09BF0:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
09BF2:  MOVLW  08
09BF4:  ADDWF  x8B,W
09BF6:  MOVWF  FE9
09BF8:  MOVLW  00
09BFA:  ADDWFC x8C,W
09BFC:  MOVWF  FEA
09BFE:  MOVFF  FEF,1E1
09C02:  MOVFF  FEC,1E2
09C06:  MOVFF  FEC,1E3
09C0A:  MOVFF  FEC,1E4
09C0E:  MOVF   FED,F
09C10:  MOVF   FED,F
09C12:  MOVF   FED,F
09C14:  MOVLB  0
....................     }
.................... 
....................     // 接続確認
....................     if (!is_connect(mis_fm))
09C16:  MOVFF  111,263
09C1A:  MOVFF  110,262
09C1E:  MOVFF  10F,261
09C22:  MOVFF  10E,260
09C26:  CALL   26D8
09C2A:  MOVF   01,F
09C2C:  BTFSS  FD8.2
09C2E:  GOTO   9C42
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
09C32:  MOVLW  E0
09C34:  MOVWF  FF6
09C36:  MOVLW  07
09C38:  MOVWF  FF7
09C3A:  MOVLW  00
09C3C:  MOVWF  FF8
09C3E:  CALL   1BBE
....................     }    
....................     if (!is_connect(smf))
09C42:  MOVFF  115,263
09C46:  MOVFF  114,262
09C4A:  MOVFF  113,261
09C4E:  MOVFF  112,260
09C52:  CALL   26D8
09C56:  MOVF   01,F
09C58:  BTFSS  FD8.2
09C5A:  GOTO   9C6E
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
09C5E:  MOVLW  02
09C60:  MOVWF  FF6
09C62:  MOVLW  08
09C64:  MOVWF  FF7
09C66:  MOVLW  00
09C68:  MOVWF  FF8
09C6A:  CALL   1BBE
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
09C6E:  MOVLW  01
09C70:  MOVLB  2
09C72:  MOVWF  x61
09C74:  MOVLW  8D
09C76:  MOVWF  x60
09C78:  MOVLB  0
09C7A:  GOTO   96E2
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
09C7E:  MOVFF  154,1F0
09C82:  MOVFF  153,1EF
09C86:  MOVFF  152,1EE
09C8A:  MOVFF  151,1ED
09C8E:  MOVFF  155,1F1
....................     fprintf(PC, "Size area read\r\n");
09C92:  MOVLW  20
09C94:  MOVWF  FF6
09C96:  MOVLW  08
09C98:  MOVWF  FF7
09C9A:  MOVLW  00
09C9C:  MOVWF  FF8
09C9E:  CALL   1BBE
....................     fprintf(PC, "smf_used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
09CA2:  MOVLW  32
09CA4:  MOVWF  FF6
09CA6:  MOVLW  08
09CA8:  MOVWF  FF7
09CAA:  MOVLW  00
09CAC:  MOVWF  FF8
09CAE:  MOVLW  10
09CB0:  MOVLB  9
09CB2:  MOVWF  xC2
09CB4:  MOVLB  0
09CB6:  CALL   1BEE
09CBA:  MOVLW  41
09CBC:  MOVWF  FE9
09CBE:  MOVFF  1F0,263
09CC2:  MOVFF  1EF,262
09CC6:  MOVFF  1EE,261
09CCA:  MOVFF  1ED,260
09CCE:  CALL   92F0
09CD2:  MOVLW  45
09CD4:  MOVWF  FF6
09CD6:  MOVLW  08
09CD8:  MOVWF  FF7
09CDA:  MOVLW  00
09CDC:  MOVWF  FF8
09CDE:  MOVLW  08
09CE0:  MOVLB  9
09CE2:  MOVWF  xC2
09CE4:  MOVLB  0
09CE6:  CALL   1BEE
09CEA:  MOVFF  1D8,264
09CEE:  MOVLW  37
09CF0:  MOVLB  2
09CF2:  MOVWF  x65
09CF4:  MOVLB  0
09CF6:  CALL   1E42
09CFA:  MOVFF  1D7,264
09CFE:  MOVLW  37
09D00:  MOVLB  2
09D02:  MOVWF  x65
09D04:  MOVLB  0
09D06:  CALL   1E42
09D0A:  MOVFF  1D6,264
09D0E:  MOVLW  37
09D10:  MOVLB  2
09D12:  MOVWF  x65
09D14:  MOVLB  0
09D16:  CALL   1E42
09D1A:  MOVFF  1D5,264
09D1E:  MOVLW  37
09D20:  MOVLB  2
09D22:  MOVWF  x65
09D24:  MOVLB  0
09D26:  CALL   1E42
09D2A:  MOVLW  52
09D2C:  MOVWF  FF6
09D2E:  MOVLW  08
09D30:  MOVWF  FF7
09D32:  MOVLW  00
09D34:  MOVWF  FF8
09D36:  MOVLW  03
09D38:  MOVLB  9
09D3A:  MOVWF  xC2
09D3C:  MOVLB  0
09D3E:  CALL   1BEE
....................     fprintf(PC, "smf_loop count= %d  (src 0x%08LX)\r\n", loop_count, mis_start_address + 4);
09D42:  MOVLW  04
09D44:  MOVLB  1
09D46:  ADDWF  xD5,W
09D48:  MOVLB  2
09D4A:  MOVWF  x60
09D4C:  MOVLW  00
09D4E:  MOVLB  1
09D50:  ADDWFC xD6,W
09D52:  MOVLB  2
09D54:  MOVWF  x61
09D56:  MOVLW  00
09D58:  MOVLB  1
09D5A:  ADDWFC xD7,W
09D5C:  MOVLB  2
09D5E:  MOVWF  x62
09D60:  MOVLW  00
09D62:  MOVLB  1
09D64:  ADDWFC xD8,W
09D66:  MOVLB  2
09D68:  MOVWF  x63
09D6A:  MOVLW  56
09D6C:  MOVWF  FF6
09D6E:  MOVLW  08
09D70:  MOVWF  FF7
09D72:  MOVLW  00
09D74:  MOVWF  FF8
09D76:  MOVLW  10
09D78:  MOVLB  9
09D7A:  MOVWF  xC2
09D7C:  MOVLB  0
09D7E:  CALL   1BEE
09D82:  MOVFF  1F1,2E3
09D86:  MOVLW  18
09D88:  MOVLB  2
09D8A:  MOVWF  xE4
09D8C:  MOVLB  0
09D8E:  CALL   980C
09D92:  MOVLW  68
09D94:  MOVWF  FF6
09D96:  MOVLW  08
09D98:  MOVWF  FF7
09D9A:  MOVLW  00
09D9C:  MOVWF  FF8
09D9E:  MOVLW  09
09DA0:  MOVLB  9
09DA2:  MOVWF  xC2
09DA4:  MOVLB  0
09DA6:  CALL   1BEE
09DAA:  MOVFF  263,264
09DAE:  MOVLW  37
09DB0:  MOVLB  2
09DB2:  MOVWF  x65
09DB4:  MOVLB  0
09DB6:  CALL   1E42
09DBA:  MOVFF  262,264
09DBE:  MOVLW  37
09DC0:  MOVLB  2
09DC2:  MOVWF  x65
09DC4:  MOVLB  0
09DC6:  CALL   1E42
09DCA:  MOVFF  261,264
09DCE:  MOVLW  37
09DD0:  MOVLB  2
09DD2:  MOVWF  x65
09DD4:  MOVLB  0
09DD6:  CALL   1E42
09DDA:  MOVFF  260,264
09DDE:  MOVLW  37
09DE0:  MOVLB  2
09DE2:  MOVWF  x65
09DE4:  MOVLB  0
09DE6:  CALL   1E42
09DEA:  MOVLW  76
09DEC:  MOVWF  FF6
09DEE:  MOVLW  08
09DF0:  MOVWF  FF7
09DF2:  MOVLW  00
09DF4:  MOVWF  FF8
09DF6:  MOVLW  03
09DF8:  MOVLB  9
09DFA:  MOVWF  xC2
09DFC:  MOVLB  0
09DFE:  CALL   1BEE
....................     fprintf(PC, "misf_write_source = 0x%08LX\r\n", write_src);
09E02:  MOVLW  7A
09E04:  MOVWF  FF6
09E06:  MOVLW  08
09E08:  MOVWF  FF7
09E0A:  MOVLW  00
09E0C:  MOVWF  FF8
09E0E:  MOVLW  16
09E10:  MOVLB  9
09E12:  MOVWF  xC2
09E14:  MOVLB  0
09E16:  CALL   1BEE
09E1A:  MOVFF  1E0,264
09E1E:  MOVLW  37
09E20:  MOVLB  2
09E22:  MOVWF  x65
09E24:  MOVLB  0
09E26:  CALL   1E42
09E2A:  MOVFF  1DF,264
09E2E:  MOVLW  37
09E30:  MOVLB  2
09E32:  MOVWF  x65
09E34:  MOVLB  0
09E36:  CALL   1E42
09E3A:  MOVFF  1DE,264
09E3E:  MOVLW  37
09E40:  MOVLB  2
09E42:  MOVWF  x65
09E44:  MOVLB  0
09E46:  CALL   1E42
09E4A:  MOVFF  1DD,264
09E4E:  MOVLW  37
09E50:  MOVLB  2
09E52:  MOVWF  x65
09E54:  MOVLB  0
09E56:  CALL   1E42
09E5A:  MOVLW  0D
09E5C:  MOVLB  A
09E5E:  MOVWF  xAD
09E60:  MOVLB  0
09E62:  CALL   1B6C
09E66:  MOVLW  0A
09E68:  MOVLB  A
09E6A:  MOVWF  xAD
09E6C:  MOVLB  0
09E6E:  CALL   1B6C
....................     fprintf(PC, "misf_write_size = 0x%08LX\r\n", write_size);
09E72:  MOVLW  98
09E74:  MOVWF  FF6
09E76:  MOVLW  08
09E78:  MOVWF  FF7
09E7A:  MOVLW  00
09E7C:  MOVWF  FF8
09E7E:  MOVLW  14
09E80:  MOVLB  9
09E82:  MOVWF  xC2
09E84:  MOVLB  0
09E86:  CALL   1BEE
09E8A:  MOVFF  1E4,264
09E8E:  MOVLW  37
09E90:  MOVLB  2
09E92:  MOVWF  x65
09E94:  MOVLB  0
09E96:  CALL   1E42
09E9A:  MOVFF  1E3,264
09E9E:  MOVLW  37
09EA0:  MOVLB  2
09EA2:  MOVWF  x65
09EA4:  MOVLB  0
09EA6:  CALL   1E42
09EAA:  MOVFF  1E2,264
09EAE:  MOVLW  37
09EB0:  MOVLB  2
09EB2:  MOVWF  x65
09EB4:  MOVLB  0
09EB6:  CALL   1E42
09EBA:  MOVFF  1E1,264
09EBE:  MOVLW  37
09EC0:  MOVLB  2
09EC2:  MOVWF  x65
09EC4:  MOVLB  0
09EC6:  CALL   1E42
09ECA:  MOVLW  0D
09ECC:  MOVLB  A
09ECE:  MOVWF  xAD
09ED0:  MOVLB  0
09ED2:  CALL   1B6C
09ED6:  MOVLW  0A
09ED8:  MOVLB  A
09EDA:  MOVWF  xAD
09EDC:  MOVLB  0
09EDE:  CALL   1B6C
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
09EE2:  MOVLB  1
09EE4:  MOVF   xD5,W
09EE6:  MOVWF  xF2
09EE8:  MOVLW  10
09EEA:  ADDWF  xD6,W
09EEC:  MOVWF  xF3
09EEE:  MOVLW  00
09EF0:  ADDWFC xD7,W
09EF2:  MOVWF  xF4
09EF4:  MOVLW  00
09EF6:  ADDWFC xD8,W
09EF8:  MOVWF  xF5
09EFA:  MOVFF  1DC,1F9
09EFE:  MOVFF  1DB,1F8
09F02:  MOVFF  1DA,1F7
09F06:  MOVFF  1D9,1F6
09F0A:  MOVF   xF2,W
09F0C:  SUBWF  xF6,W
09F0E:  MOVWF  xFA
09F10:  MOVF   xF3,W
09F12:  SUBWFB xF7,W
09F14:  MOVWF  xFB
09F16:  MOVF   xF4,W
09F18:  SUBWFB xF8,W
09F1A:  MOVWF  xFC
09F1C:  MOVF   xF5,W
09F1E:  SUBWFB xF9,W
09F20:  MOVWF  xFD
09F22:  MOVF   xED,W
09F24:  ADDWF  xF2,W
09F26:  MOVWF  xFE
09F28:  MOVF   xEE,W
09F2A:  ADDWFC xF3,W
09F2C:  MOVWF  xFF
09F2E:  MOVF   xEF,W
09F30:  ADDWFC xF4,W
09F32:  MOVLB  2
09F34:  MOVWF  x00
09F36:  MOVLB  1
09F38:  MOVF   xF0,W
09F3A:  ADDWFC xF5,W
09F3C:  MOVLB  2
09F3E:  MOVWF  x01
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
09F40:  MOVLB  1
09F42:  MOVF   xE1,W
09F44:  ADDWF  xED,W
09F46:  MOVLB  2
09F48:  MOVWF  x60
09F4A:  MOVLB  1
09F4C:  MOVF   xE2,W
09F4E:  ADDWFC xEE,W
09F50:  MOVLB  2
09F52:  MOVWF  x61
09F54:  MOVLB  1
09F56:  MOVF   xE3,W
09F58:  ADDWFC xEF,W
09F5A:  MOVLB  2
09F5C:  MOVWF  x62
09F5E:  MOVLB  1
09F60:  MOVF   xE4,W
09F62:  ADDWFC xF0,W
09F64:  MOVLB  2
09F66:  MOVWF  x63
09F68:  MOVLB  1
09F6A:  MOVF   xFD,W
09F6C:  MOVLB  2
09F6E:  SUBWF  x63,W
09F70:  BTFSC  FD8.0
09F72:  BRA    9F7A
09F74:  MOVLB  0
09F76:  GOTO   A0B6
09F7A:  MOVLB  0
09F7C:  BTFSS  FD8.2
09F7E:  GOTO   9FCA
09F82:  MOVLB  1
09F84:  MOVF   xFC,W
09F86:  MOVLB  2
09F88:  SUBWF  x62,W
09F8A:  BTFSC  FD8.0
09F8C:  BRA    9F94
09F8E:  MOVLB  0
09F90:  GOTO   A0B6
09F94:  MOVLB  0
09F96:  BTFSS  FD8.2
09F98:  GOTO   9FCA
09F9C:  MOVLB  1
09F9E:  MOVF   xFB,W
09FA0:  MOVLB  2
09FA2:  SUBWF  x61,W
09FA4:  BTFSC  FD8.0
09FA6:  BRA    9FAE
09FA8:  MOVLB  0
09FAA:  GOTO   A0B6
09FAE:  MOVLB  0
09FB0:  BTFSS  FD8.2
09FB2:  GOTO   9FCA
09FB6:  MOVLB  2
09FB8:  MOVF   x60,W
09FBA:  MOVLB  1
09FBC:  SUBWF  xFA,W
09FBE:  BTFSS  FD8.0
09FC0:  BRA    9FC8
09FC2:  MOVLB  0
09FC4:  GOTO   A0B6
09FC8:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
09FCA:  MOVLW  B4
09FCC:  MOVWF  FF6
09FCE:  MOVLW  08
09FD0:  MOVWF  FF7
09FD2:  MOVLW  00
09FD4:  MOVWF  FF8
09FD6:  CALL   1BBE
....................         loop_count++;
09FDA:  MOVLB  1
09FDC:  INCF   xF1,F
....................         used_size = 0;
09FDE:  CLRF   xF0
09FE0:  CLRF   xEF
09FE2:  CLRF   xEE
09FE4:  CLRF   xED
....................         data_write_addr = data_region_start;
09FE6:  MOVFF  1F5,201
09FEA:  MOVFF  1F4,200
09FEE:  MOVFF  1F3,1FF
09FF2:  MOVFF  1F2,1FE
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
09FF6:  MOVF   x8B,W
09FF8:  MOVWF  FE9
09FFA:  MOVF   x8C,W
09FFC:  MOVWF  FEA
09FFE:  MOVFF  FEF,260
0A002:  MOVFF  260,261
0A006:  MOVLB  0
0A008:  GOTO   991A
....................         
....................         unsigned int32 erase_ptr = data_region_start;
0A00C:  MOVFF  1F5,205
0A010:  MOVFF  1F4,204
0A014:  MOVFF  1F3,203
0A018:  MOVFF  1F2,202
....................         while (erase_ptr < data_region_end)
0A01C:  MOVLB  2
0A01E:  MOVF   x05,W
0A020:  MOVLB  1
0A022:  SUBWF  xF9,W
0A024:  BTFSC  FD8.0
0A026:  BRA    A02E
0A028:  MOVLB  0
0A02A:  GOTO   A0B6
0A02E:  MOVLB  0
0A030:  BTFSS  FD8.2
0A032:  GOTO   A07E
0A036:  MOVLB  2
0A038:  MOVF   x04,W
0A03A:  MOVLB  1
0A03C:  SUBWF  xF8,W
0A03E:  BTFSC  FD8.0
0A040:  BRA    A048
0A042:  MOVLB  0
0A044:  GOTO   A0B6
0A048:  MOVLB  0
0A04A:  BTFSS  FD8.2
0A04C:  GOTO   A07E
0A050:  MOVLB  2
0A052:  MOVF   x03,W
0A054:  MOVLB  1
0A056:  SUBWF  xF7,W
0A058:  BTFSC  FD8.0
0A05A:  BRA    A062
0A05C:  MOVLB  0
0A05E:  GOTO   A0B6
0A062:  MOVLB  0
0A064:  BTFSS  FD8.2
0A066:  GOTO   A07E
0A06A:  MOVLB  1
0A06C:  MOVF   xF6,W
0A06E:  MOVLB  2
0A070:  SUBWF  x02,W
0A072:  BTFSS  FD8.0
0A074:  BRA    A07C
0A076:  MOVLB  0
0A078:  GOTO   A0B6
0A07C:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
0A07E:  MOVFF  115,2E5
0A082:  MOVFF  114,2E4
0A086:  MOVFF  113,2E3
0A08A:  MOVFF  112,2E2
0A08E:  MOVFF  205,2E9
0A092:  MOVFF  204,2E8
0A096:  MOVFF  203,2E7
0A09A:  MOVFF  202,2E6
0A09E:  CALL   4680
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
0A0A2:  MOVLW  10
0A0A4:  MOVLB  2
0A0A6:  ADDWF  x03,F
0A0A8:  MOVLW  00
0A0AA:  ADDWFC x04,F
0A0AC:  MOVLW  00
0A0AE:  ADDWFC x05,F
0A0B0:  MOVLB  0
0A0B2:  GOTO   A01C
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
0A0B6:  MOVLB  2
0A0B8:  CLRF   x06
0A0BA:  MOVLB  1
0A0BC:  MOVF   xFF,W
0A0BE:  ANDLW  F0
0A0C0:  MOVLB  2
0A0C2:  MOVWF  x07
0A0C4:  CLRF   x08
0A0C6:  CLRF   x09
0A0C8:  MOVLB  1
0A0CA:  MOVF   xE1,W
0A0CC:  ADDWF  xFE,W
0A0CE:  MOVLB  2
0A0D0:  MOVWF  x60
0A0D2:  MOVLB  1
0A0D4:  MOVF   xE2,W
0A0D6:  ADDWFC xFF,W
0A0D8:  MOVLB  2
0A0DA:  MOVWF  x61
0A0DC:  MOVLB  1
0A0DE:  MOVF   xE3,W
0A0E0:  MOVLB  2
0A0E2:  ADDWFC x00,W
0A0E4:  MOVWF  x62
0A0E6:  MOVLB  1
0A0E8:  MOVF   xE4,W
0A0EA:  MOVLB  2
0A0EC:  ADDWFC x01,W
0A0EE:  MOVWF  x63
0A0F0:  MOVLW  FF
0A0F2:  ADDWF  x60,F
0A0F4:  MOVLW  0F
0A0F6:  ADDWFC x61,F
0A0F8:  MOVLW  00
0A0FA:  ADDWFC x62,F
0A0FC:  MOVLW  00
0A0FE:  ADDWFC x63,F
0A100:  CLRF   x0A
0A102:  MOVF   x61,W
0A104:  ANDLW  F0
0A106:  MOVWF  x0B
0A108:  CLRF   x0C
0A10A:  CLRF   x0D
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
0A10C:  MOVFF  209,211
0A110:  MOVFF  208,210
0A114:  MOVFF  207,20F
0A118:  MOVFF  206,20E
0A11C:  MOVLB  0
0A11E:  MOVLB  2
0A120:  MOVF   x11,W
0A122:  SUBWF  x0D,W
0A124:  BTFSC  FD8.0
0A126:  BRA    A12E
0A128:  MOVLB  0
0A12A:  GOTO   A212
0A12E:  MOVLB  0
0A130:  BTFSS  FD8.2
0A132:  GOTO   A178
0A136:  MOVLB  2
0A138:  MOVF   x10,W
0A13A:  SUBWF  x0C,W
0A13C:  BTFSC  FD8.0
0A13E:  BRA    A146
0A140:  MOVLB  0
0A142:  GOTO   A212
0A146:  MOVLB  0
0A148:  BTFSS  FD8.2
0A14A:  GOTO   A178
0A14E:  MOVLB  2
0A150:  MOVF   x0F,W
0A152:  SUBWF  x0B,W
0A154:  BTFSC  FD8.0
0A156:  BRA    A15E
0A158:  MOVLB  0
0A15A:  GOTO   A212
0A15E:  MOVLB  0
0A160:  BTFSS  FD8.2
0A162:  GOTO   A178
0A166:  MOVLB  2
0A168:  MOVF   x0A,W
0A16A:  SUBWF  x0E,W
0A16C:  BTFSS  FD8.0
0A16E:  BRA    A176
0A170:  MOVLB  0
0A172:  GOTO   A212
0A176:  MOVLB  0
0A178:  MOVLB  2
0A17A:  MOVF   x11,W
0A17C:  MOVLB  1
0A17E:  SUBWF  xDC,W
0A180:  BTFSC  FD8.0
0A182:  BRA    A18A
0A184:  MOVLB  0
0A186:  GOTO   A212
0A18A:  MOVLB  0
0A18C:  BTFSS  FD8.2
0A18E:  GOTO   A1DA
0A192:  MOVLB  2
0A194:  MOVF   x10,W
0A196:  MOVLB  1
0A198:  SUBWF  xDB,W
0A19A:  BTFSC  FD8.0
0A19C:  BRA    A1A4
0A19E:  MOVLB  0
0A1A0:  GOTO   A212
0A1A4:  MOVLB  0
0A1A6:  BTFSS  FD8.2
0A1A8:  GOTO   A1DA
0A1AC:  MOVLB  2
0A1AE:  MOVF   x0F,W
0A1B0:  MOVLB  1
0A1B2:  SUBWF  xDA,W
0A1B4:  BTFSC  FD8.0
0A1B6:  BRA    A1BE
0A1B8:  MOVLB  0
0A1BA:  GOTO   A212
0A1BE:  MOVLB  0
0A1C0:  BTFSS  FD8.2
0A1C2:  GOTO   A1DA
0A1C6:  MOVLB  1
0A1C8:  MOVF   xD9,W
0A1CA:  MOVLB  2
0A1CC:  SUBWF  x0E,W
0A1CE:  BTFSS  FD8.0
0A1D0:  BRA    A1D8
0A1D2:  MOVLB  0
0A1D4:  GOTO   A212
0A1D8:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
0A1DA:  MOVFF  115,2E5
0A1DE:  MOVFF  114,2E4
0A1E2:  MOVFF  113,2E3
0A1E6:  MOVFF  112,2E2
0A1EA:  MOVFF  211,2E9
0A1EE:  MOVFF  210,2E8
0A1F2:  MOVFF  20F,2E7
0A1F6:  MOVFF  20E,2E6
0A1FA:  CALL   4680
0A1FE:  MOVLW  10
0A200:  MOVLB  2
0A202:  ADDWF  x0F,F
0A204:  MOVLW  00
0A206:  ADDWFC x10,F
0A208:  MOVLW  00
0A20A:  ADDWFC x11,F
0A20C:  MOVLB  0
0A20E:  GOTO   A11E
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
0A212:  MOVFF  1E4,215
0A216:  MOVFF  1E3,214
0A21A:  MOVFF  1E2,213
0A21E:  MOVFF  1E1,212
0A222:  MOVFF  1E0,219
0A226:  MOVFF  1DF,218
0A22A:  MOVFF  1DE,217
0A22E:  MOVFF  1DD,216
....................     while (remaining > 0)
0A232:  MOVLB  2
0A234:  MOVF   x12,F
0A236:  BTFSC  FD8.2
0A238:  BRA    A240
0A23A:  MOVLB  0
0A23C:  GOTO   A272
0A240:  MOVLB  0
0A242:  MOVLB  2
0A244:  MOVF   x13,F
0A246:  BTFSC  FD8.2
0A248:  BRA    A250
0A24A:  MOVLB  0
0A24C:  GOTO   A272
0A250:  MOVLB  0
0A252:  MOVLB  2
0A254:  MOVF   x14,F
0A256:  BTFSC  FD8.2
0A258:  BRA    A260
0A25A:  MOVLB  0
0A25C:  GOTO   A272
0A260:  MOVLB  0
0A262:  MOVLB  2
0A264:  MOVF   x15,F
0A266:  BTFSS  FD8.2
0A268:  BRA    A270
0A26A:  MOVLB  0
0A26C:  GOTO   A436
0A270:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
0A272:  MOVLB  2
0A274:  MOVF   x15,F
0A276:  BTFSC  FD8.2
0A278:  BRA    A280
0A27A:  MOVLB  0
0A27C:  GOTO   A2B4
0A280:  MOVLB  0
0A282:  MOVLB  2
0A284:  MOVF   x14,F
0A286:  BTFSC  FD8.2
0A288:  BRA    A290
0A28A:  MOVLB  0
0A28C:  GOTO   A2B4
0A290:  MOVLB  0
0A292:  MOVLB  2
0A294:  MOVF   x13,F
0A296:  BTFSC  FD8.2
0A298:  BRA    A2A0
0A29A:  MOVLB  0
0A29C:  GOTO   A2B4
0A2A0:  MOVLB  0
0A2A2:  MOVLB  2
0A2A4:  MOVF   x12,W
0A2A6:  SUBLW  40
0A2A8:  BTFSS  FD8.0
0A2AA:  BRA    A2B2
0A2AC:  MOVLB  0
0A2AE:  GOTO   A2BC
0A2B2:  MOVLB  0
0A2B4:  CLRF   03
0A2B6:  MOVLW  40
0A2B8:  GOTO   A2C6
0A2BC:  MOVFF  213,03
0A2C0:  MOVLB  2
0A2C2:  MOVF   x12,W
0A2C4:  MOVLB  0
0A2C6:  MOVLB  2
0A2C8:  MOVWF  x5A
0A2CA:  MOVFF  03,25B
0A2CE:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
0A2D0:  MOVFF  111,2E5
0A2D4:  MOVFF  110,2E4
0A2D8:  MOVFF  10F,2E3
0A2DC:  MOVFF  10E,2E2
0A2E0:  MOVFF  219,2E9
0A2E4:  MOVFF  218,2E8
0A2E8:  MOVFF  217,2E7
0A2EC:  MOVFF  216,2E6
0A2F0:  MOVLW  02
0A2F2:  MOVLB  2
0A2F4:  MOVWF  xEB
0A2F6:  MOVLW  1A
0A2F8:  MOVWF  xEA
0A2FA:  CLRF   xEF
0A2FC:  CLRF   xEE
0A2FE:  MOVFF  25B,2ED
0A302:  MOVFF  25A,2EC
0A306:  MOVLB  0
0A308:  CALL   27C4
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
0A30C:  MOVFF  115,A59
0A310:  MOVFF  114,A58
0A314:  MOVFF  113,A57
0A318:  MOVFF  112,A56
0A31C:  MOVFF  201,A5D
0A320:  MOVFF  200,A5C
0A324:  MOVFF  1FF,A5B
0A328:  MOVFF  1FE,A5A
0A32C:  MOVLW  02
0A32E:  MOVLB  A
0A330:  MOVWF  x5F
0A332:  MOVLW  1A
0A334:  MOVWF  x5E
0A336:  MOVFF  25B,A61
0A33A:  MOVFF  25A,A60
0A33E:  MOVLB  0
0A340:  CALL   34DE
....................         for (unsigned int32 i = 0; i < chunk; i++)
0A344:  MOVLB  2
0A346:  CLRF   x5F
0A348:  CLRF   x5E
0A34A:  CLRF   x5D
0A34C:  CLRF   x5C
0A34E:  MOVLB  0
0A350:  MOVLB  2
0A352:  MOVF   x5F,F
0A354:  BTFSC  FD8.2
0A356:  BRA    A35E
0A358:  MOVLB  0
0A35A:  GOTO   A3DE
0A35E:  MOVLB  0
0A360:  MOVLB  2
0A362:  MOVF   x5E,F
0A364:  BTFSC  FD8.2
0A366:  BRA    A36E
0A368:  MOVLB  0
0A36A:  GOTO   A3DE
0A36E:  MOVLB  0
0A370:  MOVLB  2
0A372:  MOVF   x5D,W
0A374:  SUBWF  x5B,W
0A376:  BTFSC  FD8.0
0A378:  BRA    A380
0A37A:  MOVLB  0
0A37C:  GOTO   A3DE
0A380:  MOVLB  0
0A382:  BTFSS  FD8.2
0A384:  GOTO   A39A
0A388:  MOVLB  2
0A38A:  MOVF   x5A,W
0A38C:  SUBWF  x5C,W
0A38E:  BTFSS  FD8.0
0A390:  BRA    A398
0A392:  MOVLB  0
0A394:  GOTO   A3DE
0A398:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A39A:  MOVLW  1A
0A39C:  MOVLB  2
0A39E:  ADDWF  x5C,W
0A3A0:  MOVWF  FE9
0A3A2:  MOVLW  02
0A3A4:  ADDWFC x5D,W
0A3A6:  MOVWF  FEA
0A3A8:  MOVFF  FEF,260
0A3AC:  MOVFF  260,264
0A3B0:  MOVLW  37
0A3B2:  MOVWF  x65
0A3B4:  MOVLB  0
0A3B6:  CALL   1E42
0A3BA:  MOVLW  20
0A3BC:  MOVLB  A
0A3BE:  MOVWF  xAD
0A3C0:  MOVLB  0
0A3C2:  CALL   1B6C
0A3C6:  MOVLW  01
0A3C8:  MOVLB  2
0A3CA:  ADDWF  x5C,F
0A3CC:  BTFSC  FD8.0
0A3CE:  INCF   x5D,F
0A3D0:  BTFSC  FD8.2
0A3D2:  INCF   x5E,F
0A3D4:  BTFSC  FD8.2
0A3D6:  INCF   x5F,F
0A3D8:  MOVLB  0
0A3DA:  GOTO   A350
....................         }
....................         src_addr += chunk;
0A3DE:  MOVLB  2
0A3E0:  MOVF   x5A,W
0A3E2:  ADDWF  x16,F
0A3E4:  MOVF   x5B,W
0A3E6:  ADDWFC x17,F
0A3E8:  MOVLW  00
0A3EA:  ADDWFC x18,F
0A3EC:  MOVLW  00
0A3EE:  ADDWFC x19,F
....................         data_write_addr += chunk;
0A3F0:  MOVF   x5A,W
0A3F2:  MOVLB  1
0A3F4:  ADDWF  xFE,F
0A3F6:  MOVLB  2
0A3F8:  MOVF   x5B,W
0A3FA:  MOVLB  1
0A3FC:  ADDWFC xFF,F
0A3FE:  MOVLW  00
0A400:  MOVLB  2
0A402:  ADDWFC x00,F
0A404:  MOVLW  00
0A406:  ADDWFC x01,F
....................         used_size += chunk;
0A408:  MOVF   x5A,W
0A40A:  MOVLB  1
0A40C:  ADDWF  xED,F
0A40E:  MOVLB  2
0A410:  MOVF   x5B,W
0A412:  MOVLB  1
0A414:  ADDWFC xEE,F
0A416:  MOVLW  00
0A418:  ADDWFC xEF,F
0A41A:  MOVLW  00
0A41C:  ADDWFC xF0,F
....................         remaining -= chunk;
0A41E:  MOVLB  2
0A420:  MOVF   x5A,W
0A422:  SUBWF  x12,F
0A424:  MOVF   x5B,W
0A426:  SUBWFB x13,F
0A428:  MOVLW  00
0A42A:  SUBWFB x14,F
0A42C:  MOVLW  00
0A42E:  SUBWFB x15,F
0A430:  MOVLB  0
0A432:  GOTO   A232
....................     }
....................     // write size area
....................     write_smf_header();
0A436:  GOTO   991E
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0A43A:  MOVLB  1
0A43C:  MOVF   x8B,W
0A43E:  MOVWF  FE9
0A440:  MOVF   x8C,W
0A442:  MOVWF  FEA
0A444:  MOVFF  FEF,260
0A448:  MOVFF  260,261
0A44C:  MOVFF  1E4,265
0A450:  MOVFF  1E3,264
0A454:  MOVFF  1E2,263
0A458:  MOVFF  1E1,262
0A45C:  MOVLB  0
0A45E:  GOTO   9AAE
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0A462:  MOVLW  EA
0A464:  MOVWF  FF6
0A466:  MOVLW  08
0A468:  MOVWF  FF7
0A46A:  MOVLW  00
0A46C:  MOVWF  FF8
0A46E:  MOVLW  0C
0A470:  MOVLB  9
0A472:  MOVWF  xC2
0A474:  MOVLB  0
0A476:  CALL   1BEE
0A47A:  MOVLW  41
0A47C:  MOVWF  FE9
0A47E:  MOVFF  1F0,263
0A482:  MOVFF  1EF,262
0A486:  MOVFF  1EE,261
0A48A:  MOVFF  1ED,260
0A48E:  CALL   92F0
0A492:  MOVLW  0D
0A494:  MOVLB  A
0A496:  MOVWF  xAD
0A498:  MOVLB  0
0A49A:  CALL   1B6C
0A49E:  MOVLW  0A
0A4A0:  MOVLB  A
0A4A2:  MOVWF  xAD
0A4A4:  MOVLB  0
0A4A6:  CALL   1B6C
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0A4AA:  MOVLW  FC
0A4AC:  MOVWF  FF6
0A4AE:  MOVLW  08
0A4B0:  MOVWF  FF7
0A4B2:  MOVLW  00
0A4B4:  MOVWF  FF8
0A4B6:  MOVLW  0D
0A4B8:  MOVLB  9
0A4BA:  MOVWF  xC2
0A4BC:  MOVLB  0
0A4BE:  CALL   1BEE
0A4C2:  MOVFF  1F1,264
0A4C6:  MOVLW  1B
0A4C8:  MOVLB  2
0A4CA:  MOVWF  x65
0A4CC:  MOVLB  0
0A4CE:  CALL   6388
0A4D2:  MOVLW  0B
0A4D4:  MOVWF  FF6
0A4D6:  MOVLW  09
0A4D8:  MOVWF  FF7
0A4DA:  MOVLW  00
0A4DC:  MOVWF  FF8
0A4DE:  MOVLW  04
0A4E0:  MOVLB  9
0A4E2:  MOVWF  xC2
0A4E4:  MOVLB  0
0A4E6:  CALL   1BEE
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0A4EA:  MOVLW  10
0A4EC:  MOVWF  FF6
0A4EE:  MOVLW  09
0A4F0:  MOVWF  FF7
0A4F2:  MOVLW  00
0A4F4:  MOVWF  FF8
0A4F6:  CALL   1BBE
....................     fprintf(PC, "____________________\r\n\r\n");
0A4FA:  MOVLW  2A
0A4FC:  MOVWF  FF6
0A4FE:  MOVLW  09
0A500:  MOVWF  FF7
0A502:  MOVLW  00
0A504:  MOVWF  FF8
0A506:  CALL   1BBE
0A50A:  GOTO   B0E0 (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0A60E:  MOVLW  44
0A610:  MOVWF  FF6
0A612:  MOVLW  09
0A614:  MOVWF  FF7
0A616:  MOVLW  00
0A618:  MOVWF  FF8
0A61A:  CALL   1BBE
....................     fprintf(PC, "___Start SMF Read____\r\n");
0A61E:  MOVLW  5E
0A620:  MOVWF  FF6
0A622:  MOVLW  09
0A624:  MOVWF  FF7
0A626:  MOVLW  00
0A628:  MOVWF  FF8
0A62A:  CALL   1BBE
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0A62E:  MOVLB  1
0A630:  MOVF   x8B,W
0A632:  MOVWF  FE9
0A634:  MOVF   x8C,W
0A636:  MOVWF  FEA
0A638:  MOVFF  FEF,1E5
0A63C:  MOVFF  1E5,267
0A640:  MOVLB  0
0A642:  CALL   946C
0A646:  MOVFF  02,03
0A64A:  MOVF   01,W
0A64C:  MOVWF  FE1
0A64E:  MOVFF  03,FE2
0A652:  MOVLW  01
0A654:  MOVWF  FEA
0A656:  MOVLW  CD
0A658:  MOVWF  FE9
0A65A:  MOVLW  08
0A65C:  MOVWF  01
0A65E:  MOVFF  FE6,FEE
0A662:  DECFSZ 01,F
0A664:  GOTO   A65E
0A668:  MOVLW  04
0A66A:  MOVLB  1
0A66C:  ADDWF  x8B,W
0A66E:  MOVWF  FE9
0A670:  MOVLW  00
0A672:  ADDWFC x8C,W
0A674:  MOVWF  FEA
0A676:  MOVFF  FEF,1D5
0A67A:  MOVFF  FEC,1D6
0A67E:  MOVFF  FEC,1D7
0A682:  MOVFF  FEC,1D8
0A686:  MOVF   FED,F
0A688:  MOVF   FED,F
0A68A:  MOVF   FED,F
0A68C:  MOVLW  08
0A68E:  ADDWF  x8B,W
0A690:  MOVWF  FE9
0A692:  MOVLW  00
0A694:  ADDWFC x8C,W
0A696:  MOVWF  FEA
0A698:  MOVFF  FEF,1D9
0A69C:  MOVFF  FEC,1DA
0A6A0:  MOVFF  FEC,1DB
0A6A4:  MOVFF  FEC,1DC
0A6A8:  MOVF   FED,F
0A6AA:  MOVF   FED,F
0A6AC:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0A6AE:  MOVLW  76
0A6B0:  MOVWF  FF6
0A6B2:  MOVLW  09
0A6B4:  MOVWF  FF7
0A6B6:  MOVLW  00
0A6B8:  MOVWF  FF8
0A6BA:  MOVLW  21
0A6BC:  MOVLB  9
0A6BE:  MOVWF  xC2
0A6C0:  MOVLB  0
0A6C2:  CALL   1BEE
0A6C6:  MOVFF  1D8,264
0A6CA:  MOVLW  37
0A6CC:  MOVLB  2
0A6CE:  MOVWF  x65
0A6D0:  MOVLB  0
0A6D2:  CALL   1E42
0A6D6:  MOVFF  1D7,264
0A6DA:  MOVLW  37
0A6DC:  MOVLB  2
0A6DE:  MOVWF  x65
0A6E0:  MOVLB  0
0A6E2:  CALL   1E42
0A6E6:  MOVFF  1D6,264
0A6EA:  MOVLW  37
0A6EC:  MOVLB  2
0A6EE:  MOVWF  x65
0A6F0:  MOVLB  0
0A6F2:  CALL   1E42
0A6F6:  MOVFF  1D5,264
0A6FA:  MOVLW  37
0A6FC:  MOVLB  2
0A6FE:  MOVWF  x65
0A700:  MOVLB  0
0A702:  CALL   1E42
0A706:  MOVLW  0D
0A708:  MOVLB  A
0A70A:  MOVWF  xAD
0A70C:  MOVLB  0
0A70E:  CALL   1B6C
0A712:  MOVLW  0A
0A714:  MOVLB  A
0A716:  MOVWF  xAD
0A718:  MOVLB  0
0A71A:  CALL   1B6C
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0A71E:  MOVLW  9E
0A720:  MOVWF  FF6
0A722:  MOVLW  09
0A724:  MOVWF  FF7
0A726:  MOVLW  00
0A728:  MOVWF  FF8
0A72A:  MOVLW  21
0A72C:  MOVLB  9
0A72E:  MOVWF  xC2
0A730:  MOVLB  0
0A732:  CALL   1BEE
0A736:  MOVLW  41
0A738:  MOVWF  FE9
0A73A:  MOVFF  1DC,1E8
0A73E:  MOVFF  1DB,1E7
0A742:  MOVFF  1DA,1E6
0A746:  MOVFF  1D9,1E5
0A74A:  CALL   A50E
0A74E:  MOVLW  C2
0A750:  MOVWF  FF6
0A752:  MOVLW  09
0A754:  MOVWF  FF7
0A756:  MOVLW  00
0A758:  MOVWF  FF8
0A75A:  MOVLW  04
0A75C:  MOVLB  9
0A75E:  MOVWF  xC2
0A760:  MOVLB  0
0A762:  CALL   1BEE
0A766:  MOVFF  1DC,264
0A76A:  MOVLW  57
0A76C:  MOVLB  2
0A76E:  MOVWF  x65
0A770:  MOVLB  0
0A772:  CALL   1E42
0A776:  MOVFF  1DB,264
0A77A:  MOVLW  57
0A77C:  MOVLB  2
0A77E:  MOVWF  x65
0A780:  MOVLB  0
0A782:  CALL   1E42
0A786:  MOVFF  1DA,264
0A78A:  MOVLW  57
0A78C:  MOVLB  2
0A78E:  MOVWF  x65
0A790:  MOVLB  0
0A792:  CALL   1E42
0A796:  MOVFF  1D9,264
0A79A:  MOVLW  57
0A79C:  MOVLB  2
0A79E:  MOVWF  x65
0A7A0:  MOVLB  0
0A7A2:  CALL   1E42
0A7A6:  MOVLW  C9
0A7A8:  MOVWF  FF6
0A7AA:  MOVLW  09
0A7AC:  MOVWF  FF7
0A7AE:  MOVLW  00
0A7B0:  MOVWF  FF8
0A7B2:  MOVLW  05
0A7B4:  MOVLB  9
0A7B6:  MOVWF  xC2
0A7B8:  MOVLB  0
0A7BA:  CALL   1BEE
.................... 
....................     if (!is_connect(smf)){
0A7BE:  MOVFF  115,263
0A7C2:  MOVFF  114,262
0A7C6:  MOVFF  113,261
0A7CA:  MOVFF  112,260
0A7CE:  CALL   26D8
0A7D2:  MOVF   01,F
0A7D4:  BTFSS  FD8.2
0A7D6:  GOTO   A7EA
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A7DA:  MOVLW  D0
0A7DC:  MOVWF  FF6
0A7DE:  MOVLW  09
0A7E0:  MOVWF  FF7
0A7E2:  MOVLW  00
0A7E4:  MOVWF  FF8
0A7E6:  CALL   1BBE
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0A7EA:  MOVLW  EE
0A7EC:  MOVWF  FF6
0A7EE:  MOVLW  09
0A7F0:  MOVWF  FF7
0A7F2:  MOVLW  00
0A7F4:  MOVWF  FF8
0A7F6:  CALL   1BBE
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0A7FA:  MOVFF  1D8,1E0
0A7FE:  MOVFF  1D7,1DF
0A802:  MOVFF  1D6,1DE
0A806:  MOVFF  1D5,1DD
0A80A:  MOVLB  1
0A80C:  MOVF   xD9,W
0A80E:  ADDWF  xD5,W
0A810:  MOVWF  00
0A812:  MOVF   xDA,W
0A814:  ADDWFC xD6,W
0A816:  MOVWF  01
0A818:  MOVF   xDB,W
0A81A:  ADDWFC xD7,W
0A81C:  MOVWF  02
0A81E:  MOVF   xDC,W
0A820:  ADDWFC xD8,W
0A822:  MOVWF  03
0A824:  MOVF   xE0,W
0A826:  SUBWF  03,W
0A828:  BTFSC  FD8.0
0A82A:  BRA    A832
0A82C:  MOVLB  0
0A82E:  GOTO   A97A
0A832:  MOVLB  0
0A834:  BTFSS  FD8.2
0A836:  GOTO   A87C
0A83A:  MOVLB  1
0A83C:  MOVF   xDF,W
0A83E:  SUBWF  02,W
0A840:  BTFSC  FD8.0
0A842:  BRA    A84A
0A844:  MOVLB  0
0A846:  GOTO   A97A
0A84A:  MOVLB  0
0A84C:  BTFSS  FD8.2
0A84E:  GOTO   A87C
0A852:  MOVLB  1
0A854:  MOVF   xDE,W
0A856:  SUBWF  01,W
0A858:  BTFSC  FD8.0
0A85A:  BRA    A862
0A85C:  MOVLB  0
0A85E:  GOTO   A97A
0A862:  MOVLB  0
0A864:  BTFSS  FD8.2
0A866:  GOTO   A87C
0A86A:  MOVF   00,W
0A86C:  MOVLB  1
0A86E:  SUBWF  xDD,W
0A870:  BTFSS  FD8.0
0A872:  BRA    A87A
0A874:  MOVLB  0
0A876:  GOTO   A97A
0A87A:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0A87C:  MOVFF  115,2E5
0A880:  MOVFF  114,2E4
0A884:  MOVFF  113,2E3
0A888:  MOVFF  112,2E2
0A88C:  MOVFF  1E0,2E9
0A890:  MOVFF  1DF,2E8
0A894:  MOVFF  1DE,2E7
0A898:  MOVFF  1DD,2E6
0A89C:  MOVLW  01
0A89E:  MOVLB  2
0A8A0:  MOVWF  xEB
0A8A2:  MOVLW  8D
0A8A4:  MOVWF  xEA
0A8A6:  CLRF   xEF
0A8A8:  CLRF   xEE
0A8AA:  CLRF   xED
0A8AC:  MOVLW  40
0A8AE:  MOVWF  xEC
0A8B0:  MOVLB  0
0A8B2:  CALL   27C4
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0A8B6:  MOVLB  1
0A8B8:  CLRF   xE4
0A8BA:  CLRF   xE3
0A8BC:  CLRF   xE2
0A8BE:  CLRF   xE1
0A8C0:  MOVLB  0
0A8C2:  MOVLB  1
0A8C4:  MOVF   xE4,F
0A8C6:  BTFSC  FD8.2
0A8C8:  BRA    A8D0
0A8CA:  MOVLB  0
0A8CC:  GOTO   A94A
0A8D0:  MOVLB  0
0A8D2:  MOVLB  1
0A8D4:  MOVF   xE3,F
0A8D6:  BTFSC  FD8.2
0A8D8:  BRA    A8E0
0A8DA:  MOVLB  0
0A8DC:  GOTO   A94A
0A8E0:  MOVLB  0
0A8E2:  MOVLB  1
0A8E4:  MOVF   xE2,F
0A8E6:  BTFSC  FD8.2
0A8E8:  BRA    A8F0
0A8EA:  MOVLB  0
0A8EC:  GOTO   A94A
0A8F0:  MOVLB  0
0A8F2:  MOVLB  1
0A8F4:  MOVF   xE1,W
0A8F6:  SUBLW  3F
0A8F8:  BTFSC  FD8.0
0A8FA:  BRA    A902
0A8FC:  MOVLB  0
0A8FE:  GOTO   A94A
0A902:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A904:  MOVLW  8D
0A906:  MOVLB  1
0A908:  ADDWF  xE1,W
0A90A:  MOVWF  FE9
0A90C:  MOVLW  01
0A90E:  ADDWFC xE2,W
0A910:  MOVWF  FEA
0A912:  MOVFF  FEF,1E5
0A916:  MOVFF  1E5,264
0A91A:  MOVLW  37
0A91C:  MOVLB  2
0A91E:  MOVWF  x65
0A920:  MOVLB  0
0A922:  CALL   1E42
0A926:  MOVLW  20
0A928:  MOVLB  A
0A92A:  MOVWF  xAD
0A92C:  MOVLB  0
0A92E:  CALL   1B6C
0A932:  MOVLW  01
0A934:  MOVLB  1
0A936:  ADDWF  xE1,F
0A938:  BTFSC  FD8.0
0A93A:  INCF   xE2,F
0A93C:  BTFSC  FD8.2
0A93E:  INCF   xE3,F
0A940:  BTFSC  FD8.2
0A942:  INCF   xE4,F
0A944:  MOVLB  0
0A946:  GOTO   A8C2
....................         }
....................         fprintf(PC, "\r\n");
0A94A:  MOVLW  0D
0A94C:  MOVLB  A
0A94E:  MOVWF  xAD
0A950:  MOVLB  0
0A952:  CALL   1B6C
0A956:  MOVLW  0A
0A958:  MOVLB  A
0A95A:  MOVWF  xAD
0A95C:  MOVLB  0
0A95E:  CALL   1B6C
0A962:  MOVLW  40
0A964:  MOVLB  1
0A966:  ADDWF  xDD,F
0A968:  MOVLW  00
0A96A:  ADDWFC xDE,F
0A96C:  MOVLW  00
0A96E:  ADDWFC xDF,F
0A970:  MOVLW  00
0A972:  ADDWFC xE0,F
0A974:  MOVLB  0
0A976:  GOTO   A80A
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0A97A:  MOVLW  06
0A97C:  MOVWF  FF6
0A97E:  MOVLW  0A
0A980:  MOVWF  FF7
0A982:  MOVLW  00
0A984:  MOVWF  FF8
0A986:  CALL   1BBE
....................     fprintf(PC, "____________________\r\n\r\n");
0A98A:  MOVLW  1E
0A98C:  MOVWF  FF6
0A98E:  MOVLW  0A
0A990:  MOVWF  FF7
0A992:  MOVLW  00
0A994:  MOVWF  FF8
0A996:  CALL   1BBE
0A99A:  GOTO   B0F0 (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0A99E:  MOVLW  38
0A9A0:  MOVWF  FF6
0A9A2:  MOVLW  0A
0A9A4:  MOVWF  FF7
0A9A6:  MOVLW  00
0A9A8:  MOVWF  FF8
0A9AA:  CALL   1BBE
....................     fprintf(PC, "___Start smf_erase____\r\n");
0A9AE:  MOVLW  52
0A9B0:  MOVWF  FF6
0A9B2:  MOVLW  0A
0A9B4:  MOVWF  FF7
0A9B6:  MOVLW  00
0A9B8:  MOVWF  FF8
0A9BA:  CALL   1BBE
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0A9BE:  MOVLB  1
0A9C0:  MOVF   x8B,W
0A9C2:  MOVWF  FE9
0A9C4:  MOVF   x8C,W
0A9C6:  MOVWF  FEA
0A9C8:  MOVFF  FEF,19D
0A9CC:  MOVFF  19D,267
0A9D0:  MOVLB  0
0A9D2:  CALL   946C
0A9D6:  MOVFF  02,03
0A9DA:  MOVF   01,W
0A9DC:  MOVWF  FE1
0A9DE:  MOVFF  03,FE2
0A9E2:  MOVLW  01
0A9E4:  MOVWF  FEA
0A9E6:  MOVLW  8D
0A9E8:  MOVWF  FE9
0A9EA:  MOVLW  08
0A9EC:  MOVWF  01
0A9EE:  MOVFF  FE6,FEE
0A9F2:  DECFSZ 01,F
0A9F4:  GOTO   A9EE
0A9F8:  MOVLW  04
0A9FA:  MOVLB  1
0A9FC:  ADDWF  x8B,W
0A9FE:  MOVWF  FE9
0AA00:  MOVLW  00
0AA02:  ADDWFC x8C,W
0AA04:  MOVWF  FEA
0AA06:  MOVFF  FEF,195
0AA0A:  MOVFF  FEC,196
0AA0E:  MOVFF  FEC,197
0AA12:  MOVFF  FEC,198
0AA16:  MOVF   FED,F
0AA18:  MOVF   FED,F
0AA1A:  MOVF   FED,F
0AA1C:  MOVLW  08
0AA1E:  ADDWF  x8B,W
0AA20:  MOVWF  FE9
0AA22:  MOVLW  00
0AA24:  ADDWFC x8C,W
0AA26:  MOVWF  FEA
0AA28:  MOVFF  FEF,199
0AA2C:  MOVFF  FEC,19A
0AA30:  MOVFF  FEC,19B
0AA34:  MOVFF  FEC,19C
0AA38:  MOVF   FED,F
0AA3A:  MOVF   FED,F
0AA3C:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0AA3E:  MOVLW  6C
0AA40:  MOVWF  FF6
0AA42:  MOVLW  0A
0AA44:  MOVWF  FF7
0AA46:  MOVLW  00
0AA48:  MOVWF  FF8
0AA4A:  MOVLW  22
0AA4C:  MOVLB  9
0AA4E:  MOVWF  xC2
0AA50:  MOVLB  0
0AA52:  CALL   1BEE
0AA56:  MOVFF  198,264
0AA5A:  MOVLW  37
0AA5C:  MOVLB  2
0AA5E:  MOVWF  x65
0AA60:  MOVLB  0
0AA62:  CALL   1E42
0AA66:  MOVFF  197,264
0AA6A:  MOVLW  37
0AA6C:  MOVLB  2
0AA6E:  MOVWF  x65
0AA70:  MOVLB  0
0AA72:  CALL   1E42
0AA76:  MOVFF  196,264
0AA7A:  MOVLW  37
0AA7C:  MOVLB  2
0AA7E:  MOVWF  x65
0AA80:  MOVLB  0
0AA82:  CALL   1E42
0AA86:  MOVFF  195,264
0AA8A:  MOVLW  37
0AA8C:  MOVLB  2
0AA8E:  MOVWF  x65
0AA90:  MOVLB  0
0AA92:  CALL   1E42
0AA96:  MOVLW  0D
0AA98:  MOVLB  A
0AA9A:  MOVWF  xAD
0AA9C:  MOVLB  0
0AA9E:  CALL   1B6C
0AAA2:  MOVLW  0A
0AAA4:  MOVLB  A
0AAA6:  MOVWF  xAD
0AAA8:  MOVLB  0
0AAAA:  CALL   1B6C
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0AAAE:  MOVLW  94
0AAB0:  MOVWF  FF6
0AAB2:  MOVLW  0A
0AAB4:  MOVWF  FF7
0AAB6:  MOVLW  00
0AAB8:  MOVWF  FF8
0AABA:  MOVLW  22
0AABC:  MOVLB  9
0AABE:  MOVWF  xC2
0AAC0:  MOVLB  0
0AAC2:  CALL   1BEE
0AAC6:  MOVLW  41
0AAC8:  MOVWF  FE9
0AACA:  MOVFF  19C,1E8
0AACE:  MOVFF  19B,1E7
0AAD2:  MOVFF  19A,1E6
0AAD6:  MOVFF  199,1E5
0AADA:  CALL   A50E
0AADE:  MOVLW  B9
0AAE0:  MOVWF  FF6
0AAE2:  MOVLW  0A
0AAE4:  MOVWF  FF7
0AAE6:  MOVLW  00
0AAE8:  MOVWF  FF8
0AAEA:  MOVLW  04
0AAEC:  MOVLB  9
0AAEE:  MOVWF  xC2
0AAF0:  MOVLB  0
0AAF2:  CALL   1BEE
0AAF6:  MOVFF  19C,264
0AAFA:  MOVLW  57
0AAFC:  MOVLB  2
0AAFE:  MOVWF  x65
0AB00:  MOVLB  0
0AB02:  CALL   1E42
0AB06:  MOVFF  19B,264
0AB0A:  MOVLW  57
0AB0C:  MOVLB  2
0AB0E:  MOVWF  x65
0AB10:  MOVLB  0
0AB12:  CALL   1E42
0AB16:  MOVFF  19A,264
0AB1A:  MOVLW  57
0AB1C:  MOVLB  2
0AB1E:  MOVWF  x65
0AB20:  MOVLB  0
0AB22:  CALL   1E42
0AB26:  MOVFF  199,264
0AB2A:  MOVLW  57
0AB2C:  MOVLB  2
0AB2E:  MOVWF  x65
0AB30:  MOVLB  0
0AB32:  CALL   1E42
0AB36:  MOVLW  C0
0AB38:  MOVWF  FF6
0AB3A:  MOVLW  0A
0AB3C:  MOVWF  FF7
0AB3E:  MOVLW  00
0AB40:  MOVWF  FF8
0AB42:  MOVLW  05
0AB44:  MOVLB  9
0AB46:  MOVWF  xC2
0AB48:  MOVLB  0
0AB4A:  CALL   1BEE
.................... 
....................     if (!is_connect(smf)){
0AB4E:  MOVFF  115,263
0AB52:  MOVFF  114,262
0AB56:  MOVFF  113,261
0AB5A:  MOVFF  112,260
0AB5E:  CALL   26D8
0AB62:  MOVF   01,F
0AB64:  BTFSS  FD8.2
0AB66:  GOTO   AB7E
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0AB6A:  MOVLW  C6
0AB6C:  MOVWF  FF6
0AB6E:  MOVLW  0A
0AB70:  MOVWF  FF7
0AB72:  MOVLW  00
0AB74:  MOVWF  FF8
0AB76:  CALL   1BBE
....................         return;
0AB7A:  GOTO   AEB8
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0AB7E:  MOVLB  1
0AB80:  MOVF   x98,W
0AB82:  SUBWF  x90,W
0AB84:  BTFSC  FD8.0
0AB86:  BRA    AB8E
0AB88:  MOVLB  0
0AB8A:  GOTO   ABD8
0AB8E:  MOVLB  0
0AB90:  BTFSS  FD8.2
0AB92:  GOTO   AC32
0AB96:  MOVLB  1
0AB98:  MOVF   x97,W
0AB9A:  SUBWF  x8F,W
0AB9C:  BTFSC  FD8.0
0AB9E:  BRA    ABA6
0ABA0:  MOVLB  0
0ABA2:  GOTO   ABD8
0ABA6:  MOVLB  0
0ABA8:  BTFSS  FD8.2
0ABAA:  GOTO   AC32
0ABAE:  MOVLB  1
0ABB0:  MOVF   x96,W
0ABB2:  SUBWF  x8E,W
0ABB4:  BTFSC  FD8.0
0ABB6:  BRA    ABBE
0ABB8:  MOVLB  0
0ABBA:  GOTO   ABD8
0ABBE:  MOVLB  0
0ABC0:  BTFSS  FD8.2
0ABC2:  GOTO   AC32
0ABC6:  MOVLB  1
0ABC8:  MOVF   x8D,W
0ABCA:  SUBWF  x95,W
0ABCC:  BTFSC  FD8.0
0ABCE:  BRA    ABD6
0ABD0:  MOVLB  0
0ABD2:  GOTO   AC32
0ABD6:  MOVLB  0
0ABD8:  MOVLB  1
0ABDA:  MOVF   x94,W
0ABDC:  SUBWF  x98,W
0ABDE:  BTFSC  FD8.0
0ABE0:  BRA    ABE8
0ABE2:  MOVLB  0
0ABE4:  GOTO   AD56
0ABE8:  MOVLB  0
0ABEA:  BTFSS  FD8.2
0ABEC:  GOTO   AC32
0ABF0:  MOVLB  1
0ABF2:  MOVF   x93,W
0ABF4:  SUBWF  x97,W
0ABF6:  BTFSC  FD8.0
0ABF8:  BRA    AC00
0ABFA:  MOVLB  0
0ABFC:  GOTO   AD56
0AC00:  MOVLB  0
0AC02:  BTFSS  FD8.2
0AC04:  GOTO   AC32
0AC08:  MOVLB  1
0AC0A:  MOVF   x92,W
0AC0C:  SUBWF  x96,W
0AC0E:  BTFSC  FD8.0
0AC10:  BRA    AC18
0AC12:  MOVLB  0
0AC14:  GOTO   AD56
0AC18:  MOVLB  0
0AC1A:  BTFSS  FD8.2
0AC1C:  GOTO   AC32
0AC20:  MOVLB  1
0AC22:  MOVF   x91,W
0AC24:  SUBWF  x95,W
0AC26:  BTFSC  FD8.0
0AC28:  BRA    AC30
0AC2A:  MOVLB  0
0AC2C:  GOTO   AD56
0AC30:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0AC32:  MOVLW  E4
0AC34:  MOVWF  FF6
0AC36:  MOVLW  0A
0AC38:  MOVWF  FF7
0AC3A:  MOVLW  00
0AC3C:  MOVWF  FF8
0AC3E:  MOVLW  1E
0AC40:  MOVLB  9
0AC42:  MOVWF  xC2
0AC44:  MOVLB  0
0AC46:  CALL   1BEE
0AC4A:  MOVFF  198,264
0AC4E:  MOVLW  37
0AC50:  MOVLB  2
0AC52:  MOVWF  x65
0AC54:  MOVLB  0
0AC56:  CALL   1E42
0AC5A:  MOVFF  197,264
0AC5E:  MOVLW  37
0AC60:  MOVLB  2
0AC62:  MOVWF  x65
0AC64:  MOVLB  0
0AC66:  CALL   1E42
0AC6A:  MOVFF  196,264
0AC6E:  MOVLW  37
0AC70:  MOVLB  2
0AC72:  MOVWF  x65
0AC74:  MOVLB  0
0AC76:  CALL   1E42
0AC7A:  MOVFF  195,264
0AC7E:  MOVLW  37
0AC80:  MOVLB  2
0AC82:  MOVWF  x65
0AC84:  MOVLB  0
0AC86:  CALL   1E42
0AC8A:  MOVLW  05
0AC8C:  MOVWF  FF6
0AC8E:  MOVLW  0B
0AC90:  MOVWF  FF7
0AC92:  MOVLW  00
0AC94:  MOVWF  FF8
0AC96:  MOVLW  1D
0AC98:  MOVLB  9
0AC9A:  MOVWF  xC2
0AC9C:  MOVLB  0
0AC9E:  CALL   1BEE
0ACA2:  MOVFF  190,264
0ACA6:  MOVLW  37
0ACA8:  MOVLB  2
0ACAA:  MOVWF  x65
0ACAC:  MOVLB  0
0ACAE:  CALL   1E42
0ACB2:  MOVFF  18F,264
0ACB6:  MOVLW  37
0ACB8:  MOVLB  2
0ACBA:  MOVWF  x65
0ACBC:  MOVLB  0
0ACBE:  CALL   1E42
0ACC2:  MOVFF  18E,264
0ACC6:  MOVLW  37
0ACC8:  MOVLB  2
0ACCA:  MOVWF  x65
0ACCC:  MOVLB  0
0ACCE:  CALL   1E42
0ACD2:  MOVFF  18D,264
0ACD6:  MOVLW  37
0ACD8:  MOVLB  2
0ACDA:  MOVWF  x65
0ACDC:  MOVLB  0
0ACDE:  CALL   1E42
0ACE2:  MOVLW  25
0ACE4:  MOVWF  FF6
0ACE6:  MOVLW  0B
0ACE8:  MOVWF  FF7
0ACEA:  MOVLW  00
0ACEC:  MOVWF  FF8
0ACEE:  MOVLW  05
0ACF0:  MOVLB  9
0ACF2:  MOVWF  xC2
0ACF4:  MOVLB  0
0ACF6:  CALL   1BEE
0ACFA:  MOVFF  194,264
0ACFE:  MOVLW  37
0AD00:  MOVLB  2
0AD02:  MOVWF  x65
0AD04:  MOVLB  0
0AD06:  CALL   1E42
0AD0A:  MOVFF  193,264
0AD0E:  MOVLW  37
0AD10:  MOVLB  2
0AD12:  MOVWF  x65
0AD14:  MOVLB  0
0AD16:  CALL   1E42
0AD1A:  MOVFF  192,264
0AD1E:  MOVLW  37
0AD20:  MOVLB  2
0AD22:  MOVWF  x65
0AD24:  MOVLB  0
0AD26:  CALL   1E42
0AD2A:  MOVFF  191,264
0AD2E:  MOVLW  37
0AD30:  MOVLB  2
0AD32:  MOVWF  x65
0AD34:  MOVLB  0
0AD36:  CALL   1E42
0AD3A:  MOVLW  2D
0AD3C:  MOVWF  FF6
0AD3E:  MOVLW  0B
0AD40:  MOVWF  FF7
0AD42:  MOVLW  00
0AD44:  MOVWF  FF8
0AD46:  MOVLW  03
0AD48:  MOVLB  9
0AD4A:  MOVWF  xC2
0AD4C:  MOVLB  0
0AD4E:  CALL   1BEE
....................         return;
0AD52:  GOTO   AEB8
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0AD56:  MOVLB  1
0AD58:  MOVF   x99,W
0AD5A:  ADDWF  x95,W
0AD5C:  MOVWF  x9D
0AD5E:  MOVF   x9A,W
0AD60:  ADDWFC x96,W
0AD62:  MOVWF  x9E
0AD64:  MOVF   x9B,W
0AD66:  ADDWFC x97,W
0AD68:  MOVWF  x9F
0AD6A:  MOVF   x9C,W
0AD6C:  ADDWFC x98,W
0AD6E:  MOVWF  xA0
0AD70:  MOVF   x94,W
0AD72:  SUBWF  xA0,W
0AD74:  BTFSC  FD8.0
0AD76:  BRA    AD7E
0AD78:  MOVLB  0
0AD7A:  GOTO   AE64
0AD7E:  MOVLB  0
0AD80:  BTFSS  FD8.2
0AD82:  GOTO   ADC8
0AD86:  MOVLB  1
0AD88:  MOVF   x93,W
0AD8A:  SUBWF  x9F,W
0AD8C:  BTFSC  FD8.0
0AD8E:  BRA    AD96
0AD90:  MOVLB  0
0AD92:  GOTO   AE64
0AD96:  MOVLB  0
0AD98:  BTFSS  FD8.2
0AD9A:  GOTO   ADC8
0AD9E:  MOVLB  1
0ADA0:  MOVF   x92,W
0ADA2:  SUBWF  x9E,W
0ADA4:  BTFSC  FD8.0
0ADA6:  BRA    ADAE
0ADA8:  MOVLB  0
0ADAA:  GOTO   AE64
0ADAE:  MOVLB  0
0ADB0:  BTFSS  FD8.2
0ADB2:  GOTO   ADC8
0ADB6:  MOVLB  1
0ADB8:  MOVF   x9D,W
0ADBA:  SUBWF  x91,W
0ADBC:  BTFSS  FD8.0
0ADBE:  BRA    ADC6
0ADC0:  MOVLB  0
0ADC2:  GOTO   AE64
0ADC6:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0ADC8:  MOVLW  32
0ADCA:  MOVWF  FF6
0ADCC:  MOVLW  0B
0ADCE:  MOVWF  FF7
0ADD0:  MOVLW  00
0ADD2:  MOVWF  FF8
0ADD4:  MOVLW  3A
0ADD6:  MOVLB  9
0ADD8:  MOVWF  xC2
0ADDA:  MOVLB  0
0ADDC:  CALL   1BEE
0ADE0:  MOVFF  194,264
0ADE4:  MOVLW  37
0ADE6:  MOVLB  2
0ADE8:  MOVWF  x65
0ADEA:  MOVLB  0
0ADEC:  CALL   1E42
0ADF0:  MOVFF  193,264
0ADF4:  MOVLW  37
0ADF6:  MOVLB  2
0ADF8:  MOVWF  x65
0ADFA:  MOVLB  0
0ADFC:  CALL   1E42
0AE00:  MOVFF  192,264
0AE04:  MOVLW  37
0AE06:  MOVLB  2
0AE08:  MOVWF  x65
0AE0A:  MOVLB  0
0AE0C:  CALL   1E42
0AE10:  MOVFF  191,264
0AE14:  MOVLW  37
0AE16:  MOVLB  2
0AE18:  MOVWF  x65
0AE1A:  MOVLB  0
0AE1C:  CALL   1E42
0AE20:  MOVLW  0D
0AE22:  MOVLB  A
0AE24:  MOVWF  xAD
0AE26:  MOVLB  0
0AE28:  CALL   1B6C
0AE2C:  MOVLW  0A
0AE2E:  MOVLB  A
0AE30:  MOVWF  xAD
0AE32:  MOVLB  0
0AE34:  CALL   1B6C
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0AE38:  MOVLW  72
0AE3A:  MOVWF  FF6
0AE3C:  MOVLW  0B
0AE3E:  MOVWF  FF7
0AE40:  MOVLW  00
0AE42:  MOVWF  FF8
0AE44:  CALL   1BBE
....................         erase_size = mission_type.end_address - erase_address;
0AE48:  MOVLB  1
0AE4A:  MOVF   x95,W
0AE4C:  SUBWF  x91,W
0AE4E:  MOVWF  x99
0AE50:  MOVF   x96,W
0AE52:  SUBWFB x92,W
0AE54:  MOVWF  x9A
0AE56:  MOVF   x97,W
0AE58:  SUBWFB x93,W
0AE5A:  MOVWF  x9B
0AE5C:  MOVF   x98,W
0AE5E:  SUBWFB x94,W
0AE60:  MOVWF  x9C
0AE62:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0AE64:  MOVLW  A6
0AE66:  MOVWF  FF6
0AE68:  MOVLW  0B
0AE6A:  MOVWF  FF7
0AE6C:  MOVLW  00
0AE6E:  MOVWF  FF8
0AE70:  CALL   1BBE
....................     subsector_4kByte_erase(smf, erase_address);
0AE74:  MOVFF  115,2E5
0AE78:  MOVFF  114,2E4
0AE7C:  MOVFF  113,2E3
0AE80:  MOVFF  112,2E2
0AE84:  MOVFF  198,2E9
0AE88:  MOVFF  197,2E8
0AE8C:  MOVFF  196,2E7
0AE90:  MOVFF  195,2E6
0AE94:  CALL   4680
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0AE98:  MOVLW  D8
0AE9A:  MOVWF  FF6
0AE9C:  MOVLW  0B
0AE9E:  MOVWF  FF7
0AEA0:  MOVLW  00
0AEA2:  MOVWF  FF8
0AEA4:  CALL   1BBE
....................     fprintf(PC, "____________________\r\n\r\n");
0AEA8:  MOVLW  F2
0AEAA:  MOVWF  FF6
0AEAC:  MOVLW  0B
0AEAE:  MOVWF  FF7
0AEB0:  MOVLW  00
0AEB2:  MOVWF  FF8
0AEB4:  CALL   1BBE
0AEB8:  GOTO   B100 (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
09AAE:  GOTO   A462 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
0991A:  GOTO   A00C (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"                // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"             // ツールライブラリ
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/smf_queue.h"              // SMFキュー管理
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
02FDC:  MOVLW  78
02FDE:  MOVWF  FF6
02FE0:  MOVLW  0C
02FE2:  MOVWF  FF7
02FE4:  MOVLW  00
02FE6:  MOVWF  FF8
02FE8:  CALL   1BBE
....................     output_high(MIS_FM_CS);
02FEC:  MOVLW  DB
02FEE:  MOVWF  F92
02FF0:  BSF    F89.5
....................     output_high(SMF_CS);
02FF2:  MOVLW  DB
02FF4:  MOVWF  F92
02FF6:  BSF    F89.2
....................     delay_ms(100);
02FF8:  MOVLW  64
02FFA:  MOVLB  A
02FFC:  MOVWF  x6E
02FFE:  MOVLB  0
03000:  CALL   1B3E
.................... 
....................     // 読み込みID処理 ・・・(既存そのまま)
....................     if (is_connect(mis_fm)) {
03004:  MOVFF  111,263
03008:  MOVFF  110,262
0300C:  MOVFF  10F,261
03010:  MOVFF  10E,260
03014:  CALL   26D8
03018:  MOVF   01,F
0301A:  BTFSC  FD8.2
0301C:  GOTO   3034
....................         fprintf(PC, "\t[MIS FM] Connected\r\n");
03020:  MOVLW  94
03022:  MOVWF  FF6
03024:  MOVLW  0C
03026:  MOVWF  FF7
03028:  MOVLW  00
0302A:  MOVWF  FF8
0302C:  CALL   1BBE
....................     } else {
03030:  GOTO   3048
....................         fprintf(PC, "\t[MIS FM] Not Connected\r\n");
03034:  MOVLW  AA
03036:  MOVWF  FF6
03038:  MOVLW  0C
0303A:  MOVWF  FF7
0303C:  MOVLW  00
0303E:  MOVWF  FF8
03040:  CALL   1BBE
....................         return;
03044:  GOTO   31BE
....................     }
.................... 
....................     if (is_connect(smf)) {
03048:  MOVFF  115,263
0304C:  MOVFF  114,262
03050:  MOVFF  113,261
03054:  MOVFF  112,260
03058:  CALL   26D8
0305C:  MOVF   01,F
0305E:  BTFSC  FD8.2
03060:  GOTO   3078
....................         fprintf(PC, "\t[SMF] Connected\r\n");
03064:  MOVLW  C4
03066:  MOVWF  FF6
03068:  MOVLW  0C
0306A:  MOVWF  FF7
0306C:  MOVLW  00
0306E:  MOVWF  FF8
03070:  CALL   1BBE
....................     } else {
03074:  GOTO   308C
....................         fprintf(PC, "\t[SMF] Not Connected\r\n");
03078:  MOVLW  D8
0307A:  MOVWF  FF6
0307C:  MOVLW  0C
0307E:  MOVWF  FF7
03080:  MOVLW  00
03082:  MOVWF  FF8
03084:  CALL   1BBE
....................         return;
03088:  GOTO   31BE
....................     }
.................... 
....................     //=== MIS_FM カウンタテーブル読出し ===//
....................     FlashData_t flash_data;
....................     memset(flash_data.bytes, 0, PACKET_SIZE);
0308C:  MOVLW  01
0308E:  MOVWF  FEA
03090:  MOVLW  D3
03092:  MOVWF  FE9
03094:  CLRF   00
03096:  CLRF   02
03098:  MOVLW  40
0309A:  MOVWF  01
0309C:  CALL   27A0
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
030A0:  MOVFF  111,2E5
030A4:  MOVFF  110,2E4
030A8:  MOVFF  10F,2E3
030AC:  MOVFF  10E,2E2
030B0:  MOVLB  2
030B2:  CLRF   xE9
030B4:  CLRF   xE8
030B6:  CLRF   xE7
030B8:  CLRF   xE6
030BA:  MOVLW  01
030BC:  MOVWF  xEB
030BE:  MOVLW  D3
030C0:  MOVWF  xEA
030C2:  CLRF   xEF
030C4:  CLRF   xEE
030C6:  CLRF   xED
030C8:  MOVLW  40
030CA:  MOVWF  xEC
030CC:  MOVLB  0
030CE:  CALL   27C4
.................... 
....................     // CRC 検証
....................     if (flash_data.packet.crc != calc_crc8(flash_data.bytes, PACKET_SIZE - 1)) {
030D2:  MOVLW  01
030D4:  MOVLB  A
030D6:  MOVWF  xAE
030D8:  MOVLW  D3
030DA:  MOVWF  xAD
030DC:  MOVLW  3F
030DE:  MOVWF  xAF
030E0:  MOVLB  0
030E2:  CALL   29DC
030E6:  MOVF   01,W
030E8:  MOVLB  2
030EA:  SUBWF  x12,W
030EC:  BTFSS  FD8.2
030EE:  BRA    30F6
030F0:  MOVLB  0
030F2:  GOTO   3108
030F6:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error -> initialize counters\r\n");
030F8:  MOVLW  F0
030FA:  MOVWF  FF6
030FC:  MOVLW  0C
030FE:  MOVWF  FF7
03100:  MOVLW  00
03102:  MOVWF  FF8
03104:  CALL   1BBE
....................         // デフォルト初期化
....................         /*
....................         piclog_data.id        = FLASH_ID_PICLOG;
....................         environment_data.id   = FLASH_ID_ENVIRONMENT;
....................         iv_header.id          = FLASH_ID_IV_HEADER;
....................         iv_data.id            = FLASH_ID_IV_DATA;
....................         piclog_data.used_counter = 0;
....................         piclog_data.uncopied_counter = 0;
....................         environment_data.used_counter = 0;
....................         environment_data.uncopied_counter = 0;
....................         iv_header.used_counter = 0;
....................         iv_header.uncopied_counter = 0;
....................         iv_data.used_counter = 0;
....................         iv_data.uncopied_counter = 0;
....................         write_misf_address_area();   // 初期テーブル書込み
....................         print_flash_status();
....................         return;
....................         */
....................     }
.................... 
....................     //=== 個別コピー (キャスト禁止) ===//
....................     piclog_data.id        = FLASH_ID_PICLOG;
03108:  MOVLB  1
0310A:  CLRF   x1E
....................     piclog_data.used_counter     = flash_data.packet.payload.logdata.piclog.used_counter;
0310C:  MOVFF  1D6,122
03110:  MOVFF  1D5,121
03114:  MOVFF  1D4,120
03118:  MOVFF  1D3,11F
....................     piclog_data.uncopied_counter = flash_data.packet.payload.logdata.piclog.uncopied_counter;
0311C:  MOVFF  1DA,126
03120:  MOVFF  1D9,125
03124:  MOVFF  1D8,124
03128:  MOVFF  1D7,123
....................     piclog_data.reserve_counter1 = flash_data.packet.payload.logdata.piclog.reserve_counter1;
0312C:  MOVFF  1DB,127
....................     piclog_data.reserve_counter2 = flash_data.packet.payload.logdata.piclog.reserve_counter2;
03130:  MOVFF  1DC,128
.................... 
....................     environment_data.id        = FLASH_ID_ENVIRONMENT;
03134:  MOVLW  01
03136:  MOVWF  x29
....................     environment_data.used_counter     = flash_data.packet.payload.logdata.environment.used_counter;
03138:  MOVFF  1E0,12D
0313C:  MOVFF  1DF,12C
03140:  MOVFF  1DE,12B
03144:  MOVFF  1DD,12A
....................     environment_data.uncopied_counter = flash_data.packet.payload.logdata.environment.uncopied_counter;
03148:  MOVFF  1E4,131
0314C:  MOVFF  1E3,130
03150:  MOVFF  1E2,12F
03154:  MOVFF  1E1,12E
....................     environment_data.reserve_counter1 = flash_data.packet.payload.logdata.environment.reserve_counter1;
03158:  MOVFF  1E5,132
....................     environment_data.reserve_counter2 = flash_data.packet.payload.logdata.environment.reserve_counter2;
0315C:  MOVFF  1E6,133
.................... 
....................     iv_header.id        = FLASH_ID_IV_HEADER;
03160:  MOVLW  02
03162:  MOVWF  x34
....................     iv_header.used_counter     = flash_data.packet.payload.logdata.iv_header.used_counter;
03164:  MOVFF  1EA,138
03168:  MOVFF  1E9,137
0316C:  MOVFF  1E8,136
03170:  MOVFF  1E7,135
....................     iv_header.uncopied_counter = flash_data.packet.payload.logdata.iv_header.uncopied_counter;
03174:  MOVFF  1EE,13C
03178:  MOVFF  1ED,13B
0317C:  MOVFF  1EC,13A
03180:  MOVFF  1EB,139
....................     iv_header.reserve_counter1 = flash_data.packet.payload.logdata.iv_header.reserve_counter1;
03184:  MOVFF  1EF,13D
....................     iv_header.reserve_counter2 = flash_data.packet.payload.logdata.iv_header.reserve_counter2;
03188:  MOVFF  1F0,13E
.................... 
....................     iv_data.id        = FLASH_ID_IV_DATA;
0318C:  MOVLW  03
0318E:  MOVWF  x3F
....................     iv_data.used_counter     = flash_data.packet.payload.logdata.iv_data.used_counter;
03190:  MOVFF  1F4,143
03194:  MOVFF  1F3,142
03198:  MOVFF  1F2,141
0319C:  MOVFF  1F1,140
....................     iv_data.uncopied_counter = flash_data.packet.payload.logdata.iv_data.uncopied_counter;
031A0:  MOVFF  1F8,147
031A4:  MOVFF  1F7,146
031A8:  MOVFF  1F6,145
031AC:  MOVFF  1F5,144
....................     iv_data.reserve_counter1 = flash_data.packet.payload.logdata.iv_data.reserve_counter1;
031B0:  MOVFF  1F9,148
....................     iv_data.reserve_counter2 = flash_data.packet.payload.logdata.iv_data.reserve_counter2;
031B4:  MOVFF  1FA,149
.................... 
....................     print_flash_status();
031B8:  MOVLB  0
031BA:  GOTO   2A48
031BE:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table()
.................... {
....................     FlashData_t flash_data;
....................     memset(&flash_data.bytes, 0, sizeof(flash_data.bytes));
*
06750:  MOVLW  0A
06752:  MOVWF  FEA
06754:  MOVLW  5C
06756:  MOVWF  FE9
06758:  CLRF   00
0675A:  CLRF   02
0675C:  MOVLW  40
0675E:  MOVWF  01
06760:  CALL   27A0
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv_header,
....................         &flash_data.packet.payload.logdata.iv_data
....................     };
06764:  MOVLW  0A
06766:  MOVLB  A
06768:  MOVWF  x9D
0676A:  MOVLW  5C
0676C:  MOVWF  x9C
0676E:  MOVLW  0A
06770:  MOVWF  x9F
06772:  MOVLW  66
06774:  MOVWF  x9E
06776:  MOVLW  0A
06778:  MOVWF  xA1
0677A:  MOVLW  70
0677C:  MOVWF  xA0
0677E:  MOVLW  0A
06780:  MOVWF  xA3
06782:  MOVLW  7A
06784:  MOVWF  xA2
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv_header,
....................         &iv_data
....................     };
06786:  MOVLW  01
06788:  MOVWF  xA5
0678A:  MOVLW  1E
0678C:  MOVWF  xA4
0678E:  MOVLW  01
06790:  MOVWF  xA7
06792:  MOVLW  29
06794:  MOVWF  xA6
06796:  MOVLW  01
06798:  MOVWF  xA9
0679A:  MOVLW  34
0679C:  MOVWF  xA8
0679E:  MOVLW  01
067A0:  MOVWF  xAB
067A2:  MOVLW  3F
067A4:  MOVWF  xAA
.................... 
....................     for (int i = 0; i < 4; i++) {
067A6:  CLRF   xAC
067A8:  MOVLB  0
067AA:  MOVLB  A
067AC:  MOVF   xAC,W
067AE:  SUBLW  03
067B0:  BTFSC  FD8.0
067B2:  BRA    67BA
067B4:  MOVLB  0
067B6:  GOTO   6A6E
067BA:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
067BC:  CLRF   03
067BE:  MOVLB  A
067C0:  MOVF   xAC,W
067C2:  MOVWF  02
067C4:  BCF    FD8.0
067C6:  RLCF   02,F
067C8:  RLCF   03,F
067CA:  MOVF   02,W
067CC:  ADDLW  9C
067CE:  MOVWF  01
067D0:  MOVLW  0A
067D2:  ADDWFC 03,F
067D4:  MOVF   01,W
067D6:  MOVWF  xAD
067D8:  MOVFF  03,AAE
067DC:  MOVFF  AAE,FEA
067E0:  MOVFF  AAD,FE9
067E4:  MOVFF  FEC,AB0
067E8:  MOVF   FED,F
067EA:  MOVFF  FEF,AAF
067EE:  MOVF   xAF,W
067F0:  MOVWF  01
067F2:  MOVF   xB0,W
067F4:  MOVWF  03
067F6:  MOVF   01,W
067F8:  MOVWF  xB1
067FA:  MOVFF  03,AB2
067FE:  CLRF   03
06800:  MOVF   xAC,W
06802:  MOVWF  02
06804:  BCF    FD8.0
06806:  RLCF   02,F
06808:  RLCF   03,F
0680A:  MOVF   02,W
0680C:  ADDLW  A4
0680E:  MOVWF  01
06810:  MOVLW  0A
06812:  ADDWFC 03,F
06814:  MOVF   01,W
06816:  MOVWF  xB3
06818:  MOVFF  03,AB4
0681C:  MOVFF  AB4,FEA
06820:  MOVFF  AB3,FE9
06824:  MOVFF  FEC,AB6
06828:  MOVF   FED,F
0682A:  MOVFF  FEF,AB5
0682E:  MOVLW  01
06830:  ADDWF  xB5,W
06832:  MOVWF  FE9
06834:  MOVLW  00
06836:  ADDWFC xB6,W
06838:  MOVWF  FEA
0683A:  MOVFF  FEF,00
0683E:  MOVFF  FEC,01
06842:  MOVFF  FEC,02
06846:  MOVFF  FEC,03
0684A:  MOVF   FED,F
0684C:  MOVF   FED,F
0684E:  MOVF   FED,F
06850:  MOVFF  03,ABA
06854:  MOVFF  02,AB9
06858:  MOVFF  01,AB8
0685C:  MOVFF  00,AB7
06860:  MOVFF  AB2,FEA
06864:  MOVFF  AB1,FE9
06868:  MOVFF  AB7,FEF
0686C:  MOVFF  AB8,FEC
06870:  MOVFF  AB9,FEC
06874:  MOVFF  ABA,FEC
06878:  MOVF   FED,F
0687A:  MOVF   FED,F
0687C:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
0687E:  CLRF   03
06880:  MOVF   xAC,W
06882:  MOVWF  02
06884:  BCF    FD8.0
06886:  RLCF   02,F
06888:  RLCF   03,F
0688A:  MOVF   02,W
0688C:  ADDLW  9C
0688E:  MOVWF  01
06890:  MOVLW  0A
06892:  ADDWFC 03,F
06894:  MOVF   01,W
06896:  MOVWF  xAD
06898:  MOVFF  03,AAE
0689C:  MOVFF  AAE,FEA
068A0:  MOVFF  AAD,FE9
068A4:  MOVFF  FEC,AB0
068A8:  MOVF   FED,F
068AA:  MOVFF  FEF,AAF
068AE:  MOVLW  04
068B0:  ADDWF  xAF,W
068B2:  MOVWF  01
068B4:  MOVLW  00
068B6:  ADDWFC xB0,W
068B8:  MOVWF  03
068BA:  MOVF   01,W
068BC:  MOVWF  xB1
068BE:  MOVFF  03,AB2
068C2:  CLRF   03
068C4:  MOVF   xAC,W
068C6:  MOVWF  02
068C8:  BCF    FD8.0
068CA:  RLCF   02,F
068CC:  RLCF   03,F
068CE:  MOVF   02,W
068D0:  ADDLW  A4
068D2:  MOVWF  01
068D4:  MOVLW  0A
068D6:  ADDWFC 03,F
068D8:  MOVF   01,W
068DA:  MOVWF  xB3
068DC:  MOVFF  03,AB4
068E0:  MOVFF  AB4,FEA
068E4:  MOVFF  AB3,FE9
068E8:  MOVFF  FEC,AB6
068EC:  MOVF   FED,F
068EE:  MOVFF  FEF,AB5
068F2:  MOVLW  05
068F4:  ADDWF  xB5,W
068F6:  MOVWF  FE9
068F8:  MOVLW  00
068FA:  ADDWFC xB6,W
068FC:  MOVWF  FEA
068FE:  MOVFF  FEF,00
06902:  MOVFF  FEC,01
06906:  MOVFF  FEC,02
0690A:  MOVFF  FEC,03
0690E:  MOVF   FED,F
06910:  MOVF   FED,F
06912:  MOVF   FED,F
06914:  MOVFF  03,ABA
06918:  MOVFF  02,AB9
0691C:  MOVFF  01,AB8
06920:  MOVFF  00,AB7
06924:  MOVFF  AB2,FEA
06928:  MOVFF  AB1,FE9
0692C:  MOVFF  AB7,FEF
06930:  MOVFF  AB8,FEC
06934:  MOVFF  AB9,FEC
06938:  MOVFF  ABA,FEC
0693C:  MOVF   FED,F
0693E:  MOVF   FED,F
06940:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
06942:  CLRF   03
06944:  MOVF   xAC,W
06946:  MOVWF  02
06948:  BCF    FD8.0
0694A:  RLCF   02,F
0694C:  RLCF   03,F
0694E:  MOVF   02,W
06950:  ADDLW  9C
06952:  MOVWF  01
06954:  MOVLW  0A
06956:  ADDWFC 03,F
06958:  MOVF   01,W
0695A:  MOVWF  xAD
0695C:  MOVFF  03,AAE
06960:  MOVFF  AAE,FEA
06964:  MOVFF  AAD,FE9
06968:  MOVFF  FEC,AB0
0696C:  MOVF   FED,F
0696E:  MOVFF  FEF,AAF
06972:  MOVLW  08
06974:  ADDWF  xAF,W
06976:  MOVWF  01
06978:  MOVLW  00
0697A:  ADDWFC xB0,W
0697C:  MOVWF  03
0697E:  MOVF   01,W
06980:  MOVWF  xB1
06982:  MOVFF  03,AB2
06986:  CLRF   03
06988:  MOVF   xAC,W
0698A:  MOVWF  02
0698C:  BCF    FD8.0
0698E:  RLCF   02,F
06990:  RLCF   03,F
06992:  MOVF   02,W
06994:  ADDLW  A4
06996:  MOVWF  01
06998:  MOVLW  0A
0699A:  ADDWFC 03,F
0699C:  MOVF   01,W
0699E:  MOVWF  xB3
069A0:  MOVFF  03,AB4
069A4:  MOVFF  AB4,FEA
069A8:  MOVFF  AB3,FE9
069AC:  MOVFF  FEC,AB6
069B0:  MOVF   FED,F
069B2:  MOVFF  FEF,AB5
069B6:  MOVLW  09
069B8:  ADDWF  xB5,W
069BA:  MOVWF  FE9
069BC:  MOVLW  00
069BE:  ADDWFC xB6,W
069C0:  MOVWF  FEA
069C2:  MOVF   FEF,W
069C4:  MOVWF  xB7
069C6:  MOVFF  AB2,FEA
069CA:  MOVFF  AB1,FE9
069CE:  MOVFF  AB7,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
069D2:  CLRF   03
069D4:  MOVF   xAC,W
069D6:  MOVWF  02
069D8:  BCF    FD8.0
069DA:  RLCF   02,F
069DC:  RLCF   03,F
069DE:  MOVF   02,W
069E0:  ADDLW  9C
069E2:  MOVWF  01
069E4:  MOVLW  0A
069E6:  ADDWFC 03,F
069E8:  MOVF   01,W
069EA:  MOVWF  xAD
069EC:  MOVFF  03,AAE
069F0:  MOVFF  AAE,FEA
069F4:  MOVFF  AAD,FE9
069F8:  MOVFF  FEC,AB0
069FC:  MOVF   FED,F
069FE:  MOVFF  FEF,AAF
06A02:  MOVLW  09
06A04:  ADDWF  xAF,W
06A06:  MOVWF  01
06A08:  MOVLW  00
06A0A:  ADDWFC xB0,W
06A0C:  MOVWF  03
06A0E:  MOVF   01,W
06A10:  MOVWF  xB1
06A12:  MOVFF  03,AB2
06A16:  CLRF   03
06A18:  MOVF   xAC,W
06A1A:  MOVWF  02
06A1C:  BCF    FD8.0
06A1E:  RLCF   02,F
06A20:  RLCF   03,F
06A22:  MOVF   02,W
06A24:  ADDLW  A4
06A26:  MOVWF  01
06A28:  MOVLW  0A
06A2A:  ADDWFC 03,F
06A2C:  MOVF   01,W
06A2E:  MOVWF  xB3
06A30:  MOVFF  03,AB4
06A34:  MOVFF  AB4,FEA
06A38:  MOVFF  AB3,FE9
06A3C:  MOVFF  FEC,AB6
06A40:  MOVF   FED,F
06A42:  MOVFF  FEF,AB5
06A46:  MOVLW  0A
06A48:  ADDWF  xB5,W
06A4A:  MOVWF  FE9
06A4C:  MOVLW  00
06A4E:  ADDWFC xB6,W
06A50:  MOVWF  FEA
06A52:  MOVF   FEF,W
06A54:  MOVWF  xB7
06A56:  MOVFF  AB2,FEA
06A5A:  MOVFF  AB1,FE9
06A5E:  MOVFF  AB7,FEF
06A62:  MOVLB  0
06A64:  MOVLB  A
06A66:  INCF   xAC,F
06A68:  MOVLB  0
06A6A:  GOTO   67AA
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
06A6E:  MOVLW  0A
06A70:  MOVLB  A
06A72:  MOVWF  xAE
06A74:  MOVLW  5C
06A76:  MOVWF  xAD
06A78:  MOVLW  3F
06A7A:  MOVWF  xAF
06A7C:  MOVLB  0
06A7E:  CALL   29DC
06A82:  MOVFF  01,A9B
....................     // fprintf(PC, "make table\r\n");
....................     // for (int i = 0; i < PACKET_SIZE; i++) {
....................         // fprintf(PC, "%02X ", flash_data.bytes[i]);
....................     // }
....................     fprintf(PC, "\r\n");
06A86:  MOVLW  0D
06A88:  MOVLB  A
06A8A:  MOVWF  xAD
06A8C:  MOVLB  0
06A8E:  CALL   1B6C
06A92:  MOVLW  0A
06A94:  MOVLB  A
06A96:  MOVWF  xAD
06A98:  MOVLB  0
06A9A:  CALL   1B6C
....................     return flash_data;
06A9E:  MOVLW  5C
06AA0:  MOVWF  01
06AA2:  MOVLW  0A
06AA4:  MOVWF  02
06AA6:  RETURN 0
.................... }
.................... 
.................... 
.................... void write_misf_address_area(void)
06AA8:  CALL   6750
06AAC:  MOVFF  02,03
06AB0:  MOVF   01,W
06AB2:  MOVWF  FE1
06AB4:  MOVFF  03,FE2
06AB8:  MOVLW  0A
06ABA:  MOVWF  FEA
06ABC:  MOVLW  16
06ABE:  MOVWF  FE9
06AC0:  MOVLW  40
06AC2:  MOVWF  01
06AC4:  MOVFF  FE6,FEE
06AC8:  DECFSZ 01,F
06ACA:  GOTO   6AC4
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
....................     sector_erase(mis_fm, MISF_CIGS_DATA_TABLE_START);
06ACE:  MOVFF  111,A59
06AD2:  MOVFF  110,A58
06AD6:  MOVFF  10F,A57
06ADA:  MOVFF  10E,A56
06ADE:  MOVLB  A
06AE0:  CLRF   x5D
06AE2:  CLRF   x5C
06AE4:  CLRF   x5B
06AE6:  CLRF   x5A
06AE8:  MOVLB  0
06AEA:  CALL   40B6
....................     // START に書く (以前 END だった)
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
06AEE:  MOVFF  111,A59
06AF2:  MOVFF  110,A58
06AF6:  MOVFF  10F,A57
06AFA:  MOVFF  10E,A56
06AFE:  MOVLB  A
06B00:  CLRF   x5D
06B02:  CLRF   x5C
06B04:  CLRF   x5B
06B06:  CLRF   x5A
06B08:  MOVLW  0A
06B0A:  MOVWF  x5F
06B0C:  MOVLW  16
06B0E:  MOVWF  x5E
06B10:  CLRF   x61
06B12:  MOVLW  40
06B14:  MOVWF  x60
06B16:  MOVLB  0
06B18:  CALL   34DE
06B1C:  GOTO   7144 (RETURN)
.................... }
.................... 
.................... // PICLOG 更新後に呼ばれる関数例 (piclog_write 内で既に write_misf_address_area 呼んでいる場合は不要)
.................... static void update_piclog_counters_after_write(unsigned int16 wrote_size)
.................... {
....................     piclog_data.used_counter     += wrote_size;
....................     piclog_data.uncopied_counter += wrote_size;
....................     // 必要なら wrap 処理追加
....................     write_misf_address_area();
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG    | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02A48:  MOVLW  1E
02A4A:  MOVWF  FF6
02A4C:  MOVLW  0D
02A4E:  MOVWF  FF7
02A50:  MOVLW  00
02A52:  MOVWF  FF8
02A54:  MOVLW  2B
02A56:  MOVLB  9
02A58:  MOVWF  xC2
02A5A:  MOVLB  0
02A5C:  CALL   1BEE
02A60:  MOVFF  122,264
02A64:  MOVLW  37
02A66:  MOVLB  2
02A68:  MOVWF  x65
02A6A:  MOVLB  0
02A6C:  CALL   1E42
02A70:  MOVFF  121,264
02A74:  MOVLW  37
02A76:  MOVLB  2
02A78:  MOVWF  x65
02A7A:  MOVLB  0
02A7C:  CALL   1E42
02A80:  MOVFF  120,264
02A84:  MOVLW  37
02A86:  MOVLB  2
02A88:  MOVWF  x65
02A8A:  MOVLB  0
02A8C:  CALL   1E42
02A90:  MOVFF  11F,264
02A94:  MOVLW  37
02A96:  MOVLB  2
02A98:  MOVWF  x65
02A9A:  MOVLB  0
02A9C:  CALL   1E42
02AA0:  MOVLW  0D
02AA2:  MOVLB  A
02AA4:  MOVWF  xAD
02AA6:  MOVLB  0
02AA8:  CALL   1B6C
02AAC:  MOVLW  0A
02AAE:  MOVLB  A
02AB0:  MOVWF  xAD
02AB2:  MOVLB  0
02AB4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | PICLOG    | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02AB8:  MOVLW  52
02ABA:  MOVWF  FF6
02ABC:  MOVLW  0D
02ABE:  MOVWF  FF7
02AC0:  MOVLW  00
02AC2:  MOVWF  FF8
02AC4:  MOVLW  2B
02AC6:  MOVLB  9
02AC8:  MOVWF  xC2
02ACA:  MOVLB  0
02ACC:  CALL   1BEE
02AD0:  MOVFF  126,264
02AD4:  MOVLW  37
02AD6:  MOVLB  2
02AD8:  MOVWF  x65
02ADA:  MOVLB  0
02ADC:  CALL   1E42
02AE0:  MOVFF  125,264
02AE4:  MOVLW  37
02AE6:  MOVLB  2
02AE8:  MOVWF  x65
02AEA:  MOVLB  0
02AEC:  CALL   1E42
02AF0:  MOVFF  124,264
02AF4:  MOVLW  37
02AF6:  MOVLB  2
02AF8:  MOVWF  x65
02AFA:  MOVLB  0
02AFC:  CALL   1E42
02B00:  MOVFF  123,264
02B04:  MOVLW  37
02B06:  MOVLB  2
02B08:  MOVWF  x65
02B0A:  MOVLB  0
02B0C:  CALL   1E42
02B10:  MOVLW  0D
02B12:  MOVLB  A
02B14:  MOVWF  xAD
02B16:  MOVLB  0
02B18:  CALL   1B6C
02B1C:  MOVLW  0A
02B1E:  MOVLB  A
02B20:  MOVWF  xAD
02B22:  MOVLB  0
02B24:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02B28:  MOVLW  86
02B2A:  MOVWF  FF6
02B2C:  MOVLW  0D
02B2E:  MOVWF  FF7
02B30:  MOVLW  00
02B32:  MOVWF  FF8
02B34:  MOVLW  2B
02B36:  MOVLB  9
02B38:  MOVWF  xC2
02B3A:  MOVLB  0
02B3C:  CALL   1BEE
02B40:  MOVFF  127,264
02B44:  MOVLW  37
02B46:  MOVLB  2
02B48:  MOVWF  x65
02B4A:  MOVLB  0
02B4C:  CALL   1E42
02B50:  MOVLW  0D
02B52:  MOVLB  A
02B54:  MOVWF  xAD
02B56:  MOVLB  0
02B58:  CALL   1B6C
02B5C:  MOVLW  0A
02B5E:  MOVLB  A
02B60:  MOVWF  xAD
02B62:  MOVLB  0
02B64:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02B68:  MOVLW  B8
02B6A:  MOVWF  FF6
02B6C:  MOVLW  0D
02B6E:  MOVWF  FF7
02B70:  MOVLW  00
02B72:  MOVWF  FF8
02B74:  MOVLW  2B
02B76:  MOVLB  9
02B78:  MOVWF  xC2
02B7A:  MOVLB  0
02B7C:  CALL   1BEE
02B80:  MOVFF  128,264
02B84:  MOVLW  37
02B86:  MOVLB  2
02B88:  MOVWF  x65
02B8A:  MOVLB  0
02B8C:  CALL   1E42
02B90:  MOVLW  0D
02B92:  MOVLB  A
02B94:  MOVWF  xAD
02B96:  MOVLB  0
02B98:  CALL   1B6C
02B9C:  MOVLW  0A
02B9E:  MOVLB  A
02BA0:  MOVWF  xAD
02BA2:  MOVLB  0
02BA4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02BA8:  MOVLW  EA
02BAA:  MOVWF  FF6
02BAC:  MOVLW  0D
02BAE:  MOVWF  FF7
02BB0:  MOVLW  00
02BB2:  MOVWF  FF8
02BB4:  MOVLW  2B
02BB6:  MOVLB  9
02BB8:  MOVWF  xC2
02BBA:  MOVLB  0
02BBC:  CALL   1BEE
02BC0:  MOVFF  12D,264
02BC4:  MOVLW  37
02BC6:  MOVLB  2
02BC8:  MOVWF  x65
02BCA:  MOVLB  0
02BCC:  CALL   1E42
02BD0:  MOVFF  12C,264
02BD4:  MOVLW  37
02BD6:  MOVLB  2
02BD8:  MOVWF  x65
02BDA:  MOVLB  0
02BDC:  CALL   1E42
02BE0:  MOVFF  12B,264
02BE4:  MOVLW  37
02BE6:  MOVLB  2
02BE8:  MOVWF  x65
02BEA:  MOVLB  0
02BEC:  CALL   1E42
02BF0:  MOVFF  12A,264
02BF4:  MOVLW  37
02BF6:  MOVLB  2
02BF8:  MOVWF  x65
02BFA:  MOVLB  0
02BFC:  CALL   1E42
02C00:  MOVLW  0D
02C02:  MOVLB  A
02C04:  MOVWF  xAD
02C06:  MOVLB  0
02C08:  CALL   1B6C
02C0C:  MOVLW  0A
02C0E:  MOVLB  A
02C10:  MOVWF  xAD
02C12:  MOVLB  0
02C14:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02C18:  MOVLW  1E
02C1A:  MOVWF  FF6
02C1C:  MOVLW  0E
02C1E:  MOVWF  FF7
02C20:  MOVLW  00
02C22:  MOVWF  FF8
02C24:  MOVLW  2B
02C26:  MOVLB  9
02C28:  MOVWF  xC2
02C2A:  MOVLB  0
02C2C:  CALL   1BEE
02C30:  MOVFF  131,264
02C34:  MOVLW  37
02C36:  MOVLB  2
02C38:  MOVWF  x65
02C3A:  MOVLB  0
02C3C:  CALL   1E42
02C40:  MOVFF  130,264
02C44:  MOVLW  37
02C46:  MOVLB  2
02C48:  MOVWF  x65
02C4A:  MOVLB  0
02C4C:  CALL   1E42
02C50:  MOVFF  12F,264
02C54:  MOVLW  37
02C56:  MOVLB  2
02C58:  MOVWF  x65
02C5A:  MOVLB  0
02C5C:  CALL   1E42
02C60:  MOVFF  12E,264
02C64:  MOVLW  37
02C66:  MOVLB  2
02C68:  MOVWF  x65
02C6A:  MOVLB  0
02C6C:  CALL   1E42
02C70:  MOVLW  0D
02C72:  MOVLB  A
02C74:  MOVWF  xAD
02C76:  MOVLB  0
02C78:  CALL   1B6C
02C7C:  MOVLW  0A
02C7E:  MOVLB  A
02C80:  MOVWF  xAD
02C82:  MOVLB  0
02C84:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02C88:  MOVLW  52
02C8A:  MOVWF  FF6
02C8C:  MOVLW  0E
02C8E:  MOVWF  FF7
02C90:  MOVLW  00
02C92:  MOVWF  FF8
02C94:  MOVLW  2B
02C96:  MOVLB  9
02C98:  MOVWF  xC2
02C9A:  MOVLB  0
02C9C:  CALL   1BEE
02CA0:  MOVFF  132,264
02CA4:  MOVLW  37
02CA6:  MOVLB  2
02CA8:  MOVWF  x65
02CAA:  MOVLB  0
02CAC:  CALL   1E42
02CB0:  MOVLW  0D
02CB2:  MOVLB  A
02CB4:  MOVWF  xAD
02CB6:  MOVLB  0
02CB8:  CALL   1B6C
02CBC:  MOVLW  0A
02CBE:  MOVLB  A
02CC0:  MOVWF  xAD
02CC2:  MOVLB  0
02CC4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02CC8:  MOVLW  84
02CCA:  MOVWF  FF6
02CCC:  MOVLW  0E
02CCE:  MOVWF  FF7
02CD0:  MOVLW  00
02CD2:  MOVWF  FF8
02CD4:  MOVLW  2B
02CD6:  MOVLB  9
02CD8:  MOVWF  xC2
02CDA:  MOVLB  0
02CDC:  CALL   1BEE
02CE0:  MOVFF  133,264
02CE4:  MOVLW  37
02CE6:  MOVLB  2
02CE8:  MOVWF  x65
02CEA:  MOVLB  0
02CEC:  CALL   1E42
02CF0:  MOVLW  0D
02CF2:  MOVLB  A
02CF4:  MOVWF  xAD
02CF6:  MOVLB  0
02CF8:  CALL   1B6C
02CFC:  MOVLW  0A
02CFE:  MOVLB  A
02D00:  MOVWF  xAD
02D02:  MOVLB  0
02D04:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Use Counter      : 0x%08LX\r\n", iv_header.used_counter);
02D08:  MOVLW  B6
02D0A:  MOVWF  FF6
02D0C:  MOVLW  0E
02D0E:  MOVWF  FF7
02D10:  MOVLW  00
02D12:  MOVWF  FF8
02D14:  MOVLW  2B
02D16:  MOVLB  9
02D18:  MOVWF  xC2
02D1A:  MOVLB  0
02D1C:  CALL   1BEE
02D20:  MOVFF  138,264
02D24:  MOVLW  37
02D26:  MOVLB  2
02D28:  MOVWF  x65
02D2A:  MOVLB  0
02D2C:  CALL   1E42
02D30:  MOVFF  137,264
02D34:  MOVLW  37
02D36:  MOVLB  2
02D38:  MOVWF  x65
02D3A:  MOVLB  0
02D3C:  CALL   1E42
02D40:  MOVFF  136,264
02D44:  MOVLW  37
02D46:  MOVLB  2
02D48:  MOVWF  x65
02D4A:  MOVLB  0
02D4C:  CALL   1E42
02D50:  MOVFF  135,264
02D54:  MOVLW  37
02D56:  MOVLB  2
02D58:  MOVWF  x65
02D5A:  MOVLB  0
02D5C:  CALL   1E42
02D60:  MOVLW  0D
02D62:  MOVLB  A
02D64:  MOVWF  xAD
02D66:  MOVLB  0
02D68:  CALL   1B6C
02D6C:  MOVLW  0A
02D6E:  MOVLB  A
02D70:  MOVWF  xAD
02D72:  MOVLB  0
02D74:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Uncopyed Counter : 0x%08LX\r\n", iv_header.uncopied_counter);
02D78:  MOVLW  EA
02D7A:  MOVWF  FF6
02D7C:  MOVLW  0E
02D7E:  MOVWF  FF7
02D80:  MOVLW  00
02D82:  MOVWF  FF8
02D84:  MOVLW  2B
02D86:  MOVLB  9
02D88:  MOVWF  xC2
02D8A:  MOVLB  0
02D8C:  CALL   1BEE
02D90:  MOVFF  13C,264
02D94:  MOVLW  37
02D96:  MOVLB  2
02D98:  MOVWF  x65
02D9A:  MOVLB  0
02D9C:  CALL   1E42
02DA0:  MOVFF  13B,264
02DA4:  MOVLW  37
02DA6:  MOVLB  2
02DA8:  MOVWF  x65
02DAA:  MOVLB  0
02DAC:  CALL   1E42
02DB0:  MOVFF  13A,264
02DB4:  MOVLW  37
02DB6:  MOVLB  2
02DB8:  MOVWF  x65
02DBA:  MOVLB  0
02DBC:  CALL   1E42
02DC0:  MOVFF  139,264
02DC4:  MOVLW  37
02DC6:  MOVLB  2
02DC8:  MOVWF  x65
02DCA:  MOVLB  0
02DCC:  CALL   1E42
02DD0:  MOVLW  0D
02DD2:  MOVLB  A
02DD4:  MOVWF  xAD
02DD6:  MOVLB  0
02DD8:  CALL   1B6C
02DDC:  MOVLW  0A
02DDE:  MOVLB  A
02DE0:  MOVWF  xAD
02DE2:  MOVLB  0
02DE4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter1 : 0x%02X\r\n", iv_header.reserve_counter1);
02DE8:  MOVLW  1E
02DEA:  MOVWF  FF6
02DEC:  MOVLW  0F
02DEE:  MOVWF  FF7
02DF0:  MOVLW  00
02DF2:  MOVWF  FF8
02DF4:  MOVLW  2B
02DF6:  MOVLB  9
02DF8:  MOVWF  xC2
02DFA:  MOVLB  0
02DFC:  CALL   1BEE
02E00:  MOVFF  13D,264
02E04:  MOVLW  37
02E06:  MOVLB  2
02E08:  MOVWF  x65
02E0A:  MOVLB  0
02E0C:  CALL   1E42
02E10:  MOVLW  0D
02E12:  MOVLB  A
02E14:  MOVWF  xAD
02E16:  MOVLB  0
02E18:  CALL   1B6C
02E1C:  MOVLW  0A
02E1E:  MOVLB  A
02E20:  MOVWF  xAD
02E22:  MOVLB  0
02E24:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter2 : 0x%02X\r\n", iv_header.reserve_counter2);
02E28:  MOVLW  50
02E2A:  MOVWF  FF6
02E2C:  MOVLW  0F
02E2E:  MOVWF  FF7
02E30:  MOVLW  00
02E32:  MOVWF  FF8
02E34:  MOVLW  2B
02E36:  MOVLB  9
02E38:  MOVWF  xC2
02E3A:  MOVLB  0
02E3C:  CALL   1BEE
02E40:  MOVFF  13E,264
02E44:  MOVLW  37
02E46:  MOVLB  2
02E48:  MOVWF  x65
02E4A:  MOVLB  0
02E4C:  CALL   1E42
02E50:  MOVLW  0D
02E52:  MOVLB  A
02E54:  MOVWF  xAD
02E56:  MOVLB  0
02E58:  CALL   1B6C
02E5C:  MOVLW  0A
02E5E:  MOVLB  A
02E60:  MOVWF  xAD
02E62:  MOVLB  0
02E64:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Use Counter      : 0x%08LX\r\n", iv_data.used_counter);
02E68:  MOVLW  82
02E6A:  MOVWF  FF6
02E6C:  MOVLW  0F
02E6E:  MOVWF  FF7
02E70:  MOVLW  00
02E72:  MOVWF  FF8
02E74:  MOVLW  2B
02E76:  MOVLB  9
02E78:  MOVWF  xC2
02E7A:  MOVLB  0
02E7C:  CALL   1BEE
02E80:  MOVFF  143,264
02E84:  MOVLW  37
02E86:  MOVLB  2
02E88:  MOVWF  x65
02E8A:  MOVLB  0
02E8C:  CALL   1E42
02E90:  MOVFF  142,264
02E94:  MOVLW  37
02E96:  MOVLB  2
02E98:  MOVWF  x65
02E9A:  MOVLB  0
02E9C:  CALL   1E42
02EA0:  MOVFF  141,264
02EA4:  MOVLW  37
02EA6:  MOVLB  2
02EA8:  MOVWF  x65
02EAA:  MOVLB  0
02EAC:  CALL   1E42
02EB0:  MOVFF  140,264
02EB4:  MOVLW  37
02EB6:  MOVLB  2
02EB8:  MOVWF  x65
02EBA:  MOVLB  0
02EBC:  CALL   1E42
02EC0:  MOVLW  0D
02EC2:  MOVLB  A
02EC4:  MOVWF  xAD
02EC6:  MOVLB  0
02EC8:  CALL   1B6C
02ECC:  MOVLW  0A
02ECE:  MOVLB  A
02ED0:  MOVWF  xAD
02ED2:  MOVLB  0
02ED4:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Uncopyed Counter : 0x%08LX\r\n", iv_data.uncopied_counter);
02ED8:  MOVLW  B6
02EDA:  MOVWF  FF6
02EDC:  MOVLW  0F
02EDE:  MOVWF  FF7
02EE0:  MOVLW  00
02EE2:  MOVWF  FF8
02EE4:  MOVLW  2B
02EE6:  MOVLB  9
02EE8:  MOVWF  xC2
02EEA:  MOVLB  0
02EEC:  CALL   1BEE
02EF0:  MOVFF  147,264
02EF4:  MOVLW  37
02EF6:  MOVLB  2
02EF8:  MOVWF  x65
02EFA:  MOVLB  0
02EFC:  CALL   1E42
02F00:  MOVFF  146,264
02F04:  MOVLW  37
02F06:  MOVLB  2
02F08:  MOVWF  x65
02F0A:  MOVLB  0
02F0C:  CALL   1E42
02F10:  MOVFF  145,264
02F14:  MOVLW  37
02F16:  MOVLB  2
02F18:  MOVWF  x65
02F1A:  MOVLB  0
02F1C:  CALL   1E42
02F20:  MOVFF  144,264
02F24:  MOVLW  37
02F26:  MOVLB  2
02F28:  MOVWF  x65
02F2A:  MOVLB  0
02F2C:  CALL   1E42
02F30:  MOVLW  0D
02F32:  MOVLB  A
02F34:  MOVWF  xAD
02F36:  MOVLB  0
02F38:  CALL   1B6C
02F3C:  MOVLW  0A
02F3E:  MOVLB  A
02F40:  MOVWF  xAD
02F42:  MOVLB  0
02F44:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter1 : 0x%02X\r\n", iv_data.reserve_counter1);
02F48:  MOVLW  EA
02F4A:  MOVWF  FF6
02F4C:  MOVLW  0F
02F4E:  MOVWF  FF7
02F50:  MOVLW  00
02F52:  MOVWF  FF8
02F54:  MOVLW  2B
02F56:  MOVLB  9
02F58:  MOVWF  xC2
02F5A:  MOVLB  0
02F5C:  CALL   1BEE
02F60:  MOVFF  148,264
02F64:  MOVLW  37
02F66:  MOVLB  2
02F68:  MOVWF  x65
02F6A:  MOVLB  0
02F6C:  CALL   1E42
02F70:  MOVLW  0D
02F72:  MOVLB  A
02F74:  MOVWF  xAD
02F76:  MOVLB  0
02F78:  CALL   1B6C
02F7C:  MOVLW  0A
02F7E:  MOVLB  A
02F80:  MOVWF  xAD
02F82:  MOVLB  0
02F84:  CALL   1B6C
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter2 : 0x%02X\r\n", iv_data.reserve_counter2);
02F88:  MOVLW  1C
02F8A:  MOVWF  FF6
02F8C:  MOVLW  10
02F8E:  MOVWF  FF7
02F90:  MOVLW  00
02F92:  MOVWF  FF8
02F94:  MOVLW  2B
02F96:  MOVLB  9
02F98:  MOVWF  xC2
02F9A:  MOVLB  0
02F9C:  CALL   1BEE
02FA0:  MOVFF  149,264
02FA4:  MOVLW  37
02FA6:  MOVLB  2
02FA8:  MOVWF  x65
02FAA:  MOVLB  0
02FAC:  CALL   1E42
02FB0:  MOVLW  0D
02FB2:  MOVLB  A
02FB4:  MOVWF  xAD
02FB6:  MOVLB  0
02FB8:  CALL   1B6C
02FBC:  MOVLW  0A
02FBE:  MOVLB  A
02FC0:  MOVWF  xAD
02FC2:  MOVLB  0
02FC4:  CALL   1B6C
....................     fprintf(PC, "\tComplete\r\n");
02FC8:  MOVLW  4E
02FCA:  MOVWF  FF6
02FCC:  MOVLW  10
02FCE:  MOVWF  FF7
02FD0:  MOVLW  00
02FD2:  MOVWF  FF8
02FD4:  CALL   1BBE
02FD8:  GOTO   31BE (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
0958C:  MOVLB  2
0958E:  CLRF   x68
09590:  CLRF   x69
09592:  CLRF   x6A
09594:  CLRF   x6B
09596:  CLRF   x6C
09598:  CLRF   x6D
0959A:  CLRF   x6E
0959C:  CLRF   x6F
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0959E:  MOVF   x67,F
095A0:  BTFSC  FD8.2
095A2:  BRA    95AA
095A4:  MOVLB  0
095A6:  GOTO   95C6
095AA:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
095AC:  MOVLB  2
095AE:  CLRF   x6B
095B0:  CLRF   x6A
095B2:  CLRF   x69
095B4:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
095B6:  CLRF   x6F
095B8:  CLRF   x6E
095BA:  MOVLW  0F
095BC:  MOVWF  x6D
095BE:  SETF   x6C
095C0:  MOVLB  0
....................    }
095C2:  GOTO   9688
....................    else if (mission_id == CIGS_PICLOG_DATA)
095C6:  MOVLB  2
095C8:  DECFSZ x67,W
095CA:  BRA    95D0
095CC:  BRA    95D6
095CE:  MOVLB  0
095D0:  MOVLB  0
095D2:  GOTO   95F6
095D6:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
095D8:  MOVLB  2
095DA:  CLRF   x6B
095DC:  MOVLW  01
095DE:  MOVWF  x6A
095E0:  CLRF   x69
095E2:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
095E4:  CLRF   x6F
095E6:  MOVLW  14
095E8:  MOVWF  x6E
095EA:  MOVLW  0F
095EC:  MOVWF  x6D
095EE:  SETF   x6C
095F0:  MOVLB  0
....................    }
095F2:  GOTO   9688
....................    else if (mission_id == CIGS_ENVIRO_DATA)
095F6:  MOVLB  2
095F8:  MOVF   x67,W
095FA:  SUBLW  02
095FC:  BTFSC  FD8.2
095FE:  BRA    9606
09600:  MOVLB  0
09602:  GOTO   9628
09606:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
09608:  MOVLB  2
0960A:  CLRF   x6B
0960C:  MOVLW  28
0960E:  MOVWF  x6A
09610:  MOVLW  10
09612:  MOVWF  x69
09614:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
09616:  CLRF   x6F
09618:  MOVLW  32
0961A:  MOVWF  x6E
0961C:  MOVLW  0F
0961E:  MOVWF  x6D
09620:  SETF   x6C
09622:  MOVLB  0
....................    }
09624:  GOTO   9688
....................    else if (mission_id == CIGS_IV_HEADER)
09628:  MOVLB  2
0962A:  MOVF   x67,W
0962C:  SUBLW  03
0962E:  BTFSC  FD8.2
09630:  BRA    9638
09632:  MOVLB  0
09634:  GOTO   965A
09638:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
0963A:  MOVLB  2
0963C:  CLRF   x6B
0963E:  MOVLW  72
09640:  MOVWF  x6A
09642:  MOVLW  10
09644:  MOVWF  x69
09646:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
09648:  CLRF   x6F
0964A:  MOVLW  7C
0964C:  MOVWF  x6E
0964E:  MOVLW  0F
09650:  MOVWF  x6D
09652:  SETF   x6C
09654:  MOVLB  0
....................    }
09656:  GOTO   9688
....................    else if (mission_id == CIGS_IV_DATA)
0965A:  MOVLB  2
0965C:  MOVF   x67,W
0965E:  SUBLW  04
09660:  BTFSC  FD8.2
09662:  BRA    966A
09664:  MOVLB  0
09666:  GOTO   9688
0966A:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
0966C:  MOVLB  2
0966E:  CLRF   x6B
09670:  MOVLW  7C
09672:  MOVWF  x6A
09674:  MOVLW  10
09676:  MOVWF  x69
09678:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
0967A:  CLRF   x6F
0967C:  MOVLW  BC
0967E:  MOVWF  x6E
09680:  MOVLW  0F
09682:  MOVWF  x6D
09684:  SETF   x6C
09686:  MOVLB  0
....................    }
....................    return mis_struct;
09688:  MOVLW  68
0968A:  MOVWF  01
0968C:  MOVLW  02
0968E:  MOVWF  02
09690:  GOTO   9B66 (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv_header.used_counter - iv_header.uncopied_counter;
....................         mis_write_struct.size = iv_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter - iv_data.uncopied_counter;
....................         mis_write_struct.size = iv_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... // End of file
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "../application/mission/mmj_cigs_excute_mission.c"
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
08F36:  MOVLB  1
08F38:  MOVF   x8A,W
08F3A:  MOVWF  FE9
08F3C:  MOVF   x8B,W
08F3E:  MOVWF  FEA
08F40:  MOVFF  FEF,18C
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
08F44:  MOVLW  B6
08F46:  MOVWF  FF6
08F48:  MOVLW  10
08F4A:  MOVWF  FF7
08F4C:  MOVLW  00
08F4E:  MOVWF  FF8
08F50:  MOVLB  0
08F52:  CALL   1BBE
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
08F56:  MOVLW  FC
08F58:  MOVWF  FF6
08F5A:  MOVLW  10
08F5C:  MOVWF  FF7
08F5E:  MOVLW  00
08F60:  MOVWF  FF8
08F62:  MOVLW  0C
08F64:  MOVLB  9
08F66:  MOVWF  xC2
08F68:  MOVLB  0
08F6A:  CALL   1BEE
08F6E:  MOVFF  18C,264
08F72:  MOVLW  37
08F74:  MOVLB  2
08F76:  MOVWF  x65
08F78:  MOVLB  0
08F7A:  CALL   1E42
08F7E:  MOVLW  0A
08F80:  MOVWF  FF6
08F82:  MOVLW  11
08F84:  MOVWF  FF7
08F86:  MOVLW  00
08F88:  MOVWF  FF8
08F8A:  MOVLW  04
08F8C:  MOVLB  9
08F8E:  MOVWF  xC2
08F90:  MOVLB  0
08F92:  CALL   1BEE
....................    switch(command_id)
08F96:  MOVLB  1
08F98:  MOVF   x8C,W
08F9A:  XORLW  10
08F9C:  MOVLB  0
08F9E:  BTFSC  FD8.2
08FA0:  GOTO   9050
08FA4:  XORLW  01
08FA6:  BTFSC  FD8.2
08FA8:  GOTO   9054
08FAC:  XORLW  03
08FAE:  BTFSC  FD8.2
08FB0:  GOTO   9058
08FB4:  XORLW  13
08FB6:  BTFSC  FD8.2
08FB8:  GOTO   905C
08FBC:  XORLW  12
08FBE:  BTFSC  FD8.2
08FC0:  GOTO   9060
08FC4:  XORLW  93
08FC6:  BTFSC  FD8.2
08FC8:  GOTO   9064
08FCC:  XORLW  01
08FCE:  BTFSC  FD8.2
08FD0:  GOTO   9074
08FD4:  XORLW  03
08FD6:  BTFSC  FD8.2
08FD8:  GOTO   9084
08FDC:  XORLW  01
08FDE:  BTFSC  FD8.2
08FE0:  GOTO   9094
08FE4:  XORLW  07
08FE6:  BTFSC  FD8.2
08FE8:  GOTO   90A4
08FEC:  XORLW  01
08FEE:  BTFSC  FD8.2
08FF0:  GOTO   90B4
08FF4:  XORLW  03
08FF6:  BTFSC  FD8.2
08FF8:  GOTO   90C4
08FFC:  XORLW  01
08FFE:  BTFSC  FD8.2
09000:  GOTO   90D4
09004:  XORLW  0F
09006:  BTFSC  FD8.2
09008:  GOTO   90E4
0900C:  XORLW  18
0900E:  BTFSC  FD8.2
09010:  GOTO   90F4
09014:  XORLW  01
09016:  BTFSC  FD8.2
09018:  GOTO   9104
0901C:  XORLW  03
0901E:  BTFSC  FD8.2
09020:  GOTO   9114
09024:  XORLW  01
09026:  BTFSC  FD8.2
09028:  GOTO   9124
0902C:  XORLW  07
0902E:  BTFSC  FD8.2
09030:  GOTO   9134
09034:  XORLW  01
09036:  BTFSC  FD8.2
09038:  GOTO   9144
0903C:  XORLW  03
0903E:  BTFSC  FD8.2
09040:  GOTO   9154
09044:  XORLW  36
09046:  BTFSC  FD8.2
09048:  GOTO   9164
0904C:  GOTO   9174
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
09050:  GOTO   9184
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
09054:  GOTO   9184
....................       case 0x12:
....................          // test_adc();
....................          break;
09058:  GOTO   9184
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
0905C:  GOTO   9184
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
09060:  GOTO   9184
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
09064:  MOVFF  18B,190
09068:  MOVFF  18A,18F
0906C:  CALL   440E
....................          break;
09070:  GOTO   9184
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
09074:  MOVFF  18B,18E
09078:  MOVFF  18A,18D
0907C:  GOTO   44EA
....................          break;
09080:  GOTO   9184
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
09084:  MOVFF  18B,18E
09088:  MOVFF  18A,18D
0908C:  GOTO   49DC
....................          break;
09090:  GOTO   9184
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
09094:  MOVFF  18B,18E
09098:  MOVFF  18A,18D
0909C:  GOTO   4B6E
....................          break;
090A0:  GOTO   9184
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
090A4:  MOVFF  18B,18E
090A8:  MOVFF  18A,18D
090AC:  GOTO   4CE0
....................          break;
090B0:  GOTO   9184
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
090B4:  MOVFF  18B,18E
090B8:  MOVFF  18A,18D
090BC:  GOTO   50DA
....................          break;
090C0:  GOTO   9184
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
090C4:  MOVFF  18B,18E
090C8:  MOVFF  18A,18D
090CC:  GOTO   514E
....................          break;
090D0:  GOTO   9184
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
090D4:  MOVFF  18B,18E
090D8:  MOVFF  18A,18D
090DC:  GOTO   55D2
....................          break;
090E0:  GOTO   9184
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
090E4:  MOVFF  18B,18E
090E8:  MOVFF  18A,18D
090EC:  GOTO   58CA
....................          break;
090F0:  GOTO   9184
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
090F4:  MOVFF  18B,18E
090F8:  MOVFF  18A,18D
090FC:  GOTO   5920
....................          break;
09100:  GOTO   9184
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
09104:  MOVFF  18B,18E
09108:  MOVFF  18A,18D
0910C:  GOTO   59FC
....................          break;
09110:  GOTO   9184
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
09114:  MOVFF  18B,18E
09118:  MOVFF  18A,18D
0911C:  GOTO   5AB8
....................          break;
09120:  GOTO   9184
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
09124:  MOVFF  18B,18E
09128:  MOVFF  18A,18D
0912C:  CALL   5BEE
....................          break;
09130:  GOTO   9184
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
09134:  MOVFF  18B,18E
09138:  MOVFF  18A,18D
0913C:  GOTO   5D66
....................          break;
09140:  GOTO   9184
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
09144:  MOVFF  18B,18E
09148:  MOVFF  18A,18D
0914C:  GOTO   6148
....................          break;
09150:  GOTO   9184
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
09154:  MOVFF  18B,18E
09158:  MOVFF  18A,18D
0915C:  CALL   5BEE
....................          break;
09160:  GOTO   9184
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
09164:  MOVFF  18B,18E
09168:  MOVFF  18A,18D
0916C:  GOTO   898E
....................          break;
09170:  GOTO   9184
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
09174:  MOVLW  10
09176:  MOVWF  FF6
09178:  MOVLW  11
0917A:  MOVWF  FF7
0917C:  MOVLW  00
0917E:  MOVWF  FF8
09180:  CALL   1BBE
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
09184:  MOVLW  28
09186:  MOVWF  FF6
09188:  MOVLW  11
0918A:  MOVWF  FF7
0918C:  MOVLW  00
0918E:  MOVWF  FF8
09190:  CALL   1BBE
09194:  GOTO   9202 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0B1AC:  MOVLW  6E
0B1AE:  MOVWF  FF6
0B1B0:  MOVLW  11
0B1B2:  MOVWF  FF7
0B1B4:  MOVLW  00
0B1B6:  MOVWF  FF8
0B1B8:  CALL   1BBE
....................    
....................    switch(command->frame_id)
0B1BC:  MOVLB  1
0B1BE:  MOVF   x84,W
0B1C0:  MOVWF  FE9
0B1C2:  MOVF   x85,W
0B1C4:  MOVWF  FEA
0B1C6:  MOVF   FEF,W
0B1C8:  XORLW  00
0B1CA:  MOVLB  0
0B1CC:  BTFSC  FD8.2
0B1CE:  GOTO   B1E6
0B1D2:  XORLW  01
0B1D4:  BTFSC  FD8.2
0B1D6:  GOTO   B1F6
0B1DA:  XORLW  03
0B1DC:  BTFSC  FD8.2
0B1DE:  GOTO   B216
0B1E2:  GOTO   B226
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0B1E6:  MOVFF  185,187
0B1EA:  MOVFF  184,186
0B1EE:  GOTO   91B6
....................          break;
0B1F2:  GOTO   B226
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0B1F6:  MOVFF  185,187
0B1FA:  MOVFF  184,186
0B1FE:  GOTO   9238
0B202:  MOVF   01,F
0B204:  BTFSC  FD8.2
0B206:  GOTO   B212
....................             return TRUE; // if status is finished, return TRUE
0B20A:  MOVLW  01
0B20C:  MOVWF  01
0B20E:  GOTO   B22A
....................          }        
....................          break;
0B212:  GOTO   B226
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0B216:  MOVFF  185,187
0B21A:  MOVFF  184,186
0B21E:  GOTO   AEBC
....................          break;
0B222:  GOTO   B226
....................    }
....................    return FALSE;
0B226:  MOVLW  00
0B228:  MOVWF  01
0B22A:  GOTO   B6EE (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
091B6:  MOVLW  86
091B8:  MOVWF  FF6
091BA:  MOVLW  11
091BC:  MOVWF  FF7
091BE:  MOVLW  00
091C0:  MOVWF  FF8
091C2:  CALL   1BBE
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
091C6:  MOVLW  9C
091C8:  MOVWF  FF6
091CA:  MOVLW  11
091CC:  MOVWF  FF7
091CE:  MOVLW  00
091D0:  MOVWF  FF8
091D2:  CALL   1BBE
....................    transmit_ack();
091D6:  CALL   40A2
.................... 
....................    status[0] = EXECUTING_MISSION;
091DA:  MOVLW  02
091DC:  MOVWF  48
....................    execute_mission(command->content);
091DE:  MOVLW  03
091E0:  MOVLB  1
091E2:  ADDWF  x86,W
091E4:  MOVWF  01
091E6:  MOVLW  00
091E8:  ADDWFC x87,W
091EA:  MOVWF  03
091EC:  MOVF   01,W
091EE:  MOVWF  x88
091F0:  MOVFF  03,189
091F4:  MOVFF  189,18B
091F8:  MOVFF  188,18A
091FC:  MOVLB  0
091FE:  GOTO   8F36
....................    if (is_empty_flash_queue())
09202:  CALL   9198
09206:  MOVF   01,F
09208:  BTFSC  FD8.2
0920A:  GOTO   9216
....................       status[0] = FINISHED;
0920E:  MOVLW  06
09210:  MOVWF  48
09212:  GOTO   921A
....................    else
....................       status[0] = SMF_USE_REQ;
09216:  MOVLW  04
09218:  MOVWF  48
0921A:  GOTO   B1F2 (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
09238:  MOVLW  B6
0923A:  MOVWF  FF6
0923C:  MOVLW  11
0923E:  MOVWF  FF7
09240:  MOVLW  00
09242:  MOVWF  FF8
09244:  CALL   1BBE
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
09248:  MOVLW  CA
0924A:  MOVWF  FF6
0924C:  MOVLW  11
0924E:  MOVWF  FF7
09250:  MOVLW  00
09252:  MOVWF  FF8
09254:  CALL   1BBE
....................    transmit_status();
09258:  GOTO   921E
....................    if (status[0] == FINISHED)
0925C:  MOVF   48,W
0925E:  SUBLW  06
09260:  BTFSS  FD8.2
09262:  GOTO   9282
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
09266:  MOVLW  E8
09268:  MOVWF  FF6
0926A:  MOVLW  11
0926C:  MOVWF  FF7
0926E:  MOVLW  00
09270:  MOVWF  FF8
09272:  CALL   1BBE
....................       return TRUE;
09276:  MOVLW  01
09278:  MOVWF  01
0927A:  GOTO   928A
....................    }
0927E:  GOTO   928A
....................    else{
....................       return FALSE;
09282:  MOVLW  00
09284:  MOVWF  01
09286:  GOTO   928A
....................    }
0928A:  GOTO   B202 (RETURN)
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command)
.................... {
....................     fprintf(PC, "\t-> SMF available check\r\n");
*
0AEBC:  MOVLW  04
0AEBE:  MOVWF  FF6
0AEC0:  MOVLW  12
0AEC2:  MOVWF  FF7
0AEC4:  MOVLW  00
0AEC6:  MOVWF  FF8
0AEC8:  CALL   1BBE
....................     fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0AECC:  MOVLW  1E
0AECE:  MOVWF  FF6
0AED0:  MOVLW  12
0AED2:  MOVWF  FF7
0AED4:  MOVLW  00
0AED6:  MOVWF  FF8
0AED8:  CALL   1BBE
....................     transmit_ack();
0AEDC:  CALL   40A2
.................... 
....................     if (command->content[0] != ALLOW) {
0AEE0:  MOVLW  03
0AEE2:  MOVLB  1
0AEE4:  ADDWF  x86,W
0AEE6:  MOVWF  FE9
0AEE8:  MOVLW  00
0AEEA:  ADDWFC x87,W
0AEEC:  MOVWF  FEA
0AEEE:  DECFSZ FEF,W
0AEF0:  BRA    AEF6
0AEF2:  BRA    AEFC
0AEF4:  MOVLB  0
0AEF6:  MOVLB  0
0AEF8:  GOTO   AF02
0AEFC:  MOVLB  0
0AEFE:  GOTO   AF16
....................         fprintf(PC, "\t\t-> denied\r\n");
0AF02:  MOVLW  3E
0AF04:  MOVWF  FF6
0AF06:  MOVLW  12
0AF08:  MOVWF  FF7
0AF0A:  MOVLW  00
0AF0C:  MOVWF  FF8
0AF0E:  CALL   1BBE
....................         return;
0AF12:  GOTO   B1A8
....................     }
.................... 
....................     fprintf(PC, "\t\t-> allowed\r\n");
0AF16:  MOVLW  4C
0AF18:  MOVWF  FF6
0AF1A:  MOVLW  12
0AF1C:  MOVWF  FF7
0AF1E:  MOVLW  00
0AF20:  MOVWF  FF8
0AF22:  CALL   1BBE
....................     status[0] = COPYING;
0AF26:  MOVLW  05
0AF28:  MOVWF  48
.................... 
....................     int8 processed_count = 0;
0AF2A:  MOVLB  1
0AF2C:  CLRF   x88
0AF2E:  MOVLB  0
.................... 
....................     while (!is_empty_flash_queue()) {
0AF30:  CALL   9198
0AF34:  MOVF   01,F
0AF36:  BTFSS  FD8.2
0AF38:  GOTO   B164
....................         FlashOperationStruct *smf_data = dequeue_flash_operation();
0AF3C:  GOTO   928E
0AF40:  MOVFF  02,18A
0AF44:  MOVFF  01,189
....................         if (smf_data == NULL) {
0AF48:  MOVLB  1
0AF4A:  MOVF   x89,F
0AF4C:  BTFSC  FD8.2
0AF4E:  BRA    AF56
0AF50:  MOVLB  0
0AF52:  GOTO   AF7C
0AF56:  MOVLB  0
0AF58:  MOVLB  1
0AF5A:  MOVF   x8A,F
0AF5C:  BTFSC  FD8.2
0AF5E:  BRA    AF66
0AF60:  MOVLB  0
0AF62:  GOTO   AF7C
0AF66:  MOVLB  0
....................             fprintf(PC, "\t\t-> dequeue NULL (break)\r\n");
0AF68:  MOVLW  5C
0AF6A:  MOVWF  FF6
0AF6C:  MOVLW  12
0AF6E:  MOVWF  FF7
0AF70:  MOVLW  00
0AF72:  MOVWF  FF8
0AF74:  CALL   1BBE
....................             break;
0AF78:  GOTO   B164
....................         }
.................... 
....................         fprintf(PC, "\t\t-> Dequeued: func=%u mission=%u size=%ld addr=%ld\r\n",
....................                 (unsigned int)smf_data->func_type,
....................                 (unsigned int)smf_data->mission_id,
....................                 smf_data->misf_size,
....................                 smf_data->misf_start_addr);
0AF7C:  MOVLW  01
0AF7E:  MOVLB  1
0AF80:  ADDWF  x89,W
0AF82:  MOVWF  FE9
0AF84:  MOVLW  00
0AF86:  ADDWFC x8A,W
0AF88:  MOVWF  FEA
0AF8A:  MOVFF  FEF,18B
0AF8E:  MOVF   x89,W
0AF90:  MOVWF  FE9
0AF92:  MOVF   x8A,W
0AF94:  MOVWF  FEA
0AF96:  MOVFF  FEF,18C
0AF9A:  MOVLW  08
0AF9C:  ADDWF  x89,W
0AF9E:  MOVWF  FE9
0AFA0:  MOVLW  00
0AFA2:  ADDWFC x8A,W
0AFA4:  MOVWF  FEA
0AFA6:  MOVFF  FEF,18D
0AFAA:  MOVFF  FEC,18E
0AFAE:  MOVFF  FEC,18F
0AFB2:  MOVFF  FEC,190
0AFB6:  MOVF   FED,F
0AFB8:  MOVF   FED,F
0AFBA:  MOVF   FED,F
0AFBC:  MOVLW  04
0AFBE:  ADDWF  x89,W
0AFC0:  MOVWF  FE9
0AFC2:  MOVLW  00
0AFC4:  ADDWFC x8A,W
0AFC6:  MOVWF  FEA
0AFC8:  MOVFF  FEF,191
0AFCC:  MOVFF  FEC,192
0AFD0:  MOVFF  FEC,193
0AFD4:  MOVFF  FEC,194
0AFD8:  MOVF   FED,F
0AFDA:  MOVF   FED,F
0AFDC:  MOVF   FED,F
0AFDE:  MOVLW  78
0AFE0:  MOVWF  FF6
0AFE2:  MOVLW  12
0AFE4:  MOVWF  FF7
0AFE6:  MOVLW  00
0AFE8:  MOVWF  FF8
0AFEA:  MOVLW  14
0AFEC:  MOVLB  9
0AFEE:  MOVWF  xC2
0AFF0:  MOVLB  0
0AFF2:  CALL   1BEE
0AFF6:  MOVFF  18B,264
0AFFA:  MOVLW  1B
0AFFC:  MOVLB  2
0AFFE:  MOVWF  x65
0B000:  MOVLB  0
0B002:  CALL   6388
0B006:  MOVLW  8E
0B008:  MOVWF  FF6
0B00A:  MOVLW  12
0B00C:  MOVWF  FF7
0B00E:  MOVLW  00
0B010:  MOVWF  FF8
0B012:  MOVLW  09
0B014:  MOVLB  9
0B016:  MOVWF  xC2
0B018:  MOVLB  0
0B01A:  CALL   1BEE
0B01E:  MOVFF  18C,264
0B022:  MOVLW  1B
0B024:  MOVLB  2
0B026:  MOVWF  x65
0B028:  MOVLB  0
0B02A:  CALL   6388
0B02E:  MOVLW  99
0B030:  MOVWF  FF6
0B032:  MOVLW  12
0B034:  MOVWF  FF7
0B036:  MOVLW  00
0B038:  MOVWF  FF8
0B03A:  MOVLW  06
0B03C:  MOVLB  9
0B03E:  MOVWF  xC2
0B040:  MOVLB  0
0B042:  CALL   1BEE
0B046:  MOVLW  41
0B048:  MOVWF  FE9
0B04A:  MOVFF  190,263
0B04E:  MOVFF  18F,262
0B052:  MOVFF  18E,261
0B056:  MOVFF  18D,260
0B05A:  CALL   92F0
0B05E:  MOVLW  A2
0B060:  MOVWF  FF6
0B062:  MOVLW  12
0B064:  MOVWF  FF7
0B066:  MOVLW  00
0B068:  MOVWF  FF8
0B06A:  MOVLW  06
0B06C:  MOVLB  9
0B06E:  MOVWF  xC2
0B070:  MOVLB  0
0B072:  CALL   1BEE
0B076:  MOVLW  41
0B078:  MOVWF  FE9
0B07A:  MOVFF  194,263
0B07E:  MOVFF  193,262
0B082:  MOVFF  192,261
0B086:  MOVFF  191,260
0B08A:  CALL   92F0
0B08E:  MOVLW  0D
0B090:  MOVLB  A
0B092:  MOVWF  xAD
0B094:  MOVLB  0
0B096:  CALL   1B6C
0B09A:  MOVLW  0A
0B09C:  MOVLB  A
0B09E:  MOVWF  xAD
0B0A0:  MOVLB  0
0B0A2:  CALL   1B6C
.................... 
....................         switch (smf_data->func_type) {
0B0A6:  MOVLW  01
0B0A8:  MOVLB  1
0B0AA:  ADDWF  x89,W
0B0AC:  MOVWF  FE9
0B0AE:  MOVLW  00
0B0B0:  ADDWFC x8A,W
0B0B2:  MOVWF  FEA
0B0B4:  MOVF   FEF,W
0B0B6:  XORLW  00
0B0B8:  MOVLB  0
0B0BA:  BTFSC  FD8.2
0B0BC:  GOTO   B0D4
0B0C0:  XORLW  01
0B0C2:  BTFSC  FD8.2
0B0C4:  GOTO   B0E4
0B0C8:  XORLW  03
0B0CA:  BTFSC  FD8.2
0B0CC:  GOTO   B0F4
0B0D0:  GOTO   B104
....................             case ENUM_SMF_WRITE:
....................                 smf_write(smf_data);
0B0D4:  MOVFF  18A,18C
0B0D8:  MOVFF  189,18B
0B0DC:  GOTO   9AB2
....................                 break;
0B0E0:  GOTO   B15A
....................             case ENUM_SMF_READ:
....................                 smf_read(smf_data);
0B0E4:  MOVFF  18A,18C
0B0E8:  MOVFF  189,18B
0B0EC:  GOTO   A60E
....................                 break;
0B0F0:  GOTO   B15A
....................             case ENUM_SMF_ERASE:
....................                 smf_erase(smf_data);
0B0F4:  MOVFF  18A,18C
0B0F8:  MOVFF  189,18B
0B0FC:  GOTO   A99E
....................                 break;
0B100:  GOTO   B15A
....................             default:
....................                 fprintf(PC, "\t\t   Unknown func_type=%u\r\n",
....................                         (unsigned int)smf_data->func_type);
0B104:  MOVLW  01
0B106:  MOVLB  1
0B108:  ADDWF  x89,W
0B10A:  MOVWF  FE9
0B10C:  MOVLW  00
0B10E:  ADDWFC x8A,W
0B110:  MOVWF  FEA
0B112:  MOVFF  FEF,18B
0B116:  MOVLW  AE
0B118:  MOVWF  FF6
0B11A:  MOVLW  12
0B11C:  MOVWF  FF7
0B11E:  MOVLW  00
0B120:  MOVWF  FF8
0B122:  MOVLW  17
0B124:  MOVLB  9
0B126:  MOVWF  xC2
0B128:  MOVLB  0
0B12A:  CALL   1BEE
0B12E:  MOVFF  18B,264
0B132:  MOVLW  1B
0B134:  MOVLB  2
0B136:  MOVWF  x65
0B138:  MOVLB  0
0B13A:  CALL   6388
0B13E:  MOVLW  0D
0B140:  MOVLB  A
0B142:  MOVWF  xAD
0B144:  MOVLB  0
0B146:  CALL   1B6C
0B14A:  MOVLW  0A
0B14C:  MOVLB  A
0B14E:  MOVWF  xAD
0B150:  MOVLB  0
0B152:  CALL   1B6C
....................                 break;
0B156:  GOTO   B15A
....................         }
....................         processed_count++;
0B15A:  MOVLB  1
0B15C:  INCF   x88,F
0B15E:  MOVLB  0
0B160:  GOTO   AF30
....................     }
.................... 
....................     fprintf(PC, "\t\t-> Completed %u operations\r\n",
....................             (unsigned int)processed_count);
0B164:  MOVLW  CA
0B166:  MOVWF  FF6
0B168:  MOVLW  12
0B16A:  MOVWF  FF7
0B16C:  MOVLW  00
0B16E:  MOVWF  FF8
0B170:  MOVLW  0F
0B172:  MOVLB  9
0B174:  MOVWF  xC2
0B176:  MOVLB  0
0B178:  CALL   1BEE
0B17C:  MOVFF  188,264
0B180:  MOVLW  1B
0B182:  MOVLB  2
0B184:  MOVWF  x65
0B186:  MOVLB  0
0B188:  CALL   6388
0B18C:  MOVLW  DB
0B18E:  MOVWF  FF6
0B190:  MOVLW  12
0B192:  MOVWF  FF7
0B194:  MOVLW  00
0B196:  MOVWF  FF8
0B198:  MOVLW  0D
0B19A:  MOVLB  9
0B19C:  MOVWF  xC2
0B19E:  MOVLB  0
0B1A0:  CALL   1BEE
.................... 
....................     status[0] = FINISHED;
0B1A4:  MOVLW  06
0B1A6:  MOVWF  48
0B1A8:  GOTO   B222 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[])
.................... {
....................    unsigned int8 measurement_step = uplinkcmd[1]; // Get the measurement step from the parameter array
....................    fprintf(PC, "Start MODE TEST IV\r\n");
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(uplinkcmd); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
.................... //!   sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = ENUM_SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
0898E:  MOVLW  8E
08990:  MOVWF  FF6
08992:  MOVLW  13
08994:  MOVWF  FF7
08996:  MOVLW  00
08998:  MOVWF  FF8
0899A:  CALL   1BBE
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
0899E:  MOVFF  18E,1B2
089A2:  MOVFF  18D,1B1
089A6:  GOTO   6232
089AA:  MOVFF  02,03
089AE:  MOVF   01,W
089B0:  MOVWF  FE1
089B2:  MOVFF  03,FE2
089B6:  MOVLW  01
089B8:  MOVWF  FEA
089BA:  MOVLW  8F
089BC:  MOVWF  FE9
089BE:  MOVLW  0C
089C0:  MOVWF  01
089C2:  MOVFF  FE6,FEE
089C6:  DECFSZ 01,F
089C8:  GOTO   89C2
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
089CC:  MOVLW  A4
089CE:  MOVWF  FF6
089D0:  MOVLW  13
089D2:  MOVWF  FF7
089D4:  MOVLW  00
089D6:  MOVWF  FF8
089D8:  MOVLW  05
089DA:  MOVLB  9
089DC:  MOVWF  xC2
089DE:  MOVLB  0
089E0:  CALL   1BEE
089E4:  MOVFF  18F,264
089E8:  MOVLW  37
089EA:  MOVLB  2
089EC:  MOVWF  x65
089EE:  MOVLB  0
089F0:  CALL   1E42
089F4:  MOVLW  0D
089F6:  MOVLB  A
089F8:  MOVWF  xAD
089FA:  MOVLB  0
089FC:  CALL   1B6C
08A00:  MOVLW  0A
08A02:  MOVLB  A
08A04:  MOVWF  xAD
08A06:  MOVLB  0
08A08:  CALL   1B6C
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
08A0C:  MOVLW  B0
08A0E:  MOVWF  FF6
08A10:  MOVLW  13
08A12:  MOVWF  FF7
08A14:  MOVLW  00
08A16:  MOVWF  FF8
08A18:  MOVLW  0D
08A1A:  MOVLB  9
08A1C:  MOVWF  xC2
08A1E:  MOVLB  0
08A20:  CALL   1BEE
08A24:  MOVFF  191,264
08A28:  MOVLW  37
08A2A:  MOVLB  2
08A2C:  MOVWF  x65
08A2E:  MOVLB  0
08A30:  CALL   1E42
08A34:  MOVFF  190,264
08A38:  MOVLW  37
08A3A:  MOVLB  2
08A3C:  MOVWF  x65
08A3E:  MOVLB  0
08A40:  CALL   1E42
08A44:  MOVLW  C2
08A46:  MOVWF  FF6
08A48:  MOVLW  13
08A4A:  MOVWF  FF7
08A4C:  MOVLW  00
08A4E:  MOVWF  FF8
08A50:  MOVLW  05
08A52:  MOVLB  9
08A54:  MOVWF  xC2
08A56:  MOVLB  0
08A58:  CALL   1BEE
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
08A5C:  MOVLW  C8
08A5E:  MOVWF  FF6
08A60:  MOVLW  13
08A62:  MOVWF  FF7
08A64:  MOVLW  00
08A66:  MOVWF  FF8
08A68:  MOVLW  14
08A6A:  MOVLB  9
08A6C:  MOVWF  xC2
08A6E:  MOVLB  0
08A70:  CALL   1BEE
08A74:  MOVFF  193,264
08A78:  MOVLW  37
08A7A:  MOVLB  2
08A7C:  MOVWF  x65
08A7E:  MOVLB  0
08A80:  CALL   1E42
08A84:  MOVFF  192,264
08A88:  MOVLW  37
08A8A:  MOVLB  2
08A8C:  MOVWF  x65
08A8E:  MOVLB  0
08A90:  CALL   1E42
08A94:  MOVLW  E1
08A96:  MOVWF  FF6
08A98:  MOVLW  13
08A9A:  MOVWF  FF7
08A9C:  MOVLW  00
08A9E:  MOVWF  FF8
08AA0:  MOVLW  05
08AA2:  MOVLB  9
08AA4:  MOVWF  xC2
08AA6:  MOVLB  0
08AA8:  CALL   1BEE
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
08AAC:  MOVLW  E8
08AAE:  MOVWF  FF6
08AB0:  MOVLW  13
08AB2:  MOVWF  FF7
08AB4:  MOVLW  00
08AB6:  MOVWF  FF8
08AB8:  MOVLW  0F
08ABA:  MOVLB  9
08ABC:  MOVWF  xC2
08ABE:  MOVLB  0
08AC0:  CALL   1BEE
08AC4:  MOVFF  195,264
08AC8:  MOVLW  37
08ACA:  MOVLB  2
08ACC:  MOVWF  x65
08ACE:  MOVLB  0
08AD0:  CALL   1E42
08AD4:  MOVFF  194,264
08AD8:  MOVLW  37
08ADA:  MOVLB  2
08ADC:  MOVWF  x65
08ADE:  MOVLB  0
08AE0:  CALL   1E42
08AE4:  MOVLW  FC
08AE6:  MOVWF  FF6
08AE8:  MOVLW  13
08AEA:  MOVWF  FF7
08AEC:  MOVLW  00
08AEE:  MOVWF  FF8
08AF0:  MOVLW  05
08AF2:  MOVLB  9
08AF4:  MOVWF  xC2
08AF6:  MOVLB  0
08AF8:  CALL   1BEE
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
08AFC:  MOVLW  02
08AFE:  MOVWF  FF6
08B00:  MOVLW  14
08B02:  MOVWF  FF7
08B04:  MOVLW  00
08B06:  MOVWF  FF8
08B08:  MOVLW  10
08B0A:  MOVLB  9
08B0C:  MOVWF  xC2
08B0E:  MOVLB  0
08B10:  CALL   1BEE
08B14:  MOVFF  197,264
08B18:  MOVLW  37
08B1A:  MOVLB  2
08B1C:  MOVWF  x65
08B1E:  MOVLB  0
08B20:  CALL   1E42
08B24:  MOVFF  196,264
08B28:  MOVLW  37
08B2A:  MOVLB  2
08B2C:  MOVWF  x65
08B2E:  MOVLB  0
08B30:  CALL   1E42
08B34:  MOVLW  17
08B36:  MOVWF  FF6
08B38:  MOVLW  14
08B3A:  MOVWF  FF7
08B3C:  MOVLW  00
08B3E:  MOVWF  FF8
08B40:  MOVLW  05
08B42:  MOVLB  9
08B44:  MOVWF  xC2
08B46:  MOVLB  0
08B48:  CALL   1BEE
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
08B4C:  MOVLW  1E
08B4E:  MOVWF  FF6
08B50:  MOVLW  14
08B52:  MOVWF  FF7
08B54:  MOVLW  00
08B56:  MOVWF  FF8
08B58:  MOVLW  13
08B5A:  MOVLB  9
08B5C:  MOVWF  xC2
08B5E:  MOVLB  0
08B60:  CALL   1BEE
08B64:  MOVFF  199,264
08B68:  MOVLW  37
08B6A:  MOVLB  2
08B6C:  MOVWF  x65
08B6E:  MOVLB  0
08B70:  CALL   1E42
08B74:  MOVFF  198,264
08B78:  MOVLW  37
08B7A:  MOVLB  2
08B7C:  MOVWF  x65
08B7E:  MOVLB  0
08B80:  CALL   1E42
08B84:  MOVLW  36
08B86:  MOVWF  FF6
08B88:  MOVLW  14
08B8A:  MOVWF  FF7
08B8C:  MOVLW  00
08B8E:  MOVWF  FF8
08B90:  MOVLW  04
08B92:  MOVLB  9
08B94:  MOVWF  xC2
08B96:  MOVLB  0
08B98:  CALL   1BEE
....................    fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
08B9C:  MOVLW  3C
08B9E:  MOVWF  FF6
08BA0:  MOVLW  14
08BA2:  MOVWF  FF7
08BA4:  MOVLW  00
08BA6:  MOVWF  FF8
08BA8:  MOVLW  0E
08BAA:  MOVLB  9
08BAC:  MOVWF  xC2
08BAE:  MOVLB  0
08BB0:  CALL   1BEE
08BB4:  MOVFF  19A,264
08BB8:  MOVLW  1B
08BBA:  MOVLB  2
08BBC:  MOVWF  x65
08BBE:  MOVLB  0
08BC0:  CALL   6388
08BC4:  MOVLW  0D
08BC6:  MOVLB  A
08BC8:  MOVWF  xAD
08BCA:  MOVLB  0
08BCC:  CALL   1B6C
08BD0:  MOVLW  0A
08BD2:  MOVLB  A
08BD4:  MOVWF  xAD
08BD6:  MOVLB  0
08BD8:  CALL   1B6C
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
08BDC:  MOVFF  18F,1E0
08BE0:  MOVLB  1
08BE2:  CLRF   xE1
08BE4:  MOVLB  0
08BE6:  CALL   3862
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
08BEA:  CALL   31C0
08BEE:  MOVFF  01,19C
08BF2:  MOVFF  00,19B
08BF6:  MOVLB  1
08BF8:  CLRF   x9E
08BFA:  CLRF   x9D
08BFC:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
08BFE:  CALL   31C0
08C02:  MOVFF  03,1AE
08C06:  MOVFF  02,1AD
08C0A:  MOVFF  01,1AC
08C0E:  MOVFF  00,1AB
08C12:  MOVLB  1
08C14:  MOVF   x9B,W
08C16:  SUBWF  xAB,F
08C18:  MOVF   x9C,W
08C1A:  SUBWFB xAC,F
08C1C:  MOVLW  00
08C1E:  SUBWFB xAD,F
08C20:  MOVLW  00
08C22:  SUBWFB xAE,F
08C24:  MOVF   xAE,F
08C26:  BTFSC  FD8.2
08C28:  BRA    8C30
08C2A:  MOVLB  0
08C2C:  GOTO   8CFA
08C30:  MOVLB  0
08C32:  MOVLB  1
08C34:  MOVF   xAD,F
08C36:  BTFSC  FD8.2
08C38:  BRA    8C40
08C3A:  MOVLB  0
08C3C:  GOTO   8CFA
08C40:  MOVLB  0
08C42:  MOVLB  1
08C44:  MOVF   xAC,W
08C46:  SUBWF  x99,W
08C48:  BTFSC  FD8.0
08C4A:  BRA    8C52
08C4C:  MOVLB  0
08C4E:  GOTO   8CFA
08C52:  MOVLB  0
08C54:  BTFSS  FD8.2
08C56:  GOTO   8C6C
08C5A:  MOVLB  1
08C5C:  MOVF   x98,W
08C5E:  SUBWF  xAB,W
08C60:  BTFSS  FD8.0
08C62:  BRA    8C6A
08C64:  MOVLB  0
08C66:  GOTO   8CFA
08C6A:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
08C6C:  CALL   31C0
08C70:  MOVFF  01,19E
08C74:  MOVFF  00,19D
....................       if (current_sec - start_time >= cmd.meas_time) {
08C78:  MOVLB  1
08C7A:  MOVF   x9B,W
08C7C:  SUBWF  x9D,W
08C7E:  MOVWF  xAB
08C80:  MOVF   x9C,W
08C82:  SUBWFB x9E,W
08C84:  MOVWF  xAC
08C86:  MOVF   x99,W
08C88:  SUBWF  xAC,W
08C8A:  BTFSC  FD8.0
08C8C:  BRA    8C94
08C8E:  MOVLB  0
08C90:  GOTO   8CB2
08C94:  MOVLB  0
08C96:  BTFSS  FD8.2
08C98:  GOTO   8CAE
08C9C:  MOVLB  1
08C9E:  MOVF   x98,W
08CA0:  SUBWF  xAB,W
08CA2:  BTFSC  FD8.0
08CA4:  BRA    8CAC
08CA6:  MOVLB  0
08CA8:  GOTO   8CB2
08CAC:  MOVLB  0
....................           break;
08CAE:  GOTO   8CFA
....................       }
....................       sweep_with_threshold(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
08CB2:  MOVFF  193,1AC
08CB6:  MOVFF  192,1AB
08CBA:  MOVFF  195,1AE
08CBE:  MOVFF  194,1AD
08CC2:  MOVFF  197,1B0
08CC6:  MOVFF  196,1AF
08CCA:  GOTO   7146
....................       // Sleep for the specified time
....................       delay_ms(cmd.sleep_time);
08CCE:  MOVFF  191,1AB
08CD2:  MOVLB  1
08CD4:  INCF   xAB,F
08CD6:  MOVLB  0
08CD8:  MOVLB  1
08CDA:  DECFSZ xAB,F
08CDC:  BRA    8CE2
08CDE:  MOVLB  0
08CE0:  BRA    8CEE
08CE2:  MOVLB  A
08CE4:  SETF   x6E
08CE6:  MOVLB  0
08CE8:  CALL   1B3E
08CEC:  BRA    8CD8
08CEE:  MOVFF  190,A6E
08CF2:  CALL   1B3E
08CF6:  GOTO   8BFE
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
08CFA:  MOVFF  18F,1E0
08CFE:  MOVLB  1
08D00:  SETF   xE1
08D02:  MOVLB  0
08D04:  CALL   3862
.................... 
....................    FlashOperationStruct data = {0};
08D08:  MOVLB  1
08D0A:  CLRF   x9F
08D0C:  CLRF   xA0
08D0E:  CLRF   xA1
08D10:  CLRF   xA2
08D12:  CLRF   xA3
08D14:  CLRF   xA4
08D16:  CLRF   xA5
08D18:  CLRF   xA6
08D1A:  CLRF   xA7
08D1C:  CLRF   xA8
08D1E:  CLRF   xA9
08D20:  CLRF   xAA
....................    data.func_type = ENUM_SMF_WRITE;
08D22:  CLRF   xA0
....................    data.mission_id = CIGS_IV_DATA; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
08D24:  MOVLW  04
08D26:  MOVWF  x9F
....................    data.write_mode = SMF_WRITE_CIRCULAR;
08D28:  MOVLW  02
08D2A:  MOVWF  xA1
....................    data.source_type = SOURCE_MISF_UNCOPIED;
08D2C:  BCF    xA2.0
....................    // data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    // data.size = 0; // コピーするデータのサイズ
.................... 
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
08D2E:  MOVLW  50
08D30:  MOVWF  FF6
08D32:  MOVLW  14
08D34:  MOVWF  FF7
08D36:  MOVLW  00
08D38:  MOVWF  FF8
08D3A:  MOVLB  0
08D3C:  CALL   1BBE
....................    fprintf(PC, "Mission ID:   %02X\r\n", data.mission_id);
08D40:  MOVLW  6A
08D42:  MOVWF  FF6
08D44:  MOVLW  14
08D46:  MOVWF  FF7
08D48:  MOVLW  00
08D4A:  MOVWF  FF8
08D4C:  MOVLW  0E
08D4E:  MOVLB  9
08D50:  MOVWF  xC2
08D52:  MOVLB  0
08D54:  CALL   1BEE
08D58:  MOVFF  19F,264
08D5C:  MOVLW  37
08D5E:  MOVLB  2
08D60:  MOVWF  x65
08D62:  MOVLB  0
08D64:  CALL   1E42
08D68:  MOVLW  0D
08D6A:  MOVLB  A
08D6C:  MOVWF  xAD
08D6E:  MOVLB  0
08D70:  CALL   1B6C
08D74:  MOVLW  0A
08D76:  MOVLB  A
08D78:  MOVWF  xAD
08D7A:  MOVLB  0
08D7C:  CALL   1B6C
....................    fprintf(PC, "Function Type:%02X\r\n", data.func_type);
08D80:  MOVLW  80
08D82:  MOVWF  FF6
08D84:  MOVLW  14
08D86:  MOVWF  FF7
08D88:  MOVLW  00
08D8A:  MOVWF  FF8
08D8C:  MOVLW  0E
08D8E:  MOVLB  9
08D90:  MOVWF  xC2
08D92:  MOVLB  0
08D94:  CALL   1BEE
08D98:  MOVFF  1A0,264
08D9C:  MOVLW  37
08D9E:  MOVLB  2
08DA0:  MOVWF  x65
08DA2:  MOVLB  0
08DA4:  CALL   1E42
08DA8:  MOVLW  0D
08DAA:  MOVLB  A
08DAC:  MOVWF  xAD
08DAE:  MOVLB  0
08DB0:  CALL   1B6C
08DB4:  MOVLW  0A
08DB6:  MOVLB  A
08DB8:  MOVWF  xAD
08DBA:  MOVLB  0
08DBC:  CALL   1B6C
....................    fprintf(PC, "Write Mode:   %02X\r\n", data.write_mode);
08DC0:  MOVLW  96
08DC2:  MOVWF  FF6
08DC4:  MOVLW  14
08DC6:  MOVWF  FF7
08DC8:  MOVLW  00
08DCA:  MOVWF  FF8
08DCC:  MOVLW  0E
08DCE:  MOVLB  9
08DD0:  MOVWF  xC2
08DD2:  MOVLB  0
08DD4:  CALL   1BEE
08DD8:  MOVFF  1A1,264
08DDC:  MOVLW  37
08DDE:  MOVLB  2
08DE0:  MOVWF  x65
08DE2:  MOVLB  0
08DE4:  CALL   1E42
08DE8:  MOVLW  0D
08DEA:  MOVLB  A
08DEC:  MOVWF  xAD
08DEE:  MOVLB  0
08DF0:  CALL   1B6C
08DF4:  MOVLW  0A
08DF6:  MOVLB  A
08DF8:  MOVWF  xAD
08DFA:  MOVLB  0
08DFC:  CALL   1B6C
....................    fprintf(PC, "Source Type:  %02X\r\n", data.source_type);
08E00:  MOVLW  00
08E02:  MOVLB  1
08E04:  BTFSC  xA2.0
08E06:  MOVLW  01
08E08:  MOVWF  xAB
08E0A:  MOVLW  AC
08E0C:  MOVWF  FF6
08E0E:  MOVLW  14
08E10:  MOVWF  FF7
08E12:  MOVLW  00
08E14:  MOVWF  FF8
08E16:  MOVLW  0E
08E18:  MOVLB  9
08E1A:  MOVWF  xC2
08E1C:  MOVLB  0
08E1E:  CALL   1BEE
08E22:  MOVFF  1AB,264
08E26:  MOVLW  37
08E28:  MOVLB  2
08E2A:  MOVWF  x65
08E2C:  MOVLB  0
08E2E:  CALL   1E42
08E32:  MOVLW  0D
08E34:  MOVLB  A
08E36:  MOVWF  xAD
08E38:  MOVLB  0
08E3A:  CALL   1B6C
08E3E:  MOVLW  0A
08E40:  MOVLB  A
08E42:  MOVWF  xAD
08E44:  MOVLB  0
08E46:  CALL   1B6C
....................    fprintf(PC, "Start Address:%04X\r\n", data.misf_start_addr);
08E4A:  MOVLW  C2
08E4C:  MOVWF  FF6
08E4E:  MOVLW  14
08E50:  MOVWF  FF7
08E52:  MOVLW  00
08E54:  MOVWF  FF8
08E56:  MOVLW  0E
08E58:  MOVLB  9
08E5A:  MOVWF  xC2
08E5C:  MOVLB  0
08E5E:  CALL   1BEE
08E62:  MOVLW  02
08E64:  MOVLB  1
08E66:  MOVWF  xAB
08E68:  MOVLB  0
08E6A:  MOVLW  30
08E6C:  MOVLB  A
08E6E:  MOVWF  xAD
08E70:  MOVLB  0
08E72:  CALL   1B6C
08E76:  MOVLB  1
08E78:  DECFSZ xAB,F
08E7A:  BRA    8E80
08E7C:  BRA    8E86
08E7E:  MOVLB  0
08E80:  MOVLB  0
08E82:  GOTO   8E6A
08E86:  MOVFF  1A3,264
08E8A:  MOVLW  37
08E8C:  MOVLB  2
08E8E:  MOVWF  x65
08E90:  MOVLB  0
08E92:  CALL   1E42
08E96:  MOVLW  0D
08E98:  MOVLB  A
08E9A:  MOVWF  xAD
08E9C:  MOVLB  0
08E9E:  CALL   1B6C
08EA2:  MOVLW  0A
08EA4:  MOVLB  A
08EA6:  MOVWF  xAD
08EA8:  MOVLB  0
08EAA:  CALL   1B6C
....................    fprintf(PC, "Size:         %04X\r\n", data.misf_size);
08EAE:  MOVLW  D8
08EB0:  MOVWF  FF6
08EB2:  MOVLW  14
08EB4:  MOVWF  FF7
08EB6:  MOVLW  00
08EB8:  MOVWF  FF8
08EBA:  MOVLW  0E
08EBC:  MOVLB  9
08EBE:  MOVWF  xC2
08EC0:  MOVLB  0
08EC2:  CALL   1BEE
08EC6:  MOVLW  02
08EC8:  MOVLB  1
08ECA:  MOVWF  xAB
08ECC:  MOVLB  0
08ECE:  MOVLW  30
08ED0:  MOVLB  A
08ED2:  MOVWF  xAD
08ED4:  MOVLB  0
08ED6:  CALL   1B6C
08EDA:  MOVLB  1
08EDC:  DECFSZ xAB,F
08EDE:  BRA    8EE4
08EE0:  BRA    8EEA
08EE2:  MOVLB  0
08EE4:  MOVLB  0
08EE6:  GOTO   8ECE
08EEA:  MOVFF  1A7,264
08EEE:  MOVLW  37
08EF0:  MOVLB  2
08EF2:  MOVWF  x65
08EF4:  MOVLB  0
08EF6:  CALL   1E42
08EFA:  MOVLW  0D
08EFC:  MOVLB  A
08EFE:  MOVWF  xAD
08F00:  MOVLB  0
08F02:  CALL   1B6C
08F06:  MOVLW  0A
08F08:  MOVLB  A
08F0A:  MOVWF  xAD
08F0C:  MOVLB  0
08F0E:  CALL   1B6C
.................... 
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
08F12:  MOVLW  01
08F14:  MOVLB  1
08F16:  MOVWF  xAC
08F18:  MOVLW  9F
08F1A:  MOVWF  xAB
08F1C:  MOVLB  0
08F1E:  GOTO   872C
.................... 
....................    fprintf(PC, "End MODE MEAS IV mission\r\n");
08F22:  MOVLW  EE
08F24:  MOVWF  FF6
08F26:  MOVLW  14
08F28:  MOVWF  FF7
08F2A:  MOVLW  00
08F2C:  MOVWF  FF8
08F2E:  CALL   1BBE
08F32:  GOTO   9170 (RETURN)
.................... }
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
06232:  MOVLB  1
06234:  MOVF   xB1,W
06236:  MOVWF  FE9
06238:  MOVF   xB2,W
0623A:  MOVWF  FEA
0623C:  MOVFF  FEF,1B3
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
06240:  MOVLW  01
06242:  ADDWF  xB1,W
06244:  MOVWF  FE9
06246:  MOVLW  00
06248:  ADDWFC xB2,W
0624A:  MOVWF  FEA
0624C:  MOVF   FEF,W
0624E:  CLRF   xC0
06250:  MOVWF  xBF
06252:  MOVFF  1BF,1C0
06256:  CLRF   xBF
06258:  MOVLW  02
0625A:  ADDWF  xB1,W
0625C:  MOVWF  FE9
0625E:  MOVLW  00
06260:  ADDWFC xB2,W
06262:  MOVWF  FEA
06264:  MOVF   FEF,W
06266:  CLRF   03
06268:  IORWF  xBF,W
0626A:  MOVWF  xB4
0626C:  MOVF   03,W
0626E:  IORWF  xC0,W
06270:  MOVWF  xB5
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
06272:  MOVLW  03
06274:  ADDWF  xB1,W
06276:  MOVWF  FE9
06278:  MOVLW  00
0627A:  ADDWFC xB2,W
0627C:  MOVWF  FEA
0627E:  MOVF   FEF,W
06280:  CLRF   xC0
06282:  MOVWF  xBF
06284:  RLCF   xBF,W
06286:  MOVWF  xB6
06288:  RLCF   xC0,W
0628A:  MOVWF  xB7
0628C:  RLCF   xB6,F
0628E:  RLCF   xB7,F
06290:  RLCF   xB6,F
06292:  RLCF   xB7,F
06294:  RLCF   xB6,F
06296:  RLCF   xB7,F
06298:  MOVLW  F0
0629A:  ANDWF  xB6,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
0629C:  MOVLW  04
0629E:  ADDWF  xB1,W
062A0:  MOVWF  FE9
062A2:  MOVLW  00
062A4:  ADDWFC xB2,W
062A6:  MOVWF  FEA
062A8:  MOVF   FEF,W
062AA:  CLRF   xC0
062AC:  MOVWF  xBF
062AE:  RLCF   xBF,W
062B0:  MOVWF  xB8
062B2:  RLCF   xC0,W
062B4:  MOVWF  xB9
062B6:  RLCF   xB8,F
062B8:  RLCF   xB9,F
062BA:  RLCF   xB8,F
062BC:  RLCF   xB9,F
062BE:  RLCF   xB8,F
062C0:  RLCF   xB9,F
062C2:  MOVLW  F0
062C4:  ANDWF  xB8,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
062C6:  MOVLW  05
062C8:  ADDWF  xB1,W
062CA:  MOVWF  FE9
062CC:  MOVLW  00
062CE:  ADDWFC xB2,W
062D0:  MOVWF  FEA
062D2:  MOVF   FEF,W
062D4:  CLRF   xC0
062D6:  MOVWF  xBF
062D8:  RLCF   xBF,W
062DA:  MOVWF  xBA
062DC:  RLCF   xC0,W
062DE:  MOVWF  xBB
062E0:  RLCF   xBA,F
062E2:  RLCF   xBB,F
062E4:  RLCF   xBA,F
062E6:  RLCF   xBB,F
062E8:  RLCF   xBA,F
062EA:  RLCF   xBB,F
062EC:  MOVLW  F0
062EE:  ANDWF  xBA,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
062F0:  MOVLW  06
062F2:  ADDWF  xB1,W
062F4:  MOVWF  FE9
062F6:  MOVLW  00
062F8:  ADDWFC xB2,W
062FA:  MOVWF  FEA
062FC:  MOVF   FEF,W
062FE:  CLRF   xC0
06300:  MOVWF  xBF
06302:  MOVFF  1BF,1C0
06306:  CLRF   xBF
06308:  MOVLW  07
0630A:  ADDWF  xB1,W
0630C:  MOVWF  FE9
0630E:  MOVLW  00
06310:  ADDWFC xB2,W
06312:  MOVWF  FEA
06314:  MOVF   FEF,W
06316:  CLRF   03
06318:  IORWF  xBF,W
0631A:  MOVWF  xBC
0631C:  MOVF   03,W
0631E:  IORWF  xC0,W
06320:  MOVWF  xBD
....................    cmd.is_finished = uplinkcmd[8];
06322:  MOVLW  08
06324:  ADDWF  xB1,W
06326:  MOVWF  FE9
06328:  MOVLW  00
0632A:  ADDWFC xB2,W
0632C:  MOVWF  FEA
0632E:  MOVFF  FEF,1BE
....................    return cmd;
06332:  MOVLW  B3
06334:  MOVWF  01
06336:  MOVLW  01
06338:  MOVWF  02
0633A:  MOVLB  0
0633C:  GOTO   89AA (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
0440E:  MOVLW  0A
04410:  MOVWF  FF6
04412:  MOVLW  15
04414:  MOVWF  FF7
04416:  MOVLW  00
04418:  MOVWF  FF8
0441A:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
0441E:  MOVLB  1
04420:  MOVF   x8F,W
04422:  MOVWF  FE9
04424:  MOVF   x90,W
04426:  MOVWF  FEA
04428:  MOVFF  FEF,191
....................    piclog_make(cmd, 0x00); // Log the command execution
0442C:  MOVFF  191,1E0
04430:  CLRF   xE1
04432:  MOVLB  0
04434:  CALL   3862
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
04438:  MOVLB  1
0443A:  CLRF   x95
0443C:  CLRF   x94
0443E:  CLRF   x93
04440:  CLRF   x92
04442:  MOVLB  0
04444:  MOVLB  1
04446:  MOVF   x95,F
04448:  BTFSC  FD8.2
0444A:  BRA    4452
0444C:  MOVLB  0
0444E:  GOTO   44CA
04452:  MOVLB  0
04454:  MOVLB  1
04456:  MOVF   x94,W
04458:  SUBLW  0F
0445A:  BTFSC  FD8.0
0445C:  BRA    4464
0445E:  MOVLB  0
04460:  GOTO   44CA
04464:  MOVLB  0
04466:  BTFSS  FD8.2
04468:  GOTO   4496
0446C:  MOVLB  1
0446E:  MOVF   x93,W
04470:  SUBLW  FF
04472:  BTFSC  FD8.0
04474:  BRA    447C
04476:  MOVLB  0
04478:  GOTO   44CA
0447C:  MOVLB  0
0447E:  BTFSS  FD8.2
04480:  GOTO   4496
04484:  MOVLB  1
04486:  MOVF   x92,W
04488:  SUBLW  FE
0448A:  BTFSC  FD8.0
0448C:  BRA    4494
0448E:  MOVLB  0
04490:  GOTO   44CA
04494:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
04496:  MOVFF  111,A59
0449A:  MOVFF  110,A58
0449E:  MOVFF  10F,A57
044A2:  MOVFF  10E,A56
044A6:  MOVFF  195,A5D
044AA:  MOVFF  194,A5C
044AE:  MOVFF  193,A5B
044B2:  MOVFF  192,A5A
044B6:  CALL   40B6
044BA:  MOVLW  01
044BC:  MOVLB  1
044BE:  ADDWF  x94,F
044C0:  MOVLW  00
044C2:  ADDWFC x95,F
044C4:  MOVLB  0
044C6:  GOTO   4444
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
044CA:  MOVFF  191,1E0
044CE:  MOVLB  1
044D0:  SETF   xE1
044D2:  MOVLB  0
044D4:  CALL   3862
....................    printf("End Flash Erase All\r\n");
044D8:  MOVLW  22
044DA:  MOVWF  FF6
044DC:  MOVLW  15
044DE:  MOVWF  FF7
044E0:  MOVLW  00
044E2:  MOVWF  FF8
044E4:  CALL   1BBE
044E8:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
044EA:  MOVLW  38
044EC:  MOVWF  FF6
044EE:  MOVLW  15
044F0:  MOVWF  FF7
044F2:  MOVLW  00
044F4:  MOVWF  FF8
044F6:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
044FA:  MOVLB  1
044FC:  MOVF   x8D,W
044FE:  MOVWF  FE9
04500:  MOVF   x8E,W
04502:  MOVWF  FEA
04504:  MOVFF  FEF,18F
04508:  MOVLW  01
0450A:  ADDWF  x8D,W
0450C:  MOVWF  FE9
0450E:  MOVLW  00
04510:  ADDWFC x8E,W
04512:  MOVWF  FEA
04514:  MOVF   FEF,W
04516:  CLRF   x97
04518:  CLRF   x96
0451A:  CLRF   x95
0451C:  MOVWF  x94
0451E:  MOVFF  194,197
04522:  CLRF   x94
04524:  CLRF   x95
04526:  CLRF   x96
04528:  MOVLW  02
0452A:  ADDWF  x8D,W
0452C:  MOVWF  FE9
0452E:  MOVLW  00
04530:  ADDWFC x8E,W
04532:  MOVWF  FEA
04534:  MOVF   FEF,W
04536:  CLRF   x9C
04538:  CLRF   x9B
0453A:  CLRF   x9A
0453C:  MOVWF  x99
0453E:  MOVFF  19A,03
04542:  MOVFF  199,02
04546:  CLRF   00
04548:  CLRF   01
0454A:  MOVF   00,W
0454C:  IORWF  x94,F
0454E:  MOVF   01,W
04550:  IORWF  x95,F
04552:  MOVF   02,W
04554:  IORWF  x96,F
04556:  MOVF   03,W
04558:  IORWF  x97,F
0455A:  MOVLW  03
0455C:  ADDWF  x8D,W
0455E:  MOVWF  FE9
04560:  MOVLW  00
04562:  ADDWFC x8E,W
04564:  MOVWF  FEA
04566:  MOVF   FEF,W
04568:  CLRF   x9C
0456A:  CLRF   x9B
0456C:  CLRF   x9A
0456E:  MOVWF  x99
04570:  MOVFF  19B,03
04574:  MOVFF  19A,02
04578:  MOVFF  199,01
0457C:  CLRF   00
0457E:  MOVF   00,W
04580:  IORWF  x94,F
04582:  MOVF   01,W
04584:  IORWF  x95,F
04586:  MOVF   02,W
04588:  IORWF  x96,F
0458A:  MOVF   03,W
0458C:  IORWF  x97,F
0458E:  MOVLW  04
04590:  ADDWF  x8D,W
04592:  MOVWF  FE9
04594:  MOVLW  00
04596:  ADDWFC x8E,W
04598:  MOVWF  FEA
0459A:  MOVF   FEF,W
0459C:  MOVWF  00
0459E:  CLRF   01
045A0:  CLRF   02
045A2:  CLRF   03
045A4:  MOVF   00,W
045A6:  IORWF  x94,W
045A8:  MOVWF  x90
045AA:  MOVF   01,W
045AC:  IORWF  x95,W
045AE:  MOVWF  x91
045B0:  MOVF   02,W
045B2:  IORWF  x96,W
045B4:  MOVWF  x92
045B6:  MOVF   03,W
045B8:  IORWF  x97,W
045BA:  MOVWF  x93
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
045BC:  MOVLW  56
045BE:  MOVWF  FF6
045C0:  MOVLW  15
045C2:  MOVWF  FF7
045C4:  MOVLW  00
045C6:  MOVWF  FF8
045C8:  MOVLW  13
045CA:  MOVLB  9
045CC:  MOVWF  xC2
045CE:  MOVLB  0
045D0:  CALL   1BEE
045D4:  MOVFF  193,264
045D8:  MOVLW  37
045DA:  MOVLB  2
045DC:  MOVWF  x65
045DE:  MOVLB  0
045E0:  CALL   1E42
045E4:  MOVFF  192,264
045E8:  MOVLW  37
045EA:  MOVLB  2
045EC:  MOVWF  x65
045EE:  MOVLB  0
045F0:  CALL   1E42
045F4:  MOVFF  191,264
045F8:  MOVLW  37
045FA:  MOVLB  2
045FC:  MOVWF  x65
045FE:  MOVLB  0
04600:  CALL   1E42
04604:  MOVFF  190,264
04608:  MOVLW  37
0460A:  MOVLB  2
0460C:  MOVWF  x65
0460E:  MOVLB  0
04610:  CALL   1E42
04614:  MOVLW  0D
04616:  MOVLB  A
04618:  MOVWF  xAD
0461A:  MOVLB  0
0461C:  CALL   1B6C
04620:  MOVLW  0A
04622:  MOVLB  A
04624:  MOVWF  xAD
04626:  MOVLB  0
04628:  CALL   1B6C
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
0462C:  MOVFF  18F,1E0
04630:  MOVLB  1
04632:  CLRF   xE1
04634:  MOVLB  0
04636:  CALL   3862
....................    
....................    sector_erase(mis_fm, sector_address);
0463A:  MOVFF  111,A59
0463E:  MOVFF  110,A58
04642:  MOVFF  10F,A57
04646:  MOVFF  10E,A56
0464A:  MOVFF  193,A5D
0464E:  MOVFF  192,A5C
04652:  MOVFF  191,A5B
04656:  MOVFF  190,A5A
0465A:  CALL   40B6
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0465E:  MOVFF  18F,1E0
04662:  MOVLB  1
04664:  SETF   xE1
04666:  MOVLB  0
04668:  CALL   3862
....................    printf("End Flash Erase 1 Sector\r\n");
0466C:  MOVLW  72
0466E:  MOVWF  FF6
04670:  MOVLW  15
04672:  MOVWF  FF7
04674:  MOVLW  00
04676:  MOVWF  FF8
04678:  CALL   1BBE
0467C:  GOTO   9080 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
049DC:  MOVLW  8E
049DE:  MOVWF  FF6
049E0:  MOVLW  15
049E2:  MOVWF  FF7
049E4:  MOVLW  00
049E6:  MOVWF  FF8
049E8:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
049EC:  MOVLB  1
049EE:  MOVF   x8D,W
049F0:  MOVWF  FE9
049F2:  MOVF   x8E,W
049F4:  MOVWF  FEA
049F6:  MOVFF  FEF,18F
049FA:  MOVLW  01
049FC:  ADDWF  x8D,W
049FE:  MOVWF  FE9
04A00:  MOVLW  00
04A02:  ADDWFC x8E,W
04A04:  MOVWF  FEA
04A06:  MOVF   FEF,W
04A08:  CLRF   x97
04A0A:  CLRF   x96
04A0C:  CLRF   x95
04A0E:  MOVWF  x94
04A10:  MOVFF  194,197
04A14:  CLRF   x94
04A16:  CLRF   x95
04A18:  CLRF   x96
04A1A:  MOVLW  02
04A1C:  ADDWF  x8D,W
04A1E:  MOVWF  FE9
04A20:  MOVLW  00
04A22:  ADDWFC x8E,W
04A24:  MOVWF  FEA
04A26:  MOVF   FEF,W
04A28:  CLRF   x9C
04A2A:  CLRF   x9B
04A2C:  CLRF   x9A
04A2E:  MOVWF  x99
04A30:  MOVFF  19A,03
04A34:  MOVFF  199,02
04A38:  CLRF   00
04A3A:  CLRF   01
04A3C:  MOVF   00,W
04A3E:  IORWF  x94,F
04A40:  MOVF   01,W
04A42:  IORWF  x95,F
04A44:  MOVF   02,W
04A46:  IORWF  x96,F
04A48:  MOVF   03,W
04A4A:  IORWF  x97,F
04A4C:  MOVLW  03
04A4E:  ADDWF  x8D,W
04A50:  MOVWF  FE9
04A52:  MOVLW  00
04A54:  ADDWFC x8E,W
04A56:  MOVWF  FEA
04A58:  MOVF   FEF,W
04A5A:  CLRF   x9C
04A5C:  CLRF   x9B
04A5E:  CLRF   x9A
04A60:  MOVWF  x99
04A62:  MOVFF  19B,03
04A66:  MOVFF  19A,02
04A6A:  MOVFF  199,01
04A6E:  CLRF   00
04A70:  MOVF   00,W
04A72:  IORWF  x94,F
04A74:  MOVF   01,W
04A76:  IORWF  x95,F
04A78:  MOVF   02,W
04A7A:  IORWF  x96,F
04A7C:  MOVF   03,W
04A7E:  IORWF  x97,F
04A80:  MOVLW  04
04A82:  ADDWF  x8D,W
04A84:  MOVWF  FE9
04A86:  MOVLW  00
04A88:  ADDWFC x8E,W
04A8A:  MOVWF  FEA
04A8C:  MOVF   FEF,W
04A8E:  MOVWF  00
04A90:  CLRF   01
04A92:  CLRF   02
04A94:  CLRF   03
04A96:  MOVF   00,W
04A98:  IORWF  x94,W
04A9A:  MOVWF  x90
04A9C:  MOVF   01,W
04A9E:  IORWF  x95,W
04AA0:  MOVWF  x91
04AA2:  MOVF   02,W
04AA4:  IORWF  x96,W
04AA6:  MOVWF  x92
04AA8:  MOVF   03,W
04AAA:  IORWF  x97,W
04AAC:  MOVWF  x93
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
04AAE:  MOVLW  AA
04AB0:  MOVWF  FF6
04AB2:  MOVLW  15
04AB4:  MOVWF  FF7
04AB6:  MOVLW  00
04AB8:  MOVWF  FF8
04ABA:  MOVLW  16
04ABC:  MOVLB  9
04ABE:  MOVWF  xC2
04AC0:  MOVLB  0
04AC2:  CALL   1BEE
04AC6:  MOVFF  193,264
04ACA:  MOVLW  37
04ACC:  MOVLB  2
04ACE:  MOVWF  x65
04AD0:  MOVLB  0
04AD2:  CALL   1E42
04AD6:  MOVFF  192,264
04ADA:  MOVLW  37
04ADC:  MOVLB  2
04ADE:  MOVWF  x65
04AE0:  MOVLB  0
04AE2:  CALL   1E42
04AE6:  MOVFF  191,264
04AEA:  MOVLW  37
04AEC:  MOVLB  2
04AEE:  MOVWF  x65
04AF0:  MOVLB  0
04AF2:  CALL   1E42
04AF6:  MOVFF  190,264
04AFA:  MOVLW  37
04AFC:  MOVLB  2
04AFE:  MOVWF  x65
04B00:  MOVLB  0
04B02:  CALL   1E42
04B06:  MOVLW  0D
04B08:  MOVLB  A
04B0A:  MOVWF  xAD
04B0C:  MOVLB  0
04B0E:  CALL   1B6C
04B12:  MOVLW  0A
04B14:  MOVLB  A
04B16:  MOVWF  xAD
04B18:  MOVLB  0
04B1A:  CALL   1B6C
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04B1E:  MOVFF  18F,1E0
04B22:  MOVLB  1
04B24:  CLRF   xE1
04B26:  MOVLB  0
04B28:  CALL   3862
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
04B2C:  MOVFF  111,2E5
04B30:  MOVFF  110,2E4
04B34:  MOVFF  10F,2E3
04B38:  MOVFF  10E,2E2
04B3C:  MOVLB  2
04B3E:  CLRF   xE9
04B40:  CLRF   xE8
04B42:  CLRF   xE7
04B44:  CLRF   xE6
04B46:  MOVLB  0
04B48:  CALL   4680
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04B4C:  MOVFF  18F,1E0
04B50:  MOVLB  1
04B52:  SETF   xE1
04B54:  MOVLB  0
04B56:  CALL   3862
....................    printf("End Flash Copy 1 Sector\r\n");
04B5A:  MOVLW  C8
04B5C:  MOVWF  FF6
04B5E:  MOVLW  15
04B60:  MOVWF  FF7
04B62:  MOVLW  00
04B64:  MOVWF  FF8
04B66:  CALL   1BBE
04B6A:  GOTO   9090 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
04B6E:  MOVLW  E2
04B70:  MOVWF  FF6
04B72:  MOVLW  15
04B74:  MOVWF  FF7
04B76:  MOVLW  00
04B78:  MOVWF  FF8
04B7A:  CALL   1BBE
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
04B7E:  MOVLB  1
04B80:  MOVF   x8D,W
04B82:  MOVWF  FE9
04B84:  MOVF   x8E,W
04B86:  MOVWF  FEA
04B88:  MOVFF  FEF,18F
04B8C:  MOVLW  01
04B8E:  ADDWF  x8D,W
04B90:  MOVWF  FE9
04B92:  MOVLW  00
04B94:  ADDWFC x8E,W
04B96:  MOVWF  FEA
04B98:  MOVF   FEF,W
04B9A:  CLRF   x97
04B9C:  CLRF   x96
04B9E:  CLRF   x95
04BA0:  MOVWF  x94
04BA2:  MOVFF  194,197
04BA6:  CLRF   x94
04BA8:  CLRF   x95
04BAA:  CLRF   x96
04BAC:  MOVLW  02
04BAE:  ADDWF  x8D,W
04BB0:  MOVWF  FE9
04BB2:  MOVLW  00
04BB4:  ADDWFC x8E,W
04BB6:  MOVWF  FEA
04BB8:  MOVF   FEF,W
04BBA:  CLRF   x9C
04BBC:  CLRF   x9B
04BBE:  CLRF   x9A
04BC0:  MOVWF  x99
04BC2:  MOVFF  19A,03
04BC6:  MOVFF  199,02
04BCA:  CLRF   00
04BCC:  CLRF   01
04BCE:  MOVF   00,W
04BD0:  IORWF  x94,F
04BD2:  MOVF   01,W
04BD4:  IORWF  x95,F
04BD6:  MOVF   02,W
04BD8:  IORWF  x96,F
04BDA:  MOVF   03,W
04BDC:  IORWF  x97,F
04BDE:  MOVLW  03
04BE0:  ADDWF  x8D,W
04BE2:  MOVWF  FE9
04BE4:  MOVLW  00
04BE6:  ADDWFC x8E,W
04BE8:  MOVWF  FEA
04BEA:  MOVF   FEF,W
04BEC:  CLRF   x9C
04BEE:  CLRF   x9B
04BF0:  CLRF   x9A
04BF2:  MOVWF  x99
04BF4:  MOVFF  19B,03
04BF8:  MOVFF  19A,02
04BFC:  MOVFF  199,01
04C00:  CLRF   00
04C02:  MOVF   00,W
04C04:  IORWF  x94,F
04C06:  MOVF   01,W
04C08:  IORWF  x95,F
04C0A:  MOVF   02,W
04C0C:  IORWF  x96,F
04C0E:  MOVF   03,W
04C10:  IORWF  x97,F
04C12:  MOVLW  04
04C14:  ADDWF  x8D,W
04C16:  MOVWF  FE9
04C18:  MOVLW  00
04C1A:  ADDWFC x8E,W
04C1C:  MOVWF  FEA
04C1E:  MOVF   FEF,W
04C20:  MOVWF  00
04C22:  CLRF   01
04C24:  CLRF   02
04C26:  CLRF   03
04C28:  MOVF   00,W
04C2A:  IORWF  x94,W
04C2C:  MOVWF  x90
04C2E:  MOVF   01,W
04C30:  IORWF  x95,W
04C32:  MOVWF  x91
04C34:  MOVF   02,W
04C36:  IORWF  x96,W
04C38:  MOVWF  x92
04C3A:  MOVF   03,W
04C3C:  IORWF  x97,W
04C3E:  MOVWF  x93
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
04C40:  MOVLW  08
04C42:  MOVWF  FF6
04C44:  MOVLW  16
04C46:  MOVWF  FF7
04C48:  MOVLW  00
04C4A:  MOVWF  FF8
04C4C:  MOVLW  16
04C4E:  MOVLB  9
04C50:  MOVWF  xC2
04C52:  MOVLB  0
04C54:  CALL   1BEE
04C58:  MOVFF  193,264
04C5C:  MOVLW  37
04C5E:  MOVLB  2
04C60:  MOVWF  x65
04C62:  MOVLB  0
04C64:  CALL   1E42
04C68:  MOVFF  192,264
04C6C:  MOVLW  37
04C6E:  MOVLB  2
04C70:  MOVWF  x65
04C72:  MOVLB  0
04C74:  CALL   1E42
04C78:  MOVFF  191,264
04C7C:  MOVLW  37
04C7E:  MOVLB  2
04C80:  MOVWF  x65
04C82:  MOVLB  0
04C84:  CALL   1E42
04C88:  MOVFF  190,264
04C8C:  MOVLW  37
04C8E:  MOVLB  2
04C90:  MOVWF  x65
04C92:  MOVLB  0
04C94:  CALL   1E42
04C98:  MOVLW  0D
04C9A:  MOVLB  A
04C9C:  MOVWF  xAD
04C9E:  MOVLB  0
04CA0:  CALL   1B6C
04CA4:  MOVLW  0A
04CA6:  MOVLB  A
04CA8:  MOVWF  xAD
04CAA:  MOVLB  0
04CAC:  CALL   1B6C
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04CB0:  MOVFF  18F,1E0
04CB4:  MOVLB  1
04CB6:  CLRF   xE1
04CB8:  MOVLB  0
04CBA:  CALL   3862
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04CBE:  MOVFF  18F,1E0
04CC2:  MOVLB  1
04CC4:  SETF   xE1
04CC6:  MOVLB  0
04CC8:  CALL   3862
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
04CCC:  MOVLW  26
04CCE:  MOVWF  FF6
04CD0:  MOVLW  16
04CD2:  MOVWF  FF7
04CD4:  MOVLW  00
04CD6:  MOVWF  FF8
04CD8:  CALL   1BBE
04CDC:  GOTO   90A0 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
04CE0:  MOVLW  4A
04CE2:  MOVWF  FF6
04CE4:  MOVLW  16
04CE6:  MOVWF  FF7
04CE8:  MOVLW  00
04CEA:  MOVWF  FF8
04CEC:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
04CF0:  MOVLB  1
04CF2:  MOVF   x8D,W
04CF4:  MOVWF  FE9
04CF6:  MOVF   x8E,W
04CF8:  MOVWF  FEA
04CFA:  MOVFF  FEF,1DF
04CFE:  MOVFF  1DF,1E0
04D02:  CLRF   xE1
04D04:  MOVLB  0
04D06:  CALL   3862
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
04D0A:  MOVLB  1
04D0C:  CLRF   x8F
04D0E:  CLRF   x90
04D10:  CLRF   x91
04D12:  CLRF   x92
04D14:  CLRF   x93
04D16:  CLRF   x94
04D18:  CLRF   x95
....................    
....................    flash_write_param.id = parameter[0];
04D1A:  MOVF   x8D,W
04D1C:  MOVWF  FE9
04D1E:  MOVF   x8E,W
04D20:  MOVWF  FEA
04D22:  MOVFF  FEF,18F
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
04D26:  MOVLW  01
04D28:  ADDWF  x8D,W
04D2A:  MOVWF  FE9
04D2C:  MOVLW  00
04D2E:  ADDWFC x8E,W
04D30:  MOVWF  FEA
04D32:  MOVF   FEF,W
04D34:  CLRF   xE2
04D36:  CLRF   xE1
04D38:  CLRF   xE0
04D3A:  MOVWF  xDF
04D3C:  MOVFF  1DF,1E2
04D40:  CLRF   xDF
04D42:  CLRF   xE0
04D44:  CLRF   xE1
04D46:  MOVLW  02
04D48:  ADDWF  x8D,W
04D4A:  MOVWF  FE9
04D4C:  MOVLW  00
04D4E:  ADDWFC x8E,W
04D50:  MOVWF  FEA
04D52:  MOVF   FEF,W
04D54:  CLRF   xE7
04D56:  CLRF   xE6
04D58:  CLRF   xE5
04D5A:  MOVWF  xE4
04D5C:  MOVFF  1E5,03
04D60:  MOVFF  1E4,02
04D64:  CLRF   00
04D66:  CLRF   01
04D68:  MOVF   00,W
04D6A:  IORWF  xDF,F
04D6C:  MOVF   01,W
04D6E:  IORWF  xE0,F
04D70:  MOVF   02,W
04D72:  IORWF  xE1,F
04D74:  MOVF   03,W
04D76:  IORWF  xE2,F
04D78:  MOVLW  03
04D7A:  ADDWF  x8D,W
04D7C:  MOVWF  FE9
04D7E:  MOVLW  00
04D80:  ADDWFC x8E,W
04D82:  MOVWF  FEA
04D84:  MOVF   FEF,W
04D86:  CLRF   xE7
04D88:  CLRF   xE6
04D8A:  CLRF   xE5
04D8C:  MOVWF  xE4
04D8E:  MOVFF  1E6,03
04D92:  MOVFF  1E5,02
04D96:  MOVFF  1E4,01
04D9A:  CLRF   00
04D9C:  MOVF   00,W
04D9E:  IORWF  xDF,F
04DA0:  MOVF   01,W
04DA2:  IORWF  xE0,F
04DA4:  MOVF   02,W
04DA6:  IORWF  xE1,F
04DA8:  MOVF   03,W
04DAA:  IORWF  xE2,F
04DAC:  MOVLW  04
04DAE:  ADDWF  x8D,W
04DB0:  MOVWF  FE9
04DB2:  MOVLW  00
04DB4:  ADDWFC x8E,W
04DB6:  MOVWF  FEA
04DB8:  MOVF   FEF,W
04DBA:  MOVWF  00
04DBC:  CLRF   01
04DBE:  CLRF   02
04DC0:  CLRF   03
04DC2:  MOVF   00,W
04DC4:  IORWF  xDF,W
04DC6:  MOVWF  x90
04DC8:  MOVF   01,W
04DCA:  IORWF  xE0,W
04DCC:  MOVWF  x91
04DCE:  MOVF   02,W
04DD0:  IORWF  xE1,W
04DD2:  MOVWF  x92
04DD4:  MOVF   03,W
04DD6:  IORWF  xE2,W
04DD8:  MOVWF  x93
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
04DDA:  MOVLW  07
04DDC:  ADDWF  x8D,W
04DDE:  MOVWF  FE9
04DE0:  MOVLW  00
04DE2:  ADDWFC x8E,W
04DE4:  MOVWF  FEA
04DE6:  MOVF   FEF,W
04DE8:  CLRF   xE0
04DEA:  MOVWF  xDF
04DEC:  MOVFF  1DF,1E0
04DF0:  CLRF   xDF
04DF2:  MOVLW  08
04DF4:  ADDWF  x8D,W
04DF6:  MOVWF  FE9
04DF8:  MOVLW  00
04DFA:  ADDWFC x8E,W
04DFC:  MOVWF  FEA
04DFE:  MOVF   FEF,W
04E00:  CLRF   03
04E02:  IORWF  xDF,W
04E04:  MOVWF  x94
04E06:  MOVF   03,W
04E08:  IORWF  xE0,W
04E0A:  MOVWF  x95
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
04E0C:  MOVLW  64
04E0E:  MOVWF  FF6
04E10:  MOVLW  16
04E12:  MOVWF  FF7
04E14:  MOVLW  00
04E16:  MOVWF  FF8
04E18:  MOVLW  0C
04E1A:  MOVLB  9
04E1C:  MOVWF  xC2
04E1E:  MOVLB  0
04E20:  CALL   1BEE
04E24:  MOVFF  18F,264
04E28:  MOVLW  37
04E2A:  MOVLB  2
04E2C:  MOVWF  x65
04E2E:  MOVLB  0
04E30:  CALL   1E42
04E34:  MOVLW  0D
04E36:  MOVLB  A
04E38:  MOVWF  xAD
04E3A:  MOVLB  0
04E3C:  CALL   1B6C
04E40:  MOVLW  0A
04E42:  MOVLB  A
04E44:  MOVWF  xAD
04E46:  MOVLB  0
04E48:  CALL   1B6C
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
04E4C:  MOVLW  78
04E4E:  MOVWF  FF6
04E50:  MOVLW  16
04E52:  MOVWF  FF7
04E54:  MOVLW  00
04E56:  MOVWF  FF8
04E58:  MOVLW  0E
04E5A:  MOVLB  9
04E5C:  MOVWF  xC2
04E5E:  MOVLB  0
04E60:  CALL   1BEE
04E64:  MOVFF  193,264
04E68:  MOVLW  37
04E6A:  MOVLB  2
04E6C:  MOVWF  x65
04E6E:  MOVLB  0
04E70:  CALL   1E42
04E74:  MOVFF  192,264
04E78:  MOVLW  37
04E7A:  MOVLB  2
04E7C:  MOVWF  x65
04E7E:  MOVLB  0
04E80:  CALL   1E42
04E84:  MOVFF  191,264
04E88:  MOVLW  37
04E8A:  MOVLB  2
04E8C:  MOVWF  x65
04E8E:  MOVLB  0
04E90:  CALL   1E42
04E94:  MOVFF  190,264
04E98:  MOVLW  37
04E9A:  MOVLB  2
04E9C:  MOVWF  x65
04E9E:  MOVLB  0
04EA0:  CALL   1E42
04EA4:  MOVLW  0D
04EA6:  MOVLB  A
04EA8:  MOVWF  xAD
04EAA:  MOVLB  0
04EAC:  CALL   1B6C
04EB0:  MOVLW  0A
04EB2:  MOVLB  A
04EB4:  MOVWF  xAD
04EB6:  MOVLB  0
04EB8:  CALL   1B6C
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
04EBC:  MOVLW  8E
04EBE:  MOVWF  FF6
04EC0:  MOVLW  16
04EC2:  MOVWF  FF7
04EC4:  MOVLW  00
04EC6:  MOVWF  FF8
04EC8:  MOVLW  0E
04ECA:  MOVLB  9
04ECC:  MOVWF  xC2
04ECE:  MOVLB  0
04ED0:  CALL   1BEE
04ED4:  MOVFF  195,264
04ED8:  MOVLW  37
04EDA:  MOVLB  2
04EDC:  MOVWF  x65
04EDE:  MOVLB  0
04EE0:  CALL   1E42
04EE4:  MOVFF  194,264
04EE8:  MOVLW  37
04EEA:  MOVLB  2
04EEC:  MOVWF  x65
04EEE:  MOVLB  0
04EF0:  CALL   1E42
04EF4:  MOVLW  0D
04EF6:  MOVLB  A
04EF8:  MOVWF  xAD
04EFA:  MOVLB  0
04EFC:  CALL   1B6C
04F00:  MOVLW  0A
04F02:  MOVLB  A
04F04:  MOVWF  xAD
04F06:  MOVLB  0
04F08:  CALL   1B6C
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
04F0C:  MOVFF  18F,1E0
04F10:  MOVLB  1
04F12:  CLRF   xE1
04F14:  MOVLB  0
04F16:  CALL   3862
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
04F1A:  MOVLW  A4
04F1C:  MOVWF  FF6
04F1E:  MOVLW  16
04F20:  MOVWF  FF7
04F22:  MOVLW  00
04F24:  MOVWF  FF8
04F26:  CALL   1BBE
....................    for (p = 0; p < flash_write_param.packetnum; p++)
04F2A:  MOVLB  1
04F2C:  CLRF   xD7
04F2E:  CLRF   xD6
04F30:  MOVLB  0
04F32:  MOVLB  1
04F34:  MOVF   xD7,W
04F36:  SUBWF  x95,W
04F38:  BTFSC  FD8.0
04F3A:  BRA    4F42
04F3C:  MOVLB  0
04F3E:  GOTO   5070
04F42:  MOVLB  0
04F44:  BTFSS  FD8.2
04F46:  GOTO   4F5C
04F4A:  MOVLB  1
04F4C:  MOVF   x94,W
04F4E:  SUBWF  xD6,W
04F50:  BTFSS  FD8.0
04F52:  BRA    4F5A
04F54:  MOVLB  0
04F56:  GOTO   5070
04F5A:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
04F5C:  MOVLB  1
04F5E:  RLCF   xD6,W
04F60:  MOVWF  xD8
04F62:  RLCF   xD7,W
04F64:  MOVWF  xD9
04F66:  RLCF   xD8,F
04F68:  RLCF   xD9,F
04F6A:  RLCF   xD8,F
04F6C:  RLCF   xD9,F
04F6E:  RLCF   xD8,F
04F70:  RLCF   xD9,F
04F72:  RLCF   xD8,F
04F74:  RLCF   xD9,F
04F76:  RLCF   xD8,F
04F78:  RLCF   xD9,F
04F7A:  MOVLW  C0
04F7C:  ANDWF  xD8,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
04F7E:  CLRF   xDA
04F80:  MOVLB  0
04F82:  MOVLB  1
04F84:  MOVF   xDA,W
04F86:  SUBLW  3F
04F88:  BTFSC  FD8.0
04F8A:  BRA    4F92
04F8C:  MOVLB  0
04F8E:  GOTO   4FF2
04F92:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
04F94:  CLRF   03
04F96:  MOVLB  1
04F98:  MOVF   xDA,W
04F9A:  ADDLW  96
04F9C:  MOVWF  FE9
04F9E:  MOVLW  01
04FA0:  ADDWFC 03,W
04FA2:  MOVWF  FEA
04FA4:  MOVF   xDA,W
04FA6:  ADDWF  xD8,W
04FA8:  MOVWF  xE1
04FAA:  MOVLW  00
04FAC:  ADDWFC xD9,W
04FAE:  MOVWF  xE2
04FB0:  MOVF   xE1,W
04FB2:  MOVWF  00
04FB4:  CLRF   03
04FB6:  MOVF   00,W
04FB8:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
04FBA:  CLRF   03
04FBC:  MOVF   xDA,W
04FBE:  ADDLW  96
04FC0:  MOVWF  FE9
04FC2:  MOVLW  01
04FC4:  ADDWFC 03,W
04FC6:  MOVWF  FEA
04FC8:  MOVFF  FEF,1DF
04FCC:  MOVFF  1DF,264
04FD0:  MOVLW  37
04FD2:  MOVLB  2
04FD4:  MOVWF  x65
04FD6:  MOVLB  0
04FD8:  CALL   1E42
04FDC:  MOVLW  20
04FDE:  MOVLB  A
04FE0:  MOVWF  xAD
04FE2:  MOVLB  0
04FE4:  CALL   1B6C
04FE8:  MOVLB  1
04FEA:  INCF   xDA,F
04FEC:  MOVLB  0
04FEE:  GOTO   4F82
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
04FF2:  MOVLB  1
04FF4:  RLCF   xD6,W
04FF6:  MOVWF  02
04FF8:  RLCF   xD7,W
04FFA:  MOVWF  03
04FFC:  RLCF   02,F
04FFE:  RLCF   03,F
05000:  RLCF   02,F
05002:  RLCF   03,F
05004:  RLCF   02,F
05006:  RLCF   03,F
05008:  RLCF   02,F
0500A:  RLCF   03,F
0500C:  RLCF   02,F
0500E:  RLCF   03,F
05010:  MOVLW  C0
05012:  ANDWF  02,F
05014:  MOVF   02,W
05016:  ADDWF  x90,W
05018:  MOVWF  xDB
0501A:  MOVF   03,W
0501C:  ADDWFC x91,W
0501E:  MOVWF  xDC
05020:  MOVLW  00
05022:  ADDWFC x92,W
05024:  MOVWF  xDD
05026:  MOVLW  00
05028:  ADDWFC x93,W
0502A:  MOVWF  xDE
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
0502C:  MOVFF  111,A59
05030:  MOVFF  110,A58
05034:  MOVFF  10F,A57
05038:  MOVFF  10E,A56
0503C:  MOVFF  1DE,A5D
05040:  MOVFF  1DD,A5C
05044:  MOVFF  1DC,A5B
05048:  MOVFF  1DB,A5A
0504C:  MOVLW  01
0504E:  MOVLB  A
05050:  MOVWF  x5F
05052:  MOVLW  96
05054:  MOVWF  x5E
05056:  CLRF   x61
05058:  MOVLW  40
0505A:  MOVWF  x60
0505C:  MOVLB  0
0505E:  CALL   34DE
05062:  MOVLB  1
05064:  INCF   xD6,F
05066:  BTFSC  FD8.2
05068:  INCF   xD7,F
0506A:  MOVLB  0
0506C:  GOTO   4F32
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
05070:  MOVFF  18F,1E0
05074:  MOVLB  1
05076:  SETF   xE1
05078:  MOVLB  0
0507A:  CALL   3862
....................    fprintf(PC, "\r\n");
0507E:  MOVLW  0D
05080:  MOVLB  A
05082:  MOVWF  xAD
05084:  MOVLB  0
05086:  CALL   1B6C
0508A:  MOVLW  0A
0508C:  MOVLB  A
0508E:  MOVWF  xAD
05090:  MOVLB  0
05092:  CALL   1B6C
....................    fprintf(PC, "End Flash Write Demo\r\n");
05096:  MOVLW  B2
05098:  MOVWF  FF6
0509A:  MOVLW  16
0509C:  MOVWF  FF7
0509E:  MOVLW  00
050A0:  MOVWF  FF8
050A2:  CALL   1BBE
050A6:  GOTO   90B0 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
050DA:  MOVLW  CA
050DC:  MOVWF  FF6
050DE:  MOVLW  16
050E0:  MOVWF  FF7
050E2:  MOVLW  00
050E4:  MOVWF  FF8
050E6:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
050EA:  MOVLB  1
050EC:  MOVF   x8D,W
050EE:  MOVWF  FE9
050F0:  MOVF   x8E,W
050F2:  MOVWF  FEA
050F4:  MOVFF  FEF,193
050F8:  MOVFF  193,1E0
050FC:  CLRF   xE1
050FE:  MOVLB  0
05100:  CALL   3862
....................    flash_setting(mis_fm);
05104:  MOVFF  111,29B
05108:  MOVFF  110,29A
0510C:  MOVFF  10F,299
05110:  MOVFF  10E,298
05114:  CALL   50AA
....................    unsigned int32 write_address = 0x00000000;
05118:  MOVLB  1
0511A:  CLRF   x92
0511C:  CLRF   x91
0511E:  CLRF   x90
05120:  CLRF   x8F
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05122:  MOVF   x8D,W
05124:  MOVWF  FE9
05126:  MOVF   x8E,W
05128:  MOVWF  FEA
0512A:  MOVFF  FEF,193
0512E:  MOVFF  193,1E0
05132:  SETF   xE1
05134:  MOVLB  0
05136:  CALL   3862
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
0513A:  MOVLW  F0
0513C:  MOVWF  FF6
0513E:  MOVLW  16
05140:  MOVWF  FF7
05142:  MOVLW  00
05144:  MOVWF  FF8
05146:  CALL   1BBE
0514A:  GOTO   90C0 (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
0514E:  MOVLW  14
05150:  MOVWF  FF6
05152:  MOVLW  17
05154:  MOVWF  FF7
05156:  MOVLW  00
05158:  MOVWF  FF8
0515A:  CALL   1BBE
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
0515E:  MOVLB  1
05160:  MOVF   x8D,W
05162:  MOVWF  FE9
05164:  MOVF   x8E,W
05166:  MOVWF  FEA
05168:  MOVFF  FEF,1DF
0516C:  MOVFF  1DF,1E0
05170:  CLRF   xE1
05172:  MOVLB  0
05174:  CALL   3862
....................    FLASH_PARAM flash_param = {0};
05178:  MOVLB  1
0517A:  CLRF   x8F
0517C:  CLRF   x90
0517E:  CLRF   x91
05180:  CLRF   x92
05182:  CLRF   x93
05184:  CLRF   x94
05186:  CLRF   x95
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
05188:  MOVF   x8D,W
0518A:  MOVWF  FE9
0518C:  MOVF   x8E,W
0518E:  MOVWF  FEA
05190:  MOVFF  FEF,18F
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
05194:  MOVLW  01
05196:  ADDWF  x8D,W
05198:  MOVWF  FE9
0519A:  MOVLW  00
0519C:  ADDWFC x8E,W
0519E:  MOVWF  FEA
051A0:  MOVF   FEF,W
051A2:  CLRF   xE2
051A4:  CLRF   xE1
051A6:  CLRF   xE0
051A8:  MOVWF  xDF
051AA:  MOVFF  1DF,1E2
051AE:  CLRF   xDF
051B0:  CLRF   xE0
051B2:  CLRF   xE1
051B4:  MOVLW  02
051B6:  ADDWF  x8D,W
051B8:  MOVWF  FE9
051BA:  MOVLW  00
051BC:  ADDWFC x8E,W
051BE:  MOVWF  FEA
051C0:  MOVF   FEF,W
051C2:  CLRF   xE7
051C4:  CLRF   xE6
051C6:  CLRF   xE5
051C8:  MOVWF  xE4
051CA:  MOVFF  1E5,03
051CE:  MOVFF  1E4,02
051D2:  CLRF   00
051D4:  CLRF   01
051D6:  MOVF   00,W
051D8:  IORWF  xDF,F
051DA:  MOVF   01,W
051DC:  IORWF  xE0,F
051DE:  MOVF   02,W
051E0:  IORWF  xE1,F
051E2:  MOVF   03,W
051E4:  IORWF  xE2,F
051E6:  MOVLW  03
051E8:  ADDWF  x8D,W
051EA:  MOVWF  FE9
051EC:  MOVLW  00
051EE:  ADDWFC x8E,W
051F0:  MOVWF  FEA
051F2:  MOVF   FEF,W
051F4:  CLRF   xE7
051F6:  CLRF   xE6
051F8:  CLRF   xE5
051FA:  MOVWF  xE4
051FC:  MOVFF  1E6,03
05200:  MOVFF  1E5,02
05204:  MOVFF  1E4,01
05208:  CLRF   00
0520A:  MOVF   00,W
0520C:  IORWF  xDF,F
0520E:  MOVF   01,W
05210:  IORWF  xE0,F
05212:  MOVF   02,W
05214:  IORWF  xE1,F
05216:  MOVF   03,W
05218:  IORWF  xE2,F
0521A:  MOVLW  04
0521C:  ADDWF  x8D,W
0521E:  MOVWF  FE9
05220:  MOVLW  00
05222:  ADDWFC x8E,W
05224:  MOVWF  FEA
05226:  MOVF   FEF,W
05228:  MOVWF  00
0522A:  CLRF   01
0522C:  CLRF   02
0522E:  CLRF   03
05230:  MOVF   00,W
05232:  IORWF  xDF,W
05234:  MOVWF  x92
05236:  MOVF   01,W
05238:  IORWF  xE0,W
0523A:  MOVWF  x93
0523C:  MOVF   02,W
0523E:  IORWF  xE1,W
05240:  MOVWF  x94
05242:  MOVF   03,W
05244:  IORWF  xE2,W
05246:  MOVWF  x95
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
05248:  MOVLW  07
0524A:  ADDWF  x8D,W
0524C:  MOVWF  FE9
0524E:  MOVLW  00
05250:  ADDWFC x8E,W
05252:  MOVWF  FEA
05254:  MOVF   FEF,W
05256:  CLRF   xE0
05258:  MOVWF  xDF
0525A:  MOVFF  1DF,1E0
0525E:  CLRF   xDF
05260:  MOVLW  08
05262:  ADDWF  x8D,W
05264:  MOVWF  FE9
05266:  MOVLW  00
05268:  ADDWFC x8E,W
0526A:  MOVWF  FEA
0526C:  MOVF   FEF,W
0526E:  CLRF   03
05270:  IORWF  xDF,W
05272:  MOVWF  x90
05274:  MOVF   03,W
05276:  IORWF  xE0,W
05278:  MOVWF  x91
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
0527A:  MOVLW  28
0527C:  MOVWF  FF6
0527E:  MOVLW  17
05280:  MOVWF  FF7
05282:  MOVLW  00
05284:  MOVWF  FF8
05286:  MOVLW  0C
05288:  MOVLB  9
0528A:  MOVWF  xC2
0528C:  MOVLB  0
0528E:  CALL   1BEE
05292:  MOVFF  18F,264
05296:  MOVLW  37
05298:  MOVLB  2
0529A:  MOVWF  x65
0529C:  MOVLB  0
0529E:  CALL   1E42
052A2:  MOVLW  0D
052A4:  MOVLB  A
052A6:  MOVWF  xAD
052A8:  MOVLB  0
052AA:  CALL   1B6C
052AE:  MOVLW  0A
052B0:  MOVLB  A
052B2:  MOVWF  xAD
052B4:  MOVLB  0
052B6:  CALL   1B6C
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
052BA:  MOVLW  3C
052BC:  MOVWF  FF6
052BE:  MOVLW  17
052C0:  MOVWF  FF7
052C2:  MOVLW  00
052C4:  MOVWF  FF8
052C6:  MOVLW  0E
052C8:  MOVLB  9
052CA:  MOVWF  xC2
052CC:  MOVLB  0
052CE:  CALL   1BEE
052D2:  MOVFF  195,264
052D6:  MOVLW  37
052D8:  MOVLB  2
052DA:  MOVWF  x65
052DC:  MOVLB  0
052DE:  CALL   1E42
052E2:  MOVFF  194,264
052E6:  MOVLW  37
052E8:  MOVLB  2
052EA:  MOVWF  x65
052EC:  MOVLB  0
052EE:  CALL   1E42
052F2:  MOVFF  193,264
052F6:  MOVLW  37
052F8:  MOVLB  2
052FA:  MOVWF  x65
052FC:  MOVLB  0
052FE:  CALL   1E42
05302:  MOVFF  192,264
05306:  MOVLW  37
05308:  MOVLB  2
0530A:  MOVWF  x65
0530C:  MOVLB  0
0530E:  CALL   1E42
05312:  MOVLW  0D
05314:  MOVLB  A
05316:  MOVWF  xAD
05318:  MOVLB  0
0531A:  CALL   1B6C
0531E:  MOVLW  0A
05320:  MOVLB  A
05322:  MOVWF  xAD
05324:  MOVLB  0
05326:  CALL   1B6C
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
0532A:  MOVLW  52
0532C:  MOVWF  FF6
0532E:  MOVLW  17
05330:  MOVWF  FF7
05332:  MOVLW  00
05334:  MOVWF  FF8
05336:  MOVLW  0E
05338:  MOVLB  9
0533A:  MOVWF  xC2
0533C:  MOVLB  0
0533E:  CALL   1BEE
05342:  MOVFF  191,264
05346:  MOVLW  37
05348:  MOVLB  2
0534A:  MOVWF  x65
0534C:  MOVLB  0
0534E:  CALL   1E42
05352:  MOVFF  190,264
05356:  MOVLW  37
05358:  MOVLB  2
0535A:  MOVWF  x65
0535C:  MOVLB  0
0535E:  CALL   1E42
05362:  MOVLW  0D
05364:  MOVLB  A
05366:  MOVWF  xAD
05368:  MOVLB  0
0536A:  CALL   1B6C
0536E:  MOVLW  0A
05370:  MOVLB  A
05372:  MOVWF  xAD
05374:  MOVLB  0
05376:  CALL   1B6C
....................    
....................    piclog_make(flash_param.id, 0x00);
0537A:  MOVFF  18F,1E0
0537E:  MOVLB  1
05380:  CLRF   xE1
05382:  MOVLB  0
05384:  CALL   3862
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
05388:  MOVLB  1
0538A:  CLRF   x96
0538C:  CLRF   x97
0538E:  CLRF   x98
05390:  CLRF   x99
05392:  CLRF   x9A
05394:  CLRF   x9B
05396:  CLRF   x9C
05398:  CLRF   x9D
0539A:  CLRF   x9E
0539C:  CLRF   x9F
0539E:  CLRF   xA0
053A0:  CLRF   xA1
053A2:  CLRF   xA2
053A4:  CLRF   xA3
053A6:  CLRF   xA4
053A8:  CLRF   xA5
053AA:  CLRF   xA6
053AC:  CLRF   xA7
053AE:  CLRF   xA8
053B0:  CLRF   xA9
053B2:  CLRF   xAA
053B4:  CLRF   xAB
053B6:  CLRF   xAC
053B8:  CLRF   xAD
053BA:  CLRF   xAE
053BC:  CLRF   xAF
053BE:  CLRF   xB0
053C0:  CLRF   xB1
053C2:  CLRF   xB2
053C4:  CLRF   xB3
053C6:  CLRF   xB4
053C8:  CLRF   xB5
053CA:  CLRF   xB6
053CC:  CLRF   xB7
053CE:  CLRF   xB8
053D0:  CLRF   xB9
053D2:  CLRF   xBA
053D4:  CLRF   xBB
053D6:  CLRF   xBC
053D8:  CLRF   xBD
053DA:  CLRF   xBE
053DC:  CLRF   xBF
053DE:  CLRF   xC0
053E0:  CLRF   xC1
053E2:  CLRF   xC2
053E4:  CLRF   xC3
053E6:  CLRF   xC4
053E8:  CLRF   xC5
053EA:  CLRF   xC6
053EC:  CLRF   xC7
053EE:  CLRF   xC8
053F0:  CLRF   xC9
053F2:  CLRF   xCA
053F4:  CLRF   xCB
053F6:  CLRF   xCC
053F8:  CLRF   xCD
053FA:  CLRF   xCE
053FC:  CLRF   xCF
053FE:  CLRF   xD0
05400:  CLRF   xD1
05402:  CLRF   xD2
05404:  CLRF   xD3
05406:  CLRF   xD4
05408:  CLRF   xD5
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
0540A:  MOVLW  68
0540C:  MOVWF  FF6
0540E:  MOVLW  17
05410:  MOVWF  FF7
05412:  MOVLW  00
05414:  MOVWF  FF8
05416:  MOVLB  0
05418:  CALL   1BBE
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
0541C:  MOVFF  111,263
05420:  MOVFF  110,262
05424:  MOVFF  10F,261
05428:  MOVFF  10E,260
0542C:  CALL   26D8
05430:  MOVF   01,F
05432:  BTFSS  FD8.2
05434:  GOTO   5448
....................       fprintf(PC, "Mission Flash is not connected\r\n");
05438:  MOVLW  74
0543A:  MOVWF  FF6
0543C:  MOVLW  17
0543E:  MOVWF  FF7
05440:  MOVLW  00
05442:  MOVWF  FF8
05444:  CALL   1BBE
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
05448:  MOVLB  1
0544A:  CLRF   xDD
0544C:  CLRF   xDC
0544E:  CLRF   xDB
05450:  CLRF   xDA
05452:  MOVLB  0
05454:  MOVLB  1
05456:  MOVF   xDD,F
05458:  BTFSC  FD8.2
0545A:  BRA    5462
0545C:  MOVLB  0
0545E:  GOTO   55B0
05462:  MOVLB  0
05464:  MOVLB  1
05466:  MOVF   xDC,F
05468:  BTFSC  FD8.2
0546A:  BRA    5472
0546C:  MOVLB  0
0546E:  GOTO   55B0
05472:  MOVLB  0
05474:  MOVLB  1
05476:  MOVF   xDB,W
05478:  SUBWF  x91,W
0547A:  BTFSC  FD8.0
0547C:  BRA    5484
0547E:  MOVLB  0
05480:  GOTO   55B0
05484:  MOVLB  0
05486:  BTFSS  FD8.2
05488:  GOTO   549E
0548C:  MOVLB  1
0548E:  MOVF   x90,W
05490:  SUBWF  xDA,W
05492:  BTFSS  FD8.0
05494:  BRA    549C
05496:  MOVLB  0
05498:  GOTO   55B0
0549C:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
0549E:  MOVLB  1
054A0:  RLCF   xDA,W
054A2:  MOVWF  00
054A4:  RLCF   xDB,W
054A6:  MOVWF  01
054A8:  RLCF   xDC,W
054AA:  MOVWF  02
054AC:  RLCF   xDD,W
054AE:  MOVWF  03
054B0:  RLCF   00,F
054B2:  RLCF   01,F
054B4:  RLCF   02,F
054B6:  RLCF   03,F
054B8:  RLCF   00,F
054BA:  RLCF   01,F
054BC:  RLCF   02,F
054BE:  RLCF   03,F
054C0:  RLCF   00,F
054C2:  RLCF   01,F
054C4:  RLCF   02,F
054C6:  RLCF   03,F
054C8:  RLCF   00,F
054CA:  RLCF   01,F
054CC:  RLCF   02,F
054CE:  RLCF   03,F
054D0:  RLCF   00,F
054D2:  RLCF   01,F
054D4:  RLCF   02,F
054D6:  RLCF   03,F
054D8:  MOVLW  C0
054DA:  ANDWF  00,F
054DC:  MOVF   00,W
054DE:  ADDWF  x92,W
054E0:  MOVWF  xD6
054E2:  MOVF   01,W
054E4:  ADDWFC x93,W
054E6:  MOVWF  xD7
054E8:  MOVF   02,W
054EA:  ADDWFC x94,W
054EC:  MOVWF  xD8
054EE:  MOVF   03,W
054F0:  ADDWFC x95,W
054F2:  MOVWF  xD9
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
054F4:  MOVFF  111,2E5
054F8:  MOVFF  110,2E4
054FC:  MOVFF  10F,2E3
05500:  MOVFF  10E,2E2
05504:  MOVFF  1D9,2E9
05508:  MOVFF  1D8,2E8
0550C:  MOVFF  1D7,2E7
05510:  MOVFF  1D6,2E6
05514:  MOVLW  01
05516:  MOVLB  2
05518:  MOVWF  xEB
0551A:  MOVLW  96
0551C:  MOVWF  xEA
0551E:  CLRF   xEF
05520:  CLRF   xEE
05522:  CLRF   xED
05524:  MOVLW  40
05526:  MOVWF  xEC
05528:  MOVLB  0
0552A:  CALL   27C4
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
0552E:  MOVLB  1
05530:  CLRF   xDE
05532:  MOVLB  0
05534:  MOVLB  1
05536:  MOVF   xDE,W
05538:  SUBLW  3F
0553A:  BTFSC  FD8.0
0553C:  BRA    5544
0553E:  MOVLB  0
05540:  GOTO   5580
05544:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
05546:  CLRF   03
05548:  MOVLB  1
0554A:  MOVF   xDE,W
0554C:  ADDLW  96
0554E:  MOVWF  FE9
05550:  MOVLW  01
05552:  ADDWFC 03,W
05554:  MOVWF  FEA
05556:  MOVFF  FEF,1DF
0555A:  MOVFF  1DF,264
0555E:  MOVLW  37
05560:  MOVLB  2
05562:  MOVWF  x65
05564:  MOVLB  0
05566:  CALL   1E42
0556A:  MOVLW  20
0556C:  MOVLB  A
0556E:  MOVWF  xAD
05570:  MOVLB  0
05572:  CALL   1B6C
05576:  MOVLB  1
05578:  INCF   xDE,F
0557A:  MOVLB  0
0557C:  GOTO   5534
....................       }
....................       fprintf(PC,"\r\n");
05580:  MOVLW  0D
05582:  MOVLB  A
05584:  MOVWF  xAD
05586:  MOVLB  0
05588:  CALL   1B6C
0558C:  MOVLW  0A
0558E:  MOVLB  A
05590:  MOVWF  xAD
05592:  MOVLB  0
05594:  CALL   1B6C
05598:  MOVLW  01
0559A:  MOVLB  1
0559C:  ADDWF  xDA,F
0559E:  BTFSC  FD8.0
055A0:  INCF   xDB,F
055A2:  BTFSC  FD8.2
055A4:  INCF   xDC,F
055A6:  BTFSC  FD8.2
055A8:  INCF   xDD,F
055AA:  MOVLB  0
055AC:  GOTO   5454
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
055B0:  MOVFF  18F,1E0
055B4:  MOVLB  1
055B6:  SETF   xE1
055B8:  MOVLB  0
055BA:  CALL   3862
....................    fprintf(PC, "End Flash Read\r\n");
055BE:  MOVLW  96
055C0:  MOVWF  FF6
055C2:  MOVLW  17
055C4:  MOVWF  FF7
055C6:  MOVLW  00
055C8:  MOVWF  FF8
055CA:  CALL   1BBE
055CE:  GOTO   90D0 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
055D2:  MOVLW  A8
055D4:  MOVWF  FF6
055D6:  MOVLW  17
055D8:  MOVWF  FF7
055DA:  MOVLW  00
055DC:  MOVWF  FF8
055DE:  CALL   1BBE
....................    flash_setting(mis_fm);
055E2:  MOVFF  111,29B
055E6:  MOVFF  110,29A
055EA:  MOVFF  10F,299
055EE:  MOVFF  10E,298
055F2:  CALL   50AA
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
055F6:  MOVLB  1
055F8:  CLRF   x92
055FA:  CLRF   x91
055FC:  CLRF   x90
055FE:  CLRF   x8F
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
05600:  MOVFF  111,2E5
05604:  MOVFF  110,2E4
05608:  MOVFF  10F,2E3
0560C:  MOVFF  10E,2E2
05610:  MOVFF  192,2E9
05614:  MOVFF  191,2E8
05618:  MOVFF  190,2E7
0561C:  MOVFF  18F,2E6
05620:  MOVLW  01
05622:  MOVLB  2
05624:  MOVWF  xEB
05626:  MOVLW  93
05628:  MOVWF  xEA
0562A:  CLRF   xEF
0562C:  CLRF   xEE
0562E:  CLRF   xED
05630:  MOVLW  04
05632:  MOVWF  xEC
05634:  MOVLB  0
05636:  CALL   27C4
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
0563A:  MOVLW  C4
0563C:  MOVWF  FF6
0563E:  MOVLW  17
05640:  MOVWF  FF7
05642:  MOVLW  00
05644:  MOVWF  FF8
05646:  MOVLW  0B
05648:  MOVLB  9
0564A:  MOVWF  xC2
0564C:  MOVLB  0
0564E:  CALL   1BEE
05652:  MOVFF  193,264
05656:  MOVLW  37
05658:  MOVLB  2
0565A:  MOVWF  x65
0565C:  MOVLB  0
0565E:  CALL   1E42
05662:  MOVLW  20
05664:  MOVLB  A
05666:  MOVWF  xAD
05668:  MOVLB  0
0566A:  CALL   1B6C
0566E:  MOVFF  194,264
05672:  MOVLW  37
05674:  MOVLB  2
05676:  MOVWF  x65
05678:  MOVLB  0
0567A:  CALL   1E42
0567E:  MOVLW  20
05680:  MOVLB  A
05682:  MOVWF  xAD
05684:  MOVLB  0
05686:  CALL   1B6C
0568A:  MOVFF  195,264
0568E:  MOVLW  37
05690:  MOVLB  2
05692:  MOVWF  x65
05694:  MOVLB  0
05696:  CALL   1E42
0569A:  MOVLW  20
0569C:  MOVLB  A
0569E:  MOVWF  xAD
056A0:  MOVLB  0
056A2:  CALL   1B6C
056A6:  MOVFF  196,264
056AA:  MOVLW  37
056AC:  MOVLB  2
056AE:  MOVWF  x65
056B0:  MOVLB  0
056B2:  CALL   1E42
056B6:  MOVLW  0D
056B8:  MOVLB  A
056BA:  MOVWF  xAD
056BC:  MOVLB  0
056BE:  CALL   1B6C
056C2:  MOVLW  0A
056C4:  MOVLB  A
056C6:  MOVWF  xAD
056C8:  MOVLB  0
056CA:  CALL   1B6C
....................    fprintf(PC, "End Flash Read Address\r\n");
056CE:  MOVLW  E6
056D0:  MOVWF  FF6
056D2:  MOVLW  17
056D4:  MOVWF  FF7
056D6:  MOVLW  00
056D8:  MOVWF  FF8
056DA:  CALL   1BBE
056DE:  GOTO   90E0 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
058CA:  MOVLW  00
058CC:  MOVWF  FF6
058CE:  MOVLW  18
058D0:  MOVWF  FF7
058D2:  MOVLW  00
058D4:  MOVWF  FF8
058D6:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
058DA:  MOVLB  1
058DC:  MOVF   x8D,W
058DE:  MOVWF  FE9
058E0:  MOVF   x8E,W
058E2:  MOVWF  FEA
058E4:  MOVFF  FEF,18F
058E8:  MOVFF  18F,1E0
058EC:  CLRF   xE1
058EE:  MOVLB  0
058F0:  CALL   3862
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
058F4:  MOVFF  18E,190
058F8:  MOVFF  18D,18F
058FC:  CALL   440E
....................    mode_misf_address_reset(parameter); // Reset the address area
05900:  MOVFF  18E,190
05904:  MOVFF  18D,18F
05908:  GOTO   56E2
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
0590C:  MOVLW  1E
0590E:  MOVWF  FF6
05910:  MOVLW  18
05912:  MOVWF  FF7
05914:  MOVLW  00
05916:  MOVWF  FF8
05918:  CALL   1BBE
0591C:  GOTO   90F0 (RETURN)
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
05920:  MOVLW  3A
05922:  MOVWF  FF6
05924:  MOVLW  18
05926:  MOVWF  FF7
05928:  MOVLW  00
0592A:  MOVWF  FF8
0592C:  CALL   1BBE
....................    flash_setting(mis_fm);
05930:  MOVFF  111,29B
05934:  MOVFF  110,29A
05938:  MOVFF  10F,299
0593C:  MOVFF  10E,298
05940:  CALL   50AA
....................    flash_setting(smf);
05944:  MOVFF  115,29B
05948:  MOVFF  114,29A
0594C:  MOVFF  113,299
05950:  MOVFF  112,298
05954:  CALL   50AA
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
05958:  MOVLB  1
0595A:  MOVF   x8D,W
0595C:  MOVWF  FE9
0595E:  MOVF   x8E,W
05960:  MOVWF  FEA
05962:  MOVFF  FEF,18F
05966:  CLRF   x93
05968:  CLRF   x92
0596A:  CLRF   x91
0596C:  CLRF   x90
0596E:  CLRF   x97
05970:  CLRF   x96
05972:  MOVLW  10
05974:  MOVWF  x95
05976:  CLRF   x94
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
05978:  MOVFF  111,2E5
0597C:  MOVFF  110,2E4
05980:  MOVFF  10F,2E3
05984:  MOVFF  10E,2E2
05988:  MOVFF  193,2E9
0598C:  MOVFF  192,2E8
05990:  MOVFF  191,2E7
05994:  MOVFF  190,2E6
05998:  MOVLW  01
0599A:  MOVLB  2
0599C:  MOVWF  xEB
0599E:  MOVLW  98
059A0:  MOVWF  xEA
059A2:  CLRF   xEF
059A4:  CLRF   xEE
059A6:  MOVLW  01
059A8:  MOVWF  xED
059AA:  CLRF   xEC
059AC:  MOVLB  0
059AE:  CALL   27C4
....................    write_data_bytes(smf, dest_address, read_data, 256);
059B2:  MOVFF  115,A59
059B6:  MOVFF  114,A58
059BA:  MOVFF  113,A57
059BE:  MOVFF  112,A56
059C2:  MOVFF  197,A5D
059C6:  MOVFF  196,A5C
059CA:  MOVFF  195,A5B
059CE:  MOVFF  194,A5A
059D2:  MOVLW  01
059D4:  MOVLB  A
059D6:  MOVWF  x5F
059D8:  MOVLW  98
059DA:  MOVWF  x5E
059DC:  MOVLW  01
059DE:  MOVWF  x61
059E0:  CLRF   x60
059E2:  MOVLB  0
059E4:  CALL   34DE
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
059E8:  MOVLW  52
059EA:  MOVWF  FF6
059EC:  MOVLW  18
059EE:  MOVWF  FF7
059F0:  MOVLW  00
059F2:  MOVWF  FF8
059F4:  CALL   1BBE
059F8:  GOTO   9100 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
059FC:  MOVLW  68
059FE:  MOVWF  FF6
05A00:  MOVLW  18
05A02:  MOVWF  FF7
05A04:  MOVLW  00
05A06:  MOVWF  FF8
05A08:  CALL   1BBE
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
05A0C:  MOVFF  115,2E5
05A10:  MOVFF  114,2E4
05A14:  MOVFF  113,2E3
05A18:  MOVFF  112,2E2
05A1C:  MOVLB  2
05A1E:  CLRF   xE9
05A20:  CLRF   xE8
05A22:  MOVLW  01
05A24:  MOVWF  xE7
05A26:  MOVLW  8F
05A28:  MOVWF  xE6
05A2A:  MOVLW  01
05A2C:  MOVWF  xEB
05A2E:  MOVLW  8F
05A30:  MOVWF  xEA
05A32:  CLRF   xEF
05A34:  CLRF   xEE
05A36:  CLRF   xED
05A38:  MOVLW  40
05A3A:  MOVWF  xEC
05A3C:  MOVLB  0
05A3E:  CALL   27C4
....................    fprintf(PC, "Read Data: ");
05A42:  MOVLW  80
05A44:  MOVWF  FF6
05A46:  MOVLW  18
05A48:  MOVWF  FF7
05A4A:  MOVLW  00
05A4C:  MOVWF  FF8
05A4E:  CALL   1BBE
....................    for (int i = 0; i < PACKET_SIZE; i++)
05A52:  MOVLB  1
05A54:  CLRF   xCF
05A56:  MOVLB  0
05A58:  MOVLB  1
05A5A:  MOVF   xCF,W
05A5C:  SUBLW  3F
05A5E:  BTFSC  FD8.0
05A60:  BRA    5A68
05A62:  MOVLB  0
05A64:  GOTO   5AA4
05A68:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
05A6A:  CLRF   03
05A6C:  MOVLB  1
05A6E:  MOVF   xCF,W
05A70:  ADDLW  8F
05A72:  MOVWF  FE9
05A74:  MOVLW  01
05A76:  ADDWFC 03,W
05A78:  MOVWF  FEA
05A7A:  MOVFF  FEF,1D0
05A7E:  MOVFF  1D0,264
05A82:  MOVLW  37
05A84:  MOVLB  2
05A86:  MOVWF  x65
05A88:  MOVLB  0
05A8A:  CALL   1E42
05A8E:  MOVLW  20
05A90:  MOVLB  A
05A92:  MOVWF  xAD
05A94:  MOVLB  0
05A96:  CALL   1B6C
05A9A:  MOVLB  1
05A9C:  INCF   xCF,F
05A9E:  MOVLB  0
05AA0:  GOTO   5A58
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
05AA4:  MOVLW  8C
05AA6:  MOVWF  FF6
05AA8:  MOVLW  18
05AAA:  MOVWF  FF7
05AAC:  MOVLW  00
05AAE:  MOVWF  FF8
05AB0:  CALL   1BBE
05AB4:  GOTO   9110 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
05AB8:  MOVLW  A4
05ABA:  MOVWF  FF6
05ABC:  MOVLW  18
05ABE:  MOVWF  FF7
05AC0:  MOVLW  00
05AC2:  MOVWF  FF8
05AC4:  CALL   1BBE
....................    flash_setting(smf);
05AC8:  MOVFF  115,29B
05ACC:  MOVFF  114,29A
05AD0:  MOVFF  113,299
05AD4:  MOVFF  112,298
05AD8:  CALL   50AA
....................    unsigned int32 erase_address = 0x00000000; // Example address
05ADC:  MOVLB  1
05ADE:  CLRF   x92
05AE0:  CLRF   x91
05AE2:  CLRF   x90
05AE4:  CLRF   x8F
....................    sector_erase(smf, erase_address); // Erase the sector
05AE6:  MOVFF  115,A59
05AEA:  MOVFF  114,A58
05AEE:  MOVFF  113,A57
05AF2:  MOVFF  112,A56
05AF6:  MOVFF  192,A5D
05AFA:  MOVFF  191,A5C
05AFE:  MOVFF  190,A5B
05B02:  MOVFF  18F,A5A
05B06:  MOVLB  0
05B08:  CALL   40B6
....................    fprintf(PC, "End Flash SMF Erase\r\n");
05B0C:  MOVLW  BC
05B0E:  MOVWF  FF6
05B10:  MOVLW  18
05B12:  MOVWF  FF7
05B14:  MOVLW  00
05B16:  MOVWF  FF8
05B18:  CALL   1BBE
05B1C:  GOTO   9120 (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
056E2:  MOVLW  D2
056E4:  MOVWF  FF6
056E6:  MOVLW  18
056E8:  MOVWF  FF7
056EA:  MOVLW  00
056EC:  MOVWF  FF8
056EE:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); 
056F2:  MOVLB  1
056F4:  MOVF   x8F,W
056F6:  MOVWF  FE9
056F8:  MOVF   x90,W
056FA:  MOVWF  FEA
056FC:  MOVFF  FEF,1D3
05700:  MOVFF  1D3,1E0
05704:  CLRF   xE1
05706:  MOVLB  0
05708:  CALL   3862
....................    FlashData_t flash_data;
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
0570C:  MOVLW  01
0570E:  MOVWF  FEA
05710:  MOVLW  91
05712:  MOVWF  FE9
05714:  CLRF   00
05716:  CLRF   02
05718:  MOVLW  40
0571A:  MOVWF  01
0571C:  CALL   27A0
....................    /*
....................    for (int i = 0; i < PACKET_SIZE; i++) {
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
....................    }
....................    */
....................    fprintf(PC, "\r\n");
05720:  MOVLW  0D
05722:  MOVLB  A
05724:  MOVWF  xAD
05726:  MOVLB  0
05728:  CALL   1B6C
0572C:  MOVLW  0A
0572E:  MOVLB  A
05730:  MOVWF  xAD
05732:  MOVLB  0
05734:  CALL   1B6C
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
05738:  MOVLW  01
0573A:  MOVLB  A
0573C:  MOVWF  xAE
0573E:  MOVLW  91
05740:  MOVWF  xAD
05742:  MOVLW  3F
05744:  MOVWF  xAF
05746:  MOVLB  0
05748:  CALL   29DC
0574C:  MOVFF  01,1D0
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05750:  MOVLB  1
05752:  CLRF   xD1
05754:  MOVLB  0
05756:  MOVLB  1
05758:  MOVF   xD1,W
0575A:  SUBLW  3F
0575C:  BTFSC  FD8.0
0575E:  BRA    5766
05760:  MOVLB  0
05762:  GOTO   57A2
05766:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
05768:  CLRF   03
0576A:  MOVLB  1
0576C:  MOVF   xD1,W
0576E:  ADDLW  91
05770:  MOVWF  FE9
05772:  MOVLW  01
05774:  ADDWFC 03,W
05776:  MOVWF  FEA
05778:  MOVFF  FEF,1D3
0577C:  MOVFF  1D3,264
05780:  MOVLW  37
05782:  MOVLB  2
05784:  MOVWF  x65
05786:  MOVLB  0
05788:  CALL   1E42
0578C:  MOVLW  20
0578E:  MOVLB  A
05790:  MOVWF  xAD
05792:  MOVLB  0
05794:  CALL   1B6C
05798:  MOVLB  1
0579A:  INCF   xD1,F
0579C:  MOVLB  0
0579E:  GOTO   5756
....................    }
....................    fprintf(PC, "\r\n");
057A2:  MOVLW  0D
057A4:  MOVLB  A
057A6:  MOVWF  xAD
057A8:  MOVLB  0
057AA:  CALL   1B6C
057AE:  MOVLW  0A
057B0:  MOVLB  A
057B2:  MOVWF  xAD
057B4:  MOVLB  0
057B6:  CALL   1B6C
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
057BA:  MOVFF  111,A59
057BE:  MOVFF  110,A58
057C2:  MOVFF  10F,A57
057C6:  MOVFF  10E,A56
057CA:  MOVLB  A
057CC:  CLRF   x5D
057CE:  CLRF   x5C
057D0:  CLRF   x5B
057D2:  CLRF   x5A
057D4:  MOVLW  01
057D6:  MOVWF  x5F
057D8:  MOVLW  91
057DA:  MOVWF  x5E
057DC:  CLRF   x61
057DE:  MOVLW  40
057E0:  MOVWF  x60
057E2:  MOVLB  0
057E4:  CALL   34DE
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
057E8:  MOVLW  01
057EA:  MOVWF  FEA
057EC:  MOVLW  91
057EE:  MOVWF  FE9
057F0:  CLRF   00
057F2:  CLRF   02
057F4:  MOVLW  40
057F6:  MOVWF  01
057F8:  CALL   27A0
....................    read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
057FC:  MOVFF  111,2E5
05800:  MOVFF  110,2E4
05804:  MOVFF  10F,2E3
05808:  MOVFF  10E,2E2
0580C:  MOVLB  2
0580E:  CLRF   xE9
05810:  CLRF   xE8
05812:  CLRF   xE7
05814:  CLRF   xE6
05816:  MOVLW  01
05818:  MOVWF  xEB
0581A:  MOVLW  91
0581C:  MOVWF  xEA
0581E:  CLRF   xEF
05820:  CLRF   xEE
05822:  CLRF   xED
05824:  MOVLW  40
05826:  MOVWF  xEC
05828:  MOVLB  0
0582A:  CALL   27C4
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
0582E:  MOVLW  01
05830:  MOVLB  A
05832:  MOVWF  xAE
05834:  MOVLW  91
05836:  MOVWF  xAD
05838:  MOVLW  3F
0583A:  MOVWF  xAF
0583C:  MOVLB  0
0583E:  CALL   29DC
05842:  MOVFF  01,1D0
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05846:  MOVLB  1
05848:  CLRF   xD2
0584A:  MOVLB  0
0584C:  MOVLB  1
0584E:  MOVF   xD2,W
05850:  SUBLW  3F
05852:  BTFSC  FD8.0
05854:  BRA    585C
05856:  MOVLB  0
05858:  GOTO   5898
0585C:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
0585E:  CLRF   03
05860:  MOVLB  1
05862:  MOVF   xD2,W
05864:  ADDLW  91
05866:  MOVWF  FE9
05868:  MOVLW  01
0586A:  ADDWFC 03,W
0586C:  MOVWF  FEA
0586E:  MOVFF  FEF,1D3
05872:  MOVFF  1D3,264
05876:  MOVLW  37
05878:  MOVLB  2
0587A:  MOVWF  x65
0587C:  MOVLB  0
0587E:  CALL   1E42
05882:  MOVLW  20
05884:  MOVLB  A
05886:  MOVWF  xAD
05888:  MOVLB  0
0588A:  CALL   1B6C
0588E:  MOVLB  1
05890:  INCF   xD2,F
05892:  MOVLB  0
05894:  GOTO   584C
....................    }
....................    misf_init(); // Update the address area after writing
05898:  CALL   2FDC
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
0589C:  MOVLB  1
0589E:  MOVF   x8F,W
058A0:  MOVWF  FE9
058A2:  MOVF   x90,W
058A4:  MOVWF  FEA
058A6:  MOVFF  FEF,1D3
058AA:  MOVFF  1D3,1E0
058AE:  SETF   xE1
058B0:  MOVLB  0
058B2:  CALL   3862
....................    fprintf(PC, "End Flash Address Reset\r\n");
058B6:  MOVLW  EE
058B8:  MOVWF  FF6
058BA:  MOVLW  18
058BC:  MOVWF  FF7
058BE:  MOVLW  00
058C0:  MOVWF  FF8
058C2:  CALL   1BBE
058C6:  GOTO   590C (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
05D66:  MOVLW  01
05D68:  MOVLB  1
05D6A:  ADDWF  x8D,W
05D6C:  MOVWF  FE9
05D6E:  MOVLW  00
05D70:  ADDWFC x8E,W
05D72:  MOVWF  FEA
05D74:  MOVF   FEF,W
05D76:  CLRF   xDF
05D78:  CLRF   xDE
05D7A:  CLRF   xDD
05D7C:  MOVWF  xDC
05D7E:  MOVFF  1DC,1DF
05D82:  CLRF   xDC
05D84:  CLRF   xDD
05D86:  CLRF   xDE
05D88:  MOVLW  02
05D8A:  ADDWF  x8D,W
05D8C:  MOVWF  FE9
05D8E:  MOVLW  00
05D90:  ADDWFC x8E,W
05D92:  MOVWF  FEA
05D94:  MOVF   FEF,W
05D96:  CLRF   xE4
05D98:  CLRF   xE3
05D9A:  CLRF   xE2
05D9C:  MOVWF  xE1
05D9E:  MOVFF  1E2,03
05DA2:  MOVFF  1E1,02
05DA6:  CLRF   00
05DA8:  CLRF   01
05DAA:  MOVF   00,W
05DAC:  IORWF  xDC,F
05DAE:  MOVF   01,W
05DB0:  IORWF  xDD,F
05DB2:  MOVF   02,W
05DB4:  IORWF  xDE,F
05DB6:  MOVF   03,W
05DB8:  IORWF  xDF,F
05DBA:  MOVLW  03
05DBC:  ADDWF  x8D,W
05DBE:  MOVWF  FE9
05DC0:  MOVLW  00
05DC2:  ADDWFC x8E,W
05DC4:  MOVWF  FEA
05DC6:  MOVF   FEF,W
05DC8:  CLRF   xE4
05DCA:  CLRF   xE3
05DCC:  CLRF   xE2
05DCE:  MOVWF  xE1
05DD0:  MOVFF  1E3,03
05DD4:  MOVFF  1E2,02
05DD8:  MOVFF  1E1,01
05DDC:  CLRF   00
05DDE:  MOVF   00,W
05DE0:  IORWF  xDC,F
05DE2:  MOVF   01,W
05DE4:  IORWF  xDD,F
05DE6:  MOVF   02,W
05DE8:  IORWF  xDE,F
05DEA:  MOVF   03,W
05DEC:  IORWF  xDF,F
05DEE:  MOVLW  04
05DF0:  ADDWF  x8D,W
05DF2:  MOVWF  FE9
05DF4:  MOVLW  00
05DF6:  ADDWFC x8E,W
05DF8:  MOVWF  FEA
05DFA:  MOVF   FEF,W
05DFC:  MOVWF  00
05DFE:  CLRF   01
05E00:  CLRF   02
05E02:  CLRF   03
05E04:  MOVF   00,W
05E06:  IORWF  xDC,W
05E08:  MOVWF  x8F
05E0A:  MOVF   01,W
05E0C:  IORWF  xDD,W
05E0E:  MOVWF  x90
05E10:  MOVF   02,W
05E12:  IORWF  xDE,W
05E14:  MOVWF  x91
05E16:  MOVF   03,W
05E18:  IORWF  xDF,W
05E1A:  MOVWF  x92
05E1C:  MOVLW  07
05E1E:  ADDWF  x8D,W
05E20:  MOVWF  FE9
05E22:  MOVLW  00
05E24:  ADDWFC x8E,W
05E26:  MOVWF  FEA
05E28:  MOVF   FEF,W
05E2A:  CLRF   xDD
05E2C:  MOVWF  xDC
05E2E:  MOVFF  1DC,1DD
05E32:  CLRF   xDC
05E34:  MOVLW  08
05E36:  ADDWF  x8D,W
05E38:  MOVWF  FE9
05E3A:  MOVLW  00
05E3C:  ADDWFC x8E,W
05E3E:  MOVWF  FEA
05E40:  MOVF   FEF,W
05E42:  CLRF   03
05E44:  IORWF  xDC,W
05E46:  MOVWF  x93
05E48:  MOVF   03,W
05E4A:  IORWF  xDD,W
05E4C:  MOVWF  x94
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
05E4E:  CLRF   x95
05E50:  CLRF   x96
05E52:  CLRF   x97
05E54:  CLRF   x98
05E56:  CLRF   x99
05E58:  CLRF   x9A
05E5A:  CLRF   x9B
05E5C:  CLRF   x9C
05E5E:  CLRF   x9D
05E60:  CLRF   x9E
05E62:  CLRF   x9F
05E64:  CLRF   xA0
05E66:  CLRF   xA1
05E68:  CLRF   xA2
05E6A:  CLRF   xA3
05E6C:  CLRF   xA4
05E6E:  CLRF   xA5
05E70:  CLRF   xA6
05E72:  CLRF   xA7
05E74:  CLRF   xA8
05E76:  CLRF   xA9
05E78:  CLRF   xAA
05E7A:  CLRF   xAB
05E7C:  CLRF   xAC
05E7E:  CLRF   xAD
05E80:  CLRF   xAE
05E82:  CLRF   xAF
05E84:  CLRF   xB0
05E86:  CLRF   xB1
05E88:  CLRF   xB2
05E8A:  CLRF   xB3
05E8C:  CLRF   xB4
05E8E:  CLRF   xB5
05E90:  CLRF   xB6
05E92:  CLRF   xB7
05E94:  CLRF   xB8
05E96:  CLRF   xB9
05E98:  CLRF   xBA
05E9A:  CLRF   xBB
05E9C:  CLRF   xBC
05E9E:  CLRF   xBD
05EA0:  CLRF   xBE
05EA2:  CLRF   xBF
05EA4:  CLRF   xC0
05EA6:  CLRF   xC1
05EA8:  CLRF   xC2
05EAA:  CLRF   xC3
05EAC:  CLRF   xC4
05EAE:  CLRF   xC5
05EB0:  CLRF   xC6
05EB2:  CLRF   xC7
05EB4:  CLRF   xC8
05EB6:  CLRF   xC9
05EB8:  CLRF   xCA
05EBA:  CLRF   xCB
05EBC:  CLRF   xCC
05EBE:  CLRF   xCD
05EC0:  CLRF   xCE
05EC2:  CLRF   xCF
05EC4:  CLRF   xD0
05EC6:  CLRF   xD1
05EC8:  CLRF   xD2
05ECA:  CLRF   xD3
05ECC:  CLRF   xD4
....................    if(!is_connect(smf)) {
05ECE:  MOVFF  115,263
05ED2:  MOVFF  114,262
05ED6:  MOVFF  113,261
05EDA:  MOVFF  112,260
05EDE:  MOVLB  0
05EE0:  CALL   26D8
05EE4:  MOVF   01,F
05EE6:  BTFSS  FD8.2
05EE8:  GOTO   5F00
....................       printf("SMF is not connected\r\n");
05EEC:  MOVLW  08
05EEE:  MOVWF  FF6
05EF0:  MOVLW  19
05EF2:  MOVWF  FF7
05EF4:  MOVLW  00
05EF6:  MOVWF  FF8
05EF8:  CALL   1BBE
....................       return;
05EFC:  GOTO   6144
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
05F00:  MOVLW  20
05F02:  MOVWF  FF6
05F04:  MOVLW  19
05F06:  MOVWF  FF7
05F08:  MOVLW  00
05F0A:  MOVWF  FF8
05F0C:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05F10:  MOVLB  1
05F12:  MOVF   x8D,W
05F14:  MOVWF  FE9
05F16:  MOVF   x8E,W
05F18:  MOVWF  FEA
05F1A:  MOVFF  FEF,1DC
05F1E:  MOVFF  1DC,1E0
05F22:  CLRF   xE1
05F24:  MOVLB  0
05F26:  CALL   3862
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
05F2A:  MOVLW  3E
05F2C:  MOVWF  FF6
05F2E:  MOVLW  19
05F30:  MOVWF  FF7
05F32:  MOVLW  00
05F34:  MOVWF  FF8
05F36:  MOVLW  0E
05F38:  MOVLB  9
05F3A:  MOVWF  xC2
05F3C:  MOVLB  0
05F3E:  CALL   1BEE
05F42:  MOVFF  192,264
05F46:  MOVLW  37
05F48:  MOVLB  2
05F4A:  MOVWF  x65
05F4C:  MOVLB  0
05F4E:  CALL   1E42
05F52:  MOVFF  191,264
05F56:  MOVLW  37
05F58:  MOVLB  2
05F5A:  MOVWF  x65
05F5C:  MOVLB  0
05F5E:  CALL   1E42
05F62:  MOVFF  190,264
05F66:  MOVLW  37
05F68:  MOVLB  2
05F6A:  MOVWF  x65
05F6C:  MOVLB  0
05F6E:  CALL   1E42
05F72:  MOVFF  18F,264
05F76:  MOVLW  37
05F78:  MOVLB  2
05F7A:  MOVWF  x65
05F7C:  MOVLB  0
05F7E:  CALL   1E42
05F82:  MOVLW  0D
05F84:  MOVLB  A
05F86:  MOVWF  xAD
05F88:  MOVLB  0
05F8A:  CALL   1B6C
05F8E:  MOVLW  0A
05F90:  MOVLB  A
05F92:  MOVWF  xAD
05F94:  MOVLB  0
05F96:  CALL   1B6C
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
05F9A:  MOVLW  54
05F9C:  MOVWF  FF6
05F9E:  MOVLW  19
05FA0:  MOVWF  FF7
05FA2:  MOVLW  00
05FA4:  MOVWF  FF8
05FA6:  MOVLW  0E
05FA8:  MOVLB  9
05FAA:  MOVWF  xC2
05FAC:  MOVLB  0
05FAE:  CALL   1BEE
05FB2:  MOVFF  194,264
05FB6:  MOVLW  37
05FB8:  MOVLB  2
05FBA:  MOVWF  x65
05FBC:  MOVLB  0
05FBE:  CALL   1E42
05FC2:  MOVFF  193,264
05FC6:  MOVLW  37
05FC8:  MOVLB  2
05FCA:  MOVWF  x65
05FCC:  MOVLB  0
05FCE:  CALL   1E42
05FD2:  MOVLW  0D
05FD4:  MOVLB  A
05FD6:  MOVWF  xAD
05FD8:  MOVLB  0
05FDA:  CALL   1B6C
05FDE:  MOVLW  0A
05FE0:  MOVLB  A
05FE2:  MOVWF  xAD
05FE4:  MOVLB  0
05FE6:  CALL   1B6C
....................    printf("read data\r\n");
05FEA:  MOVLW  6A
05FEC:  MOVWF  FF6
05FEE:  MOVLW  19
05FF0:  MOVWF  FF7
05FF2:  MOVLW  00
05FF4:  MOVWF  FF8
05FF6:  CALL   1BBE
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
05FFA:  MOVLB  1
05FFC:  CLRF   xD6
05FFE:  CLRF   xD5
06000:  MOVLB  0
06002:  MOVLB  1
06004:  MOVF   xD6,W
06006:  SUBWF  x94,W
06008:  BTFSC  FD8.0
0600A:  BRA    6012
0600C:  MOVLB  0
0600E:  GOTO   611A
06012:  MOVLB  0
06014:  BTFSS  FD8.2
06016:  GOTO   602C
0601A:  MOVLB  1
0601C:  MOVF   x93,W
0601E:  SUBWF  xD5,W
06020:  BTFSS  FD8.0
06022:  BRA    602A
06024:  MOVLB  0
06026:  GOTO   611A
0602A:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
0602C:  MOVLB  1
0602E:  RLCF   xD5,W
06030:  MOVWF  02
06032:  RLCF   xD6,W
06034:  MOVWF  03
06036:  RLCF   02,F
06038:  RLCF   03,F
0603A:  RLCF   02,F
0603C:  RLCF   03,F
0603E:  RLCF   02,F
06040:  RLCF   03,F
06042:  RLCF   02,F
06044:  RLCF   03,F
06046:  RLCF   02,F
06048:  RLCF   03,F
0604A:  MOVLW  C0
0604C:  ANDWF  02,F
0604E:  MOVF   02,W
06050:  ADDWF  x8F,W
06052:  MOVWF  xD7
06054:  MOVF   03,W
06056:  ADDWFC x90,W
06058:  MOVWF  xD8
0605A:  MOVLW  00
0605C:  ADDWFC x91,W
0605E:  MOVWF  xD9
06060:  MOVLW  00
06062:  ADDWFC x92,W
06064:  MOVWF  xDA
06066:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
06068:  MOVFF  115,2E5
0606C:  MOVFF  114,2E4
06070:  MOVFF  113,2E3
06074:  MOVFF  112,2E2
06078:  MOVFF  1DA,2E9
0607C:  MOVFF  1D9,2E8
06080:  MOVFF  1D8,2E7
06084:  MOVFF  1D7,2E6
06088:  MOVLW  01
0608A:  MOVLB  2
0608C:  MOVWF  xEB
0608E:  MOVLW  95
06090:  MOVWF  xEA
06092:  CLRF   xEF
06094:  CLRF   xEE
06096:  CLRF   xED
06098:  MOVLW  40
0609A:  MOVWF  xEC
0609C:  MOVLB  0
0609E:  CALL   27C4
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
060A2:  MOVLB  1
060A4:  CLRF   xDB
060A6:  MOVLB  0
060A8:  MOVLB  1
060AA:  MOVF   xDB,W
060AC:  SUBLW  3F
060AE:  BTFSC  FD8.0
060B0:  BRA    60B8
060B2:  MOVLB  0
060B4:  GOTO   60F4
060B8:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
060BA:  CLRF   03
060BC:  MOVLB  1
060BE:  MOVF   xDB,W
060C0:  ADDLW  95
060C2:  MOVWF  FE9
060C4:  MOVLW  01
060C6:  ADDWFC 03,W
060C8:  MOVWF  FEA
060CA:  MOVFF  FEF,1DC
060CE:  MOVFF  1DC,264
060D2:  MOVLW  37
060D4:  MOVLB  2
060D6:  MOVWF  x65
060D8:  MOVLB  0
060DA:  CALL   1E42
060DE:  MOVLW  20
060E0:  MOVLB  A
060E2:  MOVWF  xAD
060E4:  MOVLB  0
060E6:  CALL   1B6C
060EA:  MOVLB  1
060EC:  INCF   xDB,F
060EE:  MOVLB  0
060F0:  GOTO   60A8
....................       }
....................       printf("\r\n");
060F4:  MOVLW  0D
060F6:  MOVLB  A
060F8:  MOVWF  xAD
060FA:  MOVLB  0
060FC:  CALL   1B6C
06100:  MOVLW  0A
06102:  MOVLB  A
06104:  MOVWF  xAD
06106:  MOVLB  0
06108:  CALL   1B6C
0610C:  MOVLB  1
0610E:  INCF   xD5,F
06110:  BTFSC  FD8.2
06112:  INCF   xD6,F
06114:  MOVLB  0
06116:  GOTO   6002
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
0611A:  MOVLW  76
0611C:  MOVWF  FF6
0611E:  MOVLW  19
06120:  MOVWF  FF7
06122:  MOVLW  00
06124:  MOVWF  FF8
06126:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
0612A:  MOVLB  1
0612C:  MOVF   x8D,W
0612E:  MOVWF  FE9
06130:  MOVF   x8E,W
06132:  MOVWF  FEA
06134:  MOVFF  FEF,1DC
06138:  MOVFF  1DC,1E0
0613C:  SETF   xE1
0613E:  MOVLB  0
06140:  CALL   3862
06144:  GOTO   9140 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
06148:  MOVLW  94
0614A:  MOVWF  FF6
0614C:  MOVLW  19
0614E:  MOVWF  FF7
06150:  MOVLW  00
06152:  MOVWF  FF8
06154:  CALL   1BBE
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
06158:  MOVLB  1
0615A:  MOVF   x8D,W
0615C:  MOVWF  FE9
0615E:  MOVF   x8E,W
06160:  MOVWF  FEA
06162:  MOVFF  FEF,18F
....................    piclog_make(cmd, 0x00); // Log the command execution
06166:  MOVFF  18F,1E0
0616A:  CLRF   xE1
0616C:  MOVLB  0
0616E:  CALL   3862
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
06172:  MOVLW  06
06174:  MOVLB  1
06176:  MOVWF  x93
06178:  MOVLW  AA
0617A:  MOVWF  x92
0617C:  CLRF   x91
0617E:  CLRF   x90
06180:  MOVLB  0
06182:  MOVLB  1
06184:  MOVF   x93,W
06186:  SUBLW  06
06188:  BTFSC  FD8.0
0618A:  BRA    6192
0618C:  MOVLB  0
0618E:  GOTO   6210
06192:  MOVLB  0
06194:  BTFSS  FD8.2
06196:  GOTO   61DC
0619A:  MOVLB  1
0619C:  MOVF   x92,W
0619E:  SUBLW  AA
061A0:  BTFSC  FD8.0
061A2:  BRA    61AA
061A4:  MOVLB  0
061A6:  GOTO   6210
061AA:  MOVLB  0
061AC:  BTFSS  FD8.2
061AE:  GOTO   61DC
061B2:  MOVLB  1
061B4:  MOVF   x91,W
061B6:  SUBLW  1F
061B8:  BTFSC  FD8.0
061BA:  BRA    61C2
061BC:  MOVLB  0
061BE:  GOTO   6210
061C2:  MOVLB  0
061C4:  BTFSS  FD8.2
061C6:  GOTO   61DC
061CA:  MOVLB  1
061CC:  MOVF   x90,W
061CE:  SUBLW  FE
061D0:  BTFSC  FD8.0
061D2:  BRA    61DA
061D4:  MOVLB  0
061D6:  GOTO   6210
061DA:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
061DC:  MOVFF  115,A59
061E0:  MOVFF  114,A58
061E4:  MOVFF  113,A57
061E8:  MOVFF  112,A56
061EC:  MOVFF  193,A5D
061F0:  MOVFF  192,A5C
061F4:  MOVFF  191,A5B
061F8:  MOVFF  190,A5A
061FC:  CALL   40B6
06200:  MOVLW  01
06202:  MOVLB  1
06204:  ADDWF  x92,F
06206:  MOVLW  00
06208:  ADDWFC x93,F
0620A:  MOVLB  0
0620C:  GOTO   6182
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
06210:  MOVFF  18F,1E0
06214:  MOVLB  1
06216:  SETF   xE1
06218:  MOVLB  0
0621A:  CALL   3862
....................    printf("End SMF Erase All\r\n");
0621E:  MOVLW  AA
06220:  MOVWF  FF6
06222:  MOVLW  19
06224:  MOVWF  FF7
06226:  MOVLW  00
06228:  MOVWF  FF8
0622A:  CALL   1BBE
0622E:  GOTO   9150 (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
05BEE:  MOVLW  BE
05BF0:  MOVWF  FF6
05BF2:  MOVLW  19
05BF4:  MOVWF  FF7
05BF6:  MOVLW  00
05BF8:  MOVWF  FF8
05BFA:  CALL   1BBE
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
05BFE:  MOVLB  1
05C00:  MOVF   x8D,W
05C02:  MOVWF  FE9
05C04:  MOVF   x8E,W
05C06:  MOVWF  FEA
05C08:  MOVFF  FEF,1D3
05C0C:  MOVFF  1D3,1E0
05C10:  CLRF   xE1
05C12:  MOVLB  0
05C14:  CALL   3862
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
05C18:  MOVLB  1
05C1A:  CLRF   x8F
05C1C:  CLRF   x90
05C1E:  CLRF   x91
05C20:  CLRF   x92
05C22:  CLRF   x93
05C24:  CLRF   x94
05C26:  CLRF   x95
05C28:  CLRF   x96
05C2A:  CLRF   x97
05C2C:  CLRF   x98
05C2E:  CLRF   x99
05C30:  CLRF   x9A
05C32:  CLRF   x9B
05C34:  CLRF   x9C
05C36:  CLRF   x9D
05C38:  CLRF   x9E
05C3A:  CLRF   x9F
05C3C:  CLRF   xA0
05C3E:  CLRF   xA1
05C40:  CLRF   xA2
05C42:  CLRF   xA3
05C44:  CLRF   xA4
05C46:  CLRF   xA5
05C48:  CLRF   xA6
05C4A:  CLRF   xA7
05C4C:  CLRF   xA8
05C4E:  CLRF   xA9
05C50:  CLRF   xAA
05C52:  CLRF   xAB
05C54:  CLRF   xAC
05C56:  CLRF   xAD
05C58:  CLRF   xAE
05C5A:  CLRF   xAF
05C5C:  CLRF   xB0
05C5E:  CLRF   xB1
05C60:  CLRF   xB2
05C62:  CLRF   xB3
05C64:  CLRF   xB4
05C66:  CLRF   xB5
05C68:  CLRF   xB6
05C6A:  CLRF   xB7
05C6C:  CLRF   xB8
05C6E:  CLRF   xB9
05C70:  CLRF   xBA
05C72:  CLRF   xBB
05C74:  CLRF   xBC
05C76:  CLRF   xBD
05C78:  CLRF   xBE
05C7A:  CLRF   xBF
05C7C:  CLRF   xC0
05C7E:  CLRF   xC1
05C80:  CLRF   xC2
05C82:  CLRF   xC3
05C84:  CLRF   xC4
05C86:  CLRF   xC5
05C88:  CLRF   xC6
05C8A:  CLRF   xC7
05C8C:  CLRF   xC8
05C8E:  CLRF   xC9
05C90:  CLRF   xCA
05C92:  CLRF   xCB
05C94:  CLRF   xCC
05C96:  CLRF   xCD
05C98:  CLRF   xCE
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_IV2_DATA_END_ADDRESS; address += SECTOR_64K_BYTE) {
05C9A:  MOVLW  06
05C9C:  MOVWF  xD2
05C9E:  MOVLW  AA
05CA0:  MOVWF  xD1
05CA2:  CLRF   xD0
05CA4:  CLRF   xCF
05CA6:  MOVLB  0
05CA8:  MOVLB  1
05CAA:  MOVF   xD2,W
05CAC:  SUBLW  07
05CAE:  BTFSC  FD8.0
05CB0:  BRA    5CB8
05CB2:  MOVLB  0
05CB4:  GOTO   5D36
05CB8:  MOVLB  0
05CBA:  BTFSS  FD8.2
05CBC:  GOTO   5D02
05CC0:  MOVLB  1
05CC2:  MOVF   xD1,W
05CC4:  SUBLW  48
05CC6:  BTFSC  FD8.0
05CC8:  BRA    5CD0
05CCA:  MOVLB  0
05CCC:  GOTO   5D36
05CD0:  MOVLB  0
05CD2:  BTFSS  FD8.2
05CD4:  GOTO   5D02
05CD8:  MOVLB  1
05CDA:  MOVF   xD0,W
05CDC:  SUBLW  3F
05CDE:  BTFSC  FD8.0
05CE0:  BRA    5CE8
05CE2:  MOVLB  0
05CE4:  GOTO   5D36
05CE8:  MOVLB  0
05CEA:  BTFSS  FD8.2
05CEC:  GOTO   5D02
05CF0:  MOVLB  1
05CF2:  MOVF   xCF,W
05CF4:  SUBLW  FE
05CF6:  BTFSC  FD8.0
05CF8:  BRA    5D00
05CFA:  MOVLB  0
05CFC:  GOTO   5D36
05D00:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
05D02:  MOVFF  115,A59
05D06:  MOVFF  114,A58
05D0A:  MOVFF  113,A57
05D0E:  MOVFF  112,A56
05D12:  MOVFF  1D2,A5D
05D16:  MOVFF  1D1,A5C
05D1A:  MOVFF  1D0,A5B
05D1E:  MOVFF  1CF,A5A
05D22:  CALL   40B6
05D26:  MOVLW  01
05D28:  MOVLB  1
05D2A:  ADDWF  xD1,F
05D2C:  MOVLW  00
05D2E:  ADDWFC xD2,F
05D30:  MOVLB  0
05D32:  GOTO   5CA8
....................    }
....................    smf_data_table_init(); // Update the address area after writing
05D36:  GOTO   5B20
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05D3A:  MOVLB  1
05D3C:  MOVF   x8D,W
05D3E:  MOVWF  FE9
05D40:  MOVF   x8E,W
05D42:  MOVWF  FEA
05D44:  MOVFF  FEF,1D3
05D48:  MOVFF  1D3,1E0
05D4C:  SETF   xE1
05D4E:  MOVLB  0
05D50:  CALL   3862
....................    printf("End SMF Reset\r\n");
05D54:  MOVLW  D0
05D56:  MOVWF  FF6
05D58:  MOVLW  19
05D5A:  MOVWF  FF7
05D5C:  MOVLW  00
05D5E:  MOVWF  FF8
05D60:  CALL   1BBE
05D64:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0B22E:  CLRF   FF8
0B230:  BCF    FD0.7
0B232:  BSF    07.7
0B234:  MOVLB  E
0B236:  MOVLW  55
0B238:  MOVWF  F7E
0B23A:  MOVLW  AA
0B23C:  MOVWF  F7E
0B23E:  BCF    F66.6
0B240:  MOVLW  F9
0B242:  MOVWF  x2C
0B244:  MOVLW  0F
0B246:  MOVWF  x2E
0B248:  MOVLW  40
0B24A:  MOVWF  x12
0B24C:  MOVLW  30
0B24E:  MOVWF  x13
0B250:  MOVLW  20
0B252:  MOVWF  x22
0B254:  MOVLW  55
0B256:  MOVWF  F7E
0B258:  MOVLW  AA
0B25A:  MOVWF  F7E
0B25C:  BSF    F66.6
0B25E:  CLRF   F9B
0B260:  CLRF   F64
0B262:  CLRF   F65
0B264:  CLRF   F66
0B266:  MOVLW  02
0B268:  MOVWF  FD3
0B26A:  CLRF   1B
0B26C:  MOVLB  F
0B26E:  BSF    x2D.3
0B270:  MOVLW  A0
0B272:  MOVWF  x2B
0B274:  MOVLW  01
0B276:  MOVWF  x2C
0B278:  MOVLW  A6
0B27A:  MOVWF  x2E
0B27C:  MOVLW  90
0B27E:  MOVWF  x2F
0B280:  BCF    F93.6
0B282:  BSF    F8A.6
0B284:  BSF    F92.1
0B286:  BCF    F92.0
0B288:  BCF    F92.3
0B28A:  BCF    F89.3
0B28C:  BSF    F96.0
0B28E:  BCF    F96.6
0B290:  BCF    F96.1
0B292:  BCF    F8D.1
0B294:  BSF    F93.4
0B296:  BCF    F93.5
0B298:  BCF    F93.2
0B29A:  BSF    F8A.2
0B29C:  CLRF   1F
0B29E:  CLRF   1E
0B2A0:  CLRF   1D
0B2A2:  CLRF   1C
0B2A4:  CLRF   23
0B2A6:  CLRF   22
0B2A8:  CLRF   21
0B2AA:  CLRF   20
0B2AC:  CLRF   25
0B2AE:  CLRF   24
0B2B0:  CLRF   46
0B2B2:  BCF    47.0
0B2B4:  MOVLW  1E
0B2B6:  MOVLB  1
0B2B8:  MOVWF  x4E
0B2BA:  CLRF   x50
0B2BC:  CLRF   x4F
0B2BE:  MOVLB  E
0B2C0:  CLRF   xD9
0B2C2:  CLRF   xDA
0B2C4:  CLRF   xCE
0B2C6:  CLRF   xCF
0B2C8:  CLRF   xD0
0B2CA:  CLRF   xD1
0B2CC:  CLRF   xD2
0B2CE:  CLRF   xD3
0B2D0:  CLRF   xD4
0B2D2:  CLRF   xD5
0B2D4:  CLRF   x45
0B2D6:  CLRF   x46
0B2D8:  CLRF   x47
0B2DA:  BCF    x8D.7
0B2DC:  BCF    x8D.6
0B2DE:  BCF    x8D.5
0B2E0:  MOVLB  F
0B2E2:  CLRF   x53
0B2E4:  CLRF   x38
0B2E6:  CLRF   x37
0B2E8:  MOVLB  0
0B2EA:  CLRF   26
0B2EC:  CLRF   27
0B2EE:  CLRF   28
0B2F0:  CLRF   29
0B2F2:  CLRF   2A
0B2F4:  CLRF   2B
0B2F6:  CLRF   2C
0B2F8:  CLRF   2D
0B2FA:  CLRF   2E
0B2FC:  CLRF   2F
0B2FE:  CLRF   30
0B300:  CLRF   31
0B302:  CLRF   32
0B304:  CLRF   33
0B306:  CLRF   34
0B308:  CLRF   35
0B30A:  CLRF   36
0B30C:  CLRF   37
0B30E:  CLRF   38
0B310:  CLRF   39
0B312:  CLRF   3A
0B314:  CLRF   3B
0B316:  CLRF   3C
0B318:  CLRF   3D
0B31A:  CLRF   3E
0B31C:  CLRF   3F
0B31E:  CLRF   40
0B320:  CLRF   41
0B322:  CLRF   42
0B324:  CLRF   43
0B326:  CLRF   44
0B328:  CLRF   45
0B32A:  MOVLW  03
0B32C:  MOVWF  48
0B32E:  CLRF   49
0B330:  CLRF   4A
0B332:  CLRF   4B
0B334:  CLRF   4C
0B336:  CLRF   4D
0B338:  CLRF   4E
0B33A:  CLRF   4F
0B33C:  CLRF   50
0B33E:  CLRF   51
0B340:  CLRF   52
0B342:  CLRF   53
0B344:  CLRF   54
0B346:  CLRF   55
0B348:  CLRF   56
0B34A:  CLRF   57
0B34C:  CLRF   58
0B34E:  CLRF   59
0B350:  CLRF   5A
0B352:  CLRF   5B
0B354:  CLRF   5C
0B356:  CLRF   5D
0B358:  CLRF   5E
0B35A:  CLRF   5F
0B35C:  CLRF   x60
0B35E:  CLRF   x61
0B360:  CLRF   x62
0B362:  CLRF   x63
0B364:  CLRF   x64
0B366:  CLRF   x65
0B368:  CLRF   x66
0B36A:  CLRF   x67
0B36C:  CLRF   x68
0B36E:  CLRF   x69
0B370:  CLRF   x6A
0B372:  CLRF   x6B
0B374:  CLRF   x6C
0B376:  CLRF   x6D
0B378:  CLRF   x6E
0B37A:  CLRF   x6F
0B37C:  CLRF   x70
0B37E:  CLRF   x71
0B380:  CLRF   x72
0B382:  CLRF   x73
0B384:  CLRF   x74
0B386:  CLRF   x75
0B388:  CLRF   x76
0B38A:  CLRF   x77
0B38C:  CLRF   x78
0B38E:  CLRF   x79
0B390:  CLRF   x7A
0B392:  CLRF   x7B
0B394:  CLRF   x7C
0B396:  CLRF   x7D
0B398:  CLRF   x7E
0B39A:  CLRF   x7F
0B39C:  CLRF   x80
0B39E:  CLRF   x81
0B3A0:  CLRF   x82
0B3A2:  CLRF   x83
0B3A4:  CLRF   x84
0B3A6:  CLRF   x85
0B3A8:  CLRF   x86
0B3AA:  CLRF   x87
0B3AC:  CLRF   x88
0B3AE:  CLRF   x89
0B3B0:  CLRF   x8A
0B3B2:  CLRF   x8B
0B3B4:  CLRF   x8C
0B3B6:  CLRF   x8D
0B3B8:  CLRF   x8E
0B3BA:  CLRF   x8F
0B3BC:  CLRF   x90
0B3BE:  CLRF   x91
0B3C0:  CLRF   x92
0B3C2:  CLRF   x93
0B3C4:  CLRF   x94
0B3C6:  CLRF   x95
0B3C8:  CLRF   x96
0B3CA:  CLRF   x97
0B3CC:  CLRF   x98
0B3CE:  CLRF   x99
0B3D0:  CLRF   x9A
0B3D2:  CLRF   x9B
0B3D4:  CLRF   x9C
0B3D6:  CLRF   x9D
0B3D8:  CLRF   x9E
0B3DA:  CLRF   x9F
0B3DC:  CLRF   xA0
0B3DE:  CLRF   xA1
0B3E0:  CLRF   xA2
0B3E2:  CLRF   xA3
0B3E4:  CLRF   xA4
0B3E6:  CLRF   xA5
0B3E8:  CLRF   xA6
0B3EA:  CLRF   xA7
0B3EC:  CLRF   xA8
0B3EE:  CLRF   xA9
0B3F0:  CLRF   xAA
0B3F2:  CLRF   xAB
0B3F4:  CLRF   xAC
0B3F6:  CLRF   xAD
0B3F8:  CLRF   xAE
0B3FA:  CLRF   xAF
0B3FC:  CLRF   xB0
0B3FE:  CLRF   xB1
0B400:  CLRF   xB2
0B402:  CLRF   xB3
0B404:  CLRF   xB4
0B406:  CLRF   xB5
0B408:  CLRF   xB6
0B40A:  CLRF   xB7
0B40C:  CLRF   xB8
0B40E:  CLRF   xB9
0B410:  CLRF   xBA
0B412:  CLRF   xBB
0B414:  CLRF   xBC
0B416:  CLRF   xBD
0B418:  CLRF   xBE
0B41A:  CLRF   xBF
0B41C:  CLRF   xC0
0B41E:  CLRF   xC1
0B420:  CLRF   xC2
0B422:  CLRF   xC3
0B424:  CLRF   xC4
0B426:  CLRF   xC5
0B428:  CLRF   xC6
0B42A:  CLRF   xC7
0B42C:  CLRF   xC8
0B42E:  CLRF   xC9
0B430:  CLRF   xCA
0B432:  CLRF   xCB
0B434:  CLRF   xCC
0B436:  CLRF   xCD
0B438:  CLRF   xCE
0B43A:  CLRF   xCF
0B43C:  CLRF   xD0
0B43E:  CLRF   xD1
0B440:  CLRF   xD2
0B442:  CLRF   xD3
0B444:  CLRF   xD4
0B446:  CLRF   xD5
0B448:  CLRF   xD6
0B44A:  CLRF   xD7
0B44C:  CLRF   xD8
0B44E:  CLRF   xD9
0B450:  CLRF   xDA
0B452:  CLRF   xDB
0B454:  CLRF   xDC
0B456:  CLRF   xDD
0B458:  CLRF   xDE
0B45A:  CLRF   xDF
0B45C:  CLRF   xE0
0B45E:  CLRF   xE1
0B460:  CLRF   xE2
0B462:  CLRF   xE3
0B464:  CLRF   xE4
0B466:  CLRF   xE5
0B468:  CLRF   xE6
0B46A:  CLRF   xE7
0B46C:  CLRF   xE8
0B46E:  CLRF   xE9
0B470:  CLRF   xEA
0B472:  CLRF   xEB
0B474:  CLRF   xEC
0B476:  CLRF   xED
0B478:  CLRF   xEE
0B47A:  CLRF   xEF
0B47C:  CLRF   xF0
0B47E:  CLRF   xF1
0B480:  CLRF   xF2
0B482:  CLRF   xF3
0B484:  CLRF   xF4
0B486:  CLRF   xF5
0B488:  CLRF   xF6
0B48A:  CLRF   xF7
0B48C:  CLRF   xF8
0B48E:  CLRF   xF9
0B490:  CLRF   xFA
0B492:  CLRF   xFB
0B494:  CLRF   xFC
0B496:  CLRF   xFD
0B498:  CLRF   xFE
0B49A:  CLRF   xFF
0B49C:  MOVLB  1
0B49E:  CLRF   x00
0B4A0:  CLRF   x01
0B4A2:  CLRF   x02
0B4A4:  CLRF   x03
0B4A6:  CLRF   x04
0B4A8:  CLRF   x05
0B4AA:  CLRF   x06
0B4AC:  CLRF   x07
0B4AE:  CLRF   x08
0B4B0:  CLRF   x09
0B4B2:  CLRF   x0A
0B4B4:  CLRF   x0B
0B4B6:  CLRF   x0C
0B4B8:  CLRF   x0D
0B4BA:  CLRF   x0E
0B4BC:  CLRF   x0F
0B4BE:  MOVLW  05
0B4C0:  MOVWF  x10
0B4C2:  MOVLW  7C
0B4C4:  MOVWF  x11
0B4C6:  MOVLW  01
0B4C8:  MOVWF  x12
0B4CA:  MOVLW  01
0B4CC:  MOVWF  x13
0B4CE:  MOVLW  02
0B4D0:  MOVWF  x14
0B4D2:  MOVLW  7C
0B4D4:  MOVWF  x15
0B4D6:  CLRF   x16
0B4D8:  MOVLW  09
0B4DA:  MOVWF  x17
0B4DC:  MOVLW  01
0B4DE:  MOVWF  x18
0B4E0:  CLRF   x19
0B4E2:  MOVLW  02
0B4E4:  MOVWF  x1A
0B4E6:  MOVLW  01
0B4E8:  MOVWF  x1B
0B4EA:  CLRF   x1C
0B4EC:  CLRF   x1D
0B4EE:  CLRF   x1E
0B4F0:  CLRF   x1F
0B4F2:  CLRF   x20
0B4F4:  CLRF   x21
0B4F6:  CLRF   x22
0B4F8:  CLRF   x23
0B4FA:  CLRF   x24
0B4FC:  CLRF   x25
0B4FE:  CLRF   x26
0B500:  CLRF   x27
0B502:  CLRF   x28
0B504:  MOVLW  01
0B506:  MOVWF  x29
0B508:  CLRF   x2A
0B50A:  CLRF   x2B
0B50C:  CLRF   x2C
0B50E:  CLRF   x2D
0B510:  CLRF   x2E
0B512:  CLRF   x2F
0B514:  CLRF   x30
0B516:  CLRF   x31
0B518:  CLRF   x32
0B51A:  CLRF   x33
0B51C:  MOVLW  02
0B51E:  MOVWF  x34
0B520:  CLRF   x35
0B522:  CLRF   x36
0B524:  CLRF   x37
0B526:  CLRF   x38
0B528:  CLRF   x39
0B52A:  CLRF   x3A
0B52C:  CLRF   x3B
0B52E:  CLRF   x3C
0B530:  CLRF   x3D
0B532:  CLRF   x3E
0B534:  MOVLW  03
0B536:  MOVWF  x3F
0B538:  CLRF   x40
0B53A:  CLRF   x41
0B53C:  CLRF   x42
0B53E:  CLRF   x43
0B540:  CLRF   x44
0B542:  CLRF   x45
0B544:  CLRF   x46
0B546:  CLRF   x47
0B548:  CLRF   x48
0B54A:  CLRF   x49
0B54C:  CLRF   x51
0B54E:  CLRF   x52
0B550:  CLRF   x53
0B552:  CLRF   x54
0B554:  CLRF   x55
0B556:  CLRF   x56
0B558:  CLRF   x57
0B55A:  CLRF   x58
0B55C:  CLRF   x59
0B55E:  CLRF   x5A
0B560:  CLRF   x5B
0B562:  CLRF   x5C
0B564:  CLRF   x5D
0B566:  CLRF   x5E
0B568:  CLRF   x5F
0B56A:  CLRF   x60
0B56C:  CLRF   x61
0B56E:  CLRF   x62
0B570:  CLRF   x63
0B572:  CLRF   x64
0B574:  CLRF   x65
0B576:  CLRF   x66
0B578:  CLRF   x67
0B57A:  CLRF   x68
0B57C:  CLRF   x69
0B57E:  CLRF   x6A
0B580:  CLRF   x6B
0B582:  CLRF   x6C
0B584:  CLRF   x6D
0B586:  CLRF   x6E
0B588:  CLRF   x6F
0B58A:  CLRF   x70
0B58C:  CLRF   x71
0B58E:  CLRF   x72
0B590:  CLRF   x73
0B592:  CLRF   x74
0B594:  CLRF   x75
0B596:  CLRF   x76
0B598:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0B59A:  MOVLW  64
0B59C:  MOVLB  A
0B59E:  MOVWF  x6E
0B5A0:  MOVLB  0
0B5A2:  CALL   1B3E
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0B5A6:  MOVLW  E0
0B5A8:  MOVWF  FF6
0B5AA:  MOVLW  19
0B5AC:  MOVWF  FF7
0B5AE:  MOVLW  00
0B5B0:  MOVWF  FF8
0B5B2:  CALL   1BBE
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0B5B6:  MOVLW  26
0B5B8:  MOVWF  FF6
0B5BA:  MOVLW  1A
0B5BC:  MOVWF  FF7
0B5BE:  MOVLW  00
0B5C0:  MOVWF  FF8
0B5C2:  CALL   1BBE
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0B5C6:  MOVLW  54
0B5C8:  MOVWF  FF6
0B5CA:  MOVLW  1A
0B5CC:  MOVWF  FF7
0B5CE:  MOVLW  00
0B5D0:  MOVWF  FF8
0B5D2:  MOVLW  10
0B5D4:  MOVLB  9
0B5D6:  MOVWF  xC2
0B5D8:  MOVLB  0
0B5DA:  CALL   1BEE
0B5DE:  MOVLW  7A
0B5E0:  MOVWF  FF6
0B5E2:  MOVLW  1A
0B5E4:  MOVWF  FF7
0B5E6:  MOVLW  00
0B5E8:  MOVWF  FF8
0B5EA:  CALL   1BBE
0B5EE:  MOVLW  20
0B5F0:  MOVLB  A
0B5F2:  MOVWF  xAD
0B5F4:  MOVLB  0
0B5F6:  CALL   1B6C
0B5FA:  MOVLW  84
0B5FC:  MOVWF  FF6
0B5FE:  MOVLW  1A
0B600:  MOVWF  FF7
0B602:  MOVLW  00
0B604:  MOVWF  FF8
0B606:  CALL   1BBE
0B60A:  MOVLW  69
0B60C:  MOVWF  FF6
0B60E:  MOVLW  1A
0B610:  MOVWF  FF7
0B612:  MOVLW  00
0B614:  MOVWF  FF8
0B616:  MOVLW  0F
0B618:  MOVLB  9
0B61A:  MOVWF  xC2
0B61C:  MOVLB  0
0B61E:  CALL   1BEE
....................    
....................    io_init();
0B622:  GOTO   1C24
....................    setup_uart_to_boss();
0B626:  GOTO   1C72
....................    setup_timer();
0B62A:  GOTO   1C9C
....................    ad7490_init();
0B62E:  GOTO   1EB2
....................    mcp4901_init();
0B632:  GOTO   2190
....................    misf_init();
0B636:  CALL   2FDC
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0B63A:  MOVLB  1
0B63C:  CLRF   xE0
0B63E:  CLRF   xE1
0B640:  MOVLB  0
0B642:  CALL   3862
.................... 
....................    int1 is_finished = FALSE;
0B646:  MOVLB  1
0B648:  BCF    x77.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0B64A:  MOVLW  8E
0B64C:  MOVWF  FF6
0B64E:  MOVLW  1A
0B650:  MOVWF  FF7
0B652:  MOVLW  00
0B654:  MOVWF  FF8
0B656:  MOVLB  0
0B658:  CALL   1BBE
....................    
....................    output_low(EN_NPWR);
0B65C:  MOVLW  5E
0B65E:  MOVWF  F94
0B660:  BCF    F8B.7
....................    // output_high(EN_NPWR); // Enable power to CIGS
....................    // output_high(CONNECT_CIGS2);
....................    fprintf(PC,"waiting for BOSS PIC command");
0B662:  MOVLW  B4
0B664:  MOVWF  FF6
0B666:  MOVLW  1A
0B668:  MOVWF  FF7
0B66A:  MOVLW  00
0B66C:  MOVWF  FF8
0B66E:  CALL   1BBE
....................    
....................    //Start loop
....................    while(!is_finished)
0B672:  MOVLB  1
0B674:  BTFSS  x77.0
0B676:  BRA    B67E
0B678:  MOVLB  0
0B67A:  GOTO   B74C
0B67E:  MOVLB  0
....................    {
....................       // unsigned int16 cigs1_amp = ad7490_read(ADC_CIGS2_AMP);
....................       // unsigned int16 cigs1_curr = ad7490_read(ADC_CIGS2_CURR);
....................       // unsigned int16 cigs1_volt = ad7490_read(ADC_CIGS2_VOLT);
....................       
.................... //!      fprintf(PC, "CIGS1 Amp: %04LX, Current: %04LX, Voltage: %04LX\r\n", cigs1_amp, cigs1_curr, cigs1_volt);
....................       
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0B680:  MOVF   46,F
0B682:  BTFSC  FD8.2
0B684:  GOTO   B708
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0B688:  MOVLB  1
0B68A:  CLRF   x8B
0B68C:  MOVLW  26
0B68E:  MOVWF  x8A
0B690:  MOVFF  46,18C
0B694:  MOVLB  0
0B696:  GOTO   3D0C
0B69A:  MOVFF  02,03
0B69E:  MOVF   01,W
0B6A0:  MOVWF  FE1
0B6A2:  MOVFF  03,FE2
0B6A6:  MOVLW  01
0B6A8:  MOVWF  FEA
0B6AA:  MOVLW  78
0B6AC:  MOVWF  FE9
0B6AE:  MOVLW  0C
0B6B0:  MOVWF  01
0B6B2:  MOVFF  FE6,FEE
0B6B6:  DECFSZ 01,F
0B6B8:  GOTO   B6B2
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0B6BC:  MOVLB  1
0B6BE:  CLRF   x85
0B6C0:  MOVLW  26
0B6C2:  MOVWF  x84
0B6C4:  CLRF   x87
0B6C6:  MOVLW  46
0B6C8:  MOVWF  x86
0B6CA:  MOVLB  0
0B6CC:  GOTO   3F08
....................          
....................          if(recieve_cmd.is_exist)
0B6D0:  MOVLB  1
0B6D2:  BTFSC  x7A.0
0B6D4:  BRA    B6DC
0B6D6:  MOVLB  0
0B6D8:  GOTO   B6F8
0B6DC:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0B6DE:  MOVLW  01
0B6E0:  MOVLB  1
0B6E2:  MOVWF  x85
0B6E4:  MOVLW  78
0B6E6:  MOVWF  x84
0B6E8:  MOVLB  0
0B6EA:  GOTO   B1AC
0B6EE:  MOVLB  1
0B6F0:  BCF    x77.1
0B6F2:  BTFSC  01.0
0B6F4:  BSF    x77.1
0B6F6:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0B6F8:  MOVLW  D2
0B6FA:  MOVWF  FF6
0B6FC:  MOVLW  1A
0B6FE:  MOVWF  FF7
0B700:  MOVLW  00
0B702:  MOVWF  FF8
0B704:  CALL   1BBE
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0B708:  MOVLB  1
0B70A:  BTFSC  x77.0
0B70C:  BRA    B714
0B70E:  MOVLB  0
0B710:  GOTO   B71A
0B714:  MOVLB  0
....................          break;
0B716:  GOTO   B74C
....................          
....................       delay_ms(400);
0B71A:  MOVLW  02
0B71C:  MOVLB  1
0B71E:  MOVWF  x84
0B720:  MOVLB  0
0B722:  MOVLW  C8
0B724:  MOVLB  A
0B726:  MOVWF  x6E
0B728:  MOVLB  0
0B72A:  CALL   1B3E
0B72E:  MOVLB  1
0B730:  DECFSZ x84,F
0B732:  BRA    B738
0B734:  BRA    B73C
0B736:  MOVLB  0
0B738:  MOVLB  0
0B73A:  BRA    B722
....................       fprintf(PC, ".");
0B73C:  MOVLW  2E
0B73E:  MOVLB  A
0B740:  MOVWF  xAD
0B742:  MOVLB  0
0B744:  CALL   1B6C
0B748:  GOTO   B672
....................       // mcp4901_2_write(100);
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0B74C:  MOVLW  F2
0B74E:  MOVWF  FF6
0B750:  MOVLW  1A
0B752:  MOVWF  FF7
0B754:  MOVLW  00
0B756:  MOVWF  FF8
0B758:  CALL   1BBE
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0B75C:  MOVLW  2E
0B75E:  MOVLB  A
0B760:  MOVWF  xAD
0B762:  MOVLB  0
0B764:  CALL   1B6C
....................       delay_ms(1000);
0B768:  MOVLW  04
0B76A:  MOVLB  1
0B76C:  MOVWF  x84
0B76E:  MOVLB  0
0B770:  MOVLW  FA
0B772:  MOVLB  A
0B774:  MOVWF  x6E
0B776:  MOVLB  0
0B778:  CALL   1B3E
0B77C:  MOVLB  1
0B77E:  DECFSZ x84,F
0B780:  BRA    B786
0B782:  BRA    B78A
0B784:  MOVLB  0
0B786:  MOVLB  0
0B788:  BRA    B770
0B78A:  MOVLB  0
0B78C:  GOTO   B75C
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0B790:  MOVLW  32
0B792:  MOVWF  FF6
0B794:  MOVLW  1B
0B796:  MOVWF  FF7
0B798:  MOVLW  00
0B79A:  MOVWF  FF8
0B79C:  CALL   1BBE
....................    
.................... }
.................... // Enf of files
0B7A0:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
