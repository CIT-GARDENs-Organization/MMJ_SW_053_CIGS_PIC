CCS PCH C Compiler, Version 5.104, 57077               20-8-25 19:29

               Filename:   build\mmj_cigs_main.lst

               ROM used:   47204 bytes (36%)
                           Largest free fragment is 65520
               RAM used:   389 (11%) at main() level
                           2751 (77%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   B2F0
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "cigs/system/mmj_cigs_main.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 45,6E
0028C:  DATA 71,75
0028E:  DATA 65,75
00290:  DATA 65,20
00292:  DATA 46,6C
00294:  DATA 61,73
00296:  DATA 68,20
00298:  DATA 4F,70
0029A:  DATA 65,72
0029C:  DATA 61,74
0029E:  DATA 69,6F
002A0:  DATA 6E,0D
002A2:  DATA 0A,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,66
002B4:  DATA 75,6C
002B6:  DATA 6C,21
002B8:  DATA 21,21
002BA:  DATA 0D,0A
002BC:  DATA 00,00
002BE:  DATA 46,6C
002C0:  DATA 61,73
002C2:  DATA 68,20
002C4:  DATA 71,75
002C6:  DATA 65,75
002C8:  DATA 65,20
002CA:  DATA 69,73
002CC:  DATA 20,65
002CE:  DATA 6D,70
002D0:  DATA 74,79
002D2:  DATA 0D,0A
002D4:  DATA 00,00
002D6:  DATA 0D,0A
002D8:  DATA 53,74
002DA:  DATA 61,72
002DC:  DATA 74,20
002DE:  DATA 6D,61
002E0:  DATA 6B,65
002E2:  DATA 5F,72
002E4:  DATA 65,63
002E6:  DATA 65,69
002E8:  DATA 76,65
002EA:  DATA 5F,63
002EC:  DATA 6F,6D
002EE:  DATA 6D,61
002F0:  DATA 6E,64
002F2:  DATA 0D,0A
002F4:  DATA 00,00
002F6:  DATA 09,5B
002F8:  DATA 42,4F
002FA:  DATA 53,53
002FC:  DATA 5D,20
002FE:  DATA 3E,3E
00300:  DATA 3E,20
00302:  DATA 00,00
00304:  DATA 45,6E
00306:  DATA 64,20
00308:  DATA 6D,61
0030A:  DATA 6B,65
0030C:  DATA 5F,72
0030E:  DATA 65,63
00310:  DATA 69,76
00312:  DATA 65,5F
00314:  DATA 63,6F
00316:  DATA 6D,6D
00318:  DATA 61,6E
0031A:  DATA 64,0D
0031C:  DATA 0A,0D
0031E:  DATA 0A,00
00320:  DATA 73,69
00322:  DATA 67,6E
00324:  DATA 61,6C
00326:  DATA 20,65
00328:  DATA 6E,64
0032A:  DATA 20,77
0032C:  DATA 69,74
0032E:  DATA 68,20
00330:  DATA 53,46
00332:  DATA 44,0D
00334:  DATA 0A,00
00336:  DATA 64,6F
00338:  DATA 6E,27
0033A:  DATA 74,20
0033C:  DATA 66,69
0033E:  DATA 6E,64
00340:  DATA 20,53
00342:  DATA 46,44
00344:  DATA 0D,0A
00346:  DATA 00,00
00348:  DATA 09,2D
0034A:  DATA 3E,20
0034C:  DATA 49,6E
0034E:  DATA 76,61
00350:  DATA 6C,69
00352:  DATA 64,20
00354:  DATA 46,72
00356:  DATA 61,6D
00358:  DATA 65,20
0035A:  DATA 49,44
0035C:  DATA 20,72
0035E:  DATA 65,63
00360:  DATA 65,69
00362:  DATA 76,65
00364:  DATA 64,3A
00366:  DATA 20,25
00368:  DATA 58,0D
0036A:  DATA 0A,00
0036C:  DATA 09,2D
0036E:  DATA 3E,20
00370:  DATA 43,52
00372:  DATA 43,20
00374:  DATA 65,72
00376:  DATA 72,6F
00378:  DATA 72,21
0037A:  DATA 0D,0A
0037C:  DATA 00,00
0037E:  DATA 09,09
00380:  DATA 2D,3E
00382:  DATA 20,72
00384:  DATA 65,63
00386:  DATA 65,69
00388:  DATA 76,65
0038A:  DATA 64,20
0038C:  DATA 43,52
0038E:  DATA 43,3A
00390:  DATA 20,25
00392:  DATA 58,0D
00394:  DATA 0A,00
00396:  DATA 09,09
00398:  DATA 20,20
0039A:  DATA 20,63
0039C:  DATA 6F,6C
0039E:  DATA 6C,65
003A0:  DATA 63,74
003A2:  DATA 20,43
003A4:  DATA 52,43
003A6:  DATA 20,3A
003A8:  DATA 20,25
003AA:  DATA 58,0D
003AC:  DATA 0A,00
003AE:  DATA 09,2D
003B0:  DATA 3E,20
003B2:  DATA 49,6E
003B4:  DATA 76,61
003B6:  DATA 6C,69
003B8:  DATA 64,20
003BA:  DATA 64,65
003BC:  DATA 76,69
003BE:  DATA 63,65
003C0:  DATA 20,49
003C2:  DATA 44,20
003C4:  DATA 72,65
003C6:  DATA 63,65
003C8:  DATA 69,76
003CA:  DATA 65,64
003CC:  DATA 0D,0A
003CE:  DATA 00,00
003D0:  DATA 09,09
003D2:  DATA 2D,3E
003D4:  DATA 20,72
003D6:  DATA 65,63
003D8:  DATA 65,69
003DA:  DATA 76,65
003DC:  DATA 64,3A
003DE:  DATA 20,20
003E0:  DATA 20,20
003E2:  DATA 20,25
003E4:  DATA 58,0D
003E6:  DATA 0A,00
003E8:  DATA 09,09
003EA:  DATA 20,20
003EC:  DATA 20,4D
003EE:  DATA 79,20
003F0:  DATA 64,65
003F2:  DATA 76,69
003F4:  DATA 63,65
003F6:  DATA 20,49
003F8:  DATA 44,3A
003FA:  DATA 20,25
003FC:  DATA 58,0D
003FE:  DATA 0A,00
00400:  DATA 09,5B
00402:  DATA 42,4F
00404:  DATA 53,53
00406:  DATA 5D,20
00408:  DATA 3C,3C
0040A:  DATA 3C,20
0040C:  DATA 00,00
0040E:  DATA 53,74
00410:  DATA 61,72
00412:  DATA 74,20
00414:  DATA 53,4D
00416:  DATA 46,20
00418:  DATA 75,73
0041A:  DATA 69,6E
0041C:  DATA 67,20
0041E:  DATA 72,65
00420:  DATA 71,65
00422:  DATA 73,74
00424:  DATA 20,73
00426:  DATA 65,61
00428:  DATA 71,75
0042A:  DATA 65,6E
0042C:  DATA 63,65
0042E:  DATA 0D,0A
00430:  DATA 00,00
00432:  DATA 45,72
00434:  DATA 72,6F
00436:  DATA 72,21
00438:  DATA 20,52
0043A:  DATA 65,63
0043C:  DATA 65,69
0043E:  DATA 76,69
00440:  DATA 6E,67
00442:  DATA 20,63
00444:  DATA 6F,6D
00446:  DATA 6D,61
00448:  DATA 6E,64
0044A:  DATA 20,69
0044C:  DATA 6E,63
0044E:  DATA 6F,6E
00450:  DATA 73,69
00452:  DATA 73,74
00454:  DATA 65,6E
00456:  DATA 74,20
00458:  DATA 77,69
0045A:  DATA 74,68
0045C:  DATA 20,74
0045E:  DATA 68,65
00460:  DATA 20,64
00462:  DATA 65,73
00464:  DATA 69,67
00466:  DATA 6E,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 61,6C
0047C:  DATA 6C,6F
0047E:  DATA 77,65
00480:  DATA 64,0D
00482:  DATA 0A,00
00484:  DATA 53,4D
00486:  DATA 46,20
00488:  DATA 75,73
0048A:  DATA 65,20
0048C:  DATA 72,65
0048E:  DATA 71,75
00490:  DATA 65,73
00492:  DATA 74,20
00494:  DATA 64,65
00496:  DATA 6E,79
00498:  DATA 65,64
0049A:  DATA 0D,0A
0049C:  DATA 00,00
0049E:  DATA 52,65
004A0:  DATA 74,72
004A2:  DATA 79,20
004A4:  DATA 72,65
004A6:  DATA 71,75
004A8:  DATA 65,73
004AA:  DATA 74,20
004AC:  DATA 74,6F
004AE:  DATA 20,42
004B0:  DATA 4F,53
004B2:  DATA 53,20
004B4:  DATA 50,49
004B6:  DATA 43,0D
004B8:  DATA 0A,00
004BA:  DATA 45,72
004BC:  DATA 72,6F
004BE:  DATA 72,21
004C0:  DATA 20,52
004C2:  DATA 65,63
004C4:  DATA 65,69
004C6:  DATA 76,69
004C8:  DATA 6E,67
004CA:  DATA 20,63
004CC:  DATA 6F,6D
004CE:  DATA 6D,61
004D0:  DATA 6E,64
004D2:  DATA 20,69
004D4:  DATA 6E,63
004D6:  DATA 6F,6E
004D8:  DATA 73,69
004DA:  DATA 73,74
004DC:  DATA 65,6E
004DE:  DATA 74,20
004E0:  DATA 77,69
004E2:  DATA 74,68
004E4:  DATA 20,74
004E6:  DATA 68,65
004E8:  DATA 20,64
004EA:  DATA 65,73
004EC:  DATA 69,67
004EE:  DATA 6E,0D
004F0:  DATA 0A,00
004F2:  DATA 45,6E
004F4:  DATA 64,20
004F6:  DATA 53,4D
004F8:  DATA 46,20
004FA:  DATA 75,73
004FC:  DATA 69,6E
004FE:  DATA 67,20
00500:  DATA 72,65
00502:  DATA 71,65
00504:  DATA 73,74
00506:  DATA 20,73
00508:  DATA 65,61
0050A:  DATA 71,75
0050C:  DATA 65,6E
0050E:  DATA 63,65
00510:  DATA 0D,0A
00512:  DATA 00,00
00514:  DATA 49,4F
00516:  DATA 20,49
00518:  DATA 6E,69
0051A:  DATA 74,69
0051C:  DATA 61,6C
0051E:  DATA 69,7A
00520:  DATA 65,0D
00522:  DATA 0A,00
00524:  DATA 09,43
00526:  DATA 6F,6D
00528:  DATA 70,6C
0052A:  DATA 65,74
0052C:  DATA 65,0D
0052E:  DATA 0A,00
00530:  DATA 53,74
00532:  DATA 61,72
00534:  DATA 74,20
00536:  DATA 54,45
00538:  DATA 53,54
0053A:  DATA 20,53
0053C:  DATA 57,45
0053E:  DATA 45,50
00540:  DATA 0D,0A
00542:  DATA 00,00
00544:  DATA 73,74
00546:  DATA 65,70
00548:  DATA 2C,20
0054A:  DATA 76,6F
0054C:  DATA 6C,74
0054E:  DATA 61,67
00550:  DATA 65,2C
00552:  DATA 20,63
00554:  DATA 75,72
00556:  DATA 72,65
00558:  DATA 6E,74
0055A:  DATA 0D,0A
0055C:  DATA 00,00
0055E:  DATA 53,74
00560:  DATA 61,72
00562:  DATA 74,20
00564:  DATA 41,44
00566:  DATA 43,20
00568:  DATA 54,45
0056A:  DATA 53,54
0056C:  DATA 0D,0A
0056E:  DATA 00,00
00570:  DATA 41,44
00572:  DATA 43,20
00574:  DATA 56,6F
00576:  DATA 6C,74
00578:  DATA 61,67
0057A:  DATA 65,3A
0057C:  DATA 20,25
0057E:  DATA 30,34
00580:  DATA 4C,58
00582:  DATA 0D,0A
00584:  DATA 00,00
00586:  DATA 41,44
00588:  DATA 43,20
0058A:  DATA 43,75
0058C:  DATA 72,72
0058E:  DATA 65,6E
00590:  DATA 74,3A
00592:  DATA 20,25
00594:  DATA 30,34
00596:  DATA 4C,58
00598:  DATA 0D,0A
0059A:  DATA 00,00
0059C:  DATA 41,44
0059E:  DATA 43,20
005A0:  DATA 43,49
005A2:  DATA 47,53
005A4:  DATA 31,20
005A6:  DATA 41,6D
005A8:  DATA 70,3A
005AA:  DATA 20,25
005AC:  DATA 30,34
005AE:  DATA 4C,58
005B0:  DATA 0D,0A
005B2:  DATA 00,00
005B4:  DATA 41,44
005B6:  DATA 43,20
005B8:  DATA 43,49
005BA:  DATA 47,53
005BC:  DATA 31,20
005BE:  DATA 56,52
005C0:  DATA 45,46
005C2:  DATA 3A,20
005C4:  DATA 25,30
005C6:  DATA 34,4C
005C8:  DATA 58,0D
005CA:  DATA 0A,00
005CC:  DATA 53,74
005CE:  DATA 61,72
005D0:  DATA 74,20
005D2:  DATA 53,57
005D4:  DATA 45,45
005D6:  DATA 50,20
005D8:  DATA 32,70
005DA:  DATA 6F,72
005DC:  DATA 74,73
005DE:  DATA 0D,0A
005E0:  DATA 00,00
005E2:  DATA 09,53
005E4:  DATA 77,65
005E6:  DATA 65,70
005E8:  DATA 20,73
005EA:  DATA 74,65
005EC:  DATA 70,20
005EE:  DATA 3A,20
005F0:  DATA 25,75
005F2:  DATA 0D,0A
005F4:  DATA 00,00
005F6:  DATA 45,4E
005F8:  DATA 44,20
005FA:  DATA 53,57
005FC:  DATA 45,45
005FE:  DATA 50,20
00600:  DATA 32,70
00602:  DATA 6F,72
00604:  DATA 74,0D
00606:  DATA 0A,00
00608:  DATA 53,74
0060A:  DATA 61,72
0060C:  DATA 74,20
0060E:  DATA 43,49
00610:  DATA 47,53
00612:  DATA 20,64
00614:  DATA 61,74
00616:  DATA 61,20
00618:  DATA 63,6F
0061A:  DATA 6E,76
0061C:  DATA 65,72
0061E:  DATA 73,69
00620:  DATA 6F,6E
00622:  DATA 0D,0A
00624:  DATA 00,00
00626:  DATA 53,74
00628:  DATA 61,72
0062A:  DATA 74,20
0062C:  DATA 53,57
0062E:  DATA 45,45
00630:  DATA 50,20
00632:  DATA 77,69
00634:  DATA 74,68
00636:  DATA 20,74
00638:  DATA 68,72
0063A:  DATA 65,73
0063C:  DATA 68,6F
0063E:  DATA 6C,64
00640:  DATA 0D,0A
00642:  DATA 00,00
00644:  DATA 43,49
00646:  DATA 47,53
00648:  DATA 32,20
0064A:  DATA 64,61
0064C:  DATA 74,61
0064E:  DATA 3A,20
00650:  DATA 25,30
00652:  DATA 34,4C
00654:  DATA 44,2C
00656:  DATA 20,25
00658:  DATA 30,34
0065A:  DATA 4C,44
0065C:  DATA 0D,0A
0065E:  DATA 00,00
00660:  DATA 4D,61
00662:  DATA 78,69
00664:  DATA 6D,75
00666:  DATA 6D,20
00668:  DATA 73,74
0066A:  DATA 65,70
0066C:  DATA 20,63
0066E:  DATA 6F,75
00670:  DATA 6E,74
00672:  DATA 20,72
00674:  DATA 65,61
00676:  DATA 63,68
00678:  DATA 65,64
0067A:  DATA 3A,20
0067C:  DATA 25,6C
0067E:  DATA 64,0D
00680:  DATA 0A,00
00682:  DATA 43,49
00684:  DATA 47,53
00686:  DATA 31,20
00688:  DATA 63,75
0068A:  DATA 72,72
0068C:  DATA 65,6E
0068E:  DATA 74,20
00690:  DATA 6C,69
00692:  DATA 6D,69
00694:  DATA 74,20
00696:  DATA 72,65
00698:  DATA 61,63
0069A:  DATA 68,65
0069C:  DATA 64,3A
0069E:  DATA 00,00
006A0:  DATA 43,49
006A2:  DATA 47,53
006A4:  DATA 31,20
006A6:  DATA 63,75
006A8:  DATA 72,72
006AA:  DATA 65,6E
006AC:  DATA 74,20
006AE:  DATA 62,65
006B0:  DATA 6C,6F
006B2:  DATA 77,20
006B4:  DATA 74,68
006B6:  DATA 72,65
006B8:  DATA 73,68
006BA:  DATA 6F,6C
006BC:  DATA 64,00
006BE:  DATA 43,49
006C0:  DATA 47,53
006C2:  DATA 32,20
006C4:  DATA 63,75
006C6:  DATA 72,72
006C8:  DATA 65,6E
006CA:  DATA 74,20
006CC:  DATA 6C,69
006CE:  DATA 6D,69
006D0:  DATA 74,20
006D2:  DATA 72,65
006D4:  DATA 61,63
006D6:  DATA 68,65
006D8:  DATA 64,3A
006DA:  DATA 20,00
006DC:  DATA 43,49
006DE:  DATA 47,53
006E0:  DATA 32,20
006E2:  DATA 63,75
006E4:  DATA 72,72
006E6:  DATA 65,6E
006E8:  DATA 74,20
006EA:  DATA 62,65
006EC:  DATA 6C,6F
006EE:  DATA 77,20
006F0:  DATA 74,68
006F2:  DATA 72,65
006F4:  DATA 73,68
006F6:  DATA 6F,6C
006F8:  DATA 64,3A
006FA:  DATA 00,00
006FC:  DATA 45,6E
006FE:  DATA 64,20
00700:  DATA 53,57
00702:  DATA 45,45
00704:  DATA 50,20
00706:  DATA 77,69
00708:  DATA 74,68
0070A:  DATA 20,74
0070C:  DATA 68,72
0070E:  DATA 65,73
00710:  DATA 68,6F
00712:  DATA 6C,64
00714:  DATA 0D,0A
00716:  DATA 00,00
00718:  DATA 45,6E
0071A:  DATA 64,20
0071C:  DATA 43,49
0071E:  DATA 47,53
00720:  DATA 20,64
00722:  DATA 61,74
00724:  DATA 61,20
00726:  DATA 63,6F
00728:  DATA 6E,76
0072A:  DATA 65,72
0072C:  DATA 73,69
0072E:  DATA 6F,6E
00730:  DATA 0D,0A
00732:  DATA 00,00
00734:  DATA 09,5B
00736:  DATA 50,49
00738:  DATA 43,4C
0073A:  DATA 4F,47
0073C:  DATA 5D,20
0073E:  DATA 3A,20
00740:  DATA 00,00
00742:  DATA 43,52
00744:  DATA 43,20
00746:  DATA 76,65
00748:  DATA 72,69
0074A:  DATA 66,69
0074C:  DATA 63,61
0074E:  DATA 74,69
00750:  DATA 6F,6E
00752:  DATA 20,70
00754:  DATA 61,73
00756:  DATA 73,65
00758:  DATA 64,20
0075A:  DATA 6F,6E
0075C:  DATA 20,61
0075E:  DATA 74,74
00760:  DATA 65,6D
00762:  DATA 70,74
00764:  DATA 20,25
00766:  DATA 75,0D
00768:  DATA 0A,00
0076A:  DATA 43,52
0076C:  DATA 43,20
0076E:  DATA 76,65
00770:  DATA 72,69
00772:  DATA 66,69
00774:  DATA 63,61
00776:  DATA 74,69
00778:  DATA 6F,6E
0077A:  DATA 20,70
0077C:  DATA 61,73
0077E:  DATA 73,65
00780:  DATA 64,20
00782:  DATA 6F,6E
00784:  DATA 20,61
00786:  DATA 74,74
00788:  DATA 65,6D
0078A:  DATA 70,74
0078C:  DATA 20,25
0078E:  DATA 64,0D
00790:  DATA 0A,00
00792:  DATA 45,72
00794:  DATA 72,6F
00796:  DATA 72,3A
00798:  DATA 20,43
0079A:  DATA 52,43
0079C:  DATA 20,76
0079E:  DATA 65,72
007A0:  DATA 69,66
007A2:  DATA 69,63
007A4:  DATA 61,74
007A6:  DATA 69,6F
007A8:  DATA 6E,20
007AA:  DATA 66,61
007AC:  DATA 69,6C
007AE:  DATA 65,64
007B0:  DATA 20,61
007B2:  DATA 66,74
007B4:  DATA 65,72
007B6:  DATA 20,25
007B8:  DATA 64,20
007BA:  DATA 61,74
007BC:  DATA 74,65
007BE:  DATA 6D,70
007C0:  DATA 74,73
007C2:  DATA 0D,0A
007C4:  DATA 00,00
007C6:  DATA 0D,0A
007C8:  DATA 5F,5F
007CA:  DATA 5F,5F
007CC:  DATA 5F,5F
007CE:  DATA 5F,5F
007D0:  DATA 5F,5F
007D2:  DATA 5F,5F
007D4:  DATA 5F,5F
007D6:  DATA 5F,5F
007D8:  DATA 5F,5F
007DA:  DATA 5F,5F
007DC:  DATA 0D,0A
007DE:  DATA 00,00
007E0:  DATA 5F,5F
007E2:  DATA 5F,5F
007E4:  DATA 5F,53
007E6:  DATA 74,61
007E8:  DATA 72,74
007EA:  DATA 20,63
007EC:  DATA 6F,70
007EE:  DATA 79,5F
007F0:  DATA 64,61
007F2:  DATA 74,61
007F4:  DATA 5F,5F
007F6:  DATA 5F,5F
007F8:  DATA 0D,0A
007FA:  DATA 00,00
007FC:  DATA 45,72
007FE:  DATA 72,6F
00800:  DATA 72,3A
00802:  DATA 20,4D
00804:  DATA 49,53
00806:  DATA 20,46
00808:  DATA 4D,20
0080A:  DATA 69,73
0080C:  DATA 20,6E
0080E:  DATA 6F,74
00810:  DATA 20,63
00812:  DATA 6F,6E
00814:  DATA 6E,65
00816:  DATA 63,74
00818:  DATA 65,64
0081A:  DATA 0D,0A
0081C:  DATA 00,00
0081E:  DATA 45,72
00820:  DATA 72,6F
00822:  DATA 72,3A
00824:  DATA 20,53
00826:  DATA 4D,46
00828:  DATA 20,69
0082A:  DATA 73,20
0082C:  DATA 6E,6F
0082E:  DATA 74,20
00830:  DATA 63,6F
00832:  DATA 6E,6E
00834:  DATA 65,63
00836:  DATA 74,65
00838:  DATA 64,0D
0083A:  DATA 0A,00
0083C:  DATA 53,69
0083E:  DATA 7A,65
00840:  DATA 20,61
00842:  DATA 72,65
00844:  DATA 61,20
00846:  DATA 72,65
00848:  DATA 61,64
0084A:  DATA 0D,0A
0084C:  DATA 00,00
0084E:  DATA 73,6D
00850:  DATA 66,5F
00852:  DATA 75,73
00854:  DATA 65,64
00856:  DATA 5F,73
00858:  DATA 69,7A
0085A:  DATA 65,20
0085C:  DATA 3D,20
0085E:  DATA 25,6C
00860:  DATA 64,20
00862:  DATA 28,73
00864:  DATA 72,63
00866:  DATA 20,30
00868:  DATA 78,25
0086A:  DATA 30,38
0086C:  DATA 4C,58
0086E:  DATA 29,0D
00870:  DATA 0A,00
00872:  DATA 73,6D
00874:  DATA 66,5F
00876:  DATA 6C,6F
00878:  DATA 6F,70
0087A:  DATA 20,63
0087C:  DATA 6F,75
0087E:  DATA 6E,74
00880:  DATA 3D,20
00882:  DATA 25,64
00884:  DATA 20,20
00886:  DATA 28,73
00888:  DATA 72,63
0088A:  DATA 20,30
0088C:  DATA 78,25
0088E:  DATA 30,38
00890:  DATA 4C,58
00892:  DATA 29,0D
00894:  DATA 0A,00
00896:  DATA 6D,69
00898:  DATA 73,66
0089A:  DATA 5F,77
0089C:  DATA 72,69
0089E:  DATA 74,65
008A0:  DATA 5F,73
008A2:  DATA 6F,75
008A4:  DATA 72,63
008A6:  DATA 65,20
008A8:  DATA 3D,20
008AA:  DATA 30,78
008AC:  DATA 25,30
008AE:  DATA 38,4C
008B0:  DATA 58,0D
008B2:  DATA 0A,00
008B4:  DATA 6D,69
008B6:  DATA 73,66
008B8:  DATA 5F,77
008BA:  DATA 72,69
008BC:  DATA 74,65
008BE:  DATA 5F,73
008C0:  DATA 69,7A
008C2:  DATA 65,20
008C4:  DATA 3D,20
008C6:  DATA 30,78
008C8:  DATA 25,30
008CA:  DATA 38,4C
008CC:  DATA 58,0D
008CE:  DATA 0A,00
008D0:  DATA 57,72
008D2:  DATA 61,70
008D4:  DATA 20,74
008D6:  DATA 72,69
008D8:  DATA 67,67
008DA:  DATA 65,72
008DC:  DATA 65,64
008DE:  DATA 3A,20
008E0:  DATA 52,65
008E2:  DATA 73,65
008E4:  DATA 74,74
008E6:  DATA 69,6E
008E8:  DATA 67,20
008EA:  DATA 64,61
008EC:  DATA 74,61
008EE:  DATA 5F,77
008F0:  DATA 72,69
008F2:  DATA 74,65
008F4:  DATA 5F,61
008F6:  DATA 64,64
008F8:  DATA 72,20
008FA:  DATA 74,6F
008FC:  DATA 20,73
008FE:  DATA 74,61
00900:  DATA 72,74
00902:  DATA 0D,0A
00904:  DATA 00,00
00906:  DATA 75,73
00908:  DATA 65,64
0090A:  DATA 5F,73
0090C:  DATA 69,7A
0090E:  DATA 65,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 64,0D
00916:  DATA 0A,00
00918:  DATA 6C,6F
0091A:  DATA 6F,70
0091C:  DATA 5F,63
0091E:  DATA 6F,75
00920:  DATA 6E,74
00922:  DATA 20,3D
00924:  DATA 20,25
00926:  DATA 75,0D
00928:  DATA 0A,0D
0092A:  DATA 0A,00
0092C:  DATA 0D,0A
0092E:  DATA 5F,5F
00930:  DATA 5F,45
00932:  DATA 6E,64
00934:  DATA 20,63
00936:  DATA 6F,70
00938:  DATA 79,5F
0093A:  DATA 64,61
0093C:  DATA 74,61
0093E:  DATA 5F,5F
00940:  DATA 5F,5F
00942:  DATA 0D,0A
00944:  DATA 00,00
00946:  DATA 5F,5F
00948:  DATA 5F,5F
0094A:  DATA 5F,5F
0094C:  DATA 5F,5F
0094E:  DATA 5F,5F
00950:  DATA 5F,5F
00952:  DATA 5F,5F
00954:  DATA 5F,5F
00956:  DATA 5F,5F
00958:  DATA 5F,5F
0095A:  DATA 0D,0A
0095C:  DATA 0D,0A
0095E:  DATA 00,00
00960:  DATA 0D,0A
00962:  DATA 5F,5F
00964:  DATA 5F,5F
00966:  DATA 5F,5F
00968:  DATA 5F,5F
0096A:  DATA 5F,5F
0096C:  DATA 5F,5F
0096E:  DATA 5F,5F
00970:  DATA 5F,5F
00972:  DATA 5F,5F
00974:  DATA 5F,5F
00976:  DATA 0D,0A
00978:  DATA 00,00
0097A:  DATA 5F,5F
0097C:  DATA 5F,53
0097E:  DATA 74,61
00980:  DATA 72,74
00982:  DATA 20,53
00984:  DATA 4D,46
00986:  DATA 20,52
00988:  DATA 65,61
0098A:  DATA 64,5F
0098C:  DATA 5F,5F
0098E:  DATA 5F,0D
00990:  DATA 0A,00
00992:  DATA 49,6E
00994:  DATA 20,53
00996:  DATA 4D,46
00998:  DATA 20,52
0099A:  DATA 65,61
0099C:  DATA 64,20
0099E:  DATA 73,6F
009A0:  DATA 75,72
009A2:  DATA 63,65
009A4:  DATA 20,64
009A6:  DATA 61,74
009A8:  DATA 61,20
009AA:  DATA 61,64
009AC:  DATA 64,72
009AE:  DATA 65,73
009B0:  DATA 73,3A
009B2:  DATA 20,25
009B4:  DATA 4C,58
009B6:  DATA 0D,0A
009B8:  DATA 00,00
009BA:  DATA 49,6E
009BC:  DATA 20,53
009BE:  DATA 4D,46
009C0:  DATA 20,52
009C2:  DATA 65,61
009C4:  DATA 64,20
009C6:  DATA 64,61
009C8:  DATA 74,61
009CA:  DATA 20,73
009CC:  DATA 69,7A
009CE:  DATA 65,20
009D0:  DATA 20,20
009D2:  DATA 20,20
009D4:  DATA 20,20
009D6:  DATA 20,20
009D8:  DATA 20,3A
009DA:  DATA 20,25
009DC:  DATA 6C,75
009DE:  DATA 20,28
009E0:  DATA 30,78
009E2:  DATA 25,6C
009E4:  DATA 78,29
009E6:  DATA 0D,0A
009E8:  DATA 0D,0A
009EA:  DATA 00,00
009EC:  DATA 45,72
009EE:  DATA 72,6F
009F0:  DATA 72,3A
009F2:  DATA 20,53
009F4:  DATA 4D,46
009F6:  DATA 20,69
009F8:  DATA 73,20
009FA:  DATA 6E,6F
009FC:  DATA 74,20
009FE:  DATA 63,6F
00A00:  DATA 6E,6E
00A02:  DATA 65,63
00A04:  DATA 74,65
00A06:  DATA 64,0D
00A08:  DATA 0A,00
00A0A:  DATA 52,45
00A0C:  DATA 41,44
00A0E:  DATA 20,44
00A10:  DATA 41,54
00A12:  DATA 41,20
00A14:  DATA 46,52
00A16:  DATA 4F,4D
00A18:  DATA 20,53
00A1A:  DATA 4D,46
00A1C:  DATA 2E,2E
00A1E:  DATA 2E,0D
00A20:  DATA 0A,00
00A22:  DATA 0D,0A
00A24:  DATA 5F,5F
00A26:  DATA 5F,45
00A28:  DATA 6E,64
00A2A:  DATA 20,53
00A2C:  DATA 4D,46
00A2E:  DATA 20,52
00A30:  DATA 65,61
00A32:  DATA 64,5F
00A34:  DATA 5F,5F
00A36:  DATA 5F,0D
00A38:  DATA 0A,00
00A3A:  DATA 5F,5F
00A3C:  DATA 5F,5F
00A3E:  DATA 5F,5F
00A40:  DATA 5F,5F
00A42:  DATA 5F,5F
00A44:  DATA 5F,5F
00A46:  DATA 5F,5F
00A48:  DATA 5F,5F
00A4A:  DATA 5F,5F
00A4C:  DATA 5F,5F
00A4E:  DATA 0D,0A
00A50:  DATA 0D,0A
00A52:  DATA 00,00
00A54:  DATA 0D,0A
00A56:  DATA 5F,5F
00A58:  DATA 5F,5F
00A5A:  DATA 5F,5F
00A5C:  DATA 5F,5F
00A5E:  DATA 5F,5F
00A60:  DATA 5F,5F
00A62:  DATA 5F,5F
00A64:  DATA 5F,5F
00A66:  DATA 5F,5F
00A68:  DATA 5F,5F
00A6A:  DATA 0D,0A
00A6C:  DATA 00,00
00A6E:  DATA 5F,5F
00A70:  DATA 5F,53
00A72:  DATA 74,61
00A74:  DATA 72,74
00A76:  DATA 20,73
00A78:  DATA 6D,66
00A7A:  DATA 5F,65
00A7C:  DATA 72,61
00A7E:  DATA 73,65
00A80:  DATA 5F,5F
00A82:  DATA 5F,5F
00A84:  DATA 0D,0A
00A86:  DATA 00,00
00A88:  DATA 49,6E
00A8A:  DATA 20,53
00A8C:  DATA 4D,46
00A8E:  DATA 20,45
00A90:  DATA 72,61
00A92:  DATA 73,65
00A94:  DATA 20,73
00A96:  DATA 6F,75
00A98:  DATA 72,63
00A9A:  DATA 65,20
00A9C:  DATA 64,61
00A9E:  DATA 74,61
00AA0:  DATA 20,61
00AA2:  DATA 64,64
00AA4:  DATA 72,65
00AA6:  DATA 73,73
00AA8:  DATA 3A,20
00AAA:  DATA 25,4C
00AAC:  DATA 58,0D
00AAE:  DATA 0A,00
00AB0:  DATA 49,6E
00AB2:  DATA 20,53
00AB4:  DATA 4D,46
00AB6:  DATA 20,45
00AB8:  DATA 72,61
00ABA:  DATA 73,65
00ABC:  DATA 20,64
00ABE:  DATA 61,74
00AC0:  DATA 61,20
00AC2:  DATA 73,69
00AC4:  DATA 7A,65
00AC6:  DATA 20,20
00AC8:  DATA 20,20
00ACA:  DATA 20,20
00ACC:  DATA 20,20
00ACE:  DATA 20,20
00AD0:  DATA 3A,20
00AD2:  DATA 25,6C
00AD4:  DATA 75,20
00AD6:  DATA 28,30
00AD8:  DATA 78,25
00ADA:  DATA 6C,78
00ADC:  DATA 29,0D
00ADE:  DATA 0A,0D
00AE0:  DATA 0A,00
00AE2:  DATA 45,72
00AE4:  DATA 72,6F
00AE6:  DATA 72,3A
00AE8:  DATA 20,53
00AEA:  DATA 4D,46
00AEC:  DATA 20,69
00AEE:  DATA 73,20
00AF0:  DATA 6E,6F
00AF2:  DATA 74,20
00AF4:  DATA 63,6F
00AF6:  DATA 6E,6E
00AF8:  DATA 65,63
00AFA:  DATA 74,65
00AFC:  DATA 64,0D
00AFE:  DATA 0A,00
00B00:  DATA 45,72
00B02:  DATA 72,6F
00B04:  DATA 72,3A
00B06:  DATA 20,45
00B08:  DATA 72,61
00B0A:  DATA 73,65
00B0C:  DATA 20,73
00B0E:  DATA 6F,75
00B10:  DATA 72,63
00B12:  DATA 65,20
00B14:  DATA 61,64
00B16:  DATA 64,72
00B18:  DATA 65,73
00B1A:  DATA 73,20
00B1C:  DATA 30,78
00B1E:  DATA 25,4C
00B20:  DATA 58,20
00B22:  DATA 69,73
00B24:  DATA 20,6F
00B26:  DATA 75,74
00B28:  DATA 73,69
00B2A:  DATA 64,65
00B2C:  DATA 20,6D
00B2E:  DATA 69,73
00B30:  DATA 73,69
00B32:  DATA 6F,6E
00B34:  DATA 20,72
00B36:  DATA 61,6E
00B38:  DATA 67,65
00B3A:  DATA 20,5B
00B3C:  DATA 30,78
00B3E:  DATA 25,4C
00B40:  DATA 58,20
00B42:  DATA 2D,20
00B44:  DATA 30,78
00B46:  DATA 25,4C
00B48:  DATA 58,5D
00B4A:  DATA 0D,0A
00B4C:  DATA 00,00
00B4E:  DATA 45,72
00B50:  DATA 72,6F
00B52:  DATA 72,3A
00B54:  DATA 20,45
00B56:  DATA 72,61
00B58:  DATA 73,65
00B5A:  DATA 20,6F
00B5C:  DATA 70,65
00B5E:  DATA 72,61
00B60:  DATA 74,69
00B62:  DATA 6F,6E
00B64:  DATA 20,77
00B66:  DATA 6F,75
00B68:  DATA 6C,64
00B6A:  DATA 20,65
00B6C:  DATA 78,63
00B6E:  DATA 65,65
00B70:  DATA 64,20
00B72:  DATA 6D,69
00B74:  DATA 73,73
00B76:  DATA 69,6F
00B78:  DATA 6E,20
00B7A:  DATA 65,6E
00B7C:  DATA 64,20
00B7E:  DATA 61,64
00B80:  DATA 64,72
00B82:  DATA 65,73
00B84:  DATA 73,20
00B86:  DATA 30,78
00B88:  DATA 25,4C
00B8A:  DATA 58,0D
00B8C:  DATA 0A,00
00B8E:  DATA 4C,69
00B90:  DATA 6D,69
00B92:  DATA 74,69
00B94:  DATA 6E,67
00B96:  DATA 20,65
00B98:  DATA 72,61
00B9A:  DATA 73,65
00B9C:  DATA 20,73
00B9E:  DATA 69,7A
00BA0:  DATA 65,20
00BA2:  DATA 74,6F
00BA4:  DATA 20,73
00BA6:  DATA 74,61
00BA8:  DATA 79,20
00BAA:  DATA 77,69
00BAC:  DATA 74,68
00BAE:  DATA 69,6E
00BB0:  DATA 20,6D
00BB2:  DATA 69,73
00BB4:  DATA 73,69
00BB6:  DATA 6F,6E
00BB8:  DATA 20,62
00BBA:  DATA 6F,75
00BBC:  DATA 6E,64
00BBE:  DATA 73,0D
00BC0:  DATA 0A,00
00BC2:  DATA 45,72
00BC4:  DATA 61,73
00BC6:  DATA 65,20
00BC8:  DATA 6F,70
00BCA:  DATA 65,72
00BCC:  DATA 61,74
00BCE:  DATA 69,6F
00BD0:  DATA 6E,20
00BD2:  DATA 76,61
00BD4:  DATA 6C,69
00BD6:  DATA 64,61
00BD8:  DATA 74,65
00BDA:  DATA 64,20
00BDC:  DATA 77,69
00BDE:  DATA 74,68
00BE0:  DATA 69,6E
00BE2:  DATA 20,6D
00BE4:  DATA 69,73
00BE6:  DATA 73,69
00BE8:  DATA 6F,6E
00BEA:  DATA 20,72
00BEC:  DATA 61,6E
00BEE:  DATA 67,65
00BF0:  DATA 0D,0A
00BF2:  DATA 00,00
00BF4:  DATA 0D,0A
00BF6:  DATA 5F,5F
00BF8:  DATA 5F,45
00BFA:  DATA 6E,64
00BFC:  DATA 20,73
00BFE:  DATA 6D,66
00C00:  DATA 5F,65
00C02:  DATA 72,61
00C04:  DATA 73,65
00C06:  DATA 5F,5F
00C08:  DATA 5F,5F
00C0A:  DATA 0D,0A
00C0C:  DATA 00,00
00C0E:  DATA 5F,5F
00C10:  DATA 5F,5F
00C12:  DATA 5F,5F
00C14:  DATA 5F,5F
00C16:  DATA 5F,5F
00C18:  DATA 5F,5F
00C1A:  DATA 5F,5F
00C1C:  DATA 5F,5F
00C1E:  DATA 5F,5F
00C20:  DATA 5F,5F
00C22:  DATA 0D,0A
00C24:  DATA 0D,0A
00C26:  DATA 00,00
00C28:  DATA 45,72
00C2A:  DATA 72,6F
00C2C:  DATA 72,3A
00C2E:  DATA 20,55
00C30:  DATA 6E,6B
00C32:  DATA 6E,6F
00C34:  DATA 77,6E
00C36:  DATA 20,6D
00C38:  DATA 69,73
00C3A:  DATA 73,69
00C3C:  DATA 6F,6E
00C3E:  DATA 5F,69
00C40:  DATA 64,3A
00C42:  DATA 20,25
00C44:  DATA 30,32
00C46:  DATA 58,0D
00C48:  DATA 0A,00
00C4A:  DATA 55,70
00C4C:  DATA 64,61
00C4E:  DATA 74,65
00C50:  DATA 64,20
00C52:  DATA 70,61
00C54:  DATA 72,74
00C56:  DATA 69,74
00C58:  DATA 69,6F
00C5A:  DATA 6E,20
00C5C:  DATA 66,6F
00C5E:  DATA 72,20
00C60:  DATA 6D,69
00C62:  DATA 73,73
00C64:  DATA 69,6F
00C66:  DATA 6E,5F
00C68:  DATA 69,64
00C6A:  DATA 20,25
00C6C:  DATA 30,32
00C6E:  DATA 58,3A
00C70:  DATA 20,75
00C72:  DATA 73,65
00C74:  DATA 64,5F
00C76:  DATA 73,69
00C78:  DATA 7A,65
00C7A:  DATA 3D,25
00C7C:  DATA 6C,64
00C7E:  DATA 2C,20
00C80:  DATA 6C,6F
00C82:  DATA 6F,70
00C84:  DATA 5F,63
00C86:  DATA 6F,75
00C88:  DATA 6E,74
00C8A:  DATA 65,72
00C8C:  DATA 3D,25
00C8E:  DATA 6C,64
00C90:  DATA 0D,0A
00C92:  DATA 00,00
00C94:  DATA 4D,49
00C96:  DATA 53,53
00C98:  DATA 49,4F
00C9A:  DATA 4E,20
00C9C:  DATA 46,4C
00C9E:  DATA 41,53
00CA0:  DATA 48,20
00CA2:  DATA 49,6E
00CA4:  DATA 69,74
00CA6:  DATA 69,61
00CA8:  DATA 6C,69
00CAA:  DATA 7A,65
00CAC:  DATA 0D,0A
00CAE:  DATA 00,00
00CB0:  DATA 09,5B
00CB2:  DATA 4D,49
00CB4:  DATA 53,20
00CB6:  DATA 46,4D
00CB8:  DATA 5D,20
00CBA:  DATA 43,6F
00CBC:  DATA 6E,6E
00CBE:  DATA 65,63
00CC0:  DATA 74,65
00CC2:  DATA 64,0D
00CC4:  DATA 0A,00
00CC6:  DATA 09,5B
00CC8:  DATA 4D,49
00CCA:  DATA 53,20
00CCC:  DATA 46,4D
00CCE:  DATA 5D,20
00CD0:  DATA 4E,6F
00CD2:  DATA 74,20
00CD4:  DATA 43,6F
00CD6:  DATA 6E,6E
00CD8:  DATA 65,63
00CDA:  DATA 74,65
00CDC:  DATA 64,0D
00CDE:  DATA 0A,00
00CE0:  DATA 09,5B
00CE2:  DATA 53,4D
00CE4:  DATA 46,5D
00CE6:  DATA 20,43
00CE8:  DATA 6F,6E
00CEA:  DATA 6E,65
00CEC:  DATA 63,74
00CEE:  DATA 65,64
00CF0:  DATA 0D,0A
00CF2:  DATA 00,00
00CF4:  DATA 09,5B
00CF6:  DATA 53,4D
00CF8:  DATA 46,5D
00CFA:  DATA 20,4E
00CFC:  DATA 6F,74
00CFE:  DATA 20,43
00D00:  DATA 6F,6E
00D02:  DATA 6E,65
00D04:  DATA 63,74
00D06:  DATA 65,64
00D08:  DATA 0D,0A
00D0A:  DATA 00,00
00D0C:  DATA 09,5B
00D0E:  DATA 4D,49
00D10:  DATA 53,20
00D12:  DATA 46,4D
00D14:  DATA 5D,20
00D16:  DATA 43,52
00D18:  DATA 43,20
00D1A:  DATA 65,72
00D1C:  DATA 72,6F
00D1E:  DATA 72,20
00D20:  DATA 2D,3E
00D22:  DATA 20,69
00D24:  DATA 6E,69
00D26:  DATA 74,69
00D28:  DATA 61,6C
00D2A:  DATA 69,7A
00D2C:  DATA 65,20
00D2E:  DATA 63,6F
00D30:  DATA 75,6E
00D32:  DATA 74,65
00D34:  DATA 72,73
00D36:  DATA 0D,0A
00D38:  DATA 00,00
00D3A:  DATA 09,7C
00D3C:  DATA 20,4D
00D3E:  DATA 49,53
00D40:  DATA 46,20
00D42:  DATA 7C,20
00D44:  DATA 50,49
00D46:  DATA 43,4C
00D48:  DATA 4F,47
00D4A:  DATA 20,20
00D4C:  DATA 20,20
00D4E:  DATA 7C,20
00D50:  DATA 55,73
00D52:  DATA 65,20
00D54:  DATA 43,6F
00D56:  DATA 75,6E
00D58:  DATA 74,65
00D5A:  DATA 72,20
00D5C:  DATA 20,20
00D5E:  DATA 20,20
00D60:  DATA 20,3A
00D62:  DATA 20,30
00D64:  DATA 78,25
00D66:  DATA 30,38
00D68:  DATA 4C,58
00D6A:  DATA 0D,0A
00D6C:  DATA 00,00
00D6E:  DATA 09,7C
00D70:  DATA 20,4D
00D72:  DATA 49,53
00D74:  DATA 46,20
00D76:  DATA 7C,20
00D78:  DATA 50,49
00D7A:  DATA 43,4C
00D7C:  DATA 4F,47
00D7E:  DATA 20,20
00D80:  DATA 20,20
00D82:  DATA 7C,20
00D84:  DATA 55,6E
00D86:  DATA 63,6F
00D88:  DATA 70,79
00D8A:  DATA 65,64
00D8C:  DATA 20,43
00D8E:  DATA 6F,75
00D90:  DATA 6E,74
00D92:  DATA 65,72
00D94:  DATA 20,3A
00D96:  DATA 20,30
00D98:  DATA 78,25
00D9A:  DATA 30,38
00D9C:  DATA 4C,58
00D9E:  DATA 0D,0A
00DA0:  DATA 00,00
00DA2:  DATA 09,7C
00DA4:  DATA 20,4D
00DA6:  DATA 49,53
00DA8:  DATA 46,20
00DAA:  DATA 7C,20
00DAC:  DATA 50,49
00DAE:  DATA 43,4C
00DB0:  DATA 4F,47
00DB2:  DATA 20,20
00DB4:  DATA 20,20
00DB6:  DATA 7C,20
00DB8:  DATA 52,65
00DBA:  DATA 73,65
00DBC:  DATA 72,76
00DBE:  DATA 65,20
00DC0:  DATA 43,6F
00DC2:  DATA 75,6E
00DC4:  DATA 74,65
00DC6:  DATA 72,31
00DC8:  DATA 20,3A
00DCA:  DATA 20,30
00DCC:  DATA 78,25
00DCE:  DATA 30,32
00DD0:  DATA 58,0D
00DD2:  DATA 0A,00
00DD4:  DATA 09,7C
00DD6:  DATA 20,4D
00DD8:  DATA 49,53
00DDA:  DATA 46,20
00DDC:  DATA 7C,20
00DDE:  DATA 50,49
00DE0:  DATA 43,4C
00DE2:  DATA 4F,47
00DE4:  DATA 20,20
00DE6:  DATA 20,20
00DE8:  DATA 7C,20
00DEA:  DATA 52,65
00DEC:  DATA 73,65
00DEE:  DATA 72,76
00DF0:  DATA 65,20
00DF2:  DATA 43,6F
00DF4:  DATA 75,6E
00DF6:  DATA 74,65
00DF8:  DATA 72,32
00DFA:  DATA 20,3A
00DFC:  DATA 20,30
00DFE:  DATA 78,25
00E00:  DATA 30,32
00E02:  DATA 58,0D
00E04:  DATA 0A,00
00E06:  DATA 09,7C
00E08:  DATA 20,4D
00E0A:  DATA 49,53
00E0C:  DATA 46,20
00E0E:  DATA 7C,20
00E10:  DATA 45,4E
00E12:  DATA 56,49
00E14:  DATA 52,4F
00E16:  DATA 20,20
00E18:  DATA 20,20
00E1A:  DATA 7C,20
00E1C:  DATA 55,73
00E1E:  DATA 65,20
00E20:  DATA 43,6F
00E22:  DATA 75,6E
00E24:  DATA 74,65
00E26:  DATA 72,20
00E28:  DATA 20,20
00E2A:  DATA 20,20
00E2C:  DATA 20,3A
00E2E:  DATA 20,30
00E30:  DATA 78,25
00E32:  DATA 30,38
00E34:  DATA 4C,58
00E36:  DATA 0D,0A
00E38:  DATA 00,00
00E3A:  DATA 09,7C
00E3C:  DATA 20,4D
00E3E:  DATA 49,53
00E40:  DATA 46,20
00E42:  DATA 7C,20
00E44:  DATA 45,4E
00E46:  DATA 56,49
00E48:  DATA 52,4F
00E4A:  DATA 20,20
00E4C:  DATA 20,20
00E4E:  DATA 7C,20
00E50:  DATA 55,6E
00E52:  DATA 63,6F
00E54:  DATA 70,79
00E56:  DATA 65,64
00E58:  DATA 20,43
00E5A:  DATA 6F,75
00E5C:  DATA 6E,74
00E5E:  DATA 65,72
00E60:  DATA 20,3A
00E62:  DATA 20,30
00E64:  DATA 78,25
00E66:  DATA 30,38
00E68:  DATA 4C,58
00E6A:  DATA 0D,0A
00E6C:  DATA 00,00
00E6E:  DATA 09,7C
00E70:  DATA 20,4D
00E72:  DATA 49,53
00E74:  DATA 46,20
00E76:  DATA 7C,20
00E78:  DATA 45,4E
00E7A:  DATA 56,49
00E7C:  DATA 52,4F
00E7E:  DATA 20,20
00E80:  DATA 20,20
00E82:  DATA 7C,20
00E84:  DATA 52,65
00E86:  DATA 73,65
00E88:  DATA 72,76
00E8A:  DATA 65,20
00E8C:  DATA 43,6F
00E8E:  DATA 75,6E
00E90:  DATA 74,65
00E92:  DATA 72,31
00E94:  DATA 20,3A
00E96:  DATA 20,30
00E98:  DATA 78,25
00E9A:  DATA 30,32
00E9C:  DATA 58,0D
00E9E:  DATA 0A,00
00EA0:  DATA 09,7C
00EA2:  DATA 20,4D
00EA4:  DATA 49,53
00EA6:  DATA 46,20
00EA8:  DATA 7C,20
00EAA:  DATA 45,4E
00EAC:  DATA 56,49
00EAE:  DATA 52,4F
00EB0:  DATA 20,20
00EB2:  DATA 20,20
00EB4:  DATA 7C,20
00EB6:  DATA 52,65
00EB8:  DATA 73,65
00EBA:  DATA 72,76
00EBC:  DATA 65,20
00EBE:  DATA 43,6F
00EC0:  DATA 75,6E
00EC2:  DATA 74,65
00EC4:  DATA 72,32
00EC6:  DATA 20,3A
00EC8:  DATA 20,30
00ECA:  DATA 78,25
00ECC:  DATA 30,32
00ECE:  DATA 58,0D
00ED0:  DATA 0A,00
00ED2:  DATA 09,7C
00ED4:  DATA 20,4D
00ED6:  DATA 49,53
00ED8:  DATA 46,20
00EDA:  DATA 7C,20
00EDC:  DATA 49,56
00EDE:  DATA 20,48
00EE0:  DATA 45,41
00EE2:  DATA 44,45
00EE4:  DATA 52,20
00EE6:  DATA 7C,20
00EE8:  DATA 55,73
00EEA:  DATA 65,20
00EEC:  DATA 43,6F
00EEE:  DATA 75,6E
00EF0:  DATA 74,65
00EF2:  DATA 72,20
00EF4:  DATA 20,20
00EF6:  DATA 20,20
00EF8:  DATA 20,3A
00EFA:  DATA 20,30
00EFC:  DATA 78,25
00EFE:  DATA 30,38
00F00:  DATA 4C,58
00F02:  DATA 0D,0A
00F04:  DATA 00,00
00F06:  DATA 09,7C
00F08:  DATA 20,4D
00F0A:  DATA 49,53
00F0C:  DATA 46,20
00F0E:  DATA 7C,20
00F10:  DATA 49,56
00F12:  DATA 20,48
00F14:  DATA 45,41
00F16:  DATA 44,45
00F18:  DATA 52,20
00F1A:  DATA 7C,20
00F1C:  DATA 55,6E
00F1E:  DATA 63,6F
00F20:  DATA 70,79
00F22:  DATA 65,64
00F24:  DATA 20,43
00F26:  DATA 6F,75
00F28:  DATA 6E,74
00F2A:  DATA 65,72
00F2C:  DATA 20,3A
00F2E:  DATA 20,30
00F30:  DATA 78,25
00F32:  DATA 30,38
00F34:  DATA 4C,58
00F36:  DATA 0D,0A
00F38:  DATA 00,00
00F3A:  DATA 09,7C
00F3C:  DATA 20,4D
00F3E:  DATA 49,53
00F40:  DATA 46,20
00F42:  DATA 7C,20
00F44:  DATA 49,56
00F46:  DATA 20,48
00F48:  DATA 45,41
00F4A:  DATA 44,45
00F4C:  DATA 52,20
00F4E:  DATA 7C,20
00F50:  DATA 52,65
00F52:  DATA 73,65
00F54:  DATA 72,76
00F56:  DATA 65,20
00F58:  DATA 43,6F
00F5A:  DATA 75,6E
00F5C:  DATA 74,65
00F5E:  DATA 72,31
00F60:  DATA 20,3A
00F62:  DATA 20,30
00F64:  DATA 78,25
00F66:  DATA 30,32
00F68:  DATA 58,0D
00F6A:  DATA 0A,00
00F6C:  DATA 09,7C
00F6E:  DATA 20,4D
00F70:  DATA 49,53
00F72:  DATA 46,20
00F74:  DATA 7C,20
00F76:  DATA 49,56
00F78:  DATA 20,48
00F7A:  DATA 45,41
00F7C:  DATA 44,45
00F7E:  DATA 52,20
00F80:  DATA 7C,20
00F82:  DATA 52,65
00F84:  DATA 73,65
00F86:  DATA 72,76
00F88:  DATA 65,20
00F8A:  DATA 43,6F
00F8C:  DATA 75,6E
00F8E:  DATA 74,65
00F90:  DATA 72,32
00F92:  DATA 20,3A
00F94:  DATA 20,30
00F96:  DATA 78,25
00F98:  DATA 30,32
00F9A:  DATA 58,0D
00F9C:  DATA 0A,00
00F9E:  DATA 09,7C
00FA0:  DATA 20,4D
00FA2:  DATA 49,53
00FA4:  DATA 46,20
00FA6:  DATA 7C,20
00FA8:  DATA 49,56
00FAA:  DATA 20,44
00FAC:  DATA 41,54
00FAE:  DATA 41,20
00FB0:  DATA 20,20
00FB2:  DATA 7C,20
00FB4:  DATA 55,73
00FB6:  DATA 65,20
00FB8:  DATA 43,6F
00FBA:  DATA 75,6E
00FBC:  DATA 74,65
00FBE:  DATA 72,20
00FC0:  DATA 20,20
00FC2:  DATA 20,20
00FC4:  DATA 20,3A
00FC6:  DATA 20,30
00FC8:  DATA 78,25
00FCA:  DATA 30,38
00FCC:  DATA 4C,58
00FCE:  DATA 0D,0A
00FD0:  DATA 00,00
00FD2:  DATA 09,7C
00FD4:  DATA 20,4D
00FD6:  DATA 49,53
00FD8:  DATA 46,20
00FDA:  DATA 7C,20
00FDC:  DATA 49,56
00FDE:  DATA 20,44
00FE0:  DATA 41,54
00FE2:  DATA 41,20
00FE4:  DATA 20,20
00FE6:  DATA 7C,20
00FE8:  DATA 55,6E
00FEA:  DATA 63,6F
00FEC:  DATA 70,79
00FEE:  DATA 65,64
00FF0:  DATA 20,43
00FF2:  DATA 6F,75
00FF4:  DATA 6E,74
00FF6:  DATA 65,72
00FF8:  DATA 20,3A
00FFA:  DATA 20,30
00FFC:  DATA 78,25
00FFE:  DATA 30,38
01000:  DATA 4C,58
01002:  DATA 0D,0A
01004:  DATA 00,00
01006:  DATA 09,7C
01008:  DATA 20,4D
0100A:  DATA 49,53
0100C:  DATA 46,20
0100E:  DATA 7C,20
01010:  DATA 49,56
01012:  DATA 20,44
01014:  DATA 41,54
01016:  DATA 41,20
01018:  DATA 20,20
0101A:  DATA 7C,20
0101C:  DATA 52,65
0101E:  DATA 73,65
01020:  DATA 72,76
01022:  DATA 65,20
01024:  DATA 43,6F
01026:  DATA 75,6E
01028:  DATA 74,65
0102A:  DATA 72,31
0102C:  DATA 20,3A
0102E:  DATA 20,30
01030:  DATA 78,25
01032:  DATA 30,32
01034:  DATA 58,0D
01036:  DATA 0A,00
01038:  DATA 09,7C
0103A:  DATA 20,4D
0103C:  DATA 49,53
0103E:  DATA 46,20
01040:  DATA 7C,20
01042:  DATA 49,56
01044:  DATA 20,44
01046:  DATA 41,54
01048:  DATA 41,20
0104A:  DATA 20,20
0104C:  DATA 7C,20
0104E:  DATA 52,65
01050:  DATA 73,65
01052:  DATA 72,76
01054:  DATA 65,20
01056:  DATA 43,6F
01058:  DATA 75,6E
0105A:  DATA 74,65
0105C:  DATA 72,32
0105E:  DATA 20,3A
01060:  DATA 20,30
01062:  DATA 78,25
01064:  DATA 30,32
01066:  DATA 58,0D
01068:  DATA 0A,00
0106A:  DATA 09,43
0106C:  DATA 6F,6D
0106E:  DATA 70,6C
01070:  DATA 65,74
01072:  DATA 65,0D
01074:  DATA 0A,00
01076:  DATA 43,52
01078:  DATA 43,20
0107A:  DATA 76,65
0107C:  DATA 72,69
0107E:  DATA 66,69
01080:  DATA 63,61
01082:  DATA 74,69
01084:  DATA 6F,6E
01086:  DATA 20,70
01088:  DATA 61,73
0108A:  DATA 73,65
0108C:  DATA 64,20
0108E:  DATA 6F,6E
01090:  DATA 20,61
01092:  DATA 74,74
01094:  DATA 65,6D
01096:  DATA 70,74
01098:  DATA 20,25
0109A:  DATA 64,0D
0109C:  DATA 0A,00
0109E:  DATA 45,72
010A0:  DATA 72,6F
010A2:  DATA 72,3A
010A4:  DATA 20,43
010A6:  DATA 52,43
010A8:  DATA 20,76
010AA:  DATA 65,72
010AC:  DATA 69,66
010AE:  DATA 69,63
010B0:  DATA 61,74
010B2:  DATA 69,6F
010B4:  DATA 6E,20
010B6:  DATA 66,61
010B8:  DATA 69,6C
010BA:  DATA 65,64
010BC:  DATA 20,61
010BE:  DATA 66,74
010C0:  DATA 65,72
010C2:  DATA 20,25
010C4:  DATA 64,20
010C6:  DATA 61,74
010C8:  DATA 74,65
010CA:  DATA 6D,70
010CC:  DATA 74,73
010CE:  DATA 0D,0A
010D0:  DATA 00,00
010D2:  DATA 0D,0A
010D4:  DATA 5F,5F
010D6:  DATA 5F,5F
010D8:  DATA 5F,5F
010DA:  DATA 5F,5F
010DC:  DATA 5F,5F
010DE:  DATA 5F,5F
010E0:  DATA 5F,5F
010E2:  DATA 5F,5F
010E4:  DATA 5F,5F
010E6:  DATA 5F,5F
010E8:  DATA 5F,5F
010EA:  DATA 5F,5F
010EC:  DATA 5F,5F
010EE:  DATA 5F,5F
010F0:  DATA 5F,5F
010F2:  DATA 0D,0A
010F4:  DATA 5F,5F
010F6:  DATA 5F,5F
010F8:  DATA 5F,53
010FA:  DATA 74,61
010FC:  DATA 72,74
010FE:  DATA 20,65
01100:  DATA 78,65
01102:  DATA 63,75
01104:  DATA 74,65
01106:  DATA 5F,6D
01108:  DATA 69,73
0110A:  DATA 73,69
0110C:  DATA 6F,6E
0110E:  DATA 5F,5F
01110:  DATA 5F,5F
01112:  DATA 5F,0D
01114:  DATA 0A,0D
01116:  DATA 0A,00
01118:  DATA 43,6F
0111A:  DATA 6D,6D
0111C:  DATA 61,6E
0111E:  DATA 64,20
01120:  DATA 49,44
01122:  DATA 3A,20
01124:  DATA 25,58
01126:  DATA 0D,0A
01128:  DATA 0D,0A
0112A:  DATA 00,00
0112C:  DATA 09,09
0112E:  DATA 2D,3E
01130:  DATA 20,49
01132:  DATA 6E,76
01134:  DATA 61,6C
01136:  DATA 69,64
01138:  DATA 20,43
0113A:  DATA 4D,44
0113C:  DATA 20,49
0113E:  DATA 44,21
01140:  DATA 0D,0A
01142:  DATA 00,00
01144:  DATA 0D,0A
01146:  DATA 5F,5F
01148:  DATA 5F,5F
0114A:  DATA 5F,5F
0114C:  DATA 45,6E
0114E:  DATA 64,20
01150:  DATA 65,78
01152:  DATA 65,63
01154:  DATA 75,74
01156:  DATA 65,5F
01158:  DATA 6D,69
0115A:  DATA 73,73
0115C:  DATA 69,6F
0115E:  DATA 6E,5F
01160:  DATA 5F,5F
01162:  DATA 5F,5F
01164:  DATA 5F,0D
01166:  DATA 0A,5F
01168:  DATA 5F,5F
0116A:  DATA 5F,5F
0116C:  DATA 5F,5F
0116E:  DATA 5F,5F
01170:  DATA 5F,5F
01172:  DATA 5F,5F
01174:  DATA 5F,5F
01176:  DATA 5F,5F
01178:  DATA 5F,5F
0117A:  DATA 5F,5F
0117C:  DATA 5F,5F
0117E:  DATA 5F,5F
01180:  DATA 5F,5F
01182:  DATA 5F,5F
01184:  DATA 5F,5F
01186:  DATA 0D,0A
01188:  DATA 00,00
0118A:  DATA 53,74
0118C:  DATA 61,72
0118E:  DATA 74,20
01190:  DATA 65,78
01192:  DATA 65,63
01194:  DATA 75,74
01196:  DATA 65,5F
01198:  DATA 63,6F
0119A:  DATA 6D,6D
0119C:  DATA 61,6E
0119E:  DATA 64,0D
011A0:  DATA 0A,00
011A2:  DATA 09,2D
011A4:  DATA 3E,20
011A6:  DATA 55,70
011A8:  DATA 6C,69
011AA:  DATA 6E,6B
011AC:  DATA 20,63
011AE:  DATA 6F,6D
011B0:  DATA 6D,61
011B2:  DATA 6E,64
011B4:  DATA 0D,0A
011B6:  DATA 00,00
011B8:  DATA 09,20
011BA:  DATA 20,20
011BC:  DATA 54,72
011BE:  DATA 61,6E
011C0:  DATA 73,6D
011C2:  DATA 69,74
011C4:  DATA 20,41
011C6:  DATA 63,6B
011C8:  DATA 6E,6F
011CA:  DATA 6C,65
011CC:  DATA 67,64
011CE:  DATA 65,0D
011D0:  DATA 0A,00
011D2:  DATA 09,2D
011D4:  DATA 3E,20
011D6:  DATA 53,74
011D8:  DATA 61,74
011DA:  DATA 75,73
011DC:  DATA 20,63
011DE:  DATA 68,65
011E0:  DATA 63,6B
011E2:  DATA 0D,0A
011E4:  DATA 00,00
011E6:  DATA 09,20
011E8:  DATA 20,20
011EA:  DATA 54,72
011EC:  DATA 61,6E
011EE:  DATA 73,6D
011F0:  DATA 69,74
011F2:  DATA 20,4D
011F4:  DATA 49,53
011F6:  DATA 20,4D
011F8:  DATA 43,55
011FA:  DATA 20,53
011FC:  DATA 74,61
011FE:  DATA 74,75
01200:  DATA 73,0D
01202:  DATA 0A,00
01204:  DATA 66,69
01206:  DATA 6E,69
01208:  DATA 73,68
0120A:  DATA 65,64
0120C:  DATA 20,69
0120E:  DATA 6E,20
01210:  DATA 73,74
01212:  DATA 61,74
01214:  DATA 75,73
01216:  DATA 5F,63
01218:  DATA 68,65
0121A:  DATA 63,6B
0121C:  DATA 0D,0A
0121E:  DATA 00,00
01220:  DATA 09,2D
01222:  DATA 3E,20
01224:  DATA 53,4D
01226:  DATA 46,20
01228:  DATA 61,76
0122A:  DATA 61,69
0122C:  DATA 6C,61
0122E:  DATA 62,6C
01230:  DATA 65,20
01232:  DATA 63,68
01234:  DATA 65,63
01236:  DATA 6B,0D
01238:  DATA 0A,00
0123A:  DATA 09,20
0123C:  DATA 20,20
0123E:  DATA 54,72
01240:  DATA 61,6E
01242:  DATA 73,6D
01244:  DATA 69,74
01246:  DATA 20,41
01248:  DATA 63,6B
0124A:  DATA 6E,6F
0124C:  DATA 77,6C
0124E:  DATA 65,64
01250:  DATA 67,65
01252:  DATA 6D,65
01254:  DATA 6E,74
01256:  DATA 0D,0A
01258:  DATA 00,00
0125A:  DATA 09,09
0125C:  DATA 2D,3E
0125E:  DATA 20,64
01260:  DATA 65,6E
01262:  DATA 69,65
01264:  DATA 64,0D
01266:  DATA 0A,00
01268:  DATA 09,09
0126A:  DATA 2D,3E
0126C:  DATA 20,61
0126E:  DATA 6C,6C
01270:  DATA 6F,77
01272:  DATA 65,64
01274:  DATA 0D,0A
01276:  DATA 00,00
01278:  DATA 09,09
0127A:  DATA 2D,3E
0127C:  DATA 20,64
0127E:  DATA 65,71
01280:  DATA 75,65
01282:  DATA 75,65
01284:  DATA 20,4E
01286:  DATA 55,4C
01288:  DATA 4C,20
0128A:  DATA 28,62
0128C:  DATA 72,65
0128E:  DATA 61,6B
01290:  DATA 29,0D
01292:  DATA 0A,00
01294:  DATA 09,09
01296:  DATA 2D,3E
01298:  DATA 20,44
0129A:  DATA 65,71
0129C:  DATA 75,65
0129E:  DATA 75,65
012A0:  DATA 64,3A
012A2:  DATA 20,66
012A4:  DATA 75,6E
012A6:  DATA 63,3D
012A8:  DATA 25,75
012AA:  DATA 20,6D
012AC:  DATA 69,73
012AE:  DATA 73,69
012B0:  DATA 6F,6E
012B2:  DATA 3D,25
012B4:  DATA 75,20
012B6:  DATA 73,69
012B8:  DATA 7A,65
012BA:  DATA 3D,25
012BC:  DATA 6C,64
012BE:  DATA 20,61
012C0:  DATA 64,64
012C2:  DATA 72,3D
012C4:  DATA 25,6C
012C6:  DATA 64,0D
012C8:  DATA 0A,00
012CA:  DATA 09,09
012CC:  DATA 20,20
012CE:  DATA 20,55
012D0:  DATA 6E,6B
012D2:  DATA 6E,6F
012D4:  DATA 77,6E
012D6:  DATA 20,66
012D8:  DATA 75,6E
012DA:  DATA 63,5F
012DC:  DATA 74,79
012DE:  DATA 70,65
012E0:  DATA 3D,25
012E2:  DATA 75,0D
012E4:  DATA 0A,00
012E6:  DATA 09,09
012E8:  DATA 2D,3E
012EA:  DATA 20,43
012EC:  DATA 6F,6D
012EE:  DATA 70,6C
012F0:  DATA 65,74
012F2:  DATA 65,64
012F4:  DATA 20,25
012F6:  DATA 75,20
012F8:  DATA 6F,70
012FA:  DATA 65,72
012FC:  DATA 61,74
012FE:  DATA 69,6F
01300:  DATA 6E,73
01302:  DATA 0D,0A
01304:  DATA 00,00
01306:  DATA 53,74
01308:  DATA 61,72
0130A:  DATA 74,20
0130C:  DATA 4D,4F
0130E:  DATA 44,45
01310:  DATA 20,44
01312:  DATA 55,4D
01314:  DATA 4D,59
01316:  DATA 0D,0A
01318:  DATA 00,00
0131A:  DATA 09,4D
0131C:  DATA 4F,44
0131E:  DATA 45,20
01320:  DATA 20,20
01322:  DATA 20,20
01324:  DATA 3A,20
01326:  DATA 25,30
01328:  DATA 32,58
0132A:  DATA 0D,0A
0132C:  DATA 00,00
0132E:  DATA 09,50
01330:  DATA 61,72
01332:  DATA 61,6D
01334:  DATA 31,20
01336:  DATA 20,20
01338:  DATA 3A,20
0133A:  DATA 30,78
0133C:  DATA 25,30
0133E:  DATA 38,4C
01340:  DATA 58,0D
01342:  DATA 0A,00
01344:  DATA 09,50
01346:  DATA 61,72
01348:  DATA 61,6D
0134A:  DATA 32,20
0134C:  DATA 20,20
0134E:  DATA 3A,20
01350:  DATA 30,78
01352:  DATA 25,30
01354:  DATA 34,4C
01356:  DATA 58,0D
01358:  DATA 0A,00
0135A:  DATA 45,6E
0135C:  DATA 64,20
0135E:  DATA 4D,4F
01360:  DATA 44,45
01362:  DATA 20,44
01364:  DATA 55,4D
01366:  DATA 4D,59
01368:  DATA 0D,0A
0136A:  DATA 00,00
0136C:  DATA 53,74
0136E:  DATA 61,72
01370:  DATA 74,20
01372:  DATA 4D,4F
01374:  DATA 44,45
01376:  DATA 20,54
01378:  DATA 45,53
0137A:  DATA 54,20
0137C:  DATA 49,56
0137E:  DATA 0D,0A
01380:  DATA 00,00
01382:  DATA 09,53
01384:  DATA 77,65
01386:  DATA 65,70
01388:  DATA 20,73
0138A:  DATA 74,65
0138C:  DATA 70,20
0138E:  DATA 3A,20
01390:  DATA 25,75
01392:  DATA 0D,0A
01394:  DATA 00,00
01396:  DATA 45,6E
01398:  DATA 64,20
0139A:  DATA 4D,4F
0139C:  DATA 44,45
0139E:  DATA 20,54
013A0:  DATA 45,53
013A2:  DATA 54,20
013A4:  DATA 49,56
013A6:  DATA 0D,0A
013A8:  DATA 00,00
013AA:  DATA 53,74
013AC:  DATA 61,72
013AE:  DATA 74,20
013B0:  DATA 4D,4F
013B2:  DATA 44,45
013B4:  DATA 20,4D
013B6:  DATA 45,41
013B8:  DATA 53,20
013BA:  DATA 49,56
013BC:  DATA 0D,0A
013BE:  DATA 00,00
013C0:  DATA 09,49
013C2:  DATA 44,3A
013C4:  DATA 20,25
013C6:  DATA 30,32
013C8:  DATA 58,0D
013CA:  DATA 0A,00
013CC:  DATA 09,53
013CE:  DATA 6C,65
013D0:  DATA 65,70
013D2:  DATA 20,54
013D4:  DATA 69,6D
013D6:  DATA 65,3A
013D8:  DATA 20,25
013DA:  DATA 30,34
013DC:  DATA 4C,58
013DE:  DATA 20,6D
013E0:  DATA 73,0D
013E2:  DATA 0A,00
013E4:  DATA 09,43
013E6:  DATA 75,72
013E8:  DATA 72,65
013EA:  DATA 6E,74
013EC:  DATA 20,54
013EE:  DATA 68,72
013F0:  DATA 65,73
013F2:  DATA 68,6F
013F4:  DATA 6C,64
013F6:  DATA 3A,20
013F8:  DATA 25,30
013FA:  DATA 34,4C
013FC:  DATA 58,20
013FE:  DATA 6D,41
01400:  DATA 0D,0A
01402:  DATA 00,00
01404:  DATA 09,50
01406:  DATA 44,20
01408:  DATA 54,68
0140A:  DATA 72,65
0140C:  DATA 73,68
0140E:  DATA 6F,6C
01410:  DATA 64,3A
01412:  DATA 20,25
01414:  DATA 30,34
01416:  DATA 4C,58
01418:  DATA 20,6D
0141A:  DATA 41,0D
0141C:  DATA 0A,00
0141E:  DATA 09,43
01420:  DATA 75,72
01422:  DATA 72,65
01424:  DATA 6E,74
01426:  DATA 20,4C
01428:  DATA 69,6D
0142A:  DATA 69,74
0142C:  DATA 3A,20
0142E:  DATA 25,30
01430:  DATA 34,4C
01432:  DATA 58,20
01434:  DATA 6D,41
01436:  DATA 0D,0A
01438:  DATA 00,00
0143A:  DATA 09,4D
0143C:  DATA 65,61
0143E:  DATA 73,75
01440:  DATA 72,65
01442:  DATA 6D,65
01444:  DATA 6E,74
01446:  DATA 20,54
01448:  DATA 69,6D
0144A:  DATA 65,3A
0144C:  DATA 20,25
0144E:  DATA 30,34
01450:  DATA 4C,58
01452:  DATA 20,73
01454:  DATA 0D,0A
01456:  DATA 00,00
01458:  DATA 09,49
0145A:  DATA 73,20
0145C:  DATA 46,69
0145E:  DATA 6E,69
01460:  DATA 73,68
01462:  DATA 65,64
01464:  DATA 3A,20
01466:  DATA 25,75
01468:  DATA 0D,0A
0146A:  DATA 00,00
0146C:  DATA 45,6E
0146E:  DATA 71,75
01470:  DATA 65,75
01472:  DATA 65,20
01474:  DATA 46,6C
01476:  DATA 61,73
01478:  DATA 68,20
0147A:  DATA 4F,70
0147C:  DATA 65,72
0147E:  DATA 61,74
01480:  DATA 69,6F
01482:  DATA 6E,0D
01484:  DATA 0A,00
01486:  DATA 4D,69
01488:  DATA 73,73
0148A:  DATA 69,6F
0148C:  DATA 6E,20
0148E:  DATA 49,44
01490:  DATA 3A,20
01492:  DATA 20,20
01494:  DATA 25,30
01496:  DATA 32,58
01498:  DATA 0D,0A
0149A:  DATA 00,00
0149C:  DATA 46,75
0149E:  DATA 6E,63
014A0:  DATA 74,69
014A2:  DATA 6F,6E
014A4:  DATA 20,54
014A6:  DATA 79,70
014A8:  DATA 65,3A
014AA:  DATA 25,30
014AC:  DATA 32,58
014AE:  DATA 0D,0A
014B0:  DATA 00,00
014B2:  DATA 57,72
014B4:  DATA 69,74
014B6:  DATA 65,20
014B8:  DATA 4D,6F
014BA:  DATA 64,65
014BC:  DATA 3A,20
014BE:  DATA 20,20
014C0:  DATA 25,30
014C2:  DATA 32,58
014C4:  DATA 0D,0A
014C6:  DATA 00,00
014C8:  DATA 53,6F
014CA:  DATA 75,72
014CC:  DATA 63,65
014CE:  DATA 20,54
014D0:  DATA 79,70
014D2:  DATA 65,3A
014D4:  DATA 20,20
014D6:  DATA 25,30
014D8:  DATA 32,58
014DA:  DATA 0D,0A
014DC:  DATA 00,00
014DE:  DATA 53,74
014E0:  DATA 61,72
014E2:  DATA 74,20
014E4:  DATA 41,64
014E6:  DATA 64,72
014E8:  DATA 65,73
014EA:  DATA 73,3A
014EC:  DATA 25,30
014EE:  DATA 34,58
014F0:  DATA 0D,0A
014F2:  DATA 00,00
014F4:  DATA 53,69
014F6:  DATA 7A,65
014F8:  DATA 3A,20
014FA:  DATA 20,20
014FC:  DATA 20,20
014FE:  DATA 20,20
01500:  DATA 20,20
01502:  DATA 25,30
01504:  DATA 34,58
01506:  DATA 0D,0A
01508:  DATA 00,00
0150A:  DATA 45,6E
0150C:  DATA 64,20
0150E:  DATA 4D,4F
01510:  DATA 44,45
01512:  DATA 20,4D
01514:  DATA 45,41
01516:  DATA 53,20
01518:  DATA 49,56
0151A:  DATA 20,6D
0151C:  DATA 69,73
0151E:  DATA 73,69
01520:  DATA 6F,6E
01522:  DATA 0D,0A
01524:  DATA 00,00
01526:  DATA 53,74
01528:  DATA 61,72
0152A:  DATA 74,20
0152C:  DATA 46,6C
0152E:  DATA 61,73
01530:  DATA 68,20
01532:  DATA 45,72
01534:  DATA 61,73
01536:  DATA 65,20
01538:  DATA 41,6C
0153A:  DATA 6C,0D
0153C:  DATA 0A,00
0153E:  DATA 45,6E
01540:  DATA 64,20
01542:  DATA 46,6C
01544:  DATA 61,73
01546:  DATA 68,20
01548:  DATA 45,72
0154A:  DATA 61,73
0154C:  DATA 65,20
0154E:  DATA 41,6C
01550:  DATA 6C,0D
01552:  DATA 0A,00
01554:  DATA 53,74
01556:  DATA 61,72
01558:  DATA 74,20
0155A:  DATA 46,6C
0155C:  DATA 61,73
0155E:  DATA 68,20
01560:  DATA 45,72
01562:  DATA 61,73
01564:  DATA 65,20
01566:  DATA 31,20
01568:  DATA 53,65
0156A:  DATA 63,74
0156C:  DATA 6F,72
0156E:  DATA 0D,0A
01570:  DATA 00,00
01572:  DATA 09,53
01574:  DATA 65,63
01576:  DATA 74,6F
01578:  DATA 72,20
0157A:  DATA 41,64
0157C:  DATA 64,72
0157E:  DATA 65,73
01580:  DATA 73,3A
01582:  DATA 20,30
01584:  DATA 78,25
01586:  DATA 30,38
01588:  DATA 4C,58
0158A:  DATA 0D,0A
0158C:  DATA 00,00
0158E:  DATA 45,6E
01590:  DATA 64,20
01592:  DATA 46,6C
01594:  DATA 61,73
01596:  DATA 68,20
01598:  DATA 45,72
0159A:  DATA 61,73
0159C:  DATA 65,20
0159E:  DATA 31,20
015A0:  DATA 53,65
015A2:  DATA 63,74
015A4:  DATA 6F,72
015A6:  DATA 0D,0A
015A8:  DATA 00,00
015AA:  DATA 53,74
015AC:  DATA 61,72
015AE:  DATA 74,20
015B0:  DATA 46,6C
015B2:  DATA 61,73
015B4:  DATA 68,20
015B6:  DATA 43,6F
015B8:  DATA 70,79
015BA:  DATA 20,31
015BC:  DATA 20,53
015BE:  DATA 65,63
015C0:  DATA 74,6F
015C2:  DATA 72,0D
015C4:  DATA 0A,00
015C6:  DATA 09,53
015C8:  DATA 75,62
015CA:  DATA 73,65
015CC:  DATA 63,74
015CE:  DATA 6F,72
015D0:  DATA 20,41
015D2:  DATA 64,64
015D4:  DATA 72,65
015D6:  DATA 73,73
015D8:  DATA 3A,20
015DA:  DATA 30,78
015DC:  DATA 25,30
015DE:  DATA 38,4C
015E0:  DATA 58,0D
015E2:  DATA 0A,00
015E4:  DATA 45,6E
015E6:  DATA 64,20
015E8:  DATA 46,6C
015EA:  DATA 61,73
015EC:  DATA 68,20
015EE:  DATA 43,6F
015F0:  DATA 70,79
015F2:  DATA 20,31
015F4:  DATA 20,53
015F6:  DATA 65,63
015F8:  DATA 74,6F
015FA:  DATA 72,0D
015FC:  DATA 0A,00
015FE:  DATA 53,74
01600:  DATA 61,72
01602:  DATA 74,20
01604:  DATA 46,6C
01606:  DATA 61,73
01608:  DATA 68,20
0160A:  DATA 45,72
0160C:  DATA 61,73
0160E:  DATA 65,20
01610:  DATA 36,34
01612:  DATA 6B,42
01614:  DATA 79,74
01616:  DATA 65,20
01618:  DATA 53,75
0161A:  DATA 62,73
0161C:  DATA 65,63
0161E:  DATA 74,6F
01620:  DATA 72,0D
01622:  DATA 0A,00
01624:  DATA 09,53
01626:  DATA 75,62
01628:  DATA 73,65
0162A:  DATA 63,74
0162C:  DATA 6F,72
0162E:  DATA 20,41
01630:  DATA 64,64
01632:  DATA 72,65
01634:  DATA 73,73
01636:  DATA 3A,20
01638:  DATA 30,78
0163A:  DATA 25,30
0163C:  DATA 38,4C
0163E:  DATA 58,0D
01640:  DATA 0A,00
01642:  DATA 45,6E
01644:  DATA 64,20
01646:  DATA 46,6C
01648:  DATA 61,73
0164A:  DATA 68,20
0164C:  DATA 45,72
0164E:  DATA 61,73
01650:  DATA 65,20
01652:  DATA 36,34
01654:  DATA 6B,42
01656:  DATA 79,74
01658:  DATA 65,20
0165A:  DATA 53,75
0165C:  DATA 62,73
0165E:  DATA 65,63
01660:  DATA 74,6F
01662:  DATA 72,0D
01664:  DATA 0A,00
01666:  DATA 53,74
01668:  DATA 61,72
0166A:  DATA 74,20
0166C:  DATA 46,6C
0166E:  DATA 61,73
01670:  DATA 68,20
01672:  DATA 57,72
01674:  DATA 69,74
01676:  DATA 65,20
01678:  DATA 44,65
0167A:  DATA 6D,6F
0167C:  DATA 0D,0A
0167E:  DATA 00,00
01680:  DATA 09,4D
01682:  DATA 4F,44
01684:  DATA 45,20
01686:  DATA 20,20
01688:  DATA 20,20
0168A:  DATA 3A,20
0168C:  DATA 25,30
0168E:  DATA 32,58
01690:  DATA 0D,0A
01692:  DATA 00,00
01694:  DATA 09,41
01696:  DATA 64,64
01698:  DATA 72,65
0169A:  DATA 73,73
0169C:  DATA 20,20
0169E:  DATA 3A,20
016A0:  DATA 30,78
016A2:  DATA 25,30
016A4:  DATA 38,4C
016A6:  DATA 58,0D
016A8:  DATA 0A,00
016AA:  DATA 09,50
016AC:  DATA 61,63
016AE:  DATA 6B,65
016B0:  DATA 74,4E
016B2:  DATA 75,6D
016B4:  DATA 3A,20
016B6:  DATA 30,78
016B8:  DATA 25,30
016BA:  DATA 34,4C
016BC:  DATA 58,0D
016BE:  DATA 0A,00
016C0:  DATA 57,72
016C2:  DATA 69,74
016C4:  DATA 65,20
016C6:  DATA 44,61
016C8:  DATA 74,61
016CA:  DATA 0D,0A
016CC:  DATA 00,00
016CE:  DATA 45,6E
016D0:  DATA 64,20
016D2:  DATA 46,6C
016D4:  DATA 61,73
016D6:  DATA 68,20
016D8:  DATA 57,72
016DA:  DATA 69,74
016DC:  DATA 65,20
016DE:  DATA 44,65
016E0:  DATA 6D,6F
016E2:  DATA 0D,0A
016E4:  DATA 00,00
016E6:  DATA 53,74
016E8:  DATA 61,72
016EA:  DATA 74,20
016EC:  DATA 46,6C
016EE:  DATA 61,73
016F0:  DATA 68,20
016F2:  DATA 57,72
016F4:  DATA 69,74
016F6:  DATA 65,20
016F8:  DATA 34,6B
016FA:  DATA 42,79
016FC:  DATA 74,65
016FE:  DATA 20,53
01700:  DATA 75,62
01702:  DATA 73,65
01704:  DATA 63,74
01706:  DATA 6F,72
01708:  DATA 0D,0A
0170A:  DATA 00,00
0170C:  DATA 45,6E
0170E:  DATA 64,20
01710:  DATA 46,6C
01712:  DATA 61,73
01714:  DATA 68,20
01716:  DATA 57,72
01718:  DATA 69,74
0171A:  DATA 65,20
0171C:  DATA 34,6B
0171E:  DATA 42,79
01720:  DATA 74,65
01722:  DATA 20,53
01724:  DATA 75,62
01726:  DATA 73,65
01728:  DATA 63,74
0172A:  DATA 6F,72
0172C:  DATA 0D,0A
0172E:  DATA 00,00
01730:  DATA 53,74
01732:  DATA 61,72
01734:  DATA 74,20
01736:  DATA 46,6C
01738:  DATA 61,73
0173A:  DATA 68,20
0173C:  DATA 52,65
0173E:  DATA 61,64
01740:  DATA 0D,0A
01742:  DATA 00,00
01744:  DATA 09,4D
01746:  DATA 4F,44
01748:  DATA 45,20
0174A:  DATA 20,20
0174C:  DATA 20,20
0174E:  DATA 3A,20
01750:  DATA 25,30
01752:  DATA 32,58
01754:  DATA 0D,0A
01756:  DATA 00,00
01758:  DATA 09,41
0175A:  DATA 64,64
0175C:  DATA 72,65
0175E:  DATA 73,73
01760:  DATA 20,20
01762:  DATA 3A,20
01764:  DATA 30,78
01766:  DATA 25,30
01768:  DATA 38,4C
0176A:  DATA 58,0D
0176C:  DATA 0A,00
0176E:  DATA 09,50
01770:  DATA 61,63
01772:  DATA 6B,65
01774:  DATA 74,4E
01776:  DATA 75,6D
01778:  DATA 3A,20
0177A:  DATA 30,78
0177C:  DATA 25,30
0177E:  DATA 34,4C
01780:  DATA 58,0D
01782:  DATA 0A,00
01784:  DATA 52,45
01786:  DATA 41,44
01788:  DATA 20,44
0178A:  DATA 41,54
0178C:  DATA 41,0D
0178E:  DATA 0A,00
01790:  DATA 4D,69
01792:  DATA 73,73
01794:  DATA 69,6F
01796:  DATA 6E,20
01798:  DATA 46,6C
0179A:  DATA 61,73
0179C:  DATA 68,20
0179E:  DATA 69,73
017A0:  DATA 20,6E
017A2:  DATA 6F,74
017A4:  DATA 20,63
017A6:  DATA 6F,6E
017A8:  DATA 6E,65
017AA:  DATA 63,74
017AC:  DATA 65,64
017AE:  DATA 0D,0A
017B0:  DATA 00,00
017B2:  DATA 45,6E
017B4:  DATA 64,20
017B6:  DATA 46,6C
017B8:  DATA 61,73
017BA:  DATA 68,20
017BC:  DATA 52,65
017BE:  DATA 61,64
017C0:  DATA 0D,0A
017C2:  DATA 00,00
017C4:  DATA 53,74
017C6:  DATA 61,72
017C8:  DATA 74,20
017CA:  DATA 46,6C
017CC:  DATA 61,73
017CE:  DATA 68,20
017D0:  DATA 52,65
017D2:  DATA 61,64
017D4:  DATA 20,41
017D6:  DATA 64,64
017D8:  DATA 72,65
017DA:  DATA 73,73
017DC:  DATA 0D,0A
017DE:  DATA 00,00
017E0:  DATA 52,65
017E2:  DATA 61,64
017E4:  DATA 20,44
017E6:  DATA 61,74
017E8:  DATA 61,3A
017EA:  DATA 20,25
017EC:  DATA 30,32
017EE:  DATA 58,20
017F0:  DATA 25,30
017F2:  DATA 32,58
017F4:  DATA 20,25
017F6:  DATA 30,32
017F8:  DATA 58,20
017FA:  DATA 25,30
017FC:  DATA 32,58
017FE:  DATA 0D,0A
01800:  DATA 00,00
01802:  DATA 45,6E
01804:  DATA 64,20
01806:  DATA 46,6C
01808:  DATA 61,73
0180A:  DATA 68,20
0180C:  DATA 52,65
0180E:  DATA 61,64
01810:  DATA 20,41
01812:  DATA 64,64
01814:  DATA 72,65
01816:  DATA 73,73
01818:  DATA 0D,0A
0181A:  DATA 00,00
0181C:  DATA 53,74
0181E:  DATA 61,72
01820:  DATA 74,20
01822:  DATA 46,6C
01824:  DATA 61,73
01826:  DATA 68,20
01828:  DATA 45,72
0182A:  DATA 61,73
0182C:  DATA 65,20
0182E:  DATA 61,6E
01830:  DATA 64,20
01832:  DATA 52,65
01834:  DATA 73,65
01836:  DATA 74,0D
01838:  DATA 0A,00
0183A:  DATA 45,6E
0183C:  DATA 64,20
0183E:  DATA 46,6C
01840:  DATA 61,73
01842:  DATA 68,20
01844:  DATA 45,72
01846:  DATA 61,73
01848:  DATA 65,20
0184A:  DATA 61,6E
0184C:  DATA 64,20
0184E:  DATA 52,65
01850:  DATA 73,65
01852:  DATA 74,0D
01854:  DATA 0A,00
01856:  DATA 53,74
01858:  DATA 61,72
0185A:  DATA 74,20
0185C:  DATA 46,6C
0185E:  DATA 61,73
01860:  DATA 68,20
01862:  DATA 53,4D
01864:  DATA 46,20
01866:  DATA 43,6F
01868:  DATA 70,79
0186A:  DATA 0D,0A
0186C:  DATA 00,00
0186E:  DATA 45,6E
01870:  DATA 64,20
01872:  DATA 46,6C
01874:  DATA 61,73
01876:  DATA 68,20
01878:  DATA 53,4D
0187A:  DATA 46,20
0187C:  DATA 43,6F
0187E:  DATA 70,79
01880:  DATA 0D,0A
01882:  DATA 00,00
01884:  DATA 53,74
01886:  DATA 61,72
01888:  DATA 74,20
0188A:  DATA 46,6C
0188C:  DATA 61,73
0188E:  DATA 68,20
01890:  DATA 53,4D
01892:  DATA 46,20
01894:  DATA 52,65
01896:  DATA 61,64
01898:  DATA 0D,0A
0189A:  DATA 00,00
0189C:  DATA 52,65
0189E:  DATA 61,64
018A0:  DATA 20,44
018A2:  DATA 61,74
018A4:  DATA 61,3A
018A6:  DATA 20,00
018A8:  DATA 0D,0A
018AA:  DATA 45,6E
018AC:  DATA 64,20
018AE:  DATA 46,6C
018B0:  DATA 61,73
018B2:  DATA 68,20
018B4:  DATA 53,4D
018B6:  DATA 46,20
018B8:  DATA 52,65
018BA:  DATA 61,64
018BC:  DATA 0D,0A
018BE:  DATA 00,00
018C0:  DATA 53,74
018C2:  DATA 61,72
018C4:  DATA 74,20
018C6:  DATA 46,6C
018C8:  DATA 61,73
018CA:  DATA 68,20
018CC:  DATA 53,4D
018CE:  DATA 46,20
018D0:  DATA 45,72
018D2:  DATA 61,73
018D4:  DATA 65,0D
018D6:  DATA 0A,00
018D8:  DATA 45,6E
018DA:  DATA 64,20
018DC:  DATA 46,6C
018DE:  DATA 61,73
018E0:  DATA 68,20
018E2:  DATA 53,4D
018E4:  DATA 46,20
018E6:  DATA 45,72
018E8:  DATA 61,73
018EA:  DATA 65,0D
018EC:  DATA 0A,00
018EE:  DATA 53,74
018F0:  DATA 61,72
018F2:  DATA 74,20
018F4:  DATA 46,6C
018F6:  DATA 61,73
018F8:  DATA 68,20
018FA:  DATA 41,64
018FC:  DATA 64,72
018FE:  DATA 65,73
01900:  DATA 73,20
01902:  DATA 52,65
01904:  DATA 73,65
01906:  DATA 74,0D
01908:  DATA 0A,00
0190A:  DATA 45,6E
0190C:  DATA 64,20
0190E:  DATA 46,6C
01910:  DATA 61,73
01912:  DATA 68,20
01914:  DATA 41,64
01916:  DATA 64,72
01918:  DATA 65,73
0191A:  DATA 73,20
0191C:  DATA 52,65
0191E:  DATA 73,65
01920:  DATA 74,0D
01922:  DATA 0A,00
01924:  DATA 53,4D
01926:  DATA 46,20
01928:  DATA 69,73
0192A:  DATA 20,6E
0192C:  DATA 6F,74
0192E:  DATA 20,63
01930:  DATA 6F,6E
01932:  DATA 6E,65
01934:  DATA 63,74
01936:  DATA 65,64
01938:  DATA 0D,0A
0193A:  DATA 00,00
0193C:  DATA 53,74
0193E:  DATA 61,72
01940:  DATA 74,20
01942:  DATA 46,6C
01944:  DATA 61,73
01946:  DATA 68,20
01948:  DATA 53,4D
0194A:  DATA 46,20
0194C:  DATA 52,65
0194E:  DATA 61,64
01950:  DATA 20,46
01952:  DATA 6F,72
01954:  DATA 63,65
01956:  DATA 0D,0A
01958:  DATA 00,00
0195A:  DATA 09,41
0195C:  DATA 64,64
0195E:  DATA 72,65
01960:  DATA 73,73
01962:  DATA 20,20
01964:  DATA 3A,20
01966:  DATA 30,78
01968:  DATA 25,30
0196A:  DATA 38,4C
0196C:  DATA 58,0D
0196E:  DATA 0A,00
01970:  DATA 09,50
01972:  DATA 61,63
01974:  DATA 6B,65
01976:  DATA 74,4E
01978:  DATA 75,6D
0197A:  DATA 3A,20
0197C:  DATA 30,78
0197E:  DATA 25,30
01980:  DATA 34,4C
01982:  DATA 58,0D
01984:  DATA 0A,00
01986:  DATA 72,65
01988:  DATA 61,64
0198A:  DATA 20,64
0198C:  DATA 61,74
0198E:  DATA 61,0D
01990:  DATA 0A,00
01992:  DATA 0D,0A
01994:  DATA 45,6E
01996:  DATA 64,20
01998:  DATA 46,6C
0199A:  DATA 61,73
0199C:  DATA 68,20
0199E:  DATA 53,4D
019A0:  DATA 46,20
019A2:  DATA 52,65
019A4:  DATA 61,64
019A6:  DATA 20,46
019A8:  DATA 6F,72
019AA:  DATA 63,65
019AC:  DATA 0D,0A
019AE:  DATA 00,00
019B0:  DATA 53,74
019B2:  DATA 61,72
019B4:  DATA 74,20
019B6:  DATA 53,4D
019B8:  DATA 46,20
019BA:  DATA 45,72
019BC:  DATA 61,73
019BE:  DATA 65,20
019C0:  DATA 41,6C
019C2:  DATA 6C,0D
019C4:  DATA 0A,00
019C6:  DATA 45,6E
019C8:  DATA 64,20
019CA:  DATA 53,4D
019CC:  DATA 46,20
019CE:  DATA 45,72
019D0:  DATA 61,73
019D2:  DATA 65,20
019D4:  DATA 41,6C
019D6:  DATA 6C,0D
019D8:  DATA 0A,00
019DA:  DATA 53,74
019DC:  DATA 61,72
019DE:  DATA 74,20
019E0:  DATA 53,4D
019E2:  DATA 46,20
019E4:  DATA 52,65
019E6:  DATA 73,65
019E8:  DATA 74,0D
019EA:  DATA 0A,00
019EC:  DATA 45,6E
019EE:  DATA 64,20
019F0:  DATA 53,4D
019F2:  DATA 46,20
019F4:  DATA 52,65
019F6:  DATA 73,65
019F8:  DATA 74,0D
019FA:  DATA 0A,00
019FC:  DATA 0D,0A
019FE:  DATA 0D,0A
01A00:  DATA 0D,0A
01A02:  DATA 3D,3D
01A04:  DATA 3D,3D
01A06:  DATA 3D,3D
01A08:  DATA 3D,3D
01A0A:  DATA 3D,3D
01A0C:  DATA 3D,3D
01A0E:  DATA 3D,3D
01A10:  DATA 3D,3D
01A12:  DATA 3D,3D
01A14:  DATA 3D,3D
01A16:  DATA 3D,3D
01A18:  DATA 3D,3D
01A1A:  DATA 3D,3D
01A1C:  DATA 3D,3D
01A1E:  DATA 3D,3D
01A20:  DATA 3D,3D
01A22:  DATA 3D,3D
01A24:  DATA 3D,3D
01A26:  DATA 3D,3D
01A28:  DATA 3D,3D
01A2A:  DATA 3D,3D
01A2C:  DATA 3D,3D
01A2E:  DATA 3D,3D
01A30:  DATA 3D,3D
01A32:  DATA 3D,3D
01A34:  DATA 3D,3D
01A36:  DATA 3D,3D
01A38:  DATA 3D,3D
01A3A:  DATA 3D,3D
01A3C:  DATA 3D,3D
01A3E:  DATA 0D,0A
01A40:  DATA 00,00
01A42:  DATA 54,68
01A44:  DATA 69,73
01A46:  DATA 20,69
01A48:  DATA 73,20
01A4A:  DATA 4D,4F
01A4C:  DATA 4D,49
01A4E:  DATA 4A,49
01A50:  DATA 20,43
01A52:  DATA 49,47
01A54:  DATA 53,20
01A56:  DATA 50,49
01A58:  DATA 43,20
01A5A:  DATA 42,42
01A5C:  DATA 4D,20
01A5E:  DATA 66,6F
01A60:  DATA 72,20
01A62:  DATA 4D,49
01A64:  DATA 53,37
01A66:  DATA 5F,42
01A68:  DATA 42,4D
01A6A:  DATA 34,2E
01A6C:  DATA 0D,0A
01A6E:  DATA 00,00
01A70:  DATA 4C,61
01A72:  DATA 73,74
01A74:  DATA 20,75
01A76:  DATA 70,64
01A78:  DATA 61,74
01A7A:  DATA 65,64
01A7C:  DATA 20,6F
01A7E:  DATA 6E,20
01A80:  DATA 25,73
01A82:  DATA 20,25
01A84:  DATA 73,2C
01A86:  DATA 20,62
01A88:  DATA 79,20
01A8A:  DATA 49,6E
01A8C:  DATA 6F,75
01A8E:  DATA 65,2E
01A90:  DATA 0D,0A
01A92:  DATA 0D,0A
01A94:  DATA 00,00
01A96:  DATA 32,30
01A98:  DATA 2D,41
01A9A:  DATA 75,67
01A9C:  DATA 2D,32
01A9E:  DATA 35,00
01AA0:  DATA 31,39
01AA2:  DATA 3A,32
01AA4:  DATA 39,3A
01AA6:  DATA 31,35
01AA8:  DATA 00,00
01AAA:  DATA 5F,5F
01AAC:  DATA 5F,5F
01AAE:  DATA 43,49
01AB0:  DATA 47,53
01AB2:  DATA 20,50
01AB4:  DATA 49,43
01AB6:  DATA 20,53
01AB8:  DATA 74,61
01ABA:  DATA 72,74
01ABC:  DATA 20,4F
01ABE:  DATA 70,65
01AC0:  DATA 72,61
01AC2:  DATA 74,69
01AC4:  DATA 6F,6E
01AC6:  DATA 5F,5F
01AC8:  DATA 5F,5F
01ACA:  DATA 5F,0D
01ACC:  DATA 0A,0D
01ACE:  DATA 0A,00
01AD0:  DATA 77,61
01AD2:  DATA 69,74
01AD4:  DATA 69,6E
01AD6:  DATA 67,20
01AD8:  DATA 66,6F
01ADA:  DATA 72,20
01ADC:  DATA 42,4F
01ADE:  DATA 53,53
01AE0:  DATA 20,50
01AE2:  DATA 49,43
01AE4:  DATA 20,63
01AE6:  DATA 6F,6D
01AE8:  DATA 6D,61
01AEA:  DATA 6E,64
01AEC:  DATA 00,00
01AEE:  DATA 0D,0A
01AF0:  DATA 77,61
01AF2:  DATA 69,74
01AF4:  DATA 69,6E
01AF6:  DATA 67,20
01AF8:  DATA 66,6F
01AFA:  DATA 72,20
01AFC:  DATA 42,4F
01AFE:  DATA 53,53
01B00:  DATA 20,50
01B02:  DATA 49,43
01B04:  DATA 20,63
01B06:  DATA 6F,6D
01B08:  DATA 6D,61
01B0A:  DATA 6E,64
01B0C:  DATA 00,00
01B0E:  DATA 0D,0A
01B10:  DATA 0D,0A
01B12:  DATA 3D,3D
01B14:  DATA 3D,3D
01B16:  DATA 3D,3D
01B18:  DATA 0D,0A
01B1A:  DATA 0D,0A
01B1C:  DATA 46,69
01B1E:  DATA 6E,69
01B20:  DATA 73,68
01B22:  DATA 65,64
01B24:  DATA 20,70
01B26:  DATA 72,6F
01B28:  DATA 63,65
01B2A:  DATA 73,73
01B2C:  DATA 2E,0D
01B2E:  DATA 0A,57
01B30:  DATA 61,69
01B32:  DATA 74,20
01B34:  DATA 66,6F
01B36:  DATA 72,20
01B38:  DATA 42,4F
01B3A:  DATA 53,53
01B3C:  DATA 20,50
01B3E:  DATA 49,43
01B40:  DATA 20,74
01B42:  DATA 75,72
01B44:  DATA 6E,20
01B46:  DATA 6F,66
01B48:  DATA 66,20
01B4A:  DATA 6D,65
01B4C:  DATA 00,00
01B4E:  DATA 45,6E
01B50:  DATA 64,20
01B52:  DATA 6D,61
01B54:  DATA 69,6E
01B56:  DATA 0D,0A
01B58:  DATA 00,00
*
01BDA:  TBLRD*+
01BDC:  MOVF   FF5,F
01BDE:  BTFSC  FD8.2
01BE0:  GOTO   1C08
01BE4:  MOVFF  FF6,A16
01BE8:  MOVFF  FF7,A17
01BEC:  MOVFF  FF8,A18
01BF0:  MOVFF  FF5,AAD
01BF4:  CALL   1B88
01BF8:  MOVFF  A16,FF6
01BFC:  MOVFF  A17,FF7
01C00:  MOVFF  A18,FF8
01C04:  GOTO   1BDA
01C08:  RETURN 0
01C0A:  TBLRD*+
01C0C:  MOVFF  FF6,9C7
01C10:  MOVFF  FF7,9C8
01C14:  MOVFF  FF8,9C9
01C18:  MOVFF  FF5,AAD
01C1C:  CALL   1B88
01C20:  MOVFF  9C7,FF6
01C24:  MOVFF  9C8,FF7
01C28:  MOVFF  9C9,FF8
01C2C:  MOVLB  9
01C2E:  DECFSZ xC6,F
01C30:  BRA    1C36
01C32:  BRA    1C3C
01C34:  MOVLB  0
01C36:  MOVLB  0
01C38:  GOTO   1C0A
01C3C:  MOVLB  0
01C3E:  RETURN 0
*
01E5E:  MOVLB  2
01E60:  BTFSS  x65.7
01E62:  BRA    1E6A
01E64:  MOVLB  0
01E66:  GOTO   1E9A
01E6A:  MOVLW  0F
01E6C:  MOVWF  00
01E6E:  SWAPF  x64,W
01E70:  ANDWF  00,F
01E72:  MOVLW  0A
01E74:  SUBWF  00,W
01E76:  BTFSS  FD8.0
01E78:  BRA    1E80
01E7A:  MOVLB  0
01E7C:  GOTO   1E8A
01E80:  MOVLW  30
01E82:  ADDWF  00,F
01E84:  MOVLB  0
01E86:  GOTO   1E92
01E8A:  MOVLB  2
01E8C:  MOVF   x65,W
01E8E:  ADDWF  00,F
01E90:  MOVLB  0
01E92:  MOVFF  00,AAD
01E96:  CALL   1B88
01E9A:  MOVLW  0F
01E9C:  MOVLB  2
01E9E:  ANDWF  x64,F
01EA0:  MOVLW  0A
01EA2:  SUBWF  x64,W
01EA4:  BTFSS  FD8.0
01EA6:  BRA    1EAE
01EA8:  MOVLB  0
01EAA:  GOTO   1EB6
01EAE:  MOVLW  30
01EB0:  MOVLB  0
01EB2:  GOTO   1EBE
01EB6:  MOVLB  2
01EB8:  BCF    x65.7
01EBA:  MOVF   x65,W
01EBC:  MOVLB  0
01EBE:  MOVLB  2
01EC0:  ADDWF  x64,F
01EC2:  MOVFF  264,AAD
01EC6:  MOVLB  0
01EC8:  CALL   1B88
01ECC:  RETURN 0
*
02374:  MOVLB  A
02376:  MOVF   x74,W
02378:  ANDLW  07
0237A:  MOVWF  00
0237C:  RRCF   x74,W
0237E:  MOVWF  01
02380:  RRCF   01,F
02382:  RRCF   01,F
02384:  MOVLW  1F
02386:  ANDWF  01,F
02388:  MOVF   01,W
0238A:  ADDWF  x76,W
0238C:  MOVWF  FE9
0238E:  MOVLW  00
02390:  ADDWFC x77,W
02392:  MOVWF  FEA
02394:  CLRF   01
02396:  INCF   01,F
02398:  INCF   00,F
0239A:  MOVLB  0
0239C:  GOTO   23A2
023A0:  RLCF   01,F
023A2:  DECFSZ 00,F
023A4:  GOTO   23A0
023A8:  MOVLB  A
023AA:  MOVF   x75,F
023AC:  BTFSS  FD8.2
023AE:  BRA    23B6
023B0:  MOVLB  0
023B2:  GOTO   23C0
023B6:  MOVF   01,W
023B8:  IORWF  FEF,F
023BA:  MOVLB  0
023BC:  GOTO   23C6
023C0:  COMF   01,F
023C2:  MOVF   01,W
023C4:  ANDWF  FEF,F
023C6:  RETURN 0
*
027BC:  TSTFSZ 01
027BE:  GOTO   27CC
027C2:  TSTFSZ 02
027C4:  GOTO   27CE
027C8:  GOTO   27DE
027CC:  INCF   02,F
027CE:  MOVFF  00,FEE
027D2:  DECFSZ 01,F
027D4:  GOTO   27CE
027D8:  DECFSZ 02,F
027DA:  GOTO   27CE
027DE:  RETURN 0
*
0635C:  MOVLB  2
0635E:  MOVF   xEA,W
06360:  CLRF   01
06362:  SUBWF  xE9,W
06364:  BTFSS  FD8.0
06366:  BRA    636E
06368:  MOVLB  0
0636A:  GOTO   6378
0636E:  MOVF   xE9,W
06370:  MOVWF  00
06372:  MOVLB  0
06374:  GOTO   63A2
06378:  CLRF   00
0637A:  MOVLW  08
0637C:  MOVLB  2
0637E:  MOVWF  xEB
06380:  MOVLB  0
06382:  MOVLB  2
06384:  RLCF   xE9,F
06386:  RLCF   00,F
06388:  MOVF   xEA,W
0638A:  SUBWF  00,W
0638C:  BTFSC  FD8.0
0638E:  MOVWF  00
06390:  RLCF   01,F
06392:  DECFSZ xEB,F
06394:  BRA    639A
06396:  BRA    63A0
06398:  MOVLB  0
0639A:  MOVLB  0
0639C:  GOTO   6382
063A0:  MOVLB  0
063A2:  RETURN 0
063A4:  MOVF   01,W
063A6:  MOVFF  264,2E9
063AA:  MOVLW  64
063AC:  MOVLB  2
063AE:  MOVWF  xEA
063B0:  MOVLB  0
063B2:  CALL   635C
063B6:  MOVFF  00,264
063BA:  MOVF   01,W
063BC:  MOVLW  30
063BE:  BTFSS  FD8.2
063C0:  GOTO   63E4
063C4:  MOVLB  2
063C6:  BTFSC  x65.1
063C8:  BRA    63D0
063CA:  MOVLB  0
063CC:  GOTO   63F8
063D0:  BTFSS  x65.3
063D2:  BRA    63DA
063D4:  MOVLB  0
063D6:  GOTO   63F8
063DA:  BTFSC  x65.4
063DC:  MOVLW  20
063DE:  MOVLB  0
063E0:  GOTO   63EE
063E4:  MOVLB  2
063E6:  BCF    x65.3
063E8:  BCF    x65.4
063EA:  BSF    x65.0
063EC:  MOVLB  0
063EE:  ADDWF  01,F
063F0:  MOVFF  01,AAD
063F4:  CALL   1B88
063F8:  MOVFF  264,2E9
063FC:  MOVLW  0A
063FE:  MOVLB  2
06400:  MOVWF  xEA
06402:  MOVLB  0
06404:  CALL   635C
06408:  MOVFF  00,264
0640C:  MOVF   01,W
0640E:  MOVLW  30
06410:  BTFSS  FD8.2
06412:  GOTO   6432
06416:  MOVLB  2
06418:  BTFSS  x65.3
0641A:  BRA    6422
0641C:  MOVLB  0
0641E:  GOTO   643C
06422:  BTFSC  x65.0
06424:  BRA    642C
06426:  MOVLB  0
06428:  GOTO   643C
0642C:  BTFSC  x65.4
0642E:  MOVLW  20
06430:  MOVLB  0
06432:  ADDWF  01,F
06434:  MOVFF  01,AAD
06438:  CALL   1B88
0643C:  MOVLW  30
0643E:  MOVLB  2
06440:  ADDWF  x64,F
06442:  MOVFF  264,AAD
06446:  MOVLB  0
06448:  CALL   1B88
0644C:  RETURN 0
0644E:  BTFSC  FD8.1
06450:  GOTO   645C
06454:  MOVLW  09
06456:  MOVWF  FEA
06458:  MOVLW  DF
0645A:  MOVWF  FE9
0645C:  CLRF   00
0645E:  CLRF   01
06460:  CLRF   02
06462:  CLRF   03
06464:  MOVLB  9
06466:  CLRF   xDF
06468:  CLRF   xE0
0646A:  CLRF   xE1
0646C:  CLRF   xE2
0646E:  MOVF   xDE,W
06470:  IORWF  xDD,W
06472:  IORWF  xDC,W
06474:  IORWF  xDB,W
06476:  BTFSS  FD8.2
06478:  BRA    6480
0647A:  MOVLB  0
0647C:  GOTO   6510
06480:  MOVLB  0
06482:  MOVLW  20
06484:  MOVLB  9
06486:  MOVWF  xE3
06488:  MOVLB  0
0648A:  BCF    FD8.0
0648C:  MOVLB  9
0648E:  RLCF   xD7,F
06490:  RLCF   xD8,F
06492:  RLCF   xD9,F
06494:  RLCF   xDA,F
06496:  RLCF   xDF,F
06498:  RLCF   xE0,F
0649A:  RLCF   xE1,F
0649C:  RLCF   xE2,F
0649E:  MOVF   xDE,W
064A0:  SUBWF  xE2,W
064A2:  BTFSC  FD8.2
064A4:  BRA    64AC
064A6:  MOVLB  0
064A8:  GOTO   64CE
064AC:  MOVF   xDD,W
064AE:  SUBWF  xE1,W
064B0:  BTFSC  FD8.2
064B2:  BRA    64BA
064B4:  MOVLB  0
064B6:  GOTO   64CE
064BA:  MOVF   xDC,W
064BC:  SUBWF  xE0,W
064BE:  BTFSC  FD8.2
064C0:  BRA    64C8
064C2:  MOVLB  0
064C4:  GOTO   64CE
064C8:  MOVF   xDB,W
064CA:  SUBWF  xDF,W
064CC:  MOVLB  0
064CE:  BTFSS  FD8.0
064D0:  GOTO   64F6
064D4:  MOVLB  9
064D6:  MOVF   xDB,W
064D8:  SUBWF  xDF,F
064DA:  MOVF   xDC,W
064DC:  BTFSS  FD8.0
064DE:  INCFSZ xDC,W
064E0:  SUBWF  xE0,F
064E2:  MOVF   xDD,W
064E4:  BTFSS  FD8.0
064E6:  INCFSZ xDD,W
064E8:  SUBWF  xE1,F
064EA:  MOVF   xDE,W
064EC:  BTFSS  FD8.0
064EE:  INCFSZ xDE,W
064F0:  SUBWF  xE2,F
064F2:  BSF    FD8.0
064F4:  MOVLB  0
064F6:  RLCF   00,F
064F8:  RLCF   01,F
064FA:  RLCF   02,F
064FC:  RLCF   03,F
064FE:  MOVLB  9
06500:  DECFSZ xE3,F
06502:  BRA    6508
06504:  BRA    650E
06506:  MOVLB  0
06508:  MOVLB  0
0650A:  GOTO   648A
0650E:  MOVLB  0
06510:  MOVFF  9DF,FEF
06514:  MOVFF  9E0,FEC
06518:  MOVFF  9E1,FEC
0651C:  MOVFF  9E2,FEC
06520:  MOVF   FED,F
06522:  MOVF   FED,F
06524:  MOVF   FED,F
06526:  RETURN 0
*
065E2:  MOVFF  FEA,9CE
065E6:  MOVFF  FE9,9CD
065EA:  MOVLB  9
065EC:  BTFSC  xC7.7
065EE:  BRA    65F6
065F0:  MOVLB  0
065F2:  GOTO   6608
065F6:  BSF    xCD.7
065F8:  BTFSS  xCD.4
065FA:  INCF   xCD,F
065FC:  COMF   xC6,F
065FE:  COMF   xC7,F
06600:  INCF   xC6,F
06602:  BTFSC  FD8.2
06604:  INCF   xC7,F
06606:  MOVLB  0
06608:  MOVLB  9
0660A:  SWAPF  xC7,W
0660C:  IORLW  F0
0660E:  MOVWF  xC9
06610:  ADDWF  xC9,F
06612:  ADDLW  E2
06614:  MOVWF  xCA
06616:  ADDLW  32
06618:  MOVWF  xCC
0661A:  MOVF   xC7,W
0661C:  ANDLW  0F
0661E:  ADDWF  xCA,F
06620:  ADDWF  xCA,F
06622:  ADDWF  xCC,F
06624:  ADDLW  E9
06626:  MOVWF  xCB
06628:  ADDWF  xCB,F
0662A:  ADDWF  xCB,F
0662C:  SWAPF  xC6,W
0662E:  ANDLW  0F
06630:  ADDWF  xCB,F
06632:  ADDWF  xCC,F
06634:  RLCF   xCB,F
06636:  RLCF   xCC,F
06638:  COMF   xCC,F
0663A:  RLCF   xCC,F
0663C:  MOVF   xC6,W
0663E:  ANDLW  0F
06640:  ADDWF  xCC,F
06642:  RLCF   xC9,F
06644:  MOVLW  07
06646:  MOVWF  xC8
06648:  MOVLW  0A
0664A:  MOVLB  0
0664C:  MOVLB  9
0664E:  DECF   xCB,F
06650:  ADDWF  xCC,F
06652:  BTFSC  FD8.0
06654:  BRA    665C
06656:  MOVLB  0
06658:  GOTO   664C
0665C:  MOVLB  0
0665E:  MOVLB  9
06660:  DECF   xCA,F
06662:  ADDWF  xCB,F
06664:  BTFSC  FD8.0
06666:  BRA    666E
06668:  MOVLB  0
0666A:  GOTO   665E
0666E:  MOVLB  0
06670:  MOVLB  9
06672:  DECF   xC9,F
06674:  ADDWF  xCA,F
06676:  BTFSC  FD8.0
06678:  BRA    6680
0667A:  MOVLB  0
0667C:  GOTO   6670
06680:  MOVLB  0
06682:  MOVLB  9
06684:  DECF   xC8,F
06686:  ADDWF  xC9,F
06688:  BTFSC  FD8.0
0668A:  BRA    6692
0668C:  MOVLB  0
0668E:  GOTO   6682
06692:  MOVLW  09
06694:  MOVWF  FEA
06696:  MOVLW  C8
06698:  MOVWF  FE9
0669A:  MOVLW  07
0669C:  ANDWF  xCD,W
0669E:  BCF    xCD.6
066A0:  MOVF   FED,F
066A2:  ANDWF  xCD,W
066A4:  BTFSC  FD8.2
066A6:  BRA    66AE
066A8:  MOVLB  0
066AA:  GOTO   66C6
066AE:  BTFSC  xCD.4
066B0:  MOVF   FEE,F
066B2:  BTFSS  xCD.4
066B4:  BRA    66BC
066B6:  MOVLB  0
066B8:  GOTO   66C6
066BC:  MOVLW  20
066BE:  MOVWF  00
066C0:  MOVLB  0
066C2:  GOTO   6740
066C6:  ADDWF  FE9,F
066C8:  MOVLW  00
066CA:  ADDWFC FEA,F
066CC:  MOVF   FE9,W
066CE:  SUBLW  CC
066D0:  BTFSS  FD8.2
066D2:  GOTO   66E6
066D6:  MOVF   FEA,W
066D8:  SUBLW  09
066DA:  BTFSS  FD8.2
066DC:  GOTO   66E6
066E0:  MOVLB  9
066E2:  BSF    xCD.6
066E4:  MOVLB  0
066E6:  MOVF   FEF,W
066E8:  MOVWF  00
066EA:  BTFSS  FD8.2
066EC:  GOTO   6718
066F0:  MOVLB  9
066F2:  BTFSS  xCD.6
066F4:  BRA    66FC
066F6:  MOVLB  0
066F8:  GOTO   6718
066FC:  BTFSS  xCD.4
066FE:  BRA    6706
06700:  MOVLB  0
06702:  GOTO   6758
06706:  BTFSS  xCD.3
06708:  BRA    6710
0670A:  MOVLB  0
0670C:  GOTO   6718
06710:  MOVLW  20
06712:  MOVLB  0
06714:  GOTO   673E
06718:  MOVLB  9
0671A:  BTFSC  xCD.7
0671C:  BRA    6724
0671E:  MOVLB  0
06720:  GOTO   6734
06724:  MOVLW  2D
06726:  MOVWF  00
06728:  MOVF   FED,W
0672A:  BCF    xCD.6
0672C:  BCF    xCD.7
0672E:  MOVLB  0
06730:  GOTO   6740
06734:  MOVLB  9
06736:  BSF    xCD.3
06738:  BCF    xCD.4
0673A:  MOVLW  30
0673C:  MOVLB  0
0673E:  ADDWF  00,F
06740:  MOVFF  FEA,9C7
06744:  MOVFF  FE9,9C6
06748:  MOVFF  00,AAD
0674C:  CALL   1B88
06750:  MOVFF  9C7,FEA
06754:  MOVFF  9C6,FE9
06758:  MOVF   FEE,W
0675A:  MOVLB  9
0675C:  BTFSC  xCD.6
0675E:  BRA    6766
06760:  MOVLB  0
06762:  GOTO   66CC
06766:  MOVLB  0
06768:  RETURN 0
*
093B2:  MOVF   FE9,W
093B4:  MOVLB  2
093B6:  MOVWF  x64
093B8:  BTFSC  x63.7
093BA:  BRA    93C2
093BC:  MOVLB  0
093BE:  GOTO   93DE
093C2:  DECF   x64,F
093C4:  BSF    x64.5
093C6:  COMF   x60,F
093C8:  COMF   x61,F
093CA:  COMF   x62,F
093CC:  COMF   x63,F
093CE:  INCF   x60,F
093D0:  BTFSC  FD8.2
093D2:  INCF   x61,F
093D4:  BTFSC  FD8.2
093D6:  INCF   x62,F
093D8:  BTFSC  FD8.2
093DA:  INCF   x63,F
093DC:  MOVLB  0
093DE:  MOVLW  3B
093E0:  MOVLB  2
093E2:  MOVWF  x6B
093E4:  MOVLW  9A
093E6:  MOVWF  x6A
093E8:  MOVLW  CA
093EA:  MOVWF  x69
093EC:  CLRF   x68
093EE:  MOVLW  0A
093F0:  MOVWF  x66
093F2:  MOVLB  0
093F4:  BSF    FD8.1
093F6:  MOVLW  02
093F8:  MOVWF  FEA
093FA:  MOVLW  60
093FC:  MOVWF  FE9
093FE:  MOVFF  263,9DA
09402:  MOVFF  262,9D9
09406:  MOVFF  261,9D8
0940A:  MOVFF  260,9D7
0940E:  MOVFF  26B,9DE
09412:  MOVFF  26A,9DD
09416:  MOVFF  269,9DC
0941A:  MOVFF  268,9DB
0941E:  CALL   644E
09422:  MOVF   01,W
09424:  MOVF   00,F
09426:  BTFSS  FD8.2
09428:  GOTO   9480
0942C:  MOVLB  2
0942E:  MOVF   x66,W
09430:  XORLW  01
09432:  BTFSS  FD8.2
09434:  BRA    943C
09436:  MOVLB  0
09438:  GOTO   9480
0943C:  MOVF   x64,W
0943E:  BTFSS  FD8.2
09440:  BRA    9448
09442:  MOVLB  0
09444:  GOTO   9488
09448:  ANDLW  0F
0944A:  SUBWF  x66,W
0944C:  BTFSS  FD8.2
0944E:  BRA    9456
09450:  MOVLB  0
09452:  GOTO   9462
09456:  BTFSS  FD8.0
09458:  BRA    9460
0945A:  MOVLB  0
0945C:  GOTO   94E6
09460:  MOVLB  0
09462:  MOVLB  2
09464:  BTFSS  x64.7
09466:  BRA    946E
09468:  MOVLB  0
0946A:  GOTO   94E6
0946E:  BTFSS  x64.6
09470:  BRA    9478
09472:  MOVLB  0
09474:  GOTO   9488
09478:  MOVLW  20
0947A:  MOVLB  0
0947C:  GOTO   94DC
09480:  MOVLW  20
09482:  MOVLB  2
09484:  ANDWF  x64,F
09486:  MOVLB  0
09488:  MOVLB  2
0948A:  BTFSC  x64.5
0948C:  BRA    9494
0948E:  MOVLB  0
09490:  GOTO   94B0
09494:  BCF    x64.5
09496:  MOVF   00,W
09498:  MOVWF  x64
0949A:  MOVLW  2D
0949C:  MOVLB  A
0949E:  MOVWF  xAD
094A0:  MOVLB  0
094A2:  CALL   1B88
094A6:  MOVLB  2
094A8:  MOVF   x64,W
094AA:  MOVWF  00
094AC:  CLRF   x64
094AE:  MOVLB  0
094B0:  MOVLW  30
094B2:  MOVLB  2
094B4:  BTFSC  x64.5
094B6:  BRA    94BE
094B8:  MOVLB  0
094BA:  GOTO   94DC
094BE:  BCF    x64.5
094C0:  MOVF   00,W
094C2:  MOVWF  x64
094C4:  MOVLW  2D
094C6:  MOVLB  A
094C8:  MOVWF  xAD
094CA:  MOVLB  0
094CC:  CALL   1B88
094D0:  MOVLB  2
094D2:  MOVF   x64,W
094D4:  MOVWF  00
094D6:  CLRF   x64
094D8:  MOVLW  30
094DA:  MOVLB  0
094DC:  ADDWF  00,F
094DE:  MOVFF  00,AAD
094E2:  CALL   1B88
094E6:  BCF    FD8.1
094E8:  MOVFF  26B,9DA
094EC:  MOVFF  26A,9D9
094F0:  MOVFF  269,9D8
094F4:  MOVFF  268,9D7
094F8:  MOVLB  9
094FA:  CLRF   xDE
094FC:  CLRF   xDD
094FE:  CLRF   xDC
09500:  MOVLW  0A
09502:  MOVWF  xDB
09504:  MOVLB  0
09506:  CALL   644E
0950A:  MOVFF  03,26B
0950E:  MOVFF  02,26A
09512:  MOVFF  01,269
09516:  MOVFF  00,268
0951A:  MOVLB  2
0951C:  DECFSZ x66,F
0951E:  BRA    9524
09520:  BRA    952A
09522:  MOVLB  0
09524:  MOVLB  0
09526:  GOTO   93F4
0952A:  MOVLB  0
0952C:  RETURN 0
*
098CE:  MOVLW  20
098D0:  MOVLB  2
098D2:  BTFSS  xE4.4
098D4:  MOVLW  30
098D6:  MOVWF  xE5
098D8:  MOVFF  2E3,00
098DC:  BTFSC  00.7
098DE:  BRA    98E6
098E0:  MOVLB  0
098E2:  GOTO   98F8
098E6:  COMF   00,F
098E8:  INCF   00,F
098EA:  MOVFF  00,2E3
098EE:  MOVLW  2D
098F0:  MOVWF  xE5
098F2:  BSF    xE4.7
098F4:  BSF    xE4.0
098F6:  MOVLB  0
098F8:  MOVF   01,W
098FA:  MOVFF  2E3,2E9
098FE:  MOVLW  64
09900:  MOVLB  2
09902:  MOVWF  xEA
09904:  MOVLB  0
09906:  CALL   635C
0990A:  MOVFF  00,2E3
0990E:  MOVLW  30
09910:  ADDWF  01,W
09912:  MOVLB  2
09914:  MOVWF  xE6
09916:  MOVFF  2E3,2E9
0991A:  MOVLW  0A
0991C:  MOVWF  xEA
0991E:  MOVLB  0
09920:  CALL   635C
09924:  MOVLW  30
09926:  ADDWF  00,W
09928:  MOVLB  2
0992A:  MOVWF  xE8
0992C:  MOVLW  30
0992E:  ADDWF  01,W
09930:  MOVWF  xE7
09932:  MOVFF  2E5,00
09936:  MOVLB  0
09938:  MOVLW  30
0993A:  MOVLB  2
0993C:  SUBWF  xE6,W
0993E:  BTFSS  FD8.2
09940:  BRA    9948
09942:  MOVLB  0
09944:  GOTO   9954
09948:  BSF    xE4.1
0994A:  BTFSC  xE4.7
0994C:  BSF    xE4.2
0994E:  MOVLB  0
09950:  GOTO   9994
09954:  MOVFF  2E5,2E6
09958:  MOVLW  20
0995A:  MOVLB  2
0995C:  MOVWF  xE5
0995E:  MOVLW  30
09960:  SUBWF  xE7,W
09962:  BTFSS  FD8.2
09964:  BRA    996C
09966:  MOVLB  0
09968:  GOTO   9978
0996C:  BSF    xE4.0
0996E:  BTFSC  xE4.7
09970:  BSF    xE4.1
09972:  MOVLB  0
09974:  GOTO   9994
09978:  BTFSC  FD8.2
0997A:  BRA    9982
0997C:  MOVLB  2
0997E:  BSF    xE4.0
09980:  MOVLB  0
09982:  BTFSS  FD8.2
09984:  GOTO   9994
09988:  MOVFF  2E6,2E7
0998C:  MOVLW  20
0998E:  MOVLB  2
09990:  MOVWF  xE6
09992:  MOVLB  0
09994:  MOVLB  2
09996:  BTFSS  xE4.2
09998:  BRA    99A0
0999A:  MOVLB  0
0999C:  GOTO   99BA
099A0:  BTFSS  xE4.1
099A2:  BRA    99AA
099A4:  MOVLB  0
099A6:  GOTO   99C2
099AA:  BTFSS  xE4.0
099AC:  BRA    99B4
099AE:  MOVLB  0
099B0:  GOTO   99CA
099B4:  MOVLB  0
099B6:  GOTO   99D2
099BA:  MOVFF  2E5,AAD
099BE:  CALL   1B88
099C2:  MOVFF  2E6,AAD
099C6:  CALL   1B88
099CA:  MOVFF  2E7,AAD
099CE:  CALL   1B88
099D2:  MOVFF  2E8,AAD
099D6:  CALL   1B88
099DA:  RETURN 0
*
0A5D0:  MOVF   FE9,W
0A5D2:  MOVLB  1
0A5D4:  MOVWF  xE9
0A5D6:  MOVLW  3B
0A5D8:  MOVWF  xF0
0A5DA:  MOVLW  9A
0A5DC:  MOVWF  xEF
0A5DE:  MOVLW  CA
0A5E0:  MOVWF  xEE
0A5E2:  CLRF   xED
0A5E4:  MOVLW  0A
0A5E6:  MOVWF  xEB
0A5E8:  MOVLB  0
0A5EA:  BSF    FD8.1
0A5EC:  MOVLW  01
0A5EE:  MOVWF  FEA
0A5F0:  MOVLW  E5
0A5F2:  MOVWF  FE9
0A5F4:  MOVFF  1E8,9DA
0A5F8:  MOVFF  1E7,9D9
0A5FC:  MOVFF  1E6,9D8
0A600:  MOVFF  1E5,9D7
0A604:  MOVFF  1F0,9DE
0A608:  MOVFF  1EF,9DD
0A60C:  MOVFF  1EE,9DC
0A610:  MOVFF  1ED,9DB
0A614:  CALL   644E
0A618:  MOVF   01,W
0A61A:  MOVF   00,F
0A61C:  BTFSS  FD8.2
0A61E:  GOTO   A676
0A622:  MOVLB  1
0A624:  MOVF   xEB,W
0A626:  XORLW  01
0A628:  BTFSS  FD8.2
0A62A:  BRA    A632
0A62C:  MOVLB  0
0A62E:  GOTO   A676
0A632:  MOVF   xE9,W
0A634:  BTFSS  FD8.2
0A636:  BRA    A63E
0A638:  MOVLB  0
0A63A:  GOTO   A67C
0A63E:  ANDLW  0F
0A640:  SUBWF  xEB,W
0A642:  BTFSS  FD8.2
0A644:  BRA    A64C
0A646:  MOVLB  0
0A648:  GOTO   A658
0A64C:  BTFSS  FD8.0
0A64E:  BRA    A656
0A650:  MOVLB  0
0A652:  GOTO   A688
0A656:  MOVLB  0
0A658:  MOVLB  1
0A65A:  BTFSS  xE9.7
0A65C:  BRA    A664
0A65E:  MOVLB  0
0A660:  GOTO   A688
0A664:  BTFSS  xE9.6
0A666:  BRA    A66E
0A668:  MOVLB  0
0A66A:  GOTO   A67C
0A66E:  MOVLW  20
0A670:  MOVLB  0
0A672:  GOTO   A67E
0A676:  MOVLB  1
0A678:  CLRF   xE9
0A67A:  MOVLB  0
0A67C:  MOVLW  30
0A67E:  ADDWF  00,F
0A680:  MOVFF  00,AAD
0A684:  CALL   1B88
0A688:  BCF    FD8.1
0A68A:  MOVFF  1F0,9DA
0A68E:  MOVFF  1EF,9D9
0A692:  MOVFF  1EE,9D8
0A696:  MOVFF  1ED,9D7
0A69A:  MOVLB  9
0A69C:  CLRF   xDE
0A69E:  CLRF   xDD
0A6A0:  CLRF   xDC
0A6A2:  MOVLW  0A
0A6A4:  MOVWF  xDB
0A6A6:  MOVLB  0
0A6A8:  CALL   644E
0A6AC:  MOVFF  03,1F0
0A6B0:  MOVFF  02,1EF
0A6B4:  MOVFF  01,1EE
0A6B8:  MOVFF  00,1ED
0A6BC:  MOVLB  1
0A6BE:  DECFSZ xEB,F
0A6C0:  BRA    A6C6
0A6C2:  BRA    A6CC
0A6C4:  MOVLB  0
0A6C6:  MOVLB  0
0A6C8:  GOTO   A5EA
0A6CC:  MOVLB  0
0A6CE:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01B5A:  MOVLW  0A
01B5C:  MOVWF  FEA
01B5E:  MOVLW  6E
01B60:  MOVWF  FE9
01B62:  MOVF   FEF,W
01B64:  BTFSC  FD8.2
01B66:  GOTO   1B86
01B6A:  MOVLW  05
01B6C:  MOVWF  01
01B6E:  CLRF   00
01B70:  DECFSZ 00,F
01B72:  BRA    1B70
01B74:  DECFSZ 01,F
01B76:  BRA    1B6E
01B78:  MOVLW  2E
01B7A:  MOVWF  00
01B7C:  DECFSZ 00,F
01B7E:  BRA    1B7C
01B80:  BRA    1B82
01B82:  DECFSZ FEF,F
01B84:  BRA    1B6A
01B86:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
03F62:  BTFSS  FA6.4
03F64:  GOTO   3F62
03F68:  MOVLB  F
03F6A:  MOVWF  x29
03F6C:  MOVLB  0
03F6E:  GOTO   3FA4 (RETURN)
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01B88:  BCF    F93.6
01B8A:  BCF    F8A.6
01B8C:  MOVLW  08
01B8E:  MOVWF  01
01B90:  BRA    1B92
01B92:  NOP   
01B94:  BSF    01.7
01B96:  GOTO   1BBE
01B9A:  BCF    01.7
01B9C:  MOVLB  A
01B9E:  RRCF   xAD,F
01BA0:  MOVLB  0
01BA2:  BTFSC  FD8.0
01BA4:  BSF    F8A.6
01BA6:  BTFSS  FD8.0
01BA8:  BCF    F8A.6
01BAA:  BSF    01.6
01BAC:  GOTO   1BBE
01BB0:  BCF    01.6
01BB2:  DECFSZ 01,F
01BB4:  GOTO   1B9C
01BB8:  BRA    1BBA
01BBA:  NOP   
01BBC:  BSF    F8A.6
01BBE:  MOVLW  84
01BC0:  MOVWF  FE9
01BC2:  DECFSZ FE9,F
01BC4:  GOTO   1BC2
01BC8:  BRA    1BCA
01BCA:  NOP   
01BCC:  BTFSC  01.7
01BCE:  GOTO   1B9A
01BD2:  BTFSC  01.6
01BD4:  GOTO   1BB0
01BD8:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
02444:  MOVLB  A
02446:  MOVF   x91,W
02448:  SUBLW  08
0244A:  BTFSS  FD8.2
0244C:  BRA    2454
0244E:  MOVLB  0
02450:  GOTO   246C
02454:  MOVWF  x93
02456:  MOVLB  0
02458:  MOVLB  A
0245A:  RLCF   x90,F
0245C:  DECFSZ x93,F
0245E:  BRA    2464
02460:  BRA    246A
02462:  MOVLB  0
02464:  MOVLB  0
02466:  GOTO   2458
0246A:  MOVLB  0
0246C:  BSF    F92.1
0246E:  BCF    F92.0
02470:  BCF    F92.3
02472:  BCF    F89.3
02474:  MOVFF  A91,A93
02478:  MOVLB  A
0247A:  BTFSS  x90.7
0247C:  BCF    F89.0
0247E:  BTFSC  x90.7
02480:  BSF    F89.0
02482:  RLCF   x90,F
02484:  BSF    F89.3
02486:  MOVLW  02
02488:  MOVWF  x94
0248A:  MOVLB  0
0248C:  MOVLB  A
0248E:  DECFSZ x94,F
02490:  BRA    2496
02492:  BRA    249C
02494:  MOVLB  0
02496:  MOVLB  0
02498:  GOTO   248C
0249C:  RLCF   01,F
0249E:  BTFSS  F80.1
024A0:  BCF    01.0
024A2:  BTFSC  F80.1
024A4:  BSF    01.0
024A6:  BCF    F89.3
024A8:  MOVLB  0
024AA:  BRA    24AC
024AC:  MOVLB  A
024AE:  DECFSZ x93,F
024B0:  BRA    24B6
024B2:  BRA    24BC
024B4:  MOVLB  0
024B6:  MOVLB  0
024B8:  GOTO   2478
024BC:  MOVLB  0
024BE:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
023C8:  MOVLB  A
023CA:  MOVF   x91,W
023CC:  SUBLW  08
023CE:  BTFSS  FD8.2
023D0:  BRA    23D8
023D2:  MOVLB  0
023D4:  GOTO   23F0
023D8:  MOVWF  x93
023DA:  MOVLB  0
023DC:  MOVLB  A
023DE:  RLCF   x90,F
023E0:  DECFSZ x93,F
023E2:  BRA    23E8
023E4:  BRA    23EE
023E6:  MOVLB  0
023E8:  MOVLB  0
023EA:  GOTO   23DC
023EE:  MOVLB  0
023F0:  BSF    F96.0
023F2:  BCF    F96.6
023F4:  BCF    F96.1
023F6:  BCF    F8D.1
023F8:  MOVFF  A91,A93
023FC:  MOVLB  A
023FE:  BTFSS  x90.7
02400:  BCF    F8D.6
02402:  BTFSC  x90.7
02404:  BSF    F8D.6
02406:  RLCF   x90,F
02408:  BSF    F8D.1
0240A:  MOVLW  02
0240C:  MOVWF  x94
0240E:  MOVLB  0
02410:  MOVLB  A
02412:  DECFSZ x94,F
02414:  BRA    241A
02416:  BRA    2420
02418:  MOVLB  0
0241A:  MOVLB  0
0241C:  GOTO   2410
02420:  RLCF   01,F
02422:  BTFSS  F84.0
02424:  BCF    01.0
02426:  BTFSC  F84.0
02428:  BSF    01.0
0242A:  BCF    F8D.1
0242C:  MOVLB  0
0242E:  BRA    2430
02430:  MOVLB  A
02432:  DECFSZ x93,F
02434:  BRA    243A
02436:  BRA    2440
02438:  MOVLB  0
0243A:  MOVLB  0
0243C:  GOTO   23FC
02440:  MOVLB  0
02442:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01D64:  MOVLB  9
01D66:  MOVF   xE0,W
01D68:  SUBLW  10
01D6A:  BTFSS  FD8.2
01D6C:  BRA    1D74
01D6E:  MOVLB  0
01D70:  GOTO   1D8E
01D74:  MOVWF  xE2
01D76:  MOVLB  0
01D78:  MOVLB  9
01D7A:  RLCF   xDE,F
01D7C:  RLCF   xDF,F
01D7E:  DECFSZ xE2,F
01D80:  BRA    1D86
01D82:  BRA    1D8C
01D84:  MOVLB  0
01D86:  MOVLB  0
01D88:  GOTO   1D78
01D8C:  MOVLB  0
01D8E:  BSF    F93.4
01D90:  BCF    F93.5
01D92:  BCF    F93.2
01D94:  BSF    F8A.2
01D96:  MOVFF  9E0,9E2
01D9A:  MOVLB  9
01D9C:  BTFSS  xDF.7
01D9E:  BCF    F8A.5
01DA0:  BTFSC  xDF.7
01DA2:  BSF    F8A.5
01DA4:  RLCF   xDE,F
01DA6:  RLCF   xDF,F
01DA8:  BCF    F8A.2
01DAA:  RLCF   01,F
01DAC:  RLCF   02,F
01DAE:  BTFSS  F81.4
01DB0:  BCF    01.0
01DB2:  BTFSC  F81.4
01DB4:  BSF    01.0
01DB6:  BSF    F8A.2
01DB8:  DECFSZ xE2,F
01DBA:  BRA    1DC0
01DBC:  BRA    1DC6
01DBE:  MOVLB  0
01DC0:  MOVLB  0
01DC2:  GOTO   1D9A
01DC6:  MOVLB  0
01DC8:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/mcu/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hardware/devices/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "../core/measurement/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/storage/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../../system/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "../application/mission/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... #include "../hardware/mcu/src/timer.c"
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
*
000CA:  MOVLW  80
000CC:  MOVWF  FCF
000CE:  MOVLW  12
000D0:  MOVWF  FCE
000D2:  NOP   
....................    sec++;
000D4:  MOVLW  01
000D6:  ADDWF  20,F
000D8:  BTFSC  FD8.0
000DA:  INCF   21,F
000DC:  BTFSC  FD8.2
000DE:  INCF   22,F
000E0:  BTFSC  FD8.2
000E2:  INCF   23,F
....................    /*
....................    if (++subsec >= 100)
....................    {
....................       subsec = 0;
....................       sec++;
.................... 
....................       if (sec >= SEC_IN_A_DAY)
....................       {
....................          day++;
....................       }
....................    }*/
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01CB8:  MOVLW  EA
01CBA:  MOVWF  FF6
01CBC:  MOVLW  00
01CBE:  MOVWF  FF7
01CC0:  MOVLW  00
01CC2:  MOVWF  FF8
01CC4:  CALL   1BDA
....................    clear_interrupt(INT_TIMER1);
01CC8:  BCF    F9E.0
....................    //sec = 0;
....................    // 外部クロックをT1CKIピンから入力、プリスケーラなし
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01CCA:  MOVLW  8F
01CCC:  MOVWF  FCD
01CCE:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01CD0:  MOVLW  80
01CD2:  MOVWF  FCF
01CD4:  MOVLW  12
01CD6:  MOVWF  FCE
01CD8:  NOP   
....................    //set_timer1(0);  // タイマーカウント初期値設定
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);   
01CDA:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01CDC:  MOVLW  C0
01CDE:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CE0:  MOVLW  FE
01CE2:  MOVWF  FF6
01CE4:  MOVLW  00
01CE6:  MOVWF  FF7
01CE8:  MOVLW  00
01CEA:  MOVWF  FF8
01CEC:  CALL   1BDA
01CF0:  GOTO   B6F0 (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
031DC:  MOVFF  20,00
031E0:  MOVFF  21,01
031E4:  MOVFF  22,02
031E8:  MOVFF  23,03
031EC:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
*
06528:  BCF    FD8.1
0652A:  MOVFF  1F,9DA
0652E:  MOVFF  1E,9D9
06532:  MOVFF  1D,9D8
06536:  MOVFF  1C,9D7
0653A:  MOVLB  9
0653C:  CLRF   xDE
0653E:  CLRF   xDD
06540:  CLRF   xDC
06542:  MOVLW  0A
06544:  MOVWF  xDB
06546:  MOVLB  0
06548:  CALL   644E
0654C:  MOVF   01,W
0654E:  MOVWF  02
06550:  MOVF   00,W
06552:  MOVWF  01
06554:  GOTO   6570 (RETURN)
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/mcu/src/uart.c"
.................... #INT_RDA3
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  47.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   46,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   46,W
0014C:  INCF   46,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  26
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,ABE
00160:  MOVFF  FE9,ABD
00164:  GOTO   010A
00168:  MOVFF  ABE,FEA
0016C:  MOVFF  ABD,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
.................... 
....................    // fprintf(PC, "RDA Interrupt: %d bytes received\r\n", boss_receive_buffer_size);
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01C8E:  MOVLW  7A
01C90:  MOVWF  FF6
01C92:  MOVLW  01
01C94:  MOVWF  FF7
01C96:  MOVLW  00
01C98:  MOVWF  FF8
01C9A:  CALL   1BDA
....................    enable_interrupts(INT_RDA3);
01C9E:  BSF    F61.5
....................    enable_interrupts(global);
01CA0:  MOVLW  C0
01CA2:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CA4:  MOVLW  8C
01CA6:  MOVWF  FF6
01CA8:  MOVLW  01
01CAA:  MOVWF  FF7
01CAC:  MOVLW  00
01CAE:  MOVWF  FF8
01CB0:  CALL   1BDA
01CB4:  GOTO   B6EC (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
03F24:  MOVFF  187,03
03F28:  MOVLB  1
03F2A:  MOVF   x86,W
03F2C:  MOVWF  FE9
03F2E:  MOVFF  03,FEA
03F32:  MOVFF  FEF,188
03F36:  MOVFF  185,FEA
03F3A:  MOVFF  184,FE9
03F3E:  CLRF   00
03F40:  CLRF   02
03F42:  MOVFF  188,01
03F46:  MOVLB  0
03F48:  CALL   27BC
....................    *receive_signal_size = 0;
03F4C:  MOVFF  187,03
03F50:  MOVLB  1
03F52:  MOVF   x86,W
03F54:  MOVWF  FE9
03F56:  MOVFF  03,FEA
03F5A:  CLRF   FEF
03F5C:  MOVLB  0
03F5E:  GOTO   B792 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/ad7490_driver.c"
.................... #include "../ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01ECE:  MOVLW  98
01ED0:  MOVWF  FF6
01ED2:  MOVLW  01
01ED4:  MOVWF  FF7
01ED6:  MOVLW  00
01ED8:  MOVWF  FF8
01EDA:  CALL   1BDA
....................     output_high(ADC_CS); // Set CS pin high to deselect the ADC
01EDE:  MOVLW  F4
01EE0:  MOVWF  F93
01EE2:  BSF    F8A.1
....................     delay_ms(10); // Wait for the ADC to stabilize
01EE4:  MOVLW  0A
01EE6:  MOVLB  A
01EE8:  MOVWF  x6E
01EEA:  MOVLB  0
01EEC:  CALL   1B5A
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR); // Read a dummy value to initialize the ADC
01EF0:  MOVLW  05
01EF2:  MOVLB  9
01EF4:  MOVWF  xD7
01EF6:  MOVLB  0
01EF8:  CALL   1DCA
01EFC:  MOVFF  02,185
01F00:  MOVFF  01,184
....................     delay_ms(1); // Wait for the ADC to stabilize after reading
01F04:  MOVLW  01
01F06:  MOVLB  A
01F08:  MOVWF  x6E
01F0A:  MOVLB  0
01F0C:  CALL   1B5A
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01F10:  MOVLW  09
01F12:  MOVLB  A
01F14:  MOVWF  xAD
01F16:  MOVLB  0
01F18:  CALL   1B88
01F1C:  MOVFF  185,264
01F20:  MOVLW  37
01F22:  MOVLB  2
01F24:  MOVWF  x65
01F26:  MOVLB  0
01F28:  CALL   1E5E
01F2C:  MOVFF  184,264
01F30:  MOVLW  37
01F32:  MOVLB  2
01F34:  MOVWF  x65
01F36:  MOVLB  0
01F38:  CALL   1E5E
01F3C:  MOVLW  0D
01F3E:  MOVLB  A
01F40:  MOVWF  xAD
01F42:  MOVLB  0
01F44:  CALL   1B88
01F48:  MOVLW  0A
01F4A:  MOVLB  A
01F4C:  MOVWF  xAD
01F4E:  MOVLB  0
01F50:  CALL   1B88
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F54:  MOVLB  1
01F56:  INCFSZ x84,W
01F58:  BRA    1F5E
01F5A:  BRA    1F64
01F5C:  MOVLB  0
01F5E:  MOVLB  0
01F60:  GOTO   1F7C
01F64:  MOVLB  0
01F66:  MOVLB  1
01F68:  INCFSZ x85,W
01F6A:  BRA    1F70
01F6C:  BRA    1F76
01F6E:  MOVLB  0
01F70:  MOVLB  0
01F72:  GOTO   1F7C
01F76:  MOVLB  0
01F78:  GOTO   1F9C
01F7C:  MOVLB  1
01F7E:  MOVF   x84,F
01F80:  BTFSC  FD8.2
01F82:  BRA    1F8A
01F84:  MOVLB  0
01F86:  GOTO   1FB0
01F8A:  MOVLB  0
01F8C:  MOVLB  1
01F8E:  MOVF   x85,F
01F90:  BTFSC  FD8.2
01F92:  BRA    1F9A
01F94:  MOVLB  0
01F96:  GOTO   1FB0
01F9A:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01F9C:  MOVLW  AC
01F9E:  MOVWF  FF6
01FA0:  MOVLW  01
01FA2:  MOVWF  FF7
01FA4:  MOVLW  00
01FA6:  MOVWF  FF8
01FA8:  CALL   1BDA
....................     } else {
01FAC:  GOTO   1FC0
....................         fprintf(PC, "\tConnect successful\r\n");
01FB0:  MOVLW  BE
01FB2:  MOVWF  FF6
01FB4:  MOVLW  01
01FB6:  MOVWF  FF7
01FB8:  MOVLW  00
01FBA:  MOVWF  FF8
01FBC:  CALL   1BDA
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01FC0:  MOVLW  D4
01FC2:  MOVWF  FF6
01FC4:  MOVLW  01
01FC6:  MOVWF  FF7
01FC8:  MOVLW  00
01FCA:  MOVWF  FF8
01FCC:  CALL   1BDA
01FD0:  GOTO   B6F4 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01DCA:  MOVFF  9D7,9DE
01DCE:  GOTO   1CF4
01DD2:  MOVFF  02,9D9
01DD6:  MOVFF  01,9D8
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     // Send the command to the ADC
....................     output_low(ADC_CS); // Set CS pin low to select the ADC
01DDA:  MOVLW  F4
01DDC:  MOVWF  F93
01DDE:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01DE0:  MOVLW  0D
01DE2:  MOVWF  00
01DE4:  DECFSZ 00,F
01DE6:  BRA    1DE4
....................     spi_xfer(ADC_STREAM, cmd); // Dummy transfer to start communication
01DE8:  MOVFF  9D9,9DF
01DEC:  MOVFF  9D8,9DE
01DF0:  MOVLW  10
01DF2:  MOVLB  9
01DF4:  MOVWF  xE0
01DF6:  MOVLW  01
01DF8:  MOVWF  xE1
01DFA:  MOVLB  0
01DFC:  CALL   1D64
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     delay_us(10); // Wait for the ADC to process the command
01E00:  MOVLW  0D
01E02:  MOVWF  00
01E04:  DECFSZ 00,F
01E06:  BRA    1E04
....................     output_high(ADC_CS); // Set CS pin high to end communication
01E08:  MOVLW  F4
01E0A:  MOVWF  F93
01E0C:  BSF    F8A.1
....................     delay_us(10); // Wait for the ADC to process the command
01E0E:  MOVLW  0D
01E10:  MOVWF  00
01E12:  DECFSZ 00,F
01E14:  BRA    1E12
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01E16:  MOVLW  F4
01E18:  MOVWF  F93
01E1A:  BCF    F8A.1
....................     delay_us(10); // Wait for the ADC to stabilize
01E1C:  MOVLW  0D
01E1E:  MOVWF  00
01E20:  DECFSZ 00,F
01E22:  BRA    1E20
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000); // Read data from ADC
01E24:  MOVLB  9
01E26:  CLRF   xDF
01E28:  CLRF   xDE
01E2A:  MOVLW  10
01E2C:  MOVWF  xE0
01E2E:  MOVLW  01
01E30:  MOVWF  xE1
01E32:  MOVLB  0
01E34:  CALL   1D64
01E38:  MOVFF  02,9DB
01E3C:  MOVFF  01,9DA
....................     output_high(ADC_CS); 
01E40:  MOVLW  F4
01E42:  MOVWF  F93
01E44:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E46:  MOVLB  9
01E48:  MOVF   xDA,W
01E4A:  MOVWF  xDC
01E4C:  MOVF   xDB,W
01E4E:  ANDLW  0F
01E50:  MOVWF  xDD
....................     
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E52:  MOVF   xDC,W
01E54:  MOVWF  01
01E56:  MOVF   xDD,W
01E58:  MOVWF  02
01E5A:  MOVLB  0
01E5C:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../hardware/devices/src/mcp4901_driver.c"
.................... #include "../mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../system/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
021AC:  MOVLW  E0
021AE:  MOVWF  FF6
021B0:  MOVLW  01
021B2:  MOVWF  FF7
021B4:  MOVLW  00
021B6:  MOVWF  FF8
021B8:  CALL   1BDA
....................     output_high(DAC1_CS); 
021BC:  MOVLW  F4
021BE:  MOVWF  F93
021C0:  BSF    F8A.3
....................     output_high(DAC2_CS); 
021C2:  MOVLW  F4
021C4:  MOVWF  F93
021C6:  BSF    F8A.0
....................     delay_ms(10); 
021C8:  MOVLW  0A
021CA:  MOVLB  A
021CC:  MOVWF  x6E
021CE:  MOVLB  0
021D0:  CALL   1B5A
....................     mcp4901_1_write(10); 
021D4:  MOVLB  9
021D6:  CLRF   xC3
021D8:  MOVLW  0A
021DA:  MOVWF  xC2
021DC:  MOVLB  0
021DE:  CALL   2128
....................     mcp4901_2_write(10); 
021E2:  MOVLB  9
021E4:  CLRF   xC3
021E6:  MOVLW  0A
021E8:  MOVWF  xC2
021EA:  MOVLB  0
021EC:  CALL   216A
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
021F0:  MOVLW  08
021F2:  MOVLB  9
021F4:  MOVWF  xD7
021F6:  MOVLB  0
021F8:  CALL   1DCA
021FC:  MOVFF  02,185
02200:  MOVFF  01,184
....................     fprintf(PC, "%04LX\r\n", readdata);
02204:  MOVFF  185,264
02208:  MOVLW  37
0220A:  MOVLB  2
0220C:  MOVWF  x65
0220E:  MOVLB  0
02210:  CALL   1E5E
02214:  MOVFF  184,264
02218:  MOVLW  37
0221A:  MOVLB  2
0221C:  MOVWF  x65
0221E:  MOVLB  0
02220:  CALL   1E5E
02224:  MOVLW  0D
02226:  MOVLB  A
02228:  MOVWF  xAD
0222A:  MOVLB  0
0222C:  CALL   1B88
02230:  MOVLW  0A
02232:  MOVLB  A
02234:  MOVWF  xAD
02236:  MOVLB  0
02238:  CALL   1B88
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
0223C:  MOVLB  1
0223E:  INCFSZ x84,W
02240:  BRA    2246
02242:  BRA    224C
02244:  MOVLB  0
02246:  MOVLB  0
02248:  GOTO   2264
0224C:  MOVLB  0
0224E:  MOVLB  1
02250:  INCFSZ x85,W
02252:  BRA    2258
02254:  BRA    225E
02256:  MOVLB  0
02258:  MOVLB  0
0225A:  GOTO   2264
0225E:  MOVLB  0
02260:  GOTO   2284
02264:  MOVLB  1
02266:  MOVF   x84,F
02268:  BTFSC  FD8.2
0226A:  BRA    2272
0226C:  MOVLB  0
0226E:  GOTO   2298
02272:  MOVLB  0
02274:  MOVLB  1
02276:  MOVF   x85,F
02278:  BTFSC  FD8.2
0227A:  BRA    2282
0227C:  MOVLB  0
0227E:  GOTO   2298
02282:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
02284:  MOVLW  F6
02286:  MOVWF  FF6
02288:  MOVLW  01
0228A:  MOVWF  FF7
0228C:  MOVLW  00
0228E:  MOVWF  FF8
02290:  CALL   1BDA
....................     } else {
02294:  GOTO   22A8
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
02298:  MOVLW  16
0229A:  MOVWF  FF6
0229C:  MOVLW  02
0229E:  MOVWF  FF7
022A0:  MOVLW  00
022A2:  MOVWF  FF8
022A4:  CALL   1BDA
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
022A8:  MOVFF  185,264
022AC:  MOVLW  37
022AE:  MOVLB  2
022B0:  MOVWF  x65
022B2:  MOVLB  0
022B4:  CALL   1E5E
022B8:  MOVFF  184,264
022BC:  MOVLW  37
022BE:  MOVLB  2
022C0:  MOVWF  x65
022C2:  MOVLB  0
022C4:  CALL   1E5E
022C8:  MOVLW  0D
022CA:  MOVLB  A
022CC:  MOVWF  xAD
022CE:  MOVLB  0
022D0:  CALL   1B88
022D4:  MOVLW  0A
022D6:  MOVLB  A
022D8:  MOVWF  xAD
022DA:  MOVLB  0
022DC:  CALL   1B88
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
022E0:  MOVLW  09
022E2:  MOVLB  9
022E4:  MOVWF  xD7
022E6:  MOVLB  0
022E8:  CALL   1DCA
022EC:  MOVFF  02,185
022F0:  MOVFF  01,184
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
022F4:  MOVLB  1
022F6:  INCFSZ x84,W
022F8:  BRA    22FE
022FA:  BRA    2304
022FC:  MOVLB  0
022FE:  MOVLB  0
02300:  GOTO   231C
02304:  MOVLB  0
02306:  MOVLB  1
02308:  INCFSZ x85,W
0230A:  BRA    2310
0230C:  BRA    2316
0230E:  MOVLB  0
02310:  MOVLB  0
02312:  GOTO   231C
02316:  MOVLB  0
02318:  GOTO   233C
0231C:  MOVLB  1
0231E:  MOVF   x84,F
02320:  BTFSC  FD8.2
02322:  BRA    232A
02324:  MOVLB  0
02326:  GOTO   2350
0232A:  MOVLB  0
0232C:  MOVLB  1
0232E:  MOVF   x85,F
02330:  BTFSC  FD8.2
02332:  BRA    233A
02334:  MOVLB  0
02336:  GOTO   2350
0233A:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
0233C:  MOVLW  3A
0233E:  MOVWF  FF6
02340:  MOVLW  02
02342:  MOVWF  FF7
02344:  MOVLW  00
02346:  MOVWF  FF8
02348:  CALL   1BDA
....................     } else {
0234C:  GOTO   2360
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02350:  MOVLW  5A
02352:  MOVWF  FF6
02354:  MOVLW  02
02356:  MOVWF  FF7
02358:  MOVLW  00
0235A:  MOVWF  FF8
0235C:  CALL   1BDA
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02360:  MOVLW  7E
02362:  MOVWF  FF6
02364:  MOVLW  02
02366:  MOVWF  FF7
02368:  MOVLW  00
0236A:  MOVWF  FF8
0236C:  CALL   1BDA
02370:  GOTO   B6F8 (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
02128:  MOVFF  9C3,9C7
0212C:  MOVFF  9C2,9C6
02130:  CALL   1FD4
02134:  MOVFF  02,9C5
02138:  MOVFF  01,9C4
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
0213C:  MOVLW  F4
0213E:  MOVWF  F93
02140:  BCF    F8A.3
....................    delay_us(10); 
02142:  MOVLW  0D
02144:  MOVWF  00
02146:  DECFSZ 00,F
02148:  BRA    2146
....................    spi_xfer(ADCDAC_STREAM, cmd); 
0214A:  MOVFF  9C5,9DF
0214E:  MOVFF  9C4,9DE
02152:  MOVLW  10
02154:  MOVLB  9
02156:  MOVWF  xE0
02158:  MOVLW  01
0215A:  MOVWF  xE1
0215C:  MOVLB  0
0215E:  CALL   1D64
....................    output_high(DAC1_CS); 
02162:  MOVLW  F4
02164:  MOVWF  F93
02166:  BSF    F8A.3
02168:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
0216A:  MOVFF  9C3,9C7
0216E:  MOVFF  9C2,9C6
02172:  CALL   1FD4
02176:  MOVFF  02,9C5
0217A:  MOVFF  01,9C4
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
0217E:  MOVLW  F4
02180:  MOVWF  F93
02182:  BCF    F8A.0
....................    delay_us(10); 
02184:  MOVLW  0D
02186:  MOVWF  00
02188:  DECFSZ 00,F
0218A:  BRA    2188
....................    spi_xfer(ADCDAC_STREAM, cmd); 
0218C:  MOVFF  9C5,9DF
02190:  MOVFF  9C4,9DE
02194:  MOVLW  10
02196:  MOVLB  9
02198:  MOVWF  xE0
0219A:  MOVLW  01
0219C:  MOVWF  xE1
0219E:  MOVLB  0
021A0:  CALL   1D64
....................    output_high(DAC2_CS); 
021A4:  MOVLW  F4
021A6:  MOVWF  F93
021A8:  BSF    F8A.0
021AA:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01CF4:  MOVLB  9
01CF6:  BCF    xDF.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01CF8:  BCF    xDF.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01CFA:  BCF    xDF.2
....................     cmd.fields.reserved3 = 0;
01CFC:  BCF    xDF.3
....................     cmd.fields.coding = 1; 
01CFE:  BSF    xDF.4
....................     cmd.fields.range = 0; 
01D00:  BCF    xDF.5
....................     cmd.fields.weak_tri = 0; 
01D02:  BCF    xDF.6
....................     cmd.fields.shadow = 0; 
01D04:  BCF    xDF.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01D06:  BSF    xE0.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01D08:  BSF    xE0.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01D0A:  MOVF   xDE,W
01D0C:  ANDLW  01
01D0E:  MOVWF  01
01D10:  BCF    xE0.2
01D12:  BTFSC  01.0
01D14:  BSF    xE0.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01D16:  BCF    FD8.0
01D18:  RRCF   xDE,W
01D1A:  ANDLW  01
01D1C:  MOVWF  01
01D1E:  BCF    xE0.3
01D20:  BTFSC  01.0
01D22:  BSF    xE0.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01D24:  RRCF   xDE,W
01D26:  MOVWF  00
01D28:  RRCF   00,F
01D2A:  MOVLW  3F
01D2C:  ANDWF  00,F
01D2E:  MOVF   00,W
01D30:  ANDLW  01
01D32:  MOVWF  01
01D34:  BCF    xE0.4
01D36:  BTFSC  01.0
01D38:  BSF    xE0.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D3A:  RRCF   xDE,W
01D3C:  MOVWF  00
01D3E:  RRCF   00,F
01D40:  RRCF   00,F
01D42:  MOVLW  1F
01D44:  ANDWF  00,F
01D46:  MOVF   00,W
01D48:  ANDLW  01
01D4A:  MOVWF  01
01D4C:  BCF    xE0.5
01D4E:  BTFSC  01.0
01D50:  BSF    xE0.5
....................     cmd.fields.seq = 0; // Random mode
01D52:  BCF    xE0.6
....................     cmd.fields.write = 1; // Read operation
01D54:  BSF    xE0.7
.................... 
.................... 
....................     return cmd.value;
01D56:  MOVF   xDF,W
01D58:  MOVWF  01
01D5A:  MOVF   xE0,W
01D5C:  MOVWF  02
01D5E:  MOVLB  0
01D60:  GOTO   1DD2 (RETURN)
.................... }
.................... 
.................... #include "../../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
01FD4:  MOVLB  9
01FD6:  BCF    xC9.7
....................    cmd.fields.buffer = 1; // Buffer used
01FD8:  BSF    xC9.6
....................    cmd.fields.gain = 1; // Gain 1x
01FDA:  BSF    xC9.5
....................    cmd.fields.shutdown = 1; // Normal operation
01FDC:  BSF    xC9.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
01FDE:  RRCF   xC7,W
01FE0:  MOVWF  xCB
01FE2:  RRCF   xC6,W
01FE4:  MOVWF  xCA
01FE6:  RRCF   xCB,F
01FE8:  RRCF   xCA,F
01FEA:  RRCF   xCB,F
01FEC:  RRCF   xCA,F
01FEE:  RRCF   xCB,F
01FF0:  RRCF   xCA,F
01FF2:  RRCF   xCB,F
01FF4:  RRCF   xCA,F
01FF6:  RRCF   xCB,F
01FF8:  RRCF   xCA,F
01FFA:  RRCF   xCB,F
01FFC:  RRCF   xCA,F
01FFE:  MOVLW  01
02000:  ANDWF  xCB,F
02002:  MOVF   xCA,W
02004:  ANDLW  01
02006:  MOVWF  00
02008:  CLRF   03
0200A:  MOVF   00,W
0200C:  MOVWF  01
0200E:  BCF    xC9.3
02010:  BTFSC  01.0
02012:  BSF    xC9.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
02014:  RRCF   xC7,W
02016:  MOVWF  xCB
02018:  RRCF   xC6,W
0201A:  MOVWF  xCA
0201C:  RRCF   xCB,F
0201E:  RRCF   xCA,F
02020:  RRCF   xCB,F
02022:  RRCF   xCA,F
02024:  RRCF   xCB,F
02026:  RRCF   xCA,F
02028:  RRCF   xCB,F
0202A:  RRCF   xCA,F
0202C:  RRCF   xCB,F
0202E:  RRCF   xCA,F
02030:  MOVLW  03
02032:  ANDWF  xCB,F
02034:  MOVF   xCA,W
02036:  ANDLW  01
02038:  MOVWF  00
0203A:  CLRF   03
0203C:  MOVF   00,W
0203E:  MOVWF  01
02040:  BCF    xC9.2
02042:  BTFSC  01.0
02044:  BSF    xC9.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
02046:  RRCF   xC7,W
02048:  MOVWF  xCB
0204A:  RRCF   xC6,W
0204C:  MOVWF  xCA
0204E:  RRCF   xCB,F
02050:  RRCF   xCA,F
02052:  RRCF   xCB,F
02054:  RRCF   xCA,F
02056:  RRCF   xCB,F
02058:  RRCF   xCA,F
0205A:  RRCF   xCB,F
0205C:  RRCF   xCA,F
0205E:  MOVLW  07
02060:  ANDWF  xCB,F
02062:  MOVF   xCA,W
02064:  ANDLW  01
02066:  MOVWF  00
02068:  CLRF   03
0206A:  MOVF   00,W
0206C:  MOVWF  01
0206E:  BCF    xC9.1
02070:  BTFSC  01.0
02072:  BSF    xC9.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
02074:  RRCF   xC7,W
02076:  MOVWF  xCB
02078:  RRCF   xC6,W
0207A:  MOVWF  xCA
0207C:  RRCF   xCB,F
0207E:  RRCF   xCA,F
02080:  RRCF   xCB,F
02082:  RRCF   xCA,F
02084:  RRCF   xCB,F
02086:  RRCF   xCA,F
02088:  MOVLW  0F
0208A:  ANDWF  xCB,F
0208C:  MOVF   xCA,W
0208E:  ANDLW  01
02090:  MOVWF  00
02092:  CLRF   03
02094:  MOVF   00,W
02096:  MOVWF  01
02098:  BCF    xC9.0
0209A:  BTFSC  01.0
0209C:  BSF    xC9.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
0209E:  RRCF   xC7,W
020A0:  MOVWF  xCB
020A2:  RRCF   xC6,W
020A4:  MOVWF  xCA
020A6:  RRCF   xCB,F
020A8:  RRCF   xCA,F
020AA:  RRCF   xCB,F
020AC:  RRCF   xCA,F
020AE:  MOVLW  1F
020B0:  ANDWF  xCB,F
020B2:  MOVF   xCA,W
020B4:  ANDLW  01
020B6:  MOVWF  00
020B8:  CLRF   03
020BA:  MOVF   00,W
020BC:  MOVWF  01
020BE:  BCF    xC8.7
020C0:  BTFSC  01.0
020C2:  BSF    xC8.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
020C4:  RRCF   xC7,W
020C6:  MOVWF  xCB
020C8:  RRCF   xC6,W
020CA:  MOVWF  xCA
020CC:  RRCF   xCB,F
020CE:  RRCF   xCA,F
020D0:  MOVLW  3F
020D2:  ANDWF  xCB,F
020D4:  MOVF   xCA,W
020D6:  ANDLW  01
020D8:  MOVWF  00
020DA:  CLRF   03
020DC:  MOVF   00,W
020DE:  MOVWF  01
020E0:  BCF    xC8.6
020E2:  BTFSC  01.0
020E4:  BSF    xC8.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
020E6:  BCF    FD8.0
020E8:  RRCF   xC7,W
020EA:  MOVWF  xCB
020EC:  RRCF   xC6,W
020EE:  MOVWF  xCA
020F0:  MOVF   xCA,W
020F2:  ANDLW  01
020F4:  MOVWF  00
020F6:  CLRF   03
020F8:  MOVF   00,W
020FA:  MOVWF  01
020FC:  BCF    xC8.5
020FE:  BTFSC  01.0
02100:  BSF    xC8.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
02102:  MOVF   xC6,W
02104:  ANDLW  01
02106:  MOVWF  00
02108:  CLRF   03
0210A:  MOVF   00,W
0210C:  MOVWF  01
0210E:  BCF    xC8.4
02110:  BTFSC  01.0
02112:  BSF    xC8.4
....................    cmd.fields.reserved = 0; // Reserved bits
02114:  BCF    xC8.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
02116:  BCF    xC8.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
02118:  BCF    xC8.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
0211A:  BCF    xC8.0
.................... 
....................    return cmd.value;
0211C:  MOVF   xC8,W
0211E:  MOVWF  01
02120:  MOVF   xC9,W
02122:  MOVWF  02
02124:  MOVLB  0
02126:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
031EE:  MOVLB  A
031F0:  MOVF   x6E,W
031F2:  XORLW  00
031F4:  MOVLB  0
031F6:  BTFSC  FD8.2
031F8:  GOTO   3208
031FC:  XORLW  01
031FE:  BTFSC  FD8.2
03200:  GOTO   3270
03204:  GOTO   32D8
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03208:  MOVLB  A
0320A:  CLRF   x77
0320C:  CLRF   x76
0320E:  MOVLB  0
03210:  MOVLB  A
03212:  MOVF   x77,W
03214:  SUBWF  x75,W
03216:  BTFSC  FD8.0
03218:  BRA    3220
0321A:  MOVLB  0
0321C:  GOTO   326C
03220:  MOVLB  0
03222:  BTFSS  FD8.2
03224:  GOTO   323A
03228:  MOVLB  A
0322A:  MOVF   x74,W
0322C:  SUBWF  x76,W
0322E:  BTFSS  FD8.0
03230:  BRA    3238
03232:  MOVLB  0
03234:  GOTO   326C
03238:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
0323A:  MOVLB  A
0323C:  MOVF   x72,W
0323E:  ADDWF  x76,W
03240:  MOVWF  FE9
03242:  MOVF   x73,W
03244:  ADDWFC x77,W
03246:  MOVWF  FEA
03248:  MOVFF  FEF,A7A
0324C:  MOVFF  A7A,A90
03250:  MOVLW  08
03252:  MOVWF  x91
03254:  MOVLW  01
03256:  MOVWF  x92
03258:  MOVLB  0
0325A:  CALL   23C8
0325E:  MOVLB  A
03260:  INCF   x76,F
03262:  BTFSC  FD8.2
03264:  INCF   x77,F
03266:  MOVLB  0
03268:  GOTO   3210
....................          break;
0326C:  GOTO   32DC
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03270:  MOVLB  A
03272:  CLRF   x79
03274:  CLRF   x78
03276:  MOVLB  0
03278:  MOVLB  A
0327A:  MOVF   x79,W
0327C:  SUBWF  x75,W
0327E:  BTFSC  FD8.0
03280:  BRA    3288
03282:  MOVLB  0
03284:  GOTO   32D4
03288:  MOVLB  0
0328A:  BTFSS  FD8.2
0328C:  GOTO   32A2
03290:  MOVLB  A
03292:  MOVF   x74,W
03294:  SUBWF  x78,W
03296:  BTFSS  FD8.0
03298:  BRA    32A0
0329A:  MOVLB  0
0329C:  GOTO   32D4
032A0:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
032A2:  MOVLB  A
032A4:  MOVF   x72,W
032A6:  ADDWF  x78,W
032A8:  MOVWF  FE9
032AA:  MOVF   x73,W
032AC:  ADDWFC x79,W
032AE:  MOVWF  FEA
032B0:  MOVFF  FEF,A7A
032B4:  MOVFF  A7A,A90
032B8:  MOVLW  08
032BA:  MOVWF  x91
032BC:  MOVLW  01
032BE:  MOVWF  x92
032C0:  MOVLB  0
032C2:  CALL   2444
032C6:  MOVLB  A
032C8:  INCF   x78,F
032CA:  BTFSC  FD8.2
032CC:  INCF   x79,F
032CE:  MOVLB  0
032D0:  GOTO   3278
....................          break;
032D4:  GOTO   32DC
....................          
....................       default:
....................          break;
032D8:  GOTO   32DC
....................    }
....................    return;
032DC:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
024C0:  MOVLB  A
024C2:  MOVF   x74,W
024C4:  XORLW  00
024C6:  MOVLB  0
024C8:  BTFSC  FD8.2
024CA:  GOTO   24DA
024CE:  XORLW  01
024D0:  BTFSC  FD8.2
024D2:  GOTO   25E4
024D6:  GOTO   26EE
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
024DA:  MOVLB  A
024DC:  CLRF   x83
024DE:  CLRF   x82
024E0:  MOVLB  0
024E2:  MOVLB  A
024E4:  MOVF   x83,W
024E6:  SUBWF  x7B,W
024E8:  BTFSC  FD8.0
024EA:  BRA    24F2
024EC:  MOVLB  0
024EE:  GOTO   253E
024F2:  MOVLB  0
024F4:  BTFSS  FD8.2
024F6:  GOTO   250C
024FA:  MOVLB  A
024FC:  MOVF   x7A,W
024FE:  SUBWF  x82,W
02500:  BTFSS  FD8.0
02502:  BRA    250A
02504:  MOVLB  0
02506:  GOTO   253E
0250A:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
0250C:  MOVLB  A
0250E:  MOVF   x78,W
02510:  ADDWF  x82,W
02512:  MOVWF  FE9
02514:  MOVF   x79,W
02516:  ADDWFC x83,W
02518:  MOVWF  FEA
0251A:  MOVFF  FEF,A8E
0251E:  MOVFF  A8E,A90
02522:  MOVLW  08
02524:  MOVWF  x91
02526:  MOVLW  01
02528:  MOVWF  x92
0252A:  MOVLB  0
0252C:  CALL   23C8
02530:  MOVLB  A
02532:  INCF   x82,F
02534:  BTFSC  FD8.2
02536:  INCF   x83,F
02538:  MOVLB  0
0253A:  GOTO   24E2
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0253E:  MOVLB  A
02540:  CLRF   x87
02542:  CLRF   x86
02544:  CLRF   x85
02546:  CLRF   x84
02548:  MOVLB  0
0254A:  MOVLB  A
0254C:  MOVF   x87,W
0254E:  SUBWF  x81,W
02550:  BTFSC  FD8.0
02552:  BRA    255A
02554:  MOVLB  0
02556:  GOTO   25E0
0255A:  MOVLB  0
0255C:  BTFSS  FD8.2
0255E:  GOTO   25A4
02562:  MOVLB  A
02564:  MOVF   x86,W
02566:  SUBWF  x80,W
02568:  BTFSC  FD8.0
0256A:  BRA    2572
0256C:  MOVLB  0
0256E:  GOTO   25E0
02572:  MOVLB  0
02574:  BTFSS  FD8.2
02576:  GOTO   25A4
0257A:  MOVLB  A
0257C:  MOVF   x85,W
0257E:  SUBWF  x7F,W
02580:  BTFSC  FD8.0
02582:  BRA    258A
02584:  MOVLB  0
02586:  GOTO   25E0
0258A:  MOVLB  0
0258C:  BTFSS  FD8.2
0258E:  GOTO   25A4
02592:  MOVLB  A
02594:  MOVF   x7E,W
02596:  SUBWF  x84,W
02598:  BTFSS  FD8.0
0259A:  BRA    25A2
0259C:  MOVLB  0
0259E:  GOTO   25E0
025A2:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
025A4:  MOVLB  A
025A6:  MOVF   x7C,W
025A8:  ADDWF  x84,W
025AA:  MOVWF  FE9
025AC:  MOVF   x7D,W
025AE:  ADDWFC x85,W
025B0:  MOVWF  FEA
025B2:  MOVLW  02
025B4:  MOVWF  x90
025B6:  MOVLW  08
025B8:  MOVWF  x91
025BA:  MOVLW  01
025BC:  MOVWF  x92
025BE:  MOVLB  0
025C0:  CALL   23C8
025C4:  MOVFF  01,FEF
025C8:  MOVLW  01
025CA:  MOVLB  A
025CC:  ADDWF  x84,F
025CE:  BTFSC  FD8.0
025D0:  INCF   x85,F
025D2:  BTFSC  FD8.2
025D4:  INCF   x86,F
025D6:  BTFSC  FD8.2
025D8:  INCF   x87,F
025DA:  MOVLB  0
025DC:  GOTO   254A
....................          break;
025E0:  GOTO   26F2
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025E4:  MOVLB  A
025E6:  CLRF   x89
025E8:  CLRF   x88
025EA:  MOVLB  0
025EC:  MOVLB  A
025EE:  MOVF   x89,W
025F0:  SUBWF  x7B,W
025F2:  BTFSC  FD8.0
025F4:  BRA    25FC
025F6:  MOVLB  0
025F8:  GOTO   2648
025FC:  MOVLB  0
025FE:  BTFSS  FD8.2
02600:  GOTO   2616
02604:  MOVLB  A
02606:  MOVF   x7A,W
02608:  SUBWF  x88,W
0260A:  BTFSS  FD8.0
0260C:  BRA    2614
0260E:  MOVLB  0
02610:  GOTO   2648
02614:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
02616:  MOVLB  A
02618:  MOVF   x78,W
0261A:  ADDWF  x88,W
0261C:  MOVWF  FE9
0261E:  MOVF   x79,W
02620:  ADDWFC x89,W
02622:  MOVWF  FEA
02624:  MOVFF  FEF,A8E
02628:  MOVFF  A8E,A90
0262C:  MOVLW  08
0262E:  MOVWF  x91
02630:  MOVLW  01
02632:  MOVWF  x92
02634:  MOVLB  0
02636:  CALL   2444
0263A:  MOVLB  A
0263C:  INCF   x88,F
0263E:  BTFSC  FD8.2
02640:  INCF   x89,F
02642:  MOVLB  0
02644:  GOTO   25EC
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02648:  MOVLB  A
0264A:  CLRF   x8D
0264C:  CLRF   x8C
0264E:  CLRF   x8B
02650:  CLRF   x8A
02652:  MOVLB  0
02654:  MOVLB  A
02656:  MOVF   x8D,W
02658:  SUBWF  x81,W
0265A:  BTFSC  FD8.0
0265C:  BRA    2664
0265E:  MOVLB  0
02660:  GOTO   26EA
02664:  MOVLB  0
02666:  BTFSS  FD8.2
02668:  GOTO   26AE
0266C:  MOVLB  A
0266E:  MOVF   x8C,W
02670:  SUBWF  x80,W
02672:  BTFSC  FD8.0
02674:  BRA    267C
02676:  MOVLB  0
02678:  GOTO   26EA
0267C:  MOVLB  0
0267E:  BTFSS  FD8.2
02680:  GOTO   26AE
02684:  MOVLB  A
02686:  MOVF   x8B,W
02688:  SUBWF  x7F,W
0268A:  BTFSC  FD8.0
0268C:  BRA    2694
0268E:  MOVLB  0
02690:  GOTO   26EA
02694:  MOVLB  0
02696:  BTFSS  FD8.2
02698:  GOTO   26AE
0269C:  MOVLB  A
0269E:  MOVF   x7E,W
026A0:  SUBWF  x8A,W
026A2:  BTFSS  FD8.0
026A4:  BRA    26AC
026A6:  MOVLB  0
026A8:  GOTO   26EA
026AC:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
026AE:  MOVLB  A
026B0:  MOVF   x7C,W
026B2:  ADDWF  x8A,W
026B4:  MOVWF  FE9
026B6:  MOVF   x7D,W
026B8:  ADDWFC x8B,W
026BA:  MOVWF  FEA
026BC:  MOVLW  01
026BE:  MOVWF  x90
026C0:  MOVLW  08
026C2:  MOVWF  x91
026C4:  MOVLW  01
026C6:  MOVWF  x92
026C8:  MOVLB  0
026CA:  CALL   2444
026CE:  MOVFF  01,FEF
026D2:  MOVLW  01
026D4:  MOVLB  A
026D6:  ADDWF  x8A,F
026D8:  BTFSC  FD8.0
026DA:  INCF   x8B,F
026DC:  BTFSC  FD8.2
026DE:  INCF   x8C,F
026E0:  BTFSC  FD8.2
026E2:  INCF   x8D,F
026E4:  MOVLB  0
026E6:  GOTO   2654
....................          break;
026EA:  GOTO   26F2
....................    
....................          
....................       default:
....................          break;
026EE:  GOTO   26F2
....................    }
....................    return;
026F2:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
032DE:  MOVLB  A
032E0:  MOVF   x6E,W
032E2:  XORLW  00
032E4:  MOVLB  0
032E6:  BTFSC  FD8.2
032E8:  GOTO   32F8
032EC:  XORLW  01
032EE:  BTFSC  FD8.2
032F0:  GOTO   33A6
032F4:  GOTO   3454
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
032F8:  MOVLB  A
032FA:  CLRF   x79
032FC:  MOVLB  0
032FE:  MOVLB  A
03300:  MOVF   x74,W
03302:  SUBWF  x79,W
03304:  BTFSS  FD8.0
03306:  BRA    330E
03308:  MOVLB  0
0330A:  GOTO   333E
0330E:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
03310:  MOVLB  A
03312:  MOVF   x79,W
03314:  ADDWF  x72,W
03316:  MOVWF  FE9
03318:  MOVLW  00
0331A:  ADDWFC x73,W
0331C:  MOVWF  FEA
0331E:  MOVFF  FEF,A7F
03322:  MOVFF  A7F,A90
03326:  MOVLW  08
03328:  MOVWF  x91
0332A:  MOVLW  01
0332C:  MOVWF  x92
0332E:  MOVLB  0
03330:  CALL   23C8
03334:  MOVLB  A
03336:  INCF   x79,F
03338:  MOVLB  0
0333A:  GOTO   32FE
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
0333E:  MOVLB  A
03340:  CLRF   x7B
03342:  CLRF   x7A
03344:  MOVLB  0
03346:  MOVLB  A
03348:  MOVF   x7B,W
0334A:  SUBWF  x78,W
0334C:  BTFSC  FD8.0
0334E:  BRA    3356
03350:  MOVLB  0
03352:  GOTO   33A2
03356:  MOVLB  0
03358:  BTFSS  FD8.2
0335A:  GOTO   3370
0335E:  MOVLB  A
03360:  MOVF   x77,W
03362:  SUBWF  x7A,W
03364:  BTFSS  FD8.0
03366:  BRA    336E
03368:  MOVLB  0
0336A:  GOTO   33A2
0336E:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
03370:  MOVLB  A
03372:  MOVF   x75,W
03374:  ADDWF  x7A,W
03376:  MOVWF  FE9
03378:  MOVF   x76,W
0337A:  ADDWFC x7B,W
0337C:  MOVWF  FEA
0337E:  MOVFF  FEF,A7F
03382:  MOVFF  A7F,A90
03386:  MOVLW  08
03388:  MOVWF  x91
0338A:  MOVLW  01
0338C:  MOVWF  x92
0338E:  MOVLB  0
03390:  CALL   23C8
03394:  MOVLB  A
03396:  INCF   x7A,F
03398:  BTFSC  FD8.2
0339A:  INCF   x7B,F
0339C:  MOVLB  0
0339E:  GOTO   3346
....................          break;
033A2:  GOTO   3458
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
033A6:  MOVLB  A
033A8:  CLRF   x7C
033AA:  MOVLB  0
033AC:  MOVLB  A
033AE:  MOVF   x74,W
033B0:  SUBWF  x7C,W
033B2:  BTFSS  FD8.0
033B4:  BRA    33BC
033B6:  MOVLB  0
033B8:  GOTO   33EC
033BC:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
033BE:  MOVLB  A
033C0:  MOVF   x7C,W
033C2:  ADDWF  x72,W
033C4:  MOVWF  FE9
033C6:  MOVLW  00
033C8:  ADDWFC x73,W
033CA:  MOVWF  FEA
033CC:  MOVFF  FEF,A7F
033D0:  MOVFF  A7F,A90
033D4:  MOVLW  08
033D6:  MOVWF  x91
033D8:  MOVLW  01
033DA:  MOVWF  x92
033DC:  MOVLB  0
033DE:  CALL   2444
033E2:  MOVLB  A
033E4:  INCF   x7C,F
033E6:  MOVLB  0
033E8:  GOTO   33AC
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
033EC:  MOVLB  A
033EE:  CLRF   x7E
033F0:  CLRF   x7D
033F2:  MOVLB  0
033F4:  MOVLB  A
033F6:  MOVF   x7E,W
033F8:  SUBWF  x78,W
033FA:  BTFSC  FD8.0
033FC:  BRA    3404
033FE:  MOVLB  0
03400:  GOTO   3450
03404:  MOVLB  0
03406:  BTFSS  FD8.2
03408:  GOTO   341E
0340C:  MOVLB  A
0340E:  MOVF   x77,W
03410:  SUBWF  x7D,W
03412:  BTFSS  FD8.0
03414:  BRA    341C
03416:  MOVLB  0
03418:  GOTO   3450
0341C:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
0341E:  MOVLB  A
03420:  MOVF   x75,W
03422:  ADDWF  x7D,W
03424:  MOVWF  FE9
03426:  MOVF   x76,W
03428:  ADDWFC x7E,W
0342A:  MOVWF  FEA
0342C:  MOVFF  FEF,A7F
03430:  MOVFF  A7F,A90
03434:  MOVLW  08
03436:  MOVWF  x91
03438:  MOVLW  01
0343A:  MOVWF  x92
0343C:  MOVLB  0
0343E:  CALL   2444
03442:  MOVLB  A
03444:  INCF   x7D,F
03446:  BTFSC  FD8.2
03448:  INCF   x7E,F
0344A:  MOVLB  0
0344C:  GOTO   33F4
....................          break;
03450:  GOTO   3458
....................          
....................       default:
....................          break;
03454:  GOTO   3458
....................    }
....................    return;
03458:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
050C6:  MOVFF  29A,A74
050CA:  MOVLW  01
050CC:  MOVLB  A
050CE:  MOVWF  x75
050D0:  MOVLW  0F
050D2:  MOVWF  x77
050D4:  MOVLW  89
050D6:  MOVWF  x76
050D8:  MOVLB  0
050DA:  CALL   2374
050DE:  MOVFF  29A,A74
050E2:  MOVLB  A
050E4:  CLRF   x75
050E6:  MOVLW  0F
050E8:  MOVWF  x77
050EA:  MOVLW  92
050EC:  MOVWF  x76
050EE:  MOVLB  0
050F0:  CALL   2374
050F4:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
0345A:  MOVLW  05
0345C:  MOVLB  A
0345E:  MOVWF  x72
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
03460:  MOVFF  A70,A74
03464:  CLRF   x75
03466:  MOVLW  0F
03468:  MOVWF  x77
0346A:  MOVLW  89
0346C:  MOVWF  x76
0346E:  MOVLB  0
03470:  CALL   2374
03474:  MOVFF  A70,A74
03478:  MOVLB  A
0347A:  CLRF   x75
0347C:  MOVLW  0F
0347E:  MOVWF  x77
03480:  MOVLW  92
03482:  MOVWF  x76
03484:  MOVLB  0
03486:  CALL   2374
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
0348A:  MOVFF  A71,A77
0348E:  MOVFF  A70,A76
03492:  MOVFF  A6F,A75
03496:  MOVFF  A6E,A74
0349A:  MOVLW  0A
0349C:  MOVLB  A
0349E:  MOVWF  x79
034A0:  MOVLW  72
034A2:  MOVWF  x78
034A4:  CLRF   x7B
034A6:  MOVLW  01
034A8:  MOVWF  x7A
034AA:  MOVLW  0A
034AC:  MOVWF  x7D
034AE:  MOVLW  73
034B0:  MOVWF  x7C
034B2:  CLRF   x81
034B4:  CLRF   x80
034B6:  CLRF   x7F
034B8:  MOVLW  01
034BA:  MOVWF  x7E
034BC:  MOVLB  0
034BE:  CALL   24C0
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
034C2:  MOVFF  A70,A74
034C6:  MOVLW  01
034C8:  MOVLB  A
034CA:  MOVWF  x75
034CC:  MOVLW  0F
034CE:  MOVWF  x77
034D0:  MOVLW  89
034D2:  MOVWF  x76
034D4:  MOVLB  0
034D6:  CALL   2374
034DA:  MOVFF  A70,A74
034DE:  MOVLB  A
034E0:  CLRF   x75
034E2:  MOVLW  0F
034E4:  MOVWF  x77
034E6:  MOVLW  92
034E8:  MOVWF  x76
034EA:  MOVLB  0
034EC:  CALL   2374
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
034F0:  MOVLB  A
034F2:  MOVF   x73,W
034F4:  MOVWF  01
034F6:  MOVLB  0
034F8:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
040D2:  MOVLB  A
040D4:  MOVF   x57,F
040D6:  BTFSC  FD8.2
040D8:  BRA    40E0
040DA:  MOVLB  0
040DC:  GOTO   4236
040E0:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
040E2:  MOVLW  06
040E4:  MOVLB  A
040E6:  MOVWF  x5E
040E8:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
040EA:  MOVLW  D8
040EC:  MOVLB  A
040EE:  MOVWF  x5F
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
040F0:  MOVFF  A5C,A6B
040F4:  MOVFF  A5D,A6C
040F8:  CLRF   x6D
040FA:  CLRF   x6E
040FC:  MOVF   x6B,W
040FE:  MOVWF  00
04100:  CLRF   01
04102:  CLRF   02
04104:  CLRF   03
04106:  MOVFF  00,A60
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0410A:  MOVFF  A5B,A6B
0410E:  MOVFF  A5C,A6C
04112:  MOVFF  A5D,A6D
04116:  CLRF   x6E
04118:  MOVF   x6B,W
0411A:  MOVWF  00
0411C:  CLRF   01
0411E:  CLRF   02
04120:  CLRF   03
04122:  MOVFF  00,A61
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
04126:  MOVF   x5A,W
04128:  MOVWF  00
0412A:  CLRF   01
0412C:  CLRF   02
0412E:  CLRF   03
04130:  MOVFF  00,A62
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
04134:  MOVFF  A58,A74
04138:  CLRF   x75
0413A:  MOVLW  0F
0413C:  MOVWF  x77
0413E:  MOVLW  89
04140:  MOVWF  x76
04142:  MOVLB  0
04144:  CALL   2374
04148:  MOVFF  A58,A74
0414C:  MOVLB  A
0414E:  CLRF   x75
04150:  MOVLW  0F
04152:  MOVWF  x77
04154:  MOVLW  92
04156:  MOVWF  x76
04158:  MOVLB  0
0415A:  CALL   2374
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0415E:  MOVFF  A59,A71
04162:  MOVFF  A58,A70
04166:  MOVFF  A57,A6F
0416A:  MOVFF  A56,A6E
0416E:  MOVLW  0A
04170:  MOVLB  A
04172:  MOVWF  x73
04174:  MOVLW  5E
04176:  MOVWF  x72
04178:  CLRF   x75
0417A:  MOVLW  01
0417C:  MOVWF  x74
0417E:  MOVLB  0
04180:  CALL   31EE
....................       output_high(flash_stream.cs_pin);
04184:  MOVFF  A58,A74
04188:  MOVLW  01
0418A:  MOVLB  A
0418C:  MOVWF  x75
0418E:  MOVLW  0F
04190:  MOVWF  x77
04192:  MOVLW  89
04194:  MOVWF  x76
04196:  MOVLB  0
04198:  CALL   2374
0419C:  MOVFF  A58,A74
041A0:  MOVLB  A
041A2:  CLRF   x75
041A4:  MOVLW  0F
041A6:  MOVWF  x77
041A8:  MOVLW  92
041AA:  MOVWF  x76
041AC:  MOVLB  0
041AE:  CALL   2374
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
041B2:  MOVFF  A58,A74
041B6:  MOVLB  A
041B8:  CLRF   x75
041BA:  MOVLW  0F
041BC:  MOVWF  x77
041BE:  MOVLW  89
041C0:  MOVWF  x76
041C2:  MOVLB  0
041C4:  CALL   2374
041C8:  MOVFF  A58,A74
041CC:  MOVLB  A
041CE:  CLRF   x75
041D0:  MOVLW  0F
041D2:  MOVWF  x77
041D4:  MOVLW  92
041D6:  MOVWF  x76
041D8:  MOVLB  0
041DA:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
041DE:  MOVFF  A59,A71
041E2:  MOVFF  A58,A70
041E6:  MOVFF  A57,A6F
041EA:  MOVFF  A56,A6E
041EE:  MOVLW  0A
041F0:  MOVLB  A
041F2:  MOVWF  x73
041F4:  MOVLW  5F
041F6:  MOVWF  x72
041F8:  CLRF   x75
041FA:  MOVLW  04
041FC:  MOVWF  x74
041FE:  MOVLB  0
04200:  CALL   31EE
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04204:  MOVFF  A58,A74
04208:  MOVLW  01
0420A:  MOVLB  A
0420C:  MOVWF  x75
0420E:  MOVLW  0F
04210:  MOVWF  x77
04212:  MOVLW  89
04214:  MOVWF  x76
04216:  MOVLB  0
04218:  CALL   2374
0421C:  MOVFF  A58,A74
04220:  MOVLB  A
04222:  CLRF   x75
04224:  MOVLW  0F
04226:  MOVWF  x77
04228:  MOVLW  92
0422A:  MOVWF  x76
0422C:  MOVLB  0
0422E:  CALL   2374
....................    }
04232:  GOTO   43B4
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04236:  MOVLB  A
04238:  DECFSZ x57,W
0423A:  BRA    4240
0423C:  BRA    4246
0423E:  MOVLB  0
04240:  MOVLB  0
04242:  GOTO   43B4
04246:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04248:  MOVLW  06
0424A:  MOVLB  A
0424C:  MOVWF  x63
0424E:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
04250:  MOVLW  DC
04252:  MOVLB  A
04254:  MOVWF  x64
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04256:  MOVFF  A5D,A6B
0425A:  CLRF   x6C
0425C:  CLRF   x6D
0425E:  CLRF   x6E
04260:  MOVF   x6B,W
04262:  MOVWF  00
04264:  CLRF   01
04266:  CLRF   02
04268:  CLRF   03
0426A:  MOVFF  00,A65
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0426E:  MOVFF  A5C,A6B
04272:  MOVFF  A5D,A6C
04276:  CLRF   x6D
04278:  CLRF   x6E
0427A:  MOVF   x6B,W
0427C:  MOVWF  00
0427E:  CLRF   01
04280:  CLRF   02
04282:  CLRF   03
04284:  MOVFF  00,A66
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04288:  MOVFF  A5B,A6B
0428C:  MOVFF  A5C,A6C
04290:  MOVFF  A5D,A6D
04294:  CLRF   x6E
04296:  MOVF   x6B,W
04298:  MOVWF  00
0429A:  CLRF   01
0429C:  CLRF   02
0429E:  CLRF   03
042A0:  MOVFF  00,A67
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
042A4:  MOVF   x5A,W
042A6:  MOVWF  00
042A8:  CLRF   01
042AA:  CLRF   02
042AC:  CLRF   03
042AE:  MOVFF  00,A68
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
042B2:  MOVFF  A58,A74
042B6:  CLRF   x75
042B8:  MOVLW  0F
042BA:  MOVWF  x77
042BC:  MOVLW  89
042BE:  MOVWF  x76
042C0:  MOVLB  0
042C2:  CALL   2374
042C6:  MOVFF  A58,A74
042CA:  MOVLB  A
042CC:  CLRF   x75
042CE:  MOVLW  0F
042D0:  MOVWF  x77
042D2:  MOVLW  92
042D4:  MOVWF  x76
042D6:  MOVLB  0
042D8:  CALL   2374
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
042DC:  MOVFF  A59,A71
042E0:  MOVFF  A58,A70
042E4:  MOVFF  A57,A6F
042E8:  MOVFF  A56,A6E
042EC:  MOVLW  0A
042EE:  MOVLB  A
042F0:  MOVWF  x73
042F2:  MOVLW  63
042F4:  MOVWF  x72
042F6:  CLRF   x75
042F8:  MOVLW  01
042FA:  MOVWF  x74
042FC:  MOVLB  0
042FE:  CALL   31EE
....................       output_high(flash_stream.cs_pin);
04302:  MOVFF  A58,A74
04306:  MOVLW  01
04308:  MOVLB  A
0430A:  MOVWF  x75
0430C:  MOVLW  0F
0430E:  MOVWF  x77
04310:  MOVLW  89
04312:  MOVWF  x76
04314:  MOVLB  0
04316:  CALL   2374
0431A:  MOVFF  A58,A74
0431E:  MOVLB  A
04320:  CLRF   x75
04322:  MOVLW  0F
04324:  MOVWF  x77
04326:  MOVLW  92
04328:  MOVWF  x76
0432A:  MOVLB  0
0432C:  CALL   2374
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04330:  MOVFF  A58,A74
04334:  MOVLB  A
04336:  CLRF   x75
04338:  MOVLW  0F
0433A:  MOVWF  x77
0433C:  MOVLW  89
0433E:  MOVWF  x76
04340:  MOVLB  0
04342:  CALL   2374
04346:  MOVFF  A58,A74
0434A:  MOVLB  A
0434C:  CLRF   x75
0434E:  MOVLW  0F
04350:  MOVWF  x77
04352:  MOVLW  92
04354:  MOVWF  x76
04356:  MOVLB  0
04358:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
0435C:  MOVFF  A59,A71
04360:  MOVFF  A58,A70
04364:  MOVFF  A57,A6F
04368:  MOVFF  A56,A6E
0436C:  MOVLW  0A
0436E:  MOVLB  A
04370:  MOVWF  x73
04372:  MOVLW  64
04374:  MOVWF  x72
04376:  CLRF   x75
04378:  MOVLW  05
0437A:  MOVWF  x74
0437C:  MOVLB  0
0437E:  CALL   31EE
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04382:  MOVFF  A58,A74
04386:  MOVLW  01
04388:  MOVLB  A
0438A:  MOVWF  x75
0438C:  MOVLW  0F
0438E:  MOVWF  x77
04390:  MOVLW  89
04392:  MOVWF  x76
04394:  MOVLB  0
04396:  CALL   2374
0439A:  MOVFF  A58,A74
0439E:  MOVLB  A
043A0:  CLRF   x75
043A2:  MOVLW  0F
043A4:  MOVWF  x77
043A6:  MOVLW  92
043A8:  MOVWF  x76
043AA:  MOVLB  0
043AC:  CALL   2374
....................    }
043B0:  GOTO   43B4
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
043B4:  MOVLB  A
043B6:  CLRF   x69
043B8:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
043BA:  MOVFF  A59,A71
043BE:  MOVFF  A58,A70
043C2:  MOVFF  A57,A6F
043C6:  MOVFF  A56,A6E
043CA:  CALL   345A
043CE:  MOVF   01,W
043D0:  ANDLW  01
043D2:  SUBLW  01
043D4:  BTFSS  FD8.2
043D6:  GOTO   4428
....................       if(timeout_counter > 10)
043DA:  MOVLB  A
043DC:  MOVF   x69,W
043DE:  SUBLW  0A
043E0:  BTFSS  FD8.0
043E2:  BRA    43EA
043E4:  MOVLB  0
043E6:  GOTO   43FC
043EA:  MOVLB  0
....................          delay_ms(200);
043EC:  MOVLW  C8
043EE:  MOVLB  A
043F0:  MOVWF  x6E
043F2:  MOVLB  0
043F4:  CALL   1B5A
043F8:  GOTO   4408
....................       else
....................          delay_ms(10);   
043FC:  MOVLW  0A
043FE:  MOVLB  A
04400:  MOVWF  x6E
04402:  MOVLB  0
04404:  CALL   1B5A
....................       
....................       if(timeout_counter > 100){
04408:  MOVLB  A
0440A:  MOVF   x69,W
0440C:  SUBLW  64
0440E:  BTFSS  FD8.0
04410:  BRA    4418
04412:  MOVLB  0
04414:  GOTO   441E
04418:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
0441A:  GOTO   4428
....................       }  
....................       timeout_counter++;
0441E:  MOVLB  A
04420:  INCF   x69,F
04422:  MOVLB  0
04424:  GOTO   43BA
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
04428:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
0469C:  MOVLB  2
0469E:  MOVF   xE3,F
046A0:  BTFSC  FD8.2
046A2:  BRA    46AA
046A4:  MOVLB  0
046A6:  GOTO   4802
046AA:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
046AC:  MOVLW  06
046AE:  MOVLB  2
046B0:  MOVWF  xEA
046B2:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
046B4:  MOVLW  20
046B6:  MOVLB  2
046B8:  MOVWF  xEB
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
046BA:  MOVFF  2E8,2F7
046BE:  MOVFF  2E9,2F8
046C2:  CLRF   xF9
046C4:  CLRF   xFA
046C6:  MOVF   xF7,W
046C8:  MOVWF  00
046CA:  CLRF   01
046CC:  CLRF   02
046CE:  CLRF   03
046D0:  MOVFF  00,2EC
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
046D4:  MOVFF  2E7,2F7
046D8:  MOVFF  2E8,2F8
046DC:  MOVFF  2E9,2F9
046E0:  CLRF   xFA
046E2:  MOVF   xF7,W
046E4:  MOVWF  00
046E6:  CLRF   01
046E8:  CLRF   02
046EA:  CLRF   03
046EC:  MOVFF  00,2ED
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
046F0:  MOVF   xE6,W
046F2:  MOVWF  00
046F4:  CLRF   01
046F6:  CLRF   02
046F8:  CLRF   03
046FA:  MOVFF  00,2EE
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
046FE:  MOVFF  2E4,A74
04702:  MOVLB  A
04704:  CLRF   x75
04706:  MOVLW  0F
04708:  MOVWF  x77
0470A:  MOVLW  89
0470C:  MOVWF  x76
0470E:  MOVLB  0
04710:  CALL   2374
04714:  MOVFF  2E4,A74
04718:  MOVLB  A
0471A:  CLRF   x75
0471C:  MOVLW  0F
0471E:  MOVWF  x77
04720:  MOVLW  92
04722:  MOVWF  x76
04724:  MOVLB  0
04726:  CALL   2374
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0472A:  MOVFF  2E5,A71
0472E:  MOVFF  2E4,A70
04732:  MOVFF  2E3,A6F
04736:  MOVFF  2E2,A6E
0473A:  MOVLW  02
0473C:  MOVLB  A
0473E:  MOVWF  x73
04740:  MOVLW  EA
04742:  MOVWF  x72
04744:  CLRF   x75
04746:  MOVLW  01
04748:  MOVWF  x74
0474A:  MOVLB  0
0474C:  CALL   31EE
....................       output_high(flash_stream.cs_pin);
04750:  MOVFF  2E4,A74
04754:  MOVLW  01
04756:  MOVLB  A
04758:  MOVWF  x75
0475A:  MOVLW  0F
0475C:  MOVWF  x77
0475E:  MOVLW  89
04760:  MOVWF  x76
04762:  MOVLB  0
04764:  CALL   2374
04768:  MOVFF  2E4,A74
0476C:  MOVLB  A
0476E:  CLRF   x75
04770:  MOVLW  0F
04772:  MOVWF  x77
04774:  MOVLW  92
04776:  MOVWF  x76
04778:  MOVLB  0
0477A:  CALL   2374
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
0477E:  MOVFF  2E4,A74
04782:  MOVLB  A
04784:  CLRF   x75
04786:  MOVLW  0F
04788:  MOVWF  x77
0478A:  MOVLW  89
0478C:  MOVWF  x76
0478E:  MOVLB  0
04790:  CALL   2374
04794:  MOVFF  2E4,A74
04798:  MOVLB  A
0479A:  CLRF   x75
0479C:  MOVLW  0F
0479E:  MOVWF  x77
047A0:  MOVLW  92
047A2:  MOVWF  x76
047A4:  MOVLB  0
047A6:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
047AA:  MOVFF  2E5,A71
047AE:  MOVFF  2E4,A70
047B2:  MOVFF  2E3,A6F
047B6:  MOVFF  2E2,A6E
047BA:  MOVLW  02
047BC:  MOVLB  A
047BE:  MOVWF  x73
047C0:  MOVLW  EB
047C2:  MOVWF  x72
047C4:  CLRF   x75
047C6:  MOVLW  04
047C8:  MOVWF  x74
047CA:  MOVLB  0
047CC:  CALL   31EE
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
047D0:  MOVFF  2E4,A74
047D4:  MOVLW  01
047D6:  MOVLB  A
047D8:  MOVWF  x75
047DA:  MOVLW  0F
047DC:  MOVWF  x77
047DE:  MOVLW  89
047E0:  MOVWF  x76
047E2:  MOVLB  0
047E4:  CALL   2374
047E8:  MOVFF  2E4,A74
047EC:  MOVLB  A
047EE:  CLRF   x75
047F0:  MOVLW  0F
047F2:  MOVWF  x77
047F4:  MOVLW  92
047F6:  MOVWF  x76
047F8:  MOVLB  0
047FA:  CALL   2374
....................    }
047FE:  GOTO   4982
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04802:  MOVLB  2
04804:  DECFSZ xE3,W
04806:  BRA    480C
04808:  BRA    4812
0480A:  MOVLB  0
0480C:  MOVLB  0
0480E:  GOTO   4982
04812:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04814:  MOVLW  06
04816:  MOVLB  2
04818:  MOVWF  xEF
0481A:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
0481C:  MOVLW  21
0481E:  MOVLB  2
04820:  MOVWF  xF0
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04822:  MOVFF  2E9,2F7
04826:  CLRF   xF8
04828:  CLRF   xF9
0482A:  CLRF   xFA
0482C:  MOVF   xF7,W
0482E:  MOVWF  00
04830:  CLRF   01
04832:  CLRF   02
04834:  CLRF   03
04836:  MOVFF  00,2F1
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0483A:  MOVFF  2E8,2F7
0483E:  MOVFF  2E9,2F8
04842:  CLRF   xF9
04844:  CLRF   xFA
04846:  MOVF   xF7,W
04848:  MOVWF  00
0484A:  CLRF   01
0484C:  CLRF   02
0484E:  CLRF   03
04850:  MOVFF  00,2F2
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04854:  MOVFF  2E7,2F7
04858:  MOVFF  2E8,2F8
0485C:  MOVFF  2E9,2F9
04860:  CLRF   xFA
04862:  MOVF   xF7,W
04864:  MOVWF  00
04866:  CLRF   01
04868:  CLRF   02
0486A:  CLRF   03
0486C:  MOVFF  00,2F3
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
04870:  MOVF   xE6,W
04872:  MOVWF  00
04874:  CLRF   01
04876:  CLRF   02
04878:  CLRF   03
0487A:  MOVFF  00,2F4
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
0487E:  MOVFF  2E4,A74
04882:  MOVLB  A
04884:  CLRF   x75
04886:  MOVLW  0F
04888:  MOVWF  x77
0488A:  MOVLW  89
0488C:  MOVWF  x76
0488E:  MOVLB  0
04890:  CALL   2374
04894:  MOVFF  2E4,A74
04898:  MOVLB  A
0489A:  CLRF   x75
0489C:  MOVLW  0F
0489E:  MOVWF  x77
048A0:  MOVLW  92
048A2:  MOVWF  x76
048A4:  MOVLB  0
048A6:  CALL   2374
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
048AA:  MOVFF  2E5,A71
048AE:  MOVFF  2E4,A70
048B2:  MOVFF  2E3,A6F
048B6:  MOVFF  2E2,A6E
048BA:  MOVLW  02
048BC:  MOVLB  A
048BE:  MOVWF  x73
048C0:  MOVLW  EF
048C2:  MOVWF  x72
048C4:  CLRF   x75
048C6:  MOVLW  01
048C8:  MOVWF  x74
048CA:  MOVLB  0
048CC:  CALL   31EE
....................       output_high(flash_stream.cs_pin);
048D0:  MOVFF  2E4,A74
048D4:  MOVLW  01
048D6:  MOVLB  A
048D8:  MOVWF  x75
048DA:  MOVLW  0F
048DC:  MOVWF  x77
048DE:  MOVLW  89
048E0:  MOVWF  x76
048E2:  MOVLB  0
048E4:  CALL   2374
048E8:  MOVFF  2E4,A74
048EC:  MOVLB  A
048EE:  CLRF   x75
048F0:  MOVLW  0F
048F2:  MOVWF  x77
048F4:  MOVLW  92
048F6:  MOVWF  x76
048F8:  MOVLB  0
048FA:  CALL   2374
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
048FE:  MOVFF  2E4,A74
04902:  MOVLB  A
04904:  CLRF   x75
04906:  MOVLW  0F
04908:  MOVWF  x77
0490A:  MOVLW  89
0490C:  MOVWF  x76
0490E:  MOVLB  0
04910:  CALL   2374
04914:  MOVFF  2E4,A74
04918:  MOVLB  A
0491A:  CLRF   x75
0491C:  MOVLW  0F
0491E:  MOVWF  x77
04920:  MOVLW  92
04922:  MOVWF  x76
04924:  MOVLB  0
04926:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
0492A:  MOVFF  2E5,A71
0492E:  MOVFF  2E4,A70
04932:  MOVFF  2E3,A6F
04936:  MOVFF  2E2,A6E
0493A:  MOVLW  02
0493C:  MOVLB  A
0493E:  MOVWF  x73
04940:  MOVLW  F0
04942:  MOVWF  x72
04944:  CLRF   x75
04946:  MOVLW  05
04948:  MOVWF  x74
0494A:  MOVLB  0
0494C:  CALL   31EE
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04950:  MOVFF  2E4,A74
04954:  MOVLW  01
04956:  MOVLB  A
04958:  MOVWF  x75
0495A:  MOVLW  0F
0495C:  MOVWF  x77
0495E:  MOVLW  89
04960:  MOVWF  x76
04962:  MOVLB  0
04964:  CALL   2374
04968:  MOVFF  2E4,A74
0496C:  MOVLB  A
0496E:  CLRF   x75
04970:  MOVLW  0F
04972:  MOVWF  x77
04974:  MOVLW  92
04976:  MOVWF  x76
04978:  MOVLB  0
0497A:  CALL   2374
....................    }
0497E:  GOTO   4982
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04982:  MOVLB  2
04984:  CLRF   xF5
04986:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
04988:  MOVFF  2E5,A71
0498C:  MOVFF  2E4,A70
04990:  MOVFF  2E3,A6F
04994:  MOVFF  2E2,A6E
04998:  CALL   345A
0499C:  MOVF   01,W
0499E:  ANDLW  01
049A0:  SUBLW  01
049A2:  BTFSS  FD8.2
049A4:  GOTO   49F6
....................       if(timeout_counter > 10)
049A8:  MOVLB  2
049AA:  MOVF   xF5,W
049AC:  SUBLW  0A
049AE:  BTFSS  FD8.0
049B0:  BRA    49B8
049B2:  MOVLB  0
049B4:  GOTO   49CA
049B8:  MOVLB  0
....................          delay_ms(200);
049BA:  MOVLW  C8
049BC:  MOVLB  A
049BE:  MOVWF  x6E
049C0:  MOVLB  0
049C2:  CALL   1B5A
049C6:  GOTO   49D6
....................       else
....................          delay_ms(10);   
049CA:  MOVLW  0A
049CC:  MOVLB  A
049CE:  MOVWF  x6E
049D0:  MOVLB  0
049D2:  CALL   1B5A
....................       
....................       if(timeout_counter > 100){
049D6:  MOVLB  2
049D8:  MOVF   xF5,W
049DA:  SUBLW  64
049DC:  BTFSS  FD8.0
049DE:  BRA    49E6
049E0:  MOVLB  0
049E2:  GOTO   49EC
049E6:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
049E8:  GOTO   49F6
....................       }  
....................       timeout_counter++;
049EC:  MOVLB  2
049EE:  INCF   xF5,F
049F0:  MOVLB  0
049F2:  GOTO   4988
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
049F6:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
027E0:  MOVLB  2
027E2:  MOVF   xE3,F
027E4:  BTFSC  FD8.2
027E6:  BRA    27EE
027E8:  MOVLB  0
027EA:  GOTO   28E0
027EE:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
027F0:  MOVLW  03
027F2:  MOVLB  2
027F4:  MOVWF  xF0
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
027F6:  MOVFF  2E8,2FA
027FA:  MOVFF  2E9,2FB
027FE:  CLRF   xFC
02800:  CLRF   xFD
02802:  MOVF   xFA,W
02804:  MOVWF  00
02806:  CLRF   01
02808:  CLRF   02
0280A:  CLRF   03
0280C:  MOVFF  00,2F1
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
02810:  MOVFF  2E7,2FA
02814:  MOVFF  2E8,2FB
02818:  MOVFF  2E9,2FC
0281C:  CLRF   xFD
0281E:  MOVF   xFA,W
02820:  MOVWF  00
02822:  CLRF   01
02824:  CLRF   02
02826:  CLRF   03
02828:  MOVFF  00,2F2
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
0282C:  MOVF   xE6,W
0282E:  MOVWF  00
02830:  CLRF   01
02832:  CLRF   02
02834:  CLRF   03
02836:  MOVFF  00,2F3
....................             
....................       output_low(flash_stream.cs_pin);
0283A:  MOVFF  2E4,A74
0283E:  MOVLB  A
02840:  CLRF   x75
02842:  MOVLW  0F
02844:  MOVWF  x77
02846:  MOVLW  89
02848:  MOVWF  x76
0284A:  MOVLB  0
0284C:  CALL   2374
02850:  MOVFF  2E4,A74
02854:  MOVLB  A
02856:  CLRF   x75
02858:  MOVLW  0F
0285A:  MOVWF  x77
0285C:  MOVLW  92
0285E:  MOVWF  x76
02860:  MOVLB  0
02862:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
02866:  MOVFF  2E5,A77
0286A:  MOVFF  2E4,A76
0286E:  MOVFF  2E3,A75
02872:  MOVFF  2E2,A74
02876:  MOVLW  02
02878:  MOVLB  A
0287A:  MOVWF  x79
0287C:  MOVLW  F0
0287E:  MOVWF  x78
02880:  CLRF   x7B
02882:  MOVLW  04
02884:  MOVWF  x7A
02886:  MOVFF  2EB,A7D
0288A:  MOVFF  2EA,A7C
0288E:  MOVFF  2EF,A81
02892:  MOVFF  2EE,A80
02896:  MOVFF  2ED,A7F
0289A:  MOVFF  2EC,A7E
0289E:  MOVLB  0
028A0:  CALL   24C0
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
028A4:  MOVLW  02
028A6:  MOVWF  00
028A8:  DECFSZ 00,F
028AA:  BRA    28A8
028AC:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
028AE:  MOVFF  2E4,A74
028B2:  MOVLW  01
028B4:  MOVLB  A
028B6:  MOVWF  x75
028B8:  MOVLW  0F
028BA:  MOVWF  x77
028BC:  MOVLW  89
028BE:  MOVWF  x76
028C0:  MOVLB  0
028C2:  CALL   2374
028C6:  MOVFF  2E4,A74
028CA:  MOVLB  A
028CC:  CLRF   x75
028CE:  MOVLW  0F
028D0:  MOVWF  x77
028D2:  MOVLW  92
028D4:  MOVWF  x76
028D6:  MOVLB  0
028D8:  CALL   2374
....................    }
028DC:  GOTO   29F6
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
028E0:  MOVLB  2
028E2:  DECFSZ xE3,W
028E4:  BRA    28EA
028E6:  BRA    28F0
028E8:  MOVLB  0
028EA:  MOVLB  0
028EC:  GOTO   29F6
028F0:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
028F2:  MOVLW  13
028F4:  MOVLB  2
028F6:  MOVWF  xF4
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
028F8:  MOVFF  2E9,2FA
028FC:  CLRF   xFB
028FE:  CLRF   xFC
02900:  CLRF   xFD
02902:  MOVF   xFA,W
02904:  MOVWF  00
02906:  CLRF   01
02908:  CLRF   02
0290A:  CLRF   03
0290C:  MOVFF  00,2F5
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
02910:  MOVFF  2E8,2FA
02914:  MOVFF  2E9,2FB
02918:  CLRF   xFC
0291A:  CLRF   xFD
0291C:  MOVF   xFA,W
0291E:  MOVWF  00
02920:  CLRF   01
02922:  CLRF   02
02924:  CLRF   03
02926:  MOVFF  00,2F6
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0292A:  MOVFF  2E7,2FA
0292E:  MOVFF  2E8,2FB
02932:  MOVFF  2E9,2FC
02936:  CLRF   xFD
02938:  MOVF   xFA,W
0293A:  MOVWF  00
0293C:  CLRF   01
0293E:  CLRF   02
02940:  CLRF   03
02942:  MOVFF  00,2F7
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02946:  MOVF   xE6,W
02948:  MOVWF  00
0294A:  CLRF   01
0294C:  CLRF   02
0294E:  CLRF   03
02950:  MOVFF  00,2F8
....................    
....................       output_low(flash_stream.cs_pin);
02954:  MOVFF  2E4,A74
02958:  MOVLB  A
0295A:  CLRF   x75
0295C:  MOVLW  0F
0295E:  MOVWF  x77
02960:  MOVLW  89
02962:  MOVWF  x76
02964:  MOVLB  0
02966:  CALL   2374
0296A:  MOVFF  2E4,A74
0296E:  MOVLB  A
02970:  CLRF   x75
02972:  MOVLW  0F
02974:  MOVWF  x77
02976:  MOVLW  92
02978:  MOVWF  x76
0297A:  MOVLB  0
0297C:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02980:  MOVFF  2E5,A77
02984:  MOVFF  2E4,A76
02988:  MOVFF  2E3,A75
0298C:  MOVFF  2E2,A74
02990:  MOVLW  02
02992:  MOVLB  A
02994:  MOVWF  x79
02996:  MOVLW  F4
02998:  MOVWF  x78
0299A:  CLRF   x7B
0299C:  MOVLW  05
0299E:  MOVWF  x7A
029A0:  MOVFF  2EB,A7D
029A4:  MOVFF  2EA,A7C
029A8:  MOVFF  2EF,A81
029AC:  MOVFF  2EE,A80
029B0:  MOVFF  2ED,A7F
029B4:  MOVFF  2EC,A7E
029B8:  MOVLB  0
029BA:  CALL   24C0
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029BE:  MOVLW  02
029C0:  MOVWF  00
029C2:  DECFSZ 00,F
029C4:  BRA    29C2
029C6:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029C8:  MOVFF  2E4,A74
029CC:  MOVLW  01
029CE:  MOVLB  A
029D0:  MOVWF  x75
029D2:  MOVLW  0F
029D4:  MOVWF  x77
029D6:  MOVLW  89
029D8:  MOVWF  x76
029DA:  MOVLB  0
029DC:  CALL   2374
029E0:  MOVFF  2E4,A74
029E4:  MOVLB  A
029E6:  CLRF   x75
029E8:  MOVLW  0F
029EA:  MOVWF  x77
029EC:  MOVLW  92
029EE:  MOVWF  x76
029F0:  MOVLB  0
029F2:  CALL   2374
....................    }
....................    return;
029F6:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
034FA:  MOVLB  A
034FC:  MOVF   x57,F
034FE:  BTFSC  FD8.2
03500:  BRA    3508
03502:  MOVLB  0
03504:  GOTO   3676
03508:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
0350A:  MOVLW  06
0350C:  MOVLB  A
0350E:  MOVWF  x62
03510:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
03512:  MOVLW  02
03514:  MOVLB  A
03516:  MOVWF  x63
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03518:  MOVFF  A5C,A6F
0351C:  MOVFF  A5D,A70
03520:  CLRF   x71
03522:  CLRF   x72
03524:  MOVF   x6F,W
03526:  MOVWF  00
03528:  CLRF   01
0352A:  CLRF   02
0352C:  CLRF   03
0352E:  MOVFF  00,A64
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03532:  MOVFF  A5B,A6F
03536:  MOVFF  A5C,A70
0353A:  MOVFF  A5D,A71
0353E:  CLRF   x72
03540:  MOVF   x6F,W
03542:  MOVWF  00
03544:  CLRF   01
03546:  CLRF   02
03548:  CLRF   03
0354A:  MOVFF  00,A65
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
0354E:  MOVF   x5A,W
03550:  MOVWF  00
03552:  CLRF   01
03554:  CLRF   02
03556:  CLRF   03
03558:  MOVFF  00,A66
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
0355C:  MOVFF  A58,A74
03560:  CLRF   x75
03562:  MOVLW  0F
03564:  MOVWF  x77
03566:  MOVLW  89
03568:  MOVWF  x76
0356A:  MOVLB  0
0356C:  CALL   2374
03570:  MOVFF  A58,A74
03574:  MOVLB  A
03576:  CLRF   x75
03578:  MOVLW  0F
0357A:  MOVWF  x77
0357C:  MOVLW  92
0357E:  MOVWF  x76
03580:  MOVLB  0
03582:  CALL   2374
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03586:  MOVFF  A59,A71
0358A:  MOVFF  A58,A70
0358E:  MOVFF  A57,A6F
03592:  MOVFF  A56,A6E
03596:  MOVLW  0A
03598:  MOVLB  A
0359A:  MOVWF  x73
0359C:  MOVLW  62
0359E:  MOVWF  x72
035A0:  CLRF   x75
035A2:  MOVLW  01
035A4:  MOVWF  x74
035A6:  MOVLB  0
035A8:  CALL   31EE
....................       output_high(flash_stream.cs_pin);
035AC:  MOVFF  A58,A74
035B0:  MOVLW  01
035B2:  MOVLB  A
035B4:  MOVWF  x75
035B6:  MOVLW  0F
035B8:  MOVWF  x77
035BA:  MOVLW  89
035BC:  MOVWF  x76
035BE:  MOVLB  0
035C0:  CALL   2374
035C4:  MOVFF  A58,A74
035C8:  MOVLB  A
035CA:  CLRF   x75
035CC:  MOVLW  0F
035CE:  MOVWF  x77
035D0:  MOVLW  92
035D2:  MOVWF  x76
035D4:  MOVLB  0
035D6:  CALL   2374
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
035DA:  MOVFF  A58,A74
035DE:  MOVLB  A
035E0:  CLRF   x75
035E2:  MOVLW  0F
035E4:  MOVWF  x77
035E6:  MOVLW  89
035E8:  MOVWF  x76
035EA:  MOVLB  0
035EC:  CALL   2374
035F0:  MOVFF  A58,A74
035F4:  MOVLB  A
035F6:  CLRF   x75
035F8:  MOVLW  0F
035FA:  MOVWF  x77
035FC:  MOVLW  92
035FE:  MOVWF  x76
03600:  MOVLB  0
03602:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
03606:  MOVFF  A59,A71
0360A:  MOVFF  A58,A70
0360E:  MOVFF  A57,A6F
03612:  MOVFF  A56,A6E
03616:  MOVLW  0A
03618:  MOVLB  A
0361A:  MOVWF  x73
0361C:  MOVLW  63
0361E:  MOVWF  x72
03620:  MOVLW  04
03622:  MOVWF  x74
03624:  MOVFF  A5F,A76
03628:  MOVFF  A5E,A75
0362C:  MOVFF  A61,A78
03630:  MOVFF  A60,A77
03634:  MOVLB  0
03636:  CALL   32DE
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
0363A:  MOVLW  02
0363C:  MOVWF  00
0363E:  DECFSZ 00,F
03640:  BRA    363E
03642:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
03644:  MOVFF  A58,A74
03648:  MOVLW  01
0364A:  MOVLB  A
0364C:  MOVWF  x75
0364E:  MOVLW  0F
03650:  MOVWF  x77
03652:  MOVLW  89
03654:  MOVWF  x76
03656:  MOVLB  0
03658:  CALL   2374
0365C:  MOVFF  A58,A74
03660:  MOVLB  A
03662:  CLRF   x75
03664:  MOVLW  0F
03666:  MOVWF  x77
03668:  MOVLW  92
0366A:  MOVWF  x76
0366C:  MOVLB  0
0366E:  CALL   2374
....................    }
03672:  GOTO   3808
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
03676:  MOVLB  A
03678:  DECFSZ x57,W
0367A:  BRA    3680
0367C:  BRA    3686
0367E:  MOVLB  0
03680:  MOVLB  0
03682:  GOTO   3808
03686:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
03688:  MOVLW  06
0368A:  MOVLB  A
0368C:  MOVWF  x67
0368E:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
03690:  MOVLW  12
03692:  MOVLB  A
03694:  MOVWF  x68
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
03696:  MOVFF  A5D,A6F
0369A:  CLRF   x70
0369C:  CLRF   x71
0369E:  CLRF   x72
036A0:  MOVF   x6F,W
036A2:  MOVWF  00
036A4:  CLRF   01
036A6:  CLRF   02
036A8:  CLRF   03
036AA:  MOVFF  00,A69
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
036AE:  MOVFF  A5C,A6F
036B2:  MOVFF  A5D,A70
036B6:  CLRF   x71
036B8:  CLRF   x72
036BA:  MOVF   x6F,W
036BC:  MOVWF  00
036BE:  CLRF   01
036C0:  CLRF   02
036C2:  CLRF   03
036C4:  MOVFF  00,A6A
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
036C8:  MOVFF  A5B,A6F
036CC:  MOVFF  A5C,A70
036D0:  MOVFF  A5D,A71
036D4:  CLRF   x72
036D6:  MOVF   x6F,W
036D8:  MOVWF  00
036DA:  CLRF   01
036DC:  CLRF   02
036DE:  CLRF   03
036E0:  MOVFF  00,A6B
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
036E4:  MOVF   x5A,W
036E6:  MOVWF  00
036E8:  CLRF   01
036EA:  CLRF   02
036EC:  CLRF   03
036EE:  MOVFF  00,A6C
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
036F2:  MOVFF  A58,A74
036F6:  CLRF   x75
036F8:  MOVLW  0F
036FA:  MOVWF  x77
036FC:  MOVLW  89
036FE:  MOVWF  x76
03700:  MOVLB  0
03702:  CALL   2374
03706:  MOVFF  A58,A74
0370A:  MOVLB  A
0370C:  CLRF   x75
0370E:  MOVLW  0F
03710:  MOVWF  x77
03712:  MOVLW  92
03714:  MOVWF  x76
03716:  MOVLB  0
03718:  CALL   2374
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0371C:  MOVFF  A59,A71
03720:  MOVFF  A58,A70
03724:  MOVFF  A57,A6F
03728:  MOVFF  A56,A6E
0372C:  MOVLW  0A
0372E:  MOVLB  A
03730:  MOVWF  x73
03732:  MOVLW  67
03734:  MOVWF  x72
03736:  CLRF   x75
03738:  MOVLW  01
0373A:  MOVWF  x74
0373C:  MOVLB  0
0373E:  CALL   31EE
....................       output_high(flash_stream.cs_pin);
03742:  MOVFF  A58,A74
03746:  MOVLW  01
03748:  MOVLB  A
0374A:  MOVWF  x75
0374C:  MOVLW  0F
0374E:  MOVWF  x77
03750:  MOVLW  89
03752:  MOVWF  x76
03754:  MOVLB  0
03756:  CALL   2374
0375A:  MOVFF  A58,A74
0375E:  MOVLB  A
03760:  CLRF   x75
03762:  MOVLW  0F
03764:  MOVWF  x77
03766:  MOVLW  92
03768:  MOVWF  x76
0376A:  MOVLB  0
0376C:  CALL   2374
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
03770:  MOVFF  A58,A74
03774:  MOVLB  A
03776:  CLRF   x75
03778:  MOVLW  0F
0377A:  MOVWF  x77
0377C:  MOVLW  89
0377E:  MOVWF  x76
03780:  MOVLB  0
03782:  CALL   2374
03786:  MOVFF  A58,A74
0378A:  MOVLB  A
0378C:  CLRF   x75
0378E:  MOVLW  0F
03790:  MOVWF  x77
03792:  MOVLW  92
03794:  MOVWF  x76
03796:  MOVLB  0
03798:  CALL   2374
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
0379C:  MOVFF  A59,A71
037A0:  MOVFF  A58,A70
037A4:  MOVFF  A57,A6F
037A8:  MOVFF  A56,A6E
037AC:  MOVLW  0A
037AE:  MOVLB  A
037B0:  MOVWF  x73
037B2:  MOVLW  68
037B4:  MOVWF  x72
037B6:  MOVLW  05
037B8:  MOVWF  x74
037BA:  MOVFF  A5F,A76
037BE:  MOVFF  A5E,A75
037C2:  MOVFF  A61,A78
037C6:  MOVFF  A60,A77
037CA:  MOVLB  0
037CC:  CALL   32DE
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
037D0:  MOVLW  02
037D2:  MOVWF  00
037D4:  DECFSZ 00,F
037D6:  BRA    37D4
037D8:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
037DA:  MOVFF  A58,A74
037DE:  MOVLW  01
037E0:  MOVLB  A
037E2:  MOVWF  x75
037E4:  MOVLW  0F
037E6:  MOVWF  x77
037E8:  MOVLW  89
037EA:  MOVWF  x76
037EC:  MOVLB  0
037EE:  CALL   2374
037F2:  MOVFF  A58,A74
037F6:  MOVLB  A
037F8:  CLRF   x75
037FA:  MOVLW  0F
037FC:  MOVWF  x77
037FE:  MOVLW  92
03800:  MOVWF  x76
03802:  MOVLB  0
03804:  CALL   2374
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
03808:  MOVLB  A
0380A:  CLRF   x6D
0380C:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
0380E:  MOVFF  A59,A71
03812:  MOVFF  A58,A70
03816:  MOVFF  A57,A6F
0381A:  MOVFF  A56,A6E
0381E:  CALL   345A
03822:  MOVF   01,W
03824:  ANDLW  01
03826:  SUBLW  01
03828:  BTFSS  FD8.2
0382A:  GOTO   387C
....................       if(timeout_counter > 10)
0382E:  MOVLB  A
03830:  MOVF   x6D,W
03832:  SUBLW  0A
03834:  BTFSS  FD8.0
03836:  BRA    383E
03838:  MOVLB  0
0383A:  GOTO   3850
0383E:  MOVLB  0
....................          delay_ms(200);
03840:  MOVLW  C8
03842:  MOVLB  A
03844:  MOVWF  x6E
03846:  MOVLB  0
03848:  CALL   1B5A
0384C:  GOTO   385C
....................       else
....................          delay_ms(10);   
03850:  MOVLW  0A
03852:  MOVLB  A
03854:  MOVWF  x6E
03856:  MOVLB  0
03858:  CALL   1B5A
....................       
....................       if(timeout_counter > 100){
0385C:  MOVLB  A
0385E:  MOVF   x6D,W
03860:  SUBLW  64
03862:  BTFSS  FD8.0
03864:  BRA    386C
03866:  MOVLB  0
03868:  GOTO   3872
0386C:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
0386E:  GOTO   387C
....................       }  
....................       timeout_counter++;
03872:  MOVLB  A
03874:  INCF   x6D,F
03876:  MOVLB  0
03878:  GOTO   380E
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
0387C:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
026F4:  MOVLW  9F
026F6:  MOVLB  2
026F8:  MOVWF  x78
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
026FA:  MOVFF  262,A74
026FE:  MOVLB  A
02700:  CLRF   x75
02702:  MOVLW  0F
02704:  MOVWF  x77
02706:  MOVLW  89
02708:  MOVWF  x76
0270A:  MOVLB  0
0270C:  CALL   2374
02710:  MOVFF  262,A74
02714:  MOVLB  A
02716:  CLRF   x75
02718:  MOVLW  0F
0271A:  MOVWF  x77
0271C:  MOVLW  92
0271E:  MOVWF  x76
02720:  MOVLB  0
02722:  CALL   2374
....................    delay_us(10);  
02726:  MOVLW  0D
02728:  MOVWF  00
0272A:  DECFSZ 00,F
0272C:  BRA    272A
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
0272E:  MOVFF  263,A77
02732:  MOVFF  262,A76
02736:  MOVFF  261,A75
0273A:  MOVFF  260,A74
0273E:  MOVLW  02
02740:  MOVLB  A
02742:  MOVWF  x79
02744:  MOVLW  78
02746:  MOVWF  x78
02748:  CLRF   x7B
0274A:  MOVLW  01
0274C:  MOVWF  x7A
0274E:  MOVLW  02
02750:  MOVWF  x7D
02752:  MOVLW  64
02754:  MOVWF  x7C
02756:  CLRF   x81
02758:  CLRF   x80
0275A:  CLRF   x7F
0275C:  MOVLW  14
0275E:  MOVWF  x7E
02760:  MOVLB  0
02762:  CALL   24C0
....................    output_high(flash_stream.cs_pin);
02766:  MOVFF  262,A74
0276A:  MOVLW  01
0276C:  MOVLB  A
0276E:  MOVWF  x75
02770:  MOVLW  0F
02772:  MOVWF  x77
02774:  MOVLW  89
02776:  MOVWF  x76
02778:  MOVLB  0
0277A:  CALL   2374
0277E:  MOVFF  262,A74
02782:  MOVLB  A
02784:  CLRF   x75
02786:  MOVLW  0F
02788:  MOVWF  x77
0278A:  MOVLW  92
0278C:  MOVWF  x76
0278E:  MOVLB  0
02790:  CALL   2374
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
02794:  MOVLB  2
02796:  MOVF   x64,W
02798:  SUBLW  20
0279A:  BTFSC  FD8.2
0279C:  BRA    27A4
0279E:  MOVLB  0
027A0:  GOTO   27B2
027A4:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
027A6:  MOVLW  01
027A8:  MOVWF  01
027AA:  GOTO   27BA
....................    }
027AE:  GOTO   27BA
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
027B2:  MOVLW  00
027B4:  MOVWF  01
027B6:  GOTO   27BA
....................    }
027BA:  RETURN 0
.................... }
.................... 
.................... #include "../../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
029F8:  MOVLB  A
029FA:  MOVF   xAF,F
029FC:  BTFSC  FD8.2
029FE:  BRA    2A06
02A00:  MOVLB  0
02A02:  GOTO   2A10
02A06:  MOVLB  0
02A08:  MOVLW  00
02A0A:  MOVWF  01
02A0C:  GOTO   2A62
.................... 
....................    unsigned int8 crc = *frame++;
02A10:  MOVLB  A
02A12:  MOVF   xAE,W
02A14:  MOVWF  03
02A16:  MOVF   xAD,W
02A18:  INCF   xAD,F
02A1A:  BTFSC  FD8.2
02A1C:  INCF   xAE,F
02A1E:  MOVWF  FE9
02A20:  MOVFF  03,FEA
02A24:  MOVFF  FEF,AB0
02A28:  MOVLB  0
....................    while (--payload_size > 0)
02A2A:  MOVLB  A
02A2C:  DECF   xAF,F
02A2E:  MOVF   xAF,F
02A30:  BTFSS  FD8.2
02A32:  BRA    2A3A
02A34:  MOVLB  0
02A36:  GOTO   2A5A
02A3A:  MOVLB  0
....................       crc ^= *frame++;
02A3C:  MOVLB  A
02A3E:  MOVF   xAE,W
02A40:  MOVWF  03
02A42:  MOVF   xAD,W
02A44:  INCF   xAD,F
02A46:  BTFSC  FD8.2
02A48:  INCF   xAE,F
02A4A:  MOVWF  FE9
02A4C:  MOVFF  03,FEA
02A50:  MOVF   FEF,W
02A52:  XORWF  xB0,F
02A54:  MOVLB  0
02A56:  GOTO   2A2A
.................... 
....................    return crc;
02A5A:  MOVLB  A
02A5C:  MOVF   xB0,W
02A5E:  MOVWF  01
02A60:  MOVLB  0
02A62:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
09756:  MOVLW  01
09758:  MOVLB  2
0975A:  SUBWF  xE4,W
0975C:  ADDWF  xE2,W
0975E:  MOVWF  FE9
09760:  MOVLW  00
09762:  ADDWFC xE3,W
09764:  MOVWF  FEA
09766:  MOVFF  FEF,2E5
0976A:  MOVLW  01
0976C:  SUBWF  xE4,W
0976E:  MOVWF  xE7
09770:  MOVFF  2E3,AAE
09774:  MOVFF  2E2,AAD
09778:  MOVFF  2E7,AAF
0977C:  MOVLB  0
0977E:  CALL   29F8
09782:  MOVFF  01,2E6
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
09786:  MOVLB  2
09788:  MOVF   xE6,W
0978A:  SUBWF  xE5,W
0978C:  BTFSS  FD8.2
0978E:  BRA    9796
09790:  MOVLB  0
09792:  GOTO   979E
09796:  MOVLB  0
09798:  MOVLW  00
0979A:  GOTO   97A0
0979E:  MOVLW  01
097A0:  MOVWF  01
097A2:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
.................... {   
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
*
087EE:  MOVLW  8A
087F0:  MOVWF  FF6
087F2:  MOVLW  02
087F4:  MOVWF  FF7
087F6:  MOVLW  00
087F8:  MOVWF  FF8
087FA:  CALL   1BDA
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
087FE:  MOVLW  01
08800:  MOVLB  1
08802:  ADDWF  x0D,W
08804:  ANDLW  0F
08806:  MOVWF  xAD
.................... 
....................    if(next_tail == flash_queue.head_index)
08808:  MOVF   x0C,W
0880A:  SUBWF  xAD,W
0880C:  BTFSC  FD8.2
0880E:  BRA    8816
08810:  MOVLB  0
08812:  GOTO   882C
08816:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
08818:  MOVLW  A4
0881A:  MOVWF  FF6
0881C:  MOVLW  02
0881E:  MOVWF  FF7
08820:  MOVLW  00
08822:  MOVWF  FF8
08824:  CALL   1BDA
08828:  GOTO   8A4A
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
0882C:  MOVLB  1
0882E:  MOVF   x0D,W
08830:  MULLW  0C
08832:  MOVF   FF3,W
08834:  CLRF   xAF
08836:  MOVWF  xAE
08838:  MOVLW  4C
0883A:  ADDWF  xAE,W
0883C:  MOVWF  01
0883E:  MOVLW  00
08840:  ADDWFC xAF,W
08842:  MOVWF  03
08844:  MOVF   01,W
08846:  MOVWF  xB0
08848:  MOVFF  03,1B1
0884C:  MOVF   xAB,W
0884E:  MOVWF  FE9
08850:  MOVF   xAC,W
08852:  MOVWF  FEA
08854:  MOVF   FEF,W
08856:  MOVWF  xB2
08858:  MOVFF  1B1,FEA
0885C:  MOVFF  1B0,FE9
08860:  MOVFF  1B2,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
08864:  MOVF   x0D,W
08866:  MULLW  0C
08868:  MOVF   FF3,W
0886A:  CLRF   xAF
0886C:  MOVWF  xAE
0886E:  MOVLW  01
08870:  ADDWF  xAE,W
08872:  MOVWF  01
08874:  MOVLW  00
08876:  ADDWFC xAF,W
08878:  MOVWF  03
0887A:  MOVF   01,W
0887C:  ADDLW  4C
0887E:  MOVWF  01
08880:  MOVLW  00
08882:  ADDWFC 03,F
08884:  MOVF   01,W
08886:  MOVWF  xAE
08888:  MOVFF  03,1AF
0888C:  MOVLW  01
0888E:  ADDWF  xAB,W
08890:  MOVWF  FE9
08892:  MOVLW  00
08894:  ADDWFC xAC,W
08896:  MOVWF  FEA
08898:  MOVF   FEF,W
0889A:  MOVWF  xB0
0889C:  MOVFF  1AF,FEA
088A0:  MOVFF  1AE,FE9
088A4:  MOVFF  1B0,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
088A8:  MOVF   x0D,W
088AA:  MULLW  0C
088AC:  MOVF   FF3,W
088AE:  CLRF   xAF
088B0:  MOVWF  xAE
088B2:  MOVLW  02
088B4:  ADDWF  xAE,W
088B6:  MOVWF  01
088B8:  MOVLW  00
088BA:  ADDWFC xAF,W
088BC:  MOVWF  03
088BE:  MOVF   01,W
088C0:  ADDLW  4C
088C2:  MOVWF  01
088C4:  MOVLW  00
088C6:  ADDWFC 03,F
088C8:  MOVF   01,W
088CA:  MOVWF  xAE
088CC:  MOVFF  03,1AF
088D0:  MOVLW  02
088D2:  ADDWF  xAB,W
088D4:  MOVWF  FE9
088D6:  MOVLW  00
088D8:  ADDWFC xAC,W
088DA:  MOVWF  FEA
088DC:  MOVF   FEF,W
088DE:  MOVWF  xB0
088E0:  MOVFF  1AF,FEA
088E4:  MOVFF  1AE,FE9
088E8:  MOVFF  1B0,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
088EC:  MOVF   x0D,W
088EE:  MULLW  0C
088F0:  MOVF   FF3,W
088F2:  CLRF   xAF
088F4:  MOVWF  xAE
088F6:  MOVLW  03
088F8:  ADDWF  xAE,W
088FA:  MOVWF  01
088FC:  MOVLW  00
088FE:  ADDWFC xAF,W
08900:  MOVWF  03
08902:  MOVF   01,W
08904:  ADDLW  4C
08906:  MOVWF  01
08908:  MOVLW  00
0890A:  ADDWFC 03,F
0890C:  MOVF   01,W
0890E:  MOVWF  xAE
08910:  MOVFF  03,1AF
08914:  MOVLW  03
08916:  ADDWF  xAB,W
08918:  MOVWF  01
0891A:  MOVLW  00
0891C:  ADDWFC xAC,W
0891E:  MOVWF  03
08920:  MOVF   01,W
08922:  MOVWF  FE9
08924:  MOVFF  03,FEA
08928:  MOVLW  00
0892A:  BTFSC  FEF.0
0892C:  MOVLW  01
0892E:  MOVWF  01
08930:  BTFSS  01.0
08932:  BRA    893A
08934:  MOVLB  0
08936:  GOTO   894A
0893A:  MOVLB  0
0893C:  MOVFF  1AF,FEA
08940:  MOVFF  1AE,FE9
08944:  BCF    FEF.0
08946:  GOTO   8954
0894A:  MOVFF  1AF,FEA
0894E:  MOVFF  1AE,FE9
08952:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
08954:  MOVLB  1
08956:  MOVF   x0D,W
08958:  MULLW  0C
0895A:  MOVF   FF3,W
0895C:  CLRF   xAF
0895E:  MOVWF  xAE
08960:  MOVLW  04
08962:  ADDWF  xAE,W
08964:  MOVWF  01
08966:  MOVLW  00
08968:  ADDWFC xAF,W
0896A:  MOVWF  03
0896C:  MOVF   01,W
0896E:  ADDLW  4C
08970:  MOVWF  01
08972:  MOVLW  00
08974:  ADDWFC 03,F
08976:  MOVF   01,W
08978:  MOVWF  xAE
0897A:  MOVFF  03,1AF
0897E:  MOVLW  04
08980:  ADDWF  xAB,W
08982:  MOVWF  FE9
08984:  MOVLW  00
08986:  ADDWFC xAC,W
08988:  MOVWF  FEA
0898A:  MOVFF  FEF,00
0898E:  MOVFF  FEC,01
08992:  MOVFF  FEC,02
08996:  MOVFF  FEC,03
0899A:  MOVF   FED,F
0899C:  MOVF   FED,F
0899E:  MOVF   FED,F
089A0:  MOVFF  03,1B3
089A4:  MOVFF  02,1B2
089A8:  MOVFF  01,1B1
089AC:  MOVFF  00,1B0
089B0:  MOVFF  1AF,FEA
089B4:  MOVFF  1AE,FE9
089B8:  MOVFF  1B0,FEF
089BC:  MOVFF  1B1,FEC
089C0:  MOVFF  1B2,FEC
089C4:  MOVFF  1B3,FEC
089C8:  MOVF   FED,F
089CA:  MOVF   FED,F
089CC:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
089CE:  MOVF   x0D,W
089D0:  MULLW  0C
089D2:  MOVF   FF3,W
089D4:  CLRF   xAF
089D6:  MOVWF  xAE
089D8:  MOVLW  08
089DA:  ADDWF  xAE,W
089DC:  MOVWF  01
089DE:  MOVLW  00
089E0:  ADDWFC xAF,W
089E2:  MOVWF  03
089E4:  MOVF   01,W
089E6:  ADDLW  4C
089E8:  MOVWF  01
089EA:  MOVLW  00
089EC:  ADDWFC 03,F
089EE:  MOVF   01,W
089F0:  MOVWF  xAE
089F2:  MOVFF  03,1AF
089F6:  MOVLW  08
089F8:  ADDWF  xAB,W
089FA:  MOVWF  FE9
089FC:  MOVLW  00
089FE:  ADDWFC xAC,W
08A00:  MOVWF  FEA
08A02:  MOVFF  FEF,00
08A06:  MOVFF  FEC,01
08A0A:  MOVFF  FEC,02
08A0E:  MOVFF  FEC,03
08A12:  MOVF   FED,F
08A14:  MOVF   FED,F
08A16:  MOVF   FED,F
08A18:  MOVFF  03,1B3
08A1C:  MOVFF  02,1B2
08A20:  MOVFF  01,1B1
08A24:  MOVFF  00,1B0
08A28:  MOVFF  1AF,FEA
08A2C:  MOVFF  1AE,FE9
08A30:  MOVFF  1B0,FEF
08A34:  MOVFF  1B1,FEC
08A38:  MOVFF  1B2,FEC
08A3C:  MOVFF  1B3,FEC
08A40:  MOVF   FED,F
08A42:  MOVF   FED,F
08A44:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
08A46:  MOVFF  1AD,10D
08A4A:  MOVLB  0
....................    }
08A4C:  GOTO   8FE4 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
09350:  MOVLB  1
09352:  MOVF   x0D,W
09354:  SUBWF  x0C,W
09356:  BTFSC  FD8.2
09358:  BRA    9360
0935A:  MOVLB  0
0935C:  GOTO   9382
09360:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
09362:  MOVLW  BE
09364:  MOVWF  FF6
09366:  MOVLW  02
09368:  MOVWF  FF7
0936A:  MOVLW  00
0936C:  MOVWF  FF8
0936E:  CALL   1BDA
....................       return 0x00;
09372:  MOVLW  00
09374:  MOVWF  01
09376:  MOVLW  00
09378:  MOVWF  02
0937A:  GOTO   93AE
....................    }
0937E:  GOTO   93AE
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
09382:  MOVFF  10C,18B
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
09386:  MOVLW  01
09388:  MOVLB  1
0938A:  ADDWF  x0C,W
0938C:  ANDLW  0F
0938E:  MOVWF  x0C
.................... 
.................... 
....................       return &flash_queue.entries[current_head];
09390:  MOVF   x8B,W
09392:  MULLW  0C
09394:  MOVF   FF3,W
09396:  CLRF   03
09398:  ADDLW  4C
0939A:  MOVWF  01
0939C:  MOVLW  00
0939E:  ADDWFC 03,F
093A0:  MOVF   01,W
093A2:  MOVWF  01
093A4:  MOVF   03,W
093A6:  MOVWF  02
093A8:  MOVLB  0
093AA:  GOTO   93AE
....................    }
093AE:  GOTO   B002 (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
0925A:  MOVLB  1
0925C:  MOVF   x0D,W
0925E:  SUBWF  x0C,W
09260:  BTFSS  FD8.2
09262:  BRA    926A
09264:  MOVLB  0
09266:  GOTO   9272
0926A:  MOVLB  0
0926C:  MOVLW  00
0926E:  GOTO   9274
09272:  MOVLW  01
09274:  MOVWF  01
09276:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
0952E:  MOVLB  2
09530:  CLRF   x68
09532:  CLRF   x69
09534:  CLRF   x6A
09536:  CLRF   x6B
09538:  CLRF   x6C
0953A:  CLRF   x6D
0953C:  CLRF   x6E
0953E:  CLRF   x6F
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
09540:  MOVF   x67,F
09542:  BTFSC  FD8.2
09544:  BRA    954C
09546:  MOVLB  0
09548:  GOTO   9570
0954C:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
0954E:  MOVLW  06
09550:  MOVLB  2
09552:  MOVWF  x6B
09554:  MOVLW  AA
09556:  MOVWF  x6A
09558:  CLRF   x69
0955A:  CLRF   x68
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
0955C:  MOVLW  06
0955E:  MOVWF  x6F
09560:  MOVLW  AA
09562:  MOVWF  x6E
09564:  MOVLW  0F
09566:  MOVWF  x6D
09568:  SETF   x6C
0956A:  MOVLB  0
....................    }
0956C:  GOTO   9644
....................    else if (mission_id == CIGS_PICLOG_DATA)
09570:  MOVLB  2
09572:  DECFSZ x67,W
09574:  BRA    957A
09576:  BRA    9580
09578:  MOVLB  0
0957A:  MOVLB  0
0957C:  GOTO   95A6
09580:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
09582:  MOVLW  06
09584:  MOVLB  2
09586:  MOVWF  x6B
09588:  MOVLW  AA
0958A:  MOVWF  x6A
0958C:  MOVLW  10
0958E:  MOVWF  x69
09590:  CLRF   x68
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
09592:  MOVLW  06
09594:  MOVWF  x6F
09596:  MOVLW  AA
09598:  MOVWF  x6E
0959A:  MOVLW  1F
0959C:  MOVWF  x6D
0959E:  SETF   x6C
095A0:  MOVLB  0
....................    }
095A2:  GOTO   9644
....................    else if (mission_id == CIGS_ENVIRO_DATA)
095A6:  MOVLB  2
095A8:  MOVF   x67,W
095AA:  SUBLW  02
095AC:  BTFSC  FD8.2
095AE:  BRA    95B6
095B0:  MOVLB  0
095B2:  GOTO   95DC
095B6:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
095B8:  MOVLW  06
095BA:  MOVLB  2
095BC:  MOVWF  x6B
095BE:  MOVLW  AA
095C0:  MOVWF  x6A
095C2:  MOVLW  10
095C4:  MOVWF  x69
095C6:  CLRF   x68
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
095C8:  MOVLW  06
095CA:  MOVWF  x6F
095CC:  MOVLW  AA
095CE:  MOVWF  x6E
095D0:  MOVLW  1F
095D2:  MOVWF  x6D
095D4:  SETF   x6C
095D6:  MOVLB  0
....................    }
095D8:  GOTO   9644
....................    else if (mission_id == CIGS_IV_HEADER)
095DC:  MOVLB  2
095DE:  MOVF   x67,W
095E0:  SUBLW  03
095E2:  BTFSC  FD8.2
095E4:  BRA    95EC
095E6:  MOVLB  0
095E8:  GOTO   9612
095EC:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_HEADER_START_ADDRESS;
095EE:  MOVLW  06
095F0:  MOVLB  2
095F2:  MOVWF  x6B
095F4:  MOVLW  B4
095F6:  MOVWF  x6A
095F8:  MOVLW  20
095FA:  MOVWF  x69
095FC:  CLRF   x68
....................       mis_struct.end_address   = CIGS_IV1_HEADER_END_ADDRESS;
095FE:  MOVLW  06
09600:  MOVWF  x6F
09602:  MOVLW  BE
09604:  MOVWF  x6E
09606:  MOVLW  1F
09608:  MOVWF  x6D
0960A:  SETF   x6C
0960C:  MOVLB  0
....................    }
0960E:  GOTO   9644
....................    else if (mission_id == CIGS_IV_DATA)
09612:  MOVLB  2
09614:  MOVF   x67,W
09616:  SUBLW  04
09618:  BTFSC  FD8.2
0961A:  BRA    9622
0961C:  MOVLB  0
0961E:  GOTO   9644
09622:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_DATA_START_ADDRESS;
09624:  MOVLW  06
09626:  MOVLB  2
09628:  MOVWF  x6B
0962A:  MOVLW  BE
0962C:  MOVWF  x6A
0962E:  MOVLW  20
09630:  MOVWF  x69
09632:  CLRF   x68
....................       mis_struct.end_address   = CIGS_IV1_DATA_END_ADDRESS;
09634:  MOVLW  06
09636:  MOVWF  x6F
09638:  MOVLW  FE
0963A:  MOVWF  x6E
0963C:  MOVLW  2F
0963E:  MOVWF  x6D
09640:  SETF   x6C
09642:  MOVLB  0
....................    }
....................    return mis_struct;
09644:  MOVLW  68
09646:  MOVWF  01
09648:  MOVLW  02
0964A:  MOVWF  02
0964C:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
03D28:  MOVLB  1
03D2A:  CLRF   x8D
03D2C:  CLRF   x8E
03D2E:  CLRF   x8F
03D30:  CLRF   x90
03D32:  CLRF   x91
03D34:  CLRF   x92
03D36:  CLRF   x93
03D38:  CLRF   x94
03D3A:  CLRF   x95
03D3C:  CLRF   x96
03D3E:  CLRF   x97
03D40:  CLRF   x98
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
03D42:  MOVLW  D6
03D44:  MOVWF  FF6
03D46:  MOVLW  02
03D48:  MOVWF  FF7
03D4A:  MOVLW  00
03D4C:  MOVWF  FF8
03D4E:  MOVLB  0
03D50:  CALL   1BDA
....................    fprintf(PC, "\t[BOSS] >>> ");
03D54:  MOVLW  F6
03D56:  MOVWF  FF6
03D58:  MOVLW  02
03D5A:  MOVWF  FF7
03D5C:  MOVLW  00
03D5E:  MOVWF  FF8
03D60:  CALL   1BDA
....................    for (int8 i = 0; i < receive_signal_size; i++)
03D64:  MOVLB  1
03D66:  CLRF   x99
03D68:  MOVLB  0
03D6A:  MOVLB  1
03D6C:  MOVF   x8C,W
03D6E:  SUBWF  x99,W
03D70:  BTFSS  FD8.0
03D72:  BRA    3D7A
03D74:  MOVLB  0
03D76:  GOTO   3DB4
03D7A:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
03D7C:  MOVLB  1
03D7E:  MOVF   x99,W
03D80:  ADDWF  x8A,W
03D82:  MOVWF  FE9
03D84:  MOVLW  00
03D86:  ADDWFC x8B,W
03D88:  MOVWF  FEA
03D8A:  MOVFF  FEF,1A0
03D8E:  MOVFF  1A0,264
03D92:  MOVLW  37
03D94:  MOVLB  2
03D96:  MOVWF  x65
03D98:  MOVLB  0
03D9A:  CALL   1E5E
03D9E:  MOVLW  20
03DA0:  MOVLB  A
03DA2:  MOVWF  xAD
03DA4:  MOVLB  0
03DA6:  CALL   1B88
03DAA:  MOVLB  1
03DAC:  INCF   x99,F
03DAE:  MOVLB  0
03DB0:  GOTO   3D6A
....................    fprintf(PC, "\r\n");
03DB4:  MOVLW  0D
03DB6:  MOVLB  A
03DB8:  MOVWF  xAD
03DBA:  MOVLB  0
03DBC:  CALL   1B88
03DC0:  MOVLW  0A
03DC2:  MOVLB  A
03DC4:  MOVWF  xAD
03DC6:  MOVLB  0
03DC8:  CALL   1B88
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
03DCC:  MOVFF  18B,1A1
03DD0:  MOVFF  18A,1A0
03DD4:  MOVFF  18C,1A2
03DD8:  GOTO   3A20
03DDC:  MOVFF  01,19A
....................    if (frame_start_position == -1)
03DE0:  MOVLB  1
03DE2:  MOVF   x9A,W
03DE4:  SUBLW  FF
03DE6:  BTFSC  FD8.2
03DE8:  BRA    3DF0
03DEA:  MOVLB  0
03DEC:  GOTO   3DFE
03DF0:  MOVLB  0
....................       return command;
03DF2:  MOVLW  8D
03DF4:  MOVWF  01
03DF6:  MOVLW  01
03DF8:  MOVWF  02
03DFA:  GOTO   3F20
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
03DFE:  MOVLB  1
03E00:  MOVF   x9A,W
03E02:  ADDWF  x8A,W
03E04:  MOVWF  01
03E06:  MOVLW  00
03E08:  ADDWFC x8B,W
03E0A:  MOVWF  03
03E0C:  MOVF   01,W
03E0E:  MOVWF  x9B
03E10:  MOVFF  03,19C
03E14:  MOVF   x9B,W
03E16:  MOVWF  FE9
03E18:  MOVF   x9C,W
03E1A:  MOVWF  FEA
03E1C:  MOVF   FEF,W
03E1E:  ANDLW  0F
03E20:  MOVWF  x9D
03E22:  MOVFF  19D,1A0
03E26:  MOVLB  0
03E28:  GOTO   3AC8
03E2C:  MOVFF  01,19E
....................    if (content_size == -1)
03E30:  MOVLB  1
03E32:  MOVF   x9E,W
03E34:  SUBLW  FF
03E36:  BTFSC  FD8.2
03E38:  BRA    3E40
03E3A:  MOVLB  0
03E3C:  GOTO   3E4E
03E40:  MOVLB  0
....................       return command;
03E42:  MOVLW  8D
03E44:  MOVWF  01
03E46:  MOVLW  01
03E48:  MOVWF  02
03E4A:  GOTO   3F20
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
03E4E:  MOVLB  1
03E50:  MOVF   x9A,W
03E52:  SUBWF  x8C,W
03E54:  MOVWF  x9F
....................    
....................    if (!check_crc(frame, receive_frame_size))
03E56:  MOVFF  19C,1A1
03E5A:  MOVFF  19B,1A0
03E5E:  MOVFF  19F,1A2
03E62:  MOVLB  0
03E64:  GOTO   3B84
03E68:  MOVF   01,F
03E6A:  BTFSS  FD8.2
03E6C:  GOTO   3E7C
....................       return command;
03E70:  MOVLW  8D
03E72:  MOVWF  01
03E74:  MOVLW  01
03E76:  MOVWF  02
03E78:  GOTO   3F20
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
03E7C:  MOVLB  1
03E7E:  MOVF   x9B,W
03E80:  MOVWF  FE9
03E82:  MOVF   x9C,W
03E84:  MOVWF  FEA
03E86:  MOVF   FEF,W
03E88:  ANDLW  F0
03E8A:  MOVWF  00
03E8C:  SWAPF  00,W
03E8E:  MOVWF  xA0
03E90:  MOVLW  0F
03E92:  ANDWF  xA0,F
03E94:  MOVFF  1A0,1A1
03E98:  MOVLB  0
03E9A:  GOTO   3C6E
03E9E:  MOVF   01,F
03EA0:  BTFSS  FD8.2
03EA2:  GOTO   3EB2
....................       return command;
03EA6:  MOVLW  8D
03EA8:  MOVWF  01
03EAA:  MOVLW  01
03EAC:  MOVWF  02
03EAE:  GOTO   3F20
.................... 
....................    command.frame_id = frame_id;
03EB2:  MOVFF  19D,18D
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
03EB6:  MOVLW  01
03EB8:  MOVLB  1
03EBA:  ADDWF  x9B,W
03EBC:  MOVWF  01
03EBE:  MOVLW  00
03EC0:  ADDWFC x9C,W
03EC2:  MOVWF  03
03EC4:  MOVF   01,W
03EC6:  MOVWF  xA0
03EC8:  MOVFF  03,1A1
03ECC:  MOVLW  02
03ECE:  SUBWF  x9F,W
03ED0:  MOVWF  xA2
03ED2:  MOVLW  01
03ED4:  MOVWF  FEA
03ED6:  MOVLW  90
03ED8:  MOVWF  FE9
03EDA:  MOVFF  1A1,FE2
03EDE:  MOVFF  1A0,FE1
03EE2:  MOVF   xA2,W
03EE4:  MOVWF  01
03EE6:  BTFSS  FD8.2
03EE8:  BRA    3EF0
03EEA:  MOVLB  0
03EEC:  GOTO   3EFC
03EF0:  MOVLB  0
03EF2:  MOVFF  FE6,FEE
03EF6:  DECFSZ 01,F
03EF8:  GOTO   3EF2
....................    command.size = receive_frame_size-2;
03EFC:  MOVLW  02
03EFE:  MOVLB  1
03F00:  SUBWF  x9F,W
03F02:  MOVWF  x8E
....................    command.is_exist = TRUE;
03F04:  BSF    x8F.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
03F06:  MOVLW  04
03F08:  MOVWF  FF6
03F0A:  MOVLW  03
03F0C:  MOVWF  FF7
03F0E:  MOVLW  00
03F10:  MOVWF  FF8
03F12:  MOVLB  0
03F14:  CALL   1BDA
....................    return command;
03F18:  MOVLW  8D
03F1A:  MOVWF  01
03F1C:  MOVLW  01
03F1E:  MOVWF  02
03F20:  GOTO   B75C (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
03A20:  MOVLB  1
03A22:  CLRF   xA3
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
03A24:  CLRF   xA3
03A26:  MOVLB  0
03A28:  MOVLW  01
03A2A:  MOVLB  1
03A2C:  SUBWF  xA2,W
03A2E:  SUBWF  xA3,W
03A30:  BTFSS  FD8.0
03A32:  BRA    3A3A
03A34:  MOVLB  0
03A36:  GOTO   3A72
03A3A:  MOVLB  0
....................       if(receive_signal[i] == SFD)
03A3C:  MOVLB  1
03A3E:  MOVF   xA3,W
03A40:  ADDWF  xA0,W
03A42:  MOVWF  FE9
03A44:  MOVLW  00
03A46:  ADDWFC xA1,W
03A48:  MOVWF  FEA
03A4A:  MOVF   FEF,W
03A4C:  SUBLW  AA
03A4E:  BTFSC  FD8.2
03A50:  BRA    3A58
03A52:  MOVLB  0
03A54:  GOTO   3A68
03A58:  MOVLB  0
....................          return i+1;
03A5A:  MOVLW  01
03A5C:  MOVLB  1
03A5E:  ADDWF  xA3,W
03A60:  MOVWF  01
03A62:  MOVLB  0
03A64:  GOTO   3AC4
03A68:  MOVLB  1
03A6A:  INCF   xA3,F
03A6C:  MOVLB  0
03A6E:  GOTO   3A28
....................    if (receive_signal[i] == SFD)
03A72:  MOVLB  1
03A74:  MOVF   xA3,W
03A76:  ADDWF  xA0,W
03A78:  MOVWF  FE9
03A7A:  MOVLW  00
03A7C:  ADDWFC xA1,W
03A7E:  MOVWF  FEA
03A80:  MOVF   FEF,W
03A82:  SUBLW  AA
03A84:  BTFSC  FD8.2
03A86:  BRA    3A8E
03A88:  MOVLB  0
03A8A:  GOTO   3AAC
03A8E:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
03A90:  MOVLW  20
03A92:  MOVWF  FF6
03A94:  MOVLW  03
03A96:  MOVWF  FF7
03A98:  MOVLW  00
03A9A:  MOVWF  FF8
03A9C:  CALL   1BDA
....................       return -1;
03AA0:  MOVLW  FF
03AA2:  MOVWF  01
03AA4:  GOTO   3AC4
....................    }
03AA8:  GOTO   3AC4
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
03AAC:  MOVLW  36
03AAE:  MOVWF  FF6
03AB0:  MOVLW  03
03AB2:  MOVWF  FF7
03AB4:  MOVLW  00
03AB6:  MOVWF  FF8
03AB8:  CALL   1BDA
....................       return -1;
03ABC:  MOVLW  FF
03ABE:  MOVWF  01
03AC0:  GOTO   3AC4
....................    }
03AC4:  GOTO   3DDC (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
03AC8:  MOVLB  1
03ACA:  CLRF   xA1
03ACC:  MOVLB  0
03ACE:  MOVLB  1
03AD0:  MOVF   xA1,W
03AD2:  SUBLW  02
03AD4:  BTFSC  FD8.0
03AD6:  BRA    3ADE
03AD8:  MOVLB  0
03ADA:  GOTO   3B3C
03ADE:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
03AE0:  BCF    FD8.0
03AE2:  MOVLB  1
03AE4:  RLCF   xA1,W
03AE6:  CLRF   xA3
03AE8:  MOVWF  xA2
03AEA:  MOVLW  16
03AEC:  ADDWF  xA2,W
03AEE:  MOVWF  FE9
03AF0:  MOVLW  01
03AF2:  ADDWFC xA3,W
03AF4:  MOVWF  FEA
03AF6:  MOVF   FEF,W
03AF8:  SUBWF  xA0,W
03AFA:  BTFSC  FD8.2
03AFC:  BRA    3B04
03AFE:  MOVLB  0
03B00:  GOTO   3B32
03B04:  MOVLB  0
....................          return frame_ids[i].length;
03B06:  BCF    FD8.0
03B08:  MOVLB  1
03B0A:  RLCF   xA1,W
03B0C:  CLRF   xA3
03B0E:  MOVWF  xA2
03B10:  MOVLW  01
03B12:  ADDWF  xA2,W
03B14:  MOVWF  01
03B16:  MOVLW  00
03B18:  ADDWFC xA3,W
03B1A:  MOVWF  03
03B1C:  MOVF   01,W
03B1E:  ADDLW  16
03B20:  MOVWF  FE9
03B22:  MOVLW  01
03B24:  ADDWFC 03,W
03B26:  MOVWF  FEA
03B28:  MOVF   FEF,W
03B2A:  MOVWF  01
03B2C:  MOVLB  0
03B2E:  GOTO   3B80
03B32:  MOVLB  1
03B34:  INCF   xA1,F
03B36:  MOVLB  0
03B38:  GOTO   3ACE
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
03B3C:  MOVLW  48
03B3E:  MOVWF  FF6
03B40:  MOVLW  03
03B42:  MOVWF  FF7
03B44:  MOVLW  00
03B46:  MOVWF  FF8
03B48:  MOVLW  1F
03B4A:  MOVLB  9
03B4C:  MOVWF  xC6
03B4E:  MOVLB  0
03B50:  CALL   1C0A
03B54:  MOVFF  1A0,264
03B58:  MOVLW  37
03B5A:  MOVLB  2
03B5C:  MOVWF  x65
03B5E:  MOVLB  0
03B60:  CALL   1E5E
03B64:  MOVLW  0D
03B66:  MOVLB  A
03B68:  MOVWF  xAD
03B6A:  MOVLB  0
03B6C:  CALL   1B88
03B70:  MOVLW  0A
03B72:  MOVLB  A
03B74:  MOVWF  xAD
03B76:  MOVLB  0
03B78:  CALL   1B88
....................    return -1;
03B7C:  MOVLW  FF
03B7E:  MOVWF  01
03B80:  GOTO   3E2C (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
03B84:  MOVLW  01
03B86:  MOVLB  1
03B88:  SUBWF  xA2,W
03B8A:  ADDWF  xA0,W
03B8C:  MOVWF  FE9
03B8E:  MOVLW  00
03B90:  ADDWFC xA1,W
03B92:  MOVWF  FEA
03B94:  MOVFF  FEF,1A3
03B98:  MOVLW  01
03B9A:  SUBWF  xA2,W
03B9C:  MOVWF  xA5
03B9E:  MOVFF  1A1,AAE
03BA2:  MOVFF  1A0,AAD
03BA6:  MOVFF  1A5,AAF
03BAA:  MOVLB  0
03BAC:  CALL   29F8
03BB0:  MOVFF  01,1A4
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
03BB4:  MOVLB  1
03BB6:  MOVF   xA4,W
03BB8:  SUBWF  xA3,W
03BBA:  BTFSC  FD8.2
03BBC:  BRA    3BC4
03BBE:  MOVLB  0
03BC0:  GOTO   3BD2
03BC4:  MOVLB  0
....................       return TRUE;
03BC6:  MOVLW  01
03BC8:  MOVWF  01
03BCA:  GOTO   3C6A
03BCE:  GOTO   3C6A
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
03BD2:  MOVLW  6C
03BD4:  MOVWF  FF6
03BD6:  MOVLW  03
03BD8:  MOVWF  FF7
03BDA:  MOVLW  00
03BDC:  MOVWF  FF8
03BDE:  CALL   1BDA
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
03BE2:  MOVLW  7E
03BE4:  MOVWF  FF6
03BE6:  MOVLW  03
03BE8:  MOVWF  FF7
03BEA:  MOVLW  00
03BEC:  MOVWF  FF8
03BEE:  MOVLW  13
03BF0:  MOVLB  9
03BF2:  MOVWF  xC6
03BF4:  MOVLB  0
03BF6:  CALL   1C0A
03BFA:  MOVFF  1A3,264
03BFE:  MOVLW  37
03C00:  MOVLB  2
03C02:  MOVWF  x65
03C04:  MOVLB  0
03C06:  CALL   1E5E
03C0A:  MOVLW  0D
03C0C:  MOVLB  A
03C0E:  MOVWF  xAD
03C10:  MOVLB  0
03C12:  CALL   1B88
03C16:  MOVLW  0A
03C18:  MOVLB  A
03C1A:  MOVWF  xAD
03C1C:  MOVLB  0
03C1E:  CALL   1B88
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
03C22:  MOVLW  96
03C24:  MOVWF  FF6
03C26:  MOVLW  03
03C28:  MOVWF  FF7
03C2A:  MOVLW  00
03C2C:  MOVWF  FF8
03C2E:  MOVLW  13
03C30:  MOVLB  9
03C32:  MOVWF  xC6
03C34:  MOVLB  0
03C36:  CALL   1C0A
03C3A:  MOVFF  1A4,264
03C3E:  MOVLW  37
03C40:  MOVLB  2
03C42:  MOVWF  x65
03C44:  MOVLB  0
03C46:  CALL   1E5E
03C4A:  MOVLW  0D
03C4C:  MOVLB  A
03C4E:  MOVWF  xAD
03C50:  MOVLB  0
03C52:  CALL   1B88
03C56:  MOVLW  0A
03C58:  MOVLB  A
03C5A:  MOVWF  xAD
03C5C:  MOVLB  0
03C5E:  CALL   1B88
....................       return FALSE;
03C62:  MOVLW  00
03C64:  MOVWF  01
03C66:  GOTO   3C6A
....................    }
03C6A:  GOTO   3E68 (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
03C6E:  MOVLB  1
03C70:  MOVF   xA1,W
03C72:  SUBLW  0C
03C74:  BTFSC  FD8.2
03C76:  BRA    3C7E
03C78:  MOVLB  0
03C7A:  GOTO   3C8C
03C7E:  MOVLB  0
....................       return TRUE;
03C80:  MOVLW  01
03C82:  MOVWF  01
03C84:  GOTO   3D24
03C88:  GOTO   3D24
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
03C8C:  MOVLW  AE
03C8E:  MOVWF  FF6
03C90:  MOVLW  03
03C92:  MOVWF  FF7
03C94:  MOVLW  00
03C96:  MOVWF  FF8
03C98:  CALL   1BDA
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
03C9C:  MOVLW  D0
03C9E:  MOVWF  FF6
03CA0:  MOVLW  03
03CA2:  MOVWF  FF7
03CA4:  MOVLW  00
03CA6:  MOVWF  FF8
03CA8:  MOVLW  13
03CAA:  MOVLB  9
03CAC:  MOVWF  xC6
03CAE:  MOVLB  0
03CB0:  CALL   1C0A
03CB4:  MOVFF  1A1,264
03CB8:  MOVLW  37
03CBA:  MOVLB  2
03CBC:  MOVWF  x65
03CBE:  MOVLB  0
03CC0:  CALL   1E5E
03CC4:  MOVLW  0D
03CC6:  MOVLB  A
03CC8:  MOVWF  xAD
03CCA:  MOVLB  0
03CCC:  CALL   1B88
03CD0:  MOVLW  0A
03CD2:  MOVLB  A
03CD4:  MOVWF  xAD
03CD6:  MOVLB  0
03CD8:  CALL   1B88
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
03CDC:  MOVLW  E8
03CDE:  MOVWF  FF6
03CE0:  MOVLW  03
03CE2:  MOVWF  FF7
03CE4:  MOVLW  00
03CE6:  MOVWF  FF8
03CE8:  MOVLW  13
03CEA:  MOVLB  9
03CEC:  MOVWF  xC6
03CEE:  MOVLB  0
03CF0:  CALL   1C0A
03CF4:  MOVLW  0C
03CF6:  MOVLB  2
03CF8:  MOVWF  x64
03CFA:  MOVLW  37
03CFC:  MOVWF  x65
03CFE:  MOVLB  0
03D00:  CALL   1E5E
03D04:  MOVLW  0D
03D06:  MOVLB  A
03D08:  MOVWF  xAD
03D0A:  MOVLB  0
03D0C:  CALL   1B88
03D10:  MOVLW  0A
03D12:  MOVLB  A
03D14:  MOVWF  xAD
03D16:  MOVLB  0
03D18:  CALL   1B88
....................       return FALSE;  
03D1C:  MOVLW  00
03D1E:  MOVWF  01
03D20:  GOTO   3D24
....................    }
03D24:  GOTO   3E9E (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
0402A:  MOVLW  AA
0402C:  MOVLB  1
0402E:  MOVWF  x8F
....................    data[1] = (BOSS_PIC << 4) | frame_id;
04030:  MOVF   x8B,W
04032:  IORLW  50
04034:  MOVWF  x90
....................    memcpy(&data[2], content, size);
04036:  MOVLW  01
04038:  MOVWF  FEA
0403A:  MOVLW  91
0403C:  MOVWF  FE9
0403E:  MOVFF  18D,FE2
04042:  MOVFF  18C,FE1
04046:  MOVF   x8E,W
04048:  MOVWF  01
0404A:  BTFSS  FD8.2
0404C:  BRA    4054
0404E:  MOVLB  0
04050:  GOTO   4060
04054:  MOVLB  0
04056:  MOVFF  FE6,FEE
0405A:  DECFSZ 01,F
0405C:  GOTO   4056
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
04060:  MOVLW  02
04062:  MOVLB  1
04064:  ADDWF  x8E,W
04066:  MOVWF  x9F
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
04068:  CLRF   03
0406A:  MOVF   x9F,W
0406C:  ADDLW  8F
0406E:  MOVWF  01
04070:  MOVLW  01
04072:  ADDWFC 03,F
04074:  MOVF   01,W
04076:  MOVWF  xA1
04078:  MOVFF  03,1A2
0407C:  MOVLW  01
0407E:  SUBWF  x9F,W
04080:  MOVWF  xA3
04082:  MOVLW  01
04084:  MOVLB  A
04086:  MOVWF  xAE
04088:  MOVLW  90
0408A:  MOVWF  xAD
0408C:  MOVFF  1A3,AAF
04090:  MOVLB  0
04092:  CALL   29F8
04096:  MOVFF  1A2,FEA
0409A:  MOVFF  1A1,FE9
0409E:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
040A2:  MOVLW  01
040A4:  MOVLB  1
040A6:  ADDWF  x9F,W
040A8:  MOVWF  xA0
....................    
....................    transmit(data, data_size);
040AA:  MOVLW  01
040AC:  MOVWF  xA2
040AE:  MOVLW  8F
040B0:  MOVWF  xA1
040B2:  MOVFF  1A0,1A3
040B6:  MOVLB  0
040B8:  GOTO   3F72
040BC:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
03F72:  MOVLB  1
03F74:  CLRF   xA4
03F76:  MOVLB  0
03F78:  MOVLB  1
03F7A:  MOVF   xA3,W
03F7C:  SUBWF  xA4,W
03F7E:  BTFSS  FD8.0
03F80:  BRA    3F88
03F82:  MOVLB  0
03F84:  GOTO   3FAE
03F88:  MOVLB  0
....................       fputc(data[i], BOSS);
03F8A:  MOVLB  1
03F8C:  MOVF   xA4,W
03F8E:  ADDWF  xA1,W
03F90:  MOVWF  FE9
03F92:  MOVLW  00
03F94:  ADDWFC xA2,W
03F96:  MOVWF  FEA
03F98:  MOVFF  FEF,1A6
03F9C:  MOVF   xA6,W
03F9E:  MOVLB  0
03FA0:  GOTO   3F62
03FA4:  MOVLB  1
03FA6:  INCF   xA4,F
03FA8:  MOVLB  0
03FAA:  GOTO   3F78
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
03FAE:  MOVLW  00
03FB0:  MOVWF  FF6
03FB2:  MOVLW  04
03FB4:  MOVWF  FF7
03FB6:  MOVLW  00
03FB8:  MOVWF  FF8
03FBA:  CALL   1BDA
....................    for(int i = 0; i < data_size; i++)
03FBE:  MOVLB  1
03FC0:  CLRF   xA5
03FC2:  MOVLB  0
03FC4:  MOVLB  1
03FC6:  MOVF   xA3,W
03FC8:  SUBWF  xA5,W
03FCA:  BTFSS  FD8.0
03FCC:  BRA    3FD4
03FCE:  MOVLB  0
03FD0:  GOTO   400E
03FD4:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
03FD6:  MOVLB  1
03FD8:  MOVF   xA5,W
03FDA:  ADDWF  xA1,W
03FDC:  MOVWF  FE9
03FDE:  MOVLW  00
03FE0:  ADDWFC xA2,W
03FE2:  MOVWF  FEA
03FE4:  MOVFF  FEF,1A6
03FE8:  MOVFF  1A6,264
03FEC:  MOVLW  37
03FEE:  MOVLB  2
03FF0:  MOVWF  x65
03FF2:  MOVLB  0
03FF4:  CALL   1E5E
03FF8:  MOVLW  20
03FFA:  MOVLB  A
03FFC:  MOVWF  xAD
03FFE:  MOVLB  0
04000:  CALL   1B88
04004:  MOVLB  1
04006:  INCF   xA5,F
04008:  MOVLB  0
0400A:  GOTO   3FC4
....................    fprintf(PC, "\r\n");
0400E:  MOVLW  0D
04010:  MOVLB  A
04012:  MOVWF  xAD
04014:  MOVLB  0
04016:  CALL   1B88
0401A:  MOVLW  0A
0401C:  MOVLB  A
0401E:  MOVWF  xAD
04020:  MOVLB  0
04022:  CALL   1B88
04026:  GOTO   40BC (RETURN)
.................... }
.................... 
.................... #include "../../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
040BE:  MOVLW  0F
040C0:  MOVLB  1
040C2:  MOVWF  x8B
040C4:  CLRF   x8D
040C6:  CLRF   x8C
040C8:  CLRF   x8E
040CA:  MOVLB  0
040CC:  CALL   402A
040D0:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
092E0:  MOVLW  03
092E2:  MOVLB  1
092E4:  MOVWF  x8B
092E6:  CLRF   x8D
092E8:  MOVLW  48
092EA:  MOVWF  x8C
092EC:  MOVLW  04
092EE:  MOVWF  x8E
092F0:  MOVLB  0
092F2:  CALL   402A
092F6:  GOTO   931E (RETURN)
.................... }
.................... 
.................... 
.................... #include "../../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "../core/measurement/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/devices/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../storage/mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../hardware/mcu/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
01C40:  MOVLW  14
01C42:  MOVWF  FF6
01C44:  MOVLW  05
01C46:  MOVWF  FF7
01C48:  MOVLW  00
01C4A:  MOVWF  FF8
01C4C:  CALL   1BDA
....................     // output_high(ADC_CS); // ADC Chip Select
....................     output_high(MIS_FM_CS); // DAC Chip Select
01C50:  MOVLW  DB
01C52:  MOVWF  F92
01C54:  BSF    F89.5
....................     output_high(SMF_CS); // SMF Chip Select
01C56:  MOVLW  DB
01C58:  MOVWF  F92
01C5A:  BSF    F89.2
....................     output_low(CONNECT_CIGS1);
01C5C:  MOVLW  5E
01C5E:  MOVWF  F94
01C60:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
01C62:  MOVLW  5E
01C64:  MOVWF  F94
01C66:  BCF    F8B.5
....................     output_high(EN_NPWR);
01C68:  MOVLW  5E
01C6A:  MOVWF  F94
01C6C:  BSF    F8B.7
....................     delay_ms(1);
01C6E:  MOVLW  01
01C70:  MOVLB  A
01C72:  MOVWF  x6E
01C74:  MOVLB  0
01C76:  CALL   1B5A
....................     fprintf(PC, "\tComplete\r\n");
01C7A:  MOVLW  24
01C7C:  MOVWF  FF6
01C7E:  MOVLW  05
01C80:  MOVWF  FF7
01C82:  MOVLW  00
01C84:  MOVWF  FF8
01C86:  CALL   1BDA
01C8A:  GOTO   B6E8 (RETURN)
.................... }
.................... 
.................... 
.................... void test_sweep(unsigned int8 sweep_step)
.................... {
....................     fprintf(PC, "Start TEST SWEEP\r\n");
....................     output_high(CONNECT_CIGS1);
....................     output_low(EN_NPWR); // Enable power to CIGS
....................     delay_us(100); // wait for the CIGS to stabilize
....................     fprintf(PC, "step, voltage, current\r\n");
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     delay_ms(100); // wait for the DAC to stabilize
.................... 
.................... 
....................     unsigned int16 volt;
....................     unsigned int16 curr;
....................     for (unsigned int8 count = 0; count < sweep_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
.................... 
....................         volt = ad7490_read(ADC_CIGS1_AMP); // read CIGS voltage
....................         curr = ad7490_read(ADC_CIGS1_CURR); // read CIGS current
....................         
....................         fprintf(PC, "%u, %lu, %lu\r\n", count, volt, curr);
....................         delay_ms(1); // wait for the ADC to stabilize
....................     }
.................... }
.................... 
.................... void test_adc()
.................... {
....................     unsigned int16 ans;
....................     mcp4901_1_write(0); // Initialize DAC to 0
....................     fprintf(PC, "Start ADC TEST\r\n");
....................     ans = ad7490_read(ADC_CIGS1_VOLT);
....................     fprintf(PC, "ADC Voltage: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_CURR);
....................     fprintf(PC, "ADC Current: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_AMP);
....................     fprintf(PC, "ADC CIGS1 Amp: %04LX\r\n", ans);
....................     ans = ad7490_read(ADC_CIGS1_VREF);
....................     fprintf(PC, "ADC CIGS1 VREF: %04LX\r\n", ans);
.................... }
.................... 
.................... void sweep_2ports(unsigned int8 measurement_step)
.................... { 
....................     fprintf(PC, "Start SWEEP 2ports\r\n");
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................     
....................     // Set CIGS1 and CIGS2
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
....................     output_low(EN_NPWR); 
.................... 
....................     MEASUREMENT_DATA measured_data;
.................... 
....................     measured_data.time_sec = get_current_sec(); 
....................     measured_data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
....................     measured_data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
....................     measured_data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
....................     measured_data.pd = ad7490_read(ADC_PD); 
.................... 
.................... 
....................     unsigned int16 cigs1_buffer[2][0xFF]; // Buffer for CIGS1 data
....................     unsigned int16 cigs2_buffer[2][0xFF];
.................... 
.................... 
....................     for (unsigned int8 count = 0; count < measurement_step; count++)
....................     {    
....................         // set DAC value
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         //delay_ms(100); // wait for the DAC to stabilize
.................... 
....................         // read CIGS voltage and current      
....................         delay_ms(1);
....................         cigs1_buffer[0][count] = ad7490_read(ADC_CIGS1_VOLT);
....................         cigs1_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................         cigs2_buffer[0][count] = ad7490_read(ADC_CIGS2_VOLT);
....................         cigs2_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................     }
.................... 
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     output_high(EN_NPWR);
.................... 
....................     fprintf(PC, "END SWEEP 2port\r\n");
.................... 
....................     fprintf(PC, "Start CIGS data conversion\r\n");  
.................... }
.................... 
.................... 
.................... /*
.................... void add_smf_queue_data()
.................... {
....................     SmfDataStruct smf_data;
....................     smf_data.type = SMF_DATA_TYPE_CIGS;
....................     smf_data.length = PACKET_SIZE;
....................     memcpy(smf_data.data, packetdata, PACKET_SIZE);
....................     enqueue_smf_data(&smf_data);
.................... }
.................... */
.................... void add_smf_queue_piclog()
.................... {}
.................... 
.................... void convert_datas(MEASUREMENT_DATA measured_data, )
.................... {
....................     
.................... }
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, "Start SWEEP with threshold\r\n");
*
07160:  MOVLW  26
07162:  MOVWF  FF6
07164:  MOVLW  06
07166:  MOVWF  FF7
07168:  MOVLW  00
0716A:  MOVWF  FF8
0716C:  CALL   1BDA
....................    
....................     // Enable both CIGS ports
....................     output_low(EN_NPWR);
07170:  MOVLW  5E
07172:  MOVWF  F94
07174:  BCF    F8B.7
....................     output_high(CONNECT_CIGS1);
07176:  MOVLW  5E
07178:  MOVWF  F94
0717A:  BSF    F8B.0
....................     output_high(CONNECT_CIGS2);
0717C:  MOVLW  5E
0717E:  MOVWF  F94
07180:  BSF    F8B.5
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     SWEEP_CONFIG port1 = {0};
07182:  MOVLB  1
07184:  CLRF   xB1
07186:  CLRF   xB2
07188:  CLRF   xB3
0718A:  CLRF   xB4
0718C:  CLRF   xB5
0718E:  CLRF   xB6
07190:  CLRF   xB7
07192:  CLRF   xB8
07194:  CLRF   xB9
07196:  CLRF   xBA
07198:  CLRF   xBB
0719A:  CLRF   xBC
0719C:  CLRF   xBD
0719E:  CLRF   xBE
071A0:  CLRF   xBF
071A2:  CLRF   xC0
071A4:  CLRF   xC1
071A6:  CLRF   xC2
071A8:  CLRF   xC3
071AA:  CLRF   xC4
071AC:  CLRF   xC5
071AE:  CLRF   xC6
071B0:  CLRF   xC7
071B2:  CLRF   xC8
071B4:  CLRF   xC9
071B6:  CLRF   xCA
071B8:  CLRF   xCB
071BA:  CLRF   xCC
071BC:  CLRF   xCD
071BE:  CLRF   xCE
071C0:  CLRF   xCF
071C2:  CLRF   xD0
071C4:  CLRF   xD1
071C6:  CLRF   xD2
071C8:  CLRF   xD3
071CA:  CLRF   xD4
071CC:  CLRF   xD5
071CE:  CLRF   xD6
071D0:  CLRF   xD7
071D2:  CLRF   xD8
071D4:  CLRF   xD9
071D6:  CLRF   xDA
071D8:  CLRF   xDB
071DA:  CLRF   xDC
071DC:  CLRF   xDD
071DE:  CLRF   xDE
071E0:  CLRF   xDF
071E2:  CLRF   xE0
071E4:  CLRF   xE1
071E6:  CLRF   xE2
071E8:  CLRF   xE3
071EA:  CLRF   xE4
071EC:  CLRF   xE5
071EE:  CLRF   xE6
071F0:  CLRF   xE7
071F2:  CLRF   xE8
071F4:  CLRF   xE9
071F6:  CLRF   xEA
071F8:  CLRF   xEB
071FA:  CLRF   xEC
071FC:  CLRF   xED
071FE:  CLRF   xEE
07200:  CLRF   xEF
07202:  CLRF   xF0
07204:  CLRF   xF1
07206:  CLRF   xF2
07208:  CLRF   xF3
0720A:  CLRF   xF4
0720C:  CLRF   xF5
0720E:  CLRF   xF6
07210:  CLRF   xF7
07212:  CLRF   xF8
07214:  CLRF   xF9
07216:  CLRF   xFA
07218:  CLRF   xFB
0721A:  CLRF   xFC
0721C:  CLRF   xFD
0721E:  CLRF   xFE
07220:  CLRF   xFF
07222:  MOVLB  2
07224:  CLRF   x00
07226:  CLRF   x01
07228:  CLRF   x02
0722A:  CLRF   x03
0722C:  CLRF   x04
0722E:  CLRF   x05
07230:  CLRF   x06
07232:  CLRF   x07
07234:  CLRF   x08
07236:  CLRF   x09
07238:  CLRF   x0A
0723A:  CLRF   x0B
0723C:  CLRF   x0C
0723E:  CLRF   x0D
07240:  CLRF   x0E
07242:  CLRF   x0F
07244:  CLRF   x10
07246:  CLRF   x11
07248:  CLRF   x12
0724A:  CLRF   x13
0724C:  CLRF   x14
0724E:  CLRF   x15
07250:  CLRF   x16
07252:  CLRF   x17
07254:  CLRF   x18
07256:  CLRF   x19
07258:  CLRF   x1A
0725A:  CLRF   x1B
0725C:  CLRF   x1C
0725E:  CLRF   x1D
07260:  CLRF   x1E
07262:  CLRF   x1F
07264:  CLRF   x20
07266:  CLRF   x21
07268:  CLRF   x22
0726A:  CLRF   x23
0726C:  CLRF   x24
0726E:  CLRF   x25
07270:  CLRF   x26
07272:  CLRF   x27
07274:  CLRF   x28
07276:  CLRF   x29
07278:  CLRF   x2A
0727A:  CLRF   x2B
0727C:  CLRF   x2C
0727E:  CLRF   x2D
07280:  CLRF   x2E
07282:  CLRF   x2F
07284:  CLRF   x30
07286:  CLRF   x31
07288:  CLRF   x32
0728A:  CLRF   x33
0728C:  CLRF   x34
0728E:  CLRF   x35
07290:  CLRF   x36
07292:  CLRF   x37
07294:  CLRF   x38
07296:  CLRF   x39
07298:  CLRF   x3A
0729A:  CLRF   x3B
0729C:  CLRF   x3C
0729E:  CLRF   x3D
072A0:  CLRF   x3E
072A2:  CLRF   x3F
072A4:  CLRF   x40
072A6:  CLRF   x41
072A8:  CLRF   x42
072AA:  CLRF   x43
072AC:  CLRF   x44
072AE:  CLRF   x45
072B0:  CLRF   x46
072B2:  CLRF   x47
072B4:  CLRF   x48
072B6:  CLRF   x49
072B8:  CLRF   x4A
072BA:  CLRF   x4B
072BC:  CLRF   x4C
072BE:  CLRF   x4D
072C0:  CLRF   x4E
072C2:  CLRF   x4F
072C4:  CLRF   x50
072C6:  CLRF   x51
072C8:  CLRF   x52
072CA:  CLRF   x53
072CC:  CLRF   x54
072CE:  CLRF   x55
072D0:  CLRF   x56
072D2:  CLRF   x57
072D4:  CLRF   x58
072D6:  CLRF   x59
072D8:  CLRF   x5A
072DA:  CLRF   x5B
072DC:  CLRF   x5C
072DE:  CLRF   x5D
072E0:  CLRF   x5E
072E2:  CLRF   x5F
072E4:  CLRF   x60
072E6:  CLRF   x61
072E8:  CLRF   x62
072EA:  CLRF   x63
072EC:  CLRF   x64
072EE:  CLRF   x65
072F0:  CLRF   x66
072F2:  CLRF   x67
072F4:  CLRF   x68
072F6:  CLRF   x69
072F8:  CLRF   x6A
072FA:  CLRF   x6B
072FC:  CLRF   x6C
072FE:  CLRF   x6D
07300:  CLRF   x6E
07302:  CLRF   x6F
07304:  CLRF   x70
07306:  CLRF   x71
07308:  CLRF   x72
0730A:  CLRF   x73
0730C:  CLRF   x74
0730E:  CLRF   x75
07310:  CLRF   x76
07312:  CLRF   x77
07314:  CLRF   x78
07316:  CLRF   x79
07318:  CLRF   x7A
0731A:  CLRF   x7B
0731C:  CLRF   x7C
0731E:  CLRF   x7D
07320:  CLRF   x7E
07322:  CLRF   x7F
07324:  CLRF   x80
07326:  CLRF   x81
07328:  CLRF   x82
0732A:  CLRF   x83
0732C:  CLRF   x84
0732E:  CLRF   x85
07330:  CLRF   x86
07332:  CLRF   x87
07334:  CLRF   x88
07336:  CLRF   x89
07338:  CLRF   x8A
0733A:  CLRF   x8B
0733C:  CLRF   x8C
0733E:  CLRF   x8D
07340:  CLRF   x8E
07342:  CLRF   x8F
07344:  CLRF   x90
07346:  CLRF   x91
07348:  CLRF   x92
0734A:  CLRF   x93
0734C:  CLRF   x94
0734E:  CLRF   x95
07350:  CLRF   x96
07352:  CLRF   x97
07354:  CLRF   x98
07356:  CLRF   x99
07358:  CLRF   x9A
0735A:  CLRF   x9B
0735C:  CLRF   x9C
0735E:  CLRF   x9D
07360:  CLRF   x9E
07362:  CLRF   x9F
07364:  CLRF   xA0
07366:  CLRF   xA1
07368:  CLRF   xA2
0736A:  CLRF   xA3
0736C:  CLRF   xA4
0736E:  CLRF   xA5
07370:  CLRF   xA6
07372:  CLRF   xA7
07374:  CLRF   xA8
07376:  CLRF   xA9
07378:  CLRF   xAA
0737A:  CLRF   xAB
0737C:  CLRF   xAC
0737E:  CLRF   xAD
07380:  CLRF   xAE
07382:  CLRF   xAF
07384:  CLRF   xB0
07386:  CLRF   xB1
07388:  CLRF   xB2
0738A:  CLRF   xB3
0738C:  CLRF   xB4
0738E:  CLRF   xB5
07390:  CLRF   xB6
07392:  CLRF   xB7
07394:  CLRF   xB8
07396:  CLRF   xB9
07398:  CLRF   xBA
0739A:  CLRF   xBB
0739C:  CLRF   xBC
0739E:  CLRF   xBD
073A0:  CLRF   xBE
073A2:  CLRF   xBF
073A4:  CLRF   xC0
073A6:  CLRF   xC1
073A8:  CLRF   xC2
073AA:  CLRF   xC3
073AC:  CLRF   xC4
073AE:  CLRF   xC5
073B0:  CLRF   xC6
073B2:  CLRF   xC7
073B4:  CLRF   xC8
073B6:  CLRF   xC9
073B8:  CLRF   xCA
073BA:  CLRF   xCB
073BC:  CLRF   xCC
073BE:  CLRF   xCD
073C0:  CLRF   xCE
073C2:  CLRF   xCF
073C4:  CLRF   xD0
073C6:  CLRF   xD1
073C8:  CLRF   xD2
073CA:  CLRF   xD3
073CC:  CLRF   xD4
073CE:  CLRF   xD5
073D0:  CLRF   xD6
073D2:  CLRF   xD7
073D4:  CLRF   xD8
073D6:  CLRF   xD9
073D8:  CLRF   xDA
073DA:  CLRF   xDB
073DC:  CLRF   xDC
073DE:  CLRF   xDD
073E0:  CLRF   xDE
073E2:  CLRF   xDF
073E4:  CLRF   xE0
073E6:  CLRF   xE1
073E8:  CLRF   xE2
073EA:  CLRF   xE3
073EC:  CLRF   xE4
073EE:  CLRF   xE5
073F0:  CLRF   xE6
073F2:  CLRF   xE7
073F4:  CLRF   xE8
073F6:  CLRF   xE9
073F8:  CLRF   xEA
073FA:  CLRF   xEB
073FC:  CLRF   xEC
073FE:  CLRF   xED
07400:  CLRF   xEE
07402:  CLRF   xEF
07404:  CLRF   xF0
07406:  CLRF   xF1
07408:  CLRF   xF2
0740A:  CLRF   xF3
0740C:  CLRF   xF4
0740E:  CLRF   xF5
07410:  CLRF   xF6
07412:  CLRF   xF7
07414:  CLRF   xF8
07416:  CLRF   xF9
07418:  CLRF   xFA
0741A:  CLRF   xFB
0741C:  CLRF   xFC
0741E:  CLRF   xFD
07420:  CLRF   xFE
07422:  CLRF   xFF
07424:  MOVLB  3
07426:  CLRF   x00
07428:  CLRF   x01
0742A:  CLRF   x02
0742C:  CLRF   x03
0742E:  CLRF   x04
07430:  CLRF   x05
07432:  CLRF   x06
07434:  CLRF   x07
07436:  CLRF   x08
07438:  CLRF   x09
0743A:  CLRF   x0A
0743C:  CLRF   x0B
0743E:  CLRF   x0C
07440:  CLRF   x0D
07442:  CLRF   x0E
07444:  CLRF   x0F
07446:  CLRF   x10
07448:  CLRF   x11
0744A:  CLRF   x12
0744C:  CLRF   x13
0744E:  CLRF   x14
07450:  CLRF   x15
07452:  CLRF   x16
07454:  CLRF   x17
07456:  CLRF   x18
07458:  CLRF   x19
0745A:  CLRF   x1A
0745C:  CLRF   x1B
0745E:  CLRF   x1C
07460:  CLRF   x1D
07462:  CLRF   x1E
07464:  CLRF   x1F
07466:  CLRF   x20
07468:  CLRF   x21
0746A:  CLRF   x22
0746C:  CLRF   x23
0746E:  CLRF   x24
07470:  CLRF   x25
07472:  CLRF   x26
07474:  CLRF   x27
07476:  CLRF   x28
07478:  CLRF   x29
0747A:  CLRF   x2A
0747C:  CLRF   x2B
0747E:  CLRF   x2C
07480:  CLRF   x2D
07482:  CLRF   x2E
07484:  CLRF   x2F
07486:  CLRF   x30
07488:  CLRF   x31
0748A:  CLRF   x32
0748C:  CLRF   x33
0748E:  CLRF   x34
07490:  CLRF   x35
07492:  CLRF   x36
07494:  CLRF   x37
07496:  CLRF   x38
07498:  CLRF   x39
0749A:  CLRF   x3A
0749C:  CLRF   x3B
0749E:  CLRF   x3C
074A0:  CLRF   x3D
074A2:  CLRF   x3E
074A4:  CLRF   x3F
074A6:  CLRF   x40
074A8:  CLRF   x41
074AA:  CLRF   x42
074AC:  CLRF   x43
074AE:  CLRF   x44
074B0:  CLRF   x45
074B2:  CLRF   x46
074B4:  CLRF   x47
074B6:  CLRF   x48
074B8:  CLRF   x49
074BA:  CLRF   x4A
074BC:  CLRF   x4B
074BE:  CLRF   x4C
074C0:  CLRF   x4D
074C2:  CLRF   x4E
074C4:  CLRF   x4F
074C6:  CLRF   x50
074C8:  CLRF   x51
074CA:  CLRF   x52
074CC:  CLRF   x53
074CE:  CLRF   x54
074D0:  CLRF   x55
074D2:  CLRF   x56
074D4:  CLRF   x57
074D6:  CLRF   x58
074D8:  CLRF   x59
074DA:  CLRF   x5A
074DC:  CLRF   x5B
074DE:  CLRF   x5C
074E0:  CLRF   x5D
074E2:  CLRF   x5E
074E4:  CLRF   x5F
074E6:  CLRF   x60
074E8:  CLRF   x61
074EA:  CLRF   x62
074EC:  CLRF   x63
074EE:  CLRF   x64
074F0:  CLRF   x65
074F2:  CLRF   x66
074F4:  CLRF   x67
074F6:  CLRF   x68
074F8:  CLRF   x69
074FA:  CLRF   x6A
074FC:  CLRF   x6B
074FE:  CLRF   x6C
07500:  CLRF   x6D
07502:  CLRF   x6E
07504:  CLRF   x6F
07506:  CLRF   x70
07508:  CLRF   x71
0750A:  CLRF   x72
0750C:  CLRF   x73
0750E:  CLRF   x74
07510:  CLRF   x75
07512:  CLRF   x76
07514:  CLRF   x77
07516:  CLRF   x78
07518:  CLRF   x79
0751A:  CLRF   x7A
0751C:  CLRF   x7B
0751E:  CLRF   x7C
07520:  CLRF   x7D
07522:  CLRF   x7E
07524:  CLRF   x7F
07526:  CLRF   x80
07528:  CLRF   x81
0752A:  CLRF   x82
0752C:  CLRF   x83
0752E:  CLRF   x84
07530:  CLRF   x85
07532:  CLRF   x86
07534:  CLRF   x87
07536:  CLRF   x88
07538:  CLRF   x89
0753A:  CLRF   x8A
0753C:  CLRF   x8B
0753E:  CLRF   x8C
07540:  CLRF   x8D
07542:  CLRF   x8E
07544:  CLRF   x8F
07546:  CLRF   x90
07548:  CLRF   x91
0754A:  CLRF   x92
0754C:  CLRF   x93
0754E:  CLRF   x94
07550:  CLRF   x95
07552:  CLRF   x96
07554:  CLRF   x97
07556:  CLRF   x98
07558:  CLRF   x99
0755A:  CLRF   x9A
0755C:  CLRF   x9B
0755E:  CLRF   x9C
07560:  CLRF   x9D
07562:  CLRF   x9E
07564:  CLRF   x9F
07566:  CLRF   xA0
07568:  CLRF   xA1
0756A:  CLRF   xA2
0756C:  CLRF   xA3
0756E:  CLRF   xA4
07570:  CLRF   xA5
07572:  CLRF   xA6
07574:  CLRF   xA7
07576:  CLRF   xA8
07578:  CLRF   xA9
0757A:  CLRF   xAA
0757C:  CLRF   xAB
0757E:  CLRF   xAC
07580:  CLRF   xAD
07582:  CLRF   xAE
07584:  CLRF   xAF
07586:  CLRF   xB0
07588:  CLRF   xB1
0758A:  CLRF   xB2
0758C:  CLRF   xB3
0758E:  CLRF   xB4
07590:  CLRF   xB5
07592:  CLRF   xB6
07594:  CLRF   xB7
07596:  CLRF   xB8
07598:  CLRF   xB9
0759A:  CLRF   xBA
0759C:  CLRF   xBB
0759E:  CLRF   xBC
075A0:  CLRF   xBD
075A2:  CLRF   xBE
075A4:  CLRF   xBF
075A6:  CLRF   xC0
075A8:  CLRF   xC1
075AA:  CLRF   xC2
075AC:  CLRF   xC3
075AE:  CLRF   xC4
075B0:  CLRF   xC5
075B2:  CLRF   xC6
075B4:  CLRF   xC7
075B6:  CLRF   xC8
075B8:  CLRF   xC9
075BA:  CLRF   xCA
075BC:  CLRF   xCB
075BE:  CLRF   xCC
075C0:  CLRF   xCD
075C2:  CLRF   xCE
075C4:  CLRF   xCF
075C6:  CLRF   xD0
075C8:  CLRF   xD1
075CA:  CLRF   xD2
075CC:  CLRF   xD3
075CE:  CLRF   xD4
075D0:  CLRF   xD5
075D2:  CLRF   xD6
075D4:  CLRF   xD7
075D6:  CLRF   xD8
075D8:  CLRF   xD9
075DA:  CLRF   xDA
075DC:  CLRF   xDB
075DE:  CLRF   xDC
075E0:  CLRF   xDD
075E2:  CLRF   xDE
075E4:  CLRF   xDF
075E6:  CLRF   xE0
075E8:  CLRF   xE1
075EA:  CLRF   xE2
075EC:  CLRF   xE3
075EE:  CLRF   xE4
075F0:  CLRF   xE5
075F2:  CLRF   xE6
075F4:  CLRF   xE7
075F6:  CLRF   xE8
075F8:  CLRF   xE9
075FA:  CLRF   xEA
075FC:  CLRF   xEB
075FE:  CLRF   xEC
07600:  CLRF   xED
07602:  CLRF   xEE
07604:  CLRF   xEF
07606:  CLRF   xF0
07608:  CLRF   xF1
0760A:  CLRF   xF2
0760C:  CLRF   xF3
0760E:  CLRF   xF4
07610:  CLRF   xF5
07612:  CLRF   xF6
07614:  CLRF   xF7
07616:  CLRF   xF8
07618:  CLRF   xF9
0761A:  CLRF   xFA
0761C:  CLRF   xFB
0761E:  CLRF   xFC
07620:  CLRF   xFD
07622:  CLRF   xFE
07624:  CLRF   xFF
07626:  MOVLB  4
07628:  CLRF   x00
0762A:  CLRF   x01
0762C:  CLRF   x02
0762E:  CLRF   x03
07630:  CLRF   x04
07632:  CLRF   x05
07634:  CLRF   x06
07636:  CLRF   x07
07638:  CLRF   x08
0763A:  CLRF   x09
0763C:  CLRF   x0A
0763E:  CLRF   x0B
07640:  CLRF   x0C
07642:  CLRF   x0D
07644:  CLRF   x0E
07646:  CLRF   x0F
07648:  CLRF   x10
0764A:  CLRF   x11
0764C:  CLRF   x12
0764E:  CLRF   x13
07650:  CLRF   x14
07652:  CLRF   x15
07654:  CLRF   x16
07656:  CLRF   x17
07658:  CLRF   x18
0765A:  CLRF   x19
0765C:  CLRF   x1A
0765E:  CLRF   x1B
07660:  CLRF   x1C
07662:  CLRF   x1D
07664:  CLRF   x1E
07666:  CLRF   x1F
07668:  CLRF   x20
0766A:  CLRF   x21
0766C:  CLRF   x22
0766E:  CLRF   x23
07670:  CLRF   x24
07672:  CLRF   x25
07674:  CLRF   x26
07676:  CLRF   x27
07678:  CLRF   x28
0767A:  CLRF   x29
0767C:  CLRF   x2A
0767E:  CLRF   x2B
07680:  CLRF   x2C
07682:  CLRF   x2D
07684:  CLRF   x2E
07686:  CLRF   x2F
07688:  CLRF   x30
0768A:  CLRF   x31
0768C:  CLRF   x32
0768E:  CLRF   x33
07690:  CLRF   x34
07692:  CLRF   x35
07694:  CLRF   x36
07696:  CLRF   x37
07698:  CLRF   x38
0769A:  CLRF   x39
0769C:  CLRF   x3A
0769E:  CLRF   x3B
076A0:  CLRF   x3C
076A2:  CLRF   x3D
076A4:  CLRF   x3E
076A6:  CLRF   x3F
076A8:  CLRF   x40
076AA:  CLRF   x41
076AC:  CLRF   x42
076AE:  CLRF   x43
076B0:  CLRF   x44
076B2:  CLRF   x45
076B4:  CLRF   x46
076B6:  CLRF   x47
076B8:  CLRF   x48
076BA:  CLRF   x49
076BC:  CLRF   x4A
076BE:  CLRF   x4B
076C0:  CLRF   x4C
076C2:  CLRF   x4D
076C4:  CLRF   x4E
076C6:  CLRF   x4F
076C8:  CLRF   x50
076CA:  CLRF   x51
076CC:  CLRF   x52
076CE:  CLRF   x53
076D0:  CLRF   x54
076D2:  CLRF   x55
076D4:  CLRF   x56
076D6:  CLRF   x57
076D8:  CLRF   x58
076DA:  CLRF   x59
076DC:  CLRF   x5A
076DE:  CLRF   x5B
076E0:  CLRF   x5C
076E2:  CLRF   x5D
076E4:  CLRF   x5E
076E6:  CLRF   x5F
076E8:  CLRF   x60
076EA:  CLRF   x61
076EC:  CLRF   x62
076EE:  CLRF   x63
076F0:  CLRF   x64
076F2:  CLRF   x65
076F4:  CLRF   x66
076F6:  CLRF   x67
076F8:  CLRF   x68
076FA:  CLRF   x69
076FC:  CLRF   x6A
076FE:  CLRF   x6B
07700:  CLRF   x6C
07702:  CLRF   x6D
07704:  CLRF   x6E
07706:  CLRF   x6F
07708:  CLRF   x70
0770A:  CLRF   x71
0770C:  CLRF   x72
0770E:  CLRF   x73
07710:  CLRF   x74
07712:  CLRF   x75
07714:  CLRF   x76
07716:  CLRF   x77
07718:  CLRF   x78
0771A:  CLRF   x79
0771C:  CLRF   x7A
0771E:  CLRF   x7B
07720:  CLRF   x7C
07722:  CLRF   x7D
07724:  CLRF   x7E
07726:  CLRF   x7F
07728:  CLRF   x80
0772A:  CLRF   x81
0772C:  CLRF   x82
0772E:  CLRF   x83
07730:  CLRF   x84
07732:  CLRF   x85
07734:  CLRF   x86
07736:  CLRF   x87
07738:  CLRF   x88
0773A:  CLRF   x89
0773C:  CLRF   x8A
0773E:  CLRF   x8B
07740:  CLRF   x8C
07742:  CLRF   x8D
07744:  CLRF   x8E
07746:  CLRF   x8F
07748:  CLRF   x90
0774A:  CLRF   x91
0774C:  CLRF   x92
0774E:  CLRF   x93
07750:  CLRF   x94
07752:  CLRF   x95
07754:  CLRF   x96
07756:  CLRF   x97
07758:  CLRF   x98
0775A:  CLRF   x99
0775C:  CLRF   x9A
0775E:  CLRF   x9B
07760:  CLRF   x9C
07762:  CLRF   x9D
07764:  CLRF   x9E
07766:  CLRF   x9F
07768:  CLRF   xA0
0776A:  CLRF   xA1
0776C:  CLRF   xA2
0776E:  CLRF   xA3
07770:  CLRF   xA4
07772:  CLRF   xA5
07774:  CLRF   xA6
07776:  CLRF   xA7
07778:  CLRF   xA8
0777A:  CLRF   xA9
0777C:  CLRF   xAA
0777E:  CLRF   xAB
07780:  CLRF   xAC
07782:  CLRF   xAD
07784:  CLRF   xAE
07786:  CLRF   xAF
07788:  CLRF   xB0
0778A:  CLRF   xB1
0778C:  CLRF   xB2
0778E:  CLRF   xB3
07790:  CLRF   xB4
07792:  CLRF   xB5
07794:  CLRF   xB6
07796:  CLRF   xB7
07798:  CLRF   xB8
0779A:  CLRF   xB9
0779C:  CLRF   xBA
0779E:  CLRF   xBB
077A0:  CLRF   xBC
077A2:  CLRF   xBD
077A4:  CLRF   xBE
077A6:  CLRF   xBF
077A8:  CLRF   xC0
077AA:  CLRF   xC1
077AC:  CLRF   xC2
077AE:  CLRF   xC3
077B0:  CLRF   xC4
077B2:  CLRF   xC5
077B4:  CLRF   xC6
077B6:  CLRF   xC7
077B8:  CLRF   xC8
077BA:  CLRF   xC9
077BC:  CLRF   xCA
077BE:  CLRF   xCB
077C0:  CLRF   xCC
077C2:  CLRF   xCD
077C4:  CLRF   xCE
077C6:  CLRF   xCF
077C8:  CLRF   xD0
077CA:  CLRF   xD1
077CC:  CLRF   xD2
077CE:  CLRF   xD3
077D0:  CLRF   xD4
077D2:  CLRF   xD5
077D4:  CLRF   xD6
077D6:  CLRF   xD7
077D8:  CLRF   xD8
077DA:  CLRF   xD9
077DC:  CLRF   xDA
077DE:  CLRF   xDB
077E0:  CLRF   xDC
077E2:  CLRF   xDD
077E4:  CLRF   xDE
077E6:  CLRF   xDF
077E8:  CLRF   xE0
077EA:  CLRF   xE1
077EC:  CLRF   xE2
077EE:  CLRF   xE3
077F0:  CLRF   xE4
077F2:  CLRF   xE5
077F4:  CLRF   xE6
077F6:  CLRF   xE7
077F8:  CLRF   xE8
077FA:  CLRF   xE9
077FC:  CLRF   xEA
077FE:  CLRF   xEB
07800:  CLRF   xEC
07802:  CLRF   xED
07804:  CLRF   xEE
07806:  CLRF   xEF
07808:  CLRF   xF0
0780A:  CLRF   xF1
0780C:  CLRF   xF2
0780E:  CLRF   xF3
07810:  CLRF   xF4
07812:  CLRF   xF5
07814:  CLRF   xF6
07816:  CLRF   xF7
07818:  CLRF   xF8
0781A:  CLRF   xF9
0781C:  CLRF   xFA
0781E:  CLRF   xFB
07820:  CLRF   xFC
07822:  CLRF   xFD
07824:  CLRF   xFE
07826:  CLRF   xFF
07828:  MOVLB  5
0782A:  CLRF   x00
0782C:  CLRF   x01
0782E:  CLRF   x02
07830:  CLRF   x03
07832:  CLRF   x04
07834:  CLRF   x05
07836:  CLRF   x06
07838:  CLRF   x07
0783A:  CLRF   x08
0783C:  CLRF   x09
0783E:  CLRF   x0A
07840:  CLRF   x0B
07842:  CLRF   x0C
07844:  CLRF   x0D
07846:  CLRF   x0E
07848:  CLRF   x0F
0784A:  CLRF   x10
0784C:  CLRF   x11
0784E:  CLRF   x12
07850:  CLRF   x13
07852:  CLRF   x14
07854:  CLRF   x15
07856:  CLRF   x16
07858:  CLRF   x17
0785A:  CLRF   x18
0785C:  CLRF   x19
0785E:  CLRF   x1A
07860:  CLRF   x1B
07862:  CLRF   x1C
07864:  CLRF   x1D
07866:  CLRF   x1E
07868:  CLRF   x1F
0786A:  CLRF   x20
0786C:  CLRF   x21
0786E:  CLRF   x22
07870:  CLRF   x23
07872:  CLRF   x24
07874:  CLRF   x25
07876:  CLRF   x26
07878:  CLRF   x27
0787A:  CLRF   x28
0787C:  CLRF   x29
0787E:  CLRF   x2A
07880:  CLRF   x2B
07882:  CLRF   x2C
07884:  CLRF   x2D
07886:  CLRF   x2E
07888:  CLRF   x2F
0788A:  CLRF   x30
0788C:  CLRF   x31
0788E:  CLRF   x32
07890:  CLRF   x33
07892:  CLRF   x34
07894:  CLRF   x35
07896:  CLRF   x36
07898:  CLRF   x37
0789A:  CLRF   x38
0789C:  CLRF   x39
0789E:  CLRF   x3A
078A0:  CLRF   x3B
078A2:  CLRF   x3C
078A4:  CLRF   x3D
078A6:  CLRF   x3E
078A8:  CLRF   x3F
078AA:  CLRF   x40
078AC:  CLRF   x41
078AE:  CLRF   x42
078B0:  CLRF   x43
078B2:  CLRF   x44
078B4:  CLRF   x45
078B6:  CLRF   x46
078B8:  CLRF   x47
078BA:  CLRF   x48
078BC:  CLRF   x49
078BE:  CLRF   x4A
078C0:  CLRF   x4B
078C2:  CLRF   x4C
078C4:  CLRF   x4D
078C6:  CLRF   x4E
078C8:  CLRF   x4F
078CA:  CLRF   x50
078CC:  CLRF   x51
078CE:  CLRF   x52
078D0:  CLRF   x53
078D2:  CLRF   x54
078D4:  CLRF   x55
078D6:  CLRF   x56
078D8:  CLRF   x57
078DA:  CLRF   x58
078DC:  CLRF   x59
078DE:  CLRF   x5A
078E0:  CLRF   x5B
078E2:  CLRF   x5C
078E4:  CLRF   x5D
078E6:  CLRF   x5E
078E8:  CLRF   x5F
078EA:  CLRF   x60
078EC:  CLRF   x61
078EE:  CLRF   x62
078F0:  CLRF   x63
078F2:  CLRF   x64
078F4:  CLRF   x65
078F6:  CLRF   x66
078F8:  CLRF   x67
078FA:  CLRF   x68
078FC:  CLRF   x69
078FE:  CLRF   x6A
07900:  CLRF   x6B
07902:  CLRF   x6C
07904:  CLRF   x6D
07906:  CLRF   x6E
07908:  CLRF   x6F
0790A:  CLRF   x70
0790C:  CLRF   x71
0790E:  CLRF   x72
07910:  CLRF   x73
07912:  CLRF   x74
07914:  CLRF   x75
07916:  CLRF   x76
07918:  CLRF   x77
0791A:  CLRF   x78
0791C:  CLRF   x79
0791E:  CLRF   x7A
07920:  CLRF   x7B
07922:  CLRF   x7C
07924:  CLRF   x7D
07926:  CLRF   x7E
07928:  CLRF   x7F
0792A:  CLRF   x80
0792C:  CLRF   x81
0792E:  CLRF   x82
07930:  CLRF   x83
07932:  CLRF   x84
07934:  CLRF   x85
07936:  CLRF   x86
07938:  CLRF   x87
0793A:  CLRF   x88
0793C:  CLRF   x89
0793E:  CLRF   x8A
07940:  CLRF   x8B
07942:  CLRF   x8C
07944:  CLRF   x8D
07946:  CLRF   x8E
07948:  CLRF   x8F
0794A:  CLRF   x90
0794C:  CLRF   x91
0794E:  CLRF   x92
07950:  CLRF   x93
07952:  CLRF   x94
07954:  CLRF   x95
07956:  CLRF   x96
07958:  CLRF   x97
0795A:  CLRF   x98
0795C:  CLRF   x99
0795E:  CLRF   x9A
07960:  CLRF   x9B
07962:  CLRF   x9C
07964:  CLRF   x9D
07966:  CLRF   x9E
07968:  CLRF   x9F
0796A:  CLRF   xA0
0796C:  CLRF   xA1
0796E:  CLRF   xA2
07970:  CLRF   xA3
07972:  CLRF   xA4
07974:  CLRF   xA5
07976:  CLRF   xA6
07978:  CLRF   xA7
0797A:  CLRF   xA8
0797C:  CLRF   xA9
0797E:  CLRF   xAA
07980:  CLRF   xAB
07982:  CLRF   xAC
07984:  CLRF   xAD
07986:  CLRF   xAE
07988:  CLRF   xAF
0798A:  CLRF   xB0
....................     port1.port_num = 1;
0798C:  MOVLW  01
0798E:  MOVLB  1
07990:  MOVWF  xB1
....................     port1.sweep_step = 0;
07992:  CLRF   xB3
07994:  CLRF   xB2
....................     port1.active = 1;
07996:  MOVLB  5
07998:  BSF    xB0.0
.................... 
....................     // Init Port2
....................     SWEEP_CONFIG port2 = {0};
0799A:  CLRF   xB1
0799C:  CLRF   xB2
0799E:  CLRF   xB3
079A0:  CLRF   xB4
079A2:  CLRF   xB5
079A4:  CLRF   xB6
079A6:  CLRF   xB7
079A8:  CLRF   xB8
079AA:  CLRF   xB9
079AC:  CLRF   xBA
079AE:  CLRF   xBB
079B0:  CLRF   xBC
079B2:  CLRF   xBD
079B4:  CLRF   xBE
079B6:  CLRF   xBF
079B8:  CLRF   xC0
079BA:  CLRF   xC1
079BC:  CLRF   xC2
079BE:  CLRF   xC3
079C0:  CLRF   xC4
079C2:  CLRF   xC5
079C4:  CLRF   xC6
079C6:  CLRF   xC7
079C8:  CLRF   xC8
079CA:  CLRF   xC9
079CC:  CLRF   xCA
079CE:  CLRF   xCB
079D0:  CLRF   xCC
079D2:  CLRF   xCD
079D4:  CLRF   xCE
079D6:  CLRF   xCF
079D8:  CLRF   xD0
079DA:  CLRF   xD1
079DC:  CLRF   xD2
079DE:  CLRF   xD3
079E0:  CLRF   xD4
079E2:  CLRF   xD5
079E4:  CLRF   xD6
079E6:  CLRF   xD7
079E8:  CLRF   xD8
079EA:  CLRF   xD9
079EC:  CLRF   xDA
079EE:  CLRF   xDB
079F0:  CLRF   xDC
079F2:  CLRF   xDD
079F4:  CLRF   xDE
079F6:  CLRF   xDF
079F8:  CLRF   xE0
079FA:  CLRF   xE1
079FC:  CLRF   xE2
079FE:  CLRF   xE3
07A00:  CLRF   xE4
07A02:  CLRF   xE5
07A04:  CLRF   xE6
07A06:  CLRF   xE7
07A08:  CLRF   xE8
07A0A:  CLRF   xE9
07A0C:  CLRF   xEA
07A0E:  CLRF   xEB
07A10:  CLRF   xEC
07A12:  CLRF   xED
07A14:  CLRF   xEE
07A16:  CLRF   xEF
07A18:  CLRF   xF0
07A1A:  CLRF   xF1
07A1C:  CLRF   xF2
07A1E:  CLRF   xF3
07A20:  CLRF   xF4
07A22:  CLRF   xF5
07A24:  CLRF   xF6
07A26:  CLRF   xF7
07A28:  CLRF   xF8
07A2A:  CLRF   xF9
07A2C:  CLRF   xFA
07A2E:  CLRF   xFB
07A30:  CLRF   xFC
07A32:  CLRF   xFD
07A34:  CLRF   xFE
07A36:  CLRF   xFF
07A38:  MOVLB  6
07A3A:  CLRF   x00
07A3C:  CLRF   x01
07A3E:  CLRF   x02
07A40:  CLRF   x03
07A42:  CLRF   x04
07A44:  CLRF   x05
07A46:  CLRF   x06
07A48:  CLRF   x07
07A4A:  CLRF   x08
07A4C:  CLRF   x09
07A4E:  CLRF   x0A
07A50:  CLRF   x0B
07A52:  CLRF   x0C
07A54:  CLRF   x0D
07A56:  CLRF   x0E
07A58:  CLRF   x0F
07A5A:  CLRF   x10
07A5C:  CLRF   x11
07A5E:  CLRF   x12
07A60:  CLRF   x13
07A62:  CLRF   x14
07A64:  CLRF   x15
07A66:  CLRF   x16
07A68:  CLRF   x17
07A6A:  CLRF   x18
07A6C:  CLRF   x19
07A6E:  CLRF   x1A
07A70:  CLRF   x1B
07A72:  CLRF   x1C
07A74:  CLRF   x1D
07A76:  CLRF   x1E
07A78:  CLRF   x1F
07A7A:  CLRF   x20
07A7C:  CLRF   x21
07A7E:  CLRF   x22
07A80:  CLRF   x23
07A82:  CLRF   x24
07A84:  CLRF   x25
07A86:  CLRF   x26
07A88:  CLRF   x27
07A8A:  CLRF   x28
07A8C:  CLRF   x29
07A8E:  CLRF   x2A
07A90:  CLRF   x2B
07A92:  CLRF   x2C
07A94:  CLRF   x2D
07A96:  CLRF   x2E
07A98:  CLRF   x2F
07A9A:  CLRF   x30
07A9C:  CLRF   x31
07A9E:  CLRF   x32
07AA0:  CLRF   x33
07AA2:  CLRF   x34
07AA4:  CLRF   x35
07AA6:  CLRF   x36
07AA8:  CLRF   x37
07AAA:  CLRF   x38
07AAC:  CLRF   x39
07AAE:  CLRF   x3A
07AB0:  CLRF   x3B
07AB2:  CLRF   x3C
07AB4:  CLRF   x3D
07AB6:  CLRF   x3E
07AB8:  CLRF   x3F
07ABA:  CLRF   x40
07ABC:  CLRF   x41
07ABE:  CLRF   x42
07AC0:  CLRF   x43
07AC2:  CLRF   x44
07AC4:  CLRF   x45
07AC6:  CLRF   x46
07AC8:  CLRF   x47
07ACA:  CLRF   x48
07ACC:  CLRF   x49
07ACE:  CLRF   x4A
07AD0:  CLRF   x4B
07AD2:  CLRF   x4C
07AD4:  CLRF   x4D
07AD6:  CLRF   x4E
07AD8:  CLRF   x4F
07ADA:  CLRF   x50
07ADC:  CLRF   x51
07ADE:  CLRF   x52
07AE0:  CLRF   x53
07AE2:  CLRF   x54
07AE4:  CLRF   x55
07AE6:  CLRF   x56
07AE8:  CLRF   x57
07AEA:  CLRF   x58
07AEC:  CLRF   x59
07AEE:  CLRF   x5A
07AF0:  CLRF   x5B
07AF2:  CLRF   x5C
07AF4:  CLRF   x5D
07AF6:  CLRF   x5E
07AF8:  CLRF   x5F
07AFA:  CLRF   x60
07AFC:  CLRF   x61
07AFE:  CLRF   x62
07B00:  CLRF   x63
07B02:  CLRF   x64
07B04:  CLRF   x65
07B06:  CLRF   x66
07B08:  CLRF   x67
07B0A:  CLRF   x68
07B0C:  CLRF   x69
07B0E:  CLRF   x6A
07B10:  CLRF   x6B
07B12:  CLRF   x6C
07B14:  CLRF   x6D
07B16:  CLRF   x6E
07B18:  CLRF   x6F
07B1A:  CLRF   x70
07B1C:  CLRF   x71
07B1E:  CLRF   x72
07B20:  CLRF   x73
07B22:  CLRF   x74
07B24:  CLRF   x75
07B26:  CLRF   x76
07B28:  CLRF   x77
07B2A:  CLRF   x78
07B2C:  CLRF   x79
07B2E:  CLRF   x7A
07B30:  CLRF   x7B
07B32:  CLRF   x7C
07B34:  CLRF   x7D
07B36:  CLRF   x7E
07B38:  CLRF   x7F
07B3A:  CLRF   x80
07B3C:  CLRF   x81
07B3E:  CLRF   x82
07B40:  CLRF   x83
07B42:  CLRF   x84
07B44:  CLRF   x85
07B46:  CLRF   x86
07B48:  CLRF   x87
07B4A:  CLRF   x88
07B4C:  CLRF   x89
07B4E:  CLRF   x8A
07B50:  CLRF   x8B
07B52:  CLRF   x8C
07B54:  CLRF   x8D
07B56:  CLRF   x8E
07B58:  CLRF   x8F
07B5A:  CLRF   x90
07B5C:  CLRF   x91
07B5E:  CLRF   x92
07B60:  CLRF   x93
07B62:  CLRF   x94
07B64:  CLRF   x95
07B66:  CLRF   x96
07B68:  CLRF   x97
07B6A:  CLRF   x98
07B6C:  CLRF   x99
07B6E:  CLRF   x9A
07B70:  CLRF   x9B
07B72:  CLRF   x9C
07B74:  CLRF   x9D
07B76:  CLRF   x9E
07B78:  CLRF   x9F
07B7A:  CLRF   xA0
07B7C:  CLRF   xA1
07B7E:  CLRF   xA2
07B80:  CLRF   xA3
07B82:  CLRF   xA4
07B84:  CLRF   xA5
07B86:  CLRF   xA6
07B88:  CLRF   xA7
07B8A:  CLRF   xA8
07B8C:  CLRF   xA9
07B8E:  CLRF   xAA
07B90:  CLRF   xAB
07B92:  CLRF   xAC
07B94:  CLRF   xAD
07B96:  CLRF   xAE
07B98:  CLRF   xAF
07B9A:  CLRF   xB0
07B9C:  CLRF   xB1
07B9E:  CLRF   xB2
07BA0:  CLRF   xB3
07BA2:  CLRF   xB4
07BA4:  CLRF   xB5
07BA6:  CLRF   xB6
07BA8:  CLRF   xB7
07BAA:  CLRF   xB8
07BAC:  CLRF   xB9
07BAE:  CLRF   xBA
07BB0:  CLRF   xBB
07BB2:  CLRF   xBC
07BB4:  CLRF   xBD
07BB6:  CLRF   xBE
07BB8:  CLRF   xBF
07BBA:  CLRF   xC0
07BBC:  CLRF   xC1
07BBE:  CLRF   xC2
07BC0:  CLRF   xC3
07BC2:  CLRF   xC4
07BC4:  CLRF   xC5
07BC6:  CLRF   xC6
07BC8:  CLRF   xC7
07BCA:  CLRF   xC8
07BCC:  CLRF   xC9
07BCE:  CLRF   xCA
07BD0:  CLRF   xCB
07BD2:  CLRF   xCC
07BD4:  CLRF   xCD
07BD6:  CLRF   xCE
07BD8:  CLRF   xCF
07BDA:  CLRF   xD0
07BDC:  CLRF   xD1
07BDE:  CLRF   xD2
07BE0:  CLRF   xD3
07BE2:  CLRF   xD4
07BE4:  CLRF   xD5
07BE6:  CLRF   xD6
07BE8:  CLRF   xD7
07BEA:  CLRF   xD8
07BEC:  CLRF   xD9
07BEE:  CLRF   xDA
07BF0:  CLRF   xDB
07BF2:  CLRF   xDC
07BF4:  CLRF   xDD
07BF6:  CLRF   xDE
07BF8:  CLRF   xDF
07BFA:  CLRF   xE0
07BFC:  CLRF   xE1
07BFE:  CLRF   xE2
07C00:  CLRF   xE3
07C02:  CLRF   xE4
07C04:  CLRF   xE5
07C06:  CLRF   xE6
07C08:  CLRF   xE7
07C0A:  CLRF   xE8
07C0C:  CLRF   xE9
07C0E:  CLRF   xEA
07C10:  CLRF   xEB
07C12:  CLRF   xEC
07C14:  CLRF   xED
07C16:  CLRF   xEE
07C18:  CLRF   xEF
07C1A:  CLRF   xF0
07C1C:  CLRF   xF1
07C1E:  CLRF   xF2
07C20:  CLRF   xF3
07C22:  CLRF   xF4
07C24:  CLRF   xF5
07C26:  CLRF   xF6
07C28:  CLRF   xF7
07C2A:  CLRF   xF8
07C2C:  CLRF   xF9
07C2E:  CLRF   xFA
07C30:  CLRF   xFB
07C32:  CLRF   xFC
07C34:  CLRF   xFD
07C36:  CLRF   xFE
07C38:  CLRF   xFF
07C3A:  MOVLB  7
07C3C:  CLRF   x00
07C3E:  CLRF   x01
07C40:  CLRF   x02
07C42:  CLRF   x03
07C44:  CLRF   x04
07C46:  CLRF   x05
07C48:  CLRF   x06
07C4A:  CLRF   x07
07C4C:  CLRF   x08
07C4E:  CLRF   x09
07C50:  CLRF   x0A
07C52:  CLRF   x0B
07C54:  CLRF   x0C
07C56:  CLRF   x0D
07C58:  CLRF   x0E
07C5A:  CLRF   x0F
07C5C:  CLRF   x10
07C5E:  CLRF   x11
07C60:  CLRF   x12
07C62:  CLRF   x13
07C64:  CLRF   x14
07C66:  CLRF   x15
07C68:  CLRF   x16
07C6A:  CLRF   x17
07C6C:  CLRF   x18
07C6E:  CLRF   x19
07C70:  CLRF   x1A
07C72:  CLRF   x1B
07C74:  CLRF   x1C
07C76:  CLRF   x1D
07C78:  CLRF   x1E
07C7A:  CLRF   x1F
07C7C:  CLRF   x20
07C7E:  CLRF   x21
07C80:  CLRF   x22
07C82:  CLRF   x23
07C84:  CLRF   x24
07C86:  CLRF   x25
07C88:  CLRF   x26
07C8A:  CLRF   x27
07C8C:  CLRF   x28
07C8E:  CLRF   x29
07C90:  CLRF   x2A
07C92:  CLRF   x2B
07C94:  CLRF   x2C
07C96:  CLRF   x2D
07C98:  CLRF   x2E
07C9A:  CLRF   x2F
07C9C:  CLRF   x30
07C9E:  CLRF   x31
07CA0:  CLRF   x32
07CA2:  CLRF   x33
07CA4:  CLRF   x34
07CA6:  CLRF   x35
07CA8:  CLRF   x36
07CAA:  CLRF   x37
07CAC:  CLRF   x38
07CAE:  CLRF   x39
07CB0:  CLRF   x3A
07CB2:  CLRF   x3B
07CB4:  CLRF   x3C
07CB6:  CLRF   x3D
07CB8:  CLRF   x3E
07CBA:  CLRF   x3F
07CBC:  CLRF   x40
07CBE:  CLRF   x41
07CC0:  CLRF   x42
07CC2:  CLRF   x43
07CC4:  CLRF   x44
07CC6:  CLRF   x45
07CC8:  CLRF   x46
07CCA:  CLRF   x47
07CCC:  CLRF   x48
07CCE:  CLRF   x49
07CD0:  CLRF   x4A
07CD2:  CLRF   x4B
07CD4:  CLRF   x4C
07CD6:  CLRF   x4D
07CD8:  CLRF   x4E
07CDA:  CLRF   x4F
07CDC:  CLRF   x50
07CDE:  CLRF   x51
07CE0:  CLRF   x52
07CE2:  CLRF   x53
07CE4:  CLRF   x54
07CE6:  CLRF   x55
07CE8:  CLRF   x56
07CEA:  CLRF   x57
07CEC:  CLRF   x58
07CEE:  CLRF   x59
07CF0:  CLRF   x5A
07CF2:  CLRF   x5B
07CF4:  CLRF   x5C
07CF6:  CLRF   x5D
07CF8:  CLRF   x5E
07CFA:  CLRF   x5F
07CFC:  CLRF   x60
07CFE:  CLRF   x61
07D00:  CLRF   x62
07D02:  CLRF   x63
07D04:  CLRF   x64
07D06:  CLRF   x65
07D08:  CLRF   x66
07D0A:  CLRF   x67
07D0C:  CLRF   x68
07D0E:  CLRF   x69
07D10:  CLRF   x6A
07D12:  CLRF   x6B
07D14:  CLRF   x6C
07D16:  CLRF   x6D
07D18:  CLRF   x6E
07D1A:  CLRF   x6F
07D1C:  CLRF   x70
07D1E:  CLRF   x71
07D20:  CLRF   x72
07D22:  CLRF   x73
07D24:  CLRF   x74
07D26:  CLRF   x75
07D28:  CLRF   x76
07D2A:  CLRF   x77
07D2C:  CLRF   x78
07D2E:  CLRF   x79
07D30:  CLRF   x7A
07D32:  CLRF   x7B
07D34:  CLRF   x7C
07D36:  CLRF   x7D
07D38:  CLRF   x7E
07D3A:  CLRF   x7F
07D3C:  CLRF   x80
07D3E:  CLRF   x81
07D40:  CLRF   x82
07D42:  CLRF   x83
07D44:  CLRF   x84
07D46:  CLRF   x85
07D48:  CLRF   x86
07D4A:  CLRF   x87
07D4C:  CLRF   x88
07D4E:  CLRF   x89
07D50:  CLRF   x8A
07D52:  CLRF   x8B
07D54:  CLRF   x8C
07D56:  CLRF   x8D
07D58:  CLRF   x8E
07D5A:  CLRF   x8F
07D5C:  CLRF   x90
07D5E:  CLRF   x91
07D60:  CLRF   x92
07D62:  CLRF   x93
07D64:  CLRF   x94
07D66:  CLRF   x95
07D68:  CLRF   x96
07D6A:  CLRF   x97
07D6C:  CLRF   x98
07D6E:  CLRF   x99
07D70:  CLRF   x9A
07D72:  CLRF   x9B
07D74:  CLRF   x9C
07D76:  CLRF   x9D
07D78:  CLRF   x9E
07D7A:  CLRF   x9F
07D7C:  CLRF   xA0
07D7E:  CLRF   xA1
07D80:  CLRF   xA2
07D82:  CLRF   xA3
07D84:  CLRF   xA4
07D86:  CLRF   xA5
07D88:  CLRF   xA6
07D8A:  CLRF   xA7
07D8C:  CLRF   xA8
07D8E:  CLRF   xA9
07D90:  CLRF   xAA
07D92:  CLRF   xAB
07D94:  CLRF   xAC
07D96:  CLRF   xAD
07D98:  CLRF   xAE
07D9A:  CLRF   xAF
07D9C:  CLRF   xB0
07D9E:  CLRF   xB1
07DA0:  CLRF   xB2
07DA2:  CLRF   xB3
07DA4:  CLRF   xB4
07DA6:  CLRF   xB5
07DA8:  CLRF   xB6
07DAA:  CLRF   xB7
07DAC:  CLRF   xB8
07DAE:  CLRF   xB9
07DB0:  CLRF   xBA
07DB2:  CLRF   xBB
07DB4:  CLRF   xBC
07DB6:  CLRF   xBD
07DB8:  CLRF   xBE
07DBA:  CLRF   xBF
07DBC:  CLRF   xC0
07DBE:  CLRF   xC1
07DC0:  CLRF   xC2
07DC2:  CLRF   xC3
07DC4:  CLRF   xC4
07DC6:  CLRF   xC5
07DC8:  CLRF   xC6
07DCA:  CLRF   xC7
07DCC:  CLRF   xC8
07DCE:  CLRF   xC9
07DD0:  CLRF   xCA
07DD2:  CLRF   xCB
07DD4:  CLRF   xCC
07DD6:  CLRF   xCD
07DD8:  CLRF   xCE
07DDA:  CLRF   xCF
07DDC:  CLRF   xD0
07DDE:  CLRF   xD1
07DE0:  CLRF   xD2
07DE2:  CLRF   xD3
07DE4:  CLRF   xD4
07DE6:  CLRF   xD5
07DE8:  CLRF   xD6
07DEA:  CLRF   xD7
07DEC:  CLRF   xD8
07DEE:  CLRF   xD9
07DF0:  CLRF   xDA
07DF2:  CLRF   xDB
07DF4:  CLRF   xDC
07DF6:  CLRF   xDD
07DF8:  CLRF   xDE
07DFA:  CLRF   xDF
07DFC:  CLRF   xE0
07DFE:  CLRF   xE1
07E00:  CLRF   xE2
07E02:  CLRF   xE3
07E04:  CLRF   xE4
07E06:  CLRF   xE5
07E08:  CLRF   xE6
07E0A:  CLRF   xE7
07E0C:  CLRF   xE8
07E0E:  CLRF   xE9
07E10:  CLRF   xEA
07E12:  CLRF   xEB
07E14:  CLRF   xEC
07E16:  CLRF   xED
07E18:  CLRF   xEE
07E1A:  CLRF   xEF
07E1C:  CLRF   xF0
07E1E:  CLRF   xF1
07E20:  CLRF   xF2
07E22:  CLRF   xF3
07E24:  CLRF   xF4
07E26:  CLRF   xF5
07E28:  CLRF   xF6
07E2A:  CLRF   xF7
07E2C:  CLRF   xF8
07E2E:  CLRF   xF9
07E30:  CLRF   xFA
07E32:  CLRF   xFB
07E34:  CLRF   xFC
07E36:  CLRF   xFD
07E38:  CLRF   xFE
07E3A:  CLRF   xFF
07E3C:  MOVLB  8
07E3E:  CLRF   x00
07E40:  CLRF   x01
07E42:  CLRF   x02
07E44:  CLRF   x03
07E46:  CLRF   x04
07E48:  CLRF   x05
07E4A:  CLRF   x06
07E4C:  CLRF   x07
07E4E:  CLRF   x08
07E50:  CLRF   x09
07E52:  CLRF   x0A
07E54:  CLRF   x0B
07E56:  CLRF   x0C
07E58:  CLRF   x0D
07E5A:  CLRF   x0E
07E5C:  CLRF   x0F
07E5E:  CLRF   x10
07E60:  CLRF   x11
07E62:  CLRF   x12
07E64:  CLRF   x13
07E66:  CLRF   x14
07E68:  CLRF   x15
07E6A:  CLRF   x16
07E6C:  CLRF   x17
07E6E:  CLRF   x18
07E70:  CLRF   x19
07E72:  CLRF   x1A
07E74:  CLRF   x1B
07E76:  CLRF   x1C
07E78:  CLRF   x1D
07E7A:  CLRF   x1E
07E7C:  CLRF   x1F
07E7E:  CLRF   x20
07E80:  CLRF   x21
07E82:  CLRF   x22
07E84:  CLRF   x23
07E86:  CLRF   x24
07E88:  CLRF   x25
07E8A:  CLRF   x26
07E8C:  CLRF   x27
07E8E:  CLRF   x28
07E90:  CLRF   x29
07E92:  CLRF   x2A
07E94:  CLRF   x2B
07E96:  CLRF   x2C
07E98:  CLRF   x2D
07E9A:  CLRF   x2E
07E9C:  CLRF   x2F
07E9E:  CLRF   x30
07EA0:  CLRF   x31
07EA2:  CLRF   x32
07EA4:  CLRF   x33
07EA6:  CLRF   x34
07EA8:  CLRF   x35
07EAA:  CLRF   x36
07EAC:  CLRF   x37
07EAE:  CLRF   x38
07EB0:  CLRF   x39
07EB2:  CLRF   x3A
07EB4:  CLRF   x3B
07EB6:  CLRF   x3C
07EB8:  CLRF   x3D
07EBA:  CLRF   x3E
07EBC:  CLRF   x3F
07EBE:  CLRF   x40
07EC0:  CLRF   x41
07EC2:  CLRF   x42
07EC4:  CLRF   x43
07EC6:  CLRF   x44
07EC8:  CLRF   x45
07ECA:  CLRF   x46
07ECC:  CLRF   x47
07ECE:  CLRF   x48
07ED0:  CLRF   x49
07ED2:  CLRF   x4A
07ED4:  CLRF   x4B
07ED6:  CLRF   x4C
07ED8:  CLRF   x4D
07EDA:  CLRF   x4E
07EDC:  CLRF   x4F
07EDE:  CLRF   x50
07EE0:  CLRF   x51
07EE2:  CLRF   x52
07EE4:  CLRF   x53
07EE6:  CLRF   x54
07EE8:  CLRF   x55
07EEA:  CLRF   x56
07EEC:  CLRF   x57
07EEE:  CLRF   x58
07EF0:  CLRF   x59
07EF2:  CLRF   x5A
07EF4:  CLRF   x5B
07EF6:  CLRF   x5C
07EF8:  CLRF   x5D
07EFA:  CLRF   x5E
07EFC:  CLRF   x5F
07EFE:  CLRF   x60
07F00:  CLRF   x61
07F02:  CLRF   x62
07F04:  CLRF   x63
07F06:  CLRF   x64
07F08:  CLRF   x65
07F0A:  CLRF   x66
07F0C:  CLRF   x67
07F0E:  CLRF   x68
07F10:  CLRF   x69
07F12:  CLRF   x6A
07F14:  CLRF   x6B
07F16:  CLRF   x6C
07F18:  CLRF   x6D
07F1A:  CLRF   x6E
07F1C:  CLRF   x6F
07F1E:  CLRF   x70
07F20:  CLRF   x71
07F22:  CLRF   x72
07F24:  CLRF   x73
07F26:  CLRF   x74
07F28:  CLRF   x75
07F2A:  CLRF   x76
07F2C:  CLRF   x77
07F2E:  CLRF   x78
07F30:  CLRF   x79
07F32:  CLRF   x7A
07F34:  CLRF   x7B
07F36:  CLRF   x7C
07F38:  CLRF   x7D
07F3A:  CLRF   x7E
07F3C:  CLRF   x7F
07F3E:  CLRF   x80
07F40:  CLRF   x81
07F42:  CLRF   x82
07F44:  CLRF   x83
07F46:  CLRF   x84
07F48:  CLRF   x85
07F4A:  CLRF   x86
07F4C:  CLRF   x87
07F4E:  CLRF   x88
07F50:  CLRF   x89
07F52:  CLRF   x8A
07F54:  CLRF   x8B
07F56:  CLRF   x8C
07F58:  CLRF   x8D
07F5A:  CLRF   x8E
07F5C:  CLRF   x8F
07F5E:  CLRF   x90
07F60:  CLRF   x91
07F62:  CLRF   x92
07F64:  CLRF   x93
07F66:  CLRF   x94
07F68:  CLRF   x95
07F6A:  CLRF   x96
07F6C:  CLRF   x97
07F6E:  CLRF   x98
07F70:  CLRF   x99
07F72:  CLRF   x9A
07F74:  CLRF   x9B
07F76:  CLRF   x9C
07F78:  CLRF   x9D
07F7A:  CLRF   x9E
07F7C:  CLRF   x9F
07F7E:  CLRF   xA0
07F80:  CLRF   xA1
07F82:  CLRF   xA2
07F84:  CLRF   xA3
07F86:  CLRF   xA4
07F88:  CLRF   xA5
07F8A:  CLRF   xA6
07F8C:  CLRF   xA7
07F8E:  CLRF   xA8
07F90:  CLRF   xA9
07F92:  CLRF   xAA
07F94:  CLRF   xAB
07F96:  CLRF   xAC
07F98:  CLRF   xAD
07F9A:  CLRF   xAE
07F9C:  CLRF   xAF
07F9E:  CLRF   xB0
07FA0:  CLRF   xB1
07FA2:  CLRF   xB2
07FA4:  CLRF   xB3
07FA6:  CLRF   xB4
07FA8:  CLRF   xB5
07FAA:  CLRF   xB6
07FAC:  CLRF   xB7
07FAE:  CLRF   xB8
07FB0:  CLRF   xB9
07FB2:  CLRF   xBA
07FB4:  CLRF   xBB
07FB6:  CLRF   xBC
07FB8:  CLRF   xBD
07FBA:  CLRF   xBE
07FBC:  CLRF   xBF
07FBE:  CLRF   xC0
07FC0:  CLRF   xC1
07FC2:  CLRF   xC2
07FC4:  CLRF   xC3
07FC6:  CLRF   xC4
07FC8:  CLRF   xC5
07FCA:  CLRF   xC6
07FCC:  CLRF   xC7
07FCE:  CLRF   xC8
07FD0:  CLRF   xC9
07FD2:  CLRF   xCA
07FD4:  CLRF   xCB
07FD6:  CLRF   xCC
07FD8:  CLRF   xCD
07FDA:  CLRF   xCE
07FDC:  CLRF   xCF
07FDE:  CLRF   xD0
07FE0:  CLRF   xD1
07FE2:  CLRF   xD2
07FE4:  CLRF   xD3
07FE6:  CLRF   xD4
07FE8:  CLRF   xD5
07FEA:  CLRF   xD6
07FEC:  CLRF   xD7
07FEE:  CLRF   xD8
07FF0:  CLRF   xD9
07FF2:  CLRF   xDA
07FF4:  CLRF   xDB
07FF6:  CLRF   xDC
07FF8:  CLRF   xDD
07FFA:  CLRF   xDE
07FFC:  CLRF   xDF
07FFE:  CLRF   xE0
08000:  CLRF   xE1
08002:  CLRF   xE2
08004:  CLRF   xE3
08006:  CLRF   xE4
08008:  CLRF   xE5
0800A:  CLRF   xE6
0800C:  CLRF   xE7
0800E:  CLRF   xE8
08010:  CLRF   xE9
08012:  CLRF   xEA
08014:  CLRF   xEB
08016:  CLRF   xEC
08018:  CLRF   xED
0801A:  CLRF   xEE
0801C:  CLRF   xEF
0801E:  CLRF   xF0
08020:  CLRF   xF1
08022:  CLRF   xF2
08024:  CLRF   xF3
08026:  CLRF   xF4
08028:  CLRF   xF5
0802A:  CLRF   xF6
0802C:  CLRF   xF7
0802E:  CLRF   xF8
08030:  CLRF   xF9
08032:  CLRF   xFA
08034:  CLRF   xFB
08036:  CLRF   xFC
08038:  CLRF   xFD
0803A:  CLRF   xFE
0803C:  CLRF   xFF
0803E:  MOVLB  9
08040:  CLRF   x00
08042:  CLRF   x01
08044:  CLRF   x02
08046:  CLRF   x03
08048:  CLRF   x04
0804A:  CLRF   x05
0804C:  CLRF   x06
0804E:  CLRF   x07
08050:  CLRF   x08
08052:  CLRF   x09
08054:  CLRF   x0A
08056:  CLRF   x0B
08058:  CLRF   x0C
0805A:  CLRF   x0D
0805C:  CLRF   x0E
0805E:  CLRF   x0F
08060:  CLRF   x10
08062:  CLRF   x11
08064:  CLRF   x12
08066:  CLRF   x13
08068:  CLRF   x14
0806A:  CLRF   x15
0806C:  CLRF   x16
0806E:  CLRF   x17
08070:  CLRF   x18
08072:  CLRF   x19
08074:  CLRF   x1A
08076:  CLRF   x1B
08078:  CLRF   x1C
0807A:  CLRF   x1D
0807C:  CLRF   x1E
0807E:  CLRF   x1F
08080:  CLRF   x20
08082:  CLRF   x21
08084:  CLRF   x22
08086:  CLRF   x23
08088:  CLRF   x24
0808A:  CLRF   x25
0808C:  CLRF   x26
0808E:  CLRF   x27
08090:  CLRF   x28
08092:  CLRF   x29
08094:  CLRF   x2A
08096:  CLRF   x2B
08098:  CLRF   x2C
0809A:  CLRF   x2D
0809C:  CLRF   x2E
0809E:  CLRF   x2F
080A0:  CLRF   x30
080A2:  CLRF   x31
080A4:  CLRF   x32
080A6:  CLRF   x33
080A8:  CLRF   x34
080AA:  CLRF   x35
080AC:  CLRF   x36
080AE:  CLRF   x37
080B0:  CLRF   x38
080B2:  CLRF   x39
080B4:  CLRF   x3A
080B6:  CLRF   x3B
080B8:  CLRF   x3C
080BA:  CLRF   x3D
080BC:  CLRF   x3E
080BE:  CLRF   x3F
080C0:  CLRF   x40
080C2:  CLRF   x41
080C4:  CLRF   x42
080C6:  CLRF   x43
080C8:  CLRF   x44
080CA:  CLRF   x45
080CC:  CLRF   x46
080CE:  CLRF   x47
080D0:  CLRF   x48
080D2:  CLRF   x49
080D4:  CLRF   x4A
080D6:  CLRF   x4B
080D8:  CLRF   x4C
080DA:  CLRF   x4D
080DC:  CLRF   x4E
080DE:  CLRF   x4F
080E0:  CLRF   x50
080E2:  CLRF   x51
080E4:  CLRF   x52
080E6:  CLRF   x53
080E8:  CLRF   x54
080EA:  CLRF   x55
080EC:  CLRF   x56
080EE:  CLRF   x57
080F0:  CLRF   x58
080F2:  CLRF   x59
080F4:  CLRF   x5A
080F6:  CLRF   x5B
080F8:  CLRF   x5C
080FA:  CLRF   x5D
080FC:  CLRF   x5E
080FE:  CLRF   x5F
08100:  CLRF   x60
08102:  CLRF   x61
08104:  CLRF   x62
08106:  CLRF   x63
08108:  CLRF   x64
0810A:  CLRF   x65
0810C:  CLRF   x66
0810E:  CLRF   x67
08110:  CLRF   x68
08112:  CLRF   x69
08114:  CLRF   x6A
08116:  CLRF   x6B
08118:  CLRF   x6C
0811A:  CLRF   x6D
0811C:  CLRF   x6E
0811E:  CLRF   x6F
08120:  CLRF   x70
08122:  CLRF   x71
08124:  CLRF   x72
08126:  CLRF   x73
08128:  CLRF   x74
0812A:  CLRF   x75
0812C:  CLRF   x76
0812E:  CLRF   x77
08130:  CLRF   x78
08132:  CLRF   x79
08134:  CLRF   x7A
08136:  CLRF   x7B
08138:  CLRF   x7C
0813A:  CLRF   x7D
0813C:  CLRF   x7E
0813E:  CLRF   x7F
08140:  CLRF   x80
08142:  CLRF   x81
08144:  CLRF   x82
08146:  CLRF   x83
08148:  CLRF   x84
0814A:  CLRF   x85
0814C:  CLRF   x86
0814E:  CLRF   x87
08150:  CLRF   x88
08152:  CLRF   x89
08154:  CLRF   x8A
08156:  CLRF   x8B
08158:  CLRF   x8C
0815A:  CLRF   x8D
0815C:  CLRF   x8E
0815E:  CLRF   x8F
08160:  CLRF   x90
08162:  CLRF   x91
08164:  CLRF   x92
08166:  CLRF   x93
08168:  CLRF   x94
0816A:  CLRF   x95
0816C:  CLRF   x96
0816E:  CLRF   x97
08170:  CLRF   x98
08172:  CLRF   x99
08174:  CLRF   x9A
08176:  CLRF   x9B
08178:  CLRF   x9C
0817A:  CLRF   x9D
0817C:  CLRF   x9E
0817E:  CLRF   x9F
08180:  CLRF   xA0
08182:  CLRF   xA1
08184:  CLRF   xA2
08186:  CLRF   xA3
08188:  CLRF   xA4
0818A:  CLRF   xA5
0818C:  CLRF   xA6
0818E:  CLRF   xA7
08190:  CLRF   xA8
08192:  CLRF   xA9
08194:  CLRF   xAA
08196:  CLRF   xAB
08198:  CLRF   xAC
0819A:  CLRF   xAD
0819C:  CLRF   xAE
0819E:  CLRF   xAF
081A0:  CLRF   xB0
....................     port2.port_num = 2;
081A2:  MOVLW  02
081A4:  MOVLB  5
081A6:  MOVWF  xB1
....................     port2.sweep_step = 0;
081A8:  CLRF   xB3
081AA:  CLRF   xB2
....................     port2.active = 1;
081AC:  MOVLB  9
081AE:  BSF    xB0.0
.................... 
....................     int16 count = 1;
081B0:  CLRF   xB2
081B2:  MOVLW  01
081B4:  MOVWF  xB1
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
081B6:  CLRF   xC3
081B8:  MOVLW  01
081BA:  MOVWF  xC2
081BC:  MOVLB  0
081BE:  CALL   2128
....................     mcp4901_2_write(1);
081C2:  MOVLB  9
081C4:  CLRF   xC3
081C6:  MOVLW  01
081C8:  MOVWF  xC2
081CA:  MOVLB  0
081CC:  CALL   216A
....................     ad7490_read(ADC_CIGS1_CURR);
081D0:  MOVLW  01
081D2:  MOVLB  9
081D4:  MOVWF  xD7
081D6:  MOVLB  0
081D8:  CALL   1DCA
....................     ad7490_read(ADC_CIGS1_CURR);
081DC:  MOVLW  01
081DE:  MOVLB  9
081E0:  MOVWF  xD7
081E2:  MOVLB  0
081E4:  CALL   1DCA
....................     ad7490_read(ADC_CIGS2_CURR);
081E8:  MOVLW  05
081EA:  MOVLB  9
081EC:  MOVWF  xD7
081EE:  MOVLB  0
081F0:  CALL   1DCA
....................     ad7490_read(ADC_CIGS2_CURR);
081F4:  MOVLW  05
081F6:  MOVLB  9
081F8:  MOVWF  xD7
081FA:  MOVLB  0
081FC:  CALL   1DCA
....................     delay_ms(200);
08200:  MOVLW  C8
08202:  MOVLB  A
08204:  MOVWF  x6E
08206:  MOVLB  0
08208:  CALL   1B5A
.................... 
....................     // Read initial PD value
....................     MEASUREMENT_DATA measured_data = create_meas_data();
0820C:  GOTO   6558
08210:  MOVFF  02,03
08214:  MOVF   01,W
08216:  MOVWF  FE1
08218:  MOVFF  03,FE2
0821C:  MOVLW  09
0821E:  MOVWF  FEA
08220:  MOVLW  B3
08222:  MOVWF  FE9
08224:  MOVLW  0F
08226:  MOVWF  01
08228:  MOVFF  FE6,FEE
0822C:  DECFSZ 01,F
0822E:  GOTO   8228
....................     // Continue measurement while at least one port is active
....................     while (port1.active || port2.active)
08232:  MOVLB  5
08234:  BTFSS  xB0.0
08236:  BRA    823E
08238:  MOVLB  0
0823A:  GOTO   824E
0823E:  MOVLB  0
08240:  MOVLB  9
08242:  BTFSC  xB0.0
08244:  BRA    824C
08246:  MOVLB  0
08248:  GOTO   879E
0824C:  MOVLB  0
....................     {
....................         // Set DAC values for both ports (synchronized timing)
....................         mcp4901_1_write(count);
0824E:  MOVFF  9B2,9C3
08252:  MOVFF  9B1,9C2
08256:  CALL   2128
....................         mcp4901_2_write(count);
0825A:  MOVFF  9B2,9C3
0825E:  MOVFF  9B1,9C2
08262:  CALL   216A
....................         delay_ms(100); // wait for DAC to stabilize
08266:  MOVLW  64
08268:  MOVLB  A
0826A:  MOVWF  x6E
0826C:  MOVLB  0
0826E:  CALL   1B5A
.................... 
....................         // Read CIGS1 data (port1) only if still active
....................         if (port1.active) {
08272:  MOVLB  5
08274:  BTFSC  xB0.0
08276:  BRA    827E
08278:  MOVLB  0
0827A:  GOTO   837E
0827E:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
08280:  BCF    FD8.0
08282:  MOVLB  9
08284:  RLCF   xB1,W
08286:  MOVWF  02
08288:  RLCF   xB2,W
0828A:  MOVWF  03
0828C:  MOVF   02,W
0828E:  ADDLW  B4
08290:  MOVWF  01
08292:  MOVLW  01
08294:  ADDWFC 03,F
08296:  MOVF   01,W
08298:  MOVWF  xC2
0829A:  MOVFF  03,9C3
0829E:  MOVLW  02
082A0:  MOVWF  xD7
082A2:  MOVLB  0
082A4:  CALL   1DCA
082A8:  MOVFF  9C3,FEA
082AC:  MOVFF  9C2,FE9
082B0:  MOVFF  02,FEC
082B4:  MOVF   FED,F
082B6:  MOVFF  01,FEF
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
082BA:  BCF    FD8.0
082BC:  MOVLB  9
082BE:  RLCF   xB1,W
082C0:  MOVWF  02
082C2:  RLCF   xB2,W
082C4:  MOVWF  03
082C6:  MOVF   02,W
082C8:  ADDLW  B4
082CA:  MOVWF  01
082CC:  MOVLW  01
082CE:  ADDWFC 03,F
082D0:  MOVF   01,W
082D2:  MOVWF  xC2
082D4:  MOVFF  03,9C3
082D8:  MOVLW  02
082DA:  MOVWF  xD7
082DC:  MOVLB  0
082DE:  CALL   1DCA
082E2:  MOVFF  9C3,FEA
082E6:  MOVFF  9C2,FE9
082EA:  MOVFF  02,FEC
082EE:  MOVF   FED,F
082F0:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
082F4:  BCF    FD8.0
082F6:  MOVLB  9
082F8:  RLCF   xB1,W
082FA:  MOVWF  02
082FC:  RLCF   xB2,W
082FE:  MOVWF  03
08300:  MOVF   02,W
08302:  ADDLW  B2
08304:  MOVWF  01
08306:  MOVLW  03
08308:  ADDWFC 03,F
0830A:  MOVF   01,W
0830C:  MOVWF  xC2
0830E:  MOVFF  03,9C3
08312:  MOVLW  01
08314:  MOVWF  xD7
08316:  MOVLB  0
08318:  CALL   1DCA
0831C:  MOVFF  9C3,FEA
08320:  MOVFF  9C2,FE9
08324:  MOVFF  02,FEC
08328:  MOVF   FED,F
0832A:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
0832E:  BCF    FD8.0
08330:  MOVLB  9
08332:  RLCF   xB1,W
08334:  MOVWF  02
08336:  RLCF   xB2,W
08338:  MOVWF  03
0833A:  MOVF   02,W
0833C:  ADDLW  B2
0833E:  MOVWF  01
08340:  MOVLW  03
08342:  ADDWFC 03,F
08344:  MOVF   01,W
08346:  MOVWF  xC2
08348:  MOVFF  03,9C3
0834C:  MOVLW  01
0834E:  MOVWF  xD7
08350:  MOVLB  0
08352:  CALL   1DCA
08356:  MOVFF  9C3,FEA
0835A:  MOVFF  9C2,FE9
0835E:  MOVFF  02,FEC
08362:  MOVF   FED,F
08364:  MOVFF  01,FEF
....................             // fprintf(PC, "CIGS1 data: %04LD, %04LD\r\n", port1.data_buffer[0][count], port1.data_buffer[1][count]);
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
08368:  MOVLW  01
0836A:  MOVLB  9
0836C:  ADDWF  xB1,W
0836E:  MOVLB  1
08370:  MOVWF  xB2
08372:  MOVLW  00
08374:  MOVLB  9
08376:  ADDWFC xB2,W
08378:  MOVLB  1
0837A:  MOVWF  xB3
0837C:  MOVLB  0
....................         }
....................         
....................         // Read CIGS2 data (port2) only if still active
....................         if (port2.active) {
0837E:  MOVLB  9
08380:  BTFSC  xB0.0
08382:  BRA    838A
08384:  MOVLB  0
08386:  GOTO   8532
0838A:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
0838C:  BCF    FD8.0
0838E:  MOVLB  9
08390:  RLCF   xB1,W
08392:  MOVWF  02
08394:  RLCF   xB2,W
08396:  MOVWF  03
08398:  MOVF   02,W
0839A:  ADDLW  B4
0839C:  MOVWF  01
0839E:  MOVLW  05
083A0:  ADDWFC 03,F
083A2:  MOVF   01,W
083A4:  MOVWF  xC2
083A6:  MOVFF  03,9C3
083AA:  MOVLW  06
083AC:  MOVWF  xD7
083AE:  MOVLB  0
083B0:  CALL   1DCA
083B4:  MOVFF  9C3,FEA
083B8:  MOVFF  9C2,FE9
083BC:  MOVFF  02,FEC
083C0:  MOVF   FED,F
083C2:  MOVFF  01,FEF
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
083C6:  BCF    FD8.0
083C8:  MOVLB  9
083CA:  RLCF   xB1,W
083CC:  MOVWF  02
083CE:  RLCF   xB2,W
083D0:  MOVWF  03
083D2:  MOVF   02,W
083D4:  ADDLW  B4
083D6:  MOVWF  01
083D8:  MOVLW  05
083DA:  ADDWFC 03,F
083DC:  MOVF   01,W
083DE:  MOVWF  xC2
083E0:  MOVFF  03,9C3
083E4:  MOVLW  06
083E6:  MOVWF  xD7
083E8:  MOVLB  0
083EA:  CALL   1DCA
083EE:  MOVFF  9C3,FEA
083F2:  MOVFF  9C2,FE9
083F6:  MOVFF  02,FEC
083FA:  MOVF   FED,F
083FC:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
08400:  BCF    FD8.0
08402:  MOVLB  9
08404:  RLCF   xB1,W
08406:  MOVWF  02
08408:  RLCF   xB2,W
0840A:  MOVWF  03
0840C:  MOVF   02,W
0840E:  ADDLW  B2
08410:  MOVWF  01
08412:  MOVLW  07
08414:  ADDWFC 03,F
08416:  MOVF   01,W
08418:  MOVWF  xC2
0841A:  MOVFF  03,9C3
0841E:  MOVLW  05
08420:  MOVWF  xD7
08422:  MOVLB  0
08424:  CALL   1DCA
08428:  MOVFF  9C3,FEA
0842C:  MOVFF  9C2,FE9
08430:  MOVFF  02,FEC
08434:  MOVF   FED,F
08436:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
0843A:  BCF    FD8.0
0843C:  MOVLB  9
0843E:  RLCF   xB1,W
08440:  MOVWF  02
08442:  RLCF   xB2,W
08444:  MOVWF  03
08446:  MOVF   02,W
08448:  ADDLW  B2
0844A:  MOVWF  01
0844C:  MOVLW  07
0844E:  ADDWFC 03,F
08450:  MOVF   01,W
08452:  MOVWF  xC2
08454:  MOVFF  03,9C3
08458:  MOVLW  05
0845A:  MOVWF  xD7
0845C:  MOVLB  0
0845E:  CALL   1DCA
08462:  MOVFF  9C3,FEA
08466:  MOVFF  9C2,FE9
0846A:  MOVFF  02,FEC
0846E:  MOVF   FED,F
08470:  MOVFF  01,FEF
....................             fprintf(PC, "CIGS2 data: %04LD, %04LD\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
08474:  BCF    FD8.0
08476:  MOVLB  9
08478:  RLCF   xB1,W
0847A:  MOVWF  02
0847C:  RLCF   xB2,W
0847E:  MOVWF  03
08480:  MOVF   02,W
08482:  ADDLW  B4
08484:  MOVWF  FE9
08486:  MOVLW  05
08488:  ADDWFC 03,W
0848A:  MOVWF  FEA
0848C:  MOVFF  FEC,9C3
08490:  MOVF   FED,F
08492:  MOVFF  FEF,9C2
08496:  BCF    FD8.0
08498:  RLCF   xB1,W
0849A:  MOVWF  02
0849C:  RLCF   xB2,W
0849E:  MOVWF  03
084A0:  MOVF   02,W
084A2:  ADDLW  B2
084A4:  MOVWF  FE9
084A6:  MOVLW  07
084A8:  ADDWFC 03,W
084AA:  MOVWF  FEA
084AC:  MOVFF  FEC,9C5
084B0:  MOVF   FED,F
084B2:  MOVFF  FEF,9C4
084B6:  MOVLW  44
084B8:  MOVWF  FF6
084BA:  MOVLW  06
084BC:  MOVWF  FF7
084BE:  MOVLW  00
084C0:  MOVWF  FF8
084C2:  MOVLW  0C
084C4:  MOVWF  xC6
084C6:  MOVLB  0
084C8:  CALL   1C0A
084CC:  MOVLW  0A
084CE:  MOVWF  FE9
084D0:  MOVFF  9C3,9C7
084D4:  MOVFF  9C2,9C6
084D8:  CALL   65E2
084DC:  MOVLW  2C
084DE:  MOVLB  A
084E0:  MOVWF  xAD
084E2:  MOVLB  0
084E4:  CALL   1B88
084E8:  MOVLW  20
084EA:  MOVLB  A
084EC:  MOVWF  xAD
084EE:  MOVLB  0
084F0:  CALL   1B88
084F4:  MOVLW  0A
084F6:  MOVWF  FE9
084F8:  MOVFF  9C5,9C7
084FC:  MOVFF  9C4,9C6
08500:  CALL   65E2
08504:  MOVLW  0D
08506:  MOVLB  A
08508:  MOVWF  xAD
0850A:  MOVLB  0
0850C:  CALL   1B88
08510:  MOVLW  0A
08512:  MOVLB  A
08514:  MOVWF  xAD
08516:  MOVLB  0
08518:  CALL   1B88
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
0851C:  MOVLW  01
0851E:  MOVLB  9
08520:  ADDWF  xB1,W
08522:  MOVLB  5
08524:  MOVWF  xB2
08526:  MOVLW  00
08528:  MOVLB  9
0852A:  ADDWFC xB2,W
0852C:  MOVLB  5
0852E:  MOVWF  xB3
08530:  MOVLB  0
....................         }
.................... 
....................         count++;
08532:  MOVLB  9
08534:  INCF   xB1,F
08536:  BTFSC  FD8.2
08538:  INCF   xB2,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
0853A:  MOVF   xB2,F
0853C:  BTFSC  FD8.2
0853E:  BRA    8546
08540:  MOVLB  0
08542:  GOTO   855A
08546:  MOVLB  0
08548:  MOVLB  9
0854A:  MOVF   xB1,W
0854C:  SUBLW  FE
0854E:  BTFSS  FD8.0
08550:  BRA    8558
08552:  MOVLB  0
08554:  GOTO   859E
08558:  MOVLB  0
....................             fprintf(PC, "Maximum step count reached: %ld\r\n", count);
0855A:  MOVLW  60
0855C:  MOVWF  FF6
0855E:  MOVLW  06
08560:  MOVWF  FF7
08562:  MOVLW  00
08564:  MOVWF  FF8
08566:  MOVLW  1C
08568:  MOVLB  9
0856A:  MOVWF  xC6
0856C:  MOVLB  0
0856E:  CALL   1C0A
08572:  MOVLW  10
08574:  MOVWF  FE9
08576:  MOVFF  9B2,9C7
0857A:  MOVFF  9B1,9C6
0857E:  CALL   65E2
08582:  MOVLW  0D
08584:  MOVLB  A
08586:  MOVWF  xAD
08588:  MOVLB  0
0858A:  CALL   1B88
0858E:  MOVLW  0A
08590:  MOVLB  A
08592:  MOVWF  xAD
08594:  MOVLB  0
08596:  CALL   1B88
....................             break;
0859A:  GOTO   879E
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
0859E:  MOVLB  5
085A0:  BTFSC  xB0.0
085A2:  BRA    85AA
085A4:  MOVLB  0
085A6:  GOTO   869C
085AA:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
085AC:  MOVLW  01
085AE:  MOVLB  9
085B0:  SUBWF  xB1,W
085B2:  MOVWF  xC2
085B4:  MOVLW  00
085B6:  SUBWFB xB2,W
085B8:  MOVWF  xC3
085BA:  BCF    FD8.0
085BC:  RLCF   xC2,W
085BE:  MOVWF  02
085C0:  RLCF   xC3,W
085C2:  MOVWF  03
085C4:  MOVF   02,W
085C6:  ADDLW  B2
085C8:  MOVWF  FE9
085CA:  MOVLW  03
085CC:  ADDWFC 03,W
085CE:  MOVWF  FEA
085D0:  MOVFF  FEC,9C3
085D4:  MOVF   FED,F
085D6:  MOVFF  FEF,9C2
085DA:  MOVF   xC3,W
085DC:  MOVLB  1
085DE:  SUBWF  xB0,W
085E0:  BTFSC  FD8.0
085E2:  BRA    85EA
085E4:  MOVLB  0
085E6:  GOTO   8626
085EA:  MOVLB  0
085EC:  BTFSS  FD8.2
085EE:  GOTO   8606
085F2:  MOVLB  1
085F4:  MOVF   xAF,W
085F6:  MOVLB  9
085F8:  SUBWF  xC2,W
085FA:  BTFSS  FD8.0
085FC:  BRA    8604
085FE:  MOVLB  0
08600:  GOTO   8626
08604:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current limit reached:");
08606:  MOVLW  82
08608:  MOVWF  FF6
0860A:  MOVLW  06
0860C:  MOVWF  FF7
0860E:  MOVLW  00
08610:  MOVWF  FF8
08612:  CALL   1BDA
....................                 port1.active = 0;
08616:  MOVLB  5
08618:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
0861A:  MOVLW  5E
0861C:  MOVWF  F94
0861E:  BCF    F8B.0
08620:  MOVLB  0
....................             }
08622:  GOTO   869C
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
08626:  MOVLW  01
08628:  MOVLB  9
0862A:  SUBWF  xB1,W
0862C:  MOVWF  xC2
0862E:  MOVLW  00
08630:  SUBWFB xB2,W
08632:  MOVWF  xC3
08634:  BCF    FD8.0
08636:  RLCF   xC2,W
08638:  MOVWF  02
0863A:  RLCF   xC3,W
0863C:  MOVWF  03
0863E:  MOVF   02,W
08640:  ADDLW  B2
08642:  MOVWF  FE9
08644:  MOVLW  03
08646:  ADDWFC 03,W
08648:  MOVWF  FEA
0864A:  MOVFF  FEC,9C3
0864E:  MOVF   FED,F
08650:  MOVFF  FEF,9C2
08654:  MOVF   xC3,W
08656:  MOVLB  1
08658:  SUBWF  xAC,W
0865A:  BTFSC  FD8.0
0865C:  BRA    8664
0865E:  MOVLB  0
08660:  GOTO   869C
08664:  MOVLB  0
08666:  BTFSS  FD8.2
08668:  GOTO   8680
0866C:  MOVLB  1
0866E:  MOVF   xAB,W
08670:  MOVLB  9
08672:  SUBWF  xC2,W
08674:  BTFSS  FD8.0
08676:  BRA    867E
08678:  MOVLB  0
0867A:  GOTO   869C
0867E:  MOVLB  0
....................                 fprintf(PC, "CIGS1 current below threshold");
08680:  MOVLW  A0
08682:  MOVWF  FF6
08684:  MOVLW  06
08686:  MOVWF  FF7
08688:  MOVLW  00
0868A:  MOVWF  FF8
0868C:  CALL   1BDA
....................                 port1.active = 0;
08690:  MOVLB  5
08692:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
08694:  MOVLW  5E
08696:  MOVWF  F94
08698:  BCF    F8B.0
0869A:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
0869C:  MOVLB  9
0869E:  BTFSC  xB0.0
086A0:  BRA    86A8
086A2:  MOVLB  0
086A4:  GOTO   879A
086A8:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
086AA:  MOVLW  01
086AC:  MOVLB  9
086AE:  SUBWF  xB1,W
086B0:  MOVWF  xC2
086B2:  MOVLW  00
086B4:  SUBWFB xB2,W
086B6:  MOVWF  xC3
086B8:  BCF    FD8.0
086BA:  RLCF   xC2,W
086BC:  MOVWF  02
086BE:  RLCF   xC3,W
086C0:  MOVWF  03
086C2:  MOVF   02,W
086C4:  ADDLW  B2
086C6:  MOVWF  FE9
086C8:  MOVLW  07
086CA:  ADDWFC 03,W
086CC:  MOVWF  FEA
086CE:  MOVFF  FEC,9C3
086D2:  MOVF   FED,F
086D4:  MOVFF  FEF,9C2
086D8:  MOVF   xC3,W
086DA:  MOVLB  1
086DC:  SUBWF  xB0,W
086DE:  BTFSC  FD8.0
086E0:  BRA    86E8
086E2:  MOVLB  0
086E4:  GOTO   8724
086E8:  MOVLB  0
086EA:  BTFSS  FD8.2
086EC:  GOTO   8704
086F0:  MOVLB  1
086F2:  MOVF   xAF,W
086F4:  MOVLB  9
086F6:  SUBWF  xC2,W
086F8:  BTFSS  FD8.0
086FA:  BRA    8702
086FC:  MOVLB  0
086FE:  GOTO   8724
08702:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current limit reached: ");
08704:  MOVLW  BE
08706:  MOVWF  FF6
08708:  MOVLW  06
0870A:  MOVWF  FF7
0870C:  MOVLW  00
0870E:  MOVWF  FF8
08710:  CALL   1BDA
....................                 port2.active = 0;
08714:  MOVLB  9
08716:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08718:  MOVLW  5E
0871A:  MOVWF  F94
0871C:  BCF    F8B.5
0871E:  MOVLB  0
....................             }
08720:  GOTO   879A
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
08724:  MOVLW  01
08726:  MOVLB  9
08728:  SUBWF  xB1,W
0872A:  MOVWF  xC2
0872C:  MOVLW  00
0872E:  SUBWFB xB2,W
08730:  MOVWF  xC3
08732:  BCF    FD8.0
08734:  RLCF   xC2,W
08736:  MOVWF  02
08738:  RLCF   xC3,W
0873A:  MOVWF  03
0873C:  MOVF   02,W
0873E:  ADDLW  B2
08740:  MOVWF  FE9
08742:  MOVLW  07
08744:  ADDWFC 03,W
08746:  MOVWF  FEA
08748:  MOVFF  FEC,9C3
0874C:  MOVF   FED,F
0874E:  MOVFF  FEF,9C2
08752:  MOVF   xC3,W
08754:  MOVLB  1
08756:  SUBWF  xAC,W
08758:  BTFSC  FD8.0
0875A:  BRA    8762
0875C:  MOVLB  0
0875E:  GOTO   879A
08762:  MOVLB  0
08764:  BTFSS  FD8.2
08766:  GOTO   877E
0876A:  MOVLB  1
0876C:  MOVF   xAB,W
0876E:  MOVLB  9
08770:  SUBWF  xC2,W
08772:  BTFSS  FD8.0
08774:  BRA    877C
08776:  MOVLB  0
08778:  GOTO   879A
0877C:  MOVLB  0
....................                 fprintf(PC, "CIGS2 current below threshold:");
0877E:  MOVLW  DC
08780:  MOVWF  FF6
08782:  MOVLW  06
08784:  MOVWF  FF7
08786:  MOVLW  00
08788:  MOVWF  FF8
0878A:  CALL   1BDA
....................                 port2.active = 0;
0878E:  MOVLB  9
08790:  BCF    xB0.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
08792:  MOVLW  5E
08794:  MOVWF  F94
08796:  BCF    F8B.5
08798:  MOVLB  0
....................             }
....................         }
0879A:  GOTO   8232
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
0879E:  MOVLW  5E
087A0:  MOVWF  F94
087A2:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
087A4:  MOVLW  5E
087A6:  MOVWF  F94
087A8:  BCF    F8B.5
....................     // output_high(EN_NPWR);
.................... 
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
087AA:  MOVLW  09
087AC:  MOVLB  9
087AE:  MOVWF  xC3
087B0:  MOVLW  B3
087B2:  MOVWF  xC2
087B4:  MOVLW  01
087B6:  MOVWF  xC5
087B8:  MOVLW  B1
087BA:  MOVWF  xC4
087BC:  MOVLB  0
087BE:  CALL   6B3A
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
087C2:  MOVLW  09
087C4:  MOVLB  9
087C6:  MOVWF  xC3
087C8:  MOVLW  B3
087CA:  MOVWF  xC2
087CC:  MOVLW  05
087CE:  MOVWF  xC5
087D0:  MOVLW  B1
087D2:  MOVWF  xC4
087D4:  MOVLB  0
087D6:  CALL   6B3A
.................... 
....................     fprintf(PC, "End SWEEP with threshold\r\n");
087DA:  MOVLW  FC
087DC:  MOVWF  FF6
087DE:  MOVLW  06
087E0:  MOVWF  FF7
087E2:  MOVLW  00
087E4:  MOVWF  FF8
087E6:  CALL   1BDA
087EA:  GOTO   8D90 (RETURN)
.................... }
.................... 
.................... 
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data)
*
06BBE:  CLRF   x06
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; // Initialize packet data with 0x00
*
06B3A:  MOVLB  9
06B3C:  CLRF   xC6
06B3E:  CLRF   xC7
06B40:  CLRF   xC8
06B42:  CLRF   xC9
06B44:  CLRF   xCA
06B46:  CLRF   xCB
06B48:  CLRF   xCC
06B4A:  CLRF   xCD
06B4C:  CLRF   xCE
06B4E:  CLRF   xCF
06B50:  CLRF   xD0
06B52:  CLRF   xD1
06B54:  CLRF   xD2
06B56:  CLRF   xD3
06B58:  CLRF   xD4
06B5A:  CLRF   xD5
06B5C:  CLRF   xD6
06B5E:  CLRF   xD7
06B60:  CLRF   xD8
06B62:  CLRF   xD9
06B64:  CLRF   xDA
06B66:  CLRF   xDB
06B68:  CLRF   xDC
06B6A:  CLRF   xDD
06B6C:  CLRF   xDE
06B6E:  CLRF   xDF
06B70:  CLRF   xE0
06B72:  CLRF   xE1
06B74:  CLRF   xE2
06B76:  CLRF   xE3
06B78:  CLRF   xE4
06B7A:  CLRF   xE5
06B7C:  CLRF   xE6
06B7E:  CLRF   xE7
06B80:  CLRF   xE8
06B82:  CLRF   xE9
06B84:  CLRF   xEA
06B86:  CLRF   xEB
06B88:  CLRF   xEC
06B8A:  CLRF   xED
06B8C:  CLRF   xEE
06B8E:  CLRF   xEF
06B90:  CLRF   xF0
06B92:  CLRF   xF1
06B94:  CLRF   xF2
06B96:  CLRF   xF3
06B98:  CLRF   xF4
06B9A:  CLRF   xF5
06B9C:  CLRF   xF6
06B9E:  CLRF   xF7
06BA0:  CLRF   xF8
06BA2:  CLRF   xF9
06BA4:  CLRF   xFA
06BA6:  CLRF   xFB
06BA8:  CLRF   xFC
06BAA:  CLRF   xFD
06BAC:  CLRF   xFE
06BAE:  CLRF   xFF
06BB0:  MOVLB  A
06BB2:  CLRF   x00
06BB4:  CLRF   x01
06BB6:  CLRF   x02
06BB8:  CLRF   x03
06BBA:  CLRF   x04
06BBC:  CLRF   x05
....................     unsigned int8 packetdata_index = 0; // Index for packet data
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
06BC0:  MOVLB  9
06BC2:  SETF   xC6
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data->port_num & 0x0F);
06BC4:  MOVF   xC4,W
06BC6:  MOVWF  FE9
06BC8:  MOVF   xC5,W
06BCA:  MOVWF  FEA
06BCC:  MOVF   FEF,W
06BCE:  ANDLW  0F
06BD0:  IORLW  F0
06BD2:  MOVWF  xC7
....................     packetdata[2] = measured_data->time_sec >> 24 & 0xFF;
06BD4:  MOVF   xC2,W
06BD6:  MOVWF  FE9
06BD8:  MOVF   xC3,W
06BDA:  MOVWF  FEA
06BDC:  MOVFF  FEF,A16
06BE0:  MOVFF  FEC,A17
06BE4:  MOVFF  FEC,A18
06BE8:  MOVFF  FEC,A19
06BEC:  MOVF   FED,F
06BEE:  MOVF   FED,F
06BF0:  MOVF   FED,F
06BF2:  MOVFF  A19,A16
06BF6:  MOVLB  A
06BF8:  CLRF   x17
06BFA:  CLRF   x18
06BFC:  CLRF   x19
06BFE:  MOVF   x16,W
06C00:  MOVLB  9
06C02:  MOVWF  xC8
....................     packetdata[3] = measured_data->time_sec >> 16 & 0xFF;
06C04:  MOVF   xC2,W
06C06:  MOVWF  FE9
06C08:  MOVF   xC3,W
06C0A:  MOVWF  FEA
06C0C:  MOVFF  FEF,A16
06C10:  MOVFF  FEC,A17
06C14:  MOVFF  FEC,A18
06C18:  MOVFF  FEC,A19
06C1C:  MOVF   FED,F
06C1E:  MOVF   FED,F
06C20:  MOVF   FED,F
06C22:  MOVFF  A18,A16
06C26:  MOVFF  A19,A17
06C2A:  MOVLB  A
06C2C:  CLRF   x18
06C2E:  CLRF   x19
06C30:  MOVF   x16,W
06C32:  MOVLB  9
06C34:  MOVWF  xC9
....................     packetdata[4] = measured_data->time_sec >> 8 & 0xFF;
06C36:  MOVF   xC2,W
06C38:  MOVWF  FE9
06C3A:  MOVF   xC3,W
06C3C:  MOVWF  FEA
06C3E:  MOVFF  FEF,A16
06C42:  MOVFF  FEC,A17
06C46:  MOVFF  FEC,A18
06C4A:  MOVFF  FEC,A19
06C4E:  MOVF   FED,F
06C50:  MOVF   FED,F
06C52:  MOVF   FED,F
06C54:  MOVFF  A17,A16
06C58:  MOVFF  A18,A17
06C5C:  MOVFF  A19,A18
06C60:  MOVLB  A
06C62:  CLRF   x19
06C64:  MOVF   x16,W
06C66:  MOVLB  9
06C68:  MOVWF  xCA
....................     packetdata[5] = measured_data->time_sec & 0xFF;
06C6A:  MOVF   xC2,W
06C6C:  MOVWF  FE9
06C6E:  MOVF   xC3,W
06C70:  MOVWF  FEA
06C72:  MOVFF  FEF,A16
06C76:  MOVFF  FEC,A17
06C7A:  MOVFF  FEC,A18
06C7E:  MOVFF  FEC,A19
06C82:  MOVF   FED,F
06C84:  MOVF   FED,F
06C86:  MOVF   FED,F
06C88:  MOVLB  A
06C8A:  MOVF   x16,W
06C8C:  MOVLB  9
06C8E:  MOVWF  xCB
....................     packetdata[6] = (measured_data->time_msec & 0x0F) >>4 | measured_data->pd >> 8 & 0x0F;
06C90:  MOVLW  04
06C92:  ADDWF  xC2,W
06C94:  MOVWF  FE9
06C96:  MOVLW  00
06C98:  ADDWFC xC3,W
06C9A:  MOVWF  FEA
06C9C:  MOVF   FEF,W
06C9E:  ANDLW  0F
06CA0:  MOVWF  00
06CA2:  SWAPF  00,W
06CA4:  MOVLB  A
06CA6:  MOVWF  x16
06CA8:  MOVLW  0F
06CAA:  ANDWF  x16,F
06CAC:  MOVLW  0D
06CAE:  MOVLB  9
06CB0:  ADDWF  xC2,W
06CB2:  MOVWF  FE9
06CB4:  MOVLW  00
06CB6:  ADDWFC xC3,W
06CB8:  MOVWF  FEA
06CBA:  MOVFF  FEC,A18
06CBE:  MOVF   FED,F
06CC0:  MOVFF  FEF,A17
06CC4:  MOVFF  A18,A17
06CC8:  MOVLB  A
06CCA:  CLRF   x18
06CCC:  MOVF   x17,W
06CCE:  ANDLW  0F
06CD0:  MOVWF  00
06CD2:  CLRF   03
06CD4:  MOVF   00,W
06CD6:  IORWF  x16,W
06CD8:  MOVLB  9
06CDA:  MOVWF  xCC
....................     packetdata[7] = measured_data->pd & 0xFF;
06CDC:  MOVLW  0D
06CDE:  ADDWF  xC2,W
06CE0:  MOVWF  FE9
06CE2:  MOVLW  00
06CE4:  ADDWFC xC3,W
06CE6:  MOVWF  FEA
06CE8:  MOVFF  FEC,A17
06CEC:  MOVF   FED,F
06CEE:  MOVFF  FEF,A16
06CF2:  MOVLB  A
06CF4:  MOVF   x16,W
06CF6:  MOVLB  9
06CF8:  MOVWF  xCD
....................     packetdata[8] = (measured_data->open_voltage >> 4) & 0xFF; // PD start low byte
06CFA:  MOVLW  05
06CFC:  ADDWF  xC2,W
06CFE:  MOVWF  FE9
06D00:  MOVLW  00
06D02:  ADDWFC xC3,W
06D04:  MOVWF  FEA
06D06:  MOVFF  FEC,A17
06D0A:  MOVF   FED,F
06D0C:  MOVFF  FEF,A16
06D10:  MOVLB  A
06D12:  RRCF   x17,F
06D14:  RRCF   x16,F
06D16:  RRCF   x17,F
06D18:  RRCF   x16,F
06D1A:  RRCF   x17,F
06D1C:  RRCF   x16,F
06D1E:  RRCF   x17,F
06D20:  RRCF   x16,F
06D22:  MOVLW  0F
06D24:  ANDWF  x17,F
06D26:  MOVF   x16,W
06D28:  MOVLB  9
06D2A:  MOVWF  xCE
....................     packetdata[9] = (measured_data->open_voltage & 0x0F) << 4 | (measured_data->temp_py_top >> 8) & 0x0F;
06D2C:  MOVLW  05
06D2E:  ADDWF  xC2,W
06D30:  MOVWF  FE9
06D32:  MOVLW  00
06D34:  ADDWFC xC3,W
06D36:  MOVWF  FEA
06D38:  MOVFF  FEC,A17
06D3C:  MOVF   FED,F
06D3E:  MOVFF  FEF,A16
06D42:  MOVLW  0F
06D44:  MOVLB  A
06D46:  ANDWF  x16,F
06D48:  CLRF   x17
06D4A:  RLCF   x16,F
06D4C:  RLCF   x17,F
06D4E:  RLCF   x16,F
06D50:  RLCF   x17,F
06D52:  RLCF   x16,F
06D54:  RLCF   x17,F
06D56:  RLCF   x16,F
06D58:  RLCF   x17,F
06D5A:  MOVLW  F0
06D5C:  ANDWF  x16,F
06D5E:  MOVLW  07
06D60:  MOVLB  9
06D62:  ADDWF  xC2,W
06D64:  MOVWF  FE9
06D66:  MOVLW  00
06D68:  ADDWFC xC3,W
06D6A:  MOVWF  FEA
06D6C:  MOVFF  FEC,A19
06D70:  MOVF   FED,F
06D72:  MOVFF  FEF,A18
06D76:  MOVFF  A19,A18
06D7A:  MOVLB  A
06D7C:  CLRF   x19
06D7E:  MOVF   x18,W
06D80:  ANDLW  0F
06D82:  MOVWF  00
06D84:  CLRF   03
06D86:  MOVF   00,W
06D88:  IORWF  x16,W
06D8A:  MOVLB  9
06D8C:  MOVWF  xCF
....................     packetdata[10] = measured_data->temp_py_top & 0xFF;
06D8E:  MOVLW  07
06D90:  ADDWF  xC2,W
06D92:  MOVWF  FE9
06D94:  MOVLW  00
06D96:  ADDWFC xC3,W
06D98:  MOVWF  FEA
06D9A:  MOVFF  FEC,A17
06D9E:  MOVF   FED,F
06DA0:  MOVFF  FEF,A16
06DA4:  MOVLB  A
06DA6:  MOVF   x16,W
06DA8:  MOVLB  9
06DAA:  MOVWF  xD0
....................     packetdata[11] = (measured_data->temp_py_bot >> 4) & 0xFF; // PD start low byte
06DAC:  MOVLW  09
06DAE:  ADDWF  xC2,W
06DB0:  MOVWF  FE9
06DB2:  MOVLW  00
06DB4:  ADDWFC xC3,W
06DB6:  MOVWF  FEA
06DB8:  MOVFF  FEC,A17
06DBC:  MOVF   FED,F
06DBE:  MOVFF  FEF,A16
06DC2:  MOVLB  A
06DC4:  RRCF   x17,F
06DC6:  RRCF   x16,F
06DC8:  RRCF   x17,F
06DCA:  RRCF   x16,F
06DCC:  RRCF   x17,F
06DCE:  RRCF   x16,F
06DD0:  RRCF   x17,F
06DD2:  RRCF   x16,F
06DD4:  MOVLW  0F
06DD6:  ANDWF  x17,F
06DD8:  MOVF   x16,W
06DDA:  MOVLB  9
06DDC:  MOVWF  xD1
....................     packetdata[12] = (measured_data->temp_py_bot & 0x0F) << 4 | (measured_data->temp_mis7 >> 8) & 0x0F;
06DDE:  MOVLW  09
06DE0:  ADDWF  xC2,W
06DE2:  MOVWF  FE9
06DE4:  MOVLW  00
06DE6:  ADDWFC xC3,W
06DE8:  MOVWF  FEA
06DEA:  MOVFF  FEC,A17
06DEE:  MOVF   FED,F
06DF0:  MOVFF  FEF,A16
06DF4:  MOVLW  0F
06DF6:  MOVLB  A
06DF8:  ANDWF  x16,F
06DFA:  CLRF   x17
06DFC:  RLCF   x16,F
06DFE:  RLCF   x17,F
06E00:  RLCF   x16,F
06E02:  RLCF   x17,F
06E04:  RLCF   x16,F
06E06:  RLCF   x17,F
06E08:  RLCF   x16,F
06E0A:  RLCF   x17,F
06E0C:  MOVLW  F0
06E0E:  ANDWF  x16,F
06E10:  MOVLW  0B
06E12:  MOVLB  9
06E14:  ADDWF  xC2,W
06E16:  MOVWF  FE9
06E18:  MOVLW  00
06E1A:  ADDWFC xC3,W
06E1C:  MOVWF  FEA
06E1E:  MOVFF  FEC,A19
06E22:  MOVF   FED,F
06E24:  MOVFF  FEF,A18
06E28:  MOVFF  A19,A18
06E2C:  MOVLB  A
06E2E:  CLRF   x19
06E30:  MOVF   x18,W
06E32:  ANDLW  0F
06E34:  MOVWF  00
06E36:  CLRF   03
06E38:  MOVF   00,W
06E3A:  IORWF  x16,W
06E3C:  MOVLB  9
06E3E:  MOVWF  xD2
....................     packetdata[13] = measured_data->temp_mis7 & 0xFF;
06E40:  MOVLW  0B
06E42:  ADDWF  xC2,W
06E44:  MOVWF  FE9
06E46:  MOVLW  00
06E48:  ADDWFC xC3,W
06E4A:  MOVWF  FEA
06E4C:  MOVFF  FEC,A17
06E50:  MOVF   FED,F
06E52:  MOVFF  FEF,A16
06E56:  MOVLB  A
06E58:  MOVF   x16,W
06E5A:  MOVLB  9
06E5C:  MOVWF  xD3
.................... 
....................     packetdata_index = 14; // Start index for data
06E5E:  MOVLW  0E
06E60:  MOVLB  A
06E62:  MOVWF  x06
.................... 
....................     for (unsigned int16 i = 0; i < port_data->sweep_step ; i++) {
06E64:  CLRF   x08
06E66:  CLRF   x07
06E68:  MOVLB  0
06E6A:  MOVLW  01
06E6C:  MOVLB  9
06E6E:  ADDWF  xC4,W
06E70:  MOVWF  FE9
06E72:  MOVLW  00
06E74:  ADDWFC xC5,W
06E76:  MOVWF  FEA
06E78:  MOVFF  FEC,03
06E7C:  MOVF   FED,F
06E7E:  MOVF   FEF,W
06E80:  MOVWF  01
06E82:  MOVLB  A
06E84:  MOVF   x08,W
06E86:  SUBWF  03,W
06E88:  BTFSC  FD8.0
06E8A:  BRA    6E92
06E8C:  MOVLB  0
06E8E:  GOTO   7070
06E92:  MOVLB  0
06E94:  BTFSS  FD8.2
06E96:  GOTO   6EAC
06E9A:  MOVF   01,W
06E9C:  MOVLB  A
06E9E:  SUBWF  x07,W
06EA0:  BTFSS  FD8.0
06EA2:  BRA    6EAA
06EA4:  MOVLB  0
06EA6:  GOTO   7070
06EAA:  MOVLB  0
....................         unsigned int16 data0 = port_data->data_buffer[0][i];
....................         unsigned int16 data1 = port_data->data_buffer[1][i];
06EAC:  BCF    FD8.0
06EAE:  MOVLB  A
06EB0:  RLCF   x07,W
06EB2:  MOVWF  02
06EB4:  RLCF   x08,W
06EB6:  MOVWF  03
06EB8:  MOVF   02,W
06EBA:  ADDLW  03
06EBC:  MOVWF  01
06EBE:  MOVLW  00
06EC0:  ADDWFC 03,F
06EC2:  MOVF   01,W
06EC4:  MOVLB  9
06EC6:  ADDWF  xC4,W
06EC8:  MOVWF  FE9
06ECA:  MOVF   xC5,W
06ECC:  ADDWFC 03,W
06ECE:  MOVWF  FEA
06ED0:  MOVFF  FEC,A0A
06ED4:  MOVF   FED,F
06ED6:  MOVFF  FEF,A09
06EDA:  BCF    FD8.0
06EDC:  MOVLB  A
06EDE:  RLCF   x07,W
06EE0:  MOVWF  02
06EE2:  RLCF   x08,W
06EE4:  MOVWF  03
06EE6:  MOVF   02,W
06EE8:  ADDLW  01
06EEA:  MOVWF  01
06EEC:  MOVLW  02
06EEE:  ADDWFC 03,F
06EF0:  MOVF   01,W
06EF2:  MOVLB  9
06EF4:  ADDWF  xC4,W
06EF6:  MOVWF  FE9
06EF8:  MOVF   xC5,W
06EFA:  ADDWFC 03,W
06EFC:  MOVWF  FEA
06EFE:  MOVFF  FEC,A0C
06F02:  MOVF   FED,F
06F04:  MOVFF  FEF,A0B
06F08:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
06F0A:  MOVLB  A
06F0C:  MOVF   x06,W
06F0E:  INCF   x06,F
06F10:  CLRF   03
06F12:  ADDLW  C6
06F14:  MOVWF  FE9
06F16:  MOVLW  09
06F18:  ADDWFC 03,W
06F1A:  MOVWF  FEA
06F1C:  RRCF   x0A,W
06F1E:  MOVWF  x19
06F20:  RRCF   x09,W
06F22:  MOVWF  x18
06F24:  RRCF   x19,F
06F26:  RRCF   x18,F
06F28:  RRCF   x19,F
06F2A:  RRCF   x18,F
06F2C:  RRCF   x19,F
06F2E:  RRCF   x18,F
06F30:  MOVLW  0F
06F32:  ANDWF  x19,F
06F34:  MOVF   x18,W
06F36:  MOVWF  00
06F38:  CLRF   03
06F3A:  MOVF   00,W
06F3C:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
06F3E:  MOVF   x06,W
06F40:  INCF   x06,F
06F42:  CLRF   03
06F44:  ADDLW  C6
06F46:  MOVWF  FE9
06F48:  MOVLW  09
06F4A:  ADDWFC 03,W
06F4C:  MOVWF  FEA
06F4E:  MOVF   x09,W
06F50:  ANDLW  0F
06F52:  MOVWF  x18
06F54:  CLRF   x19
06F56:  RLCF   x18,F
06F58:  RLCF   x19,F
06F5A:  RLCF   x18,F
06F5C:  RLCF   x19,F
06F5E:  RLCF   x18,F
06F60:  RLCF   x19,F
06F62:  RLCF   x18,F
06F64:  RLCF   x19,F
06F66:  MOVLW  F0
06F68:  ANDWF  x18,F
06F6A:  MOVFF  A0C,A1A
06F6E:  CLRF   x1B
06F70:  MOVF   x1A,W
06F72:  ANDLW  0F
06F74:  MOVWF  00
06F76:  CLRF   03
06F78:  MOVF   00,W
06F7A:  IORWF  x18,W
06F7C:  MOVWF  00
06F7E:  MOVF   03,W
06F80:  IORWF  x19,W
06F82:  MOVWF  03
06F84:  MOVF   00,W
06F86:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
06F88:  MOVF   x06,W
06F8A:  INCF   x06,F
06F8C:  CLRF   03
06F8E:  ADDLW  C6
06F90:  MOVWF  FE9
06F92:  MOVLW  09
06F94:  ADDWFC 03,W
06F96:  MOVWF  FEA
06F98:  MOVF   x0B,W
06F9A:  MOVWF  00
06F9C:  CLRF   03
06F9E:  MOVF   00,W
06FA0:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
06FA2:  MOVLW  03
06FA4:  ADDWF  x06,W
06FA6:  SUBLW  3E
06FA8:  BTFSS  FD8.0
06FAA:  BRA    6FB2
06FAC:  MOVLB  0
06FAE:  GOTO   7062
06FB2:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
06FB4:  MOVLW  09
06FB6:  MOVLB  A
06FB8:  MOVWF  xAE
06FBA:  MOVLW  C6
06FBC:  MOVWF  xAD
06FBE:  MOVLW  3F
06FC0:  MOVWF  xAF
06FC2:  MOVLB  0
06FC4:  CALL   29F8
06FC8:  MOVFF  01,A05
....................             unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
06FCC:  MOVLB  1
06FCE:  MOVF   x40,W
06FD0:  MOVLB  A
06FD2:  MOVWF  x0D
06FD4:  MOVLW  10
06FD6:  MOVLB  1
06FD8:  ADDWF  x41,W
06FDA:  MOVLB  A
06FDC:  MOVWF  x0E
06FDE:  MOVLW  7C
06FE0:  MOVLB  1
06FE2:  ADDWFC x42,W
06FE4:  MOVLB  A
06FE6:  MOVWF  x0F
06FE8:  MOVLW  00
06FEA:  MOVLB  1
06FEC:  ADDWFC x43,W
06FEE:  MOVLB  A
06FF0:  MOVWF  x10
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
06FF2:  MOVFF  111,A59
06FF6:  MOVFF  110,A58
06FFA:  MOVFF  10F,A57
06FFE:  MOVFF  10E,A56
07002:  MOVFF  A10,A5D
07006:  MOVFF  A0F,A5C
0700A:  MOVFF  A0E,A5B
0700E:  MOVFF  A0D,A5A
07012:  MOVLW  09
07014:  MOVWF  x5F
07016:  MOVLW  C6
07018:  MOVWF  x5E
0701A:  CLRF   x61
0701C:  MOVLW  40
0701E:  MOVWF  x60
07020:  MOVLB  0
07022:  CALL   34FA
....................             iv_data.used_counter += PACKET_SIZE;
07026:  MOVLW  40
07028:  MOVLB  1
0702A:  ADDWF  x40,F
0702C:  MOVLW  00
0702E:  ADDWFC x41,F
07030:  MOVLW  00
07032:  ADDWFC x42,F
07034:  MOVLW  00
07036:  ADDWFC x43,F
....................             iv_data.uncopied_counter += PACKET_SIZE;
07038:  MOVLW  40
0703A:  ADDWF  x44,F
0703C:  MOVLW  00
0703E:  ADDWFC x45,F
07040:  MOVLW  00
07042:  ADDWFC x46,F
07044:  MOVLW  00
07046:  ADDWFC x47,F
....................             packetdata_index = 0;
07048:  MOVLB  A
0704A:  CLRF   x06
....................             memset(packetdata, 0x00, PACKET_SIZE);
0704C:  MOVLW  09
0704E:  MOVWF  FEA
07050:  MOVLW  C6
07052:  MOVWF  FE9
07054:  CLRF   00
07056:  CLRF   02
07058:  MOVLW  40
0705A:  MOVWF  01
0705C:  MOVLB  0
0705E:  CALL   27BC
....................         }
07062:  MOVLB  A
07064:  INCF   x07,F
07066:  BTFSC  FD8.2
07068:  INCF   x08,F
0706A:  MOVLB  0
0706C:  GOTO   6E6A
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
07070:  MOVLB  A
07072:  MOVF   x06,F
07074:  BTFSS  FD8.2
07076:  BRA    707E
07078:  MOVLB  0
0707A:  GOTO   714A
0707E:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
07080:  MOVFF  A06,A11
07084:  MOVLB  A
07086:  MOVF   x11,W
07088:  SUBLW  3E
0708A:  BTFSC  FD8.0
0708C:  BRA    7094
0708E:  MOVLB  0
07090:  GOTO   70B4
07094:  MOVLB  0
....................             packetdata[j] = 0x00;
07096:  CLRF   03
07098:  MOVLB  A
0709A:  MOVF   x11,W
0709C:  ADDLW  C6
0709E:  MOVWF  FE9
070A0:  MOVLW  09
070A2:  ADDWFC 03,W
070A4:  MOVWF  FEA
070A6:  CLRF   FEF
070A8:  MOVLB  0
070AA:  MOVLB  A
070AC:  INCF   x11,F
070AE:  MOVLB  0
070B0:  GOTO   7084
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
070B4:  MOVLW  09
070B6:  MOVLB  A
070B8:  MOVWF  xAE
070BA:  MOVLW  C6
070BC:  MOVWF  xAD
070BE:  MOVLW  3F
070C0:  MOVWF  xAF
070C2:  MOVLB  0
070C4:  CALL   29F8
070C8:  MOVFF  01,A05
....................         unsigned int32 write_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter;
070CC:  MOVLB  1
070CE:  MOVF   x40,W
070D0:  MOVLB  A
070D2:  MOVWF  x12
070D4:  MOVLW  10
070D6:  MOVLB  1
070D8:  ADDWF  x41,W
070DA:  MOVLB  A
070DC:  MOVWF  x13
070DE:  MOVLW  7C
070E0:  MOVLB  1
070E2:  ADDWFC x42,W
070E4:  MOVLB  A
070E6:  MOVWF  x14
070E8:  MOVLW  00
070EA:  MOVLB  1
070EC:  ADDWFC x43,W
070EE:  MOVLB  A
070F0:  MOVWF  x15
....................         write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
070F2:  MOVFF  111,A59
070F6:  MOVFF  110,A58
070FA:  MOVFF  10F,A57
070FE:  MOVFF  10E,A56
07102:  MOVFF  A15,A5D
07106:  MOVFF  A14,A5C
0710A:  MOVFF  A13,A5B
0710E:  MOVFF  A12,A5A
07112:  MOVLW  09
07114:  MOVWF  x5F
07116:  MOVLW  C6
07118:  MOVWF  x5E
0711A:  CLRF   x61
0711C:  MOVLW  40
0711E:  MOVWF  x60
07120:  MOVLB  0
07122:  CALL   34FA
....................         iv_data.used_counter += PACKET_SIZE;
07126:  MOVLW  40
07128:  MOVLB  1
0712A:  ADDWF  x40,F
0712C:  MOVLW  00
0712E:  ADDWFC x41,F
07130:  MOVLW  00
07132:  ADDWFC x42,F
07134:  MOVLW  00
07136:  ADDWFC x43,F
....................         iv_data.uncopied_counter += PACKET_SIZE;
07138:  MOVLW  40
0713A:  ADDWF  x44,F
0713C:  MOVLW  00
0713E:  ADDWFC x45,F
07140:  MOVLW  00
07142:  ADDWFC x46,F
07144:  MOVLW  00
07146:  ADDWFC x47,F
07148:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "End CIGS data conversion\r\n");
0714A:  MOVLW  18
0714C:  MOVWF  FF6
0714E:  MOVLW  07
07150:  MOVWF  FF7
07152:  MOVLW  00
07154:  MOVWF  FF8
07156:  CALL   1BDA
....................     write_misf_address_area(); // Write the mission flash address area
0715A:  GOTO   6AC2
0715E:  RETURN 0
.................... }
.................... 
.................... MEASUREMENT_DATA create_meas_data()
.................... {
....................     MEASUREMENT_DATA data;
....................     data.time_sec = get_current_sec();
*
06558:  CALL   31DC
0655C:  MOVFF  03,9CB
06560:  MOVFF  02,9CA
06564:  MOVFF  01,9C9
06568:  MOVFF  00,9C8
....................     data.time_msec = get_current_msec();
0656C:  GOTO   6528
06570:  MOVFF  01,9CC
....................     data.temp_py_top = ad7490_read(ADC_TEMP_PY_TOP);
06574:  MOVLW  0D
06576:  MOVLB  9
06578:  MOVWF  xD7
0657A:  MOVLB  0
0657C:  CALL   1DCA
06580:  MOVFF  02,9D0
06584:  MOVFF  01,9CF
....................     data.temp_py_bot = ad7490_read(ADC_TEMP_PY_BOT);
06588:  MOVLW  0E
0658A:  MOVLB  9
0658C:  MOVWF  xD7
0658E:  MOVLB  0
06590:  CALL   1DCA
06594:  MOVFF  02,9D2
06598:  MOVFF  01,9D1
....................     data.temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
0659C:  MOVLW  0C
0659E:  MOVLB  9
065A0:  MOVWF  xD7
065A2:  MOVLB  0
065A4:  CALL   1DCA
065A8:  MOVFF  02,9D4
065AC:  MOVFF  01,9D3
....................     data.pd = ad7490_read(ADC_PD);
065B0:  MOVLW  0F
065B2:  MOVLB  9
065B4:  MOVWF  xD7
065B6:  MOVLB  0
065B8:  CALL   1DCA
065BC:  MOVFF  02,9D6
065C0:  MOVFF  01,9D5
....................     data.open_voltage = ad7490_read(ADC_CIGS1_VOLT); // Assuming this is the correct ADC channel for open voltage
065C4:  MOVLB  9
065C6:  CLRF   xD7
065C8:  MOVLB  0
065CA:  CALL   1DCA
065CE:  MOVFF  02,9CE
065D2:  MOVFF  01,9CD
....................     return data;
065D6:  MOVLW  C8
065D8:  MOVWF  01
065DA:  MOVLW  09
065DC:  MOVWF  02
065DE:  GOTO   8210 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../core/logging/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../hardware/mcu/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... // External clock source for Timer1
.................... // Must Add a 32.768 kHz crystal to the T1CKI pin (pin 6 of PIC16F1789)
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../storage/mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
.................... {
....................     PICLOG_t piclog;
....................     memset(piclog.bytes, 0, PICLOG_PACKET_SIZE);
*
0387E:  MOVLW  01
03880:  MOVWF  FEA
03882:  MOVLW  E2
03884:  MOVWF  FE9
03886:  CLRF   00
03888:  CLRF   02
0388A:  MOVLW  06
0388C:  MOVWF  01
0388E:  CALL   27BC
....................     piclog.fields.time = get_current_sec();
03892:  CALL   31DC
03896:  MOVFF  03,1E5
0389A:  MOVFF  02,1E4
0389E:  MOVFF  01,1E3
038A2:  MOVFF  00,1E2
....................     piclog.fields.function = function;
038A6:  MOVFF  1E0,1E6
....................     piclog.fields.parameter = parameter;
038AA:  MOVFF  1E1,1E7
.................... 
....................     printf("\t[PICLOG] : ");
038AE:  MOVLW  34
038B0:  MOVWF  FF6
038B2:  MOVLW  07
038B4:  MOVWF  FF7
038B6:  MOVLW  00
038B8:  MOVWF  FF8
038BA:  CALL   1BDA
....................     for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
038BE:  MOVLB  1
038C0:  CLRF   xE8
038C2:  MOVLB  0
038C4:  MOVLB  1
038C6:  MOVF   xE8,W
038C8:  SUBLW  05
038CA:  BTFSC  FD8.0
038CC:  BRA    38D4
038CE:  MOVLB  0
038D0:  GOTO   3910
038D4:  MOVLB  0
....................         printf("%02X ", piclog.bytes[i]);
038D6:  CLRF   03
038D8:  MOVLB  1
038DA:  MOVF   xE8,W
038DC:  ADDLW  E2
038DE:  MOVWF  FE9
038E0:  MOVLW  01
038E2:  ADDWFC 03,W
038E4:  MOVWF  FEA
038E6:  MOVFF  FEF,1ED
038EA:  MOVFF  1ED,264
038EE:  MOVLW  37
038F0:  MOVLB  2
038F2:  MOVWF  x65
038F4:  MOVLB  0
038F6:  CALL   1E5E
038FA:  MOVLW  20
038FC:  MOVLB  A
038FE:  MOVWF  xAD
03900:  MOVLB  0
03902:  CALL   1B88
03906:  MOVLB  1
03908:  INCF   xE8,F
0390A:  MOVLB  0
0390C:  GOTO   38C4
....................     }
....................     printf("\r\n");
03910:  MOVLW  0D
03912:  MOVLB  A
03914:  MOVWF  xAD
03916:  MOVLB  0
03918:  CALL   1B88
0391C:  MOVLW  0A
0391E:  MOVLB  A
03920:  MOVWF  xAD
03922:  MOVLB  0
03924:  CALL   1B88
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
03928:  MOVLB  1
0392A:  MOVF   x1F,W
0392C:  MOVWF  xE9
0392E:  MOVF   x20,W
03930:  MOVWF  xEA
03932:  MOVLW  01
03934:  ADDWF  x21,W
03936:  MOVWF  xEB
03938:  MOVLW  00
0393A:  ADDWFC x22,W
0393C:  MOVWF  xEC
....................     write_data_bytes(mis_fm, write_address, piclog.bytes, PICLOG_PACKET_SIZE);
0393E:  MOVFF  111,A59
03942:  MOVFF  110,A58
03946:  MOVFF  10F,A57
0394A:  MOVFF  10E,A56
0394E:  MOVFF  1EC,A5D
03952:  MOVFF  1EB,A5C
03956:  MOVFF  1EA,A5B
0395A:  MOVFF  1E9,A5A
0395E:  MOVLW  01
03960:  MOVLB  A
03962:  MOVWF  x5F
03964:  MOVLW  E2
03966:  MOVWF  x5E
03968:  CLRF   x61
0396A:  MOVLW  06
0396C:  MOVWF  x60
0396E:  MOVLB  0
03970:  CALL   34FA
.................... 
....................     piclog_data.used_counter += PICLOG_PACKET_SIZE;
03974:  MOVLW  06
03976:  MOVLB  1
03978:  ADDWF  x1F,F
0397A:  MOVLW  00
0397C:  ADDWFC x20,F
0397E:  MOVLW  00
03980:  ADDWFC x21,F
03982:  MOVLW  00
03984:  ADDWFC x22,F
....................     piclog_data.uncopied_counter += PICLOG_PACKET_SIZE;
03986:  MOVLW  06
03988:  ADDWF  x23,F
0398A:  MOVLW  00
0398C:  ADDWFC x24,F
0398E:  MOVLW  00
03990:  ADDWFC x25,F
03992:  MOVLW  00
03994:  ADDWFC x26,F
....................     piclog_data.reserve_counter1 += PICLOG_PACKET_SIZE;
03996:  MOVLW  06
03998:  ADDWF  x27,F
.................... 
....................     // Next Packet
....................     if (piclog_data.reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
0399A:  MOVLW  06
0399C:  ADDWF  x27,W
0399E:  SUBLW  3F
039A0:  BTFSS  FD8.0
039A2:  BRA    39AA
039A4:  MOVLB  0
039A6:  GOTO   3A1E
039AA:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter;
039AC:  MOVLB  1
039AE:  MOVF   x1F,W
039B0:  MOVWF  xE9
039B2:  MOVF   x20,W
039B4:  MOVWF  xEA
039B6:  MOVLW  01
039B8:  ADDWF  x21,W
039BA:  MOVWF  xEB
039BC:  MOVLW  00
039BE:  ADDWFC x22,W
039C0:  MOVWF  xEC
....................         write_data_bytes(mis_fm, write_address, PICLOG_BLANK_DATA, sizeof(PICLOG_BLANK_DATA));
039C2:  MOVFF  111,A59
039C6:  MOVFF  110,A58
039CA:  MOVFF  10F,A57
039CE:  MOVFF  10E,A56
039D2:  MOVFF  1EC,A5D
039D6:  MOVFF  1EB,A5C
039DA:  MOVFF  1EA,A5B
039DE:  MOVFF  1E9,A5A
039E2:  MOVLW  01
039E4:  MOVLB  A
039E6:  MOVWF  x5F
039E8:  MOVLW  4A
039EA:  MOVWF  x5E
039EC:  CLRF   x61
039EE:  MOVLW  04
039F0:  MOVWF  x60
039F2:  MOVLB  0
039F4:  CALL   34FA
....................         piclog_data.used_counter += sizeof(PICLOG_BLANK_DATA);
039F8:  MOVLW  04
039FA:  MOVLB  1
039FC:  ADDWF  x1F,F
039FE:  MOVLW  00
03A00:  ADDWFC x20,F
03A02:  MOVLW  00
03A04:  ADDWFC x21,F
03A06:  MOVLW  00
03A08:  ADDWFC x22,F
....................         piclog_data.uncopied_counter += sizeof(PICLOG_BLANK_DATA);
03A0A:  MOVLW  04
03A0C:  ADDWF  x23,F
03A0E:  MOVLW  00
03A10:  ADDWFC x24,F
03A12:  MOVLW  00
03A14:  ADDWFC x25,F
03A16:  MOVLW  00
03A18:  ADDWFC x26,F
....................         piclog_data.reserve_counter1 = 0;
03A1A:  CLRF   x27
03A1C:  MOVLB  0
....................     }
.................... 
....................     // write_misf_address_area(); // Update the address area after writing
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
....................     #ifdef PICLOG_DEBUG
03A1E:  RETURN 0
....................         //fprintf(PC, "PICLOG written: %02X %02X %02X %02X %02X %02X\r\n", piclog_data.bytes[0], data[1], data[2], data[3], data[4], data[5]);
....................     #endif
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
*
05B3C:  MOVLB  1
05B3E:  CLRF   xD3
05B40:  CLRF   xD4
05B42:  CLRF   xD5
05B44:  CLRF   xD6
05B46:  CLRF   xD7
05B48:  CLRF   xD8
05B4A:  CLRF   xD9
05B4C:  CLRF   xDA
05B4E:  CLRF   xDB
05B50:  CLRF   xDC
05B52:  CLRF   xDD
05B54:  CLRF   xDE
05B56:  CLRF   xDF
05B58:  CLRF   xE0
05B5A:  CLRF   xE1
05B5C:  CLRF   xE2
05B5E:  CLRF   xE3
05B60:  CLRF   xE4
05B62:  CLRF   xE5
05B64:  CLRF   xE6
05B66:  CLRF   xE7
05B68:  CLRF   xE8
05B6A:  CLRF   xE9
05B6C:  CLRF   xEA
05B6E:  CLRF   xEB
05B70:  CLRF   xEC
05B72:  CLRF   xED
05B74:  CLRF   xEE
05B76:  CLRF   xEF
05B78:  CLRF   xF0
05B7A:  CLRF   xF1
05B7C:  CLRF   xF2
05B7E:  CLRF   xF3
05B80:  CLRF   xF4
05B82:  CLRF   xF5
05B84:  CLRF   xF6
05B86:  CLRF   xF7
05B88:  CLRF   xF8
05B8A:  CLRF   xF9
05B8C:  CLRF   xFA
05B8E:  CLRF   xFB
05B90:  CLRF   xFC
05B92:  CLRF   xFD
05B94:  CLRF   xFE
05B96:  CLRF   xFF
05B98:  MOVLB  2
05B9A:  CLRF   x00
05B9C:  CLRF   x01
05B9E:  CLRF   x02
05BA0:  CLRF   x03
05BA2:  CLRF   x04
05BA4:  CLRF   x05
05BA6:  CLRF   x06
05BA8:  CLRF   x07
05BAA:  CLRF   x08
05BAC:  CLRF   x09
05BAE:  CLRF   x0A
05BB0:  CLRF   x0B
05BB2:  CLRF   x0C
05BB4:  CLRF   x0D
05BB6:  CLRF   x0E
05BB8:  CLRF   x0F
05BBA:  CLRF   x10
05BBC:  CLRF   x11
05BBE:  CLRF   x12
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
05BC0:  MOVLW  01
05BC2:  MOVLB  A
05BC4:  MOVWF  xAE
05BC6:  MOVLW  D3
05BC8:  MOVWF  xAD
05BCA:  MOVLW  3F
05BCC:  MOVWF  xAF
05BCE:  MOVLB  0
05BD0:  CALL   29F8
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
05BD4:  MOVFF  115,A59
05BD8:  MOVFF  114,A58
05BDC:  MOVFF  113,A57
05BE0:  MOVFF  112,A56
05BE4:  MOVLW  06
05BE6:  MOVLB  A
05BE8:  MOVWF  x5D
05BEA:  MOVLW  AA
05BEC:  MOVWF  x5C
05BEE:  CLRF   x5B
05BF0:  CLRF   x5A
05BF2:  MOVLW  01
05BF4:  MOVWF  x5F
05BF6:  MOVLW  D3
05BF8:  MOVWF  x5E
05BFA:  CLRF   x61
05BFC:  MOVLW  40
05BFE:  MOVWF  x60
05C00:  MOVLB  0
05C02:  CALL   34FA
05C06:  GOTO   5D56 (RETURN)
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
097A4:  MOVLB  2
097A6:  MOVF   x60,W
097A8:  MOVWF  01
097AA:  MOVF   x61,W
097AC:  MOVWF  03
097AE:  MOVF   01,W
097B0:  MOVWF  x63
097B2:  MOVFF  03,264
097B6:  MOVFF  115,2E5
097BA:  MOVFF  114,2E4
097BE:  MOVFF  113,2E3
097C2:  MOVFF  112,2E2
097C6:  MOVLW  06
097C8:  MOVWF  xE9
097CA:  MOVLW  AA
097CC:  MOVWF  xE8
097CE:  CLRF   xE7
097D0:  CLRF   xE6
097D2:  MOVFF  264,2EB
097D6:  MOVFF  263,2EA
097DA:  CLRF   xEF
097DC:  CLRF   xEE
097DE:  CLRF   xED
097E0:  MOVLW  40
097E2:  MOVWF  xEC
097E4:  MOVLB  0
097E6:  CALL   27E0
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
097EA:  MOVLB  2
097EC:  CLRF   x62
097EE:  MOVLB  0
097F0:  MOVLB  2
097F2:  MOVF   x62,W
097F4:  SUBLW  04
097F6:  BTFSC  FD8.0
097F8:  BRA    9800
097FA:  MOVLB  0
097FC:  GOTO   98CA
09800:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
09802:  MOVLB  2
09804:  MOVF   x60,W
09806:  MOVWF  01
09808:  MOVF   x61,W
0980A:  MOVWF  03
0980C:  MOVF   01,W
0980E:  MOVWF  x63
09810:  MOVFF  03,264
09814:  MOVFF  115,2E5
09818:  MOVFF  114,2E4
0981C:  MOVFF  113,2E3
09820:  MOVFF  112,2E2
09824:  MOVLW  06
09826:  MOVWF  xE9
09828:  MOVLW  AA
0982A:  MOVWF  xE8
0982C:  CLRF   xE7
0982E:  CLRF   xE6
09830:  MOVFF  264,2EB
09834:  MOVFF  263,2EA
09838:  CLRF   xEF
0983A:  CLRF   xEE
0983C:  CLRF   xED
0983E:  MOVLW  40
09840:  MOVWF  xEC
09842:  MOVLB  0
09844:  CALL   27E0
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
09848:  MOVLB  2
0984A:  MOVF   x60,W
0984C:  MOVWF  01
0984E:  MOVF   x61,W
09850:  MOVWF  03
09852:  MOVF   01,W
09854:  MOVWF  x63
09856:  MOVFF  03,264
0985A:  MOVFF  264,2E3
0985E:  MOVFF  263,2E2
09862:  MOVLW  3F
09864:  MOVWF  xE4
09866:  MOVLB  0
09868:  CALL   9756
0986C:  MOVF   01,F
0986E:  BTFSC  FD8.2
09870:  GOTO   98C0
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
09874:  MOVLW  01
09876:  MOVLB  2
09878:  ADDWF  x62,W
0987A:  MOVWF  x63
0987C:  MOVLW  42
0987E:  MOVWF  FF6
09880:  MOVLW  07
09882:  MOVWF  FF7
09884:  MOVLW  00
09886:  MOVWF  FF8
09888:  MOVLW  23
0988A:  MOVLB  9
0988C:  MOVWF  xC6
0988E:  MOVLB  0
09890:  CALL   1C0A
09894:  MOVFF  263,264
09898:  MOVLW  1B
0989A:  MOVLB  2
0989C:  MOVWF  x65
0989E:  MOVLB  0
098A0:  CALL   63A4
098A4:  MOVLW  0D
098A6:  MOVLB  A
098A8:  MOVWF  xAD
098AA:  MOVLB  0
098AC:  CALL   1B88
098B0:  MOVLW  0A
098B2:  MOVLB  A
098B4:  MOVWF  xAD
098B6:  MOVLB  0
098B8:  CALL   1B88
....................             break;
098BC:  GOTO   98CA
....................         }
098C0:  MOVLB  2
098C2:  INCF   x62,F
098C4:  MOVLB  0
098C6:  GOTO   97F0
....................     }
098CA:  GOTO   9D40 (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
099E0:  CALL   676A
099E4:  MOVFF  02,03
099E8:  MOVF   01,W
099EA:  MOVWF  FE1
099EC:  MOVFF  03,FE2
099F0:  MOVLW  02
099F2:  MOVWF  FEA
099F4:  MOVLW  60
099F6:  MOVWF  FE9
099F8:  MOVLW  40
099FA:  MOVWF  01
099FC:  MOVFF  FE6,FEE
09A00:  DECFSZ 01,F
09A02:  GOTO   99FC
09A06:  MOVLB  2
09A08:  BCF    xE0.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
09A0A:  CLRF   xE1
09A0C:  MOVLB  0
09A0E:  MOVLB  2
09A10:  MOVF   xE1,W
09A12:  SUBLW  04
09A14:  BTFSC  FD8.0
09A16:  BRA    9A1E
09A18:  MOVLB  0
09A1A:  GOTO   9B1E
09A1E:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
09A20:  MOVFF  115,2E5
09A24:  MOVFF  114,2E4
09A28:  MOVFF  113,2E3
09A2C:  MOVFF  112,2E2
09A30:  MOVLW  06
09A32:  MOVLB  2
09A34:  MOVWF  xE9
09A36:  MOVLW  AA
09A38:  MOVWF  xE8
09A3A:  CLRF   xE7
09A3C:  CLRF   xE6
09A3E:  MOVLB  0
09A40:  CALL   469C
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
09A44:  MOVFF  115,A59
09A48:  MOVFF  114,A58
09A4C:  MOVFF  113,A57
09A50:  MOVFF  112,A56
09A54:  MOVLW  06
09A56:  MOVLB  A
09A58:  MOVWF  x5D
09A5A:  MOVLW  AA
09A5C:  MOVWF  x5C
09A5E:  CLRF   x5B
09A60:  CLRF   x5A
09A62:  MOVLW  02
09A64:  MOVWF  x5F
09A66:  MOVLW  60
09A68:  MOVWF  x5E
09A6A:  CLRF   x61
09A6C:  MOVLW  40
09A6E:  MOVWF  x60
09A70:  MOVLB  0
09A72:  CALL   34FA
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
09A76:  MOVFF  115,2E5
09A7A:  MOVFF  114,2E4
09A7E:  MOVFF  113,2E3
09A82:  MOVFF  112,2E2
09A86:  MOVLW  06
09A88:  MOVLB  2
09A8A:  MOVWF  xE9
09A8C:  MOVLW  AA
09A8E:  MOVWF  xE8
09A90:  CLRF   xE7
09A92:  CLRF   xE6
09A94:  MOVLW  02
09A96:  MOVWF  xEB
09A98:  MOVLW  A0
09A9A:  MOVWF  xEA
09A9C:  CLRF   xEF
09A9E:  CLRF   xEE
09AA0:  CLRF   xED
09AA2:  MOVLW  40
09AA4:  MOVWF  xEC
09AA6:  MOVLB  0
09AA8:  CALL   27E0
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
09AAC:  MOVLW  02
09AAE:  MOVLB  2
09AB0:  MOVWF  xE3
09AB2:  MOVLW  A0
09AB4:  MOVWF  xE2
09AB6:  MOVLW  3F
09AB8:  MOVWF  xE4
09ABA:  MOVLB  0
09ABC:  CALL   9756
09AC0:  MOVF   01,F
09AC2:  BTFSC  FD8.2
09AC4:  GOTO   9B14
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
09AC8:  MOVLW  01
09ACA:  MOVLB  2
09ACC:  ADDWF  xE1,W
09ACE:  MOVWF  xE2
09AD0:  MOVLW  6A
09AD2:  MOVWF  FF6
09AD4:  MOVLW  07
09AD6:  MOVWF  FF7
09AD8:  MOVLW  00
09ADA:  MOVWF  FF8
09ADC:  MOVLW  23
09ADE:  MOVLB  9
09AE0:  MOVWF  xC6
09AE2:  MOVLB  0
09AE4:  CALL   1C0A
09AE8:  MOVFF  2E2,2E3
09AEC:  MOVLW  18
09AEE:  MOVLB  2
09AF0:  MOVWF  xE4
09AF2:  MOVLB  0
09AF4:  CALL   98CE
09AF8:  MOVLW  0D
09AFA:  MOVLB  A
09AFC:  MOVWF  xAD
09AFE:  MOVLB  0
09B00:  CALL   1B88
09B04:  MOVLW  0A
09B06:  MOVLB  A
09B08:  MOVWF  xAD
09B0A:  MOVLB  0
09B0C:  CALL   1B88
....................             break;
09B10:  GOTO   9B1E
....................         }
09B14:  MOVLB  2
09B16:  INCF   xE1,F
09B18:  MOVLB  0
09B1A:  GOTO   9A0E
....................     }
....................     if (!crc_valid)
09B1E:  MOVLB  2
09B20:  BTFSS  xE0.0
09B22:  BRA    9B2A
09B24:  MOVLB  0
09B26:  GOTO   9B6C
09B2A:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
09B2C:  MOVLW  92
09B2E:  MOVWF  FF6
09B30:  MOVLW  07
09B32:  MOVWF  FF7
09B34:  MOVLW  00
09B36:  MOVWF  FF8
09B38:  MOVLW  25
09B3A:  MOVLB  9
09B3C:  MOVWF  xC6
09B3E:  MOVLB  0
09B40:  CALL   1C0A
09B44:  MOVLW  05
09B46:  MOVLB  2
09B48:  MOVWF  xE3
09B4A:  MOVLW  18
09B4C:  MOVWF  xE4
09B4E:  MOVLB  0
09B50:  CALL   98CE
09B54:  MOVLW  B9
09B56:  MOVWF  FF6
09B58:  MOVLW  07
09B5A:  MOVWF  FF7
09B5C:  MOVLW  00
09B5E:  MOVWF  FF8
09B60:  MOVLW  0B
09B62:  MOVLB  9
09B64:  MOVWF  xC6
09B66:  MOVLB  0
09B68:  CALL   1C0A
....................         // return; 
....................     }
09B6C:  GOTO   A4FC (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
09B74:  MOVLW  C6
09B76:  MOVWF  FF6
09B78:  MOVLW  07
09B7A:  MOVWF  FF7
09B7C:  MOVLW  00
09B7E:  MOVWF  FF8
09B80:  CALL   1BDA
....................     fprintf(PC, "_____Start copy_data____\r\n");
09B84:  MOVLW  E0
09B86:  MOVWF  FF6
09B88:  MOVLW  07
09B8A:  MOVWF  FF7
09B8C:  MOVLW  00
09B8E:  MOVWF  FF8
09B90:  CALL   1BDA
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
.................... 
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
09B94:  MOVLB  1
09B96:  MOVF   x8B,W
09B98:  MOVWF  FE9
09B9A:  MOVF   x8C,W
09B9C:  MOVWF  FEA
09B9E:  MOVFF  FEF,260
09BA2:  MOVFF  260,267
09BA6:  MOVLB  0
09BA8:  CALL   952E
09BAC:  MOVFF  02,03
09BB0:  MOVF   01,W
09BB2:  MOVWF  FE1
09BB4:  MOVFF  03,FE2
09BB8:  MOVLW  01
09BBA:  MOVWF  FEA
09BBC:  MOVLW  CD
09BBE:  MOVWF  FE9
09BC0:  MOVLW  08
09BC2:  MOVWF  01
09BC4:  MOVFF  FE6,FEE
09BC8:  DECFSZ 01,F
09BCA:  GOTO   9BC4
09BCE:  MOVFF  1D0,1D8
09BD2:  MOVFF  1CF,1D7
09BD6:  MOVFF  1CE,1D6
09BDA:  MOVFF  1CD,1D5
09BDE:  MOVFF  1D4,1DC
09BE2:  MOVFF  1D3,1DB
09BE6:  MOVFF  1D2,1DA
09BEA:  MOVFF  1D1,1D9
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
09BEE:  MOVLW  03
09BF0:  MOVLB  1
09BF2:  ADDWF  x8B,W
09BF4:  MOVWF  01
09BF6:  MOVLW  00
09BF8:  ADDWFC x8C,W
09BFA:  MOVWF  03
09BFC:  MOVF   01,W
09BFE:  MOVWF  FE9
09C00:  MOVFF  03,FEA
09C04:  BTFSS  FEF.0
09C06:  BRA    9C0E
09C08:  MOVLB  0
09C0A:  GOTO   9C6E
09C0E:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
09C10:  MOVLB  1
09C12:  MOVF   x8B,W
09C14:  MOVWF  FE9
09C16:  MOVF   x8C,W
09C18:  MOVWF  FEA
09C1A:  MOVFF  FEF,260
09C1E:  MOVFF  260,267
09C22:  MOVLB  0
09C24:  GOTO   964E
09C28:  MOVFF  02,03
09C2C:  MOVF   01,W
09C2E:  MOVWF  FE1
09C30:  MOVFF  03,FE2
09C34:  MOVLW  01
09C36:  MOVWF  FEA
09C38:  MOVLW  E5
09C3A:  MOVWF  FE9
09C3C:  MOVLW  08
09C3E:  MOVWF  01
09C40:  MOVFF  FE6,FEE
09C44:  DECFSZ 01,F
09C46:  GOTO   9C40
....................         write_src = misf_address.start_address;
09C4A:  MOVFF  1E8,1E0
09C4E:  MOVFF  1E7,1DF
09C52:  MOVFF  1E6,1DE
09C56:  MOVFF  1E5,1DD
....................         write_size = iv_data.uncopied_counter;
09C5A:  MOVFF  147,1E4
09C5E:  MOVFF  146,1E3
09C62:  MOVFF  145,1E2
09C66:  MOVFF  144,1E1
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
09C6A:  GOTO   9CD8
09C6E:  MOVLW  03
09C70:  MOVLB  1
09C72:  ADDWF  x8B,W
09C74:  MOVWF  01
09C76:  MOVLW  00
09C78:  ADDWFC x8C,W
09C7A:  MOVWF  03
09C7C:  MOVF   01,W
09C7E:  MOVWF  FE9
09C80:  MOVFF  03,FEA
09C84:  BTFSC  FEF.0
09C86:  BRA    9C8E
09C88:  MOVLB  0
09C8A:  GOTO   9CD8
09C8E:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
09C90:  MOVLW  04
09C92:  MOVLB  1
09C94:  ADDWF  x8B,W
09C96:  MOVWF  FE9
09C98:  MOVLW  00
09C9A:  ADDWFC x8C,W
09C9C:  MOVWF  FEA
09C9E:  MOVFF  FEF,1DD
09CA2:  MOVFF  FEC,1DE
09CA6:  MOVFF  FEC,1DF
09CAA:  MOVFF  FEC,1E0
09CAE:  MOVF   FED,F
09CB0:  MOVF   FED,F
09CB2:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
09CB4:  MOVLW  08
09CB6:  ADDWF  x8B,W
09CB8:  MOVWF  FE9
09CBA:  MOVLW  00
09CBC:  ADDWFC x8C,W
09CBE:  MOVWF  FEA
09CC0:  MOVFF  FEF,1E1
09CC4:  MOVFF  FEC,1E2
09CC8:  MOVFF  FEC,1E3
09CCC:  MOVFF  FEC,1E4
09CD0:  MOVF   FED,F
09CD2:  MOVF   FED,F
09CD4:  MOVF   FED,F
09CD6:  MOVLB  0
....................     }
.................... 
....................     // 接続確認
....................     if (!is_connect(mis_fm))
09CD8:  MOVFF  111,263
09CDC:  MOVFF  110,262
09CE0:  MOVFF  10F,261
09CE4:  MOVFF  10E,260
09CE8:  CALL   26F4
09CEC:  MOVF   01,F
09CEE:  BTFSS  FD8.2
09CF0:  GOTO   9D04
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
09CF4:  MOVLW  FC
09CF6:  MOVWF  FF6
09CF8:  MOVLW  07
09CFA:  MOVWF  FF7
09CFC:  MOVLW  00
09CFE:  MOVWF  FF8
09D00:  CALL   1BDA
....................     }    
....................     if (!is_connect(smf))
09D04:  MOVFF  115,263
09D08:  MOVFF  114,262
09D0C:  MOVFF  113,261
09D10:  MOVFF  112,260
09D14:  CALL   26F4
09D18:  MOVF   01,F
09D1A:  BTFSS  FD8.2
09D1C:  GOTO   9D30
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
09D20:  MOVLW  1E
09D22:  MOVWF  FF6
09D24:  MOVLW  08
09D26:  MOVWF  FF7
09D28:  MOVLW  00
09D2A:  MOVWF  FF8
09D2C:  CALL   1BDA
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
09D30:  MOVLW  01
09D32:  MOVLB  2
09D34:  MOVWF  x61
09D36:  MOVLW  8D
09D38:  MOVWF  x60
09D3A:  MOVLB  0
09D3C:  GOTO   97A4
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
09D40:  MOVFF  154,1F0
09D44:  MOVFF  153,1EF
09D48:  MOVFF  152,1EE
09D4C:  MOVFF  151,1ED
09D50:  MOVFF  155,1F1
....................     fprintf(PC, "Size area read\r\n");
09D54:  MOVLW  3C
09D56:  MOVWF  FF6
09D58:  MOVLW  08
09D5A:  MOVWF  FF7
09D5C:  MOVLW  00
09D5E:  MOVWF  FF8
09D60:  CALL   1BDA
....................     fprintf(PC, "smf_used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
09D64:  MOVLW  4E
09D66:  MOVWF  FF6
09D68:  MOVLW  08
09D6A:  MOVWF  FF7
09D6C:  MOVLW  00
09D6E:  MOVWF  FF8
09D70:  MOVLW  10
09D72:  MOVLB  9
09D74:  MOVWF  xC6
09D76:  MOVLB  0
09D78:  CALL   1C0A
09D7C:  MOVLW  41
09D7E:  MOVWF  FE9
09D80:  MOVFF  1F0,263
09D84:  MOVFF  1EF,262
09D88:  MOVFF  1EE,261
09D8C:  MOVFF  1ED,260
09D90:  CALL   93B2
09D94:  MOVLW  61
09D96:  MOVWF  FF6
09D98:  MOVLW  08
09D9A:  MOVWF  FF7
09D9C:  MOVLW  00
09D9E:  MOVWF  FF8
09DA0:  MOVLW  08
09DA2:  MOVLB  9
09DA4:  MOVWF  xC6
09DA6:  MOVLB  0
09DA8:  CALL   1C0A
09DAC:  MOVFF  1D8,264
09DB0:  MOVLW  37
09DB2:  MOVLB  2
09DB4:  MOVWF  x65
09DB6:  MOVLB  0
09DB8:  CALL   1E5E
09DBC:  MOVFF  1D7,264
09DC0:  MOVLW  37
09DC2:  MOVLB  2
09DC4:  MOVWF  x65
09DC6:  MOVLB  0
09DC8:  CALL   1E5E
09DCC:  MOVFF  1D6,264
09DD0:  MOVLW  37
09DD2:  MOVLB  2
09DD4:  MOVWF  x65
09DD6:  MOVLB  0
09DD8:  CALL   1E5E
09DDC:  MOVFF  1D5,264
09DE0:  MOVLW  37
09DE2:  MOVLB  2
09DE4:  MOVWF  x65
09DE6:  MOVLB  0
09DE8:  CALL   1E5E
09DEC:  MOVLW  6E
09DEE:  MOVWF  FF6
09DF0:  MOVLW  08
09DF2:  MOVWF  FF7
09DF4:  MOVLW  00
09DF6:  MOVWF  FF8
09DF8:  MOVLW  03
09DFA:  MOVLB  9
09DFC:  MOVWF  xC6
09DFE:  MOVLB  0
09E00:  CALL   1C0A
....................     fprintf(PC, "smf_loop count= %d  (src 0x%08LX)\r\n", loop_count, mis_start_address + 4);
09E04:  MOVLW  04
09E06:  MOVLB  1
09E08:  ADDWF  xD5,W
09E0A:  MOVLB  2
09E0C:  MOVWF  x60
09E0E:  MOVLW  00
09E10:  MOVLB  1
09E12:  ADDWFC xD6,W
09E14:  MOVLB  2
09E16:  MOVWF  x61
09E18:  MOVLW  00
09E1A:  MOVLB  1
09E1C:  ADDWFC xD7,W
09E1E:  MOVLB  2
09E20:  MOVWF  x62
09E22:  MOVLW  00
09E24:  MOVLB  1
09E26:  ADDWFC xD8,W
09E28:  MOVLB  2
09E2A:  MOVWF  x63
09E2C:  MOVLW  72
09E2E:  MOVWF  FF6
09E30:  MOVLW  08
09E32:  MOVWF  FF7
09E34:  MOVLW  00
09E36:  MOVWF  FF8
09E38:  MOVLW  10
09E3A:  MOVLB  9
09E3C:  MOVWF  xC6
09E3E:  MOVLB  0
09E40:  CALL   1C0A
09E44:  MOVFF  1F1,2E3
09E48:  MOVLW  18
09E4A:  MOVLB  2
09E4C:  MOVWF  xE4
09E4E:  MOVLB  0
09E50:  CALL   98CE
09E54:  MOVLW  84
09E56:  MOVWF  FF6
09E58:  MOVLW  08
09E5A:  MOVWF  FF7
09E5C:  MOVLW  00
09E5E:  MOVWF  FF8
09E60:  MOVLW  09
09E62:  MOVLB  9
09E64:  MOVWF  xC6
09E66:  MOVLB  0
09E68:  CALL   1C0A
09E6C:  MOVFF  263,264
09E70:  MOVLW  37
09E72:  MOVLB  2
09E74:  MOVWF  x65
09E76:  MOVLB  0
09E78:  CALL   1E5E
09E7C:  MOVFF  262,264
09E80:  MOVLW  37
09E82:  MOVLB  2
09E84:  MOVWF  x65
09E86:  MOVLB  0
09E88:  CALL   1E5E
09E8C:  MOVFF  261,264
09E90:  MOVLW  37
09E92:  MOVLB  2
09E94:  MOVWF  x65
09E96:  MOVLB  0
09E98:  CALL   1E5E
09E9C:  MOVFF  260,264
09EA0:  MOVLW  37
09EA2:  MOVLB  2
09EA4:  MOVWF  x65
09EA6:  MOVLB  0
09EA8:  CALL   1E5E
09EAC:  MOVLW  92
09EAE:  MOVWF  FF6
09EB0:  MOVLW  08
09EB2:  MOVWF  FF7
09EB4:  MOVLW  00
09EB6:  MOVWF  FF8
09EB8:  MOVLW  03
09EBA:  MOVLB  9
09EBC:  MOVWF  xC6
09EBE:  MOVLB  0
09EC0:  CALL   1C0A
....................     fprintf(PC, "misf_write_source = 0x%08LX\r\n", write_src);
09EC4:  MOVLW  96
09EC6:  MOVWF  FF6
09EC8:  MOVLW  08
09ECA:  MOVWF  FF7
09ECC:  MOVLW  00
09ECE:  MOVWF  FF8
09ED0:  MOVLW  16
09ED2:  MOVLB  9
09ED4:  MOVWF  xC6
09ED6:  MOVLB  0
09ED8:  CALL   1C0A
09EDC:  MOVFF  1E0,264
09EE0:  MOVLW  37
09EE2:  MOVLB  2
09EE4:  MOVWF  x65
09EE6:  MOVLB  0
09EE8:  CALL   1E5E
09EEC:  MOVFF  1DF,264
09EF0:  MOVLW  37
09EF2:  MOVLB  2
09EF4:  MOVWF  x65
09EF6:  MOVLB  0
09EF8:  CALL   1E5E
09EFC:  MOVFF  1DE,264
09F00:  MOVLW  37
09F02:  MOVLB  2
09F04:  MOVWF  x65
09F06:  MOVLB  0
09F08:  CALL   1E5E
09F0C:  MOVFF  1DD,264
09F10:  MOVLW  37
09F12:  MOVLB  2
09F14:  MOVWF  x65
09F16:  MOVLB  0
09F18:  CALL   1E5E
09F1C:  MOVLW  0D
09F1E:  MOVLB  A
09F20:  MOVWF  xAD
09F22:  MOVLB  0
09F24:  CALL   1B88
09F28:  MOVLW  0A
09F2A:  MOVLB  A
09F2C:  MOVWF  xAD
09F2E:  MOVLB  0
09F30:  CALL   1B88
....................     fprintf(PC, "misf_write_size = 0x%08LX\r\n", write_size);
09F34:  MOVLW  B4
09F36:  MOVWF  FF6
09F38:  MOVLW  08
09F3A:  MOVWF  FF7
09F3C:  MOVLW  00
09F3E:  MOVWF  FF8
09F40:  MOVLW  14
09F42:  MOVLB  9
09F44:  MOVWF  xC6
09F46:  MOVLB  0
09F48:  CALL   1C0A
09F4C:  MOVFF  1E4,264
09F50:  MOVLW  37
09F52:  MOVLB  2
09F54:  MOVWF  x65
09F56:  MOVLB  0
09F58:  CALL   1E5E
09F5C:  MOVFF  1E3,264
09F60:  MOVLW  37
09F62:  MOVLB  2
09F64:  MOVWF  x65
09F66:  MOVLB  0
09F68:  CALL   1E5E
09F6C:  MOVFF  1E2,264
09F70:  MOVLW  37
09F72:  MOVLB  2
09F74:  MOVWF  x65
09F76:  MOVLB  0
09F78:  CALL   1E5E
09F7C:  MOVFF  1E1,264
09F80:  MOVLW  37
09F82:  MOVLB  2
09F84:  MOVWF  x65
09F86:  MOVLB  0
09F88:  CALL   1E5E
09F8C:  MOVLW  0D
09F8E:  MOVLB  A
09F90:  MOVWF  xAD
09F92:  MOVLB  0
09F94:  CALL   1B88
09F98:  MOVLW  0A
09F9A:  MOVLB  A
09F9C:  MOVWF  xAD
09F9E:  MOVLB  0
09FA0:  CALL   1B88
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
09FA4:  MOVLB  1
09FA6:  MOVF   xD5,W
09FA8:  MOVWF  xF2
09FAA:  MOVLW  10
09FAC:  ADDWF  xD6,W
09FAE:  MOVWF  xF3
09FB0:  MOVLW  00
09FB2:  ADDWFC xD7,W
09FB4:  MOVWF  xF4
09FB6:  MOVLW  00
09FB8:  ADDWFC xD8,W
09FBA:  MOVWF  xF5
09FBC:  MOVFF  1DC,1F9
09FC0:  MOVFF  1DB,1F8
09FC4:  MOVFF  1DA,1F7
09FC8:  MOVFF  1D9,1F6
09FCC:  MOVF   xF2,W
09FCE:  SUBWF  xF6,W
09FD0:  MOVWF  xFA
09FD2:  MOVF   xF3,W
09FD4:  SUBWFB xF7,W
09FD6:  MOVWF  xFB
09FD8:  MOVF   xF4,W
09FDA:  SUBWFB xF8,W
09FDC:  MOVWF  xFC
09FDE:  MOVF   xF5,W
09FE0:  SUBWFB xF9,W
09FE2:  MOVWF  xFD
09FE4:  MOVF   xED,W
09FE6:  ADDWF  xF2,W
09FE8:  MOVWF  xFE
09FEA:  MOVF   xEE,W
09FEC:  ADDWFC xF3,W
09FEE:  MOVWF  xFF
09FF0:  MOVF   xEF,W
09FF2:  ADDWFC xF4,W
09FF4:  MOVLB  2
09FF6:  MOVWF  x00
09FF8:  MOVLB  1
09FFA:  MOVF   xF0,W
09FFC:  ADDWFC xF5,W
09FFE:  MOVLB  2
0A000:  MOVWF  x01
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
0A002:  MOVLB  1
0A004:  MOVF   xE1,W
0A006:  ADDWF  xED,W
0A008:  MOVLB  2
0A00A:  MOVWF  x60
0A00C:  MOVLB  1
0A00E:  MOVF   xE2,W
0A010:  ADDWFC xEE,W
0A012:  MOVLB  2
0A014:  MOVWF  x61
0A016:  MOVLB  1
0A018:  MOVF   xE3,W
0A01A:  ADDWFC xEF,W
0A01C:  MOVLB  2
0A01E:  MOVWF  x62
0A020:  MOVLB  1
0A022:  MOVF   xE4,W
0A024:  ADDWFC xF0,W
0A026:  MOVLB  2
0A028:  MOVWF  x63
0A02A:  MOVLB  1
0A02C:  MOVF   xFD,W
0A02E:  MOVLB  2
0A030:  SUBWF  x63,W
0A032:  BTFSC  FD8.0
0A034:  BRA    A03C
0A036:  MOVLB  0
0A038:  GOTO   A178
0A03C:  MOVLB  0
0A03E:  BTFSS  FD8.2
0A040:  GOTO   A08C
0A044:  MOVLB  1
0A046:  MOVF   xFC,W
0A048:  MOVLB  2
0A04A:  SUBWF  x62,W
0A04C:  BTFSC  FD8.0
0A04E:  BRA    A056
0A050:  MOVLB  0
0A052:  GOTO   A178
0A056:  MOVLB  0
0A058:  BTFSS  FD8.2
0A05A:  GOTO   A08C
0A05E:  MOVLB  1
0A060:  MOVF   xFB,W
0A062:  MOVLB  2
0A064:  SUBWF  x61,W
0A066:  BTFSC  FD8.0
0A068:  BRA    A070
0A06A:  MOVLB  0
0A06C:  GOTO   A178
0A070:  MOVLB  0
0A072:  BTFSS  FD8.2
0A074:  GOTO   A08C
0A078:  MOVLB  2
0A07A:  MOVF   x60,W
0A07C:  MOVLB  1
0A07E:  SUBWF  xFA,W
0A080:  BTFSS  FD8.0
0A082:  BRA    A08A
0A084:  MOVLB  0
0A086:  GOTO   A178
0A08A:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
0A08C:  MOVLW  D0
0A08E:  MOVWF  FF6
0A090:  MOVLW  08
0A092:  MOVWF  FF7
0A094:  MOVLW  00
0A096:  MOVWF  FF8
0A098:  CALL   1BDA
....................         loop_count++;
0A09C:  MOVLB  1
0A09E:  INCF   xF1,F
....................         used_size = 0;
0A0A0:  CLRF   xF0
0A0A2:  CLRF   xEF
0A0A4:  CLRF   xEE
0A0A6:  CLRF   xED
....................         data_write_addr = data_region_start;
0A0A8:  MOVFF  1F5,201
0A0AC:  MOVFF  1F4,200
0A0B0:  MOVFF  1F3,1FF
0A0B4:  MOVFF  1F2,1FE
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
0A0B8:  MOVF   x8B,W
0A0BA:  MOVWF  FE9
0A0BC:  MOVF   x8C,W
0A0BE:  MOVWF  FEA
0A0C0:  MOVFF  FEF,260
0A0C4:  MOVFF  260,261
0A0C8:  MOVLB  0
0A0CA:  GOTO   99DC
....................         
....................         unsigned int32 erase_ptr = data_region_start;
0A0CE:  MOVFF  1F5,205
0A0D2:  MOVFF  1F4,204
0A0D6:  MOVFF  1F3,203
0A0DA:  MOVFF  1F2,202
....................         while (erase_ptr < data_region_end)
0A0DE:  MOVLB  2
0A0E0:  MOVF   x05,W
0A0E2:  MOVLB  1
0A0E4:  SUBWF  xF9,W
0A0E6:  BTFSC  FD8.0
0A0E8:  BRA    A0F0
0A0EA:  MOVLB  0
0A0EC:  GOTO   A178
0A0F0:  MOVLB  0
0A0F2:  BTFSS  FD8.2
0A0F4:  GOTO   A140
0A0F8:  MOVLB  2
0A0FA:  MOVF   x04,W
0A0FC:  MOVLB  1
0A0FE:  SUBWF  xF8,W
0A100:  BTFSC  FD8.0
0A102:  BRA    A10A
0A104:  MOVLB  0
0A106:  GOTO   A178
0A10A:  MOVLB  0
0A10C:  BTFSS  FD8.2
0A10E:  GOTO   A140
0A112:  MOVLB  2
0A114:  MOVF   x03,W
0A116:  MOVLB  1
0A118:  SUBWF  xF7,W
0A11A:  BTFSC  FD8.0
0A11C:  BRA    A124
0A11E:  MOVLB  0
0A120:  GOTO   A178
0A124:  MOVLB  0
0A126:  BTFSS  FD8.2
0A128:  GOTO   A140
0A12C:  MOVLB  1
0A12E:  MOVF   xF6,W
0A130:  MOVLB  2
0A132:  SUBWF  x02,W
0A134:  BTFSS  FD8.0
0A136:  BRA    A13E
0A138:  MOVLB  0
0A13A:  GOTO   A178
0A13E:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
0A140:  MOVFF  115,2E5
0A144:  MOVFF  114,2E4
0A148:  MOVFF  113,2E3
0A14C:  MOVFF  112,2E2
0A150:  MOVFF  205,2E9
0A154:  MOVFF  204,2E8
0A158:  MOVFF  203,2E7
0A15C:  MOVFF  202,2E6
0A160:  CALL   469C
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
0A164:  MOVLW  10
0A166:  MOVLB  2
0A168:  ADDWF  x03,F
0A16A:  MOVLW  00
0A16C:  ADDWFC x04,F
0A16E:  MOVLW  00
0A170:  ADDWFC x05,F
0A172:  MOVLB  0
0A174:  GOTO   A0DE
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
0A178:  MOVLB  2
0A17A:  CLRF   x06
0A17C:  MOVLB  1
0A17E:  MOVF   xFF,W
0A180:  ANDLW  F0
0A182:  MOVLB  2
0A184:  MOVWF  x07
0A186:  CLRF   x08
0A188:  CLRF   x09
0A18A:  MOVLB  1
0A18C:  MOVF   xE1,W
0A18E:  ADDWF  xFE,W
0A190:  MOVLB  2
0A192:  MOVWF  x60
0A194:  MOVLB  1
0A196:  MOVF   xE2,W
0A198:  ADDWFC xFF,W
0A19A:  MOVLB  2
0A19C:  MOVWF  x61
0A19E:  MOVLB  1
0A1A0:  MOVF   xE3,W
0A1A2:  MOVLB  2
0A1A4:  ADDWFC x00,W
0A1A6:  MOVWF  x62
0A1A8:  MOVLB  1
0A1AA:  MOVF   xE4,W
0A1AC:  MOVLB  2
0A1AE:  ADDWFC x01,W
0A1B0:  MOVWF  x63
0A1B2:  MOVLW  FF
0A1B4:  ADDWF  x60,F
0A1B6:  MOVLW  0F
0A1B8:  ADDWFC x61,F
0A1BA:  MOVLW  00
0A1BC:  ADDWFC x62,F
0A1BE:  MOVLW  00
0A1C0:  ADDWFC x63,F
0A1C2:  CLRF   x0A
0A1C4:  MOVF   x61,W
0A1C6:  ANDLW  F0
0A1C8:  MOVWF  x0B
0A1CA:  CLRF   x0C
0A1CC:  CLRF   x0D
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
0A1CE:  MOVFF  209,211
0A1D2:  MOVFF  208,210
0A1D6:  MOVFF  207,20F
0A1DA:  MOVFF  206,20E
0A1DE:  MOVLB  0
0A1E0:  MOVLB  2
0A1E2:  MOVF   x11,W
0A1E4:  SUBWF  x0D,W
0A1E6:  BTFSC  FD8.0
0A1E8:  BRA    A1F0
0A1EA:  MOVLB  0
0A1EC:  GOTO   A2D4
0A1F0:  MOVLB  0
0A1F2:  BTFSS  FD8.2
0A1F4:  GOTO   A23A
0A1F8:  MOVLB  2
0A1FA:  MOVF   x10,W
0A1FC:  SUBWF  x0C,W
0A1FE:  BTFSC  FD8.0
0A200:  BRA    A208
0A202:  MOVLB  0
0A204:  GOTO   A2D4
0A208:  MOVLB  0
0A20A:  BTFSS  FD8.2
0A20C:  GOTO   A23A
0A210:  MOVLB  2
0A212:  MOVF   x0F,W
0A214:  SUBWF  x0B,W
0A216:  BTFSC  FD8.0
0A218:  BRA    A220
0A21A:  MOVLB  0
0A21C:  GOTO   A2D4
0A220:  MOVLB  0
0A222:  BTFSS  FD8.2
0A224:  GOTO   A23A
0A228:  MOVLB  2
0A22A:  MOVF   x0A,W
0A22C:  SUBWF  x0E,W
0A22E:  BTFSS  FD8.0
0A230:  BRA    A238
0A232:  MOVLB  0
0A234:  GOTO   A2D4
0A238:  MOVLB  0
0A23A:  MOVLB  2
0A23C:  MOVF   x11,W
0A23E:  MOVLB  1
0A240:  SUBWF  xDC,W
0A242:  BTFSC  FD8.0
0A244:  BRA    A24C
0A246:  MOVLB  0
0A248:  GOTO   A2D4
0A24C:  MOVLB  0
0A24E:  BTFSS  FD8.2
0A250:  GOTO   A29C
0A254:  MOVLB  2
0A256:  MOVF   x10,W
0A258:  MOVLB  1
0A25A:  SUBWF  xDB,W
0A25C:  BTFSC  FD8.0
0A25E:  BRA    A266
0A260:  MOVLB  0
0A262:  GOTO   A2D4
0A266:  MOVLB  0
0A268:  BTFSS  FD8.2
0A26A:  GOTO   A29C
0A26E:  MOVLB  2
0A270:  MOVF   x0F,W
0A272:  MOVLB  1
0A274:  SUBWF  xDA,W
0A276:  BTFSC  FD8.0
0A278:  BRA    A280
0A27A:  MOVLB  0
0A27C:  GOTO   A2D4
0A280:  MOVLB  0
0A282:  BTFSS  FD8.2
0A284:  GOTO   A29C
0A288:  MOVLB  1
0A28A:  MOVF   xD9,W
0A28C:  MOVLB  2
0A28E:  SUBWF  x0E,W
0A290:  BTFSS  FD8.0
0A292:  BRA    A29A
0A294:  MOVLB  0
0A296:  GOTO   A2D4
0A29A:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
0A29C:  MOVFF  115,2E5
0A2A0:  MOVFF  114,2E4
0A2A4:  MOVFF  113,2E3
0A2A8:  MOVFF  112,2E2
0A2AC:  MOVFF  211,2E9
0A2B0:  MOVFF  210,2E8
0A2B4:  MOVFF  20F,2E7
0A2B8:  MOVFF  20E,2E6
0A2BC:  CALL   469C
0A2C0:  MOVLW  10
0A2C2:  MOVLB  2
0A2C4:  ADDWF  x0F,F
0A2C6:  MOVLW  00
0A2C8:  ADDWFC x10,F
0A2CA:  MOVLW  00
0A2CC:  ADDWFC x11,F
0A2CE:  MOVLB  0
0A2D0:  GOTO   A1E0
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
0A2D4:  MOVFF  1E4,215
0A2D8:  MOVFF  1E3,214
0A2DC:  MOVFF  1E2,213
0A2E0:  MOVFF  1E1,212
0A2E4:  MOVFF  1E0,219
0A2E8:  MOVFF  1DF,218
0A2EC:  MOVFF  1DE,217
0A2F0:  MOVFF  1DD,216
....................     while (remaining > 0)
0A2F4:  MOVLB  2
0A2F6:  MOVF   x12,F
0A2F8:  BTFSC  FD8.2
0A2FA:  BRA    A302
0A2FC:  MOVLB  0
0A2FE:  GOTO   A334
0A302:  MOVLB  0
0A304:  MOVLB  2
0A306:  MOVF   x13,F
0A308:  BTFSC  FD8.2
0A30A:  BRA    A312
0A30C:  MOVLB  0
0A30E:  GOTO   A334
0A312:  MOVLB  0
0A314:  MOVLB  2
0A316:  MOVF   x14,F
0A318:  BTFSC  FD8.2
0A31A:  BRA    A322
0A31C:  MOVLB  0
0A31E:  GOTO   A334
0A322:  MOVLB  0
0A324:  MOVLB  2
0A326:  MOVF   x15,F
0A328:  BTFSS  FD8.2
0A32A:  BRA    A332
0A32C:  MOVLB  0
0A32E:  GOTO   A4F8
0A332:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
0A334:  MOVLB  2
0A336:  MOVF   x15,F
0A338:  BTFSC  FD8.2
0A33A:  BRA    A342
0A33C:  MOVLB  0
0A33E:  GOTO   A376
0A342:  MOVLB  0
0A344:  MOVLB  2
0A346:  MOVF   x14,F
0A348:  BTFSC  FD8.2
0A34A:  BRA    A352
0A34C:  MOVLB  0
0A34E:  GOTO   A376
0A352:  MOVLB  0
0A354:  MOVLB  2
0A356:  MOVF   x13,F
0A358:  BTFSC  FD8.2
0A35A:  BRA    A362
0A35C:  MOVLB  0
0A35E:  GOTO   A376
0A362:  MOVLB  0
0A364:  MOVLB  2
0A366:  MOVF   x12,W
0A368:  SUBLW  40
0A36A:  BTFSS  FD8.0
0A36C:  BRA    A374
0A36E:  MOVLB  0
0A370:  GOTO   A37E
0A374:  MOVLB  0
0A376:  CLRF   03
0A378:  MOVLW  40
0A37A:  GOTO   A388
0A37E:  MOVFF  213,03
0A382:  MOVLB  2
0A384:  MOVF   x12,W
0A386:  MOVLB  0
0A388:  MOVLB  2
0A38A:  MOVWF  x5A
0A38C:  MOVFF  03,25B
0A390:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
0A392:  MOVFF  111,2E5
0A396:  MOVFF  110,2E4
0A39A:  MOVFF  10F,2E3
0A39E:  MOVFF  10E,2E2
0A3A2:  MOVFF  219,2E9
0A3A6:  MOVFF  218,2E8
0A3AA:  MOVFF  217,2E7
0A3AE:  MOVFF  216,2E6
0A3B2:  MOVLW  02
0A3B4:  MOVLB  2
0A3B6:  MOVWF  xEB
0A3B8:  MOVLW  1A
0A3BA:  MOVWF  xEA
0A3BC:  CLRF   xEF
0A3BE:  CLRF   xEE
0A3C0:  MOVFF  25B,2ED
0A3C4:  MOVFF  25A,2EC
0A3C8:  MOVLB  0
0A3CA:  CALL   27E0
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
0A3CE:  MOVFF  115,A59
0A3D2:  MOVFF  114,A58
0A3D6:  MOVFF  113,A57
0A3DA:  MOVFF  112,A56
0A3DE:  MOVFF  201,A5D
0A3E2:  MOVFF  200,A5C
0A3E6:  MOVFF  1FF,A5B
0A3EA:  MOVFF  1FE,A5A
0A3EE:  MOVLW  02
0A3F0:  MOVLB  A
0A3F2:  MOVWF  x5F
0A3F4:  MOVLW  1A
0A3F6:  MOVWF  x5E
0A3F8:  MOVFF  25B,A61
0A3FC:  MOVFF  25A,A60
0A400:  MOVLB  0
0A402:  CALL   34FA
....................         for (unsigned int32 i = 0; i < chunk; i++)
0A406:  MOVLB  2
0A408:  CLRF   x5F
0A40A:  CLRF   x5E
0A40C:  CLRF   x5D
0A40E:  CLRF   x5C
0A410:  MOVLB  0
0A412:  MOVLB  2
0A414:  MOVF   x5F,F
0A416:  BTFSC  FD8.2
0A418:  BRA    A420
0A41A:  MOVLB  0
0A41C:  GOTO   A4A0
0A420:  MOVLB  0
0A422:  MOVLB  2
0A424:  MOVF   x5E,F
0A426:  BTFSC  FD8.2
0A428:  BRA    A430
0A42A:  MOVLB  0
0A42C:  GOTO   A4A0
0A430:  MOVLB  0
0A432:  MOVLB  2
0A434:  MOVF   x5D,W
0A436:  SUBWF  x5B,W
0A438:  BTFSC  FD8.0
0A43A:  BRA    A442
0A43C:  MOVLB  0
0A43E:  GOTO   A4A0
0A442:  MOVLB  0
0A444:  BTFSS  FD8.2
0A446:  GOTO   A45C
0A44A:  MOVLB  2
0A44C:  MOVF   x5A,W
0A44E:  SUBWF  x5C,W
0A450:  BTFSS  FD8.0
0A452:  BRA    A45A
0A454:  MOVLB  0
0A456:  GOTO   A4A0
0A45A:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A45C:  MOVLW  1A
0A45E:  MOVLB  2
0A460:  ADDWF  x5C,W
0A462:  MOVWF  FE9
0A464:  MOVLW  02
0A466:  ADDWFC x5D,W
0A468:  MOVWF  FEA
0A46A:  MOVFF  FEF,260
0A46E:  MOVFF  260,264
0A472:  MOVLW  37
0A474:  MOVWF  x65
0A476:  MOVLB  0
0A478:  CALL   1E5E
0A47C:  MOVLW  20
0A47E:  MOVLB  A
0A480:  MOVWF  xAD
0A482:  MOVLB  0
0A484:  CALL   1B88
0A488:  MOVLW  01
0A48A:  MOVLB  2
0A48C:  ADDWF  x5C,F
0A48E:  BTFSC  FD8.0
0A490:  INCF   x5D,F
0A492:  BTFSC  FD8.2
0A494:  INCF   x5E,F
0A496:  BTFSC  FD8.2
0A498:  INCF   x5F,F
0A49A:  MOVLB  0
0A49C:  GOTO   A412
....................         }
....................         src_addr += chunk;
0A4A0:  MOVLB  2
0A4A2:  MOVF   x5A,W
0A4A4:  ADDWF  x16,F
0A4A6:  MOVF   x5B,W
0A4A8:  ADDWFC x17,F
0A4AA:  MOVLW  00
0A4AC:  ADDWFC x18,F
0A4AE:  MOVLW  00
0A4B0:  ADDWFC x19,F
....................         data_write_addr += chunk;
0A4B2:  MOVF   x5A,W
0A4B4:  MOVLB  1
0A4B6:  ADDWF  xFE,F
0A4B8:  MOVLB  2
0A4BA:  MOVF   x5B,W
0A4BC:  MOVLB  1
0A4BE:  ADDWFC xFF,F
0A4C0:  MOVLW  00
0A4C2:  MOVLB  2
0A4C4:  ADDWFC x00,F
0A4C6:  MOVLW  00
0A4C8:  ADDWFC x01,F
....................         used_size += chunk;
0A4CA:  MOVF   x5A,W
0A4CC:  MOVLB  1
0A4CE:  ADDWF  xED,F
0A4D0:  MOVLB  2
0A4D2:  MOVF   x5B,W
0A4D4:  MOVLB  1
0A4D6:  ADDWFC xEE,F
0A4D8:  MOVLW  00
0A4DA:  ADDWFC xEF,F
0A4DC:  MOVLW  00
0A4DE:  ADDWFC xF0,F
....................         remaining -= chunk;
0A4E0:  MOVLB  2
0A4E2:  MOVF   x5A,W
0A4E4:  SUBWF  x12,F
0A4E6:  MOVF   x5B,W
0A4E8:  SUBWFB x13,F
0A4EA:  MOVLW  00
0A4EC:  SUBWFB x14,F
0A4EE:  MOVLW  00
0A4F0:  SUBWFB x15,F
0A4F2:  MOVLB  0
0A4F4:  GOTO   A2F4
....................     }
....................     // write size area
....................     write_smf_header();
0A4F8:  GOTO   99E0
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0A4FC:  MOVLB  1
0A4FE:  MOVF   x8B,W
0A500:  MOVWF  FE9
0A502:  MOVF   x8C,W
0A504:  MOVWF  FEA
0A506:  MOVFF  FEF,260
0A50A:  MOVFF  260,261
0A50E:  MOVFF  1E4,265
0A512:  MOVFF  1E3,264
0A516:  MOVFF  1E2,263
0A51A:  MOVFF  1E1,262
0A51E:  MOVLB  0
0A520:  GOTO   9B70
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0A524:  MOVLW  06
0A526:  MOVWF  FF6
0A528:  MOVLW  09
0A52A:  MOVWF  FF7
0A52C:  MOVLW  00
0A52E:  MOVWF  FF8
0A530:  MOVLW  0C
0A532:  MOVLB  9
0A534:  MOVWF  xC6
0A536:  MOVLB  0
0A538:  CALL   1C0A
0A53C:  MOVLW  41
0A53E:  MOVWF  FE9
0A540:  MOVFF  1F0,263
0A544:  MOVFF  1EF,262
0A548:  MOVFF  1EE,261
0A54C:  MOVFF  1ED,260
0A550:  CALL   93B2
0A554:  MOVLW  0D
0A556:  MOVLB  A
0A558:  MOVWF  xAD
0A55A:  MOVLB  0
0A55C:  CALL   1B88
0A560:  MOVLW  0A
0A562:  MOVLB  A
0A564:  MOVWF  xAD
0A566:  MOVLB  0
0A568:  CALL   1B88
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0A56C:  MOVLW  18
0A56E:  MOVWF  FF6
0A570:  MOVLW  09
0A572:  MOVWF  FF7
0A574:  MOVLW  00
0A576:  MOVWF  FF8
0A578:  MOVLW  0D
0A57A:  MOVLB  9
0A57C:  MOVWF  xC6
0A57E:  MOVLB  0
0A580:  CALL   1C0A
0A584:  MOVFF  1F1,264
0A588:  MOVLW  1B
0A58A:  MOVLB  2
0A58C:  MOVWF  x65
0A58E:  MOVLB  0
0A590:  CALL   63A4
0A594:  MOVLW  27
0A596:  MOVWF  FF6
0A598:  MOVLW  09
0A59A:  MOVWF  FF7
0A59C:  MOVLW  00
0A59E:  MOVWF  FF8
0A5A0:  MOVLW  04
0A5A2:  MOVLB  9
0A5A4:  MOVWF  xC6
0A5A6:  MOVLB  0
0A5A8:  CALL   1C0A
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0A5AC:  MOVLW  2C
0A5AE:  MOVWF  FF6
0A5B0:  MOVLW  09
0A5B2:  MOVWF  FF7
0A5B4:  MOVLW  00
0A5B6:  MOVWF  FF8
0A5B8:  CALL   1BDA
....................     fprintf(PC, "____________________\r\n\r\n");
0A5BC:  MOVLW  46
0A5BE:  MOVWF  FF6
0A5C0:  MOVLW  09
0A5C2:  MOVWF  FF7
0A5C4:  MOVLW  00
0A5C6:  MOVWF  FF8
0A5C8:  CALL   1BDA
0A5CC:  GOTO   B1A2 (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0A6D0:  MOVLW  60
0A6D2:  MOVWF  FF6
0A6D4:  MOVLW  09
0A6D6:  MOVWF  FF7
0A6D8:  MOVLW  00
0A6DA:  MOVWF  FF8
0A6DC:  CALL   1BDA
....................     fprintf(PC, "___Start SMF Read____\r\n");
0A6E0:  MOVLW  7A
0A6E2:  MOVWF  FF6
0A6E4:  MOVLW  09
0A6E6:  MOVWF  FF7
0A6E8:  MOVLW  00
0A6EA:  MOVWF  FF8
0A6EC:  CALL   1BDA
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0A6F0:  MOVLB  1
0A6F2:  MOVF   x8B,W
0A6F4:  MOVWF  FE9
0A6F6:  MOVF   x8C,W
0A6F8:  MOVWF  FEA
0A6FA:  MOVFF  FEF,1E5
0A6FE:  MOVFF  1E5,267
0A702:  MOVLB  0
0A704:  CALL   952E
0A708:  MOVFF  02,03
0A70C:  MOVF   01,W
0A70E:  MOVWF  FE1
0A710:  MOVFF  03,FE2
0A714:  MOVLW  01
0A716:  MOVWF  FEA
0A718:  MOVLW  CD
0A71A:  MOVWF  FE9
0A71C:  MOVLW  08
0A71E:  MOVWF  01
0A720:  MOVFF  FE6,FEE
0A724:  DECFSZ 01,F
0A726:  GOTO   A720
0A72A:  MOVLW  04
0A72C:  MOVLB  1
0A72E:  ADDWF  x8B,W
0A730:  MOVWF  FE9
0A732:  MOVLW  00
0A734:  ADDWFC x8C,W
0A736:  MOVWF  FEA
0A738:  MOVFF  FEF,1D5
0A73C:  MOVFF  FEC,1D6
0A740:  MOVFF  FEC,1D7
0A744:  MOVFF  FEC,1D8
0A748:  MOVF   FED,F
0A74A:  MOVF   FED,F
0A74C:  MOVF   FED,F
0A74E:  MOVLW  08
0A750:  ADDWF  x8B,W
0A752:  MOVWF  FE9
0A754:  MOVLW  00
0A756:  ADDWFC x8C,W
0A758:  MOVWF  FEA
0A75A:  MOVFF  FEF,1D9
0A75E:  MOVFF  FEC,1DA
0A762:  MOVFF  FEC,1DB
0A766:  MOVFF  FEC,1DC
0A76A:  MOVF   FED,F
0A76C:  MOVF   FED,F
0A76E:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0A770:  MOVLW  92
0A772:  MOVWF  FF6
0A774:  MOVLW  09
0A776:  MOVWF  FF7
0A778:  MOVLW  00
0A77A:  MOVWF  FF8
0A77C:  MOVLW  21
0A77E:  MOVLB  9
0A780:  MOVWF  xC6
0A782:  MOVLB  0
0A784:  CALL   1C0A
0A788:  MOVFF  1D8,264
0A78C:  MOVLW  37
0A78E:  MOVLB  2
0A790:  MOVWF  x65
0A792:  MOVLB  0
0A794:  CALL   1E5E
0A798:  MOVFF  1D7,264
0A79C:  MOVLW  37
0A79E:  MOVLB  2
0A7A0:  MOVWF  x65
0A7A2:  MOVLB  0
0A7A4:  CALL   1E5E
0A7A8:  MOVFF  1D6,264
0A7AC:  MOVLW  37
0A7AE:  MOVLB  2
0A7B0:  MOVWF  x65
0A7B2:  MOVLB  0
0A7B4:  CALL   1E5E
0A7B8:  MOVFF  1D5,264
0A7BC:  MOVLW  37
0A7BE:  MOVLB  2
0A7C0:  MOVWF  x65
0A7C2:  MOVLB  0
0A7C4:  CALL   1E5E
0A7C8:  MOVLW  0D
0A7CA:  MOVLB  A
0A7CC:  MOVWF  xAD
0A7CE:  MOVLB  0
0A7D0:  CALL   1B88
0A7D4:  MOVLW  0A
0A7D6:  MOVLB  A
0A7D8:  MOVWF  xAD
0A7DA:  MOVLB  0
0A7DC:  CALL   1B88
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0A7E0:  MOVLW  BA
0A7E2:  MOVWF  FF6
0A7E4:  MOVLW  09
0A7E6:  MOVWF  FF7
0A7E8:  MOVLW  00
0A7EA:  MOVWF  FF8
0A7EC:  MOVLW  21
0A7EE:  MOVLB  9
0A7F0:  MOVWF  xC6
0A7F2:  MOVLB  0
0A7F4:  CALL   1C0A
0A7F8:  MOVLW  41
0A7FA:  MOVWF  FE9
0A7FC:  MOVFF  1DC,1E8
0A800:  MOVFF  1DB,1E7
0A804:  MOVFF  1DA,1E6
0A808:  MOVFF  1D9,1E5
0A80C:  CALL   A5D0
0A810:  MOVLW  DE
0A812:  MOVWF  FF6
0A814:  MOVLW  09
0A816:  MOVWF  FF7
0A818:  MOVLW  00
0A81A:  MOVWF  FF8
0A81C:  MOVLW  04
0A81E:  MOVLB  9
0A820:  MOVWF  xC6
0A822:  MOVLB  0
0A824:  CALL   1C0A
0A828:  MOVFF  1DC,264
0A82C:  MOVLW  57
0A82E:  MOVLB  2
0A830:  MOVWF  x65
0A832:  MOVLB  0
0A834:  CALL   1E5E
0A838:  MOVFF  1DB,264
0A83C:  MOVLW  57
0A83E:  MOVLB  2
0A840:  MOVWF  x65
0A842:  MOVLB  0
0A844:  CALL   1E5E
0A848:  MOVFF  1DA,264
0A84C:  MOVLW  57
0A84E:  MOVLB  2
0A850:  MOVWF  x65
0A852:  MOVLB  0
0A854:  CALL   1E5E
0A858:  MOVFF  1D9,264
0A85C:  MOVLW  57
0A85E:  MOVLB  2
0A860:  MOVWF  x65
0A862:  MOVLB  0
0A864:  CALL   1E5E
0A868:  MOVLW  E5
0A86A:  MOVWF  FF6
0A86C:  MOVLW  09
0A86E:  MOVWF  FF7
0A870:  MOVLW  00
0A872:  MOVWF  FF8
0A874:  MOVLW  05
0A876:  MOVLB  9
0A878:  MOVWF  xC6
0A87A:  MOVLB  0
0A87C:  CALL   1C0A
.................... 
....................     if (!is_connect(smf)){
0A880:  MOVFF  115,263
0A884:  MOVFF  114,262
0A888:  MOVFF  113,261
0A88C:  MOVFF  112,260
0A890:  CALL   26F4
0A894:  MOVF   01,F
0A896:  BTFSS  FD8.2
0A898:  GOTO   A8AC
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0A89C:  MOVLW  EC
0A89E:  MOVWF  FF6
0A8A0:  MOVLW  09
0A8A2:  MOVWF  FF7
0A8A4:  MOVLW  00
0A8A6:  MOVWF  FF8
0A8A8:  CALL   1BDA
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0A8AC:  MOVLW  0A
0A8AE:  MOVWF  FF6
0A8B0:  MOVLW  0A
0A8B2:  MOVWF  FF7
0A8B4:  MOVLW  00
0A8B6:  MOVWF  FF8
0A8B8:  CALL   1BDA
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0A8BC:  MOVFF  1D8,1E0
0A8C0:  MOVFF  1D7,1DF
0A8C4:  MOVFF  1D6,1DE
0A8C8:  MOVFF  1D5,1DD
0A8CC:  MOVLB  1
0A8CE:  MOVF   xD9,W
0A8D0:  ADDWF  xD5,W
0A8D2:  MOVWF  00
0A8D4:  MOVF   xDA,W
0A8D6:  ADDWFC xD6,W
0A8D8:  MOVWF  01
0A8DA:  MOVF   xDB,W
0A8DC:  ADDWFC xD7,W
0A8DE:  MOVWF  02
0A8E0:  MOVF   xDC,W
0A8E2:  ADDWFC xD8,W
0A8E4:  MOVWF  03
0A8E6:  MOVF   xE0,W
0A8E8:  SUBWF  03,W
0A8EA:  BTFSC  FD8.0
0A8EC:  BRA    A8F4
0A8EE:  MOVLB  0
0A8F0:  GOTO   AA3C
0A8F4:  MOVLB  0
0A8F6:  BTFSS  FD8.2
0A8F8:  GOTO   A93E
0A8FC:  MOVLB  1
0A8FE:  MOVF   xDF,W
0A900:  SUBWF  02,W
0A902:  BTFSC  FD8.0
0A904:  BRA    A90C
0A906:  MOVLB  0
0A908:  GOTO   AA3C
0A90C:  MOVLB  0
0A90E:  BTFSS  FD8.2
0A910:  GOTO   A93E
0A914:  MOVLB  1
0A916:  MOVF   xDE,W
0A918:  SUBWF  01,W
0A91A:  BTFSC  FD8.0
0A91C:  BRA    A924
0A91E:  MOVLB  0
0A920:  GOTO   AA3C
0A924:  MOVLB  0
0A926:  BTFSS  FD8.2
0A928:  GOTO   A93E
0A92C:  MOVF   00,W
0A92E:  MOVLB  1
0A930:  SUBWF  xDD,W
0A932:  BTFSS  FD8.0
0A934:  BRA    A93C
0A936:  MOVLB  0
0A938:  GOTO   AA3C
0A93C:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0A93E:  MOVFF  115,2E5
0A942:  MOVFF  114,2E4
0A946:  MOVFF  113,2E3
0A94A:  MOVFF  112,2E2
0A94E:  MOVFF  1E0,2E9
0A952:  MOVFF  1DF,2E8
0A956:  MOVFF  1DE,2E7
0A95A:  MOVFF  1DD,2E6
0A95E:  MOVLW  01
0A960:  MOVLB  2
0A962:  MOVWF  xEB
0A964:  MOVLW  8D
0A966:  MOVWF  xEA
0A968:  CLRF   xEF
0A96A:  CLRF   xEE
0A96C:  CLRF   xED
0A96E:  MOVLW  40
0A970:  MOVWF  xEC
0A972:  MOVLB  0
0A974:  CALL   27E0
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0A978:  MOVLB  1
0A97A:  CLRF   xE4
0A97C:  CLRF   xE3
0A97E:  CLRF   xE2
0A980:  CLRF   xE1
0A982:  MOVLB  0
0A984:  MOVLB  1
0A986:  MOVF   xE4,F
0A988:  BTFSC  FD8.2
0A98A:  BRA    A992
0A98C:  MOVLB  0
0A98E:  GOTO   AA0C
0A992:  MOVLB  0
0A994:  MOVLB  1
0A996:  MOVF   xE3,F
0A998:  BTFSC  FD8.2
0A99A:  BRA    A9A2
0A99C:  MOVLB  0
0A99E:  GOTO   AA0C
0A9A2:  MOVLB  0
0A9A4:  MOVLB  1
0A9A6:  MOVF   xE2,F
0A9A8:  BTFSC  FD8.2
0A9AA:  BRA    A9B2
0A9AC:  MOVLB  0
0A9AE:  GOTO   AA0C
0A9B2:  MOVLB  0
0A9B4:  MOVLB  1
0A9B6:  MOVF   xE1,W
0A9B8:  SUBLW  3F
0A9BA:  BTFSC  FD8.0
0A9BC:  BRA    A9C4
0A9BE:  MOVLB  0
0A9C0:  GOTO   AA0C
0A9C4:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0A9C6:  MOVLW  8D
0A9C8:  MOVLB  1
0A9CA:  ADDWF  xE1,W
0A9CC:  MOVWF  FE9
0A9CE:  MOVLW  01
0A9D0:  ADDWFC xE2,W
0A9D2:  MOVWF  FEA
0A9D4:  MOVFF  FEF,1E5
0A9D8:  MOVFF  1E5,264
0A9DC:  MOVLW  37
0A9DE:  MOVLB  2
0A9E0:  MOVWF  x65
0A9E2:  MOVLB  0
0A9E4:  CALL   1E5E
0A9E8:  MOVLW  20
0A9EA:  MOVLB  A
0A9EC:  MOVWF  xAD
0A9EE:  MOVLB  0
0A9F0:  CALL   1B88
0A9F4:  MOVLW  01
0A9F6:  MOVLB  1
0A9F8:  ADDWF  xE1,F
0A9FA:  BTFSC  FD8.0
0A9FC:  INCF   xE2,F
0A9FE:  BTFSC  FD8.2
0AA00:  INCF   xE3,F
0AA02:  BTFSC  FD8.2
0AA04:  INCF   xE4,F
0AA06:  MOVLB  0
0AA08:  GOTO   A984
....................         }
....................         fprintf(PC, "\r\n");
0AA0C:  MOVLW  0D
0AA0E:  MOVLB  A
0AA10:  MOVWF  xAD
0AA12:  MOVLB  0
0AA14:  CALL   1B88
0AA18:  MOVLW  0A
0AA1A:  MOVLB  A
0AA1C:  MOVWF  xAD
0AA1E:  MOVLB  0
0AA20:  CALL   1B88
0AA24:  MOVLW  40
0AA26:  MOVLB  1
0AA28:  ADDWF  xDD,F
0AA2A:  MOVLW  00
0AA2C:  ADDWFC xDE,F
0AA2E:  MOVLW  00
0AA30:  ADDWFC xDF,F
0AA32:  MOVLW  00
0AA34:  ADDWFC xE0,F
0AA36:  MOVLB  0
0AA38:  GOTO   A8CC
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0AA3C:  MOVLW  22
0AA3E:  MOVWF  FF6
0AA40:  MOVLW  0A
0AA42:  MOVWF  FF7
0AA44:  MOVLW  00
0AA46:  MOVWF  FF8
0AA48:  CALL   1BDA
....................     fprintf(PC, "____________________\r\n\r\n");
0AA4C:  MOVLW  3A
0AA4E:  MOVWF  FF6
0AA50:  MOVLW  0A
0AA52:  MOVWF  FF7
0AA54:  MOVLW  00
0AA56:  MOVWF  FF8
0AA58:  CALL   1BDA
0AA5C:  GOTO   B1B2 (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0AA60:  MOVLW  54
0AA62:  MOVWF  FF6
0AA64:  MOVLW  0A
0AA66:  MOVWF  FF7
0AA68:  MOVLW  00
0AA6A:  MOVWF  FF8
0AA6C:  CALL   1BDA
....................     fprintf(PC, "___Start smf_erase____\r\n");
0AA70:  MOVLW  6E
0AA72:  MOVWF  FF6
0AA74:  MOVLW  0A
0AA76:  MOVWF  FF7
0AA78:  MOVLW  00
0AA7A:  MOVWF  FF8
0AA7C:  CALL   1BDA
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0AA80:  MOVLB  1
0AA82:  MOVF   x8B,W
0AA84:  MOVWF  FE9
0AA86:  MOVF   x8C,W
0AA88:  MOVWF  FEA
0AA8A:  MOVFF  FEF,19D
0AA8E:  MOVFF  19D,267
0AA92:  MOVLB  0
0AA94:  CALL   952E
0AA98:  MOVFF  02,03
0AA9C:  MOVF   01,W
0AA9E:  MOVWF  FE1
0AAA0:  MOVFF  03,FE2
0AAA4:  MOVLW  01
0AAA6:  MOVWF  FEA
0AAA8:  MOVLW  8D
0AAAA:  MOVWF  FE9
0AAAC:  MOVLW  08
0AAAE:  MOVWF  01
0AAB0:  MOVFF  FE6,FEE
0AAB4:  DECFSZ 01,F
0AAB6:  GOTO   AAB0
0AABA:  MOVLW  04
0AABC:  MOVLB  1
0AABE:  ADDWF  x8B,W
0AAC0:  MOVWF  FE9
0AAC2:  MOVLW  00
0AAC4:  ADDWFC x8C,W
0AAC6:  MOVWF  FEA
0AAC8:  MOVFF  FEF,195
0AACC:  MOVFF  FEC,196
0AAD0:  MOVFF  FEC,197
0AAD4:  MOVFF  FEC,198
0AAD8:  MOVF   FED,F
0AADA:  MOVF   FED,F
0AADC:  MOVF   FED,F
0AADE:  MOVLW  08
0AAE0:  ADDWF  x8B,W
0AAE2:  MOVWF  FE9
0AAE4:  MOVLW  00
0AAE6:  ADDWFC x8C,W
0AAE8:  MOVWF  FEA
0AAEA:  MOVFF  FEF,199
0AAEE:  MOVFF  FEC,19A
0AAF2:  MOVFF  FEC,19B
0AAF6:  MOVFF  FEC,19C
0AAFA:  MOVF   FED,F
0AAFC:  MOVF   FED,F
0AAFE:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0AB00:  MOVLW  88
0AB02:  MOVWF  FF6
0AB04:  MOVLW  0A
0AB06:  MOVWF  FF7
0AB08:  MOVLW  00
0AB0A:  MOVWF  FF8
0AB0C:  MOVLW  22
0AB0E:  MOVLB  9
0AB10:  MOVWF  xC6
0AB12:  MOVLB  0
0AB14:  CALL   1C0A
0AB18:  MOVFF  198,264
0AB1C:  MOVLW  37
0AB1E:  MOVLB  2
0AB20:  MOVWF  x65
0AB22:  MOVLB  0
0AB24:  CALL   1E5E
0AB28:  MOVFF  197,264
0AB2C:  MOVLW  37
0AB2E:  MOVLB  2
0AB30:  MOVWF  x65
0AB32:  MOVLB  0
0AB34:  CALL   1E5E
0AB38:  MOVFF  196,264
0AB3C:  MOVLW  37
0AB3E:  MOVLB  2
0AB40:  MOVWF  x65
0AB42:  MOVLB  0
0AB44:  CALL   1E5E
0AB48:  MOVFF  195,264
0AB4C:  MOVLW  37
0AB4E:  MOVLB  2
0AB50:  MOVWF  x65
0AB52:  MOVLB  0
0AB54:  CALL   1E5E
0AB58:  MOVLW  0D
0AB5A:  MOVLB  A
0AB5C:  MOVWF  xAD
0AB5E:  MOVLB  0
0AB60:  CALL   1B88
0AB64:  MOVLW  0A
0AB66:  MOVLB  A
0AB68:  MOVWF  xAD
0AB6A:  MOVLB  0
0AB6C:  CALL   1B88
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0AB70:  MOVLW  B0
0AB72:  MOVWF  FF6
0AB74:  MOVLW  0A
0AB76:  MOVWF  FF7
0AB78:  MOVLW  00
0AB7A:  MOVWF  FF8
0AB7C:  MOVLW  22
0AB7E:  MOVLB  9
0AB80:  MOVWF  xC6
0AB82:  MOVLB  0
0AB84:  CALL   1C0A
0AB88:  MOVLW  41
0AB8A:  MOVWF  FE9
0AB8C:  MOVFF  19C,1E8
0AB90:  MOVFF  19B,1E7
0AB94:  MOVFF  19A,1E6
0AB98:  MOVFF  199,1E5
0AB9C:  CALL   A5D0
0ABA0:  MOVLW  D5
0ABA2:  MOVWF  FF6
0ABA4:  MOVLW  0A
0ABA6:  MOVWF  FF7
0ABA8:  MOVLW  00
0ABAA:  MOVWF  FF8
0ABAC:  MOVLW  04
0ABAE:  MOVLB  9
0ABB0:  MOVWF  xC6
0ABB2:  MOVLB  0
0ABB4:  CALL   1C0A
0ABB8:  MOVFF  19C,264
0ABBC:  MOVLW  57
0ABBE:  MOVLB  2
0ABC0:  MOVWF  x65
0ABC2:  MOVLB  0
0ABC4:  CALL   1E5E
0ABC8:  MOVFF  19B,264
0ABCC:  MOVLW  57
0ABCE:  MOVLB  2
0ABD0:  MOVWF  x65
0ABD2:  MOVLB  0
0ABD4:  CALL   1E5E
0ABD8:  MOVFF  19A,264
0ABDC:  MOVLW  57
0ABDE:  MOVLB  2
0ABE0:  MOVWF  x65
0ABE2:  MOVLB  0
0ABE4:  CALL   1E5E
0ABE8:  MOVFF  199,264
0ABEC:  MOVLW  57
0ABEE:  MOVLB  2
0ABF0:  MOVWF  x65
0ABF2:  MOVLB  0
0ABF4:  CALL   1E5E
0ABF8:  MOVLW  DC
0ABFA:  MOVWF  FF6
0ABFC:  MOVLW  0A
0ABFE:  MOVWF  FF7
0AC00:  MOVLW  00
0AC02:  MOVWF  FF8
0AC04:  MOVLW  05
0AC06:  MOVLB  9
0AC08:  MOVWF  xC6
0AC0A:  MOVLB  0
0AC0C:  CALL   1C0A
.................... 
....................     if (!is_connect(smf)){
0AC10:  MOVFF  115,263
0AC14:  MOVFF  114,262
0AC18:  MOVFF  113,261
0AC1C:  MOVFF  112,260
0AC20:  CALL   26F4
0AC24:  MOVF   01,F
0AC26:  BTFSS  FD8.2
0AC28:  GOTO   AC40
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0AC2C:  MOVLW  E2
0AC2E:  MOVWF  FF6
0AC30:  MOVLW  0A
0AC32:  MOVWF  FF7
0AC34:  MOVLW  00
0AC36:  MOVWF  FF8
0AC38:  CALL   1BDA
....................         return;
0AC3C:  GOTO   AF7A
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0AC40:  MOVLB  1
0AC42:  MOVF   x98,W
0AC44:  SUBWF  x90,W
0AC46:  BTFSC  FD8.0
0AC48:  BRA    AC50
0AC4A:  MOVLB  0
0AC4C:  GOTO   AC9A
0AC50:  MOVLB  0
0AC52:  BTFSS  FD8.2
0AC54:  GOTO   ACF4
0AC58:  MOVLB  1
0AC5A:  MOVF   x97,W
0AC5C:  SUBWF  x8F,W
0AC5E:  BTFSC  FD8.0
0AC60:  BRA    AC68
0AC62:  MOVLB  0
0AC64:  GOTO   AC9A
0AC68:  MOVLB  0
0AC6A:  BTFSS  FD8.2
0AC6C:  GOTO   ACF4
0AC70:  MOVLB  1
0AC72:  MOVF   x96,W
0AC74:  SUBWF  x8E,W
0AC76:  BTFSC  FD8.0
0AC78:  BRA    AC80
0AC7A:  MOVLB  0
0AC7C:  GOTO   AC9A
0AC80:  MOVLB  0
0AC82:  BTFSS  FD8.2
0AC84:  GOTO   ACF4
0AC88:  MOVLB  1
0AC8A:  MOVF   x8D,W
0AC8C:  SUBWF  x95,W
0AC8E:  BTFSC  FD8.0
0AC90:  BRA    AC98
0AC92:  MOVLB  0
0AC94:  GOTO   ACF4
0AC98:  MOVLB  0
0AC9A:  MOVLB  1
0AC9C:  MOVF   x94,W
0AC9E:  SUBWF  x98,W
0ACA0:  BTFSC  FD8.0
0ACA2:  BRA    ACAA
0ACA4:  MOVLB  0
0ACA6:  GOTO   AE18
0ACAA:  MOVLB  0
0ACAC:  BTFSS  FD8.2
0ACAE:  GOTO   ACF4
0ACB2:  MOVLB  1
0ACB4:  MOVF   x93,W
0ACB6:  SUBWF  x97,W
0ACB8:  BTFSC  FD8.0
0ACBA:  BRA    ACC2
0ACBC:  MOVLB  0
0ACBE:  GOTO   AE18
0ACC2:  MOVLB  0
0ACC4:  BTFSS  FD8.2
0ACC6:  GOTO   ACF4
0ACCA:  MOVLB  1
0ACCC:  MOVF   x92,W
0ACCE:  SUBWF  x96,W
0ACD0:  BTFSC  FD8.0
0ACD2:  BRA    ACDA
0ACD4:  MOVLB  0
0ACD6:  GOTO   AE18
0ACDA:  MOVLB  0
0ACDC:  BTFSS  FD8.2
0ACDE:  GOTO   ACF4
0ACE2:  MOVLB  1
0ACE4:  MOVF   x91,W
0ACE6:  SUBWF  x95,W
0ACE8:  BTFSC  FD8.0
0ACEA:  BRA    ACF2
0ACEC:  MOVLB  0
0ACEE:  GOTO   AE18
0ACF2:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0ACF4:  MOVLW  00
0ACF6:  MOVWF  FF6
0ACF8:  MOVLW  0B
0ACFA:  MOVWF  FF7
0ACFC:  MOVLW  00
0ACFE:  MOVWF  FF8
0AD00:  MOVLW  1E
0AD02:  MOVLB  9
0AD04:  MOVWF  xC6
0AD06:  MOVLB  0
0AD08:  CALL   1C0A
0AD0C:  MOVFF  198,264
0AD10:  MOVLW  37
0AD12:  MOVLB  2
0AD14:  MOVWF  x65
0AD16:  MOVLB  0
0AD18:  CALL   1E5E
0AD1C:  MOVFF  197,264
0AD20:  MOVLW  37
0AD22:  MOVLB  2
0AD24:  MOVWF  x65
0AD26:  MOVLB  0
0AD28:  CALL   1E5E
0AD2C:  MOVFF  196,264
0AD30:  MOVLW  37
0AD32:  MOVLB  2
0AD34:  MOVWF  x65
0AD36:  MOVLB  0
0AD38:  CALL   1E5E
0AD3C:  MOVFF  195,264
0AD40:  MOVLW  37
0AD42:  MOVLB  2
0AD44:  MOVWF  x65
0AD46:  MOVLB  0
0AD48:  CALL   1E5E
0AD4C:  MOVLW  21
0AD4E:  MOVWF  FF6
0AD50:  MOVLW  0B
0AD52:  MOVWF  FF7
0AD54:  MOVLW  00
0AD56:  MOVWF  FF8
0AD58:  MOVLW  1D
0AD5A:  MOVLB  9
0AD5C:  MOVWF  xC6
0AD5E:  MOVLB  0
0AD60:  CALL   1C0A
0AD64:  MOVFF  190,264
0AD68:  MOVLW  37
0AD6A:  MOVLB  2
0AD6C:  MOVWF  x65
0AD6E:  MOVLB  0
0AD70:  CALL   1E5E
0AD74:  MOVFF  18F,264
0AD78:  MOVLW  37
0AD7A:  MOVLB  2
0AD7C:  MOVWF  x65
0AD7E:  MOVLB  0
0AD80:  CALL   1E5E
0AD84:  MOVFF  18E,264
0AD88:  MOVLW  37
0AD8A:  MOVLB  2
0AD8C:  MOVWF  x65
0AD8E:  MOVLB  0
0AD90:  CALL   1E5E
0AD94:  MOVFF  18D,264
0AD98:  MOVLW  37
0AD9A:  MOVLB  2
0AD9C:  MOVWF  x65
0AD9E:  MOVLB  0
0ADA0:  CALL   1E5E
0ADA4:  MOVLW  41
0ADA6:  MOVWF  FF6
0ADA8:  MOVLW  0B
0ADAA:  MOVWF  FF7
0ADAC:  MOVLW  00
0ADAE:  MOVWF  FF8
0ADB0:  MOVLW  05
0ADB2:  MOVLB  9
0ADB4:  MOVWF  xC6
0ADB6:  MOVLB  0
0ADB8:  CALL   1C0A
0ADBC:  MOVFF  194,264
0ADC0:  MOVLW  37
0ADC2:  MOVLB  2
0ADC4:  MOVWF  x65
0ADC6:  MOVLB  0
0ADC8:  CALL   1E5E
0ADCC:  MOVFF  193,264
0ADD0:  MOVLW  37
0ADD2:  MOVLB  2
0ADD4:  MOVWF  x65
0ADD6:  MOVLB  0
0ADD8:  CALL   1E5E
0ADDC:  MOVFF  192,264
0ADE0:  MOVLW  37
0ADE2:  MOVLB  2
0ADE4:  MOVWF  x65
0ADE6:  MOVLB  0
0ADE8:  CALL   1E5E
0ADEC:  MOVFF  191,264
0ADF0:  MOVLW  37
0ADF2:  MOVLB  2
0ADF4:  MOVWF  x65
0ADF6:  MOVLB  0
0ADF8:  CALL   1E5E
0ADFC:  MOVLW  49
0ADFE:  MOVWF  FF6
0AE00:  MOVLW  0B
0AE02:  MOVWF  FF7
0AE04:  MOVLW  00
0AE06:  MOVWF  FF8
0AE08:  MOVLW  03
0AE0A:  MOVLB  9
0AE0C:  MOVWF  xC6
0AE0E:  MOVLB  0
0AE10:  CALL   1C0A
....................         return;
0AE14:  GOTO   AF7A
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0AE18:  MOVLB  1
0AE1A:  MOVF   x99,W
0AE1C:  ADDWF  x95,W
0AE1E:  MOVWF  x9D
0AE20:  MOVF   x9A,W
0AE22:  ADDWFC x96,W
0AE24:  MOVWF  x9E
0AE26:  MOVF   x9B,W
0AE28:  ADDWFC x97,W
0AE2A:  MOVWF  x9F
0AE2C:  MOVF   x9C,W
0AE2E:  ADDWFC x98,W
0AE30:  MOVWF  xA0
0AE32:  MOVF   x94,W
0AE34:  SUBWF  xA0,W
0AE36:  BTFSC  FD8.0
0AE38:  BRA    AE40
0AE3A:  MOVLB  0
0AE3C:  GOTO   AF26
0AE40:  MOVLB  0
0AE42:  BTFSS  FD8.2
0AE44:  GOTO   AE8A
0AE48:  MOVLB  1
0AE4A:  MOVF   x93,W
0AE4C:  SUBWF  x9F,W
0AE4E:  BTFSC  FD8.0
0AE50:  BRA    AE58
0AE52:  MOVLB  0
0AE54:  GOTO   AF26
0AE58:  MOVLB  0
0AE5A:  BTFSS  FD8.2
0AE5C:  GOTO   AE8A
0AE60:  MOVLB  1
0AE62:  MOVF   x92,W
0AE64:  SUBWF  x9E,W
0AE66:  BTFSC  FD8.0
0AE68:  BRA    AE70
0AE6A:  MOVLB  0
0AE6C:  GOTO   AF26
0AE70:  MOVLB  0
0AE72:  BTFSS  FD8.2
0AE74:  GOTO   AE8A
0AE78:  MOVLB  1
0AE7A:  MOVF   x9D,W
0AE7C:  SUBWF  x91,W
0AE7E:  BTFSS  FD8.0
0AE80:  BRA    AE88
0AE82:  MOVLB  0
0AE84:  GOTO   AF26
0AE88:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0AE8A:  MOVLW  4E
0AE8C:  MOVWF  FF6
0AE8E:  MOVLW  0B
0AE90:  MOVWF  FF7
0AE92:  MOVLW  00
0AE94:  MOVWF  FF8
0AE96:  MOVLW  3A
0AE98:  MOVLB  9
0AE9A:  MOVWF  xC6
0AE9C:  MOVLB  0
0AE9E:  CALL   1C0A
0AEA2:  MOVFF  194,264
0AEA6:  MOVLW  37
0AEA8:  MOVLB  2
0AEAA:  MOVWF  x65
0AEAC:  MOVLB  0
0AEAE:  CALL   1E5E
0AEB2:  MOVFF  193,264
0AEB6:  MOVLW  37
0AEB8:  MOVLB  2
0AEBA:  MOVWF  x65
0AEBC:  MOVLB  0
0AEBE:  CALL   1E5E
0AEC2:  MOVFF  192,264
0AEC6:  MOVLW  37
0AEC8:  MOVLB  2
0AECA:  MOVWF  x65
0AECC:  MOVLB  0
0AECE:  CALL   1E5E
0AED2:  MOVFF  191,264
0AED6:  MOVLW  37
0AED8:  MOVLB  2
0AEDA:  MOVWF  x65
0AEDC:  MOVLB  0
0AEDE:  CALL   1E5E
0AEE2:  MOVLW  0D
0AEE4:  MOVLB  A
0AEE6:  MOVWF  xAD
0AEE8:  MOVLB  0
0AEEA:  CALL   1B88
0AEEE:  MOVLW  0A
0AEF0:  MOVLB  A
0AEF2:  MOVWF  xAD
0AEF4:  MOVLB  0
0AEF6:  CALL   1B88
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0AEFA:  MOVLW  8E
0AEFC:  MOVWF  FF6
0AEFE:  MOVLW  0B
0AF00:  MOVWF  FF7
0AF02:  MOVLW  00
0AF04:  MOVWF  FF8
0AF06:  CALL   1BDA
....................         erase_size = mission_type.end_address - erase_address;
0AF0A:  MOVLB  1
0AF0C:  MOVF   x95,W
0AF0E:  SUBWF  x91,W
0AF10:  MOVWF  x99
0AF12:  MOVF   x96,W
0AF14:  SUBWFB x92,W
0AF16:  MOVWF  x9A
0AF18:  MOVF   x97,W
0AF1A:  SUBWFB x93,W
0AF1C:  MOVWF  x9B
0AF1E:  MOVF   x98,W
0AF20:  SUBWFB x94,W
0AF22:  MOVWF  x9C
0AF24:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0AF26:  MOVLW  C2
0AF28:  MOVWF  FF6
0AF2A:  MOVLW  0B
0AF2C:  MOVWF  FF7
0AF2E:  MOVLW  00
0AF30:  MOVWF  FF8
0AF32:  CALL   1BDA
....................     subsector_4kByte_erase(smf, erase_address);
0AF36:  MOVFF  115,2E5
0AF3A:  MOVFF  114,2E4
0AF3E:  MOVFF  113,2E3
0AF42:  MOVFF  112,2E2
0AF46:  MOVFF  198,2E9
0AF4A:  MOVFF  197,2E8
0AF4E:  MOVFF  196,2E7
0AF52:  MOVFF  195,2E6
0AF56:  CALL   469C
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0AF5A:  MOVLW  F4
0AF5C:  MOVWF  FF6
0AF5E:  MOVLW  0B
0AF60:  MOVWF  FF7
0AF62:  MOVLW  00
0AF64:  MOVWF  FF8
0AF66:  CALL   1BDA
....................     fprintf(PC, "____________________\r\n\r\n");
0AF6A:  MOVLW  0E
0AF6C:  MOVWF  FF6
0AF6E:  MOVLW  0C
0AF70:  MOVWF  FF7
0AF72:  MOVLW  00
0AF74:  MOVWF  FF8
0AF76:  CALL   1BDA
0AF7A:  GOTO   B1C2 (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
09B70:  GOTO   A524 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
099DC:  GOTO   A0CE (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "../core/storage/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/device/mt25q.h"                // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/tool/calc_tools.h"             // ツールライブラリ
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../../../lib/tool/smf_queue.h"              // SMFキュー管理
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
02FF8:  MOVLW  94
02FFA:  MOVWF  FF6
02FFC:  MOVLW  0C
02FFE:  MOVWF  FF7
03000:  MOVLW  00
03002:  MOVWF  FF8
03004:  CALL   1BDA
....................     output_high(MIS_FM_CS);
03008:  MOVLW  DB
0300A:  MOVWF  F92
0300C:  BSF    F89.5
....................     output_high(SMF_CS);
0300E:  MOVLW  DB
03010:  MOVWF  F92
03012:  BSF    F89.2
....................     delay_ms(100);
03014:  MOVLW  64
03016:  MOVLB  A
03018:  MOVWF  x6E
0301A:  MOVLB  0
0301C:  CALL   1B5A
.................... 
....................     // 読み込みID処理 ・・・(既存そのまま)
....................     if (is_connect(mis_fm)) {
03020:  MOVFF  111,263
03024:  MOVFF  110,262
03028:  MOVFF  10F,261
0302C:  MOVFF  10E,260
03030:  CALL   26F4
03034:  MOVF   01,F
03036:  BTFSC  FD8.2
03038:  GOTO   3050
....................         fprintf(PC, "\t[MIS FM] Connected\r\n");
0303C:  MOVLW  B0
0303E:  MOVWF  FF6
03040:  MOVLW  0C
03042:  MOVWF  FF7
03044:  MOVLW  00
03046:  MOVWF  FF8
03048:  CALL   1BDA
....................     } else {
0304C:  GOTO   3064
....................         fprintf(PC, "\t[MIS FM] Not Connected\r\n");
03050:  MOVLW  C6
03052:  MOVWF  FF6
03054:  MOVLW  0C
03056:  MOVWF  FF7
03058:  MOVLW  00
0305A:  MOVWF  FF8
0305C:  CALL   1BDA
....................         return;
03060:  GOTO   31DA
....................     }
.................... 
....................     if (is_connect(smf)) {
03064:  MOVFF  115,263
03068:  MOVFF  114,262
0306C:  MOVFF  113,261
03070:  MOVFF  112,260
03074:  CALL   26F4
03078:  MOVF   01,F
0307A:  BTFSC  FD8.2
0307C:  GOTO   3094
....................         fprintf(PC, "\t[SMF] Connected\r\n");
03080:  MOVLW  E0
03082:  MOVWF  FF6
03084:  MOVLW  0C
03086:  MOVWF  FF7
03088:  MOVLW  00
0308A:  MOVWF  FF8
0308C:  CALL   1BDA
....................     } else {
03090:  GOTO   30A8
....................         fprintf(PC, "\t[SMF] Not Connected\r\n");
03094:  MOVLW  F4
03096:  MOVWF  FF6
03098:  MOVLW  0C
0309A:  MOVWF  FF7
0309C:  MOVLW  00
0309E:  MOVWF  FF8
030A0:  CALL   1BDA
....................         return;
030A4:  GOTO   31DA
....................     }
.................... 
....................     //=== MIS_FM カウンタテーブル読出し ===//
....................     FlashData_t flash_data;
....................     memset(flash_data.bytes, 0, PACKET_SIZE);
030A8:  MOVLW  01
030AA:  MOVWF  FEA
030AC:  MOVLW  D3
030AE:  MOVWF  FE9
030B0:  CLRF   00
030B2:  CLRF   02
030B4:  MOVLW  40
030B6:  MOVWF  01
030B8:  CALL   27BC
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
030BC:  MOVFF  111,2E5
030C0:  MOVFF  110,2E4
030C4:  MOVFF  10F,2E3
030C8:  MOVFF  10E,2E2
030CC:  MOVLB  2
030CE:  CLRF   xE9
030D0:  CLRF   xE8
030D2:  CLRF   xE7
030D4:  CLRF   xE6
030D6:  MOVLW  01
030D8:  MOVWF  xEB
030DA:  MOVLW  D3
030DC:  MOVWF  xEA
030DE:  CLRF   xEF
030E0:  CLRF   xEE
030E2:  CLRF   xED
030E4:  MOVLW  40
030E6:  MOVWF  xEC
030E8:  MOVLB  0
030EA:  CALL   27E0
.................... 
....................     // CRC 検証
....................     if (flash_data.packet.crc != calc_crc8(flash_data.bytes, PACKET_SIZE - 1)) {
030EE:  MOVLW  01
030F0:  MOVLB  A
030F2:  MOVWF  xAE
030F4:  MOVLW  D3
030F6:  MOVWF  xAD
030F8:  MOVLW  3F
030FA:  MOVWF  xAF
030FC:  MOVLB  0
030FE:  CALL   29F8
03102:  MOVF   01,W
03104:  MOVLB  2
03106:  SUBWF  x12,W
03108:  BTFSS  FD8.2
0310A:  BRA    3112
0310C:  MOVLB  0
0310E:  GOTO   3124
03112:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error -> initialize counters\r\n");
03114:  MOVLW  0C
03116:  MOVWF  FF6
03118:  MOVLW  0D
0311A:  MOVWF  FF7
0311C:  MOVLW  00
0311E:  MOVWF  FF8
03120:  CALL   1BDA
....................         // デフォルト初期化
....................         /*
....................         piclog_data.id        = FLASH_ID_PICLOG;
....................         environment_data.id   = FLASH_ID_ENVIRONMENT;
....................         iv_header.id          = FLASH_ID_IV_HEADER;
....................         iv_data.id            = FLASH_ID_IV_DATA;
....................         piclog_data.used_counter = 0;
....................         piclog_data.uncopied_counter = 0;
....................         environment_data.used_counter = 0;
....................         environment_data.uncopied_counter = 0;
....................         iv_header.used_counter = 0;
....................         iv_header.uncopied_counter = 0;
....................         iv_data.used_counter = 0;
....................         iv_data.uncopied_counter = 0;
....................         write_misf_address_area();   // 初期テーブル書込み
....................         print_flash_status();
....................         return;
....................         */
....................     }
.................... 
....................     //=== 個別コピー (キャスト禁止) ===//
....................     piclog_data.id        = FLASH_ID_PICLOG;
03124:  MOVLB  1
03126:  CLRF   x1E
....................     piclog_data.used_counter     = flash_data.packet.payload.logdata.piclog.used_counter;
03128:  MOVFF  1D6,122
0312C:  MOVFF  1D5,121
03130:  MOVFF  1D4,120
03134:  MOVFF  1D3,11F
....................     piclog_data.uncopied_counter = flash_data.packet.payload.logdata.piclog.uncopied_counter;
03138:  MOVFF  1DA,126
0313C:  MOVFF  1D9,125
03140:  MOVFF  1D8,124
03144:  MOVFF  1D7,123
....................     piclog_data.reserve_counter1 = flash_data.packet.payload.logdata.piclog.reserve_counter1;
03148:  MOVFF  1DB,127
....................     piclog_data.reserve_counter2 = flash_data.packet.payload.logdata.piclog.reserve_counter2;
0314C:  MOVFF  1DC,128
.................... 
....................     environment_data.id        = FLASH_ID_ENVIRONMENT;
03150:  MOVLW  01
03152:  MOVWF  x29
....................     environment_data.used_counter     = flash_data.packet.payload.logdata.environment.used_counter;
03154:  MOVFF  1E0,12D
03158:  MOVFF  1DF,12C
0315C:  MOVFF  1DE,12B
03160:  MOVFF  1DD,12A
....................     environment_data.uncopied_counter = flash_data.packet.payload.logdata.environment.uncopied_counter;
03164:  MOVFF  1E4,131
03168:  MOVFF  1E3,130
0316C:  MOVFF  1E2,12F
03170:  MOVFF  1E1,12E
....................     environment_data.reserve_counter1 = flash_data.packet.payload.logdata.environment.reserve_counter1;
03174:  MOVFF  1E5,132
....................     environment_data.reserve_counter2 = flash_data.packet.payload.logdata.environment.reserve_counter2;
03178:  MOVFF  1E6,133
.................... 
....................     iv_header.id        = FLASH_ID_IV_HEADER;
0317C:  MOVLW  02
0317E:  MOVWF  x34
....................     iv_header.used_counter     = flash_data.packet.payload.logdata.iv_header.used_counter;
03180:  MOVFF  1EA,138
03184:  MOVFF  1E9,137
03188:  MOVFF  1E8,136
0318C:  MOVFF  1E7,135
....................     iv_header.uncopied_counter = flash_data.packet.payload.logdata.iv_header.uncopied_counter;
03190:  MOVFF  1EE,13C
03194:  MOVFF  1ED,13B
03198:  MOVFF  1EC,13A
0319C:  MOVFF  1EB,139
....................     iv_header.reserve_counter1 = flash_data.packet.payload.logdata.iv_header.reserve_counter1;
031A0:  MOVFF  1EF,13D
....................     iv_header.reserve_counter2 = flash_data.packet.payload.logdata.iv_header.reserve_counter2;
031A4:  MOVFF  1F0,13E
.................... 
....................     iv_data.id        = FLASH_ID_IV_DATA;
031A8:  MOVLW  03
031AA:  MOVWF  x3F
....................     iv_data.used_counter     = flash_data.packet.payload.logdata.iv_data.used_counter;
031AC:  MOVFF  1F4,143
031B0:  MOVFF  1F3,142
031B4:  MOVFF  1F2,141
031B8:  MOVFF  1F1,140
....................     iv_data.uncopied_counter = flash_data.packet.payload.logdata.iv_data.uncopied_counter;
031BC:  MOVFF  1F8,147
031C0:  MOVFF  1F7,146
031C4:  MOVFF  1F6,145
031C8:  MOVFF  1F5,144
....................     iv_data.reserve_counter1 = flash_data.packet.payload.logdata.iv_data.reserve_counter1;
031CC:  MOVFF  1F9,148
....................     iv_data.reserve_counter2 = flash_data.packet.payload.logdata.iv_data.reserve_counter2;
031D0:  MOVFF  1FA,149
.................... 
....................     print_flash_status();
031D4:  MOVLB  0
031D6:  GOTO   2A64
031DA:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table()
.................... {
....................     FlashData_t flash_data;
....................     memset(&flash_data.bytes, 0, sizeof(flash_data.bytes));
*
0676A:  MOVLW  0A
0676C:  MOVWF  FEA
0676E:  MOVLW  5C
06770:  MOVWF  FE9
06772:  CLRF   00
06774:  CLRF   02
06776:  MOVLW  40
06778:  MOVWF  01
0677A:  CALL   27BC
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv_header,
....................         &flash_data.packet.payload.logdata.iv_data
....................     };
0677E:  MOVLW  0A
06780:  MOVLB  A
06782:  MOVWF  x9D
06784:  MOVLW  5C
06786:  MOVWF  x9C
06788:  MOVLW  0A
0678A:  MOVWF  x9F
0678C:  MOVLW  66
0678E:  MOVWF  x9E
06790:  MOVLW  0A
06792:  MOVWF  xA1
06794:  MOVLW  70
06796:  MOVWF  xA0
06798:  MOVLW  0A
0679A:  MOVWF  xA3
0679C:  MOVLW  7A
0679E:  MOVWF  xA2
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv_header,
....................         &iv_data
....................     };
067A0:  MOVLW  01
067A2:  MOVWF  xA5
067A4:  MOVLW  1E
067A6:  MOVWF  xA4
067A8:  MOVLW  01
067AA:  MOVWF  xA7
067AC:  MOVLW  29
067AE:  MOVWF  xA6
067B0:  MOVLW  01
067B2:  MOVWF  xA9
067B4:  MOVLW  34
067B6:  MOVWF  xA8
067B8:  MOVLW  01
067BA:  MOVWF  xAB
067BC:  MOVLW  3F
067BE:  MOVWF  xAA
.................... 
....................     for (int i = 0; i < 4; i++) {
067C0:  CLRF   xAC
067C2:  MOVLB  0
067C4:  MOVLB  A
067C6:  MOVF   xAC,W
067C8:  SUBLW  03
067CA:  BTFSC  FD8.0
067CC:  BRA    67D4
067CE:  MOVLB  0
067D0:  GOTO   6A88
067D4:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
067D6:  CLRF   03
067D8:  MOVLB  A
067DA:  MOVF   xAC,W
067DC:  MOVWF  02
067DE:  BCF    FD8.0
067E0:  RLCF   02,F
067E2:  RLCF   03,F
067E4:  MOVF   02,W
067E6:  ADDLW  9C
067E8:  MOVWF  01
067EA:  MOVLW  0A
067EC:  ADDWFC 03,F
067EE:  MOVF   01,W
067F0:  MOVWF  xAD
067F2:  MOVFF  03,AAE
067F6:  MOVFF  AAE,FEA
067FA:  MOVFF  AAD,FE9
067FE:  MOVFF  FEC,AB0
06802:  MOVF   FED,F
06804:  MOVFF  FEF,AAF
06808:  MOVF   xAF,W
0680A:  MOVWF  01
0680C:  MOVF   xB0,W
0680E:  MOVWF  03
06810:  MOVF   01,W
06812:  MOVWF  xB1
06814:  MOVFF  03,AB2
06818:  CLRF   03
0681A:  MOVF   xAC,W
0681C:  MOVWF  02
0681E:  BCF    FD8.0
06820:  RLCF   02,F
06822:  RLCF   03,F
06824:  MOVF   02,W
06826:  ADDLW  A4
06828:  MOVWF  01
0682A:  MOVLW  0A
0682C:  ADDWFC 03,F
0682E:  MOVF   01,W
06830:  MOVWF  xB3
06832:  MOVFF  03,AB4
06836:  MOVFF  AB4,FEA
0683A:  MOVFF  AB3,FE9
0683E:  MOVFF  FEC,AB6
06842:  MOVF   FED,F
06844:  MOVFF  FEF,AB5
06848:  MOVLW  01
0684A:  ADDWF  xB5,W
0684C:  MOVWF  FE9
0684E:  MOVLW  00
06850:  ADDWFC xB6,W
06852:  MOVWF  FEA
06854:  MOVFF  FEF,00
06858:  MOVFF  FEC,01
0685C:  MOVFF  FEC,02
06860:  MOVFF  FEC,03
06864:  MOVF   FED,F
06866:  MOVF   FED,F
06868:  MOVF   FED,F
0686A:  MOVFF  03,ABA
0686E:  MOVFF  02,AB9
06872:  MOVFF  01,AB8
06876:  MOVFF  00,AB7
0687A:  MOVFF  AB2,FEA
0687E:  MOVFF  AB1,FE9
06882:  MOVFF  AB7,FEF
06886:  MOVFF  AB8,FEC
0688A:  MOVFF  AB9,FEC
0688E:  MOVFF  ABA,FEC
06892:  MOVF   FED,F
06894:  MOVF   FED,F
06896:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
06898:  CLRF   03
0689A:  MOVF   xAC,W
0689C:  MOVWF  02
0689E:  BCF    FD8.0
068A0:  RLCF   02,F
068A2:  RLCF   03,F
068A4:  MOVF   02,W
068A6:  ADDLW  9C
068A8:  MOVWF  01
068AA:  MOVLW  0A
068AC:  ADDWFC 03,F
068AE:  MOVF   01,W
068B0:  MOVWF  xAD
068B2:  MOVFF  03,AAE
068B6:  MOVFF  AAE,FEA
068BA:  MOVFF  AAD,FE9
068BE:  MOVFF  FEC,AB0
068C2:  MOVF   FED,F
068C4:  MOVFF  FEF,AAF
068C8:  MOVLW  04
068CA:  ADDWF  xAF,W
068CC:  MOVWF  01
068CE:  MOVLW  00
068D0:  ADDWFC xB0,W
068D2:  MOVWF  03
068D4:  MOVF   01,W
068D6:  MOVWF  xB1
068D8:  MOVFF  03,AB2
068DC:  CLRF   03
068DE:  MOVF   xAC,W
068E0:  MOVWF  02
068E2:  BCF    FD8.0
068E4:  RLCF   02,F
068E6:  RLCF   03,F
068E8:  MOVF   02,W
068EA:  ADDLW  A4
068EC:  MOVWF  01
068EE:  MOVLW  0A
068F0:  ADDWFC 03,F
068F2:  MOVF   01,W
068F4:  MOVWF  xB3
068F6:  MOVFF  03,AB4
068FA:  MOVFF  AB4,FEA
068FE:  MOVFF  AB3,FE9
06902:  MOVFF  FEC,AB6
06906:  MOVF   FED,F
06908:  MOVFF  FEF,AB5
0690C:  MOVLW  05
0690E:  ADDWF  xB5,W
06910:  MOVWF  FE9
06912:  MOVLW  00
06914:  ADDWFC xB6,W
06916:  MOVWF  FEA
06918:  MOVFF  FEF,00
0691C:  MOVFF  FEC,01
06920:  MOVFF  FEC,02
06924:  MOVFF  FEC,03
06928:  MOVF   FED,F
0692A:  MOVF   FED,F
0692C:  MOVF   FED,F
0692E:  MOVFF  03,ABA
06932:  MOVFF  02,AB9
06936:  MOVFF  01,AB8
0693A:  MOVFF  00,AB7
0693E:  MOVFF  AB2,FEA
06942:  MOVFF  AB1,FE9
06946:  MOVFF  AB7,FEF
0694A:  MOVFF  AB8,FEC
0694E:  MOVFF  AB9,FEC
06952:  MOVFF  ABA,FEC
06956:  MOVF   FED,F
06958:  MOVF   FED,F
0695A:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
0695C:  CLRF   03
0695E:  MOVF   xAC,W
06960:  MOVWF  02
06962:  BCF    FD8.0
06964:  RLCF   02,F
06966:  RLCF   03,F
06968:  MOVF   02,W
0696A:  ADDLW  9C
0696C:  MOVWF  01
0696E:  MOVLW  0A
06970:  ADDWFC 03,F
06972:  MOVF   01,W
06974:  MOVWF  xAD
06976:  MOVFF  03,AAE
0697A:  MOVFF  AAE,FEA
0697E:  MOVFF  AAD,FE9
06982:  MOVFF  FEC,AB0
06986:  MOVF   FED,F
06988:  MOVFF  FEF,AAF
0698C:  MOVLW  08
0698E:  ADDWF  xAF,W
06990:  MOVWF  01
06992:  MOVLW  00
06994:  ADDWFC xB0,W
06996:  MOVWF  03
06998:  MOVF   01,W
0699A:  MOVWF  xB1
0699C:  MOVFF  03,AB2
069A0:  CLRF   03
069A2:  MOVF   xAC,W
069A4:  MOVWF  02
069A6:  BCF    FD8.0
069A8:  RLCF   02,F
069AA:  RLCF   03,F
069AC:  MOVF   02,W
069AE:  ADDLW  A4
069B0:  MOVWF  01
069B2:  MOVLW  0A
069B4:  ADDWFC 03,F
069B6:  MOVF   01,W
069B8:  MOVWF  xB3
069BA:  MOVFF  03,AB4
069BE:  MOVFF  AB4,FEA
069C2:  MOVFF  AB3,FE9
069C6:  MOVFF  FEC,AB6
069CA:  MOVF   FED,F
069CC:  MOVFF  FEF,AB5
069D0:  MOVLW  09
069D2:  ADDWF  xB5,W
069D4:  MOVWF  FE9
069D6:  MOVLW  00
069D8:  ADDWFC xB6,W
069DA:  MOVWF  FEA
069DC:  MOVF   FEF,W
069DE:  MOVWF  xB7
069E0:  MOVFF  AB2,FEA
069E4:  MOVFF  AB1,FE9
069E8:  MOVFF  AB7,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
069EC:  CLRF   03
069EE:  MOVF   xAC,W
069F0:  MOVWF  02
069F2:  BCF    FD8.0
069F4:  RLCF   02,F
069F6:  RLCF   03,F
069F8:  MOVF   02,W
069FA:  ADDLW  9C
069FC:  MOVWF  01
069FE:  MOVLW  0A
06A00:  ADDWFC 03,F
06A02:  MOVF   01,W
06A04:  MOVWF  xAD
06A06:  MOVFF  03,AAE
06A0A:  MOVFF  AAE,FEA
06A0E:  MOVFF  AAD,FE9
06A12:  MOVFF  FEC,AB0
06A16:  MOVF   FED,F
06A18:  MOVFF  FEF,AAF
06A1C:  MOVLW  09
06A1E:  ADDWF  xAF,W
06A20:  MOVWF  01
06A22:  MOVLW  00
06A24:  ADDWFC xB0,W
06A26:  MOVWF  03
06A28:  MOVF   01,W
06A2A:  MOVWF  xB1
06A2C:  MOVFF  03,AB2
06A30:  CLRF   03
06A32:  MOVF   xAC,W
06A34:  MOVWF  02
06A36:  BCF    FD8.0
06A38:  RLCF   02,F
06A3A:  RLCF   03,F
06A3C:  MOVF   02,W
06A3E:  ADDLW  A4
06A40:  MOVWF  01
06A42:  MOVLW  0A
06A44:  ADDWFC 03,F
06A46:  MOVF   01,W
06A48:  MOVWF  xB3
06A4A:  MOVFF  03,AB4
06A4E:  MOVFF  AB4,FEA
06A52:  MOVFF  AB3,FE9
06A56:  MOVFF  FEC,AB6
06A5A:  MOVF   FED,F
06A5C:  MOVFF  FEF,AB5
06A60:  MOVLW  0A
06A62:  ADDWF  xB5,W
06A64:  MOVWF  FE9
06A66:  MOVLW  00
06A68:  ADDWFC xB6,W
06A6A:  MOVWF  FEA
06A6C:  MOVF   FEF,W
06A6E:  MOVWF  xB7
06A70:  MOVFF  AB2,FEA
06A74:  MOVFF  AB1,FE9
06A78:  MOVFF  AB7,FEF
06A7C:  MOVLB  0
06A7E:  MOVLB  A
06A80:  INCF   xAC,F
06A82:  MOVLB  0
06A84:  GOTO   67C4
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
06A88:  MOVLW  0A
06A8A:  MOVLB  A
06A8C:  MOVWF  xAE
06A8E:  MOVLW  5C
06A90:  MOVWF  xAD
06A92:  MOVLW  3F
06A94:  MOVWF  xAF
06A96:  MOVLB  0
06A98:  CALL   29F8
06A9C:  MOVFF  01,A9B
....................     // fprintf(PC, "make table\r\n");
....................     // for (int i = 0; i < PACKET_SIZE; i++) {
....................         // fprintf(PC, "%02X ", flash_data.bytes[i]);
....................     // }
....................     fprintf(PC, "\r\n");
06AA0:  MOVLW  0D
06AA2:  MOVLB  A
06AA4:  MOVWF  xAD
06AA6:  MOVLB  0
06AA8:  CALL   1B88
06AAC:  MOVLW  0A
06AAE:  MOVLB  A
06AB0:  MOVWF  xAD
06AB2:  MOVLB  0
06AB4:  CALL   1B88
....................     return flash_data;
06AB8:  MOVLW  5C
06ABA:  MOVWF  01
06ABC:  MOVLW  0A
06ABE:  MOVWF  02
06AC0:  RETURN 0
.................... }
.................... 
.................... 
.................... void write_misf_address_area(void)
06AC2:  CALL   676A
06AC6:  MOVFF  02,03
06ACA:  MOVF   01,W
06ACC:  MOVWF  FE1
06ACE:  MOVFF  03,FE2
06AD2:  MOVLW  0A
06AD4:  MOVWF  FEA
06AD6:  MOVLW  16
06AD8:  MOVWF  FE9
06ADA:  MOVLW  40
06ADC:  MOVWF  01
06ADE:  MOVFF  FE6,FEE
06AE2:  DECFSZ 01,F
06AE4:  GOTO   6ADE
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
....................     sector_erase(mis_fm, MISF_CIGS_DATA_TABLE_START);
06AE8:  MOVFF  111,A59
06AEC:  MOVFF  110,A58
06AF0:  MOVFF  10F,A57
06AF4:  MOVFF  10E,A56
06AF8:  MOVLB  A
06AFA:  CLRF   x5D
06AFC:  CLRF   x5C
06AFE:  CLRF   x5B
06B00:  CLRF   x5A
06B02:  MOVLB  0
06B04:  CALL   40D2
....................     // START に書く (以前 END だった)
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
06B08:  MOVFF  111,A59
06B0C:  MOVFF  110,A58
06B10:  MOVFF  10F,A57
06B14:  MOVFF  10E,A56
06B18:  MOVLB  A
06B1A:  CLRF   x5D
06B1C:  CLRF   x5C
06B1E:  CLRF   x5B
06B20:  CLRF   x5A
06B22:  MOVLW  0A
06B24:  MOVWF  x5F
06B26:  MOVLW  16
06B28:  MOVWF  x5E
06B2A:  CLRF   x61
06B2C:  MOVLW  40
06B2E:  MOVWF  x60
06B30:  MOVLB  0
06B32:  CALL   34FA
06B36:  GOTO   715E (RETURN)
.................... }
.................... 
.................... // PICLOG 更新後に呼ばれる関数例 (piclog_write 内で既に write_misf_address_area 呼んでいる場合は不要)
.................... static void update_piclog_counters_after_write(unsigned int16 wrote_size)
.................... {
....................     piclog_data.used_counter     += wrote_size;
....................     piclog_data.uncopied_counter += wrote_size;
....................     // 必要なら wrap 処理追加
....................     write_misf_address_area();
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG    | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02A64:  MOVLW  3A
02A66:  MOVWF  FF6
02A68:  MOVLW  0D
02A6A:  MOVWF  FF7
02A6C:  MOVLW  00
02A6E:  MOVWF  FF8
02A70:  MOVLW  2B
02A72:  MOVLB  9
02A74:  MOVWF  xC6
02A76:  MOVLB  0
02A78:  CALL   1C0A
02A7C:  MOVFF  122,264
02A80:  MOVLW  37
02A82:  MOVLB  2
02A84:  MOVWF  x65
02A86:  MOVLB  0
02A88:  CALL   1E5E
02A8C:  MOVFF  121,264
02A90:  MOVLW  37
02A92:  MOVLB  2
02A94:  MOVWF  x65
02A96:  MOVLB  0
02A98:  CALL   1E5E
02A9C:  MOVFF  120,264
02AA0:  MOVLW  37
02AA2:  MOVLB  2
02AA4:  MOVWF  x65
02AA6:  MOVLB  0
02AA8:  CALL   1E5E
02AAC:  MOVFF  11F,264
02AB0:  MOVLW  37
02AB2:  MOVLB  2
02AB4:  MOVWF  x65
02AB6:  MOVLB  0
02AB8:  CALL   1E5E
02ABC:  MOVLW  0D
02ABE:  MOVLB  A
02AC0:  MOVWF  xAD
02AC2:  MOVLB  0
02AC4:  CALL   1B88
02AC8:  MOVLW  0A
02ACA:  MOVLB  A
02ACC:  MOVWF  xAD
02ACE:  MOVLB  0
02AD0:  CALL   1B88
....................     fprintf(PC, "\t| MISF | PICLOG    | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02AD4:  MOVLW  6E
02AD6:  MOVWF  FF6
02AD8:  MOVLW  0D
02ADA:  MOVWF  FF7
02ADC:  MOVLW  00
02ADE:  MOVWF  FF8
02AE0:  MOVLW  2B
02AE2:  MOVLB  9
02AE4:  MOVWF  xC6
02AE6:  MOVLB  0
02AE8:  CALL   1C0A
02AEC:  MOVFF  126,264
02AF0:  MOVLW  37
02AF2:  MOVLB  2
02AF4:  MOVWF  x65
02AF6:  MOVLB  0
02AF8:  CALL   1E5E
02AFC:  MOVFF  125,264
02B00:  MOVLW  37
02B02:  MOVLB  2
02B04:  MOVWF  x65
02B06:  MOVLB  0
02B08:  CALL   1E5E
02B0C:  MOVFF  124,264
02B10:  MOVLW  37
02B12:  MOVLB  2
02B14:  MOVWF  x65
02B16:  MOVLB  0
02B18:  CALL   1E5E
02B1C:  MOVFF  123,264
02B20:  MOVLW  37
02B22:  MOVLB  2
02B24:  MOVWF  x65
02B26:  MOVLB  0
02B28:  CALL   1E5E
02B2C:  MOVLW  0D
02B2E:  MOVLB  A
02B30:  MOVWF  xAD
02B32:  MOVLB  0
02B34:  CALL   1B88
02B38:  MOVLW  0A
02B3A:  MOVLB  A
02B3C:  MOVWF  xAD
02B3E:  MOVLB  0
02B40:  CALL   1B88
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02B44:  MOVLW  A2
02B46:  MOVWF  FF6
02B48:  MOVLW  0D
02B4A:  MOVWF  FF7
02B4C:  MOVLW  00
02B4E:  MOVWF  FF8
02B50:  MOVLW  2B
02B52:  MOVLB  9
02B54:  MOVWF  xC6
02B56:  MOVLB  0
02B58:  CALL   1C0A
02B5C:  MOVFF  127,264
02B60:  MOVLW  37
02B62:  MOVLB  2
02B64:  MOVWF  x65
02B66:  MOVLB  0
02B68:  CALL   1E5E
02B6C:  MOVLW  0D
02B6E:  MOVLB  A
02B70:  MOVWF  xAD
02B72:  MOVLB  0
02B74:  CALL   1B88
02B78:  MOVLW  0A
02B7A:  MOVLB  A
02B7C:  MOVWF  xAD
02B7E:  MOVLB  0
02B80:  CALL   1B88
....................     fprintf(PC, "\t| MISF | PICLOG    | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02B84:  MOVLW  D4
02B86:  MOVWF  FF6
02B88:  MOVLW  0D
02B8A:  MOVWF  FF7
02B8C:  MOVLW  00
02B8E:  MOVWF  FF8
02B90:  MOVLW  2B
02B92:  MOVLB  9
02B94:  MOVWF  xC6
02B96:  MOVLB  0
02B98:  CALL   1C0A
02B9C:  MOVFF  128,264
02BA0:  MOVLW  37
02BA2:  MOVLB  2
02BA4:  MOVWF  x65
02BA6:  MOVLB  0
02BA8:  CALL   1E5E
02BAC:  MOVLW  0D
02BAE:  MOVLB  A
02BB0:  MOVWF  xAD
02BB2:  MOVLB  0
02BB4:  CALL   1B88
02BB8:  MOVLW  0A
02BBA:  MOVLB  A
02BBC:  MOVWF  xAD
02BBE:  MOVLB  0
02BC0:  CALL   1B88
....................     fprintf(PC, "\t| MISF | ENVIRO    | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02BC4:  MOVLW  06
02BC6:  MOVWF  FF6
02BC8:  MOVLW  0E
02BCA:  MOVWF  FF7
02BCC:  MOVLW  00
02BCE:  MOVWF  FF8
02BD0:  MOVLW  2B
02BD2:  MOVLB  9
02BD4:  MOVWF  xC6
02BD6:  MOVLB  0
02BD8:  CALL   1C0A
02BDC:  MOVFF  12D,264
02BE0:  MOVLW  37
02BE2:  MOVLB  2
02BE4:  MOVWF  x65
02BE6:  MOVLB  0
02BE8:  CALL   1E5E
02BEC:  MOVFF  12C,264
02BF0:  MOVLW  37
02BF2:  MOVLB  2
02BF4:  MOVWF  x65
02BF6:  MOVLB  0
02BF8:  CALL   1E5E
02BFC:  MOVFF  12B,264
02C00:  MOVLW  37
02C02:  MOVLB  2
02C04:  MOVWF  x65
02C06:  MOVLB  0
02C08:  CALL   1E5E
02C0C:  MOVFF  12A,264
02C10:  MOVLW  37
02C12:  MOVLB  2
02C14:  MOVWF  x65
02C16:  MOVLB  0
02C18:  CALL   1E5E
02C1C:  MOVLW  0D
02C1E:  MOVLB  A
02C20:  MOVWF  xAD
02C22:  MOVLB  0
02C24:  CALL   1B88
02C28:  MOVLW  0A
02C2A:  MOVLB  A
02C2C:  MOVWF  xAD
02C2E:  MOVLB  0
02C30:  CALL   1B88
....................     fprintf(PC, "\t| MISF | ENVIRO    | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02C34:  MOVLW  3A
02C36:  MOVWF  FF6
02C38:  MOVLW  0E
02C3A:  MOVWF  FF7
02C3C:  MOVLW  00
02C3E:  MOVWF  FF8
02C40:  MOVLW  2B
02C42:  MOVLB  9
02C44:  MOVWF  xC6
02C46:  MOVLB  0
02C48:  CALL   1C0A
02C4C:  MOVFF  131,264
02C50:  MOVLW  37
02C52:  MOVLB  2
02C54:  MOVWF  x65
02C56:  MOVLB  0
02C58:  CALL   1E5E
02C5C:  MOVFF  130,264
02C60:  MOVLW  37
02C62:  MOVLB  2
02C64:  MOVWF  x65
02C66:  MOVLB  0
02C68:  CALL   1E5E
02C6C:  MOVFF  12F,264
02C70:  MOVLW  37
02C72:  MOVLB  2
02C74:  MOVWF  x65
02C76:  MOVLB  0
02C78:  CALL   1E5E
02C7C:  MOVFF  12E,264
02C80:  MOVLW  37
02C82:  MOVLB  2
02C84:  MOVWF  x65
02C86:  MOVLB  0
02C88:  CALL   1E5E
02C8C:  MOVLW  0D
02C8E:  MOVLB  A
02C90:  MOVWF  xAD
02C92:  MOVLB  0
02C94:  CALL   1B88
02C98:  MOVLW  0A
02C9A:  MOVLB  A
02C9C:  MOVWF  xAD
02C9E:  MOVLB  0
02CA0:  CALL   1B88
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02CA4:  MOVLW  6E
02CA6:  MOVWF  FF6
02CA8:  MOVLW  0E
02CAA:  MOVWF  FF7
02CAC:  MOVLW  00
02CAE:  MOVWF  FF8
02CB0:  MOVLW  2B
02CB2:  MOVLB  9
02CB4:  MOVWF  xC6
02CB6:  MOVLB  0
02CB8:  CALL   1C0A
02CBC:  MOVFF  132,264
02CC0:  MOVLW  37
02CC2:  MOVLB  2
02CC4:  MOVWF  x65
02CC6:  MOVLB  0
02CC8:  CALL   1E5E
02CCC:  MOVLW  0D
02CCE:  MOVLB  A
02CD0:  MOVWF  xAD
02CD2:  MOVLB  0
02CD4:  CALL   1B88
02CD8:  MOVLW  0A
02CDA:  MOVLB  A
02CDC:  MOVWF  xAD
02CDE:  MOVLB  0
02CE0:  CALL   1B88
....................     fprintf(PC, "\t| MISF | ENVIRO    | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02CE4:  MOVLW  A0
02CE6:  MOVWF  FF6
02CE8:  MOVLW  0E
02CEA:  MOVWF  FF7
02CEC:  MOVLW  00
02CEE:  MOVWF  FF8
02CF0:  MOVLW  2B
02CF2:  MOVLB  9
02CF4:  MOVWF  xC6
02CF6:  MOVLB  0
02CF8:  CALL   1C0A
02CFC:  MOVFF  133,264
02D00:  MOVLW  37
02D02:  MOVLB  2
02D04:  MOVWF  x65
02D06:  MOVLB  0
02D08:  CALL   1E5E
02D0C:  MOVLW  0D
02D0E:  MOVLB  A
02D10:  MOVWF  xAD
02D12:  MOVLB  0
02D14:  CALL   1B88
02D18:  MOVLW  0A
02D1A:  MOVLB  A
02D1C:  MOVWF  xAD
02D1E:  MOVLB  0
02D20:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV HEADER | Use Counter      : 0x%08LX\r\n", iv_header.used_counter);
02D24:  MOVLW  D2
02D26:  MOVWF  FF6
02D28:  MOVLW  0E
02D2A:  MOVWF  FF7
02D2C:  MOVLW  00
02D2E:  MOVWF  FF8
02D30:  MOVLW  2B
02D32:  MOVLB  9
02D34:  MOVWF  xC6
02D36:  MOVLB  0
02D38:  CALL   1C0A
02D3C:  MOVFF  138,264
02D40:  MOVLW  37
02D42:  MOVLB  2
02D44:  MOVWF  x65
02D46:  MOVLB  0
02D48:  CALL   1E5E
02D4C:  MOVFF  137,264
02D50:  MOVLW  37
02D52:  MOVLB  2
02D54:  MOVWF  x65
02D56:  MOVLB  0
02D58:  CALL   1E5E
02D5C:  MOVFF  136,264
02D60:  MOVLW  37
02D62:  MOVLB  2
02D64:  MOVWF  x65
02D66:  MOVLB  0
02D68:  CALL   1E5E
02D6C:  MOVFF  135,264
02D70:  MOVLW  37
02D72:  MOVLB  2
02D74:  MOVWF  x65
02D76:  MOVLB  0
02D78:  CALL   1E5E
02D7C:  MOVLW  0D
02D7E:  MOVLB  A
02D80:  MOVWF  xAD
02D82:  MOVLB  0
02D84:  CALL   1B88
02D88:  MOVLW  0A
02D8A:  MOVLB  A
02D8C:  MOVWF  xAD
02D8E:  MOVLB  0
02D90:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV HEADER | Uncopyed Counter : 0x%08LX\r\n", iv_header.uncopied_counter);
02D94:  MOVLW  06
02D96:  MOVWF  FF6
02D98:  MOVLW  0F
02D9A:  MOVWF  FF7
02D9C:  MOVLW  00
02D9E:  MOVWF  FF8
02DA0:  MOVLW  2B
02DA2:  MOVLB  9
02DA4:  MOVWF  xC6
02DA6:  MOVLB  0
02DA8:  CALL   1C0A
02DAC:  MOVFF  13C,264
02DB0:  MOVLW  37
02DB2:  MOVLB  2
02DB4:  MOVWF  x65
02DB6:  MOVLB  0
02DB8:  CALL   1E5E
02DBC:  MOVFF  13B,264
02DC0:  MOVLW  37
02DC2:  MOVLB  2
02DC4:  MOVWF  x65
02DC6:  MOVLB  0
02DC8:  CALL   1E5E
02DCC:  MOVFF  13A,264
02DD0:  MOVLW  37
02DD2:  MOVLB  2
02DD4:  MOVWF  x65
02DD6:  MOVLB  0
02DD8:  CALL   1E5E
02DDC:  MOVFF  139,264
02DE0:  MOVLW  37
02DE2:  MOVLB  2
02DE4:  MOVWF  x65
02DE6:  MOVLB  0
02DE8:  CALL   1E5E
02DEC:  MOVLW  0D
02DEE:  MOVLB  A
02DF0:  MOVWF  xAD
02DF2:  MOVLB  0
02DF4:  CALL   1B88
02DF8:  MOVLW  0A
02DFA:  MOVLB  A
02DFC:  MOVWF  xAD
02DFE:  MOVLB  0
02E00:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter1 : 0x%02X\r\n", iv_header.reserve_counter1);
02E04:  MOVLW  3A
02E06:  MOVWF  FF6
02E08:  MOVLW  0F
02E0A:  MOVWF  FF7
02E0C:  MOVLW  00
02E0E:  MOVWF  FF8
02E10:  MOVLW  2B
02E12:  MOVLB  9
02E14:  MOVWF  xC6
02E16:  MOVLB  0
02E18:  CALL   1C0A
02E1C:  MOVFF  13D,264
02E20:  MOVLW  37
02E22:  MOVLB  2
02E24:  MOVWF  x65
02E26:  MOVLB  0
02E28:  CALL   1E5E
02E2C:  MOVLW  0D
02E2E:  MOVLB  A
02E30:  MOVWF  xAD
02E32:  MOVLB  0
02E34:  CALL   1B88
02E38:  MOVLW  0A
02E3A:  MOVLB  A
02E3C:  MOVWF  xAD
02E3E:  MOVLB  0
02E40:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV HEADER | Reserve Counter2 : 0x%02X\r\n", iv_header.reserve_counter2);
02E44:  MOVLW  6C
02E46:  MOVWF  FF6
02E48:  MOVLW  0F
02E4A:  MOVWF  FF7
02E4C:  MOVLW  00
02E4E:  MOVWF  FF8
02E50:  MOVLW  2B
02E52:  MOVLB  9
02E54:  MOVWF  xC6
02E56:  MOVLB  0
02E58:  CALL   1C0A
02E5C:  MOVFF  13E,264
02E60:  MOVLW  37
02E62:  MOVLB  2
02E64:  MOVWF  x65
02E66:  MOVLB  0
02E68:  CALL   1E5E
02E6C:  MOVLW  0D
02E6E:  MOVLB  A
02E70:  MOVWF  xAD
02E72:  MOVLB  0
02E74:  CALL   1B88
02E78:  MOVLW  0A
02E7A:  MOVLB  A
02E7C:  MOVWF  xAD
02E7E:  MOVLB  0
02E80:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV DATA   | Use Counter      : 0x%08LX\r\n", iv_data.used_counter);
02E84:  MOVLW  9E
02E86:  MOVWF  FF6
02E88:  MOVLW  0F
02E8A:  MOVWF  FF7
02E8C:  MOVLW  00
02E8E:  MOVWF  FF8
02E90:  MOVLW  2B
02E92:  MOVLB  9
02E94:  MOVWF  xC6
02E96:  MOVLB  0
02E98:  CALL   1C0A
02E9C:  MOVFF  143,264
02EA0:  MOVLW  37
02EA2:  MOVLB  2
02EA4:  MOVWF  x65
02EA6:  MOVLB  0
02EA8:  CALL   1E5E
02EAC:  MOVFF  142,264
02EB0:  MOVLW  37
02EB2:  MOVLB  2
02EB4:  MOVWF  x65
02EB6:  MOVLB  0
02EB8:  CALL   1E5E
02EBC:  MOVFF  141,264
02EC0:  MOVLW  37
02EC2:  MOVLB  2
02EC4:  MOVWF  x65
02EC6:  MOVLB  0
02EC8:  CALL   1E5E
02ECC:  MOVFF  140,264
02ED0:  MOVLW  37
02ED2:  MOVLB  2
02ED4:  MOVWF  x65
02ED6:  MOVLB  0
02ED8:  CALL   1E5E
02EDC:  MOVLW  0D
02EDE:  MOVLB  A
02EE0:  MOVWF  xAD
02EE2:  MOVLB  0
02EE4:  CALL   1B88
02EE8:  MOVLW  0A
02EEA:  MOVLB  A
02EEC:  MOVWF  xAD
02EEE:  MOVLB  0
02EF0:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV DATA   | Uncopyed Counter : 0x%08LX\r\n", iv_data.uncopied_counter);
02EF4:  MOVLW  D2
02EF6:  MOVWF  FF6
02EF8:  MOVLW  0F
02EFA:  MOVWF  FF7
02EFC:  MOVLW  00
02EFE:  MOVWF  FF8
02F00:  MOVLW  2B
02F02:  MOVLB  9
02F04:  MOVWF  xC6
02F06:  MOVLB  0
02F08:  CALL   1C0A
02F0C:  MOVFF  147,264
02F10:  MOVLW  37
02F12:  MOVLB  2
02F14:  MOVWF  x65
02F16:  MOVLB  0
02F18:  CALL   1E5E
02F1C:  MOVFF  146,264
02F20:  MOVLW  37
02F22:  MOVLB  2
02F24:  MOVWF  x65
02F26:  MOVLB  0
02F28:  CALL   1E5E
02F2C:  MOVFF  145,264
02F30:  MOVLW  37
02F32:  MOVLB  2
02F34:  MOVWF  x65
02F36:  MOVLB  0
02F38:  CALL   1E5E
02F3C:  MOVFF  144,264
02F40:  MOVLW  37
02F42:  MOVLB  2
02F44:  MOVWF  x65
02F46:  MOVLB  0
02F48:  CALL   1E5E
02F4C:  MOVLW  0D
02F4E:  MOVLB  A
02F50:  MOVWF  xAD
02F52:  MOVLB  0
02F54:  CALL   1B88
02F58:  MOVLW  0A
02F5A:  MOVLB  A
02F5C:  MOVWF  xAD
02F5E:  MOVLB  0
02F60:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter1 : 0x%02X\r\n", iv_data.reserve_counter1);
02F64:  MOVLW  06
02F66:  MOVWF  FF6
02F68:  MOVLW  10
02F6A:  MOVWF  FF7
02F6C:  MOVLW  00
02F6E:  MOVWF  FF8
02F70:  MOVLW  2B
02F72:  MOVLB  9
02F74:  MOVWF  xC6
02F76:  MOVLB  0
02F78:  CALL   1C0A
02F7C:  MOVFF  148,264
02F80:  MOVLW  37
02F82:  MOVLB  2
02F84:  MOVWF  x65
02F86:  MOVLB  0
02F88:  CALL   1E5E
02F8C:  MOVLW  0D
02F8E:  MOVLB  A
02F90:  MOVWF  xAD
02F92:  MOVLB  0
02F94:  CALL   1B88
02F98:  MOVLW  0A
02F9A:  MOVLB  A
02F9C:  MOVWF  xAD
02F9E:  MOVLB  0
02FA0:  CALL   1B88
....................     fprintf(PC, "\t| MISF | IV DATA   | Reserve Counter2 : 0x%02X\r\n", iv_data.reserve_counter2);
02FA4:  MOVLW  38
02FA6:  MOVWF  FF6
02FA8:  MOVLW  10
02FAA:  MOVWF  FF7
02FAC:  MOVLW  00
02FAE:  MOVWF  FF8
02FB0:  MOVLW  2B
02FB2:  MOVLB  9
02FB4:  MOVWF  xC6
02FB6:  MOVLB  0
02FB8:  CALL   1C0A
02FBC:  MOVFF  149,264
02FC0:  MOVLW  37
02FC2:  MOVLB  2
02FC4:  MOVWF  x65
02FC6:  MOVLB  0
02FC8:  CALL   1E5E
02FCC:  MOVLW  0D
02FCE:  MOVLB  A
02FD0:  MOVWF  xAD
02FD2:  MOVLB  0
02FD4:  CALL   1B88
02FD8:  MOVLW  0A
02FDA:  MOVLB  A
02FDC:  MOVWF  xAD
02FDE:  MOVLB  0
02FE0:  CALL   1B88
....................     fprintf(PC, "\tComplete\r\n");
02FE4:  MOVLW  6A
02FE6:  MOVWF  FF6
02FE8:  MOVLW  10
02FEA:  MOVWF  FF7
02FEC:  MOVLW  00
02FEE:  MOVWF  FF8
02FF0:  CALL   1BDA
02FF4:  GOTO   31DA (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
0964E:  MOVLB  2
09650:  CLRF   x68
09652:  CLRF   x69
09654:  CLRF   x6A
09656:  CLRF   x6B
09658:  CLRF   x6C
0965A:  CLRF   x6D
0965C:  CLRF   x6E
0965E:  CLRF   x6F
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
09660:  MOVF   x67,F
09662:  BTFSC  FD8.2
09664:  BRA    966C
09666:  MOVLB  0
09668:  GOTO   9688
0966C:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
0966E:  MOVLB  2
09670:  CLRF   x6B
09672:  CLRF   x6A
09674:  CLRF   x69
09676:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
09678:  CLRF   x6F
0967A:  CLRF   x6E
0967C:  MOVLW  0F
0967E:  MOVWF  x6D
09680:  SETF   x6C
09682:  MOVLB  0
....................    }
09684:  GOTO   974A
....................    else if (mission_id == CIGS_PICLOG_DATA)
09688:  MOVLB  2
0968A:  DECFSZ x67,W
0968C:  BRA    9692
0968E:  BRA    9698
09690:  MOVLB  0
09692:  MOVLB  0
09694:  GOTO   96B8
09698:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
0969A:  MOVLB  2
0969C:  CLRF   x6B
0969E:  MOVLW  01
096A0:  MOVWF  x6A
096A2:  CLRF   x69
096A4:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
096A6:  CLRF   x6F
096A8:  MOVLW  14
096AA:  MOVWF  x6E
096AC:  MOVLW  0F
096AE:  MOVWF  x6D
096B0:  SETF   x6C
096B2:  MOVLB  0
....................    }
096B4:  GOTO   974A
....................    else if (mission_id == CIGS_ENVIRO_DATA)
096B8:  MOVLB  2
096BA:  MOVF   x67,W
096BC:  SUBLW  02
096BE:  BTFSC  FD8.2
096C0:  BRA    96C8
096C2:  MOVLB  0
096C4:  GOTO   96EA
096C8:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
096CA:  MOVLB  2
096CC:  CLRF   x6B
096CE:  MOVLW  28
096D0:  MOVWF  x6A
096D2:  MOVLW  10
096D4:  MOVWF  x69
096D6:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
096D8:  CLRF   x6F
096DA:  MOVLW  32
096DC:  MOVWF  x6E
096DE:  MOVLW  0F
096E0:  MOVWF  x6D
096E2:  SETF   x6C
096E4:  MOVLB  0
....................    }
096E6:  GOTO   974A
....................    else if (mission_id == CIGS_IV_HEADER)
096EA:  MOVLB  2
096EC:  MOVF   x67,W
096EE:  SUBLW  03
096F0:  BTFSC  FD8.2
096F2:  BRA    96FA
096F4:  MOVLB  0
096F6:  GOTO   971C
096FA:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
096FC:  MOVLB  2
096FE:  CLRF   x6B
09700:  MOVLW  72
09702:  MOVWF  x6A
09704:  MOVLW  10
09706:  MOVWF  x69
09708:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
0970A:  CLRF   x6F
0970C:  MOVLW  7C
0970E:  MOVWF  x6E
09710:  MOVLW  0F
09712:  MOVWF  x6D
09714:  SETF   x6C
09716:  MOVLB  0
....................    }
09718:  GOTO   974A
....................    else if (mission_id == CIGS_IV_DATA)
0971C:  MOVLB  2
0971E:  MOVF   x67,W
09720:  SUBLW  04
09722:  BTFSC  FD8.2
09724:  BRA    972C
09726:  MOVLB  0
09728:  GOTO   974A
0972C:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
0972E:  MOVLB  2
09730:  CLRF   x6B
09732:  MOVLW  7C
09734:  MOVWF  x6A
09736:  MOVLW  10
09738:  MOVWF  x69
0973A:  CLRF   x68
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
0973C:  CLRF   x6F
0973E:  MOVLW  BC
09740:  MOVWF  x6E
09742:  MOVLW  0F
09744:  MOVWF  x6D
09746:  SETF   x6C
09748:  MOVLB  0
....................    }
....................    return mis_struct;
0974A:  MOVLW  68
0974C:  MOVWF  01
0974E:  MOVLW  02
09750:  MOVWF  02
09752:  GOTO   9C28 (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv_header.used_counter - iv_header.uncopied_counter;
....................         mis_write_struct.size = iv_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv_data.used_counter - iv_data.uncopied_counter;
....................         mis_write_struct.size = iv_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... // End of file
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "../application/mission/mmj_cigs_excute_mission.c"
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../system/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
....................     //#use rs232(baud=9600,parity=N, xmit=PIN_E4,bits=8,stream=PC)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../../../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../../../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
08FF8:  MOVLB  1
08FFA:  MOVF   x8A,W
08FFC:  MOVWF  FE9
08FFE:  MOVF   x8B,W
09000:  MOVWF  FEA
09002:  MOVFF  FEF,18C
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
09006:  MOVLW  D2
09008:  MOVWF  FF6
0900A:  MOVLW  10
0900C:  MOVWF  FF7
0900E:  MOVLW  00
09010:  MOVWF  FF8
09012:  MOVLB  0
09014:  CALL   1BDA
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
09018:  MOVLW  18
0901A:  MOVWF  FF6
0901C:  MOVLW  11
0901E:  MOVWF  FF7
09020:  MOVLW  00
09022:  MOVWF  FF8
09024:  MOVLW  0C
09026:  MOVLB  9
09028:  MOVWF  xC6
0902A:  MOVLB  0
0902C:  CALL   1C0A
09030:  MOVFF  18C,264
09034:  MOVLW  37
09036:  MOVLB  2
09038:  MOVWF  x65
0903A:  MOVLB  0
0903C:  CALL   1E5E
09040:  MOVLW  26
09042:  MOVWF  FF6
09044:  MOVLW  11
09046:  MOVWF  FF7
09048:  MOVLW  00
0904A:  MOVWF  FF8
0904C:  MOVLW  04
0904E:  MOVLB  9
09050:  MOVWF  xC6
09052:  MOVLB  0
09054:  CALL   1C0A
....................    switch(command_id)
09058:  MOVLB  1
0905A:  MOVF   x8C,W
0905C:  XORLW  10
0905E:  MOVLB  0
09060:  BTFSC  FD8.2
09062:  GOTO   9112
09066:  XORLW  01
09068:  BTFSC  FD8.2
0906A:  GOTO   9116
0906E:  XORLW  03
09070:  BTFSC  FD8.2
09072:  GOTO   911A
09076:  XORLW  13
09078:  BTFSC  FD8.2
0907A:  GOTO   911E
0907E:  XORLW  12
09080:  BTFSC  FD8.2
09082:  GOTO   9122
09086:  XORLW  93
09088:  BTFSC  FD8.2
0908A:  GOTO   9126
0908E:  XORLW  01
09090:  BTFSC  FD8.2
09092:  GOTO   9136
09096:  XORLW  03
09098:  BTFSC  FD8.2
0909A:  GOTO   9146
0909E:  XORLW  01
090A0:  BTFSC  FD8.2
090A2:  GOTO   9156
090A6:  XORLW  07
090A8:  BTFSC  FD8.2
090AA:  GOTO   9166
090AE:  XORLW  01
090B0:  BTFSC  FD8.2
090B2:  GOTO   9176
090B6:  XORLW  03
090B8:  BTFSC  FD8.2
090BA:  GOTO   9186
090BE:  XORLW  01
090C0:  BTFSC  FD8.2
090C2:  GOTO   9196
090C6:  XORLW  0F
090C8:  BTFSC  FD8.2
090CA:  GOTO   91A6
090CE:  XORLW  18
090D0:  BTFSC  FD8.2
090D2:  GOTO   91B6
090D6:  XORLW  01
090D8:  BTFSC  FD8.2
090DA:  GOTO   91C6
090DE:  XORLW  03
090E0:  BTFSC  FD8.2
090E2:  GOTO   91D6
090E6:  XORLW  01
090E8:  BTFSC  FD8.2
090EA:  GOTO   91E6
090EE:  XORLW  07
090F0:  BTFSC  FD8.2
090F2:  GOTO   91F6
090F6:  XORLW  01
090F8:  BTFSC  FD8.2
090FA:  GOTO   9206
090FE:  XORLW  03
09100:  BTFSC  FD8.2
09102:  GOTO   9216
09106:  XORLW  36
09108:  BTFSC  FD8.2
0910A:  GOTO   9226
0910E:  GOTO   9236
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
09112:  GOTO   9246
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
09116:  GOTO   9246
....................       case 0x12:
....................          // test_adc();
....................          break;
0911A:  GOTO   9246
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
0911E:  GOTO   9246
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
09122:  GOTO   9246
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
09126:  MOVFF  18B,190
0912A:  MOVFF  18A,18F
0912E:  CALL   442A
....................          break;
09132:  GOTO   9246
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
09136:  MOVFF  18B,18E
0913A:  MOVFF  18A,18D
0913E:  GOTO   4506
....................          break;
09142:  GOTO   9246
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
09146:  MOVFF  18B,18E
0914A:  MOVFF  18A,18D
0914E:  GOTO   49F8
....................          break;
09152:  GOTO   9246
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
09156:  MOVFF  18B,18E
0915A:  MOVFF  18A,18D
0915E:  GOTO   4B8A
....................          break;
09162:  GOTO   9246
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
09166:  MOVFF  18B,18E
0916A:  MOVFF  18A,18D
0916E:  GOTO   4CFC
....................          break;
09172:  GOTO   9246
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
09176:  MOVFF  18B,18E
0917A:  MOVFF  18A,18D
0917E:  GOTO   50F6
....................          break;
09182:  GOTO   9246
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
09186:  MOVFF  18B,18E
0918A:  MOVFF  18A,18D
0918E:  GOTO   516A
....................          break;
09192:  GOTO   9246
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
09196:  MOVFF  18B,18E
0919A:  MOVFF  18A,18D
0919E:  GOTO   55EE
....................          break;
091A2:  GOTO   9246
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
091A6:  MOVFF  18B,18E
091AA:  MOVFF  18A,18D
091AE:  GOTO   58E6
....................          break;
091B2:  GOTO   9246
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
091B6:  MOVFF  18B,18E
091BA:  MOVFF  18A,18D
091BE:  GOTO   593C
....................          break;
091C2:  GOTO   9246
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
091C6:  MOVFF  18B,18E
091CA:  MOVFF  18A,18D
091CE:  GOTO   5A18
....................          break;
091D2:  GOTO   9246
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
091D6:  MOVFF  18B,18E
091DA:  MOVFF  18A,18D
091DE:  GOTO   5AD4
....................          break;
091E2:  GOTO   9246
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
091E6:  MOVFF  18B,18E
091EA:  MOVFF  18A,18D
091EE:  CALL   5C0A
....................          break;
091F2:  GOTO   9246
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
091F6:  MOVFF  18B,18E
091FA:  MOVFF  18A,18D
091FE:  GOTO   5D82
....................          break;
09202:  GOTO   9246
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
09206:  MOVFF  18B,18E
0920A:  MOVFF  18A,18D
0920E:  GOTO   6164
....................          break;
09212:  GOTO   9246
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
09216:  MOVFF  18B,18E
0921A:  MOVFF  18A,18D
0921E:  CALL   5C0A
....................          break;
09222:  GOTO   9246
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
09226:  MOVFF  18B,18E
0922A:  MOVFF  18A,18D
0922E:  GOTO   8A50
....................          break;
09232:  GOTO   9246
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
09236:  MOVLW  2C
09238:  MOVWF  FF6
0923A:  MOVLW  11
0923C:  MOVWF  FF7
0923E:  MOVLW  00
09240:  MOVWF  FF8
09242:  CALL   1BDA
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
09246:  MOVLW  44
09248:  MOVWF  FF6
0924A:  MOVLW  11
0924C:  MOVWF  FF7
0924E:  MOVLW  00
09250:  MOVWF  FF8
09252:  CALL   1BDA
09256:  GOTO   92C4 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0B26E:  MOVLW  8A
0B270:  MOVWF  FF6
0B272:  MOVLW  11
0B274:  MOVWF  FF7
0B276:  MOVLW  00
0B278:  MOVWF  FF8
0B27A:  CALL   1BDA
....................    
....................    switch(command->frame_id)
0B27E:  MOVLB  1
0B280:  MOVF   x84,W
0B282:  MOVWF  FE9
0B284:  MOVF   x85,W
0B286:  MOVWF  FEA
0B288:  MOVF   FEF,W
0B28A:  XORLW  00
0B28C:  MOVLB  0
0B28E:  BTFSC  FD8.2
0B290:  GOTO   B2A8
0B294:  XORLW  01
0B296:  BTFSC  FD8.2
0B298:  GOTO   B2B8
0B29C:  XORLW  03
0B29E:  BTFSC  FD8.2
0B2A0:  GOTO   B2D8
0B2A4:  GOTO   B2E8
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0B2A8:  MOVFF  185,187
0B2AC:  MOVFF  184,186
0B2B0:  GOTO   9278
....................          break;
0B2B4:  GOTO   B2E8
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0B2B8:  MOVFF  185,187
0B2BC:  MOVFF  184,186
0B2C0:  GOTO   92FA
0B2C4:  MOVF   01,F
0B2C6:  BTFSC  FD8.2
0B2C8:  GOTO   B2D4
....................             return TRUE; // if status is finished, return TRUE
0B2CC:  MOVLW  01
0B2CE:  MOVWF  01
0B2D0:  GOTO   B2EC
....................          }        
....................          break;
0B2D4:  GOTO   B2E8
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0B2D8:  MOVFF  185,187
0B2DC:  MOVFF  184,186
0B2E0:  GOTO   AF7E
....................          break;
0B2E4:  GOTO   B2E8
....................    }
....................    return FALSE;
0B2E8:  MOVLW  00
0B2EA:  MOVWF  01
0B2EC:  GOTO   B7B0 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
09278:  MOVLW  A2
0927A:  MOVWF  FF6
0927C:  MOVLW  11
0927E:  MOVWF  FF7
09280:  MOVLW  00
09282:  MOVWF  FF8
09284:  CALL   1BDA
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
09288:  MOVLW  B8
0928A:  MOVWF  FF6
0928C:  MOVLW  11
0928E:  MOVWF  FF7
09290:  MOVLW  00
09292:  MOVWF  FF8
09294:  CALL   1BDA
....................    transmit_ack();
09298:  CALL   40BE
.................... 
....................    status[0] = EXECUTING_MISSION;
0929C:  MOVLW  02
0929E:  MOVWF  48
....................    execute_mission(command->content);
092A0:  MOVLW  03
092A2:  MOVLB  1
092A4:  ADDWF  x86,W
092A6:  MOVWF  01
092A8:  MOVLW  00
092AA:  ADDWFC x87,W
092AC:  MOVWF  03
092AE:  MOVF   01,W
092B0:  MOVWF  x88
092B2:  MOVFF  03,189
092B6:  MOVFF  189,18B
092BA:  MOVFF  188,18A
092BE:  MOVLB  0
092C0:  GOTO   8FF8
....................    if (is_empty_flash_queue())
092C4:  CALL   925A
092C8:  MOVF   01,F
092CA:  BTFSC  FD8.2
092CC:  GOTO   92D8
....................       status[0] = FINISHED;
092D0:  MOVLW  06
092D2:  MOVWF  48
092D4:  GOTO   92DC
....................    else
....................       status[0] = SMF_USE_REQ;
092D8:  MOVLW  04
092DA:  MOVWF  48
092DC:  GOTO   B2B4 (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
092FA:  MOVLW  D2
092FC:  MOVWF  FF6
092FE:  MOVLW  11
09300:  MOVWF  FF7
09302:  MOVLW  00
09304:  MOVWF  FF8
09306:  CALL   1BDA
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
0930A:  MOVLW  E6
0930C:  MOVWF  FF6
0930E:  MOVLW  11
09310:  MOVWF  FF7
09312:  MOVLW  00
09314:  MOVWF  FF8
09316:  CALL   1BDA
....................    transmit_status();
0931A:  GOTO   92E0
....................    if (status[0] == FINISHED)
0931E:  MOVF   48,W
09320:  SUBLW  06
09322:  BTFSS  FD8.2
09324:  GOTO   9344
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
09328:  MOVLW  04
0932A:  MOVWF  FF6
0932C:  MOVLW  12
0932E:  MOVWF  FF7
09330:  MOVLW  00
09332:  MOVWF  FF8
09334:  CALL   1BDA
....................       return TRUE;
09338:  MOVLW  01
0933A:  MOVWF  01
0933C:  GOTO   934C
....................    }
09340:  GOTO   934C
....................    else{
....................       return FALSE;
09344:  MOVLW  00
09346:  MOVWF  01
09348:  GOTO   934C
....................    }
0934C:  GOTO   B2C4 (RETURN)
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command)
.................... {
....................     fprintf(PC, "\t-> SMF available check\r\n");
*
0AF7E:  MOVLW  20
0AF80:  MOVWF  FF6
0AF82:  MOVLW  12
0AF84:  MOVWF  FF7
0AF86:  MOVLW  00
0AF88:  MOVWF  FF8
0AF8A:  CALL   1BDA
....................     fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0AF8E:  MOVLW  3A
0AF90:  MOVWF  FF6
0AF92:  MOVLW  12
0AF94:  MOVWF  FF7
0AF96:  MOVLW  00
0AF98:  MOVWF  FF8
0AF9A:  CALL   1BDA
....................     transmit_ack();
0AF9E:  CALL   40BE
.................... 
....................     if (command->content[0] != ALLOW) {
0AFA2:  MOVLW  03
0AFA4:  MOVLB  1
0AFA6:  ADDWF  x86,W
0AFA8:  MOVWF  FE9
0AFAA:  MOVLW  00
0AFAC:  ADDWFC x87,W
0AFAE:  MOVWF  FEA
0AFB0:  DECFSZ FEF,W
0AFB2:  BRA    AFB8
0AFB4:  BRA    AFBE
0AFB6:  MOVLB  0
0AFB8:  MOVLB  0
0AFBA:  GOTO   AFC4
0AFBE:  MOVLB  0
0AFC0:  GOTO   AFD8
....................         fprintf(PC, "\t\t-> denied\r\n");
0AFC4:  MOVLW  5A
0AFC6:  MOVWF  FF6
0AFC8:  MOVLW  12
0AFCA:  MOVWF  FF7
0AFCC:  MOVLW  00
0AFCE:  MOVWF  FF8
0AFD0:  CALL   1BDA
....................         return;
0AFD4:  GOTO   B26A
....................     }
.................... 
....................     fprintf(PC, "\t\t-> allowed\r\n");
0AFD8:  MOVLW  68
0AFDA:  MOVWF  FF6
0AFDC:  MOVLW  12
0AFDE:  MOVWF  FF7
0AFE0:  MOVLW  00
0AFE2:  MOVWF  FF8
0AFE4:  CALL   1BDA
....................     status[0] = COPYING;
0AFE8:  MOVLW  05
0AFEA:  MOVWF  48
.................... 
....................     int8 processed_count = 0;
0AFEC:  MOVLB  1
0AFEE:  CLRF   x88
0AFF0:  MOVLB  0
.................... 
....................     while (!is_empty_flash_queue()) {
0AFF2:  CALL   925A
0AFF6:  MOVF   01,F
0AFF8:  BTFSS  FD8.2
0AFFA:  GOTO   B226
....................         FlashOperationStruct *smf_data = dequeue_flash_operation();
0AFFE:  GOTO   9350
0B002:  MOVFF  02,18A
0B006:  MOVFF  01,189
....................         if (smf_data == NULL) {
0B00A:  MOVLB  1
0B00C:  MOVF   x89,F
0B00E:  BTFSC  FD8.2
0B010:  BRA    B018
0B012:  MOVLB  0
0B014:  GOTO   B03E
0B018:  MOVLB  0
0B01A:  MOVLB  1
0B01C:  MOVF   x8A,F
0B01E:  BTFSC  FD8.2
0B020:  BRA    B028
0B022:  MOVLB  0
0B024:  GOTO   B03E
0B028:  MOVLB  0
....................             fprintf(PC, "\t\t-> dequeue NULL (break)\r\n");
0B02A:  MOVLW  78
0B02C:  MOVWF  FF6
0B02E:  MOVLW  12
0B030:  MOVWF  FF7
0B032:  MOVLW  00
0B034:  MOVWF  FF8
0B036:  CALL   1BDA
....................             break;
0B03A:  GOTO   B226
....................         }
.................... 
....................         fprintf(PC, "\t\t-> Dequeued: func=%u mission=%u size=%ld addr=%ld\r\n",
....................                 (unsigned int)smf_data->func_type,
....................                 (unsigned int)smf_data->mission_id,
....................                 smf_data->misf_size,
....................                 smf_data->misf_start_addr);
0B03E:  MOVLW  01
0B040:  MOVLB  1
0B042:  ADDWF  x89,W
0B044:  MOVWF  FE9
0B046:  MOVLW  00
0B048:  ADDWFC x8A,W
0B04A:  MOVWF  FEA
0B04C:  MOVFF  FEF,18B
0B050:  MOVF   x89,W
0B052:  MOVWF  FE9
0B054:  MOVF   x8A,W
0B056:  MOVWF  FEA
0B058:  MOVFF  FEF,18C
0B05C:  MOVLW  08
0B05E:  ADDWF  x89,W
0B060:  MOVWF  FE9
0B062:  MOVLW  00
0B064:  ADDWFC x8A,W
0B066:  MOVWF  FEA
0B068:  MOVFF  FEF,18D
0B06C:  MOVFF  FEC,18E
0B070:  MOVFF  FEC,18F
0B074:  MOVFF  FEC,190
0B078:  MOVF   FED,F
0B07A:  MOVF   FED,F
0B07C:  MOVF   FED,F
0B07E:  MOVLW  04
0B080:  ADDWF  x89,W
0B082:  MOVWF  FE9
0B084:  MOVLW  00
0B086:  ADDWFC x8A,W
0B088:  MOVWF  FEA
0B08A:  MOVFF  FEF,191
0B08E:  MOVFF  FEC,192
0B092:  MOVFF  FEC,193
0B096:  MOVFF  FEC,194
0B09A:  MOVF   FED,F
0B09C:  MOVF   FED,F
0B09E:  MOVF   FED,F
0B0A0:  MOVLW  94
0B0A2:  MOVWF  FF6
0B0A4:  MOVLW  12
0B0A6:  MOVWF  FF7
0B0A8:  MOVLW  00
0B0AA:  MOVWF  FF8
0B0AC:  MOVLW  14
0B0AE:  MOVLB  9
0B0B0:  MOVWF  xC6
0B0B2:  MOVLB  0
0B0B4:  CALL   1C0A
0B0B8:  MOVFF  18B,264
0B0BC:  MOVLW  1B
0B0BE:  MOVLB  2
0B0C0:  MOVWF  x65
0B0C2:  MOVLB  0
0B0C4:  CALL   63A4
0B0C8:  MOVLW  AA
0B0CA:  MOVWF  FF6
0B0CC:  MOVLW  12
0B0CE:  MOVWF  FF7
0B0D0:  MOVLW  00
0B0D2:  MOVWF  FF8
0B0D4:  MOVLW  09
0B0D6:  MOVLB  9
0B0D8:  MOVWF  xC6
0B0DA:  MOVLB  0
0B0DC:  CALL   1C0A
0B0E0:  MOVFF  18C,264
0B0E4:  MOVLW  1B
0B0E6:  MOVLB  2
0B0E8:  MOVWF  x65
0B0EA:  MOVLB  0
0B0EC:  CALL   63A4
0B0F0:  MOVLW  B5
0B0F2:  MOVWF  FF6
0B0F4:  MOVLW  12
0B0F6:  MOVWF  FF7
0B0F8:  MOVLW  00
0B0FA:  MOVWF  FF8
0B0FC:  MOVLW  06
0B0FE:  MOVLB  9
0B100:  MOVWF  xC6
0B102:  MOVLB  0
0B104:  CALL   1C0A
0B108:  MOVLW  41
0B10A:  MOVWF  FE9
0B10C:  MOVFF  190,263
0B110:  MOVFF  18F,262
0B114:  MOVFF  18E,261
0B118:  MOVFF  18D,260
0B11C:  CALL   93B2
0B120:  MOVLW  BE
0B122:  MOVWF  FF6
0B124:  MOVLW  12
0B126:  MOVWF  FF7
0B128:  MOVLW  00
0B12A:  MOVWF  FF8
0B12C:  MOVLW  06
0B12E:  MOVLB  9
0B130:  MOVWF  xC6
0B132:  MOVLB  0
0B134:  CALL   1C0A
0B138:  MOVLW  41
0B13A:  MOVWF  FE9
0B13C:  MOVFF  194,263
0B140:  MOVFF  193,262
0B144:  MOVFF  192,261
0B148:  MOVFF  191,260
0B14C:  CALL   93B2
0B150:  MOVLW  0D
0B152:  MOVLB  A
0B154:  MOVWF  xAD
0B156:  MOVLB  0
0B158:  CALL   1B88
0B15C:  MOVLW  0A
0B15E:  MOVLB  A
0B160:  MOVWF  xAD
0B162:  MOVLB  0
0B164:  CALL   1B88
.................... 
....................         switch (smf_data->func_type) {
0B168:  MOVLW  01
0B16A:  MOVLB  1
0B16C:  ADDWF  x89,W
0B16E:  MOVWF  FE9
0B170:  MOVLW  00
0B172:  ADDWFC x8A,W
0B174:  MOVWF  FEA
0B176:  MOVF   FEF,W
0B178:  XORLW  00
0B17A:  MOVLB  0
0B17C:  BTFSC  FD8.2
0B17E:  GOTO   B196
0B182:  XORLW  01
0B184:  BTFSC  FD8.2
0B186:  GOTO   B1A6
0B18A:  XORLW  03
0B18C:  BTFSC  FD8.2
0B18E:  GOTO   B1B6
0B192:  GOTO   B1C6
....................             case ENUM_SMF_WRITE:
....................                 smf_write(smf_data);
0B196:  MOVFF  18A,18C
0B19A:  MOVFF  189,18B
0B19E:  GOTO   9B74
....................                 break;
0B1A2:  GOTO   B21C
....................             case ENUM_SMF_READ:
....................                 smf_read(smf_data);
0B1A6:  MOVFF  18A,18C
0B1AA:  MOVFF  189,18B
0B1AE:  GOTO   A6D0
....................                 break;
0B1B2:  GOTO   B21C
....................             case ENUM_SMF_ERASE:
....................                 smf_erase(smf_data);
0B1B6:  MOVFF  18A,18C
0B1BA:  MOVFF  189,18B
0B1BE:  GOTO   AA60
....................                 break;
0B1C2:  GOTO   B21C
....................             default:
....................                 fprintf(PC, "\t\t   Unknown func_type=%u\r\n",
....................                         (unsigned int)smf_data->func_type);
0B1C6:  MOVLW  01
0B1C8:  MOVLB  1
0B1CA:  ADDWF  x89,W
0B1CC:  MOVWF  FE9
0B1CE:  MOVLW  00
0B1D0:  ADDWFC x8A,W
0B1D2:  MOVWF  FEA
0B1D4:  MOVFF  FEF,18B
0B1D8:  MOVLW  CA
0B1DA:  MOVWF  FF6
0B1DC:  MOVLW  12
0B1DE:  MOVWF  FF7
0B1E0:  MOVLW  00
0B1E2:  MOVWF  FF8
0B1E4:  MOVLW  17
0B1E6:  MOVLB  9
0B1E8:  MOVWF  xC6
0B1EA:  MOVLB  0
0B1EC:  CALL   1C0A
0B1F0:  MOVFF  18B,264
0B1F4:  MOVLW  1B
0B1F6:  MOVLB  2
0B1F8:  MOVWF  x65
0B1FA:  MOVLB  0
0B1FC:  CALL   63A4
0B200:  MOVLW  0D
0B202:  MOVLB  A
0B204:  MOVWF  xAD
0B206:  MOVLB  0
0B208:  CALL   1B88
0B20C:  MOVLW  0A
0B20E:  MOVLB  A
0B210:  MOVWF  xAD
0B212:  MOVLB  0
0B214:  CALL   1B88
....................                 break;
0B218:  GOTO   B21C
....................         }
....................         processed_count++;
0B21C:  MOVLB  1
0B21E:  INCF   x88,F
0B220:  MOVLB  0
0B222:  GOTO   AFF2
....................     }
.................... 
....................     fprintf(PC, "\t\t-> Completed %u operations\r\n",
....................             (unsigned int)processed_count);
0B226:  MOVLW  E6
0B228:  MOVWF  FF6
0B22A:  MOVLW  12
0B22C:  MOVWF  FF7
0B22E:  MOVLW  00
0B230:  MOVWF  FF8
0B232:  MOVLW  0F
0B234:  MOVLB  9
0B236:  MOVWF  xC6
0B238:  MOVLB  0
0B23A:  CALL   1C0A
0B23E:  MOVFF  188,264
0B242:  MOVLW  1B
0B244:  MOVLB  2
0B246:  MOVWF  x65
0B248:  MOVLB  0
0B24A:  CALL   63A4
0B24E:  MOVLW  F7
0B250:  MOVWF  FF6
0B252:  MOVLW  12
0B254:  MOVWF  FF7
0B256:  MOVLW  00
0B258:  MOVWF  FF8
0B25A:  MOVLW  0D
0B25C:  MOVLB  9
0B25E:  MOVWF  xC6
0B260:  MOVLB  0
0B262:  CALL   1C0A
.................... 
....................     status[0] = FINISHED;
0B266:  MOVLW  06
0B268:  MOVWF  48
0B26A:  GOTO   B2E4 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "../application/mission/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[]);
.................... 
.................... // Development command
.................... 
.................... void mode_dev_vol();
.................... 
.................... void mode_dev_cur();
.................... 
.................... void mode_dev_temp();   
.................... 
.................... void mode_dev_pd();
.................... 
.................... void mode_dev_cigs();
.................... 
.................... void mode_dev_time();
.................... 
.................... void mode_dev_sweep();
.................... 
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     unsigned int8 is_finished; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd[])
.................... {
....................    unsigned int8 measurement_step = uplinkcmd[1]; // Get the measurement step from the parameter array
....................    fprintf(PC, "Start MODE TEST IV\r\n");
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(uplinkcmd); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
.................... //!   sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = ENUM_SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
08A50:  MOVLW  AA
08A52:  MOVWF  FF6
08A54:  MOVLW  13
08A56:  MOVWF  FF7
08A58:  MOVLW  00
08A5A:  MOVWF  FF8
08A5C:  CALL   1BDA
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
08A60:  MOVFF  18E,1B2
08A64:  MOVFF  18D,1B1
08A68:  GOTO   624E
08A6C:  MOVFF  02,03
08A70:  MOVF   01,W
08A72:  MOVWF  FE1
08A74:  MOVFF  03,FE2
08A78:  MOVLW  01
08A7A:  MOVWF  FEA
08A7C:  MOVLW  8F
08A7E:  MOVWF  FE9
08A80:  MOVLW  0C
08A82:  MOVWF  01
08A84:  MOVFF  FE6,FEE
08A88:  DECFSZ 01,F
08A8A:  GOTO   8A84
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
08A8E:  MOVLW  C0
08A90:  MOVWF  FF6
08A92:  MOVLW  13
08A94:  MOVWF  FF7
08A96:  MOVLW  00
08A98:  MOVWF  FF8
08A9A:  MOVLW  05
08A9C:  MOVLB  9
08A9E:  MOVWF  xC6
08AA0:  MOVLB  0
08AA2:  CALL   1C0A
08AA6:  MOVFF  18F,264
08AAA:  MOVLW  37
08AAC:  MOVLB  2
08AAE:  MOVWF  x65
08AB0:  MOVLB  0
08AB2:  CALL   1E5E
08AB6:  MOVLW  0D
08AB8:  MOVLB  A
08ABA:  MOVWF  xAD
08ABC:  MOVLB  0
08ABE:  CALL   1B88
08AC2:  MOVLW  0A
08AC4:  MOVLB  A
08AC6:  MOVWF  xAD
08AC8:  MOVLB  0
08ACA:  CALL   1B88
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
08ACE:  MOVLW  CC
08AD0:  MOVWF  FF6
08AD2:  MOVLW  13
08AD4:  MOVWF  FF7
08AD6:  MOVLW  00
08AD8:  MOVWF  FF8
08ADA:  MOVLW  0D
08ADC:  MOVLB  9
08ADE:  MOVWF  xC6
08AE0:  MOVLB  0
08AE2:  CALL   1C0A
08AE6:  MOVFF  191,264
08AEA:  MOVLW  37
08AEC:  MOVLB  2
08AEE:  MOVWF  x65
08AF0:  MOVLB  0
08AF2:  CALL   1E5E
08AF6:  MOVFF  190,264
08AFA:  MOVLW  37
08AFC:  MOVLB  2
08AFE:  MOVWF  x65
08B00:  MOVLB  0
08B02:  CALL   1E5E
08B06:  MOVLW  DE
08B08:  MOVWF  FF6
08B0A:  MOVLW  13
08B0C:  MOVWF  FF7
08B0E:  MOVLW  00
08B10:  MOVWF  FF8
08B12:  MOVLW  05
08B14:  MOVLB  9
08B16:  MOVWF  xC6
08B18:  MOVLB  0
08B1A:  CALL   1C0A
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
08B1E:  MOVLW  E4
08B20:  MOVWF  FF6
08B22:  MOVLW  13
08B24:  MOVWF  FF7
08B26:  MOVLW  00
08B28:  MOVWF  FF8
08B2A:  MOVLW  14
08B2C:  MOVLB  9
08B2E:  MOVWF  xC6
08B30:  MOVLB  0
08B32:  CALL   1C0A
08B36:  MOVFF  193,264
08B3A:  MOVLW  37
08B3C:  MOVLB  2
08B3E:  MOVWF  x65
08B40:  MOVLB  0
08B42:  CALL   1E5E
08B46:  MOVFF  192,264
08B4A:  MOVLW  37
08B4C:  MOVLB  2
08B4E:  MOVWF  x65
08B50:  MOVLB  0
08B52:  CALL   1E5E
08B56:  MOVLW  FD
08B58:  MOVWF  FF6
08B5A:  MOVLW  13
08B5C:  MOVWF  FF7
08B5E:  MOVLW  00
08B60:  MOVWF  FF8
08B62:  MOVLW  05
08B64:  MOVLB  9
08B66:  MOVWF  xC6
08B68:  MOVLB  0
08B6A:  CALL   1C0A
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
08B6E:  MOVLW  04
08B70:  MOVWF  FF6
08B72:  MOVLW  14
08B74:  MOVWF  FF7
08B76:  MOVLW  00
08B78:  MOVWF  FF8
08B7A:  MOVLW  0F
08B7C:  MOVLB  9
08B7E:  MOVWF  xC6
08B80:  MOVLB  0
08B82:  CALL   1C0A
08B86:  MOVFF  195,264
08B8A:  MOVLW  37
08B8C:  MOVLB  2
08B8E:  MOVWF  x65
08B90:  MOVLB  0
08B92:  CALL   1E5E
08B96:  MOVFF  194,264
08B9A:  MOVLW  37
08B9C:  MOVLB  2
08B9E:  MOVWF  x65
08BA0:  MOVLB  0
08BA2:  CALL   1E5E
08BA6:  MOVLW  18
08BA8:  MOVWF  FF6
08BAA:  MOVLW  14
08BAC:  MOVWF  FF7
08BAE:  MOVLW  00
08BB0:  MOVWF  FF8
08BB2:  MOVLW  05
08BB4:  MOVLB  9
08BB6:  MOVWF  xC6
08BB8:  MOVLB  0
08BBA:  CALL   1C0A
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
08BBE:  MOVLW  1E
08BC0:  MOVWF  FF6
08BC2:  MOVLW  14
08BC4:  MOVWF  FF7
08BC6:  MOVLW  00
08BC8:  MOVWF  FF8
08BCA:  MOVLW  10
08BCC:  MOVLB  9
08BCE:  MOVWF  xC6
08BD0:  MOVLB  0
08BD2:  CALL   1C0A
08BD6:  MOVFF  197,264
08BDA:  MOVLW  37
08BDC:  MOVLB  2
08BDE:  MOVWF  x65
08BE0:  MOVLB  0
08BE2:  CALL   1E5E
08BE6:  MOVFF  196,264
08BEA:  MOVLW  37
08BEC:  MOVLB  2
08BEE:  MOVWF  x65
08BF0:  MOVLB  0
08BF2:  CALL   1E5E
08BF6:  MOVLW  33
08BF8:  MOVWF  FF6
08BFA:  MOVLW  14
08BFC:  MOVWF  FF7
08BFE:  MOVLW  00
08C00:  MOVWF  FF8
08C02:  MOVLW  05
08C04:  MOVLB  9
08C06:  MOVWF  xC6
08C08:  MOVLB  0
08C0A:  CALL   1C0A
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
08C0E:  MOVLW  3A
08C10:  MOVWF  FF6
08C12:  MOVLW  14
08C14:  MOVWF  FF7
08C16:  MOVLW  00
08C18:  MOVWF  FF8
08C1A:  MOVLW  13
08C1C:  MOVLB  9
08C1E:  MOVWF  xC6
08C20:  MOVLB  0
08C22:  CALL   1C0A
08C26:  MOVFF  199,264
08C2A:  MOVLW  37
08C2C:  MOVLB  2
08C2E:  MOVWF  x65
08C30:  MOVLB  0
08C32:  CALL   1E5E
08C36:  MOVFF  198,264
08C3A:  MOVLW  37
08C3C:  MOVLB  2
08C3E:  MOVWF  x65
08C40:  MOVLB  0
08C42:  CALL   1E5E
08C46:  MOVLW  52
08C48:  MOVWF  FF6
08C4A:  MOVLW  14
08C4C:  MOVWF  FF7
08C4E:  MOVLW  00
08C50:  MOVWF  FF8
08C52:  MOVLW  04
08C54:  MOVLB  9
08C56:  MOVWF  xC6
08C58:  MOVLB  0
08C5A:  CALL   1C0A
....................    fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
08C5E:  MOVLW  58
08C60:  MOVWF  FF6
08C62:  MOVLW  14
08C64:  MOVWF  FF7
08C66:  MOVLW  00
08C68:  MOVWF  FF8
08C6A:  MOVLW  0E
08C6C:  MOVLB  9
08C6E:  MOVWF  xC6
08C70:  MOVLB  0
08C72:  CALL   1C0A
08C76:  MOVFF  19A,264
08C7A:  MOVLW  1B
08C7C:  MOVLB  2
08C7E:  MOVWF  x65
08C80:  MOVLB  0
08C82:  CALL   63A4
08C86:  MOVLW  0D
08C88:  MOVLB  A
08C8A:  MOVWF  xAD
08C8C:  MOVLB  0
08C8E:  CALL   1B88
08C92:  MOVLW  0A
08C94:  MOVLB  A
08C96:  MOVWF  xAD
08C98:  MOVLB  0
08C9A:  CALL   1B88
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
08C9E:  MOVFF  18F,1E0
08CA2:  MOVLB  1
08CA4:  CLRF   xE1
08CA6:  MOVLB  0
08CA8:  CALL   387E
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
08CAC:  CALL   31DC
08CB0:  MOVFF  01,19C
08CB4:  MOVFF  00,19B
08CB8:  MOVLB  1
08CBA:  CLRF   x9E
08CBC:  CLRF   x9D
08CBE:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
08CC0:  CALL   31DC
08CC4:  MOVFF  03,1AE
08CC8:  MOVFF  02,1AD
08CCC:  MOVFF  01,1AC
08CD0:  MOVFF  00,1AB
08CD4:  MOVLB  1
08CD6:  MOVF   x9B,W
08CD8:  SUBWF  xAB,F
08CDA:  MOVF   x9C,W
08CDC:  SUBWFB xAC,F
08CDE:  MOVLW  00
08CE0:  SUBWFB xAD,F
08CE2:  MOVLW  00
08CE4:  SUBWFB xAE,F
08CE6:  MOVF   xAE,F
08CE8:  BTFSC  FD8.2
08CEA:  BRA    8CF2
08CEC:  MOVLB  0
08CEE:  GOTO   8DBC
08CF2:  MOVLB  0
08CF4:  MOVLB  1
08CF6:  MOVF   xAD,F
08CF8:  BTFSC  FD8.2
08CFA:  BRA    8D02
08CFC:  MOVLB  0
08CFE:  GOTO   8DBC
08D02:  MOVLB  0
08D04:  MOVLB  1
08D06:  MOVF   xAC,W
08D08:  SUBWF  x99,W
08D0A:  BTFSC  FD8.0
08D0C:  BRA    8D14
08D0E:  MOVLB  0
08D10:  GOTO   8DBC
08D14:  MOVLB  0
08D16:  BTFSS  FD8.2
08D18:  GOTO   8D2E
08D1C:  MOVLB  1
08D1E:  MOVF   x98,W
08D20:  SUBWF  xAB,W
08D22:  BTFSS  FD8.0
08D24:  BRA    8D2C
08D26:  MOVLB  0
08D28:  GOTO   8DBC
08D2C:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
08D2E:  CALL   31DC
08D32:  MOVFF  01,19E
08D36:  MOVFF  00,19D
....................       if (current_sec - start_time >= cmd.meas_time) {
08D3A:  MOVLB  1
08D3C:  MOVF   x9B,W
08D3E:  SUBWF  x9D,W
08D40:  MOVWF  xAB
08D42:  MOVF   x9C,W
08D44:  SUBWFB x9E,W
08D46:  MOVWF  xAC
08D48:  MOVF   x99,W
08D4A:  SUBWF  xAC,W
08D4C:  BTFSC  FD8.0
08D4E:  BRA    8D56
08D50:  MOVLB  0
08D52:  GOTO   8D74
08D56:  MOVLB  0
08D58:  BTFSS  FD8.2
08D5A:  GOTO   8D70
08D5E:  MOVLB  1
08D60:  MOVF   x98,W
08D62:  SUBWF  xAB,W
08D64:  BTFSC  FD8.0
08D66:  BRA    8D6E
08D68:  MOVLB  0
08D6A:  GOTO   8D74
08D6E:  MOVLB  0
....................           break;
08D70:  GOTO   8DBC
....................       }
....................       sweep_with_threshold(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
08D74:  MOVFF  193,1AC
08D78:  MOVFF  192,1AB
08D7C:  MOVFF  195,1AE
08D80:  MOVFF  194,1AD
08D84:  MOVFF  197,1B0
08D88:  MOVFF  196,1AF
08D8C:  GOTO   7160
....................       // Sleep for the specified time
....................       delay_ms(cmd.sleep_time);
08D90:  MOVFF  191,1AB
08D94:  MOVLB  1
08D96:  INCF   xAB,F
08D98:  MOVLB  0
08D9A:  MOVLB  1
08D9C:  DECFSZ xAB,F
08D9E:  BRA    8DA4
08DA0:  MOVLB  0
08DA2:  BRA    8DB0
08DA4:  MOVLB  A
08DA6:  SETF   x6E
08DA8:  MOVLB  0
08DAA:  CALL   1B5A
08DAE:  BRA    8D9A
08DB0:  MOVFF  190,A6E
08DB4:  CALL   1B5A
08DB8:  GOTO   8CC0
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
08DBC:  MOVFF  18F,1E0
08DC0:  MOVLB  1
08DC2:  SETF   xE1
08DC4:  MOVLB  0
08DC6:  CALL   387E
.................... 
....................    FlashOperationStruct data = {0};
08DCA:  MOVLB  1
08DCC:  CLRF   x9F
08DCE:  CLRF   xA0
08DD0:  CLRF   xA1
08DD2:  CLRF   xA2
08DD4:  CLRF   xA3
08DD6:  CLRF   xA4
08DD8:  CLRF   xA5
08DDA:  CLRF   xA6
08DDC:  CLRF   xA7
08DDE:  CLRF   xA8
08DE0:  CLRF   xA9
08DE2:  CLRF   xAA
....................    data.func_type = ENUM_SMF_WRITE;
08DE4:  CLRF   xA0
....................    data.mission_id = CIGS_IV_DATA; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
08DE6:  MOVLW  04
08DE8:  MOVWF  x9F
....................    data.write_mode = SMF_WRITE_CIRCULAR;
08DEA:  MOVLW  02
08DEC:  MOVWF  xA1
....................    data.source_type = SOURCE_MISF_UNCOPIED;
08DEE:  BCF    xA2.0
....................    // data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    // data.size = 0; // コピーするデータのサイズ
.................... 
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
08DF0:  MOVLW  6C
08DF2:  MOVWF  FF6
08DF4:  MOVLW  14
08DF6:  MOVWF  FF7
08DF8:  MOVLW  00
08DFA:  MOVWF  FF8
08DFC:  MOVLB  0
08DFE:  CALL   1BDA
....................    fprintf(PC, "Mission ID:   %02X\r\n", data.mission_id);
08E02:  MOVLW  86
08E04:  MOVWF  FF6
08E06:  MOVLW  14
08E08:  MOVWF  FF7
08E0A:  MOVLW  00
08E0C:  MOVWF  FF8
08E0E:  MOVLW  0E
08E10:  MOVLB  9
08E12:  MOVWF  xC6
08E14:  MOVLB  0
08E16:  CALL   1C0A
08E1A:  MOVFF  19F,264
08E1E:  MOVLW  37
08E20:  MOVLB  2
08E22:  MOVWF  x65
08E24:  MOVLB  0
08E26:  CALL   1E5E
08E2A:  MOVLW  0D
08E2C:  MOVLB  A
08E2E:  MOVWF  xAD
08E30:  MOVLB  0
08E32:  CALL   1B88
08E36:  MOVLW  0A
08E38:  MOVLB  A
08E3A:  MOVWF  xAD
08E3C:  MOVLB  0
08E3E:  CALL   1B88
....................    fprintf(PC, "Function Type:%02X\r\n", data.func_type);
08E42:  MOVLW  9C
08E44:  MOVWF  FF6
08E46:  MOVLW  14
08E48:  MOVWF  FF7
08E4A:  MOVLW  00
08E4C:  MOVWF  FF8
08E4E:  MOVLW  0E
08E50:  MOVLB  9
08E52:  MOVWF  xC6
08E54:  MOVLB  0
08E56:  CALL   1C0A
08E5A:  MOVFF  1A0,264
08E5E:  MOVLW  37
08E60:  MOVLB  2
08E62:  MOVWF  x65
08E64:  MOVLB  0
08E66:  CALL   1E5E
08E6A:  MOVLW  0D
08E6C:  MOVLB  A
08E6E:  MOVWF  xAD
08E70:  MOVLB  0
08E72:  CALL   1B88
08E76:  MOVLW  0A
08E78:  MOVLB  A
08E7A:  MOVWF  xAD
08E7C:  MOVLB  0
08E7E:  CALL   1B88
....................    fprintf(PC, "Write Mode:   %02X\r\n", data.write_mode);
08E82:  MOVLW  B2
08E84:  MOVWF  FF6
08E86:  MOVLW  14
08E88:  MOVWF  FF7
08E8A:  MOVLW  00
08E8C:  MOVWF  FF8
08E8E:  MOVLW  0E
08E90:  MOVLB  9
08E92:  MOVWF  xC6
08E94:  MOVLB  0
08E96:  CALL   1C0A
08E9A:  MOVFF  1A1,264
08E9E:  MOVLW  37
08EA0:  MOVLB  2
08EA2:  MOVWF  x65
08EA4:  MOVLB  0
08EA6:  CALL   1E5E
08EAA:  MOVLW  0D
08EAC:  MOVLB  A
08EAE:  MOVWF  xAD
08EB0:  MOVLB  0
08EB2:  CALL   1B88
08EB6:  MOVLW  0A
08EB8:  MOVLB  A
08EBA:  MOVWF  xAD
08EBC:  MOVLB  0
08EBE:  CALL   1B88
....................    fprintf(PC, "Source Type:  %02X\r\n", data.source_type);
08EC2:  MOVLW  00
08EC4:  MOVLB  1
08EC6:  BTFSC  xA2.0
08EC8:  MOVLW  01
08ECA:  MOVWF  xAB
08ECC:  MOVLW  C8
08ECE:  MOVWF  FF6
08ED0:  MOVLW  14
08ED2:  MOVWF  FF7
08ED4:  MOVLW  00
08ED6:  MOVWF  FF8
08ED8:  MOVLW  0E
08EDA:  MOVLB  9
08EDC:  MOVWF  xC6
08EDE:  MOVLB  0
08EE0:  CALL   1C0A
08EE4:  MOVFF  1AB,264
08EE8:  MOVLW  37
08EEA:  MOVLB  2
08EEC:  MOVWF  x65
08EEE:  MOVLB  0
08EF0:  CALL   1E5E
08EF4:  MOVLW  0D
08EF6:  MOVLB  A
08EF8:  MOVWF  xAD
08EFA:  MOVLB  0
08EFC:  CALL   1B88
08F00:  MOVLW  0A
08F02:  MOVLB  A
08F04:  MOVWF  xAD
08F06:  MOVLB  0
08F08:  CALL   1B88
....................    fprintf(PC, "Start Address:%04X\r\n", data.misf_start_addr);
08F0C:  MOVLW  DE
08F0E:  MOVWF  FF6
08F10:  MOVLW  14
08F12:  MOVWF  FF7
08F14:  MOVLW  00
08F16:  MOVWF  FF8
08F18:  MOVLW  0E
08F1A:  MOVLB  9
08F1C:  MOVWF  xC6
08F1E:  MOVLB  0
08F20:  CALL   1C0A
08F24:  MOVLW  02
08F26:  MOVLB  1
08F28:  MOVWF  xAB
08F2A:  MOVLB  0
08F2C:  MOVLW  30
08F2E:  MOVLB  A
08F30:  MOVWF  xAD
08F32:  MOVLB  0
08F34:  CALL   1B88
08F38:  MOVLB  1
08F3A:  DECFSZ xAB,F
08F3C:  BRA    8F42
08F3E:  BRA    8F48
08F40:  MOVLB  0
08F42:  MOVLB  0
08F44:  GOTO   8F2C
08F48:  MOVFF  1A3,264
08F4C:  MOVLW  37
08F4E:  MOVLB  2
08F50:  MOVWF  x65
08F52:  MOVLB  0
08F54:  CALL   1E5E
08F58:  MOVLW  0D
08F5A:  MOVLB  A
08F5C:  MOVWF  xAD
08F5E:  MOVLB  0
08F60:  CALL   1B88
08F64:  MOVLW  0A
08F66:  MOVLB  A
08F68:  MOVWF  xAD
08F6A:  MOVLB  0
08F6C:  CALL   1B88
....................    fprintf(PC, "Size:         %04X\r\n", data.misf_size);
08F70:  MOVLW  F4
08F72:  MOVWF  FF6
08F74:  MOVLW  14
08F76:  MOVWF  FF7
08F78:  MOVLW  00
08F7A:  MOVWF  FF8
08F7C:  MOVLW  0E
08F7E:  MOVLB  9
08F80:  MOVWF  xC6
08F82:  MOVLB  0
08F84:  CALL   1C0A
08F88:  MOVLW  02
08F8A:  MOVLB  1
08F8C:  MOVWF  xAB
08F8E:  MOVLB  0
08F90:  MOVLW  30
08F92:  MOVLB  A
08F94:  MOVWF  xAD
08F96:  MOVLB  0
08F98:  CALL   1B88
08F9C:  MOVLB  1
08F9E:  DECFSZ xAB,F
08FA0:  BRA    8FA6
08FA2:  BRA    8FAC
08FA4:  MOVLB  0
08FA6:  MOVLB  0
08FA8:  GOTO   8F90
08FAC:  MOVFF  1A7,264
08FB0:  MOVLW  37
08FB2:  MOVLB  2
08FB4:  MOVWF  x65
08FB6:  MOVLB  0
08FB8:  CALL   1E5E
08FBC:  MOVLW  0D
08FBE:  MOVLB  A
08FC0:  MOVWF  xAD
08FC2:  MOVLB  0
08FC4:  CALL   1B88
08FC8:  MOVLW  0A
08FCA:  MOVLB  A
08FCC:  MOVWF  xAD
08FCE:  MOVLB  0
08FD0:  CALL   1B88
.................... 
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
08FD4:  MOVLW  01
08FD6:  MOVLB  1
08FD8:  MOVWF  xAC
08FDA:  MOVLW  9F
08FDC:  MOVWF  xAB
08FDE:  MOVLB  0
08FE0:  GOTO   87EE
.................... 
....................    fprintf(PC, "End MODE MEAS IV mission\r\n");
08FE4:  MOVLW  0A
08FE6:  MOVWF  FF6
08FE8:  MOVLW  15
08FEA:  MOVWF  FF7
08FEC:  MOVLW  00
08FEE:  MOVWF  FF8
08FF0:  CALL   1BDA
08FF4:  GOTO   9232 (RETURN)
.................... }
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
0624E:  MOVLB  1
06250:  MOVF   xB1,W
06252:  MOVWF  FE9
06254:  MOVF   xB2,W
06256:  MOVWF  FEA
06258:  MOVFF  FEF,1B3
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
0625C:  MOVLW  01
0625E:  ADDWF  xB1,W
06260:  MOVWF  FE9
06262:  MOVLW  00
06264:  ADDWFC xB2,W
06266:  MOVWF  FEA
06268:  MOVF   FEF,W
0626A:  CLRF   xC0
0626C:  MOVWF  xBF
0626E:  MOVFF  1BF,1C0
06272:  CLRF   xBF
06274:  MOVLW  02
06276:  ADDWF  xB1,W
06278:  MOVWF  FE9
0627A:  MOVLW  00
0627C:  ADDWFC xB2,W
0627E:  MOVWF  FEA
06280:  MOVF   FEF,W
06282:  CLRF   03
06284:  IORWF  xBF,W
06286:  MOVWF  xB4
06288:  MOVF   03,W
0628A:  IORWF  xC0,W
0628C:  MOVWF  xB5
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
0628E:  MOVLW  03
06290:  ADDWF  xB1,W
06292:  MOVWF  FE9
06294:  MOVLW  00
06296:  ADDWFC xB2,W
06298:  MOVWF  FEA
0629A:  MOVF   FEF,W
0629C:  CLRF   xC0
0629E:  MOVWF  xBF
062A0:  RLCF   xBF,W
062A2:  MOVWF  xB6
062A4:  RLCF   xC0,W
062A6:  MOVWF  xB7
062A8:  RLCF   xB6,F
062AA:  RLCF   xB7,F
062AC:  RLCF   xB6,F
062AE:  RLCF   xB7,F
062B0:  RLCF   xB6,F
062B2:  RLCF   xB7,F
062B4:  MOVLW  F0
062B6:  ANDWF  xB6,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
062B8:  MOVLW  04
062BA:  ADDWF  xB1,W
062BC:  MOVWF  FE9
062BE:  MOVLW  00
062C0:  ADDWFC xB2,W
062C2:  MOVWF  FEA
062C4:  MOVF   FEF,W
062C6:  CLRF   xC0
062C8:  MOVWF  xBF
062CA:  RLCF   xBF,W
062CC:  MOVWF  xB8
062CE:  RLCF   xC0,W
062D0:  MOVWF  xB9
062D2:  RLCF   xB8,F
062D4:  RLCF   xB9,F
062D6:  RLCF   xB8,F
062D8:  RLCF   xB9,F
062DA:  RLCF   xB8,F
062DC:  RLCF   xB9,F
062DE:  MOVLW  F0
062E0:  ANDWF  xB8,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
062E2:  MOVLW  05
062E4:  ADDWF  xB1,W
062E6:  MOVWF  FE9
062E8:  MOVLW  00
062EA:  ADDWFC xB2,W
062EC:  MOVWF  FEA
062EE:  MOVF   FEF,W
062F0:  CLRF   xC0
062F2:  MOVWF  xBF
062F4:  RLCF   xBF,W
062F6:  MOVWF  xBA
062F8:  RLCF   xC0,W
062FA:  MOVWF  xBB
062FC:  RLCF   xBA,F
062FE:  RLCF   xBB,F
06300:  RLCF   xBA,F
06302:  RLCF   xBB,F
06304:  RLCF   xBA,F
06306:  RLCF   xBB,F
06308:  MOVLW  F0
0630A:  ANDWF  xBA,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
0630C:  MOVLW  06
0630E:  ADDWF  xB1,W
06310:  MOVWF  FE9
06312:  MOVLW  00
06314:  ADDWFC xB2,W
06316:  MOVWF  FEA
06318:  MOVF   FEF,W
0631A:  CLRF   xC0
0631C:  MOVWF  xBF
0631E:  MOVFF  1BF,1C0
06322:  CLRF   xBF
06324:  MOVLW  07
06326:  ADDWF  xB1,W
06328:  MOVWF  FE9
0632A:  MOVLW  00
0632C:  ADDWFC xB2,W
0632E:  MOVWF  FEA
06330:  MOVF   FEF,W
06332:  CLRF   03
06334:  IORWF  xBF,W
06336:  MOVWF  xBC
06338:  MOVF   03,W
0633A:  IORWF  xC0,W
0633C:  MOVWF  xBD
....................    cmd.is_finished = uplinkcmd[8];
0633E:  MOVLW  08
06340:  ADDWF  xB1,W
06342:  MOVWF  FE9
06344:  MOVLW  00
06346:  ADDWFC xB2,W
06348:  MOVWF  FEA
0634A:  MOVFF  FEF,1BE
....................    return cmd;
0634E:  MOVLW  B3
06350:  MOVWF  01
06352:  MOVLW  01
06354:  MOVWF  02
06356:  MOVLB  0
06358:  GOTO   8A6C (RETURN)
.................... }
.................... 
.................... #include "../application/mission/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/measurement/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep_with_threshold(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... 
.................... 
.................... typedef struct{
....................     unsigned int32 time_sec;
....................     unsigned int8 time_msec;
....................     unsigned int16 open_voltage;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
....................     unsigned int16 pd;
.................... } MEASUREMENT_DATA;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } SWEEP_CONFIG;
.................... 
.................... 
.................... 
.................... MEASUREMENT_DATA create_meas_data();
.................... void log_meas_data(MEASUREMENT_DATA *measured_data, SWEEP_CONFIG *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV_HEADER,
....................    CIGS_IV_DATA,
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../../../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../../core/storage/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../../system/mmj_cigs_config.h"
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... 
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_PICLOG = 0,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV_HEADER,
....................     FLASH_ID_IV_DATA,
....................     FLASH_ID_UNKNOWN = 0x7F
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv_header;
....................                 FlashCounter_t iv_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... Flash_t piclog_data={FLASH_ID_PICLOG,0,0,0,0};
.................... Flash_t environment_data={FLASH_ID_ENVIRONMENT,0,0,0,0};
.................... Flash_t iv_header={FLASH_ID_IV_HEADER,0,0,0,0};
.................... Flash_t iv_data={FLASH_ID_IV_DATA,0,0,0,0};
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../../core/logging/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } PICLOG_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_write(unsigned int8 *data);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../../../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
0442A:  MOVLW  26
0442C:  MOVWF  FF6
0442E:  MOVLW  15
04430:  MOVWF  FF7
04432:  MOVLW  00
04434:  MOVWF  FF8
04436:  CALL   1BDA
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
0443A:  MOVLB  1
0443C:  MOVF   x8F,W
0443E:  MOVWF  FE9
04440:  MOVF   x90,W
04442:  MOVWF  FEA
04444:  MOVFF  FEF,191
....................    piclog_make(cmd, 0x00); // Log the command execution
04448:  MOVFF  191,1E0
0444C:  CLRF   xE1
0444E:  MOVLB  0
04450:  CALL   387E
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
04454:  MOVLB  1
04456:  CLRF   x95
04458:  CLRF   x94
0445A:  CLRF   x93
0445C:  CLRF   x92
0445E:  MOVLB  0
04460:  MOVLB  1
04462:  MOVF   x95,F
04464:  BTFSC  FD8.2
04466:  BRA    446E
04468:  MOVLB  0
0446A:  GOTO   44E6
0446E:  MOVLB  0
04470:  MOVLB  1
04472:  MOVF   x94,W
04474:  SUBLW  0F
04476:  BTFSC  FD8.0
04478:  BRA    4480
0447A:  MOVLB  0
0447C:  GOTO   44E6
04480:  MOVLB  0
04482:  BTFSS  FD8.2
04484:  GOTO   44B2
04488:  MOVLB  1
0448A:  MOVF   x93,W
0448C:  SUBLW  FF
0448E:  BTFSC  FD8.0
04490:  BRA    4498
04492:  MOVLB  0
04494:  GOTO   44E6
04498:  MOVLB  0
0449A:  BTFSS  FD8.2
0449C:  GOTO   44B2
044A0:  MOVLB  1
044A2:  MOVF   x92,W
044A4:  SUBLW  FE
044A6:  BTFSC  FD8.0
044A8:  BRA    44B0
044AA:  MOVLB  0
044AC:  GOTO   44E6
044B0:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
044B2:  MOVFF  111,A59
044B6:  MOVFF  110,A58
044BA:  MOVFF  10F,A57
044BE:  MOVFF  10E,A56
044C2:  MOVFF  195,A5D
044C6:  MOVFF  194,A5C
044CA:  MOVFF  193,A5B
044CE:  MOVFF  192,A5A
044D2:  CALL   40D2
044D6:  MOVLW  01
044D8:  MOVLB  1
044DA:  ADDWF  x94,F
044DC:  MOVLW  00
044DE:  ADDWFC x95,F
044E0:  MOVLB  0
044E2:  GOTO   4460
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
044E6:  MOVFF  191,1E0
044EA:  MOVLB  1
044EC:  SETF   xE1
044EE:  MOVLB  0
044F0:  CALL   387E
....................    printf("End Flash Erase All\r\n");
044F4:  MOVLW  3E
044F6:  MOVWF  FF6
044F8:  MOVLW  15
044FA:  MOVWF  FF7
044FC:  MOVLW  00
044FE:  MOVWF  FF8
04500:  CALL   1BDA
04504:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
04506:  MOVLW  54
04508:  MOVWF  FF6
0450A:  MOVLW  15
0450C:  MOVWF  FF7
0450E:  MOVLW  00
04510:  MOVWF  FF8
04512:  CALL   1BDA
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
04516:  MOVLB  1
04518:  MOVF   x8D,W
0451A:  MOVWF  FE9
0451C:  MOVF   x8E,W
0451E:  MOVWF  FEA
04520:  MOVFF  FEF,18F
04524:  MOVLW  01
04526:  ADDWF  x8D,W
04528:  MOVWF  FE9
0452A:  MOVLW  00
0452C:  ADDWFC x8E,W
0452E:  MOVWF  FEA
04530:  MOVF   FEF,W
04532:  CLRF   x97
04534:  CLRF   x96
04536:  CLRF   x95
04538:  MOVWF  x94
0453A:  MOVFF  194,197
0453E:  CLRF   x94
04540:  CLRF   x95
04542:  CLRF   x96
04544:  MOVLW  02
04546:  ADDWF  x8D,W
04548:  MOVWF  FE9
0454A:  MOVLW  00
0454C:  ADDWFC x8E,W
0454E:  MOVWF  FEA
04550:  MOVF   FEF,W
04552:  CLRF   x9C
04554:  CLRF   x9B
04556:  CLRF   x9A
04558:  MOVWF  x99
0455A:  MOVFF  19A,03
0455E:  MOVFF  199,02
04562:  CLRF   00
04564:  CLRF   01
04566:  MOVF   00,W
04568:  IORWF  x94,F
0456A:  MOVF   01,W
0456C:  IORWF  x95,F
0456E:  MOVF   02,W
04570:  IORWF  x96,F
04572:  MOVF   03,W
04574:  IORWF  x97,F
04576:  MOVLW  03
04578:  ADDWF  x8D,W
0457A:  MOVWF  FE9
0457C:  MOVLW  00
0457E:  ADDWFC x8E,W
04580:  MOVWF  FEA
04582:  MOVF   FEF,W
04584:  CLRF   x9C
04586:  CLRF   x9B
04588:  CLRF   x9A
0458A:  MOVWF  x99
0458C:  MOVFF  19B,03
04590:  MOVFF  19A,02
04594:  MOVFF  199,01
04598:  CLRF   00
0459A:  MOVF   00,W
0459C:  IORWF  x94,F
0459E:  MOVF   01,W
045A0:  IORWF  x95,F
045A2:  MOVF   02,W
045A4:  IORWF  x96,F
045A6:  MOVF   03,W
045A8:  IORWF  x97,F
045AA:  MOVLW  04
045AC:  ADDWF  x8D,W
045AE:  MOVWF  FE9
045B0:  MOVLW  00
045B2:  ADDWFC x8E,W
045B4:  MOVWF  FEA
045B6:  MOVF   FEF,W
045B8:  MOVWF  00
045BA:  CLRF   01
045BC:  CLRF   02
045BE:  CLRF   03
045C0:  MOVF   00,W
045C2:  IORWF  x94,W
045C4:  MOVWF  x90
045C6:  MOVF   01,W
045C8:  IORWF  x95,W
045CA:  MOVWF  x91
045CC:  MOVF   02,W
045CE:  IORWF  x96,W
045D0:  MOVWF  x92
045D2:  MOVF   03,W
045D4:  IORWF  x97,W
045D6:  MOVWF  x93
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
045D8:  MOVLW  72
045DA:  MOVWF  FF6
045DC:  MOVLW  15
045DE:  MOVWF  FF7
045E0:  MOVLW  00
045E2:  MOVWF  FF8
045E4:  MOVLW  13
045E6:  MOVLB  9
045E8:  MOVWF  xC6
045EA:  MOVLB  0
045EC:  CALL   1C0A
045F0:  MOVFF  193,264
045F4:  MOVLW  37
045F6:  MOVLB  2
045F8:  MOVWF  x65
045FA:  MOVLB  0
045FC:  CALL   1E5E
04600:  MOVFF  192,264
04604:  MOVLW  37
04606:  MOVLB  2
04608:  MOVWF  x65
0460A:  MOVLB  0
0460C:  CALL   1E5E
04610:  MOVFF  191,264
04614:  MOVLW  37
04616:  MOVLB  2
04618:  MOVWF  x65
0461A:  MOVLB  0
0461C:  CALL   1E5E
04620:  MOVFF  190,264
04624:  MOVLW  37
04626:  MOVLB  2
04628:  MOVWF  x65
0462A:  MOVLB  0
0462C:  CALL   1E5E
04630:  MOVLW  0D
04632:  MOVLB  A
04634:  MOVWF  xAD
04636:  MOVLB  0
04638:  CALL   1B88
0463C:  MOVLW  0A
0463E:  MOVLB  A
04640:  MOVWF  xAD
04642:  MOVLB  0
04644:  CALL   1B88
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04648:  MOVFF  18F,1E0
0464C:  MOVLB  1
0464E:  CLRF   xE1
04650:  MOVLB  0
04652:  CALL   387E
....................    
....................    sector_erase(mis_fm, sector_address);
04656:  MOVFF  111,A59
0465A:  MOVFF  110,A58
0465E:  MOVFF  10F,A57
04662:  MOVFF  10E,A56
04666:  MOVFF  193,A5D
0466A:  MOVFF  192,A5C
0466E:  MOVFF  191,A5B
04672:  MOVFF  190,A5A
04676:  CALL   40D2
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0467A:  MOVFF  18F,1E0
0467E:  MOVLB  1
04680:  SETF   xE1
04682:  MOVLB  0
04684:  CALL   387E
....................    printf("End Flash Erase 1 Sector\r\n");
04688:  MOVLW  8E
0468A:  MOVWF  FF6
0468C:  MOVLW  15
0468E:  MOVWF  FF7
04690:  MOVLW  00
04692:  MOVWF  FF8
04694:  CALL   1BDA
04698:  GOTO   9142 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
049F8:  MOVLW  AA
049FA:  MOVWF  FF6
049FC:  MOVLW  15
049FE:  MOVWF  FF7
04A00:  MOVLW  00
04A02:  MOVWF  FF8
04A04:  CALL   1BDA
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
04A08:  MOVLB  1
04A0A:  MOVF   x8D,W
04A0C:  MOVWF  FE9
04A0E:  MOVF   x8E,W
04A10:  MOVWF  FEA
04A12:  MOVFF  FEF,18F
04A16:  MOVLW  01
04A18:  ADDWF  x8D,W
04A1A:  MOVWF  FE9
04A1C:  MOVLW  00
04A1E:  ADDWFC x8E,W
04A20:  MOVWF  FEA
04A22:  MOVF   FEF,W
04A24:  CLRF   x97
04A26:  CLRF   x96
04A28:  CLRF   x95
04A2A:  MOVWF  x94
04A2C:  MOVFF  194,197
04A30:  CLRF   x94
04A32:  CLRF   x95
04A34:  CLRF   x96
04A36:  MOVLW  02
04A38:  ADDWF  x8D,W
04A3A:  MOVWF  FE9
04A3C:  MOVLW  00
04A3E:  ADDWFC x8E,W
04A40:  MOVWF  FEA
04A42:  MOVF   FEF,W
04A44:  CLRF   x9C
04A46:  CLRF   x9B
04A48:  CLRF   x9A
04A4A:  MOVWF  x99
04A4C:  MOVFF  19A,03
04A50:  MOVFF  199,02
04A54:  CLRF   00
04A56:  CLRF   01
04A58:  MOVF   00,W
04A5A:  IORWF  x94,F
04A5C:  MOVF   01,W
04A5E:  IORWF  x95,F
04A60:  MOVF   02,W
04A62:  IORWF  x96,F
04A64:  MOVF   03,W
04A66:  IORWF  x97,F
04A68:  MOVLW  03
04A6A:  ADDWF  x8D,W
04A6C:  MOVWF  FE9
04A6E:  MOVLW  00
04A70:  ADDWFC x8E,W
04A72:  MOVWF  FEA
04A74:  MOVF   FEF,W
04A76:  CLRF   x9C
04A78:  CLRF   x9B
04A7A:  CLRF   x9A
04A7C:  MOVWF  x99
04A7E:  MOVFF  19B,03
04A82:  MOVFF  19A,02
04A86:  MOVFF  199,01
04A8A:  CLRF   00
04A8C:  MOVF   00,W
04A8E:  IORWF  x94,F
04A90:  MOVF   01,W
04A92:  IORWF  x95,F
04A94:  MOVF   02,W
04A96:  IORWF  x96,F
04A98:  MOVF   03,W
04A9A:  IORWF  x97,F
04A9C:  MOVLW  04
04A9E:  ADDWF  x8D,W
04AA0:  MOVWF  FE9
04AA2:  MOVLW  00
04AA4:  ADDWFC x8E,W
04AA6:  MOVWF  FEA
04AA8:  MOVF   FEF,W
04AAA:  MOVWF  00
04AAC:  CLRF   01
04AAE:  CLRF   02
04AB0:  CLRF   03
04AB2:  MOVF   00,W
04AB4:  IORWF  x94,W
04AB6:  MOVWF  x90
04AB8:  MOVF   01,W
04ABA:  IORWF  x95,W
04ABC:  MOVWF  x91
04ABE:  MOVF   02,W
04AC0:  IORWF  x96,W
04AC2:  MOVWF  x92
04AC4:  MOVF   03,W
04AC6:  IORWF  x97,W
04AC8:  MOVWF  x93
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
04ACA:  MOVLW  C6
04ACC:  MOVWF  FF6
04ACE:  MOVLW  15
04AD0:  MOVWF  FF7
04AD2:  MOVLW  00
04AD4:  MOVWF  FF8
04AD6:  MOVLW  16
04AD8:  MOVLB  9
04ADA:  MOVWF  xC6
04ADC:  MOVLB  0
04ADE:  CALL   1C0A
04AE2:  MOVFF  193,264
04AE6:  MOVLW  37
04AE8:  MOVLB  2
04AEA:  MOVWF  x65
04AEC:  MOVLB  0
04AEE:  CALL   1E5E
04AF2:  MOVFF  192,264
04AF6:  MOVLW  37
04AF8:  MOVLB  2
04AFA:  MOVWF  x65
04AFC:  MOVLB  0
04AFE:  CALL   1E5E
04B02:  MOVFF  191,264
04B06:  MOVLW  37
04B08:  MOVLB  2
04B0A:  MOVWF  x65
04B0C:  MOVLB  0
04B0E:  CALL   1E5E
04B12:  MOVFF  190,264
04B16:  MOVLW  37
04B18:  MOVLB  2
04B1A:  MOVWF  x65
04B1C:  MOVLB  0
04B1E:  CALL   1E5E
04B22:  MOVLW  0D
04B24:  MOVLB  A
04B26:  MOVWF  xAD
04B28:  MOVLB  0
04B2A:  CALL   1B88
04B2E:  MOVLW  0A
04B30:  MOVLB  A
04B32:  MOVWF  xAD
04B34:  MOVLB  0
04B36:  CALL   1B88
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04B3A:  MOVFF  18F,1E0
04B3E:  MOVLB  1
04B40:  CLRF   xE1
04B42:  MOVLB  0
04B44:  CALL   387E
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
04B48:  MOVFF  111,2E5
04B4C:  MOVFF  110,2E4
04B50:  MOVFF  10F,2E3
04B54:  MOVFF  10E,2E2
04B58:  MOVLB  2
04B5A:  CLRF   xE9
04B5C:  CLRF   xE8
04B5E:  CLRF   xE7
04B60:  CLRF   xE6
04B62:  MOVLB  0
04B64:  CALL   469C
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04B68:  MOVFF  18F,1E0
04B6C:  MOVLB  1
04B6E:  SETF   xE1
04B70:  MOVLB  0
04B72:  CALL   387E
....................    printf("End Flash Copy 1 Sector\r\n");
04B76:  MOVLW  E4
04B78:  MOVWF  FF6
04B7A:  MOVLW  15
04B7C:  MOVWF  FF7
04B7E:  MOVLW  00
04B80:  MOVWF  FF8
04B82:  CALL   1BDA
04B86:  GOTO   9152 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
04B8A:  MOVLW  FE
04B8C:  MOVWF  FF6
04B8E:  MOVLW  15
04B90:  MOVWF  FF7
04B92:  MOVLW  00
04B94:  MOVWF  FF8
04B96:  CALL   1BDA
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
04B9A:  MOVLB  1
04B9C:  MOVF   x8D,W
04B9E:  MOVWF  FE9
04BA0:  MOVF   x8E,W
04BA2:  MOVWF  FEA
04BA4:  MOVFF  FEF,18F
04BA8:  MOVLW  01
04BAA:  ADDWF  x8D,W
04BAC:  MOVWF  FE9
04BAE:  MOVLW  00
04BB0:  ADDWFC x8E,W
04BB2:  MOVWF  FEA
04BB4:  MOVF   FEF,W
04BB6:  CLRF   x97
04BB8:  CLRF   x96
04BBA:  CLRF   x95
04BBC:  MOVWF  x94
04BBE:  MOVFF  194,197
04BC2:  CLRF   x94
04BC4:  CLRF   x95
04BC6:  CLRF   x96
04BC8:  MOVLW  02
04BCA:  ADDWF  x8D,W
04BCC:  MOVWF  FE9
04BCE:  MOVLW  00
04BD0:  ADDWFC x8E,W
04BD2:  MOVWF  FEA
04BD4:  MOVF   FEF,W
04BD6:  CLRF   x9C
04BD8:  CLRF   x9B
04BDA:  CLRF   x9A
04BDC:  MOVWF  x99
04BDE:  MOVFF  19A,03
04BE2:  MOVFF  199,02
04BE6:  CLRF   00
04BE8:  CLRF   01
04BEA:  MOVF   00,W
04BEC:  IORWF  x94,F
04BEE:  MOVF   01,W
04BF0:  IORWF  x95,F
04BF2:  MOVF   02,W
04BF4:  IORWF  x96,F
04BF6:  MOVF   03,W
04BF8:  IORWF  x97,F
04BFA:  MOVLW  03
04BFC:  ADDWF  x8D,W
04BFE:  MOVWF  FE9
04C00:  MOVLW  00
04C02:  ADDWFC x8E,W
04C04:  MOVWF  FEA
04C06:  MOVF   FEF,W
04C08:  CLRF   x9C
04C0A:  CLRF   x9B
04C0C:  CLRF   x9A
04C0E:  MOVWF  x99
04C10:  MOVFF  19B,03
04C14:  MOVFF  19A,02
04C18:  MOVFF  199,01
04C1C:  CLRF   00
04C1E:  MOVF   00,W
04C20:  IORWF  x94,F
04C22:  MOVF   01,W
04C24:  IORWF  x95,F
04C26:  MOVF   02,W
04C28:  IORWF  x96,F
04C2A:  MOVF   03,W
04C2C:  IORWF  x97,F
04C2E:  MOVLW  04
04C30:  ADDWF  x8D,W
04C32:  MOVWF  FE9
04C34:  MOVLW  00
04C36:  ADDWFC x8E,W
04C38:  MOVWF  FEA
04C3A:  MOVF   FEF,W
04C3C:  MOVWF  00
04C3E:  CLRF   01
04C40:  CLRF   02
04C42:  CLRF   03
04C44:  MOVF   00,W
04C46:  IORWF  x94,W
04C48:  MOVWF  x90
04C4A:  MOVF   01,W
04C4C:  IORWF  x95,W
04C4E:  MOVWF  x91
04C50:  MOVF   02,W
04C52:  IORWF  x96,W
04C54:  MOVWF  x92
04C56:  MOVF   03,W
04C58:  IORWF  x97,W
04C5A:  MOVWF  x93
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
04C5C:  MOVLW  24
04C5E:  MOVWF  FF6
04C60:  MOVLW  16
04C62:  MOVWF  FF7
04C64:  MOVLW  00
04C66:  MOVWF  FF8
04C68:  MOVLW  16
04C6A:  MOVLB  9
04C6C:  MOVWF  xC6
04C6E:  MOVLB  0
04C70:  CALL   1C0A
04C74:  MOVFF  193,264
04C78:  MOVLW  37
04C7A:  MOVLB  2
04C7C:  MOVWF  x65
04C7E:  MOVLB  0
04C80:  CALL   1E5E
04C84:  MOVFF  192,264
04C88:  MOVLW  37
04C8A:  MOVLB  2
04C8C:  MOVWF  x65
04C8E:  MOVLB  0
04C90:  CALL   1E5E
04C94:  MOVFF  191,264
04C98:  MOVLW  37
04C9A:  MOVLB  2
04C9C:  MOVWF  x65
04C9E:  MOVLB  0
04CA0:  CALL   1E5E
04CA4:  MOVFF  190,264
04CA8:  MOVLW  37
04CAA:  MOVLB  2
04CAC:  MOVWF  x65
04CAE:  MOVLB  0
04CB0:  CALL   1E5E
04CB4:  MOVLW  0D
04CB6:  MOVLB  A
04CB8:  MOVWF  xAD
04CBA:  MOVLB  0
04CBC:  CALL   1B88
04CC0:  MOVLW  0A
04CC2:  MOVLB  A
04CC4:  MOVWF  xAD
04CC6:  MOVLB  0
04CC8:  CALL   1B88
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
04CCC:  MOVFF  18F,1E0
04CD0:  MOVLB  1
04CD2:  CLRF   xE1
04CD4:  MOVLB  0
04CD6:  CALL   387E
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
04CDA:  MOVFF  18F,1E0
04CDE:  MOVLB  1
04CE0:  SETF   xE1
04CE2:  MOVLB  0
04CE4:  CALL   387E
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
04CE8:  MOVLW  42
04CEA:  MOVWF  FF6
04CEC:  MOVLW  16
04CEE:  MOVWF  FF7
04CF0:  MOVLW  00
04CF2:  MOVWF  FF8
04CF4:  CALL   1BDA
04CF8:  GOTO   9162 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
04CFC:  MOVLW  66
04CFE:  MOVWF  FF6
04D00:  MOVLW  16
04D02:  MOVWF  FF7
04D04:  MOVLW  00
04D06:  MOVWF  FF8
04D08:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
04D0C:  MOVLB  1
04D0E:  MOVF   x8D,W
04D10:  MOVWF  FE9
04D12:  MOVF   x8E,W
04D14:  MOVWF  FEA
04D16:  MOVFF  FEF,1DF
04D1A:  MOVFF  1DF,1E0
04D1E:  CLRF   xE1
04D20:  MOVLB  0
04D22:  CALL   387E
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
04D26:  MOVLB  1
04D28:  CLRF   x8F
04D2A:  CLRF   x90
04D2C:  CLRF   x91
04D2E:  CLRF   x92
04D30:  CLRF   x93
04D32:  CLRF   x94
04D34:  CLRF   x95
....................    
....................    flash_write_param.id = parameter[0];
04D36:  MOVF   x8D,W
04D38:  MOVWF  FE9
04D3A:  MOVF   x8E,W
04D3C:  MOVWF  FEA
04D3E:  MOVFF  FEF,18F
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
04D42:  MOVLW  01
04D44:  ADDWF  x8D,W
04D46:  MOVWF  FE9
04D48:  MOVLW  00
04D4A:  ADDWFC x8E,W
04D4C:  MOVWF  FEA
04D4E:  MOVF   FEF,W
04D50:  CLRF   xE2
04D52:  CLRF   xE1
04D54:  CLRF   xE0
04D56:  MOVWF  xDF
04D58:  MOVFF  1DF,1E2
04D5C:  CLRF   xDF
04D5E:  CLRF   xE0
04D60:  CLRF   xE1
04D62:  MOVLW  02
04D64:  ADDWF  x8D,W
04D66:  MOVWF  FE9
04D68:  MOVLW  00
04D6A:  ADDWFC x8E,W
04D6C:  MOVWF  FEA
04D6E:  MOVF   FEF,W
04D70:  CLRF   xE7
04D72:  CLRF   xE6
04D74:  CLRF   xE5
04D76:  MOVWF  xE4
04D78:  MOVFF  1E5,03
04D7C:  MOVFF  1E4,02
04D80:  CLRF   00
04D82:  CLRF   01
04D84:  MOVF   00,W
04D86:  IORWF  xDF,F
04D88:  MOVF   01,W
04D8A:  IORWF  xE0,F
04D8C:  MOVF   02,W
04D8E:  IORWF  xE1,F
04D90:  MOVF   03,W
04D92:  IORWF  xE2,F
04D94:  MOVLW  03
04D96:  ADDWF  x8D,W
04D98:  MOVWF  FE9
04D9A:  MOVLW  00
04D9C:  ADDWFC x8E,W
04D9E:  MOVWF  FEA
04DA0:  MOVF   FEF,W
04DA2:  CLRF   xE7
04DA4:  CLRF   xE6
04DA6:  CLRF   xE5
04DA8:  MOVWF  xE4
04DAA:  MOVFF  1E6,03
04DAE:  MOVFF  1E5,02
04DB2:  MOVFF  1E4,01
04DB6:  CLRF   00
04DB8:  MOVF   00,W
04DBA:  IORWF  xDF,F
04DBC:  MOVF   01,W
04DBE:  IORWF  xE0,F
04DC0:  MOVF   02,W
04DC2:  IORWF  xE1,F
04DC4:  MOVF   03,W
04DC6:  IORWF  xE2,F
04DC8:  MOVLW  04
04DCA:  ADDWF  x8D,W
04DCC:  MOVWF  FE9
04DCE:  MOVLW  00
04DD0:  ADDWFC x8E,W
04DD2:  MOVWF  FEA
04DD4:  MOVF   FEF,W
04DD6:  MOVWF  00
04DD8:  CLRF   01
04DDA:  CLRF   02
04DDC:  CLRF   03
04DDE:  MOVF   00,W
04DE0:  IORWF  xDF,W
04DE2:  MOVWF  x90
04DE4:  MOVF   01,W
04DE6:  IORWF  xE0,W
04DE8:  MOVWF  x91
04DEA:  MOVF   02,W
04DEC:  IORWF  xE1,W
04DEE:  MOVWF  x92
04DF0:  MOVF   03,W
04DF2:  IORWF  xE2,W
04DF4:  MOVWF  x93
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
04DF6:  MOVLW  07
04DF8:  ADDWF  x8D,W
04DFA:  MOVWF  FE9
04DFC:  MOVLW  00
04DFE:  ADDWFC x8E,W
04E00:  MOVWF  FEA
04E02:  MOVF   FEF,W
04E04:  CLRF   xE0
04E06:  MOVWF  xDF
04E08:  MOVFF  1DF,1E0
04E0C:  CLRF   xDF
04E0E:  MOVLW  08
04E10:  ADDWF  x8D,W
04E12:  MOVWF  FE9
04E14:  MOVLW  00
04E16:  ADDWFC x8E,W
04E18:  MOVWF  FEA
04E1A:  MOVF   FEF,W
04E1C:  CLRF   03
04E1E:  IORWF  xDF,W
04E20:  MOVWF  x94
04E22:  MOVF   03,W
04E24:  IORWF  xE0,W
04E26:  MOVWF  x95
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
04E28:  MOVLW  80
04E2A:  MOVWF  FF6
04E2C:  MOVLW  16
04E2E:  MOVWF  FF7
04E30:  MOVLW  00
04E32:  MOVWF  FF8
04E34:  MOVLW  0C
04E36:  MOVLB  9
04E38:  MOVWF  xC6
04E3A:  MOVLB  0
04E3C:  CALL   1C0A
04E40:  MOVFF  18F,264
04E44:  MOVLW  37
04E46:  MOVLB  2
04E48:  MOVWF  x65
04E4A:  MOVLB  0
04E4C:  CALL   1E5E
04E50:  MOVLW  0D
04E52:  MOVLB  A
04E54:  MOVWF  xAD
04E56:  MOVLB  0
04E58:  CALL   1B88
04E5C:  MOVLW  0A
04E5E:  MOVLB  A
04E60:  MOVWF  xAD
04E62:  MOVLB  0
04E64:  CALL   1B88
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
04E68:  MOVLW  94
04E6A:  MOVWF  FF6
04E6C:  MOVLW  16
04E6E:  MOVWF  FF7
04E70:  MOVLW  00
04E72:  MOVWF  FF8
04E74:  MOVLW  0E
04E76:  MOVLB  9
04E78:  MOVWF  xC6
04E7A:  MOVLB  0
04E7C:  CALL   1C0A
04E80:  MOVFF  193,264
04E84:  MOVLW  37
04E86:  MOVLB  2
04E88:  MOVWF  x65
04E8A:  MOVLB  0
04E8C:  CALL   1E5E
04E90:  MOVFF  192,264
04E94:  MOVLW  37
04E96:  MOVLB  2
04E98:  MOVWF  x65
04E9A:  MOVLB  0
04E9C:  CALL   1E5E
04EA0:  MOVFF  191,264
04EA4:  MOVLW  37
04EA6:  MOVLB  2
04EA8:  MOVWF  x65
04EAA:  MOVLB  0
04EAC:  CALL   1E5E
04EB0:  MOVFF  190,264
04EB4:  MOVLW  37
04EB6:  MOVLB  2
04EB8:  MOVWF  x65
04EBA:  MOVLB  0
04EBC:  CALL   1E5E
04EC0:  MOVLW  0D
04EC2:  MOVLB  A
04EC4:  MOVWF  xAD
04EC6:  MOVLB  0
04EC8:  CALL   1B88
04ECC:  MOVLW  0A
04ECE:  MOVLB  A
04ED0:  MOVWF  xAD
04ED2:  MOVLB  0
04ED4:  CALL   1B88
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
04ED8:  MOVLW  AA
04EDA:  MOVWF  FF6
04EDC:  MOVLW  16
04EDE:  MOVWF  FF7
04EE0:  MOVLW  00
04EE2:  MOVWF  FF8
04EE4:  MOVLW  0E
04EE6:  MOVLB  9
04EE8:  MOVWF  xC6
04EEA:  MOVLB  0
04EEC:  CALL   1C0A
04EF0:  MOVFF  195,264
04EF4:  MOVLW  37
04EF6:  MOVLB  2
04EF8:  MOVWF  x65
04EFA:  MOVLB  0
04EFC:  CALL   1E5E
04F00:  MOVFF  194,264
04F04:  MOVLW  37
04F06:  MOVLB  2
04F08:  MOVWF  x65
04F0A:  MOVLB  0
04F0C:  CALL   1E5E
04F10:  MOVLW  0D
04F12:  MOVLB  A
04F14:  MOVWF  xAD
04F16:  MOVLB  0
04F18:  CALL   1B88
04F1C:  MOVLW  0A
04F1E:  MOVLB  A
04F20:  MOVWF  xAD
04F22:  MOVLB  0
04F24:  CALL   1B88
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
04F28:  MOVFF  18F,1E0
04F2C:  MOVLB  1
04F2E:  CLRF   xE1
04F30:  MOVLB  0
04F32:  CALL   387E
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
04F36:  MOVLW  C0
04F38:  MOVWF  FF6
04F3A:  MOVLW  16
04F3C:  MOVWF  FF7
04F3E:  MOVLW  00
04F40:  MOVWF  FF8
04F42:  CALL   1BDA
....................    for (p = 0; p < flash_write_param.packetnum; p++)
04F46:  MOVLB  1
04F48:  CLRF   xD7
04F4A:  CLRF   xD6
04F4C:  MOVLB  0
04F4E:  MOVLB  1
04F50:  MOVF   xD7,W
04F52:  SUBWF  x95,W
04F54:  BTFSC  FD8.0
04F56:  BRA    4F5E
04F58:  MOVLB  0
04F5A:  GOTO   508C
04F5E:  MOVLB  0
04F60:  BTFSS  FD8.2
04F62:  GOTO   4F78
04F66:  MOVLB  1
04F68:  MOVF   x94,W
04F6A:  SUBWF  xD6,W
04F6C:  BTFSS  FD8.0
04F6E:  BRA    4F76
04F70:  MOVLB  0
04F72:  GOTO   508C
04F76:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
04F78:  MOVLB  1
04F7A:  RLCF   xD6,W
04F7C:  MOVWF  xD8
04F7E:  RLCF   xD7,W
04F80:  MOVWF  xD9
04F82:  RLCF   xD8,F
04F84:  RLCF   xD9,F
04F86:  RLCF   xD8,F
04F88:  RLCF   xD9,F
04F8A:  RLCF   xD8,F
04F8C:  RLCF   xD9,F
04F8E:  RLCF   xD8,F
04F90:  RLCF   xD9,F
04F92:  RLCF   xD8,F
04F94:  RLCF   xD9,F
04F96:  MOVLW  C0
04F98:  ANDWF  xD8,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
04F9A:  CLRF   xDA
04F9C:  MOVLB  0
04F9E:  MOVLB  1
04FA0:  MOVF   xDA,W
04FA2:  SUBLW  3F
04FA4:  BTFSC  FD8.0
04FA6:  BRA    4FAE
04FA8:  MOVLB  0
04FAA:  GOTO   500E
04FAE:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
04FB0:  CLRF   03
04FB2:  MOVLB  1
04FB4:  MOVF   xDA,W
04FB6:  ADDLW  96
04FB8:  MOVWF  FE9
04FBA:  MOVLW  01
04FBC:  ADDWFC 03,W
04FBE:  MOVWF  FEA
04FC0:  MOVF   xDA,W
04FC2:  ADDWF  xD8,W
04FC4:  MOVWF  xE1
04FC6:  MOVLW  00
04FC8:  ADDWFC xD9,W
04FCA:  MOVWF  xE2
04FCC:  MOVF   xE1,W
04FCE:  MOVWF  00
04FD0:  CLRF   03
04FD2:  MOVF   00,W
04FD4:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
04FD6:  CLRF   03
04FD8:  MOVF   xDA,W
04FDA:  ADDLW  96
04FDC:  MOVWF  FE9
04FDE:  MOVLW  01
04FE0:  ADDWFC 03,W
04FE2:  MOVWF  FEA
04FE4:  MOVFF  FEF,1DF
04FE8:  MOVFF  1DF,264
04FEC:  MOVLW  37
04FEE:  MOVLB  2
04FF0:  MOVWF  x65
04FF2:  MOVLB  0
04FF4:  CALL   1E5E
04FF8:  MOVLW  20
04FFA:  MOVLB  A
04FFC:  MOVWF  xAD
04FFE:  MOVLB  0
05000:  CALL   1B88
05004:  MOVLB  1
05006:  INCF   xDA,F
05008:  MOVLB  0
0500A:  GOTO   4F9E
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
0500E:  MOVLB  1
05010:  RLCF   xD6,W
05012:  MOVWF  02
05014:  RLCF   xD7,W
05016:  MOVWF  03
05018:  RLCF   02,F
0501A:  RLCF   03,F
0501C:  RLCF   02,F
0501E:  RLCF   03,F
05020:  RLCF   02,F
05022:  RLCF   03,F
05024:  RLCF   02,F
05026:  RLCF   03,F
05028:  RLCF   02,F
0502A:  RLCF   03,F
0502C:  MOVLW  C0
0502E:  ANDWF  02,F
05030:  MOVF   02,W
05032:  ADDWF  x90,W
05034:  MOVWF  xDB
05036:  MOVF   03,W
05038:  ADDWFC x91,W
0503A:  MOVWF  xDC
0503C:  MOVLW  00
0503E:  ADDWFC x92,W
05040:  MOVWF  xDD
05042:  MOVLW  00
05044:  ADDWFC x93,W
05046:  MOVWF  xDE
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
05048:  MOVFF  111,A59
0504C:  MOVFF  110,A58
05050:  MOVFF  10F,A57
05054:  MOVFF  10E,A56
05058:  MOVFF  1DE,A5D
0505C:  MOVFF  1DD,A5C
05060:  MOVFF  1DC,A5B
05064:  MOVFF  1DB,A5A
05068:  MOVLW  01
0506A:  MOVLB  A
0506C:  MOVWF  x5F
0506E:  MOVLW  96
05070:  MOVWF  x5E
05072:  CLRF   x61
05074:  MOVLW  40
05076:  MOVWF  x60
05078:  MOVLB  0
0507A:  CALL   34FA
0507E:  MOVLB  1
05080:  INCF   xD6,F
05082:  BTFSC  FD8.2
05084:  INCF   xD7,F
05086:  MOVLB  0
05088:  GOTO   4F4E
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
0508C:  MOVFF  18F,1E0
05090:  MOVLB  1
05092:  SETF   xE1
05094:  MOVLB  0
05096:  CALL   387E
....................    fprintf(PC, "\r\n");
0509A:  MOVLW  0D
0509C:  MOVLB  A
0509E:  MOVWF  xAD
050A0:  MOVLB  0
050A2:  CALL   1B88
050A6:  MOVLW  0A
050A8:  MOVLB  A
050AA:  MOVWF  xAD
050AC:  MOVLB  0
050AE:  CALL   1B88
....................    fprintf(PC, "End Flash Write Demo\r\n");
050B2:  MOVLW  CE
050B4:  MOVWF  FF6
050B6:  MOVLW  16
050B8:  MOVWF  FF7
050BA:  MOVLW  00
050BC:  MOVWF  FF8
050BE:  CALL   1BDA
050C2:  GOTO   9172 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
050F6:  MOVLW  E6
050F8:  MOVWF  FF6
050FA:  MOVLW  16
050FC:  MOVWF  FF7
050FE:  MOVLW  00
05100:  MOVWF  FF8
05102:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05106:  MOVLB  1
05108:  MOVF   x8D,W
0510A:  MOVWF  FE9
0510C:  MOVF   x8E,W
0510E:  MOVWF  FEA
05110:  MOVFF  FEF,193
05114:  MOVFF  193,1E0
05118:  CLRF   xE1
0511A:  MOVLB  0
0511C:  CALL   387E
....................    flash_setting(mis_fm);
05120:  MOVFF  111,29B
05124:  MOVFF  110,29A
05128:  MOVFF  10F,299
0512C:  MOVFF  10E,298
05130:  CALL   50C6
....................    unsigned int32 write_address = 0x00000000;
05134:  MOVLB  1
05136:  CLRF   x92
05138:  CLRF   x91
0513A:  CLRF   x90
0513C:  CLRF   x8F
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
0513E:  MOVF   x8D,W
05140:  MOVWF  FE9
05142:  MOVF   x8E,W
05144:  MOVWF  FEA
05146:  MOVFF  FEF,193
0514A:  MOVFF  193,1E0
0514E:  SETF   xE1
05150:  MOVLB  0
05152:  CALL   387E
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
05156:  MOVLW  0C
05158:  MOVWF  FF6
0515A:  MOVLW  17
0515C:  MOVWF  FF7
0515E:  MOVLW  00
05160:  MOVWF  FF8
05162:  CALL   1BDA
05166:  GOTO   9182 (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
0516A:  MOVLW  30
0516C:  MOVWF  FF6
0516E:  MOVLW  17
05170:  MOVWF  FF7
05172:  MOVLW  00
05174:  MOVWF  FF8
05176:  CALL   1BDA
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
0517A:  MOVLB  1
0517C:  MOVF   x8D,W
0517E:  MOVWF  FE9
05180:  MOVF   x8E,W
05182:  MOVWF  FEA
05184:  MOVFF  FEF,1DF
05188:  MOVFF  1DF,1E0
0518C:  CLRF   xE1
0518E:  MOVLB  0
05190:  CALL   387E
....................    FLASH_PARAM flash_param = {0};
05194:  MOVLB  1
05196:  CLRF   x8F
05198:  CLRF   x90
0519A:  CLRF   x91
0519C:  CLRF   x92
0519E:  CLRF   x93
051A0:  CLRF   x94
051A2:  CLRF   x95
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
051A4:  MOVF   x8D,W
051A6:  MOVWF  FE9
051A8:  MOVF   x8E,W
051AA:  MOVWF  FEA
051AC:  MOVFF  FEF,18F
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
051B0:  MOVLW  01
051B2:  ADDWF  x8D,W
051B4:  MOVWF  FE9
051B6:  MOVLW  00
051B8:  ADDWFC x8E,W
051BA:  MOVWF  FEA
051BC:  MOVF   FEF,W
051BE:  CLRF   xE2
051C0:  CLRF   xE1
051C2:  CLRF   xE0
051C4:  MOVWF  xDF
051C6:  MOVFF  1DF,1E2
051CA:  CLRF   xDF
051CC:  CLRF   xE0
051CE:  CLRF   xE1
051D0:  MOVLW  02
051D2:  ADDWF  x8D,W
051D4:  MOVWF  FE9
051D6:  MOVLW  00
051D8:  ADDWFC x8E,W
051DA:  MOVWF  FEA
051DC:  MOVF   FEF,W
051DE:  CLRF   xE7
051E0:  CLRF   xE6
051E2:  CLRF   xE5
051E4:  MOVWF  xE4
051E6:  MOVFF  1E5,03
051EA:  MOVFF  1E4,02
051EE:  CLRF   00
051F0:  CLRF   01
051F2:  MOVF   00,W
051F4:  IORWF  xDF,F
051F6:  MOVF   01,W
051F8:  IORWF  xE0,F
051FA:  MOVF   02,W
051FC:  IORWF  xE1,F
051FE:  MOVF   03,W
05200:  IORWF  xE2,F
05202:  MOVLW  03
05204:  ADDWF  x8D,W
05206:  MOVWF  FE9
05208:  MOVLW  00
0520A:  ADDWFC x8E,W
0520C:  MOVWF  FEA
0520E:  MOVF   FEF,W
05210:  CLRF   xE7
05212:  CLRF   xE6
05214:  CLRF   xE5
05216:  MOVWF  xE4
05218:  MOVFF  1E6,03
0521C:  MOVFF  1E5,02
05220:  MOVFF  1E4,01
05224:  CLRF   00
05226:  MOVF   00,W
05228:  IORWF  xDF,F
0522A:  MOVF   01,W
0522C:  IORWF  xE0,F
0522E:  MOVF   02,W
05230:  IORWF  xE1,F
05232:  MOVF   03,W
05234:  IORWF  xE2,F
05236:  MOVLW  04
05238:  ADDWF  x8D,W
0523A:  MOVWF  FE9
0523C:  MOVLW  00
0523E:  ADDWFC x8E,W
05240:  MOVWF  FEA
05242:  MOVF   FEF,W
05244:  MOVWF  00
05246:  CLRF   01
05248:  CLRF   02
0524A:  CLRF   03
0524C:  MOVF   00,W
0524E:  IORWF  xDF,W
05250:  MOVWF  x92
05252:  MOVF   01,W
05254:  IORWF  xE0,W
05256:  MOVWF  x93
05258:  MOVF   02,W
0525A:  IORWF  xE1,W
0525C:  MOVWF  x94
0525E:  MOVF   03,W
05260:  IORWF  xE2,W
05262:  MOVWF  x95
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
05264:  MOVLW  07
05266:  ADDWF  x8D,W
05268:  MOVWF  FE9
0526A:  MOVLW  00
0526C:  ADDWFC x8E,W
0526E:  MOVWF  FEA
05270:  MOVF   FEF,W
05272:  CLRF   xE0
05274:  MOVWF  xDF
05276:  MOVFF  1DF,1E0
0527A:  CLRF   xDF
0527C:  MOVLW  08
0527E:  ADDWF  x8D,W
05280:  MOVWF  FE9
05282:  MOVLW  00
05284:  ADDWFC x8E,W
05286:  MOVWF  FEA
05288:  MOVF   FEF,W
0528A:  CLRF   03
0528C:  IORWF  xDF,W
0528E:  MOVWF  x90
05290:  MOVF   03,W
05292:  IORWF  xE0,W
05294:  MOVWF  x91
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
05296:  MOVLW  44
05298:  MOVWF  FF6
0529A:  MOVLW  17
0529C:  MOVWF  FF7
0529E:  MOVLW  00
052A0:  MOVWF  FF8
052A2:  MOVLW  0C
052A4:  MOVLB  9
052A6:  MOVWF  xC6
052A8:  MOVLB  0
052AA:  CALL   1C0A
052AE:  MOVFF  18F,264
052B2:  MOVLW  37
052B4:  MOVLB  2
052B6:  MOVWF  x65
052B8:  MOVLB  0
052BA:  CALL   1E5E
052BE:  MOVLW  0D
052C0:  MOVLB  A
052C2:  MOVWF  xAD
052C4:  MOVLB  0
052C6:  CALL   1B88
052CA:  MOVLW  0A
052CC:  MOVLB  A
052CE:  MOVWF  xAD
052D0:  MOVLB  0
052D2:  CALL   1B88
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
052D6:  MOVLW  58
052D8:  MOVWF  FF6
052DA:  MOVLW  17
052DC:  MOVWF  FF7
052DE:  MOVLW  00
052E0:  MOVWF  FF8
052E2:  MOVLW  0E
052E4:  MOVLB  9
052E6:  MOVWF  xC6
052E8:  MOVLB  0
052EA:  CALL   1C0A
052EE:  MOVFF  195,264
052F2:  MOVLW  37
052F4:  MOVLB  2
052F6:  MOVWF  x65
052F8:  MOVLB  0
052FA:  CALL   1E5E
052FE:  MOVFF  194,264
05302:  MOVLW  37
05304:  MOVLB  2
05306:  MOVWF  x65
05308:  MOVLB  0
0530A:  CALL   1E5E
0530E:  MOVFF  193,264
05312:  MOVLW  37
05314:  MOVLB  2
05316:  MOVWF  x65
05318:  MOVLB  0
0531A:  CALL   1E5E
0531E:  MOVFF  192,264
05322:  MOVLW  37
05324:  MOVLB  2
05326:  MOVWF  x65
05328:  MOVLB  0
0532A:  CALL   1E5E
0532E:  MOVLW  0D
05330:  MOVLB  A
05332:  MOVWF  xAD
05334:  MOVLB  0
05336:  CALL   1B88
0533A:  MOVLW  0A
0533C:  MOVLB  A
0533E:  MOVWF  xAD
05340:  MOVLB  0
05342:  CALL   1B88
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
05346:  MOVLW  6E
05348:  MOVWF  FF6
0534A:  MOVLW  17
0534C:  MOVWF  FF7
0534E:  MOVLW  00
05350:  MOVWF  FF8
05352:  MOVLW  0E
05354:  MOVLB  9
05356:  MOVWF  xC6
05358:  MOVLB  0
0535A:  CALL   1C0A
0535E:  MOVFF  191,264
05362:  MOVLW  37
05364:  MOVLB  2
05366:  MOVWF  x65
05368:  MOVLB  0
0536A:  CALL   1E5E
0536E:  MOVFF  190,264
05372:  MOVLW  37
05374:  MOVLB  2
05376:  MOVWF  x65
05378:  MOVLB  0
0537A:  CALL   1E5E
0537E:  MOVLW  0D
05380:  MOVLB  A
05382:  MOVWF  xAD
05384:  MOVLB  0
05386:  CALL   1B88
0538A:  MOVLW  0A
0538C:  MOVLB  A
0538E:  MOVWF  xAD
05390:  MOVLB  0
05392:  CALL   1B88
....................    
....................    piclog_make(flash_param.id, 0x00);
05396:  MOVFF  18F,1E0
0539A:  MOVLB  1
0539C:  CLRF   xE1
0539E:  MOVLB  0
053A0:  CALL   387E
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
053A4:  MOVLB  1
053A6:  CLRF   x96
053A8:  CLRF   x97
053AA:  CLRF   x98
053AC:  CLRF   x99
053AE:  CLRF   x9A
053B0:  CLRF   x9B
053B2:  CLRF   x9C
053B4:  CLRF   x9D
053B6:  CLRF   x9E
053B8:  CLRF   x9F
053BA:  CLRF   xA0
053BC:  CLRF   xA1
053BE:  CLRF   xA2
053C0:  CLRF   xA3
053C2:  CLRF   xA4
053C4:  CLRF   xA5
053C6:  CLRF   xA6
053C8:  CLRF   xA7
053CA:  CLRF   xA8
053CC:  CLRF   xA9
053CE:  CLRF   xAA
053D0:  CLRF   xAB
053D2:  CLRF   xAC
053D4:  CLRF   xAD
053D6:  CLRF   xAE
053D8:  CLRF   xAF
053DA:  CLRF   xB0
053DC:  CLRF   xB1
053DE:  CLRF   xB2
053E0:  CLRF   xB3
053E2:  CLRF   xB4
053E4:  CLRF   xB5
053E6:  CLRF   xB6
053E8:  CLRF   xB7
053EA:  CLRF   xB8
053EC:  CLRF   xB9
053EE:  CLRF   xBA
053F0:  CLRF   xBB
053F2:  CLRF   xBC
053F4:  CLRF   xBD
053F6:  CLRF   xBE
053F8:  CLRF   xBF
053FA:  CLRF   xC0
053FC:  CLRF   xC1
053FE:  CLRF   xC2
05400:  CLRF   xC3
05402:  CLRF   xC4
05404:  CLRF   xC5
05406:  CLRF   xC6
05408:  CLRF   xC7
0540A:  CLRF   xC8
0540C:  CLRF   xC9
0540E:  CLRF   xCA
05410:  CLRF   xCB
05412:  CLRF   xCC
05414:  CLRF   xCD
05416:  CLRF   xCE
05418:  CLRF   xCF
0541A:  CLRF   xD0
0541C:  CLRF   xD1
0541E:  CLRF   xD2
05420:  CLRF   xD3
05422:  CLRF   xD4
05424:  CLRF   xD5
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
05426:  MOVLW  84
05428:  MOVWF  FF6
0542A:  MOVLW  17
0542C:  MOVWF  FF7
0542E:  MOVLW  00
05430:  MOVWF  FF8
05432:  MOVLB  0
05434:  CALL   1BDA
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
05438:  MOVFF  111,263
0543C:  MOVFF  110,262
05440:  MOVFF  10F,261
05444:  MOVFF  10E,260
05448:  CALL   26F4
0544C:  MOVF   01,F
0544E:  BTFSS  FD8.2
05450:  GOTO   5464
....................       fprintf(PC, "Mission Flash is not connected\r\n");
05454:  MOVLW  90
05456:  MOVWF  FF6
05458:  MOVLW  17
0545A:  MOVWF  FF7
0545C:  MOVLW  00
0545E:  MOVWF  FF8
05460:  CALL   1BDA
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
05464:  MOVLB  1
05466:  CLRF   xDD
05468:  CLRF   xDC
0546A:  CLRF   xDB
0546C:  CLRF   xDA
0546E:  MOVLB  0
05470:  MOVLB  1
05472:  MOVF   xDD,F
05474:  BTFSC  FD8.2
05476:  BRA    547E
05478:  MOVLB  0
0547A:  GOTO   55CC
0547E:  MOVLB  0
05480:  MOVLB  1
05482:  MOVF   xDC,F
05484:  BTFSC  FD8.2
05486:  BRA    548E
05488:  MOVLB  0
0548A:  GOTO   55CC
0548E:  MOVLB  0
05490:  MOVLB  1
05492:  MOVF   xDB,W
05494:  SUBWF  x91,W
05496:  BTFSC  FD8.0
05498:  BRA    54A0
0549A:  MOVLB  0
0549C:  GOTO   55CC
054A0:  MOVLB  0
054A2:  BTFSS  FD8.2
054A4:  GOTO   54BA
054A8:  MOVLB  1
054AA:  MOVF   x90,W
054AC:  SUBWF  xDA,W
054AE:  BTFSS  FD8.0
054B0:  BRA    54B8
054B2:  MOVLB  0
054B4:  GOTO   55CC
054B8:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
054BA:  MOVLB  1
054BC:  RLCF   xDA,W
054BE:  MOVWF  00
054C0:  RLCF   xDB,W
054C2:  MOVWF  01
054C4:  RLCF   xDC,W
054C6:  MOVWF  02
054C8:  RLCF   xDD,W
054CA:  MOVWF  03
054CC:  RLCF   00,F
054CE:  RLCF   01,F
054D0:  RLCF   02,F
054D2:  RLCF   03,F
054D4:  RLCF   00,F
054D6:  RLCF   01,F
054D8:  RLCF   02,F
054DA:  RLCF   03,F
054DC:  RLCF   00,F
054DE:  RLCF   01,F
054E0:  RLCF   02,F
054E2:  RLCF   03,F
054E4:  RLCF   00,F
054E6:  RLCF   01,F
054E8:  RLCF   02,F
054EA:  RLCF   03,F
054EC:  RLCF   00,F
054EE:  RLCF   01,F
054F0:  RLCF   02,F
054F2:  RLCF   03,F
054F4:  MOVLW  C0
054F6:  ANDWF  00,F
054F8:  MOVF   00,W
054FA:  ADDWF  x92,W
054FC:  MOVWF  xD6
054FE:  MOVF   01,W
05500:  ADDWFC x93,W
05502:  MOVWF  xD7
05504:  MOVF   02,W
05506:  ADDWFC x94,W
05508:  MOVWF  xD8
0550A:  MOVF   03,W
0550C:  ADDWFC x95,W
0550E:  MOVWF  xD9
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
05510:  MOVFF  111,2E5
05514:  MOVFF  110,2E4
05518:  MOVFF  10F,2E3
0551C:  MOVFF  10E,2E2
05520:  MOVFF  1D9,2E9
05524:  MOVFF  1D8,2E8
05528:  MOVFF  1D7,2E7
0552C:  MOVFF  1D6,2E6
05530:  MOVLW  01
05532:  MOVLB  2
05534:  MOVWF  xEB
05536:  MOVLW  96
05538:  MOVWF  xEA
0553A:  CLRF   xEF
0553C:  CLRF   xEE
0553E:  CLRF   xED
05540:  MOVLW  40
05542:  MOVWF  xEC
05544:  MOVLB  0
05546:  CALL   27E0
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
0554A:  MOVLB  1
0554C:  CLRF   xDE
0554E:  MOVLB  0
05550:  MOVLB  1
05552:  MOVF   xDE,W
05554:  SUBLW  3F
05556:  BTFSC  FD8.0
05558:  BRA    5560
0555A:  MOVLB  0
0555C:  GOTO   559C
05560:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
05562:  CLRF   03
05564:  MOVLB  1
05566:  MOVF   xDE,W
05568:  ADDLW  96
0556A:  MOVWF  FE9
0556C:  MOVLW  01
0556E:  ADDWFC 03,W
05570:  MOVWF  FEA
05572:  MOVFF  FEF,1DF
05576:  MOVFF  1DF,264
0557A:  MOVLW  37
0557C:  MOVLB  2
0557E:  MOVWF  x65
05580:  MOVLB  0
05582:  CALL   1E5E
05586:  MOVLW  20
05588:  MOVLB  A
0558A:  MOVWF  xAD
0558C:  MOVLB  0
0558E:  CALL   1B88
05592:  MOVLB  1
05594:  INCF   xDE,F
05596:  MOVLB  0
05598:  GOTO   5550
....................       }
....................       fprintf(PC,"\r\n");
0559C:  MOVLW  0D
0559E:  MOVLB  A
055A0:  MOVWF  xAD
055A2:  MOVLB  0
055A4:  CALL   1B88
055A8:  MOVLW  0A
055AA:  MOVLB  A
055AC:  MOVWF  xAD
055AE:  MOVLB  0
055B0:  CALL   1B88
055B4:  MOVLW  01
055B6:  MOVLB  1
055B8:  ADDWF  xDA,F
055BA:  BTFSC  FD8.0
055BC:  INCF   xDB,F
055BE:  BTFSC  FD8.2
055C0:  INCF   xDC,F
055C2:  BTFSC  FD8.2
055C4:  INCF   xDD,F
055C6:  MOVLB  0
055C8:  GOTO   5470
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
055CC:  MOVFF  18F,1E0
055D0:  MOVLB  1
055D2:  SETF   xE1
055D4:  MOVLB  0
055D6:  CALL   387E
....................    fprintf(PC, "End Flash Read\r\n");
055DA:  MOVLW  B2
055DC:  MOVWF  FF6
055DE:  MOVLW  17
055E0:  MOVWF  FF7
055E2:  MOVLW  00
055E4:  MOVWF  FF8
055E6:  CALL   1BDA
055EA:  GOTO   9192 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
055EE:  MOVLW  C4
055F0:  MOVWF  FF6
055F2:  MOVLW  17
055F4:  MOVWF  FF7
055F6:  MOVLW  00
055F8:  MOVWF  FF8
055FA:  CALL   1BDA
....................    flash_setting(mis_fm);
055FE:  MOVFF  111,29B
05602:  MOVFF  110,29A
05606:  MOVFF  10F,299
0560A:  MOVFF  10E,298
0560E:  CALL   50C6
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
05612:  MOVLB  1
05614:  CLRF   x92
05616:  CLRF   x91
05618:  CLRF   x90
0561A:  CLRF   x8F
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
0561C:  MOVFF  111,2E5
05620:  MOVFF  110,2E4
05624:  MOVFF  10F,2E3
05628:  MOVFF  10E,2E2
0562C:  MOVFF  192,2E9
05630:  MOVFF  191,2E8
05634:  MOVFF  190,2E7
05638:  MOVFF  18F,2E6
0563C:  MOVLW  01
0563E:  MOVLB  2
05640:  MOVWF  xEB
05642:  MOVLW  93
05644:  MOVWF  xEA
05646:  CLRF   xEF
05648:  CLRF   xEE
0564A:  CLRF   xED
0564C:  MOVLW  04
0564E:  MOVWF  xEC
05650:  MOVLB  0
05652:  CALL   27E0
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
05656:  MOVLW  E0
05658:  MOVWF  FF6
0565A:  MOVLW  17
0565C:  MOVWF  FF7
0565E:  MOVLW  00
05660:  MOVWF  FF8
05662:  MOVLW  0B
05664:  MOVLB  9
05666:  MOVWF  xC6
05668:  MOVLB  0
0566A:  CALL   1C0A
0566E:  MOVFF  193,264
05672:  MOVLW  37
05674:  MOVLB  2
05676:  MOVWF  x65
05678:  MOVLB  0
0567A:  CALL   1E5E
0567E:  MOVLW  20
05680:  MOVLB  A
05682:  MOVWF  xAD
05684:  MOVLB  0
05686:  CALL   1B88
0568A:  MOVFF  194,264
0568E:  MOVLW  37
05690:  MOVLB  2
05692:  MOVWF  x65
05694:  MOVLB  0
05696:  CALL   1E5E
0569A:  MOVLW  20
0569C:  MOVLB  A
0569E:  MOVWF  xAD
056A0:  MOVLB  0
056A2:  CALL   1B88
056A6:  MOVFF  195,264
056AA:  MOVLW  37
056AC:  MOVLB  2
056AE:  MOVWF  x65
056B0:  MOVLB  0
056B2:  CALL   1E5E
056B6:  MOVLW  20
056B8:  MOVLB  A
056BA:  MOVWF  xAD
056BC:  MOVLB  0
056BE:  CALL   1B88
056C2:  MOVFF  196,264
056C6:  MOVLW  37
056C8:  MOVLB  2
056CA:  MOVWF  x65
056CC:  MOVLB  0
056CE:  CALL   1E5E
056D2:  MOVLW  0D
056D4:  MOVLB  A
056D6:  MOVWF  xAD
056D8:  MOVLB  0
056DA:  CALL   1B88
056DE:  MOVLW  0A
056E0:  MOVLB  A
056E2:  MOVWF  xAD
056E4:  MOVLB  0
056E6:  CALL   1B88
....................    fprintf(PC, "End Flash Read Address\r\n");
056EA:  MOVLW  02
056EC:  MOVWF  FF6
056EE:  MOVLW  18
056F0:  MOVWF  FF7
056F2:  MOVLW  00
056F4:  MOVWF  FF8
056F6:  CALL   1BDA
056FA:  GOTO   91A2 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
058E6:  MOVLW  1C
058E8:  MOVWF  FF6
058EA:  MOVLW  18
058EC:  MOVWF  FF7
058EE:  MOVLW  00
058F0:  MOVWF  FF8
058F2:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
058F6:  MOVLB  1
058F8:  MOVF   x8D,W
058FA:  MOVWF  FE9
058FC:  MOVF   x8E,W
058FE:  MOVWF  FEA
05900:  MOVFF  FEF,18F
05904:  MOVFF  18F,1E0
05908:  CLRF   xE1
0590A:  MOVLB  0
0590C:  CALL   387E
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
05910:  MOVFF  18E,190
05914:  MOVFF  18D,18F
05918:  CALL   442A
....................    mode_misf_address_reset(parameter); // Reset the address area
0591C:  MOVFF  18E,190
05920:  MOVFF  18D,18F
05924:  GOTO   56FE
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
05928:  MOVLW  3A
0592A:  MOVWF  FF6
0592C:  MOVLW  18
0592E:  MOVWF  FF7
05930:  MOVLW  00
05932:  MOVWF  FF8
05934:  CALL   1BDA
05938:  GOTO   91B2 (RETURN)
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
0593C:  MOVLW  56
0593E:  MOVWF  FF6
05940:  MOVLW  18
05942:  MOVWF  FF7
05944:  MOVLW  00
05946:  MOVWF  FF8
05948:  CALL   1BDA
....................    flash_setting(mis_fm);
0594C:  MOVFF  111,29B
05950:  MOVFF  110,29A
05954:  MOVFF  10F,299
05958:  MOVFF  10E,298
0595C:  CALL   50C6
....................    flash_setting(smf);
05960:  MOVFF  115,29B
05964:  MOVFF  114,29A
05968:  MOVFF  113,299
0596C:  MOVFF  112,298
05970:  CALL   50C6
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
05974:  MOVLB  1
05976:  MOVF   x8D,W
05978:  MOVWF  FE9
0597A:  MOVF   x8E,W
0597C:  MOVWF  FEA
0597E:  MOVFF  FEF,18F
05982:  CLRF   x93
05984:  CLRF   x92
05986:  CLRF   x91
05988:  CLRF   x90
0598A:  CLRF   x97
0598C:  CLRF   x96
0598E:  MOVLW  10
05990:  MOVWF  x95
05992:  CLRF   x94
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
05994:  MOVFF  111,2E5
05998:  MOVFF  110,2E4
0599C:  MOVFF  10F,2E3
059A0:  MOVFF  10E,2E2
059A4:  MOVFF  193,2E9
059A8:  MOVFF  192,2E8
059AC:  MOVFF  191,2E7
059B0:  MOVFF  190,2E6
059B4:  MOVLW  01
059B6:  MOVLB  2
059B8:  MOVWF  xEB
059BA:  MOVLW  98
059BC:  MOVWF  xEA
059BE:  CLRF   xEF
059C0:  CLRF   xEE
059C2:  MOVLW  01
059C4:  MOVWF  xED
059C6:  CLRF   xEC
059C8:  MOVLB  0
059CA:  CALL   27E0
....................    write_data_bytes(smf, dest_address, read_data, 256);
059CE:  MOVFF  115,A59
059D2:  MOVFF  114,A58
059D6:  MOVFF  113,A57
059DA:  MOVFF  112,A56
059DE:  MOVFF  197,A5D
059E2:  MOVFF  196,A5C
059E6:  MOVFF  195,A5B
059EA:  MOVFF  194,A5A
059EE:  MOVLW  01
059F0:  MOVLB  A
059F2:  MOVWF  x5F
059F4:  MOVLW  98
059F6:  MOVWF  x5E
059F8:  MOVLW  01
059FA:  MOVWF  x61
059FC:  CLRF   x60
059FE:  MOVLB  0
05A00:  CALL   34FA
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
05A04:  MOVLW  6E
05A06:  MOVWF  FF6
05A08:  MOVLW  18
05A0A:  MOVWF  FF7
05A0C:  MOVLW  00
05A0E:  MOVWF  FF8
05A10:  CALL   1BDA
05A14:  GOTO   91C2 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
05A18:  MOVLW  84
05A1A:  MOVWF  FF6
05A1C:  MOVLW  18
05A1E:  MOVWF  FF7
05A20:  MOVLW  00
05A22:  MOVWF  FF8
05A24:  CALL   1BDA
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
05A28:  MOVFF  115,2E5
05A2C:  MOVFF  114,2E4
05A30:  MOVFF  113,2E3
05A34:  MOVFF  112,2E2
05A38:  MOVLB  2
05A3A:  CLRF   xE9
05A3C:  CLRF   xE8
05A3E:  MOVLW  01
05A40:  MOVWF  xE7
05A42:  MOVLW  8F
05A44:  MOVWF  xE6
05A46:  MOVLW  01
05A48:  MOVWF  xEB
05A4A:  MOVLW  8F
05A4C:  MOVWF  xEA
05A4E:  CLRF   xEF
05A50:  CLRF   xEE
05A52:  CLRF   xED
05A54:  MOVLW  40
05A56:  MOVWF  xEC
05A58:  MOVLB  0
05A5A:  CALL   27E0
....................    fprintf(PC, "Read Data: ");
05A5E:  MOVLW  9C
05A60:  MOVWF  FF6
05A62:  MOVLW  18
05A64:  MOVWF  FF7
05A66:  MOVLW  00
05A68:  MOVWF  FF8
05A6A:  CALL   1BDA
....................    for (int i = 0; i < PACKET_SIZE; i++)
05A6E:  MOVLB  1
05A70:  CLRF   xCF
05A72:  MOVLB  0
05A74:  MOVLB  1
05A76:  MOVF   xCF,W
05A78:  SUBLW  3F
05A7A:  BTFSC  FD8.0
05A7C:  BRA    5A84
05A7E:  MOVLB  0
05A80:  GOTO   5AC0
05A84:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
05A86:  CLRF   03
05A88:  MOVLB  1
05A8A:  MOVF   xCF,W
05A8C:  ADDLW  8F
05A8E:  MOVWF  FE9
05A90:  MOVLW  01
05A92:  ADDWFC 03,W
05A94:  MOVWF  FEA
05A96:  MOVFF  FEF,1D0
05A9A:  MOVFF  1D0,264
05A9E:  MOVLW  37
05AA0:  MOVLB  2
05AA2:  MOVWF  x65
05AA4:  MOVLB  0
05AA6:  CALL   1E5E
05AAA:  MOVLW  20
05AAC:  MOVLB  A
05AAE:  MOVWF  xAD
05AB0:  MOVLB  0
05AB2:  CALL   1B88
05AB6:  MOVLB  1
05AB8:  INCF   xCF,F
05ABA:  MOVLB  0
05ABC:  GOTO   5A74
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
05AC0:  MOVLW  A8
05AC2:  MOVWF  FF6
05AC4:  MOVLW  18
05AC6:  MOVWF  FF7
05AC8:  MOVLW  00
05ACA:  MOVWF  FF8
05ACC:  CALL   1BDA
05AD0:  GOTO   91D2 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
05AD4:  MOVLW  C0
05AD6:  MOVWF  FF6
05AD8:  MOVLW  18
05ADA:  MOVWF  FF7
05ADC:  MOVLW  00
05ADE:  MOVWF  FF8
05AE0:  CALL   1BDA
....................    flash_setting(smf);
05AE4:  MOVFF  115,29B
05AE8:  MOVFF  114,29A
05AEC:  MOVFF  113,299
05AF0:  MOVFF  112,298
05AF4:  CALL   50C6
....................    unsigned int32 erase_address = 0x00000000; // Example address
05AF8:  MOVLB  1
05AFA:  CLRF   x92
05AFC:  CLRF   x91
05AFE:  CLRF   x90
05B00:  CLRF   x8F
....................    sector_erase(smf, erase_address); // Erase the sector
05B02:  MOVFF  115,A59
05B06:  MOVFF  114,A58
05B0A:  MOVFF  113,A57
05B0E:  MOVFF  112,A56
05B12:  MOVFF  192,A5D
05B16:  MOVFF  191,A5C
05B1A:  MOVFF  190,A5B
05B1E:  MOVFF  18F,A5A
05B22:  MOVLB  0
05B24:  CALL   40D2
....................    fprintf(PC, "End Flash SMF Erase\r\n");
05B28:  MOVLW  D8
05B2A:  MOVWF  FF6
05B2C:  MOVLW  18
05B2E:  MOVWF  FF7
05B30:  MOVLW  00
05B32:  MOVWF  FF8
05B34:  CALL   1BDA
05B38:  GOTO   91E2 (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
056FE:  MOVLW  EE
05700:  MOVWF  FF6
05702:  MOVLW  18
05704:  MOVWF  FF7
05706:  MOVLW  00
05708:  MOVWF  FF8
0570A:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_START); 
0570E:  MOVLB  1
05710:  MOVF   x8F,W
05712:  MOVWF  FE9
05714:  MOVF   x90,W
05716:  MOVWF  FEA
05718:  MOVFF  FEF,1D3
0571C:  MOVFF  1D3,1E0
05720:  CLRF   xE1
05722:  MOVLB  0
05724:  CALL   387E
....................    FlashData_t flash_data;
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
05728:  MOVLW  01
0572A:  MOVWF  FEA
0572C:  MOVLW  91
0572E:  MOVWF  FE9
05730:  CLRF   00
05732:  CLRF   02
05734:  MOVLW  40
05736:  MOVWF  01
05738:  CALL   27BC
....................    /*
....................    for (int i = 0; i < PACKET_SIZE; i++) {
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
....................    }
....................    */
....................    fprintf(PC, "\r\n");
0573C:  MOVLW  0D
0573E:  MOVLB  A
05740:  MOVWF  xAD
05742:  MOVLB  0
05744:  CALL   1B88
05748:  MOVLW  0A
0574A:  MOVLB  A
0574C:  MOVWF  xAD
0574E:  MOVLB  0
05750:  CALL   1B88
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
05754:  MOVLW  01
05756:  MOVLB  A
05758:  MOVWF  xAE
0575A:  MOVLW  91
0575C:  MOVWF  xAD
0575E:  MOVLW  3F
05760:  MOVWF  xAF
05762:  MOVLB  0
05764:  CALL   29F8
05768:  MOVFF  01,1D0
....................    for (int i = 0; i < PACKET_SIZE; i++) {
0576C:  MOVLB  1
0576E:  CLRF   xD1
05770:  MOVLB  0
05772:  MOVLB  1
05774:  MOVF   xD1,W
05776:  SUBLW  3F
05778:  BTFSC  FD8.0
0577A:  BRA    5782
0577C:  MOVLB  0
0577E:  GOTO   57BE
05782:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
05784:  CLRF   03
05786:  MOVLB  1
05788:  MOVF   xD1,W
0578A:  ADDLW  91
0578C:  MOVWF  FE9
0578E:  MOVLW  01
05790:  ADDWFC 03,W
05792:  MOVWF  FEA
05794:  MOVFF  FEF,1D3
05798:  MOVFF  1D3,264
0579C:  MOVLW  37
0579E:  MOVLB  2
057A0:  MOVWF  x65
057A2:  MOVLB  0
057A4:  CALL   1E5E
057A8:  MOVLW  20
057AA:  MOVLB  A
057AC:  MOVWF  xAD
057AE:  MOVLB  0
057B0:  CALL   1B88
057B4:  MOVLB  1
057B6:  INCF   xD1,F
057B8:  MOVLB  0
057BA:  GOTO   5772
....................    }
....................    fprintf(PC, "\r\n");
057BE:  MOVLW  0D
057C0:  MOVLB  A
057C2:  MOVWF  xAD
057C4:  MOVLB  0
057C6:  CALL   1B88
057CA:  MOVLW  0A
057CC:  MOVLB  A
057CE:  MOVWF  xAD
057D0:  MOVLB  0
057D2:  CALL   1B88
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
057D6:  MOVFF  111,A59
057DA:  MOVFF  110,A58
057DE:  MOVFF  10F,A57
057E2:  MOVFF  10E,A56
057E6:  MOVLB  A
057E8:  CLRF   x5D
057EA:  CLRF   x5C
057EC:  CLRF   x5B
057EE:  CLRF   x5A
057F0:  MOVLW  01
057F2:  MOVWF  x5F
057F4:  MOVLW  91
057F6:  MOVWF  x5E
057F8:  CLRF   x61
057FA:  MOVLW  40
057FC:  MOVWF  x60
057FE:  MOVLB  0
05800:  CALL   34FA
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
05804:  MOVLW  01
05806:  MOVWF  FEA
05808:  MOVLW  91
0580A:  MOVWF  FE9
0580C:  CLRF   00
0580E:  CLRF   02
05810:  MOVLW  40
05812:  MOVWF  01
05814:  CALL   27BC
....................    read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
05818:  MOVFF  111,2E5
0581C:  MOVFF  110,2E4
05820:  MOVFF  10F,2E3
05824:  MOVFF  10E,2E2
05828:  MOVLB  2
0582A:  CLRF   xE9
0582C:  CLRF   xE8
0582E:  CLRF   xE7
05830:  CLRF   xE6
05832:  MOVLW  01
05834:  MOVWF  xEB
05836:  MOVLW  91
05838:  MOVWF  xEA
0583A:  CLRF   xEF
0583C:  CLRF   xEE
0583E:  CLRF   xED
05840:  MOVLW  40
05842:  MOVWF  xEC
05844:  MOVLB  0
05846:  CALL   27E0
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
0584A:  MOVLW  01
0584C:  MOVLB  A
0584E:  MOVWF  xAE
05850:  MOVLW  91
05852:  MOVWF  xAD
05854:  MOVLW  3F
05856:  MOVWF  xAF
05858:  MOVLB  0
0585A:  CALL   29F8
0585E:  MOVFF  01,1D0
....................    for (int i = 0; i < PACKET_SIZE; i++) {
05862:  MOVLB  1
05864:  CLRF   xD2
05866:  MOVLB  0
05868:  MOVLB  1
0586A:  MOVF   xD2,W
0586C:  SUBLW  3F
0586E:  BTFSC  FD8.0
05870:  BRA    5878
05872:  MOVLB  0
05874:  GOTO   58B4
05878:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
0587A:  CLRF   03
0587C:  MOVLB  1
0587E:  MOVF   xD2,W
05880:  ADDLW  91
05882:  MOVWF  FE9
05884:  MOVLW  01
05886:  ADDWFC 03,W
05888:  MOVWF  FEA
0588A:  MOVFF  FEF,1D3
0588E:  MOVFF  1D3,264
05892:  MOVLW  37
05894:  MOVLB  2
05896:  MOVWF  x65
05898:  MOVLB  0
0589A:  CALL   1E5E
0589E:  MOVLW  20
058A0:  MOVLB  A
058A2:  MOVWF  xAD
058A4:  MOVLB  0
058A6:  CALL   1B88
058AA:  MOVLB  1
058AC:  INCF   xD2,F
058AE:  MOVLB  0
058B0:  GOTO   5868
....................    }
....................    misf_init(); // Update the address area after writing
058B4:  CALL   2FF8
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
058B8:  MOVLB  1
058BA:  MOVF   x8F,W
058BC:  MOVWF  FE9
058BE:  MOVF   x90,W
058C0:  MOVWF  FEA
058C2:  MOVFF  FEF,1D3
058C6:  MOVFF  1D3,1E0
058CA:  SETF   xE1
058CC:  MOVLB  0
058CE:  CALL   387E
....................    fprintf(PC, "End Flash Address Reset\r\n");
058D2:  MOVLW  0A
058D4:  MOVWF  FF6
058D6:  MOVLW  19
058D8:  MOVWF  FF7
058DA:  MOVLW  00
058DC:  MOVWF  FF8
058DE:  CALL   1BDA
058E2:  GOTO   5928 (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
05D82:  MOVLW  01
05D84:  MOVLB  1
05D86:  ADDWF  x8D,W
05D88:  MOVWF  FE9
05D8A:  MOVLW  00
05D8C:  ADDWFC x8E,W
05D8E:  MOVWF  FEA
05D90:  MOVF   FEF,W
05D92:  CLRF   xDF
05D94:  CLRF   xDE
05D96:  CLRF   xDD
05D98:  MOVWF  xDC
05D9A:  MOVFF  1DC,1DF
05D9E:  CLRF   xDC
05DA0:  CLRF   xDD
05DA2:  CLRF   xDE
05DA4:  MOVLW  02
05DA6:  ADDWF  x8D,W
05DA8:  MOVWF  FE9
05DAA:  MOVLW  00
05DAC:  ADDWFC x8E,W
05DAE:  MOVWF  FEA
05DB0:  MOVF   FEF,W
05DB2:  CLRF   xE4
05DB4:  CLRF   xE3
05DB6:  CLRF   xE2
05DB8:  MOVWF  xE1
05DBA:  MOVFF  1E2,03
05DBE:  MOVFF  1E1,02
05DC2:  CLRF   00
05DC4:  CLRF   01
05DC6:  MOVF   00,W
05DC8:  IORWF  xDC,F
05DCA:  MOVF   01,W
05DCC:  IORWF  xDD,F
05DCE:  MOVF   02,W
05DD0:  IORWF  xDE,F
05DD2:  MOVF   03,W
05DD4:  IORWF  xDF,F
05DD6:  MOVLW  03
05DD8:  ADDWF  x8D,W
05DDA:  MOVWF  FE9
05DDC:  MOVLW  00
05DDE:  ADDWFC x8E,W
05DE0:  MOVWF  FEA
05DE2:  MOVF   FEF,W
05DE4:  CLRF   xE4
05DE6:  CLRF   xE3
05DE8:  CLRF   xE2
05DEA:  MOVWF  xE1
05DEC:  MOVFF  1E3,03
05DF0:  MOVFF  1E2,02
05DF4:  MOVFF  1E1,01
05DF8:  CLRF   00
05DFA:  MOVF   00,W
05DFC:  IORWF  xDC,F
05DFE:  MOVF   01,W
05E00:  IORWF  xDD,F
05E02:  MOVF   02,W
05E04:  IORWF  xDE,F
05E06:  MOVF   03,W
05E08:  IORWF  xDF,F
05E0A:  MOVLW  04
05E0C:  ADDWF  x8D,W
05E0E:  MOVWF  FE9
05E10:  MOVLW  00
05E12:  ADDWFC x8E,W
05E14:  MOVWF  FEA
05E16:  MOVF   FEF,W
05E18:  MOVWF  00
05E1A:  CLRF   01
05E1C:  CLRF   02
05E1E:  CLRF   03
05E20:  MOVF   00,W
05E22:  IORWF  xDC,W
05E24:  MOVWF  x8F
05E26:  MOVF   01,W
05E28:  IORWF  xDD,W
05E2A:  MOVWF  x90
05E2C:  MOVF   02,W
05E2E:  IORWF  xDE,W
05E30:  MOVWF  x91
05E32:  MOVF   03,W
05E34:  IORWF  xDF,W
05E36:  MOVWF  x92
05E38:  MOVLW  07
05E3A:  ADDWF  x8D,W
05E3C:  MOVWF  FE9
05E3E:  MOVLW  00
05E40:  ADDWFC x8E,W
05E42:  MOVWF  FEA
05E44:  MOVF   FEF,W
05E46:  CLRF   xDD
05E48:  MOVWF  xDC
05E4A:  MOVFF  1DC,1DD
05E4E:  CLRF   xDC
05E50:  MOVLW  08
05E52:  ADDWF  x8D,W
05E54:  MOVWF  FE9
05E56:  MOVLW  00
05E58:  ADDWFC x8E,W
05E5A:  MOVWF  FEA
05E5C:  MOVF   FEF,W
05E5E:  CLRF   03
05E60:  IORWF  xDC,W
05E62:  MOVWF  x93
05E64:  MOVF   03,W
05E66:  IORWF  xDD,W
05E68:  MOVWF  x94
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
05E6A:  CLRF   x95
05E6C:  CLRF   x96
05E6E:  CLRF   x97
05E70:  CLRF   x98
05E72:  CLRF   x99
05E74:  CLRF   x9A
05E76:  CLRF   x9B
05E78:  CLRF   x9C
05E7A:  CLRF   x9D
05E7C:  CLRF   x9E
05E7E:  CLRF   x9F
05E80:  CLRF   xA0
05E82:  CLRF   xA1
05E84:  CLRF   xA2
05E86:  CLRF   xA3
05E88:  CLRF   xA4
05E8A:  CLRF   xA5
05E8C:  CLRF   xA6
05E8E:  CLRF   xA7
05E90:  CLRF   xA8
05E92:  CLRF   xA9
05E94:  CLRF   xAA
05E96:  CLRF   xAB
05E98:  CLRF   xAC
05E9A:  CLRF   xAD
05E9C:  CLRF   xAE
05E9E:  CLRF   xAF
05EA0:  CLRF   xB0
05EA2:  CLRF   xB1
05EA4:  CLRF   xB2
05EA6:  CLRF   xB3
05EA8:  CLRF   xB4
05EAA:  CLRF   xB5
05EAC:  CLRF   xB6
05EAE:  CLRF   xB7
05EB0:  CLRF   xB8
05EB2:  CLRF   xB9
05EB4:  CLRF   xBA
05EB6:  CLRF   xBB
05EB8:  CLRF   xBC
05EBA:  CLRF   xBD
05EBC:  CLRF   xBE
05EBE:  CLRF   xBF
05EC0:  CLRF   xC0
05EC2:  CLRF   xC1
05EC4:  CLRF   xC2
05EC6:  CLRF   xC3
05EC8:  CLRF   xC4
05ECA:  CLRF   xC5
05ECC:  CLRF   xC6
05ECE:  CLRF   xC7
05ED0:  CLRF   xC8
05ED2:  CLRF   xC9
05ED4:  CLRF   xCA
05ED6:  CLRF   xCB
05ED8:  CLRF   xCC
05EDA:  CLRF   xCD
05EDC:  CLRF   xCE
05EDE:  CLRF   xCF
05EE0:  CLRF   xD0
05EE2:  CLRF   xD1
05EE4:  CLRF   xD2
05EE6:  CLRF   xD3
05EE8:  CLRF   xD4
....................    if(!is_connect(smf)) {
05EEA:  MOVFF  115,263
05EEE:  MOVFF  114,262
05EF2:  MOVFF  113,261
05EF6:  MOVFF  112,260
05EFA:  MOVLB  0
05EFC:  CALL   26F4
05F00:  MOVF   01,F
05F02:  BTFSS  FD8.2
05F04:  GOTO   5F1C
....................       printf("SMF is not connected\r\n");
05F08:  MOVLW  24
05F0A:  MOVWF  FF6
05F0C:  MOVLW  19
05F0E:  MOVWF  FF7
05F10:  MOVLW  00
05F12:  MOVWF  FF8
05F14:  CALL   1BDA
....................       return;
05F18:  GOTO   6160
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
05F1C:  MOVLW  3C
05F1E:  MOVWF  FF6
05F20:  MOVLW  19
05F22:  MOVWF  FF7
05F24:  MOVLW  00
05F26:  MOVWF  FF8
05F28:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05F2C:  MOVLB  1
05F2E:  MOVF   x8D,W
05F30:  MOVWF  FE9
05F32:  MOVF   x8E,W
05F34:  MOVWF  FEA
05F36:  MOVFF  FEF,1DC
05F3A:  MOVFF  1DC,1E0
05F3E:  CLRF   xE1
05F40:  MOVLB  0
05F42:  CALL   387E
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
05F46:  MOVLW  5A
05F48:  MOVWF  FF6
05F4A:  MOVLW  19
05F4C:  MOVWF  FF7
05F4E:  MOVLW  00
05F50:  MOVWF  FF8
05F52:  MOVLW  0E
05F54:  MOVLB  9
05F56:  MOVWF  xC6
05F58:  MOVLB  0
05F5A:  CALL   1C0A
05F5E:  MOVFF  192,264
05F62:  MOVLW  37
05F64:  MOVLB  2
05F66:  MOVWF  x65
05F68:  MOVLB  0
05F6A:  CALL   1E5E
05F6E:  MOVFF  191,264
05F72:  MOVLW  37
05F74:  MOVLB  2
05F76:  MOVWF  x65
05F78:  MOVLB  0
05F7A:  CALL   1E5E
05F7E:  MOVFF  190,264
05F82:  MOVLW  37
05F84:  MOVLB  2
05F86:  MOVWF  x65
05F88:  MOVLB  0
05F8A:  CALL   1E5E
05F8E:  MOVFF  18F,264
05F92:  MOVLW  37
05F94:  MOVLB  2
05F96:  MOVWF  x65
05F98:  MOVLB  0
05F9A:  CALL   1E5E
05F9E:  MOVLW  0D
05FA0:  MOVLB  A
05FA2:  MOVWF  xAD
05FA4:  MOVLB  0
05FA6:  CALL   1B88
05FAA:  MOVLW  0A
05FAC:  MOVLB  A
05FAE:  MOVWF  xAD
05FB0:  MOVLB  0
05FB2:  CALL   1B88
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
05FB6:  MOVLW  70
05FB8:  MOVWF  FF6
05FBA:  MOVLW  19
05FBC:  MOVWF  FF7
05FBE:  MOVLW  00
05FC0:  MOVWF  FF8
05FC2:  MOVLW  0E
05FC4:  MOVLB  9
05FC6:  MOVWF  xC6
05FC8:  MOVLB  0
05FCA:  CALL   1C0A
05FCE:  MOVFF  194,264
05FD2:  MOVLW  37
05FD4:  MOVLB  2
05FD6:  MOVWF  x65
05FD8:  MOVLB  0
05FDA:  CALL   1E5E
05FDE:  MOVFF  193,264
05FE2:  MOVLW  37
05FE4:  MOVLB  2
05FE6:  MOVWF  x65
05FE8:  MOVLB  0
05FEA:  CALL   1E5E
05FEE:  MOVLW  0D
05FF0:  MOVLB  A
05FF2:  MOVWF  xAD
05FF4:  MOVLB  0
05FF6:  CALL   1B88
05FFA:  MOVLW  0A
05FFC:  MOVLB  A
05FFE:  MOVWF  xAD
06000:  MOVLB  0
06002:  CALL   1B88
....................    printf("read data\r\n");
06006:  MOVLW  86
06008:  MOVWF  FF6
0600A:  MOVLW  19
0600C:  MOVWF  FF7
0600E:  MOVLW  00
06010:  MOVWF  FF8
06012:  CALL   1BDA
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
06016:  MOVLB  1
06018:  CLRF   xD6
0601A:  CLRF   xD5
0601C:  MOVLB  0
0601E:  MOVLB  1
06020:  MOVF   xD6,W
06022:  SUBWF  x94,W
06024:  BTFSC  FD8.0
06026:  BRA    602E
06028:  MOVLB  0
0602A:  GOTO   6136
0602E:  MOVLB  0
06030:  BTFSS  FD8.2
06032:  GOTO   6048
06036:  MOVLB  1
06038:  MOVF   x93,W
0603A:  SUBWF  xD5,W
0603C:  BTFSS  FD8.0
0603E:  BRA    6046
06040:  MOVLB  0
06042:  GOTO   6136
06046:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
06048:  MOVLB  1
0604A:  RLCF   xD5,W
0604C:  MOVWF  02
0604E:  RLCF   xD6,W
06050:  MOVWF  03
06052:  RLCF   02,F
06054:  RLCF   03,F
06056:  RLCF   02,F
06058:  RLCF   03,F
0605A:  RLCF   02,F
0605C:  RLCF   03,F
0605E:  RLCF   02,F
06060:  RLCF   03,F
06062:  RLCF   02,F
06064:  RLCF   03,F
06066:  MOVLW  C0
06068:  ANDWF  02,F
0606A:  MOVF   02,W
0606C:  ADDWF  x8F,W
0606E:  MOVWF  xD7
06070:  MOVF   03,W
06072:  ADDWFC x90,W
06074:  MOVWF  xD8
06076:  MOVLW  00
06078:  ADDWFC x91,W
0607A:  MOVWF  xD9
0607C:  MOVLW  00
0607E:  ADDWFC x92,W
06080:  MOVWF  xDA
06082:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
06084:  MOVFF  115,2E5
06088:  MOVFF  114,2E4
0608C:  MOVFF  113,2E3
06090:  MOVFF  112,2E2
06094:  MOVFF  1DA,2E9
06098:  MOVFF  1D9,2E8
0609C:  MOVFF  1D8,2E7
060A0:  MOVFF  1D7,2E6
060A4:  MOVLW  01
060A6:  MOVLB  2
060A8:  MOVWF  xEB
060AA:  MOVLW  95
060AC:  MOVWF  xEA
060AE:  CLRF   xEF
060B0:  CLRF   xEE
060B2:  CLRF   xED
060B4:  MOVLW  40
060B6:  MOVWF  xEC
060B8:  MOVLB  0
060BA:  CALL   27E0
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
060BE:  MOVLB  1
060C0:  CLRF   xDB
060C2:  MOVLB  0
060C4:  MOVLB  1
060C6:  MOVF   xDB,W
060C8:  SUBLW  3F
060CA:  BTFSC  FD8.0
060CC:  BRA    60D4
060CE:  MOVLB  0
060D0:  GOTO   6110
060D4:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
060D6:  CLRF   03
060D8:  MOVLB  1
060DA:  MOVF   xDB,W
060DC:  ADDLW  95
060DE:  MOVWF  FE9
060E0:  MOVLW  01
060E2:  ADDWFC 03,W
060E4:  MOVWF  FEA
060E6:  MOVFF  FEF,1DC
060EA:  MOVFF  1DC,264
060EE:  MOVLW  37
060F0:  MOVLB  2
060F2:  MOVWF  x65
060F4:  MOVLB  0
060F6:  CALL   1E5E
060FA:  MOVLW  20
060FC:  MOVLB  A
060FE:  MOVWF  xAD
06100:  MOVLB  0
06102:  CALL   1B88
06106:  MOVLB  1
06108:  INCF   xDB,F
0610A:  MOVLB  0
0610C:  GOTO   60C4
....................       }
....................       printf("\r\n");
06110:  MOVLW  0D
06112:  MOVLB  A
06114:  MOVWF  xAD
06116:  MOVLB  0
06118:  CALL   1B88
0611C:  MOVLW  0A
0611E:  MOVLB  A
06120:  MOVWF  xAD
06122:  MOVLB  0
06124:  CALL   1B88
06128:  MOVLB  1
0612A:  INCF   xD5,F
0612C:  BTFSC  FD8.2
0612E:  INCF   xD6,F
06130:  MOVLB  0
06132:  GOTO   601E
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
06136:  MOVLW  92
06138:  MOVWF  FF6
0613A:  MOVLW  19
0613C:  MOVWF  FF7
0613E:  MOVLW  00
06140:  MOVWF  FF8
06142:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06146:  MOVLB  1
06148:  MOVF   x8D,W
0614A:  MOVWF  FE9
0614C:  MOVF   x8E,W
0614E:  MOVWF  FEA
06150:  MOVFF  FEF,1DC
06154:  MOVFF  1DC,1E0
06158:  SETF   xE1
0615A:  MOVLB  0
0615C:  CALL   387E
06160:  GOTO   9202 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
06164:  MOVLW  B0
06166:  MOVWF  FF6
06168:  MOVLW  19
0616A:  MOVWF  FF7
0616C:  MOVLW  00
0616E:  MOVWF  FF8
06170:  CALL   1BDA
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
06174:  MOVLB  1
06176:  MOVF   x8D,W
06178:  MOVWF  FE9
0617A:  MOVF   x8E,W
0617C:  MOVWF  FEA
0617E:  MOVFF  FEF,18F
....................    piclog_make(cmd, 0x00); // Log the command execution
06182:  MOVFF  18F,1E0
06186:  CLRF   xE1
06188:  MOVLB  0
0618A:  CALL   387E
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
0618E:  MOVLW  06
06190:  MOVLB  1
06192:  MOVWF  x93
06194:  MOVLW  AA
06196:  MOVWF  x92
06198:  CLRF   x91
0619A:  CLRF   x90
0619C:  MOVLB  0
0619E:  MOVLB  1
061A0:  MOVF   x93,W
061A2:  SUBLW  06
061A4:  BTFSC  FD8.0
061A6:  BRA    61AE
061A8:  MOVLB  0
061AA:  GOTO   622C
061AE:  MOVLB  0
061B0:  BTFSS  FD8.2
061B2:  GOTO   61F8
061B6:  MOVLB  1
061B8:  MOVF   x92,W
061BA:  SUBLW  AA
061BC:  BTFSC  FD8.0
061BE:  BRA    61C6
061C0:  MOVLB  0
061C2:  GOTO   622C
061C6:  MOVLB  0
061C8:  BTFSS  FD8.2
061CA:  GOTO   61F8
061CE:  MOVLB  1
061D0:  MOVF   x91,W
061D2:  SUBLW  1F
061D4:  BTFSC  FD8.0
061D6:  BRA    61DE
061D8:  MOVLB  0
061DA:  GOTO   622C
061DE:  MOVLB  0
061E0:  BTFSS  FD8.2
061E2:  GOTO   61F8
061E6:  MOVLB  1
061E8:  MOVF   x90,W
061EA:  SUBLW  FE
061EC:  BTFSC  FD8.0
061EE:  BRA    61F6
061F0:  MOVLB  0
061F2:  GOTO   622C
061F6:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
061F8:  MOVFF  115,A59
061FC:  MOVFF  114,A58
06200:  MOVFF  113,A57
06204:  MOVFF  112,A56
06208:  MOVFF  193,A5D
0620C:  MOVFF  192,A5C
06210:  MOVFF  191,A5B
06214:  MOVFF  190,A5A
06218:  CALL   40D2
0621C:  MOVLW  01
0621E:  MOVLB  1
06220:  ADDWF  x92,F
06222:  MOVLW  00
06224:  ADDWFC x93,F
06226:  MOVLB  0
06228:  GOTO   619E
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0622C:  MOVFF  18F,1E0
06230:  MOVLB  1
06232:  SETF   xE1
06234:  MOVLB  0
06236:  CALL   387E
....................    printf("End SMF Erase All\r\n");
0623A:  MOVLW  C6
0623C:  MOVWF  FF6
0623E:  MOVLW  19
06240:  MOVWF  FF7
06242:  MOVLW  00
06244:  MOVWF  FF8
06246:  CALL   1BDA
0624A:  GOTO   9212 (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
05C0A:  MOVLW  DA
05C0C:  MOVWF  FF6
05C0E:  MOVLW  19
05C10:  MOVWF  FF7
05C12:  MOVLW  00
05C14:  MOVWF  FF8
05C16:  CALL   1BDA
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
05C1A:  MOVLB  1
05C1C:  MOVF   x8D,W
05C1E:  MOVWF  FE9
05C20:  MOVF   x8E,W
05C22:  MOVWF  FEA
05C24:  MOVFF  FEF,1D3
05C28:  MOVFF  1D3,1E0
05C2C:  CLRF   xE1
05C2E:  MOVLB  0
05C30:  CALL   387E
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
05C34:  MOVLB  1
05C36:  CLRF   x8F
05C38:  CLRF   x90
05C3A:  CLRF   x91
05C3C:  CLRF   x92
05C3E:  CLRF   x93
05C40:  CLRF   x94
05C42:  CLRF   x95
05C44:  CLRF   x96
05C46:  CLRF   x97
05C48:  CLRF   x98
05C4A:  CLRF   x99
05C4C:  CLRF   x9A
05C4E:  CLRF   x9B
05C50:  CLRF   x9C
05C52:  CLRF   x9D
05C54:  CLRF   x9E
05C56:  CLRF   x9F
05C58:  CLRF   xA0
05C5A:  CLRF   xA1
05C5C:  CLRF   xA2
05C5E:  CLRF   xA3
05C60:  CLRF   xA4
05C62:  CLRF   xA5
05C64:  CLRF   xA6
05C66:  CLRF   xA7
05C68:  CLRF   xA8
05C6A:  CLRF   xA9
05C6C:  CLRF   xAA
05C6E:  CLRF   xAB
05C70:  CLRF   xAC
05C72:  CLRF   xAD
05C74:  CLRF   xAE
05C76:  CLRF   xAF
05C78:  CLRF   xB0
05C7A:  CLRF   xB1
05C7C:  CLRF   xB2
05C7E:  CLRF   xB3
05C80:  CLRF   xB4
05C82:  CLRF   xB5
05C84:  CLRF   xB6
05C86:  CLRF   xB7
05C88:  CLRF   xB8
05C8A:  CLRF   xB9
05C8C:  CLRF   xBA
05C8E:  CLRF   xBB
05C90:  CLRF   xBC
05C92:  CLRF   xBD
05C94:  CLRF   xBE
05C96:  CLRF   xBF
05C98:  CLRF   xC0
05C9A:  CLRF   xC1
05C9C:  CLRF   xC2
05C9E:  CLRF   xC3
05CA0:  CLRF   xC4
05CA2:  CLRF   xC5
05CA4:  CLRF   xC6
05CA6:  CLRF   xC7
05CA8:  CLRF   xC8
05CAA:  CLRF   xC9
05CAC:  CLRF   xCA
05CAE:  CLRF   xCB
05CB0:  CLRF   xCC
05CB2:  CLRF   xCD
05CB4:  CLRF   xCE
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_IV2_DATA_END_ADDRESS; address += SECTOR_64K_BYTE) {
05CB6:  MOVLW  06
05CB8:  MOVWF  xD2
05CBA:  MOVLW  AA
05CBC:  MOVWF  xD1
05CBE:  CLRF   xD0
05CC0:  CLRF   xCF
05CC2:  MOVLB  0
05CC4:  MOVLB  1
05CC6:  MOVF   xD2,W
05CC8:  SUBLW  07
05CCA:  BTFSC  FD8.0
05CCC:  BRA    5CD4
05CCE:  MOVLB  0
05CD0:  GOTO   5D52
05CD4:  MOVLB  0
05CD6:  BTFSS  FD8.2
05CD8:  GOTO   5D1E
05CDC:  MOVLB  1
05CDE:  MOVF   xD1,W
05CE0:  SUBLW  48
05CE2:  BTFSC  FD8.0
05CE4:  BRA    5CEC
05CE6:  MOVLB  0
05CE8:  GOTO   5D52
05CEC:  MOVLB  0
05CEE:  BTFSS  FD8.2
05CF0:  GOTO   5D1E
05CF4:  MOVLB  1
05CF6:  MOVF   xD0,W
05CF8:  SUBLW  3F
05CFA:  BTFSC  FD8.0
05CFC:  BRA    5D04
05CFE:  MOVLB  0
05D00:  GOTO   5D52
05D04:  MOVLB  0
05D06:  BTFSS  FD8.2
05D08:  GOTO   5D1E
05D0C:  MOVLB  1
05D0E:  MOVF   xCF,W
05D10:  SUBLW  FE
05D12:  BTFSC  FD8.0
05D14:  BRA    5D1C
05D16:  MOVLB  0
05D18:  GOTO   5D52
05D1C:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
05D1E:  MOVFF  115,A59
05D22:  MOVFF  114,A58
05D26:  MOVFF  113,A57
05D2A:  MOVFF  112,A56
05D2E:  MOVFF  1D2,A5D
05D32:  MOVFF  1D1,A5C
05D36:  MOVFF  1D0,A5B
05D3A:  MOVFF  1CF,A5A
05D3E:  CALL   40D2
05D42:  MOVLW  01
05D44:  MOVLB  1
05D46:  ADDWF  xD1,F
05D48:  MOVLW  00
05D4A:  ADDWFC xD2,F
05D4C:  MOVLB  0
05D4E:  GOTO   5CC4
....................    }
....................    smf_data_table_init(); // Update the address area after writing
05D52:  GOTO   5B3C
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
05D56:  MOVLB  1
05D58:  MOVF   x8D,W
05D5A:  MOVWF  FE9
05D5C:  MOVF   x8E,W
05D5E:  MOVWF  FEA
05D60:  MOVFF  FEF,1D3
05D64:  MOVFF  1D3,1E0
05D68:  SETF   xE1
05D6A:  MOVLB  0
05D6C:  CALL   387E
....................    printf("End SMF Reset\r\n");
05D70:  MOVLW  EC
05D72:  MOVWF  FF6
05D74:  MOVLW  19
05D76:  MOVWF  FF7
05D78:  MOVLW  00
05D7A:  MOVWF  FF8
05D7C:  CALL   1BDA
05D80:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0B2F0:  CLRF   FF8
0B2F2:  BCF    FD0.7
0B2F4:  BSF    07.7
0B2F6:  MOVLB  E
0B2F8:  MOVLW  55
0B2FA:  MOVWF  F7E
0B2FC:  MOVLW  AA
0B2FE:  MOVWF  F7E
0B300:  BCF    F66.6
0B302:  MOVLW  F9
0B304:  MOVWF  x2C
0B306:  MOVLW  0F
0B308:  MOVWF  x2E
0B30A:  MOVLW  40
0B30C:  MOVWF  x12
0B30E:  MOVLW  30
0B310:  MOVWF  x13
0B312:  MOVLW  20
0B314:  MOVWF  x22
0B316:  MOVLW  55
0B318:  MOVWF  F7E
0B31A:  MOVLW  AA
0B31C:  MOVWF  F7E
0B31E:  BSF    F66.6
0B320:  CLRF   F9B
0B322:  CLRF   F64
0B324:  CLRF   F65
0B326:  CLRF   F66
0B328:  MOVLW  02
0B32A:  MOVWF  FD3
0B32C:  CLRF   1B
0B32E:  MOVLB  F
0B330:  BSF    x2D.3
0B332:  MOVLW  A0
0B334:  MOVWF  x2B
0B336:  MOVLW  01
0B338:  MOVWF  x2C
0B33A:  MOVLW  A6
0B33C:  MOVWF  x2E
0B33E:  MOVLW  90
0B340:  MOVWF  x2F
0B342:  BCF    F93.6
0B344:  BSF    F8A.6
0B346:  BSF    F92.1
0B348:  BCF    F92.0
0B34A:  BCF    F92.3
0B34C:  BCF    F89.3
0B34E:  BSF    F96.0
0B350:  BCF    F96.6
0B352:  BCF    F96.1
0B354:  BCF    F8D.1
0B356:  BSF    F93.4
0B358:  BCF    F93.5
0B35A:  BCF    F93.2
0B35C:  BSF    F8A.2
0B35E:  CLRF   1F
0B360:  CLRF   1E
0B362:  CLRF   1D
0B364:  CLRF   1C
0B366:  CLRF   23
0B368:  CLRF   22
0B36A:  CLRF   21
0B36C:  CLRF   20
0B36E:  CLRF   25
0B370:  CLRF   24
0B372:  CLRF   46
0B374:  BCF    47.0
0B376:  MOVLW  1E
0B378:  MOVLB  1
0B37A:  MOVWF  x4E
0B37C:  CLRF   x50
0B37E:  CLRF   x4F
0B380:  MOVLB  E
0B382:  CLRF   xD9
0B384:  CLRF   xDA
0B386:  CLRF   xCE
0B388:  CLRF   xCF
0B38A:  CLRF   xD0
0B38C:  CLRF   xD1
0B38E:  CLRF   xD2
0B390:  CLRF   xD3
0B392:  CLRF   xD4
0B394:  CLRF   xD5
0B396:  CLRF   x45
0B398:  CLRF   x46
0B39A:  CLRF   x47
0B39C:  BCF    x8D.7
0B39E:  BCF    x8D.6
0B3A0:  BCF    x8D.5
0B3A2:  MOVLB  F
0B3A4:  CLRF   x53
0B3A6:  CLRF   x38
0B3A8:  CLRF   x37
0B3AA:  MOVLB  0
0B3AC:  CLRF   26
0B3AE:  CLRF   27
0B3B0:  CLRF   28
0B3B2:  CLRF   29
0B3B4:  CLRF   2A
0B3B6:  CLRF   2B
0B3B8:  CLRF   2C
0B3BA:  CLRF   2D
0B3BC:  CLRF   2E
0B3BE:  CLRF   2F
0B3C0:  CLRF   30
0B3C2:  CLRF   31
0B3C4:  CLRF   32
0B3C6:  CLRF   33
0B3C8:  CLRF   34
0B3CA:  CLRF   35
0B3CC:  CLRF   36
0B3CE:  CLRF   37
0B3D0:  CLRF   38
0B3D2:  CLRF   39
0B3D4:  CLRF   3A
0B3D6:  CLRF   3B
0B3D8:  CLRF   3C
0B3DA:  CLRF   3D
0B3DC:  CLRF   3E
0B3DE:  CLRF   3F
0B3E0:  CLRF   40
0B3E2:  CLRF   41
0B3E4:  CLRF   42
0B3E6:  CLRF   43
0B3E8:  CLRF   44
0B3EA:  CLRF   45
0B3EC:  MOVLW  03
0B3EE:  MOVWF  48
0B3F0:  CLRF   49
0B3F2:  CLRF   4A
0B3F4:  CLRF   4B
0B3F6:  CLRF   4C
0B3F8:  CLRF   4D
0B3FA:  CLRF   4E
0B3FC:  CLRF   4F
0B3FE:  CLRF   50
0B400:  CLRF   51
0B402:  CLRF   52
0B404:  CLRF   53
0B406:  CLRF   54
0B408:  CLRF   55
0B40A:  CLRF   56
0B40C:  CLRF   57
0B40E:  CLRF   58
0B410:  CLRF   59
0B412:  CLRF   5A
0B414:  CLRF   5B
0B416:  CLRF   5C
0B418:  CLRF   5D
0B41A:  CLRF   5E
0B41C:  CLRF   5F
0B41E:  CLRF   x60
0B420:  CLRF   x61
0B422:  CLRF   x62
0B424:  CLRF   x63
0B426:  CLRF   x64
0B428:  CLRF   x65
0B42A:  CLRF   x66
0B42C:  CLRF   x67
0B42E:  CLRF   x68
0B430:  CLRF   x69
0B432:  CLRF   x6A
0B434:  CLRF   x6B
0B436:  CLRF   x6C
0B438:  CLRF   x6D
0B43A:  CLRF   x6E
0B43C:  CLRF   x6F
0B43E:  CLRF   x70
0B440:  CLRF   x71
0B442:  CLRF   x72
0B444:  CLRF   x73
0B446:  CLRF   x74
0B448:  CLRF   x75
0B44A:  CLRF   x76
0B44C:  CLRF   x77
0B44E:  CLRF   x78
0B450:  CLRF   x79
0B452:  CLRF   x7A
0B454:  CLRF   x7B
0B456:  CLRF   x7C
0B458:  CLRF   x7D
0B45A:  CLRF   x7E
0B45C:  CLRF   x7F
0B45E:  CLRF   x80
0B460:  CLRF   x81
0B462:  CLRF   x82
0B464:  CLRF   x83
0B466:  CLRF   x84
0B468:  CLRF   x85
0B46A:  CLRF   x86
0B46C:  CLRF   x87
0B46E:  CLRF   x88
0B470:  CLRF   x89
0B472:  CLRF   x8A
0B474:  CLRF   x8B
0B476:  CLRF   x8C
0B478:  CLRF   x8D
0B47A:  CLRF   x8E
0B47C:  CLRF   x8F
0B47E:  CLRF   x90
0B480:  CLRF   x91
0B482:  CLRF   x92
0B484:  CLRF   x93
0B486:  CLRF   x94
0B488:  CLRF   x95
0B48A:  CLRF   x96
0B48C:  CLRF   x97
0B48E:  CLRF   x98
0B490:  CLRF   x99
0B492:  CLRF   x9A
0B494:  CLRF   x9B
0B496:  CLRF   x9C
0B498:  CLRF   x9D
0B49A:  CLRF   x9E
0B49C:  CLRF   x9F
0B49E:  CLRF   xA0
0B4A0:  CLRF   xA1
0B4A2:  CLRF   xA2
0B4A4:  CLRF   xA3
0B4A6:  CLRF   xA4
0B4A8:  CLRF   xA5
0B4AA:  CLRF   xA6
0B4AC:  CLRF   xA7
0B4AE:  CLRF   xA8
0B4B0:  CLRF   xA9
0B4B2:  CLRF   xAA
0B4B4:  CLRF   xAB
0B4B6:  CLRF   xAC
0B4B8:  CLRF   xAD
0B4BA:  CLRF   xAE
0B4BC:  CLRF   xAF
0B4BE:  CLRF   xB0
0B4C0:  CLRF   xB1
0B4C2:  CLRF   xB2
0B4C4:  CLRF   xB3
0B4C6:  CLRF   xB4
0B4C8:  CLRF   xB5
0B4CA:  CLRF   xB6
0B4CC:  CLRF   xB7
0B4CE:  CLRF   xB8
0B4D0:  CLRF   xB9
0B4D2:  CLRF   xBA
0B4D4:  CLRF   xBB
0B4D6:  CLRF   xBC
0B4D8:  CLRF   xBD
0B4DA:  CLRF   xBE
0B4DC:  CLRF   xBF
0B4DE:  CLRF   xC0
0B4E0:  CLRF   xC1
0B4E2:  CLRF   xC2
0B4E4:  CLRF   xC3
0B4E6:  CLRF   xC4
0B4E8:  CLRF   xC5
0B4EA:  CLRF   xC6
0B4EC:  CLRF   xC7
0B4EE:  CLRF   xC8
0B4F0:  CLRF   xC9
0B4F2:  CLRF   xCA
0B4F4:  CLRF   xCB
0B4F6:  CLRF   xCC
0B4F8:  CLRF   xCD
0B4FA:  CLRF   xCE
0B4FC:  CLRF   xCF
0B4FE:  CLRF   xD0
0B500:  CLRF   xD1
0B502:  CLRF   xD2
0B504:  CLRF   xD3
0B506:  CLRF   xD4
0B508:  CLRF   xD5
0B50A:  CLRF   xD6
0B50C:  CLRF   xD7
0B50E:  CLRF   xD8
0B510:  CLRF   xD9
0B512:  CLRF   xDA
0B514:  CLRF   xDB
0B516:  CLRF   xDC
0B518:  CLRF   xDD
0B51A:  CLRF   xDE
0B51C:  CLRF   xDF
0B51E:  CLRF   xE0
0B520:  CLRF   xE1
0B522:  CLRF   xE2
0B524:  CLRF   xE3
0B526:  CLRF   xE4
0B528:  CLRF   xE5
0B52A:  CLRF   xE6
0B52C:  CLRF   xE7
0B52E:  CLRF   xE8
0B530:  CLRF   xE9
0B532:  CLRF   xEA
0B534:  CLRF   xEB
0B536:  CLRF   xEC
0B538:  CLRF   xED
0B53A:  CLRF   xEE
0B53C:  CLRF   xEF
0B53E:  CLRF   xF0
0B540:  CLRF   xF1
0B542:  CLRF   xF2
0B544:  CLRF   xF3
0B546:  CLRF   xF4
0B548:  CLRF   xF5
0B54A:  CLRF   xF6
0B54C:  CLRF   xF7
0B54E:  CLRF   xF8
0B550:  CLRF   xF9
0B552:  CLRF   xFA
0B554:  CLRF   xFB
0B556:  CLRF   xFC
0B558:  CLRF   xFD
0B55A:  CLRF   xFE
0B55C:  CLRF   xFF
0B55E:  MOVLB  1
0B560:  CLRF   x00
0B562:  CLRF   x01
0B564:  CLRF   x02
0B566:  CLRF   x03
0B568:  CLRF   x04
0B56A:  CLRF   x05
0B56C:  CLRF   x06
0B56E:  CLRF   x07
0B570:  CLRF   x08
0B572:  CLRF   x09
0B574:  CLRF   x0A
0B576:  CLRF   x0B
0B578:  CLRF   x0C
0B57A:  CLRF   x0D
0B57C:  CLRF   x0E
0B57E:  CLRF   x0F
0B580:  MOVLW  05
0B582:  MOVWF  x10
0B584:  MOVLW  7C
0B586:  MOVWF  x11
0B588:  MOVLW  01
0B58A:  MOVWF  x12
0B58C:  MOVLW  01
0B58E:  MOVWF  x13
0B590:  MOVLW  02
0B592:  MOVWF  x14
0B594:  MOVLW  7C
0B596:  MOVWF  x15
0B598:  CLRF   x16
0B59A:  MOVLW  09
0B59C:  MOVWF  x17
0B59E:  MOVLW  01
0B5A0:  MOVWF  x18
0B5A2:  CLRF   x19
0B5A4:  MOVLW  02
0B5A6:  MOVWF  x1A
0B5A8:  MOVLW  01
0B5AA:  MOVWF  x1B
0B5AC:  CLRF   x1C
0B5AE:  CLRF   x1D
0B5B0:  CLRF   x1E
0B5B2:  CLRF   x1F
0B5B4:  CLRF   x20
0B5B6:  CLRF   x21
0B5B8:  CLRF   x22
0B5BA:  CLRF   x23
0B5BC:  CLRF   x24
0B5BE:  CLRF   x25
0B5C0:  CLRF   x26
0B5C2:  CLRF   x27
0B5C4:  CLRF   x28
0B5C6:  MOVLW  01
0B5C8:  MOVWF  x29
0B5CA:  CLRF   x2A
0B5CC:  CLRF   x2B
0B5CE:  CLRF   x2C
0B5D0:  CLRF   x2D
0B5D2:  CLRF   x2E
0B5D4:  CLRF   x2F
0B5D6:  CLRF   x30
0B5D8:  CLRF   x31
0B5DA:  CLRF   x32
0B5DC:  CLRF   x33
0B5DE:  MOVLW  02
0B5E0:  MOVWF  x34
0B5E2:  CLRF   x35
0B5E4:  CLRF   x36
0B5E6:  CLRF   x37
0B5E8:  CLRF   x38
0B5EA:  CLRF   x39
0B5EC:  CLRF   x3A
0B5EE:  CLRF   x3B
0B5F0:  CLRF   x3C
0B5F2:  CLRF   x3D
0B5F4:  CLRF   x3E
0B5F6:  MOVLW  03
0B5F8:  MOVWF  x3F
0B5FA:  CLRF   x40
0B5FC:  CLRF   x41
0B5FE:  CLRF   x42
0B600:  CLRF   x43
0B602:  CLRF   x44
0B604:  CLRF   x45
0B606:  CLRF   x46
0B608:  CLRF   x47
0B60A:  CLRF   x48
0B60C:  CLRF   x49
0B60E:  CLRF   x51
0B610:  CLRF   x52
0B612:  CLRF   x53
0B614:  CLRF   x54
0B616:  CLRF   x55
0B618:  CLRF   x56
0B61A:  CLRF   x57
0B61C:  CLRF   x58
0B61E:  CLRF   x59
0B620:  CLRF   x5A
0B622:  CLRF   x5B
0B624:  CLRF   x5C
0B626:  CLRF   x5D
0B628:  CLRF   x5E
0B62A:  CLRF   x5F
0B62C:  CLRF   x60
0B62E:  CLRF   x61
0B630:  CLRF   x62
0B632:  CLRF   x63
0B634:  CLRF   x64
0B636:  CLRF   x65
0B638:  CLRF   x66
0B63A:  CLRF   x67
0B63C:  CLRF   x68
0B63E:  CLRF   x69
0B640:  CLRF   x6A
0B642:  CLRF   x6B
0B644:  CLRF   x6C
0B646:  CLRF   x6D
0B648:  CLRF   x6E
0B64A:  CLRF   x6F
0B64C:  CLRF   x70
0B64E:  CLRF   x71
0B650:  CLRF   x72
0B652:  CLRF   x73
0B654:  CLRF   x74
0B656:  CLRF   x75
0B658:  CLRF   x76
0B65A:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0B65C:  MOVLW  64
0B65E:  MOVLB  A
0B660:  MOVWF  x6E
0B662:  MOVLB  0
0B664:  CALL   1B5A
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0B668:  MOVLW  FC
0B66A:  MOVWF  FF6
0B66C:  MOVLW  19
0B66E:  MOVWF  FF7
0B670:  MOVLW  00
0B672:  MOVWF  FF8
0B674:  CALL   1BDA
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0B678:  MOVLW  42
0B67A:  MOVWF  FF6
0B67C:  MOVLW  1A
0B67E:  MOVWF  FF7
0B680:  MOVLW  00
0B682:  MOVWF  FF8
0B684:  CALL   1BDA
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0B688:  MOVLW  70
0B68A:  MOVWF  FF6
0B68C:  MOVLW  1A
0B68E:  MOVWF  FF7
0B690:  MOVLW  00
0B692:  MOVWF  FF8
0B694:  MOVLW  10
0B696:  MOVLB  9
0B698:  MOVWF  xC6
0B69A:  MOVLB  0
0B69C:  CALL   1C0A
0B6A0:  MOVLW  96
0B6A2:  MOVWF  FF6
0B6A4:  MOVLW  1A
0B6A6:  MOVWF  FF7
0B6A8:  MOVLW  00
0B6AA:  MOVWF  FF8
0B6AC:  CALL   1BDA
0B6B0:  MOVLW  20
0B6B2:  MOVLB  A
0B6B4:  MOVWF  xAD
0B6B6:  MOVLB  0
0B6B8:  CALL   1B88
0B6BC:  MOVLW  A0
0B6BE:  MOVWF  FF6
0B6C0:  MOVLW  1A
0B6C2:  MOVWF  FF7
0B6C4:  MOVLW  00
0B6C6:  MOVWF  FF8
0B6C8:  CALL   1BDA
0B6CC:  MOVLW  85
0B6CE:  MOVWF  FF6
0B6D0:  MOVLW  1A
0B6D2:  MOVWF  FF7
0B6D4:  MOVLW  00
0B6D6:  MOVWF  FF8
0B6D8:  MOVLW  0F
0B6DA:  MOVLB  9
0B6DC:  MOVWF  xC6
0B6DE:  MOVLB  0
0B6E0:  CALL   1C0A
....................    
....................    io_init();
0B6E4:  GOTO   1C40
....................    setup_uart_to_boss();
0B6E8:  GOTO   1C8E
....................    setup_timer();
0B6EC:  GOTO   1CB8
....................    ad7490_init();
0B6F0:  GOTO   1ECE
....................    mcp4901_init();
0B6F4:  GOTO   21AC
....................    misf_init();
0B6F8:  CALL   2FF8
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0B6FC:  MOVLB  1
0B6FE:  CLRF   xE0
0B700:  CLRF   xE1
0B702:  MOVLB  0
0B704:  CALL   387E
.................... 
....................    int1 is_finished = FALSE;
0B708:  MOVLB  1
0B70A:  BCF    x77.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0B70C:  MOVLW  AA
0B70E:  MOVWF  FF6
0B710:  MOVLW  1A
0B712:  MOVWF  FF7
0B714:  MOVLW  00
0B716:  MOVWF  FF8
0B718:  MOVLB  0
0B71A:  CALL   1BDA
....................    
....................    output_low(EN_NPWR);
0B71E:  MOVLW  5E
0B720:  MOVWF  F94
0B722:  BCF    F8B.7
....................    // output_high(EN_NPWR); // Enable power to CIGS
....................    // output_high(CONNECT_CIGS2);
....................    fprintf(PC,"waiting for BOSS PIC command");
0B724:  MOVLW  D0
0B726:  MOVWF  FF6
0B728:  MOVLW  1A
0B72A:  MOVWF  FF7
0B72C:  MOVLW  00
0B72E:  MOVWF  FF8
0B730:  CALL   1BDA
....................    
....................    //Start loop
....................    while(!is_finished)
0B734:  MOVLB  1
0B736:  BTFSS  x77.0
0B738:  BRA    B740
0B73A:  MOVLB  0
0B73C:  GOTO   B810
0B740:  MOVLB  0
....................    {
....................       // unsigned int16 cigs1_amp = ad7490_read(ADC_CIGS2_AMP);
....................       // unsigned int16 cigs1_curr = ad7490_read(ADC_CIGS2_CURR);
....................       // unsigned int16 cigs1_volt = ad7490_read(ADC_CIGS2_VOLT);
....................       
....................       // fprintf(PC, "CIGS1 Amp: %04LX, Current: %04LX, Voltage: %04LX\r\n", cigs1_amp, cigs1_curr, cigs1_volt);
....................       
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0B742:  MOVF   46,F
0B744:  BTFSC  FD8.2
0B746:  GOTO   B7CA
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0B74A:  MOVLB  1
0B74C:  CLRF   x8B
0B74E:  MOVLW  26
0B750:  MOVWF  x8A
0B752:  MOVFF  46,18C
0B756:  MOVLB  0
0B758:  GOTO   3D28
0B75C:  MOVFF  02,03
0B760:  MOVF   01,W
0B762:  MOVWF  FE1
0B764:  MOVFF  03,FE2
0B768:  MOVLW  01
0B76A:  MOVWF  FEA
0B76C:  MOVLW  78
0B76E:  MOVWF  FE9
0B770:  MOVLW  0C
0B772:  MOVWF  01
0B774:  MOVFF  FE6,FEE
0B778:  DECFSZ 01,F
0B77A:  GOTO   B774
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0B77E:  MOVLB  1
0B780:  CLRF   x85
0B782:  MOVLW  26
0B784:  MOVWF  x84
0B786:  CLRF   x87
0B788:  MOVLW  46
0B78A:  MOVWF  x86
0B78C:  MOVLB  0
0B78E:  GOTO   3F24
....................          
....................          if(recieve_cmd.is_exist)
0B792:  MOVLB  1
0B794:  BTFSC  x7A.0
0B796:  BRA    B79E
0B798:  MOVLB  0
0B79A:  GOTO   B7BA
0B79E:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0B7A0:  MOVLW  01
0B7A2:  MOVLB  1
0B7A4:  MOVWF  x85
0B7A6:  MOVLW  78
0B7A8:  MOVWF  x84
0B7AA:  MOVLB  0
0B7AC:  GOTO   B26E
0B7B0:  MOVLB  1
0B7B2:  BCF    x77.1
0B7B4:  BTFSC  01.0
0B7B6:  BSF    x77.1
0B7B8:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0B7BA:  MOVLW  EE
0B7BC:  MOVWF  FF6
0B7BE:  MOVLW  1A
0B7C0:  MOVWF  FF7
0B7C2:  MOVLW  00
0B7C4:  MOVWF  FF8
0B7C6:  CALL   1BDA
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0B7CA:  MOVLB  1
0B7CC:  BTFSC  x77.0
0B7CE:  BRA    B7D6
0B7D0:  MOVLB  0
0B7D2:  GOTO   B7DC
0B7D6:  MOVLB  0
....................          break;
0B7D8:  GOTO   B810
....................          
....................       delay_ms(400);
0B7DC:  MOVLW  02
0B7DE:  MOVLB  1
0B7E0:  MOVWF  x84
0B7E2:  MOVLB  0
0B7E4:  MOVLW  C8
0B7E6:  MOVLB  A
0B7E8:  MOVWF  x6E
0B7EA:  MOVLB  0
0B7EC:  CALL   1B5A
0B7F0:  MOVLB  1
0B7F2:  DECFSZ x84,F
0B7F4:  BRA    B7FA
0B7F6:  BRA    B7FE
0B7F8:  MOVLB  0
0B7FA:  MOVLB  0
0B7FC:  BRA    B7E4
....................       // fprintf(PC, ".");
....................       mcp4901_2_write(100);
0B7FE:  MOVLB  9
0B800:  CLRF   xC3
0B802:  MOVLW  64
0B804:  MOVWF  xC2
0B806:  MOVLB  0
0B808:  CALL   216A
0B80C:  GOTO   B734
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0B810:  MOVLW  0E
0B812:  MOVWF  FF6
0B814:  MOVLW  1B
0B816:  MOVWF  FF7
0B818:  MOVLW  00
0B81A:  MOVWF  FF8
0B81C:  CALL   1BDA
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0B820:  MOVLW  2E
0B822:  MOVLB  A
0B824:  MOVWF  xAD
0B826:  MOVLB  0
0B828:  CALL   1B88
....................       delay_ms(1000);
0B82C:  MOVLW  04
0B82E:  MOVLB  1
0B830:  MOVWF  x84
0B832:  MOVLB  0
0B834:  MOVLW  FA
0B836:  MOVLB  A
0B838:  MOVWF  x6E
0B83A:  MOVLB  0
0B83C:  CALL   1B5A
0B840:  MOVLB  1
0B842:  DECFSZ x84,F
0B844:  BRA    B84A
0B846:  BRA    B84E
0B848:  MOVLB  0
0B84A:  MOVLB  0
0B84C:  BRA    B834
0B84E:  MOVLB  0
0B850:  GOTO   B820
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0B854:  MOVLW  4E
0B856:  MOVWF  FF6
0B858:  MOVLW  1B
0B85A:  MOVWF  FF7
0B85C:  MOVLW  00
0B85E:  MOVWF  FF8
0B860:  CALL   1BDA
....................    
.................... }
.................... // Enf of files
0B864:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
