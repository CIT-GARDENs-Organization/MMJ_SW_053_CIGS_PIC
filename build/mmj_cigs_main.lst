CCS PCH C Compiler, Version 5.104, 57077               31-8-25 19:52

               Filename:   ..\build\mmj_cigs_main.lst

               ROM used:   53384 bytes (41%)
                           Largest free fragment is 65520
               RAM used:   441 (12%) at main() level
                           2812 (79%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   CA56
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   00CA
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   0132
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "mmj_cigs_main.h"  // ルート直下のヘッダー
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "hal/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
000EA:  DATA 54,69
000EC:  DATA 6D,65
000EE:  DATA 72,20
000F0:  DATA 49,6E
000F2:  DATA 69,74
000F4:  DATA 69,61
000F6:  DATA 6C,69
000F8:  DATA 7A,65
000FA:  DATA 0D,0A
000FC:  DATA 00,00
000FE:  DATA 09,43
00100:  DATA 6F,6D
00102:  DATA 70,6C
00104:  DATA 65,74
00106:  DATA 65,0D
00108:  DATA 0A,00
*
0017A:  DATA 55,41
0017C:  DATA 52,54
0017E:  DATA 20,49
00180:  DATA 6E,69
00182:  DATA 74,69
00184:  DATA 61,6C
00186:  DATA 69,7A
00188:  DATA 65,0D
0018A:  DATA 0A,00
0018C:  DATA 09,43
0018E:  DATA 6F,6D
00190:  DATA 70,6C
00192:  DATA 65,74
00194:  DATA 65,0D
00196:  DATA 0A,00
00198:  DATA 41,44
0019A:  DATA 37,34
0019C:  DATA 39,30
0019E:  DATA 20,49
001A0:  DATA 6E,69
001A2:  DATA 74,69
001A4:  DATA 61,6C
001A6:  DATA 69,7A
001A8:  DATA 65,0D
001AA:  DATA 0A,00
001AC:  DATA 09,43
001AE:  DATA 6F,6E
001B0:  DATA 6E,65
001B2:  DATA 63,74
001B4:  DATA 20,65
001B6:  DATA 72,72
001B8:  DATA 6F,72
001BA:  DATA 21,0D
001BC:  DATA 0A,00
001BE:  DATA 09,43
001C0:  DATA 6F,6E
001C2:  DATA 6E,65
001C4:  DATA 63,74
001C6:  DATA 20,73
001C8:  DATA 75,63
001CA:  DATA 63,65
001CC:  DATA 73,73
001CE:  DATA 66,75
001D0:  DATA 6C,0D
001D2:  DATA 0A,00
001D4:  DATA 09,43
001D6:  DATA 6F,6D
001D8:  DATA 70,6C
001DA:  DATA 65,74
001DC:  DATA 65,0D
001DE:  DATA 0A,00
001E0:  DATA 4D,43
001E2:  DATA 50,34
001E4:  DATA 39,30
001E6:  DATA 31,20
001E8:  DATA 49,6E
001EA:  DATA 69,74
001EC:  DATA 69,61
001EE:  DATA 6C,69
001F0:  DATA 7A,65
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  DATA 09,5B
001F8:  DATA 44,41
001FA:  DATA 43,20
001FC:  DATA 50,6F
001FE:  DATA 72,74
00200:  DATA 20,31
00202:  DATA 5D,20
00204:  DATA 43,6F
00206:  DATA 6E,6E
00208:  DATA 65,63
0020A:  DATA 74,20
0020C:  DATA 65,72
0020E:  DATA 72,6F
00210:  DATA 72,21
00212:  DATA 0D,0A
00214:  DATA 00,00
00216:  DATA 09,5B
00218:  DATA 44,41
0021A:  DATA 43,20
0021C:  DATA 50,6F
0021E:  DATA 72,74
00220:  DATA 20,31
00222:  DATA 5D,20
00224:  DATA 43,6F
00226:  DATA 6E,6E
00228:  DATA 65,63
0022A:  DATA 74,20
0022C:  DATA 73,75
0022E:  DATA 63,63
00230:  DATA 65,73
00232:  DATA 73,66
00234:  DATA 75,6C
00236:  DATA 0D,0A
00238:  DATA 00,00
0023A:  DATA 09,5B
0023C:  DATA 44,41
0023E:  DATA 43,20
00240:  DATA 50,6F
00242:  DATA 72,74
00244:  DATA 20,32
00246:  DATA 5D,20
00248:  DATA 43,6F
0024A:  DATA 6E,6E
0024C:  DATA 65,63
0024E:  DATA 74,20
00250:  DATA 65,72
00252:  DATA 72,6F
00254:  DATA 72,21
00256:  DATA 0D,0A
00258:  DATA 00,00
0025A:  DATA 09,5B
0025C:  DATA 44,41
0025E:  DATA 43,20
00260:  DATA 50,6F
00262:  DATA 72,74
00264:  DATA 20,32
00266:  DATA 5D,20
00268:  DATA 43,6F
0026A:  DATA 6E,6E
0026C:  DATA 65,63
0026E:  DATA 74,20
00270:  DATA 73,75
00272:  DATA 63,63
00274:  DATA 65,73
00276:  DATA 73,66
00278:  DATA 75,6C
0027A:  DATA 0D,0A
0027C:  DATA 00,00
0027E:  DATA 09,43
00280:  DATA 6F,6D
00282:  DATA 70,6C
00284:  DATA 65,74
00286:  DATA 65,0D
00288:  DATA 0A,00
0028A:  DATA 45,6E
0028C:  DATA 71,75
0028E:  DATA 65,75
00290:  DATA 65,20
00292:  DATA 46,6C
00294:  DATA 61,73
00296:  DATA 68,20
00298:  DATA 4F,70
0029A:  DATA 65,72
0029C:  DATA 61,74
0029E:  DATA 69,6F
002A0:  DATA 6E,0D
002A2:  DATA 0A,00
002A4:  DATA 46,6C
002A6:  DATA 61,73
002A8:  DATA 68,20
002AA:  DATA 71,75
002AC:  DATA 65,75
002AE:  DATA 65,20
002B0:  DATA 69,73
002B2:  DATA 20,66
002B4:  DATA 75,6C
002B6:  DATA 6C,21
002B8:  DATA 21,21
002BA:  DATA 0D,0A
002BC:  DATA 00,00
002BE:  DATA 46,6C
002C0:  DATA 61,73
002C2:  DATA 68,20
002C4:  DATA 71,75
002C6:  DATA 65,75
002C8:  DATA 65,20
002CA:  DATA 69,73
002CC:  DATA 20,65
002CE:  DATA 6D,70
002D0:  DATA 74,79
002D2:  DATA 0D,0A
002D4:  DATA 00,00
002D6:  DATA 0D,0A
002D8:  DATA 53,74
002DA:  DATA 61,72
002DC:  DATA 74,20
002DE:  DATA 6D,61
002E0:  DATA 6B,65
002E2:  DATA 5F,72
002E4:  DATA 65,63
002E6:  DATA 65,69
002E8:  DATA 76,65
002EA:  DATA 5F,63
002EC:  DATA 6F,6D
002EE:  DATA 6D,61
002F0:  DATA 6E,64
002F2:  DATA 0D,0A
002F4:  DATA 00,00
002F6:  DATA 09,5B
002F8:  DATA 42,4F
002FA:  DATA 53,53
002FC:  DATA 5D,20
002FE:  DATA 3E,3E
00300:  DATA 3E,20
00302:  DATA 00,00
00304:  DATA 45,6E
00306:  DATA 64,20
00308:  DATA 6D,61
0030A:  DATA 6B,65
0030C:  DATA 5F,72
0030E:  DATA 65,63
00310:  DATA 69,76
00312:  DATA 65,5F
00314:  DATA 63,6F
00316:  DATA 6D,6D
00318:  DATA 61,6E
0031A:  DATA 64,0D
0031C:  DATA 0A,0D
0031E:  DATA 0A,00
00320:  DATA 73,69
00322:  DATA 67,6E
00324:  DATA 61,6C
00326:  DATA 20,65
00328:  DATA 6E,64
0032A:  DATA 20,77
0032C:  DATA 69,74
0032E:  DATA 68,20
00330:  DATA 53,46
00332:  DATA 44,0D
00334:  DATA 0A,00
00336:  DATA 64,6F
00338:  DATA 6E,27
0033A:  DATA 74,20
0033C:  DATA 66,69
0033E:  DATA 6E,64
00340:  DATA 20,53
00342:  DATA 46,44
00344:  DATA 0D,0A
00346:  DATA 00,00
00348:  DATA 09,2D
0034A:  DATA 3E,20
0034C:  DATA 49,6E
0034E:  DATA 76,61
00350:  DATA 6C,69
00352:  DATA 64,20
00354:  DATA 46,72
00356:  DATA 61,6D
00358:  DATA 65,20
0035A:  DATA 49,44
0035C:  DATA 20,72
0035E:  DATA 65,63
00360:  DATA 65,69
00362:  DATA 76,65
00364:  DATA 64,3A
00366:  DATA 20,25
00368:  DATA 58,0D
0036A:  DATA 0A,00
0036C:  DATA 09,2D
0036E:  DATA 3E,20
00370:  DATA 43,52
00372:  DATA 43,20
00374:  DATA 65,72
00376:  DATA 72,6F
00378:  DATA 72,21
0037A:  DATA 0D,0A
0037C:  DATA 00,00
0037E:  DATA 09,09
00380:  DATA 2D,3E
00382:  DATA 20,72
00384:  DATA 65,63
00386:  DATA 65,69
00388:  DATA 76,65
0038A:  DATA 64,20
0038C:  DATA 43,52
0038E:  DATA 43,3A
00390:  DATA 20,25
00392:  DATA 58,0D
00394:  DATA 0A,00
00396:  DATA 09,09
00398:  DATA 20,20
0039A:  DATA 20,63
0039C:  DATA 6F,6C
0039E:  DATA 6C,65
003A0:  DATA 63,74
003A2:  DATA 20,43
003A4:  DATA 52,43
003A6:  DATA 20,3A
003A8:  DATA 20,25
003AA:  DATA 58,0D
003AC:  DATA 0A,00
003AE:  DATA 09,2D
003B0:  DATA 3E,20
003B2:  DATA 49,6E
003B4:  DATA 76,61
003B6:  DATA 6C,69
003B8:  DATA 64,20
003BA:  DATA 64,65
003BC:  DATA 76,69
003BE:  DATA 63,65
003C0:  DATA 20,49
003C2:  DATA 44,20
003C4:  DATA 72,65
003C6:  DATA 63,65
003C8:  DATA 69,76
003CA:  DATA 65,64
003CC:  DATA 0D,0A
003CE:  DATA 00,00
003D0:  DATA 09,09
003D2:  DATA 2D,3E
003D4:  DATA 20,72
003D6:  DATA 65,63
003D8:  DATA 65,69
003DA:  DATA 76,65
003DC:  DATA 64,3A
003DE:  DATA 20,20
003E0:  DATA 20,20
003E2:  DATA 20,25
003E4:  DATA 58,0D
003E6:  DATA 0A,00
003E8:  DATA 09,09
003EA:  DATA 20,20
003EC:  DATA 20,4D
003EE:  DATA 79,20
003F0:  DATA 64,65
003F2:  DATA 76,69
003F4:  DATA 63,65
003F6:  DATA 20,49
003F8:  DATA 44,3A
003FA:  DATA 20,25
003FC:  DATA 58,0D
003FE:  DATA 0A,00
00400:  DATA 09,5B
00402:  DATA 42,4F
00404:  DATA 53,53
00406:  DATA 5D,20
00408:  DATA 3C,3C
0040A:  DATA 3C,20
0040C:  DATA 00,00
0040E:  DATA 53,74
00410:  DATA 61,72
00412:  DATA 74,20
00414:  DATA 53,4D
00416:  DATA 46,20
00418:  DATA 75,73
0041A:  DATA 69,6E
0041C:  DATA 67,20
0041E:  DATA 72,65
00420:  DATA 71,65
00422:  DATA 73,74
00424:  DATA 20,73
00426:  DATA 65,61
00428:  DATA 71,75
0042A:  DATA 65,6E
0042C:  DATA 63,65
0042E:  DATA 0D,0A
00430:  DATA 00,00
00432:  DATA 45,72
00434:  DATA 72,6F
00436:  DATA 72,21
00438:  DATA 20,52
0043A:  DATA 65,63
0043C:  DATA 65,69
0043E:  DATA 76,69
00440:  DATA 6E,67
00442:  DATA 20,63
00444:  DATA 6F,6D
00446:  DATA 6D,61
00448:  DATA 6E,64
0044A:  DATA 20,69
0044C:  DATA 6E,63
0044E:  DATA 6F,6E
00450:  DATA 73,69
00452:  DATA 73,74
00454:  DATA 65,6E
00456:  DATA 74,20
00458:  DATA 77,69
0045A:  DATA 74,68
0045C:  DATA 20,74
0045E:  DATA 68,65
00460:  DATA 20,64
00462:  DATA 65,73
00464:  DATA 69,67
00466:  DATA 6E,0D
00468:  DATA 0A,00
0046A:  DATA 53,4D
0046C:  DATA 46,20
0046E:  DATA 75,73
00470:  DATA 65,20
00472:  DATA 72,65
00474:  DATA 71,75
00476:  DATA 65,73
00478:  DATA 74,20
0047A:  DATA 61,6C
0047C:  DATA 6C,6F
0047E:  DATA 77,65
00480:  DATA 64,0D
00482:  DATA 0A,00
00484:  DATA 53,4D
00486:  DATA 46,20
00488:  DATA 75,73
0048A:  DATA 65,20
0048C:  DATA 72,65
0048E:  DATA 71,75
00490:  DATA 65,73
00492:  DATA 74,20
00494:  DATA 64,65
00496:  DATA 6E,79
00498:  DATA 65,64
0049A:  DATA 0D,0A
0049C:  DATA 00,00
0049E:  DATA 52,65
004A0:  DATA 74,72
004A2:  DATA 79,20
004A4:  DATA 72,65
004A6:  DATA 71,75
004A8:  DATA 65,73
004AA:  DATA 74,20
004AC:  DATA 74,6F
004AE:  DATA 20,42
004B0:  DATA 4F,53
004B2:  DATA 53,20
004B4:  DATA 50,49
004B6:  DATA 43,0D
004B8:  DATA 0A,00
004BA:  DATA 45,72
004BC:  DATA 72,6F
004BE:  DATA 72,21
004C0:  DATA 20,52
004C2:  DATA 65,63
004C4:  DATA 65,69
004C6:  DATA 76,69
004C8:  DATA 6E,67
004CA:  DATA 20,63
004CC:  DATA 6F,6D
004CE:  DATA 6D,61
004D0:  DATA 6E,64
004D2:  DATA 20,69
004D4:  DATA 6E,63
004D6:  DATA 6F,6E
004D8:  DATA 73,69
004DA:  DATA 73,74
004DC:  DATA 65,6E
004DE:  DATA 74,20
004E0:  DATA 77,69
004E2:  DATA 74,68
004E4:  DATA 20,74
004E6:  DATA 68,65
004E8:  DATA 20,64
004EA:  DATA 65,73
004EC:  DATA 69,67
004EE:  DATA 6E,0D
004F0:  DATA 0A,00
004F2:  DATA 45,6E
004F4:  DATA 64,20
004F6:  DATA 53,4D
004F8:  DATA 46,20
004FA:  DATA 75,73
004FC:  DATA 69,6E
004FE:  DATA 67,20
00500:  DATA 72,65
00502:  DATA 71,65
00504:  DATA 73,74
00506:  DATA 20,73
00508:  DATA 65,61
0050A:  DATA 71,75
0050C:  DATA 65,6E
0050E:  DATA 63,65
00510:  DATA 0D,0A
00512:  DATA 00,00
00514:  DATA 73,77
00516:  DATA 65,65
00518:  DATA 70,20
0051A:  DATA 73,74
0051C:  DATA 65,70
0051E:  DATA 20,3A
00520:  DATA 20,25
00522:  DATA 30,34
00524:  DATA 4C,58
00526:  DATA 0D,0A
00528:  DATA 00,00
0052A:  DATA 70,6F
0052C:  DATA 72,74
0052E:  DATA 31,0D
00530:  DATA 0A,00
00532:  DATA 70,6F
00534:  DATA 72,74
00536:  DATA 32,0D
00538:  DATA 0A,00
0053A:  DATA 5B,50
0053C:  DATA 49,43
0053E:  DATA 4C,4F
00540:  DATA 47,5D
00542:  DATA 20,3A
00544:  DATA 20,00
00546:  DATA 43,52
00548:  DATA 43,20
0054A:  DATA 76,65
0054C:  DATA 72,69
0054E:  DATA 66,69
00550:  DATA 63,61
00552:  DATA 74,69
00554:  DATA 6F,6E
00556:  DATA 20,70
00558:  DATA 61,73
0055A:  DATA 73,65
0055C:  DATA 64,20
0055E:  DATA 6F,6E
00560:  DATA 20,61
00562:  DATA 74,74
00564:  DATA 65,6D
00566:  DATA 70,74
00568:  DATA 20,25
0056A:  DATA 75,0D
0056C:  DATA 0A,00
0056E:  DATA 43,52
00570:  DATA 43,20
00572:  DATA 76,65
00574:  DATA 72,69
00576:  DATA 66,69
00578:  DATA 63,61
0057A:  DATA 74,69
0057C:  DATA 6F,6E
0057E:  DATA 20,70
00580:  DATA 61,73
00582:  DATA 73,65
00584:  DATA 64,20
00586:  DATA 6F,6E
00588:  DATA 20,61
0058A:  DATA 74,74
0058C:  DATA 65,6D
0058E:  DATA 70,74
00590:  DATA 20,25
00592:  DATA 64,0D
00594:  DATA 0A,00
00596:  DATA 45,72
00598:  DATA 72,6F
0059A:  DATA 72,3A
0059C:  DATA 20,43
0059E:  DATA 52,43
005A0:  DATA 20,76
005A2:  DATA 65,72
005A4:  DATA 69,66
005A6:  DATA 69,63
005A8:  DATA 61,74
005AA:  DATA 69,6F
005AC:  DATA 6E,20
005AE:  DATA 66,61
005B0:  DATA 69,6C
005B2:  DATA 65,64
005B4:  DATA 20,61
005B6:  DATA 66,74
005B8:  DATA 65,72
005BA:  DATA 20,25
005BC:  DATA 64,20
005BE:  DATA 61,74
005C0:  DATA 74,65
005C2:  DATA 6D,70
005C4:  DATA 74,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 0D,0A
005CC:  DATA 5F,5F
005CE:  DATA 5F,5F
005D0:  DATA 5F,5F
005D2:  DATA 5F,5F
005D4:  DATA 5F,5F
005D6:  DATA 5F,5F
005D8:  DATA 5F,5F
005DA:  DATA 5F,5F
005DC:  DATA 5F,5F
005DE:  DATA 5F,5F
005E0:  DATA 0D,0A
005E2:  DATA 00,00
005E4:  DATA 5F,5F
005E6:  DATA 5F,5F
005E8:  DATA 5F,53
005EA:  DATA 74,61
005EC:  DATA 72,74
005EE:  DATA 20,63
005F0:  DATA 6F,70
005F2:  DATA 79,5F
005F4:  DATA 64,61
005F6:  DATA 74,61
005F8:  DATA 5F,5F
005FA:  DATA 5F,5F
005FC:  DATA 0D,0A
005FE:  DATA 00,00
00600:  DATA 45,72
00602:  DATA 72,6F
00604:  DATA 72,3A
00606:  DATA 20,4D
00608:  DATA 49,53
0060A:  DATA 20,46
0060C:  DATA 4D,20
0060E:  DATA 69,73
00610:  DATA 20,6E
00612:  DATA 6F,74
00614:  DATA 20,63
00616:  DATA 6F,6E
00618:  DATA 6E,65
0061A:  DATA 63,74
0061C:  DATA 65,64
0061E:  DATA 0D,0A
00620:  DATA 00,00
00622:  DATA 45,72
00624:  DATA 72,6F
00626:  DATA 72,3A
00628:  DATA 20,53
0062A:  DATA 4D,46
0062C:  DATA 20,69
0062E:  DATA 73,20
00630:  DATA 6E,6F
00632:  DATA 74,20
00634:  DATA 63,6F
00636:  DATA 6E,6E
00638:  DATA 65,63
0063A:  DATA 74,65
0063C:  DATA 64,0D
0063E:  DATA 0A,00
00640:  DATA 53,69
00642:  DATA 7A,65
00644:  DATA 20,61
00646:  DATA 72,65
00648:  DATA 61,20
0064A:  DATA 72,65
0064C:  DATA 61,64
0064E:  DATA 0D,0A
00650:  DATA 00,00
00652:  DATA 73,6D
00654:  DATA 66,5F
00656:  DATA 75,73
00658:  DATA 65,64
0065A:  DATA 5F,73
0065C:  DATA 69,7A
0065E:  DATA 65,20
00660:  DATA 3D,20
00662:  DATA 25,6C
00664:  DATA 64,20
00666:  DATA 28,73
00668:  DATA 72,63
0066A:  DATA 20,30
0066C:  DATA 78,25
0066E:  DATA 30,38
00670:  DATA 4C,58
00672:  DATA 29,0D
00674:  DATA 0A,00
00676:  DATA 73,6D
00678:  DATA 66,5F
0067A:  DATA 6C,6F
0067C:  DATA 6F,70
0067E:  DATA 20,63
00680:  DATA 6F,75
00682:  DATA 6E,74
00684:  DATA 3D,20
00686:  DATA 25,64
00688:  DATA 20,20
0068A:  DATA 28,73
0068C:  DATA 72,63
0068E:  DATA 20,30
00690:  DATA 78,25
00692:  DATA 30,38
00694:  DATA 4C,58
00696:  DATA 29,0D
00698:  DATA 0A,00
0069A:  DATA 6D,69
0069C:  DATA 73,66
0069E:  DATA 5F,77
006A0:  DATA 72,69
006A2:  DATA 74,65
006A4:  DATA 5F,73
006A6:  DATA 6F,75
006A8:  DATA 72,63
006AA:  DATA 65,20
006AC:  DATA 3D,20
006AE:  DATA 30,78
006B0:  DATA 25,30
006B2:  DATA 38,4C
006B4:  DATA 58,0D
006B6:  DATA 0A,00
006B8:  DATA 6D,69
006BA:  DATA 73,66
006BC:  DATA 5F,77
006BE:  DATA 72,69
006C0:  DATA 74,65
006C2:  DATA 5F,73
006C4:  DATA 69,7A
006C6:  DATA 65,20
006C8:  DATA 3D,20
006CA:  DATA 30,78
006CC:  DATA 25,30
006CE:  DATA 38,4C
006D0:  DATA 58,0D
006D2:  DATA 0A,00
006D4:  DATA 57,72
006D6:  DATA 61,70
006D8:  DATA 20,74
006DA:  DATA 72,69
006DC:  DATA 67,67
006DE:  DATA 65,72
006E0:  DATA 65,64
006E2:  DATA 3A,20
006E4:  DATA 52,65
006E6:  DATA 73,65
006E8:  DATA 74,74
006EA:  DATA 69,6E
006EC:  DATA 67,20
006EE:  DATA 64,61
006F0:  DATA 74,61
006F2:  DATA 5F,77
006F4:  DATA 72,69
006F6:  DATA 74,65
006F8:  DATA 5F,61
006FA:  DATA 64,64
006FC:  DATA 72,20
006FE:  DATA 74,6F
00700:  DATA 20,73
00702:  DATA 74,61
00704:  DATA 72,74
00706:  DATA 0D,0A
00708:  DATA 00,00
0070A:  DATA 75,73
0070C:  DATA 65,64
0070E:  DATA 5F,73
00710:  DATA 69,7A
00712:  DATA 65,20
00714:  DATA 3D,20
00716:  DATA 25,6C
00718:  DATA 64,0D
0071A:  DATA 0A,00
0071C:  DATA 6C,6F
0071E:  DATA 6F,70
00720:  DATA 5F,63
00722:  DATA 6F,75
00724:  DATA 6E,74
00726:  DATA 20,3D
00728:  DATA 20,25
0072A:  DATA 75,0D
0072C:  DATA 0A,0D
0072E:  DATA 0A,00
00730:  DATA 0D,0A
00732:  DATA 5F,5F
00734:  DATA 5F,45
00736:  DATA 6E,64
00738:  DATA 20,63
0073A:  DATA 6F,70
0073C:  DATA 79,5F
0073E:  DATA 64,61
00740:  DATA 74,61
00742:  DATA 5F,5F
00744:  DATA 5F,5F
00746:  DATA 0D,0A
00748:  DATA 00,00
0074A:  DATA 5F,5F
0074C:  DATA 5F,5F
0074E:  DATA 5F,5F
00750:  DATA 5F,5F
00752:  DATA 5F,5F
00754:  DATA 5F,5F
00756:  DATA 5F,5F
00758:  DATA 5F,5F
0075A:  DATA 5F,5F
0075C:  DATA 5F,5F
0075E:  DATA 0D,0A
00760:  DATA 0D,0A
00762:  DATA 00,00
00764:  DATA 0D,0A
00766:  DATA 5F,5F
00768:  DATA 5F,5F
0076A:  DATA 5F,5F
0076C:  DATA 5F,5F
0076E:  DATA 5F,5F
00770:  DATA 5F,5F
00772:  DATA 5F,5F
00774:  DATA 5F,5F
00776:  DATA 5F,5F
00778:  DATA 5F,5F
0077A:  DATA 0D,0A
0077C:  DATA 00,00
0077E:  DATA 5F,5F
00780:  DATA 5F,53
00782:  DATA 74,61
00784:  DATA 72,74
00786:  DATA 20,53
00788:  DATA 4D,46
0078A:  DATA 20,52
0078C:  DATA 65,61
0078E:  DATA 64,5F
00790:  DATA 5F,5F
00792:  DATA 5F,0D
00794:  DATA 0A,00
00796:  DATA 49,6E
00798:  DATA 20,53
0079A:  DATA 4D,46
0079C:  DATA 20,52
0079E:  DATA 65,61
007A0:  DATA 64,20
007A2:  DATA 73,6F
007A4:  DATA 75,72
007A6:  DATA 63,65
007A8:  DATA 20,64
007AA:  DATA 61,74
007AC:  DATA 61,20
007AE:  DATA 61,64
007B0:  DATA 64,72
007B2:  DATA 65,73
007B4:  DATA 73,3A
007B6:  DATA 20,25
007B8:  DATA 4C,58
007BA:  DATA 0D,0A
007BC:  DATA 00,00
007BE:  DATA 49,6E
007C0:  DATA 20,53
007C2:  DATA 4D,46
007C4:  DATA 20,52
007C6:  DATA 65,61
007C8:  DATA 64,20
007CA:  DATA 64,61
007CC:  DATA 74,61
007CE:  DATA 20,73
007D0:  DATA 69,7A
007D2:  DATA 65,20
007D4:  DATA 20,20
007D6:  DATA 20,20
007D8:  DATA 20,20
007DA:  DATA 20,20
007DC:  DATA 20,3A
007DE:  DATA 20,25
007E0:  DATA 6C,75
007E2:  DATA 20,28
007E4:  DATA 30,78
007E6:  DATA 25,6C
007E8:  DATA 78,29
007EA:  DATA 0D,0A
007EC:  DATA 0D,0A
007EE:  DATA 00,00
007F0:  DATA 45,72
007F2:  DATA 72,6F
007F4:  DATA 72,3A
007F6:  DATA 20,53
007F8:  DATA 4D,46
007FA:  DATA 20,69
007FC:  DATA 73,20
007FE:  DATA 6E,6F
00800:  DATA 74,20
00802:  DATA 63,6F
00804:  DATA 6E,6E
00806:  DATA 65,63
00808:  DATA 74,65
0080A:  DATA 64,0D
0080C:  DATA 0A,00
0080E:  DATA 52,45
00810:  DATA 41,44
00812:  DATA 20,44
00814:  DATA 41,54
00816:  DATA 41,20
00818:  DATA 46,52
0081A:  DATA 4F,4D
0081C:  DATA 20,53
0081E:  DATA 4D,46
00820:  DATA 2E,2E
00822:  DATA 2E,0D
00824:  DATA 0A,00
00826:  DATA 0D,0A
00828:  DATA 5F,5F
0082A:  DATA 5F,45
0082C:  DATA 6E,64
0082E:  DATA 20,53
00830:  DATA 4D,46
00832:  DATA 20,52
00834:  DATA 65,61
00836:  DATA 64,5F
00838:  DATA 5F,5F
0083A:  DATA 5F,0D
0083C:  DATA 0A,00
0083E:  DATA 5F,5F
00840:  DATA 5F,5F
00842:  DATA 5F,5F
00844:  DATA 5F,5F
00846:  DATA 5F,5F
00848:  DATA 5F,5F
0084A:  DATA 5F,5F
0084C:  DATA 5F,5F
0084E:  DATA 5F,5F
00850:  DATA 5F,5F
00852:  DATA 0D,0A
00854:  DATA 0D,0A
00856:  DATA 00,00
00858:  DATA 0D,0A
0085A:  DATA 5F,5F
0085C:  DATA 5F,5F
0085E:  DATA 5F,5F
00860:  DATA 5F,5F
00862:  DATA 5F,5F
00864:  DATA 5F,5F
00866:  DATA 5F,5F
00868:  DATA 5F,5F
0086A:  DATA 5F,5F
0086C:  DATA 5F,5F
0086E:  DATA 0D,0A
00870:  DATA 00,00
00872:  DATA 5F,5F
00874:  DATA 5F,53
00876:  DATA 74,61
00878:  DATA 72,74
0087A:  DATA 20,73
0087C:  DATA 6D,66
0087E:  DATA 5F,65
00880:  DATA 72,61
00882:  DATA 73,65
00884:  DATA 5F,5F
00886:  DATA 5F,5F
00888:  DATA 0D,0A
0088A:  DATA 00,00
0088C:  DATA 49,6E
0088E:  DATA 20,53
00890:  DATA 4D,46
00892:  DATA 20,45
00894:  DATA 72,61
00896:  DATA 73,65
00898:  DATA 20,73
0089A:  DATA 6F,75
0089C:  DATA 72,63
0089E:  DATA 65,20
008A0:  DATA 64,61
008A2:  DATA 74,61
008A4:  DATA 20,61
008A6:  DATA 64,64
008A8:  DATA 72,65
008AA:  DATA 73,73
008AC:  DATA 3A,20
008AE:  DATA 25,4C
008B0:  DATA 58,0D
008B2:  DATA 0A,00
008B4:  DATA 49,6E
008B6:  DATA 20,53
008B8:  DATA 4D,46
008BA:  DATA 20,45
008BC:  DATA 72,61
008BE:  DATA 73,65
008C0:  DATA 20,64
008C2:  DATA 61,74
008C4:  DATA 61,20
008C6:  DATA 73,69
008C8:  DATA 7A,65
008CA:  DATA 20,20
008CC:  DATA 20,20
008CE:  DATA 20,20
008D0:  DATA 20,20
008D2:  DATA 20,20
008D4:  DATA 3A,20
008D6:  DATA 25,6C
008D8:  DATA 75,20
008DA:  DATA 28,30
008DC:  DATA 78,25
008DE:  DATA 6C,78
008E0:  DATA 29,0D
008E2:  DATA 0A,0D
008E4:  DATA 0A,00
008E6:  DATA 45,72
008E8:  DATA 72,6F
008EA:  DATA 72,3A
008EC:  DATA 20,53
008EE:  DATA 4D,46
008F0:  DATA 20,69
008F2:  DATA 73,20
008F4:  DATA 6E,6F
008F6:  DATA 74,20
008F8:  DATA 63,6F
008FA:  DATA 6E,6E
008FC:  DATA 65,63
008FE:  DATA 74,65
00900:  DATA 64,0D
00902:  DATA 0A,00
00904:  DATA 45,72
00906:  DATA 72,6F
00908:  DATA 72,3A
0090A:  DATA 20,45
0090C:  DATA 72,61
0090E:  DATA 73,65
00910:  DATA 20,73
00912:  DATA 6F,75
00914:  DATA 72,63
00916:  DATA 65,20
00918:  DATA 61,64
0091A:  DATA 64,72
0091C:  DATA 65,73
0091E:  DATA 73,20
00920:  DATA 30,78
00922:  DATA 25,4C
00924:  DATA 58,20
00926:  DATA 69,73
00928:  DATA 20,6F
0092A:  DATA 75,74
0092C:  DATA 73,69
0092E:  DATA 64,65
00930:  DATA 20,6D
00932:  DATA 69,73
00934:  DATA 73,69
00936:  DATA 6F,6E
00938:  DATA 20,72
0093A:  DATA 61,6E
0093C:  DATA 67,65
0093E:  DATA 20,5B
00940:  DATA 30,78
00942:  DATA 25,4C
00944:  DATA 58,20
00946:  DATA 2D,20
00948:  DATA 30,78
0094A:  DATA 25,4C
0094C:  DATA 58,5D
0094E:  DATA 0D,0A
00950:  DATA 00,00
00952:  DATA 45,72
00954:  DATA 72,6F
00956:  DATA 72,3A
00958:  DATA 20,45
0095A:  DATA 72,61
0095C:  DATA 73,65
0095E:  DATA 20,6F
00960:  DATA 70,65
00962:  DATA 72,61
00964:  DATA 74,69
00966:  DATA 6F,6E
00968:  DATA 20,77
0096A:  DATA 6F,75
0096C:  DATA 6C,64
0096E:  DATA 20,65
00970:  DATA 78,63
00972:  DATA 65,65
00974:  DATA 64,20
00976:  DATA 6D,69
00978:  DATA 73,73
0097A:  DATA 69,6F
0097C:  DATA 6E,20
0097E:  DATA 65,6E
00980:  DATA 64,20
00982:  DATA 61,64
00984:  DATA 64,72
00986:  DATA 65,73
00988:  DATA 73,20
0098A:  DATA 30,78
0098C:  DATA 25,4C
0098E:  DATA 58,0D
00990:  DATA 0A,00
00992:  DATA 4C,69
00994:  DATA 6D,69
00996:  DATA 74,69
00998:  DATA 6E,67
0099A:  DATA 20,65
0099C:  DATA 72,61
0099E:  DATA 73,65
009A0:  DATA 20,73
009A2:  DATA 69,7A
009A4:  DATA 65,20
009A6:  DATA 74,6F
009A8:  DATA 20,73
009AA:  DATA 74,61
009AC:  DATA 79,20
009AE:  DATA 77,69
009B0:  DATA 74,68
009B2:  DATA 69,6E
009B4:  DATA 20,6D
009B6:  DATA 69,73
009B8:  DATA 73,69
009BA:  DATA 6F,6E
009BC:  DATA 20,62
009BE:  DATA 6F,75
009C0:  DATA 6E,64
009C2:  DATA 73,0D
009C4:  DATA 0A,00
009C6:  DATA 45,72
009C8:  DATA 61,73
009CA:  DATA 65,20
009CC:  DATA 6F,70
009CE:  DATA 65,72
009D0:  DATA 61,74
009D2:  DATA 69,6F
009D4:  DATA 6E,20
009D6:  DATA 76,61
009D8:  DATA 6C,69
009DA:  DATA 64,61
009DC:  DATA 74,65
009DE:  DATA 64,20
009E0:  DATA 77,69
009E2:  DATA 74,68
009E4:  DATA 69,6E
009E6:  DATA 20,6D
009E8:  DATA 69,73
009EA:  DATA 73,69
009EC:  DATA 6F,6E
009EE:  DATA 20,72
009F0:  DATA 61,6E
009F2:  DATA 67,65
009F4:  DATA 0D,0A
009F6:  DATA 00,00
009F8:  DATA 0D,0A
009FA:  DATA 5F,5F
009FC:  DATA 5F,45
009FE:  DATA 6E,64
00A00:  DATA 20,73
00A02:  DATA 6D,66
00A04:  DATA 5F,65
00A06:  DATA 72,61
00A08:  DATA 73,65
00A0A:  DATA 5F,5F
00A0C:  DATA 5F,5F
00A0E:  DATA 0D,0A
00A10:  DATA 00,00
00A12:  DATA 5F,5F
00A14:  DATA 5F,5F
00A16:  DATA 5F,5F
00A18:  DATA 5F,5F
00A1A:  DATA 5F,5F
00A1C:  DATA 5F,5F
00A1E:  DATA 5F,5F
00A20:  DATA 5F,5F
00A22:  DATA 5F,5F
00A24:  DATA 5F,5F
00A26:  DATA 0D,0A
00A28:  DATA 0D,0A
00A2A:  DATA 00,00
00A2C:  DATA 45,72
00A2E:  DATA 72,6F
00A30:  DATA 72,3A
00A32:  DATA 20,55
00A34:  DATA 6E,6B
00A36:  DATA 6E,6F
00A38:  DATA 77,6E
00A3A:  DATA 20,6D
00A3C:  DATA 69,73
00A3E:  DATA 73,69
00A40:  DATA 6F,6E
00A42:  DATA 5F,69
00A44:  DATA 64,3A
00A46:  DATA 20,25
00A48:  DATA 30,32
00A4A:  DATA 58,0D
00A4C:  DATA 0A,00
00A4E:  DATA 55,70
00A50:  DATA 64,61
00A52:  DATA 74,65
00A54:  DATA 64,20
00A56:  DATA 70,61
00A58:  DATA 72,74
00A5A:  DATA 69,74
00A5C:  DATA 69,6F
00A5E:  DATA 6E,20
00A60:  DATA 66,6F
00A62:  DATA 72,20
00A64:  DATA 6D,69
00A66:  DATA 73,73
00A68:  DATA 69,6F
00A6A:  DATA 6E,5F
00A6C:  DATA 69,64
00A6E:  DATA 20,25
00A70:  DATA 30,32
00A72:  DATA 58,3A
00A74:  DATA 20,75
00A76:  DATA 73,65
00A78:  DATA 64,5F
00A7A:  DATA 73,69
00A7C:  DATA 7A,65
00A7E:  DATA 3D,25
00A80:  DATA 6C,64
00A82:  DATA 2C,20
00A84:  DATA 6C,6F
00A86:  DATA 6F,70
00A88:  DATA 5F,63
00A8A:  DATA 6F,75
00A8C:  DATA 6E,74
00A8E:  DATA 65,72
00A90:  DATA 3D,25
00A92:  DATA 6C,64
00A94:  DATA 0D,0A
00A96:  DATA 00,00
00A98:  DATA 4D,49
00A9A:  DATA 53,53
00A9C:  DATA 49,4F
00A9E:  DATA 4E,20
00AA0:  DATA 46,4C
00AA2:  DATA 41,53
00AA4:  DATA 48,20
00AA6:  DATA 49,6E
00AA8:  DATA 69,74
00AAA:  DATA 69,61
00AAC:  DATA 6C,69
00AAE:  DATA 7A,65
00AB0:  DATA 0D,0A
00AB2:  DATA 00,00
00AB4:  DATA 09,5B
00AB6:  DATA 4D,49
00AB8:  DATA 53,20
00ABA:  DATA 46,4D
00ABC:  DATA 5D,20
00ABE:  DATA 43,6F
00AC0:  DATA 6E,6E
00AC2:  DATA 65,63
00AC4:  DATA 74,65
00AC6:  DATA 64,0D
00AC8:  DATA 0A,00
00ACA:  DATA 09,5B
00ACC:  DATA 4D,49
00ACE:  DATA 53,20
00AD0:  DATA 46,4D
00AD2:  DATA 5D,20
00AD4:  DATA 4E,6F
00AD6:  DATA 74,20
00AD8:  DATA 43,6F
00ADA:  DATA 6E,6E
00ADC:  DATA 65,63
00ADE:  DATA 74,65
00AE0:  DATA 64,0D
00AE2:  DATA 0A,00
00AE4:  DATA 09,5B
00AE6:  DATA 53,4D
00AE8:  DATA 46,5D
00AEA:  DATA 20,43
00AEC:  DATA 6F,6E
00AEE:  DATA 6E,65
00AF0:  DATA 63,74
00AF2:  DATA 65,64
00AF4:  DATA 0D,0A
00AF6:  DATA 00,00
00AF8:  DATA 09,5B
00AFA:  DATA 53,4D
00AFC:  DATA 46,5D
00AFE:  DATA 20,4E
00B00:  DATA 6F,74
00B02:  DATA 20,43
00B04:  DATA 6F,6E
00B06:  DATA 6E,65
00B08:  DATA 63,74
00B0A:  DATA 65,64
00B0C:  DATA 0D,0A
00B0E:  DATA 00,00
00B10:  DATA 09,5B
00B12:  DATA 4D,49
00B14:  DATA 53,20
00B16:  DATA 46,4D
00B18:  DATA 5D,20
00B1A:  DATA 43,52
00B1C:  DATA 43,20
00B1E:  DATA 65,72
00B20:  DATA 72,6F
00B22:  DATA 72,20
00B24:  DATA 2D,3E
00B26:  DATA 20,69
00B28:  DATA 6E,69
00B2A:  DATA 74,69
00B2C:  DATA 61,6C
00B2E:  DATA 69,7A
00B30:  DATA 65,20
00B32:  DATA 63,6F
00B34:  DATA 75,6E
00B36:  DATA 74,65
00B38:  DATA 72,73
00B3A:  DATA 0D,0A
00B3C:  DATA 00,00
00B3E:  DATA 09,7C
00B40:  DATA 20,4D
00B42:  DATA 49,53
00B44:  DATA 46,20
00B46:  DATA 7C,20
00B48:  DATA 50,49
00B4A:  DATA 43,4C
00B4C:  DATA 4F,47
00B4E:  DATA 20,20
00B50:  DATA 20,20
00B52:  DATA 20,7C
00B54:  DATA 20,55
00B56:  DATA 73,65
00B58:  DATA 20,43
00B5A:  DATA 6F,75
00B5C:  DATA 6E,74
00B5E:  DATA 65,72
00B60:  DATA 20,20
00B62:  DATA 20,20
00B64:  DATA 20,20
00B66:  DATA 3A,20
00B68:  DATA 30,78
00B6A:  DATA 25,30
00B6C:  DATA 38,4C
00B6E:  DATA 58,0D
00B70:  DATA 0A,00
00B72:  DATA 09,7C
00B74:  DATA 20,4D
00B76:  DATA 49,53
00B78:  DATA 46,20
00B7A:  DATA 7C,20
00B7C:  DATA 50,49
00B7E:  DATA 43,4C
00B80:  DATA 4F,47
00B82:  DATA 20,20
00B84:  DATA 20,20
00B86:  DATA 20,7C
00B88:  DATA 20,55
00B8A:  DATA 6E,63
00B8C:  DATA 6F,70
00B8E:  DATA 79,65
00B90:  DATA 64,20
00B92:  DATA 43,6F
00B94:  DATA 75,6E
00B96:  DATA 74,65
00B98:  DATA 72,20
00B9A:  DATA 3A,20
00B9C:  DATA 30,78
00B9E:  DATA 25,30
00BA0:  DATA 38,4C
00BA2:  DATA 58,0D
00BA4:  DATA 0A,00
00BA6:  DATA 09,7C
00BA8:  DATA 20,4D
00BAA:  DATA 49,53
00BAC:  DATA 46,20
00BAE:  DATA 7C,20
00BB0:  DATA 50,49
00BB2:  DATA 43,4C
00BB4:  DATA 4F,47
00BB6:  DATA 20,20
00BB8:  DATA 20,20
00BBA:  DATA 20,7C
00BBC:  DATA 20,52
00BBE:  DATA 65,73
00BC0:  DATA 65,72
00BC2:  DATA 76,65
00BC4:  DATA 20,43
00BC6:  DATA 6F,75
00BC8:  DATA 6E,74
00BCA:  DATA 65,72
00BCC:  DATA 31,20
00BCE:  DATA 3A,20
00BD0:  DATA 30,78
00BD2:  DATA 25,30
00BD4:  DATA 32,58
00BD6:  DATA 0D,0A
00BD8:  DATA 00,00
00BDA:  DATA 09,7C
00BDC:  DATA 20,4D
00BDE:  DATA 49,53
00BE0:  DATA 46,20
00BE2:  DATA 7C,20
00BE4:  DATA 50,49
00BE6:  DATA 43,4C
00BE8:  DATA 4F,47
00BEA:  DATA 20,20
00BEC:  DATA 20,20
00BEE:  DATA 20,7C
00BF0:  DATA 20,52
00BF2:  DATA 65,73
00BF4:  DATA 65,72
00BF6:  DATA 76,65
00BF8:  DATA 20,43
00BFA:  DATA 6F,75
00BFC:  DATA 6E,74
00BFE:  DATA 65,72
00C00:  DATA 32,20
00C02:  DATA 3A,20
00C04:  DATA 30,78
00C06:  DATA 25,30
00C08:  DATA 32,58
00C0A:  DATA 0D,0A
00C0C:  DATA 00,00
00C0E:  DATA 09,7C
00C10:  DATA 20,4D
00C12:  DATA 49,53
00C14:  DATA 46,20
00C16:  DATA 7C,20
00C18:  DATA 45,4E
00C1A:  DATA 56,49
00C1C:  DATA 52,4F
00C1E:  DATA 20,20
00C20:  DATA 20,20
00C22:  DATA 20,7C
00C24:  DATA 20,55
00C26:  DATA 73,65
00C28:  DATA 20,43
00C2A:  DATA 6F,75
00C2C:  DATA 6E,74
00C2E:  DATA 65,72
00C30:  DATA 20,20
00C32:  DATA 20,20
00C34:  DATA 20,20
00C36:  DATA 3A,20
00C38:  DATA 30,78
00C3A:  DATA 25,30
00C3C:  DATA 38,4C
00C3E:  DATA 58,0D
00C40:  DATA 0A,00
00C42:  DATA 09,7C
00C44:  DATA 20,4D
00C46:  DATA 49,53
00C48:  DATA 46,20
00C4A:  DATA 7C,20
00C4C:  DATA 45,4E
00C4E:  DATA 56,49
00C50:  DATA 52,4F
00C52:  DATA 20,20
00C54:  DATA 20,20
00C56:  DATA 20,7C
00C58:  DATA 20,55
00C5A:  DATA 6E,63
00C5C:  DATA 6F,70
00C5E:  DATA 79,65
00C60:  DATA 64,20
00C62:  DATA 43,6F
00C64:  DATA 75,6E
00C66:  DATA 74,65
00C68:  DATA 72,20
00C6A:  DATA 3A,20
00C6C:  DATA 30,78
00C6E:  DATA 25,30
00C70:  DATA 38,4C
00C72:  DATA 58,0D
00C74:  DATA 0A,00
00C76:  DATA 09,7C
00C78:  DATA 20,4D
00C7A:  DATA 49,53
00C7C:  DATA 46,20
00C7E:  DATA 7C,20
00C80:  DATA 45,4E
00C82:  DATA 56,49
00C84:  DATA 52,4F
00C86:  DATA 20,20
00C88:  DATA 20,20
00C8A:  DATA 20,7C
00C8C:  DATA 20,52
00C8E:  DATA 65,73
00C90:  DATA 65,72
00C92:  DATA 76,65
00C94:  DATA 20,43
00C96:  DATA 6F,75
00C98:  DATA 6E,74
00C9A:  DATA 65,72
00C9C:  DATA 31,20
00C9E:  DATA 3A,20
00CA0:  DATA 30,78
00CA2:  DATA 25,30
00CA4:  DATA 32,58
00CA6:  DATA 0D,0A
00CA8:  DATA 00,00
00CAA:  DATA 09,7C
00CAC:  DATA 20,4D
00CAE:  DATA 49,53
00CB0:  DATA 46,20
00CB2:  DATA 7C,20
00CB4:  DATA 45,4E
00CB6:  DATA 56,49
00CB8:  DATA 52,4F
00CBA:  DATA 20,20
00CBC:  DATA 20,20
00CBE:  DATA 20,7C
00CC0:  DATA 20,52
00CC2:  DATA 65,73
00CC4:  DATA 65,72
00CC6:  DATA 76,65
00CC8:  DATA 20,43
00CCA:  DATA 6F,75
00CCC:  DATA 6E,74
00CCE:  DATA 65,72
00CD0:  DATA 32,20
00CD2:  DATA 3A,20
00CD4:  DATA 30,78
00CD6:  DATA 25,30
00CD8:  DATA 32,58
00CDA:  DATA 0D,0A
00CDC:  DATA 00,00
00CDE:  DATA 09,7C
00CE0:  DATA 20,4D
00CE2:  DATA 49,53
00CE4:  DATA 46,20
00CE6:  DATA 7C,20
00CE8:  DATA 49,56
00CEA:  DATA 31,20
00CEC:  DATA 48,45
00CEE:  DATA 41,44
00CF0:  DATA 45,52
00CF2:  DATA 20,7C
00CF4:  DATA 20,55
00CF6:  DATA 73,65
00CF8:  DATA 20,43
00CFA:  DATA 6F,75
00CFC:  DATA 6E,74
00CFE:  DATA 65,72
00D00:  DATA 20,20
00D02:  DATA 20,20
00D04:  DATA 20,20
00D06:  DATA 3A,20
00D08:  DATA 30,78
00D0A:  DATA 25,30
00D0C:  DATA 38,4C
00D0E:  DATA 58,0D
00D10:  DATA 0A,00
00D12:  DATA 09,7C
00D14:  DATA 20,4D
00D16:  DATA 49,53
00D18:  DATA 46,20
00D1A:  DATA 7C,20
00D1C:  DATA 49,56
00D1E:  DATA 31,20
00D20:  DATA 48,45
00D22:  DATA 41,44
00D24:  DATA 45,52
00D26:  DATA 20,7C
00D28:  DATA 20,55
00D2A:  DATA 6E,63
00D2C:  DATA 6F,70
00D2E:  DATA 79,65
00D30:  DATA 64,20
00D32:  DATA 43,6F
00D34:  DATA 75,6E
00D36:  DATA 74,65
00D38:  DATA 72,20
00D3A:  DATA 3A,20
00D3C:  DATA 30,78
00D3E:  DATA 25,30
00D40:  DATA 38,4C
00D42:  DATA 58,0D
00D44:  DATA 0A,00
00D46:  DATA 09,7C
00D48:  DATA 20,4D
00D4A:  DATA 49,53
00D4C:  DATA 46,20
00D4E:  DATA 7C,20
00D50:  DATA 49,56
00D52:  DATA 31,20
00D54:  DATA 48,45
00D56:  DATA 41,44
00D58:  DATA 45,52
00D5A:  DATA 20,7C
00D5C:  DATA 20,52
00D5E:  DATA 65,73
00D60:  DATA 65,72
00D62:  DATA 76,65
00D64:  DATA 20,43
00D66:  DATA 6F,75
00D68:  DATA 6E,74
00D6A:  DATA 65,72
00D6C:  DATA 31,20
00D6E:  DATA 3A,20
00D70:  DATA 30,78
00D72:  DATA 25,30
00D74:  DATA 32,58
00D76:  DATA 0D,0A
00D78:  DATA 00,00
00D7A:  DATA 09,7C
00D7C:  DATA 20,4D
00D7E:  DATA 49,53
00D80:  DATA 46,20
00D82:  DATA 7C,20
00D84:  DATA 49,56
00D86:  DATA 31,20
00D88:  DATA 48,45
00D8A:  DATA 41,44
00D8C:  DATA 45,52
00D8E:  DATA 20,7C
00D90:  DATA 20,52
00D92:  DATA 65,73
00D94:  DATA 65,72
00D96:  DATA 76,65
00D98:  DATA 20,43
00D9A:  DATA 6F,75
00D9C:  DATA 6E,74
00D9E:  DATA 65,72
00DA0:  DATA 32,20
00DA2:  DATA 3A,20
00DA4:  DATA 30,78
00DA6:  DATA 25,30
00DA8:  DATA 32,58
00DAA:  DATA 0D,0A
00DAC:  DATA 00,00
00DAE:  DATA 09,7C
00DB0:  DATA 20,4D
00DB2:  DATA 49,53
00DB4:  DATA 46,20
00DB6:  DATA 7C,20
00DB8:  DATA 49,56
00DBA:  DATA 31,20
00DBC:  DATA 44,41
00DBE:  DATA 54,41
00DC0:  DATA 20,20
00DC2:  DATA 20,7C
00DC4:  DATA 20,55
00DC6:  DATA 73,65
00DC8:  DATA 20,43
00DCA:  DATA 6F,75
00DCC:  DATA 6E,74
00DCE:  DATA 65,72
00DD0:  DATA 20,20
00DD2:  DATA 20,20
00DD4:  DATA 20,20
00DD6:  DATA 3A,20
00DD8:  DATA 30,78
00DDA:  DATA 25,30
00DDC:  DATA 38,4C
00DDE:  DATA 58,0D
00DE0:  DATA 0A,00
00DE2:  DATA 09,7C
00DE4:  DATA 20,4D
00DE6:  DATA 49,53
00DE8:  DATA 46,20
00DEA:  DATA 7C,20
00DEC:  DATA 49,56
00DEE:  DATA 31,20
00DF0:  DATA 44,41
00DF2:  DATA 54,41
00DF4:  DATA 20,20
00DF6:  DATA 20,7C
00DF8:  DATA 20,55
00DFA:  DATA 6E,63
00DFC:  DATA 6F,70
00DFE:  DATA 79,65
00E00:  DATA 64,20
00E02:  DATA 43,6F
00E04:  DATA 75,6E
00E06:  DATA 74,65
00E08:  DATA 72,20
00E0A:  DATA 3A,20
00E0C:  DATA 30,78
00E0E:  DATA 25,30
00E10:  DATA 38,4C
00E12:  DATA 58,0D
00E14:  DATA 0A,00
00E16:  DATA 09,7C
00E18:  DATA 20,4D
00E1A:  DATA 49,53
00E1C:  DATA 46,20
00E1E:  DATA 7C,20
00E20:  DATA 49,56
00E22:  DATA 31,20
00E24:  DATA 44,41
00E26:  DATA 54,41
00E28:  DATA 20,20
00E2A:  DATA 20,7C
00E2C:  DATA 20,52
00E2E:  DATA 65,73
00E30:  DATA 65,72
00E32:  DATA 76,65
00E34:  DATA 20,43
00E36:  DATA 6F,75
00E38:  DATA 6E,74
00E3A:  DATA 65,72
00E3C:  DATA 31,20
00E3E:  DATA 3A,20
00E40:  DATA 30,78
00E42:  DATA 25,30
00E44:  DATA 32,58
00E46:  DATA 0D,0A
00E48:  DATA 00,00
00E4A:  DATA 09,7C
00E4C:  DATA 20,4D
00E4E:  DATA 49,53
00E50:  DATA 46,20
00E52:  DATA 7C,20
00E54:  DATA 49,56
00E56:  DATA 31,20
00E58:  DATA 44,41
00E5A:  DATA 54,41
00E5C:  DATA 20,20
00E5E:  DATA 20,7C
00E60:  DATA 20,52
00E62:  DATA 65,73
00E64:  DATA 65,72
00E66:  DATA 76,65
00E68:  DATA 20,43
00E6A:  DATA 6F,75
00E6C:  DATA 6E,74
00E6E:  DATA 65,72
00E70:  DATA 32,20
00E72:  DATA 3A,20
00E74:  DATA 30,78
00E76:  DATA 25,30
00E78:  DATA 32,58
00E7A:  DATA 0D,0A
00E7C:  DATA 00,00
00E7E:  DATA 09,7C
00E80:  DATA 20,4D
00E82:  DATA 49,53
00E84:  DATA 46,20
00E86:  DATA 7C,20
00E88:  DATA 49,56
00E8A:  DATA 32,20
00E8C:  DATA 48,45
00E8E:  DATA 41,44
00E90:  DATA 45,52
00E92:  DATA 20,7C
00E94:  DATA 20,55
00E96:  DATA 73,65
00E98:  DATA 20,43
00E9A:  DATA 6F,75
00E9C:  DATA 6E,74
00E9E:  DATA 65,72
00EA0:  DATA 20,20
00EA2:  DATA 20,20
00EA4:  DATA 20,20
00EA6:  DATA 3A,20
00EA8:  DATA 30,78
00EAA:  DATA 25,30
00EAC:  DATA 38,4C
00EAE:  DATA 58,0D
00EB0:  DATA 0A,00
00EB2:  DATA 09,7C
00EB4:  DATA 20,4D
00EB6:  DATA 49,53
00EB8:  DATA 46,20
00EBA:  DATA 7C,20
00EBC:  DATA 49,56
00EBE:  DATA 32,20
00EC0:  DATA 48,45
00EC2:  DATA 41,44
00EC4:  DATA 45,52
00EC6:  DATA 20,7C
00EC8:  DATA 20,55
00ECA:  DATA 6E,63
00ECC:  DATA 6F,70
00ECE:  DATA 79,65
00ED0:  DATA 64,20
00ED2:  DATA 43,6F
00ED4:  DATA 75,6E
00ED6:  DATA 74,65
00ED8:  DATA 72,20
00EDA:  DATA 3A,20
00EDC:  DATA 30,78
00EDE:  DATA 25,30
00EE0:  DATA 38,4C
00EE2:  DATA 58,0D
00EE4:  DATA 0A,00
00EE6:  DATA 09,7C
00EE8:  DATA 20,4D
00EEA:  DATA 49,53
00EEC:  DATA 46,20
00EEE:  DATA 7C,20
00EF0:  DATA 49,56
00EF2:  DATA 32,20
00EF4:  DATA 48,45
00EF6:  DATA 41,44
00EF8:  DATA 45,52
00EFA:  DATA 20,7C
00EFC:  DATA 20,52
00EFE:  DATA 65,73
00F00:  DATA 65,72
00F02:  DATA 76,65
00F04:  DATA 20,43
00F06:  DATA 6F,75
00F08:  DATA 6E,74
00F0A:  DATA 65,72
00F0C:  DATA 31,20
00F0E:  DATA 3A,20
00F10:  DATA 30,78
00F12:  DATA 25,30
00F14:  DATA 32,58
00F16:  DATA 0D,0A
00F18:  DATA 00,00
00F1A:  DATA 09,7C
00F1C:  DATA 20,4D
00F1E:  DATA 49,53
00F20:  DATA 46,20
00F22:  DATA 7C,20
00F24:  DATA 49,56
00F26:  DATA 32,20
00F28:  DATA 48,45
00F2A:  DATA 41,44
00F2C:  DATA 45,52
00F2E:  DATA 20,7C
00F30:  DATA 20,52
00F32:  DATA 65,73
00F34:  DATA 65,72
00F36:  DATA 76,65
00F38:  DATA 20,43
00F3A:  DATA 6F,75
00F3C:  DATA 6E,74
00F3E:  DATA 65,72
00F40:  DATA 32,20
00F42:  DATA 3A,20
00F44:  DATA 30,78
00F46:  DATA 25,30
00F48:  DATA 32,58
00F4A:  DATA 0D,0A
00F4C:  DATA 00,00
00F4E:  DATA 09,7C
00F50:  DATA 20,4D
00F52:  DATA 49,53
00F54:  DATA 46,20
00F56:  DATA 7C,20
00F58:  DATA 49,56
00F5A:  DATA 32,20
00F5C:  DATA 44,41
00F5E:  DATA 54,41
00F60:  DATA 20,20
00F62:  DATA 20,7C
00F64:  DATA 20,55
00F66:  DATA 73,65
00F68:  DATA 20,43
00F6A:  DATA 6F,75
00F6C:  DATA 6E,74
00F6E:  DATA 65,72
00F70:  DATA 20,20
00F72:  DATA 20,20
00F74:  DATA 20,20
00F76:  DATA 3A,20
00F78:  DATA 30,78
00F7A:  DATA 25,30
00F7C:  DATA 38,4C
00F7E:  DATA 58,0D
00F80:  DATA 0A,00
00F82:  DATA 09,7C
00F84:  DATA 20,4D
00F86:  DATA 49,53
00F88:  DATA 46,20
00F8A:  DATA 7C,20
00F8C:  DATA 49,56
00F8E:  DATA 32,20
00F90:  DATA 44,41
00F92:  DATA 54,41
00F94:  DATA 20,20
00F96:  DATA 20,7C
00F98:  DATA 20,55
00F9A:  DATA 6E,63
00F9C:  DATA 6F,70
00F9E:  DATA 79,65
00FA0:  DATA 64,20
00FA2:  DATA 43,6F
00FA4:  DATA 75,6E
00FA6:  DATA 74,65
00FA8:  DATA 72,20
00FAA:  DATA 3A,20
00FAC:  DATA 30,78
00FAE:  DATA 25,30
00FB0:  DATA 38,4C
00FB2:  DATA 58,0D
00FB4:  DATA 0A,00
00FB6:  DATA 09,7C
00FB8:  DATA 20,4D
00FBA:  DATA 49,53
00FBC:  DATA 46,20
00FBE:  DATA 7C,20
00FC0:  DATA 49,56
00FC2:  DATA 32,20
00FC4:  DATA 44,41
00FC6:  DATA 54,41
00FC8:  DATA 20,20
00FCA:  DATA 20,7C
00FCC:  DATA 20,52
00FCE:  DATA 65,73
00FD0:  DATA 65,72
00FD2:  DATA 76,65
00FD4:  DATA 20,43
00FD6:  DATA 6F,75
00FD8:  DATA 6E,74
00FDA:  DATA 65,72
00FDC:  DATA 31,20
00FDE:  DATA 3A,20
00FE0:  DATA 30,78
00FE2:  DATA 25,30
00FE4:  DATA 32,58
00FE6:  DATA 0D,0A
00FE8:  DATA 00,00
00FEA:  DATA 09,7C
00FEC:  DATA 20,4D
00FEE:  DATA 49,53
00FF0:  DATA 46,20
00FF2:  DATA 7C,20
00FF4:  DATA 49,56
00FF6:  DATA 32,20
00FF8:  DATA 44,41
00FFA:  DATA 54,41
00FFC:  DATA 20,20
00FFE:  DATA 20,7C
01000:  DATA 20,52
01002:  DATA 65,73
01004:  DATA 65,72
01006:  DATA 76,65
01008:  DATA 20,43
0100A:  DATA 6F,75
0100C:  DATA 6E,74
0100E:  DATA 65,72
01010:  DATA 32,20
01012:  DATA 3A,20
01014:  DATA 30,78
01016:  DATA 25,30
01018:  DATA 32,58
0101A:  DATA 0D,0A
0101C:  DATA 00,00
0101E:  DATA 09,43
01020:  DATA 6F,6D
01022:  DATA 70,6C
01024:  DATA 65,74
01026:  DATA 65,0D
01028:  DATA 0A,00
0102A:  DATA 43,52
0102C:  DATA 43,20
0102E:  DATA 76,65
01030:  DATA 72,69
01032:  DATA 66,69
01034:  DATA 63,61
01036:  DATA 74,69
01038:  DATA 6F,6E
0103A:  DATA 20,70
0103C:  DATA 61,73
0103E:  DATA 73,65
01040:  DATA 64,20
01042:  DATA 6F,6E
01044:  DATA 20,61
01046:  DATA 74,74
01048:  DATA 65,6D
0104A:  DATA 70,74
0104C:  DATA 20,25
0104E:  DATA 64,0D
01050:  DATA 0A,00
01052:  DATA 45,72
01054:  DATA 72,6F
01056:  DATA 72,3A
01058:  DATA 20,43
0105A:  DATA 52,43
0105C:  DATA 20,76
0105E:  DATA 65,72
01060:  DATA 69,66
01062:  DATA 69,63
01064:  DATA 61,74
01066:  DATA 69,6F
01068:  DATA 6E,20
0106A:  DATA 66,61
0106C:  DATA 69,6C
0106E:  DATA 65,64
01070:  DATA 20,61
01072:  DATA 66,74
01074:  DATA 65,72
01076:  DATA 20,25
01078:  DATA 64,20
0107A:  DATA 61,74
0107C:  DATA 74,65
0107E:  DATA 6D,70
01080:  DATA 74,73
01082:  DATA 0D,0A
01084:  DATA 00,00
01086:  DATA 0D,0A
01088:  DATA 5F,5F
0108A:  DATA 5F,5F
0108C:  DATA 5F,5F
0108E:  DATA 5F,5F
01090:  DATA 5F,5F
01092:  DATA 5F,5F
01094:  DATA 5F,5F
01096:  DATA 5F,5F
01098:  DATA 5F,5F
0109A:  DATA 5F,5F
0109C:  DATA 5F,5F
0109E:  DATA 5F,5F
010A0:  DATA 5F,5F
010A2:  DATA 5F,5F
010A4:  DATA 5F,5F
010A6:  DATA 0D,0A
010A8:  DATA 5F,5F
010AA:  DATA 5F,5F
010AC:  DATA 5F,53
010AE:  DATA 74,61
010B0:  DATA 72,74
010B2:  DATA 20,65
010B4:  DATA 78,65
010B6:  DATA 63,75
010B8:  DATA 74,65
010BA:  DATA 5F,6D
010BC:  DATA 69,73
010BE:  DATA 73,69
010C0:  DATA 6F,6E
010C2:  DATA 5F,5F
010C4:  DATA 5F,5F
010C6:  DATA 5F,0D
010C8:  DATA 0A,0D
010CA:  DATA 0A,00
010CC:  DATA 43,6F
010CE:  DATA 6D,6D
010D0:  DATA 61,6E
010D2:  DATA 64,20
010D4:  DATA 49,44
010D6:  DATA 3A,20
010D8:  DATA 25,58
010DA:  DATA 0D,0A
010DC:  DATA 0D,0A
010DE:  DATA 00,00
010E0:  DATA 09,09
010E2:  DATA 2D,3E
010E4:  DATA 20,49
010E6:  DATA 6E,76
010E8:  DATA 61,6C
010EA:  DATA 69,64
010EC:  DATA 20,43
010EE:  DATA 4D,44
010F0:  DATA 20,49
010F2:  DATA 44,21
010F4:  DATA 0D,0A
010F6:  DATA 00,00
010F8:  DATA 0D,0A
010FA:  DATA 5F,5F
010FC:  DATA 5F,5F
010FE:  DATA 5F,5F
01100:  DATA 45,6E
01102:  DATA 64,20
01104:  DATA 65,78
01106:  DATA 65,63
01108:  DATA 75,74
0110A:  DATA 65,5F
0110C:  DATA 6D,69
0110E:  DATA 73,73
01110:  DATA 69,6F
01112:  DATA 6E,5F
01114:  DATA 5F,5F
01116:  DATA 5F,5F
01118:  DATA 5F,0D
0111A:  DATA 0A,5F
0111C:  DATA 5F,5F
0111E:  DATA 5F,5F
01120:  DATA 5F,5F
01122:  DATA 5F,5F
01124:  DATA 5F,5F
01126:  DATA 5F,5F
01128:  DATA 5F,5F
0112A:  DATA 5F,5F
0112C:  DATA 5F,5F
0112E:  DATA 5F,5F
01130:  DATA 5F,5F
01132:  DATA 5F,5F
01134:  DATA 5F,5F
01136:  DATA 5F,5F
01138:  DATA 5F,5F
0113A:  DATA 0D,0A
0113C:  DATA 00,00
0113E:  DATA 53,74
01140:  DATA 61,72
01142:  DATA 74,20
01144:  DATA 65,78
01146:  DATA 65,63
01148:  DATA 75,74
0114A:  DATA 65,5F
0114C:  DATA 63,6F
0114E:  DATA 6D,6D
01150:  DATA 61,6E
01152:  DATA 64,0D
01154:  DATA 0A,00
01156:  DATA 09,2D
01158:  DATA 3E,20
0115A:  DATA 55,70
0115C:  DATA 6C,69
0115E:  DATA 6E,6B
01160:  DATA 20,63
01162:  DATA 6F,6D
01164:  DATA 6D,61
01166:  DATA 6E,64
01168:  DATA 0D,0A
0116A:  DATA 00,00
0116C:  DATA 09,20
0116E:  DATA 20,20
01170:  DATA 54,72
01172:  DATA 61,6E
01174:  DATA 73,6D
01176:  DATA 69,74
01178:  DATA 20,41
0117A:  DATA 63,6B
0117C:  DATA 6E,6F
0117E:  DATA 6C,65
01180:  DATA 67,64
01182:  DATA 65,0D
01184:  DATA 0A,00
01186:  DATA 09,2D
01188:  DATA 3E,20
0118A:  DATA 53,74
0118C:  DATA 61,74
0118E:  DATA 75,73
01190:  DATA 20,63
01192:  DATA 68,65
01194:  DATA 63,6B
01196:  DATA 0D,0A
01198:  DATA 00,00
0119A:  DATA 09,20
0119C:  DATA 20,20
0119E:  DATA 54,72
011A0:  DATA 61,6E
011A2:  DATA 73,6D
011A4:  DATA 69,74
011A6:  DATA 20,4D
011A8:  DATA 49,53
011AA:  DATA 20,4D
011AC:  DATA 43,55
011AE:  DATA 20,53
011B0:  DATA 74,61
011B2:  DATA 74,75
011B4:  DATA 73,0D
011B6:  DATA 0A,00
011B8:  DATA 66,69
011BA:  DATA 6E,69
011BC:  DATA 73,68
011BE:  DATA 65,64
011C0:  DATA 20,69
011C2:  DATA 6E,20
011C4:  DATA 73,74
011C6:  DATA 61,74
011C8:  DATA 75,73
011CA:  DATA 5F,63
011CC:  DATA 68,65
011CE:  DATA 63,6B
011D0:  DATA 0D,0A
011D2:  DATA 00,00
011D4:  DATA 09,2D
011D6:  DATA 3E,20
011D8:  DATA 53,4D
011DA:  DATA 46,20
011DC:  DATA 61,76
011DE:  DATA 61,69
011E0:  DATA 6C,61
011E2:  DATA 62,6C
011E4:  DATA 65,20
011E6:  DATA 63,68
011E8:  DATA 65,63
011EA:  DATA 6B,0D
011EC:  DATA 0A,00
011EE:  DATA 09,20
011F0:  DATA 20,20
011F2:  DATA 54,72
011F4:  DATA 61,6E
011F6:  DATA 73,6D
011F8:  DATA 69,74
011FA:  DATA 20,41
011FC:  DATA 63,6B
011FE:  DATA 6E,6F
01200:  DATA 77,6C
01202:  DATA 65,64
01204:  DATA 67,65
01206:  DATA 6D,65
01208:  DATA 6E,74
0120A:  DATA 0D,0A
0120C:  DATA 00,00
0120E:  DATA 09,09
01210:  DATA 2D,3E
01212:  DATA 20,64
01214:  DATA 65,6E
01216:  DATA 69,65
01218:  DATA 64,0D
0121A:  DATA 0A,00
0121C:  DATA 09,09
0121E:  DATA 2D,3E
01220:  DATA 20,61
01222:  DATA 6C,6C
01224:  DATA 6F,77
01226:  DATA 65,64
01228:  DATA 0D,0A
0122A:  DATA 00,00
0122C:  DATA 09,09
0122E:  DATA 2D,3E
01230:  DATA 20,64
01232:  DATA 65,71
01234:  DATA 75,65
01236:  DATA 75,65
01238:  DATA 20,4E
0123A:  DATA 55,4C
0123C:  DATA 4C,20
0123E:  DATA 28,62
01240:  DATA 72,65
01242:  DATA 61,6B
01244:  DATA 29,0D
01246:  DATA 0A,00
01248:  DATA 09,09
0124A:  DATA 2D,3E
0124C:  DATA 20,44
0124E:  DATA 65,71
01250:  DATA 75,65
01252:  DATA 75,65
01254:  DATA 64,3A
01256:  DATA 20,66
01258:  DATA 75,6E
0125A:  DATA 63,3D
0125C:  DATA 25,75
0125E:  DATA 20,6D
01260:  DATA 69,73
01262:  DATA 73,69
01264:  DATA 6F,6E
01266:  DATA 3D,25
01268:  DATA 75,20
0126A:  DATA 73,69
0126C:  DATA 7A,65
0126E:  DATA 3D,25
01270:  DATA 6C,64
01272:  DATA 20,61
01274:  DATA 64,64
01276:  DATA 72,3D
01278:  DATA 25,6C
0127A:  DATA 64,0D
0127C:  DATA 0A,00
0127E:  DATA 09,09
01280:  DATA 20,20
01282:  DATA 20,55
01284:  DATA 6E,6B
01286:  DATA 6E,6F
01288:  DATA 77,6E
0128A:  DATA 20,66
0128C:  DATA 75,6E
0128E:  DATA 63,5F
01290:  DATA 74,79
01292:  DATA 70,65
01294:  DATA 3D,25
01296:  DATA 75,0D
01298:  DATA 0A,00
0129A:  DATA 09,09
0129C:  DATA 2D,3E
0129E:  DATA 20,43
012A0:  DATA 6F,6D
012A2:  DATA 70,6C
012A4:  DATA 65,74
012A6:  DATA 65,64
012A8:  DATA 20,25
012AA:  DATA 75,20
012AC:  DATA 6F,70
012AE:  DATA 65,72
012B0:  DATA 61,74
012B2:  DATA 69,6F
012B4:  DATA 6E,73
012B6:  DATA 0D,0A
012B8:  DATA 00,00
012BA:  DATA 53,74
012BC:  DATA 61,72
012BE:  DATA 74,20
012C0:  DATA 4D,4F
012C2:  DATA 44,45
012C4:  DATA 20,4D
012C6:  DATA 45,41
012C8:  DATA 53,20
012CA:  DATA 49,56
012CC:  DATA 0D,0A
012CE:  DATA 00,00
012D0:  DATA 09,49
012D2:  DATA 44,3A
012D4:  DATA 20,25
012D6:  DATA 30,32
012D8:  DATA 58,0D
012DA:  DATA 0A,00
012DC:  DATA 09,53
012DE:  DATA 6C,65
012E0:  DATA 65,70
012E2:  DATA 20,54
012E4:  DATA 69,6D
012E6:  DATA 65,3A
012E8:  DATA 20,25
012EA:  DATA 30,34
012EC:  DATA 4C,58
012EE:  DATA 20,6D
012F0:  DATA 73,0D
012F2:  DATA 0A,00
012F4:  DATA 09,43
012F6:  DATA 75,72
012F8:  DATA 72,65
012FA:  DATA 6E,74
012FC:  DATA 20,54
012FE:  DATA 68,72
01300:  DATA 65,73
01302:  DATA 68,6F
01304:  DATA 6C,64
01306:  DATA 3A,20
01308:  DATA 25,30
0130A:  DATA 34,4C
0130C:  DATA 58,20
0130E:  DATA 6D,41
01310:  DATA 0D,0A
01312:  DATA 00,00
01314:  DATA 09,50
01316:  DATA 44,20
01318:  DATA 54,68
0131A:  DATA 72,65
0131C:  DATA 73,68
0131E:  DATA 6F,6C
01320:  DATA 64,3A
01322:  DATA 20,25
01324:  DATA 30,34
01326:  DATA 4C,58
01328:  DATA 20,6D
0132A:  DATA 41,0D
0132C:  DATA 0A,00
0132E:  DATA 09,43
01330:  DATA 75,72
01332:  DATA 72,65
01334:  DATA 6E,74
01336:  DATA 20,4C
01338:  DATA 69,6D
0133A:  DATA 69,74
0133C:  DATA 3A,20
0133E:  DATA 25,30
01340:  DATA 34,4C
01342:  DATA 58,20
01344:  DATA 6D,41
01346:  DATA 0D,0A
01348:  DATA 00,00
0134A:  DATA 09,4D
0134C:  DATA 65,61
0134E:  DATA 73,75
01350:  DATA 72,65
01352:  DATA 6D,65
01354:  DATA 6E,74
01356:  DATA 20,54
01358:  DATA 69,6D
0135A:  DATA 65,3A
0135C:  DATA 20,25
0135E:  DATA 30,34
01360:  DATA 4C,58
01362:  DATA 20,73
01364:  DATA 0D,0A
01366:  DATA 00,00
01368:  DATA 45,6E
0136A:  DATA 71,75
0136C:  DATA 65,75
0136E:  DATA 65,20
01370:  DATA 46,6C
01372:  DATA 61,73
01374:  DATA 68,20
01376:  DATA 4F,70
01378:  DATA 65,72
0137A:  DATA 61,74
0137C:  DATA 69,6F
0137E:  DATA 6E,0D
01380:  DATA 0A,00
01382:  DATA 4D,69
01384:  DATA 73,73
01386:  DATA 69,6F
01388:  DATA 6E,20
0138A:  DATA 49,44
0138C:  DATA 3A,20
0138E:  DATA 20,20
01390:  DATA 25,30
01392:  DATA 32,58
01394:  DATA 0D,0A
01396:  DATA 00,00
01398:  DATA 46,75
0139A:  DATA 6E,63
0139C:  DATA 74,69
0139E:  DATA 6F,6E
013A0:  DATA 20,54
013A2:  DATA 79,70
013A4:  DATA 65,3A
013A6:  DATA 25,30
013A8:  DATA 32,58
013AA:  DATA 0D,0A
013AC:  DATA 00,00
013AE:  DATA 57,72
013B0:  DATA 69,74
013B2:  DATA 65,20
013B4:  DATA 4D,6F
013B6:  DATA 64,65
013B8:  DATA 3A,20
013BA:  DATA 20,20
013BC:  DATA 25,30
013BE:  DATA 32,58
013C0:  DATA 0D,0A
013C2:  DATA 00,00
013C4:  DATA 53,6F
013C6:  DATA 75,72
013C8:  DATA 63,65
013CA:  DATA 20,54
013CC:  DATA 79,70
013CE:  DATA 65,3A
013D0:  DATA 20,20
013D2:  DATA 25,30
013D4:  DATA 32,58
013D6:  DATA 0D,0A
013D8:  DATA 00,00
013DA:  DATA 53,74
013DC:  DATA 61,72
013DE:  DATA 74,20
013E0:  DATA 41,64
013E2:  DATA 64,72
013E4:  DATA 65,73
013E6:  DATA 73,3A
013E8:  DATA 25,30
013EA:  DATA 34,58
013EC:  DATA 0D,0A
013EE:  DATA 00,00
013F0:  DATA 53,69
013F2:  DATA 7A,65
013F4:  DATA 3A,20
013F6:  DATA 20,20
013F8:  DATA 20,20
013FA:  DATA 20,20
013FC:  DATA 20,20
013FE:  DATA 25,30
01400:  DATA 34,58
01402:  DATA 0D,0A
01404:  DATA 00,00
01406:  DATA 45,6E
01408:  DATA 64,20
0140A:  DATA 4D,4F
0140C:  DATA 44,45
0140E:  DATA 20,4D
01410:  DATA 45,41
01412:  DATA 53,20
01414:  DATA 49,56
01416:  DATA 20,6D
01418:  DATA 69,73
0141A:  DATA 73,69
0141C:  DATA 6F,6E
0141E:  DATA 0D,0A
01420:  DATA 00,00
01422:  DATA 5B,49
01424:  DATA 56,44
01426:  DATA 42,47
01428:  DATA 5D,20
0142A:  DATA 53,74
0142C:  DATA 61,72
0142E:  DATA 74,20
01430:  DATA 4D,4F
01432:  DATA 44,45
01434:  DATA 20,49
01436:  DATA 56,20
01438:  DATA 44,45
0143A:  DATA 42,55
0143C:  DATA 47,0D
0143E:  DATA 0A,00
01440:  DATA 5B,49
01442:  DATA 56,44
01444:  DATA 42,47
01446:  DATA 5D,20
01448:  DATA 49,44
0144A:  DATA 3A,20
0144C:  DATA 25,30
0144E:  DATA 32,58
01450:  DATA 0D,0A
01452:  DATA 00,00
01454:  DATA 5B,49
01456:  DATA 56,44
01458:  DATA 42,47
0145A:  DATA 5D,20
0145C:  DATA 53,6C
0145E:  DATA 65,65
01460:  DATA 70,20
01462:  DATA 54,69
01464:  DATA 6D,65
01466:  DATA 3A,20
01468:  DATA 25,6C
0146A:  DATA 75,20
0146C:  DATA 6D,73
0146E:  DATA 0D,0A
01470:  DATA 00,00
01472:  DATA 5B,49
01474:  DATA 56,44
01476:  DATA 42,47
01478:  DATA 5D,20
0147A:  DATA 43,75
0147C:  DATA 72,72
0147E:  DATA 65,6E
01480:  DATA 74,20
01482:  DATA 54,68
01484:  DATA 72,65
01486:  DATA 73,68
01488:  DATA 6F,6C
0148A:  DATA 64,3A
0148C:  DATA 20,25
0148E:  DATA 6C,75
01490:  DATA 20,6D
01492:  DATA 41,0D
01494:  DATA 0A,00
01496:  DATA 5B,49
01498:  DATA 56,44
0149A:  DATA 42,47
0149C:  DATA 5D,20
0149E:  DATA 50,44
014A0:  DATA 20,54
014A2:  DATA 68,72
014A4:  DATA 65,73
014A6:  DATA 68,6F
014A8:  DATA 6C,64
014AA:  DATA 3A,20
014AC:  DATA 25,6C
014AE:  DATA 75,20
014B0:  DATA 6D,41
014B2:  DATA 0D,0A
014B4:  DATA 00,00
014B6:  DATA 5B,49
014B8:  DATA 56,44
014BA:  DATA 42,47
014BC:  DATA 5D,20
014BE:  DATA 43,75
014C0:  DATA 72,72
014C2:  DATA 65,6E
014C4:  DATA 74,20
014C6:  DATA 4C,69
014C8:  DATA 6D,69
014CA:  DATA 74,3A
014CC:  DATA 20,25
014CE:  DATA 6C,75
014D0:  DATA 20,6D
014D2:  DATA 41,0D
014D4:  DATA 0A,00
014D6:  DATA 5B,49
014D8:  DATA 56,44
014DA:  DATA 42,47
014DC:  DATA 5D,20
014DE:  DATA 4D,65
014E0:  DATA 61,73
014E2:  DATA 75,72
014E4:  DATA 65,6D
014E6:  DATA 65,6E
014E8:  DATA 74,20
014EA:  DATA 54,69
014EC:  DATA 6D,65
014EE:  DATA 3A,20
014F0:  DATA 25,6C
014F2:  DATA 75,20
014F4:  DATA 73,0D
014F6:  DATA 0A,00
014F8:  DATA 5B,49
014FA:  DATA 56,44
014FC:  DATA 42,47
014FE:  DATA 5D,20
01500:  DATA 45,6E
01502:  DATA 64,20
01504:  DATA 4D,4F
01506:  DATA 44,45
01508:  DATA 20,49
0150A:  DATA 56,20
0150C:  DATA 44,45
0150E:  DATA 42,55
01510:  DATA 47,0D
01512:  DATA 0A,00
01514:  DATA 74,65
01516:  DATA 6D,70
01518:  DATA 5F,74
0151A:  DATA 6F,70
0151C:  DATA 2C,20
0151E:  DATA 74,65
01520:  DATA 6D,70
01522:  DATA 5F,62
01524:  DATA 6F,74
01526:  DATA 2C,20
01528:  DATA 74,65
0152A:  DATA 6D,70
0152C:  DATA 5F,6D
0152E:  DATA 69,73
01530:  DATA 37,2C
01532:  DATA 20,70
01534:  DATA 64,0D
01536:  DATA 0A,00
01538:  DATA 30,78
0153A:  DATA 25,30
0153C:  DATA 34,4C
0153E:  DATA 58,2C
01540:  DATA 20,30
01542:  DATA 78,25
01544:  DATA 30,34
01546:  DATA 4C,58
01548:  DATA 2C,20
0154A:  DATA 30,78
0154C:  DATA 25,30
0154E:  DATA 34,4C
01550:  DATA 58,2C
01552:  DATA 20,30
01554:  DATA 78,25
01556:  DATA 30,34
01558:  DATA 4C,58
0155A:  DATA 0D,0A
0155C:  DATA 00,00
0155E:  DATA 53,74
01560:  DATA 61,72
01562:  DATA 74,20
01564:  DATA 4D,4F
01566:  DATA 44,45
01568:  DATA 20,4D
0156A:  DATA 45,41
0156C:  DATA 53,20
0156E:  DATA 45,4E
01570:  DATA 56,20
01572:  DATA 44,45
01574:  DATA 42,55
01576:  DATA 47,0D
01578:  DATA 0A,00
0157A:  DATA 45,6E
0157C:  DATA 64,20
0157E:  DATA 4D,4F
01580:  DATA 44,45
01582:  DATA 20,4D
01584:  DATA 45,41
01586:  DATA 53,20
01588:  DATA 45,4E
0158A:  DATA 56,20
0158C:  DATA 44,45
0158E:  DATA 42,55
01590:  DATA 47,0D
01592:  DATA 0A,00
01594:  DATA 53,74
01596:  DATA 61,72
01598:  DATA 74,20
0159A:  DATA 46,6C
0159C:  DATA 61,73
0159E:  DATA 68,20
015A0:  DATA 45,72
015A2:  DATA 61,73
015A4:  DATA 65,20
015A6:  DATA 41,6C
015A8:  DATA 6C,0D
015AA:  DATA 0A,00
015AC:  DATA 45,6E
015AE:  DATA 64,20
015B0:  DATA 46,6C
015B2:  DATA 61,73
015B4:  DATA 68,20
015B6:  DATA 45,72
015B8:  DATA 61,73
015BA:  DATA 65,20
015BC:  DATA 41,6C
015BE:  DATA 6C,0D
015C0:  DATA 0A,00
015C2:  DATA 53,74
015C4:  DATA 61,72
015C6:  DATA 74,20
015C8:  DATA 46,6C
015CA:  DATA 61,73
015CC:  DATA 68,20
015CE:  DATA 45,72
015D0:  DATA 61,73
015D2:  DATA 65,20
015D4:  DATA 31,20
015D6:  DATA 53,65
015D8:  DATA 63,74
015DA:  DATA 6F,72
015DC:  DATA 0D,0A
015DE:  DATA 00,00
015E0:  DATA 09,53
015E2:  DATA 65,63
015E4:  DATA 74,6F
015E6:  DATA 72,20
015E8:  DATA 41,64
015EA:  DATA 64,72
015EC:  DATA 65,73
015EE:  DATA 73,3A
015F0:  DATA 20,30
015F2:  DATA 78,25
015F4:  DATA 30,38
015F6:  DATA 4C,58
015F8:  DATA 0D,0A
015FA:  DATA 00,00
015FC:  DATA 45,6E
015FE:  DATA 64,20
01600:  DATA 46,6C
01602:  DATA 61,73
01604:  DATA 68,20
01606:  DATA 45,72
01608:  DATA 61,73
0160A:  DATA 65,20
0160C:  DATA 31,20
0160E:  DATA 53,65
01610:  DATA 63,74
01612:  DATA 6F,72
01614:  DATA 0D,0A
01616:  DATA 00,00
01618:  DATA 53,74
0161A:  DATA 61,72
0161C:  DATA 74,20
0161E:  DATA 46,6C
01620:  DATA 61,73
01622:  DATA 68,20
01624:  DATA 43,6F
01626:  DATA 70,79
01628:  DATA 20,31
0162A:  DATA 20,53
0162C:  DATA 65,63
0162E:  DATA 74,6F
01630:  DATA 72,0D
01632:  DATA 0A,00
01634:  DATA 09,53
01636:  DATA 75,62
01638:  DATA 73,65
0163A:  DATA 63,74
0163C:  DATA 6F,72
0163E:  DATA 20,41
01640:  DATA 64,64
01642:  DATA 72,65
01644:  DATA 73,73
01646:  DATA 3A,20
01648:  DATA 30,78
0164A:  DATA 25,30
0164C:  DATA 38,4C
0164E:  DATA 58,0D
01650:  DATA 0A,00
01652:  DATA 45,6E
01654:  DATA 64,20
01656:  DATA 46,6C
01658:  DATA 61,73
0165A:  DATA 68,20
0165C:  DATA 43,6F
0165E:  DATA 70,79
01660:  DATA 20,31
01662:  DATA 20,53
01664:  DATA 65,63
01666:  DATA 74,6F
01668:  DATA 72,0D
0166A:  DATA 0A,00
0166C:  DATA 53,74
0166E:  DATA 61,72
01670:  DATA 74,20
01672:  DATA 46,6C
01674:  DATA 61,73
01676:  DATA 68,20
01678:  DATA 45,72
0167A:  DATA 61,73
0167C:  DATA 65,20
0167E:  DATA 36,34
01680:  DATA 6B,42
01682:  DATA 79,74
01684:  DATA 65,20
01686:  DATA 53,75
01688:  DATA 62,73
0168A:  DATA 65,63
0168C:  DATA 74,6F
0168E:  DATA 72,0D
01690:  DATA 0A,00
01692:  DATA 09,53
01694:  DATA 75,62
01696:  DATA 73,65
01698:  DATA 63,74
0169A:  DATA 6F,72
0169C:  DATA 20,41
0169E:  DATA 64,64
016A0:  DATA 72,65
016A2:  DATA 73,73
016A4:  DATA 3A,20
016A6:  DATA 30,78
016A8:  DATA 25,30
016AA:  DATA 38,4C
016AC:  DATA 58,0D
016AE:  DATA 0A,00
016B0:  DATA 45,6E
016B2:  DATA 64,20
016B4:  DATA 46,6C
016B6:  DATA 61,73
016B8:  DATA 68,20
016BA:  DATA 45,72
016BC:  DATA 61,73
016BE:  DATA 65,20
016C0:  DATA 36,34
016C2:  DATA 6B,42
016C4:  DATA 79,74
016C6:  DATA 65,20
016C8:  DATA 53,75
016CA:  DATA 62,73
016CC:  DATA 65,63
016CE:  DATA 74,6F
016D0:  DATA 72,0D
016D2:  DATA 0A,00
016D4:  DATA 53,74
016D6:  DATA 61,72
016D8:  DATA 74,20
016DA:  DATA 46,6C
016DC:  DATA 61,73
016DE:  DATA 68,20
016E0:  DATA 57,72
016E2:  DATA 69,74
016E4:  DATA 65,20
016E6:  DATA 44,65
016E8:  DATA 6D,6F
016EA:  DATA 0D,0A
016EC:  DATA 00,00
016EE:  DATA 09,4D
016F0:  DATA 4F,44
016F2:  DATA 45,20
016F4:  DATA 20,20
016F6:  DATA 20,20
016F8:  DATA 3A,20
016FA:  DATA 25,30
016FC:  DATA 32,58
016FE:  DATA 0D,0A
01700:  DATA 00,00
01702:  DATA 09,41
01704:  DATA 64,64
01706:  DATA 72,65
01708:  DATA 73,73
0170A:  DATA 20,20
0170C:  DATA 3A,20
0170E:  DATA 30,78
01710:  DATA 25,30
01712:  DATA 38,4C
01714:  DATA 58,0D
01716:  DATA 0A,00
01718:  DATA 09,50
0171A:  DATA 61,63
0171C:  DATA 6B,65
0171E:  DATA 74,4E
01720:  DATA 75,6D
01722:  DATA 3A,20
01724:  DATA 30,78
01726:  DATA 25,30
01728:  DATA 34,4C
0172A:  DATA 58,0D
0172C:  DATA 0A,00
0172E:  DATA 57,72
01730:  DATA 69,74
01732:  DATA 65,20
01734:  DATA 44,61
01736:  DATA 74,61
01738:  DATA 0D,0A
0173A:  DATA 00,00
0173C:  DATA 45,6E
0173E:  DATA 64,20
01740:  DATA 46,6C
01742:  DATA 61,73
01744:  DATA 68,20
01746:  DATA 57,72
01748:  DATA 69,74
0174A:  DATA 65,20
0174C:  DATA 44,65
0174E:  DATA 6D,6F
01750:  DATA 0D,0A
01752:  DATA 00,00
01754:  DATA 53,74
01756:  DATA 61,72
01758:  DATA 74,20
0175A:  DATA 46,6C
0175C:  DATA 61,73
0175E:  DATA 68,20
01760:  DATA 57,72
01762:  DATA 69,74
01764:  DATA 65,20
01766:  DATA 34,6B
01768:  DATA 42,79
0176A:  DATA 74,65
0176C:  DATA 20,53
0176E:  DATA 75,62
01770:  DATA 73,65
01772:  DATA 63,74
01774:  DATA 6F,72
01776:  DATA 0D,0A
01778:  DATA 00,00
0177A:  DATA 45,6E
0177C:  DATA 64,20
0177E:  DATA 46,6C
01780:  DATA 61,73
01782:  DATA 68,20
01784:  DATA 57,72
01786:  DATA 69,74
01788:  DATA 65,20
0178A:  DATA 34,6B
0178C:  DATA 42,79
0178E:  DATA 74,65
01790:  DATA 20,53
01792:  DATA 75,62
01794:  DATA 73,65
01796:  DATA 63,74
01798:  DATA 6F,72
0179A:  DATA 0D,0A
0179C:  DATA 00,00
0179E:  DATA 53,74
017A0:  DATA 61,72
017A2:  DATA 74,20
017A4:  DATA 46,6C
017A6:  DATA 61,73
017A8:  DATA 68,20
017AA:  DATA 52,65
017AC:  DATA 61,64
017AE:  DATA 0D,0A
017B0:  DATA 00,00
017B2:  DATA 09,4D
017B4:  DATA 4F,44
017B6:  DATA 45,20
017B8:  DATA 20,20
017BA:  DATA 20,20
017BC:  DATA 3A,20
017BE:  DATA 25,30
017C0:  DATA 32,58
017C2:  DATA 0D,0A
017C4:  DATA 00,00
017C6:  DATA 09,41
017C8:  DATA 64,64
017CA:  DATA 72,65
017CC:  DATA 73,73
017CE:  DATA 20,20
017D0:  DATA 3A,20
017D2:  DATA 30,78
017D4:  DATA 25,30
017D6:  DATA 38,4C
017D8:  DATA 58,0D
017DA:  DATA 0A,00
017DC:  DATA 09,50
017DE:  DATA 61,63
017E0:  DATA 6B,65
017E2:  DATA 74,4E
017E4:  DATA 75,6D
017E6:  DATA 3A,20
017E8:  DATA 30,78
017EA:  DATA 25,30
017EC:  DATA 34,4C
017EE:  DATA 58,0D
017F0:  DATA 0A,00
017F2:  DATA 52,45
017F4:  DATA 41,44
017F6:  DATA 20,44
017F8:  DATA 41,54
017FA:  DATA 41,0D
017FC:  DATA 0A,00
017FE:  DATA 4D,69
01800:  DATA 73,73
01802:  DATA 69,6F
01804:  DATA 6E,20
01806:  DATA 46,6C
01808:  DATA 61,73
0180A:  DATA 68,20
0180C:  DATA 69,73
0180E:  DATA 20,6E
01810:  DATA 6F,74
01812:  DATA 20,63
01814:  DATA 6F,6E
01816:  DATA 6E,65
01818:  DATA 63,74
0181A:  DATA 65,64
0181C:  DATA 0D,0A
0181E:  DATA 00,00
01820:  DATA 45,6E
01822:  DATA 64,20
01824:  DATA 46,6C
01826:  DATA 61,73
01828:  DATA 68,20
0182A:  DATA 52,65
0182C:  DATA 61,64
0182E:  DATA 0D,0A
01830:  DATA 00,00
01832:  DATA 53,74
01834:  DATA 61,72
01836:  DATA 74,20
01838:  DATA 46,6C
0183A:  DATA 61,73
0183C:  DATA 68,20
0183E:  DATA 52,65
01840:  DATA 61,64
01842:  DATA 20,41
01844:  DATA 64,64
01846:  DATA 72,65
01848:  DATA 73,73
0184A:  DATA 0D,0A
0184C:  DATA 00,00
0184E:  DATA 52,65
01850:  DATA 61,64
01852:  DATA 20,44
01854:  DATA 61,74
01856:  DATA 61,3A
01858:  DATA 20,25
0185A:  DATA 30,32
0185C:  DATA 58,20
0185E:  DATA 25,30
01860:  DATA 32,58
01862:  DATA 20,25
01864:  DATA 30,32
01866:  DATA 58,20
01868:  DATA 25,30
0186A:  DATA 32,58
0186C:  DATA 0D,0A
0186E:  DATA 00,00
01870:  DATA 45,6E
01872:  DATA 64,20
01874:  DATA 46,6C
01876:  DATA 61,73
01878:  DATA 68,20
0187A:  DATA 52,65
0187C:  DATA 61,64
0187E:  DATA 20,41
01880:  DATA 64,64
01882:  DATA 72,65
01884:  DATA 73,73
01886:  DATA 0D,0A
01888:  DATA 00,00
0188A:  DATA 53,74
0188C:  DATA 61,72
0188E:  DATA 74,20
01890:  DATA 46,6C
01892:  DATA 61,73
01894:  DATA 68,20
01896:  DATA 45,72
01898:  DATA 61,73
0189A:  DATA 65,20
0189C:  DATA 61,6E
0189E:  DATA 64,20
018A0:  DATA 52,65
018A2:  DATA 73,65
018A4:  DATA 74,0D
018A6:  DATA 0A,00
018A8:  DATA 45,6E
018AA:  DATA 64,20
018AC:  DATA 46,6C
018AE:  DATA 61,73
018B0:  DATA 68,20
018B2:  DATA 45,72
018B4:  DATA 61,73
018B6:  DATA 65,20
018B8:  DATA 61,6E
018BA:  DATA 64,20
018BC:  DATA 52,65
018BE:  DATA 73,65
018C0:  DATA 74,0D
018C2:  DATA 0A,00
018C4:  DATA 53,74
018C6:  DATA 61,72
018C8:  DATA 74,20
018CA:  DATA 46,6C
018CC:  DATA 61,73
018CE:  DATA 68,20
018D0:  DATA 53,4D
018D2:  DATA 46,20
018D4:  DATA 43,6F
018D6:  DATA 70,79
018D8:  DATA 0D,0A
018DA:  DATA 00,00
018DC:  DATA 45,6E
018DE:  DATA 64,20
018E0:  DATA 46,6C
018E2:  DATA 61,73
018E4:  DATA 68,20
018E6:  DATA 53,4D
018E8:  DATA 46,20
018EA:  DATA 43,6F
018EC:  DATA 70,79
018EE:  DATA 0D,0A
018F0:  DATA 00,00
018F2:  DATA 53,74
018F4:  DATA 61,72
018F6:  DATA 74,20
018F8:  DATA 46,6C
018FA:  DATA 61,73
018FC:  DATA 68,20
018FE:  DATA 53,4D
01900:  DATA 46,20
01902:  DATA 52,65
01904:  DATA 61,64
01906:  DATA 0D,0A
01908:  DATA 00,00
0190A:  DATA 52,65
0190C:  DATA 61,64
0190E:  DATA 20,44
01910:  DATA 61,74
01912:  DATA 61,3A
01914:  DATA 20,00
01916:  DATA 0D,0A
01918:  DATA 45,6E
0191A:  DATA 64,20
0191C:  DATA 46,6C
0191E:  DATA 61,73
01920:  DATA 68,20
01922:  DATA 53,4D
01924:  DATA 46,20
01926:  DATA 52,65
01928:  DATA 61,64
0192A:  DATA 0D,0A
0192C:  DATA 00,00
0192E:  DATA 53,74
01930:  DATA 61,72
01932:  DATA 74,20
01934:  DATA 46,6C
01936:  DATA 61,73
01938:  DATA 68,20
0193A:  DATA 53,4D
0193C:  DATA 46,20
0193E:  DATA 45,72
01940:  DATA 61,73
01942:  DATA 65,0D
01944:  DATA 0A,00
01946:  DATA 45,6E
01948:  DATA 64,20
0194A:  DATA 46,6C
0194C:  DATA 61,73
0194E:  DATA 68,20
01950:  DATA 53,4D
01952:  DATA 46,20
01954:  DATA 45,72
01956:  DATA 61,73
01958:  DATA 65,0D
0195A:  DATA 0A,00
0195C:  DATA 53,74
0195E:  DATA 61,72
01960:  DATA 74,20
01962:  DATA 46,6C
01964:  DATA 61,73
01966:  DATA 68,20
01968:  DATA 41,64
0196A:  DATA 64,72
0196C:  DATA 65,73
0196E:  DATA 73,20
01970:  DATA 52,65
01972:  DATA 73,65
01974:  DATA 74,0D
01976:  DATA 0A,00
01978:  DATA 45,6E
0197A:  DATA 64,20
0197C:  DATA 46,6C
0197E:  DATA 61,73
01980:  DATA 68,20
01982:  DATA 41,64
01984:  DATA 64,72
01986:  DATA 65,73
01988:  DATA 73,20
0198A:  DATA 52,65
0198C:  DATA 73,65
0198E:  DATA 74,0D
01990:  DATA 0A,00
01992:  DATA 53,4D
01994:  DATA 46,20
01996:  DATA 69,73
01998:  DATA 20,6E
0199A:  DATA 6F,74
0199C:  DATA 20,63
0199E:  DATA 6F,6E
019A0:  DATA 6E,65
019A2:  DATA 63,74
019A4:  DATA 65,64
019A6:  DATA 0D,0A
019A8:  DATA 00,00
019AA:  DATA 53,74
019AC:  DATA 61,72
019AE:  DATA 74,20
019B0:  DATA 46,6C
019B2:  DATA 61,73
019B4:  DATA 68,20
019B6:  DATA 53,4D
019B8:  DATA 46,20
019BA:  DATA 52,65
019BC:  DATA 61,64
019BE:  DATA 20,46
019C0:  DATA 6F,72
019C2:  DATA 63,65
019C4:  DATA 0D,0A
019C6:  DATA 00,00
019C8:  DATA 09,41
019CA:  DATA 64,64
019CC:  DATA 72,65
019CE:  DATA 73,73
019D0:  DATA 20,20
019D2:  DATA 3A,20
019D4:  DATA 30,78
019D6:  DATA 25,30
019D8:  DATA 38,4C
019DA:  DATA 58,0D
019DC:  DATA 0A,00
019DE:  DATA 09,50
019E0:  DATA 61,63
019E2:  DATA 6B,65
019E4:  DATA 74,4E
019E6:  DATA 75,6D
019E8:  DATA 3A,20
019EA:  DATA 30,78
019EC:  DATA 25,30
019EE:  DATA 34,4C
019F0:  DATA 58,0D
019F2:  DATA 0A,00
019F4:  DATA 72,65
019F6:  DATA 61,64
019F8:  DATA 20,64
019FA:  DATA 61,74
019FC:  DATA 61,0D
019FE:  DATA 0A,00
01A00:  DATA 0D,0A
01A02:  DATA 45,6E
01A04:  DATA 64,20
01A06:  DATA 46,6C
01A08:  DATA 61,73
01A0A:  DATA 68,20
01A0C:  DATA 53,4D
01A0E:  DATA 46,20
01A10:  DATA 52,65
01A12:  DATA 61,64
01A14:  DATA 20,46
01A16:  DATA 6F,72
01A18:  DATA 63,65
01A1A:  DATA 0D,0A
01A1C:  DATA 00,00
01A1E:  DATA 53,74
01A20:  DATA 61,72
01A22:  DATA 74,20
01A24:  DATA 53,4D
01A26:  DATA 46,20
01A28:  DATA 45,72
01A2A:  DATA 61,73
01A2C:  DATA 65,20
01A2E:  DATA 41,6C
01A30:  DATA 6C,0D
01A32:  DATA 0A,00
01A34:  DATA 45,6E
01A36:  DATA 64,20
01A38:  DATA 53,4D
01A3A:  DATA 46,20
01A3C:  DATA 45,72
01A3E:  DATA 61,73
01A40:  DATA 65,20
01A42:  DATA 41,6C
01A44:  DATA 6C,0D
01A46:  DATA 0A,00
01A48:  DATA 53,74
01A4A:  DATA 61,72
01A4C:  DATA 74,20
01A4E:  DATA 53,4D
01A50:  DATA 46,20
01A52:  DATA 52,65
01A54:  DATA 73,65
01A56:  DATA 74,0D
01A58:  DATA 0A,00
01A5A:  DATA 45,6E
01A5C:  DATA 64,20
01A5E:  DATA 53,4D
01A60:  DATA 46,20
01A62:  DATA 52,65
01A64:  DATA 73,65
01A66:  DATA 74,0D
01A68:  DATA 0A,00
01A6A:  DATA 0D,0A
01A6C:  DATA 0D,0A
01A6E:  DATA 0D,0A
01A70:  DATA 3D,3D
01A72:  DATA 3D,3D
01A74:  DATA 3D,3D
01A76:  DATA 3D,3D
01A78:  DATA 3D,3D
01A7A:  DATA 3D,3D
01A7C:  DATA 3D,3D
01A7E:  DATA 3D,3D
01A80:  DATA 3D,3D
01A82:  DATA 3D,3D
01A84:  DATA 3D,3D
01A86:  DATA 3D,3D
01A88:  DATA 3D,3D
01A8A:  DATA 3D,3D
01A8C:  DATA 3D,3D
01A8E:  DATA 3D,3D
01A90:  DATA 3D,3D
01A92:  DATA 3D,3D
01A94:  DATA 3D,3D
01A96:  DATA 3D,3D
01A98:  DATA 3D,3D
01A9A:  DATA 3D,3D
01A9C:  DATA 3D,3D
01A9E:  DATA 3D,3D
01AA0:  DATA 3D,3D
01AA2:  DATA 3D,3D
01AA4:  DATA 3D,3D
01AA6:  DATA 3D,3D
01AA8:  DATA 3D,3D
01AAA:  DATA 3D,3D
01AAC:  DATA 0D,0A
01AAE:  DATA 00,00
01AB0:  DATA 54,68
01AB2:  DATA 69,73
01AB4:  DATA 20,69
01AB6:  DATA 73,20
01AB8:  DATA 4D,4F
01ABA:  DATA 4D,49
01ABC:  DATA 4A,49
01ABE:  DATA 20,43
01AC0:  DATA 49,47
01AC2:  DATA 53,20
01AC4:  DATA 50,49
01AC6:  DATA 43,20
01AC8:  DATA 42,42
01ACA:  DATA 4D,20
01ACC:  DATA 66,6F
01ACE:  DATA 72,20
01AD0:  DATA 4D,49
01AD2:  DATA 53,37
01AD4:  DATA 5F,42
01AD6:  DATA 42,4D
01AD8:  DATA 34,2E
01ADA:  DATA 0D,0A
01ADC:  DATA 00,00
01ADE:  DATA 4C,61
01AE0:  DATA 73,74
01AE2:  DATA 20,75
01AE4:  DATA 70,64
01AE6:  DATA 61,74
01AE8:  DATA 65,64
01AEA:  DATA 20,6F
01AEC:  DATA 6E,20
01AEE:  DATA 25,73
01AF0:  DATA 20,25
01AF2:  DATA 73,2C
01AF4:  DATA 20,62
01AF6:  DATA 79,20
01AF8:  DATA 49,6E
01AFA:  DATA 6F,75
01AFC:  DATA 65,2E
01AFE:  DATA 0D,0A
01B00:  DATA 0D,0A
01B02:  DATA 00,00
01B04:  DATA 33,31
01B06:  DATA 2D,41
01B08:  DATA 75,67
01B0A:  DATA 2D,32
01B0C:  DATA 35,00
01B0E:  DATA 31,39
01B10:  DATA 3A,35
01B12:  DATA 32,3A
01B14:  DATA 35,34
01B16:  DATA 00,00
01B18:  DATA 5F,5F
01B1A:  DATA 5F,5F
01B1C:  DATA 43,49
01B1E:  DATA 47,53
01B20:  DATA 20,50
01B22:  DATA 49,43
01B24:  DATA 20,53
01B26:  DATA 74,61
01B28:  DATA 72,74
01B2A:  DATA 20,4F
01B2C:  DATA 70,65
01B2E:  DATA 72,61
01B30:  DATA 74,69
01B32:  DATA 6F,6E
01B34:  DATA 5F,5F
01B36:  DATA 5F,5F
01B38:  DATA 5F,0D
01B3A:  DATA 0A,0D
01B3C:  DATA 0A,00
01B3E:  DATA 77,61
01B40:  DATA 69,74
01B42:  DATA 69,6E
01B44:  DATA 67,20
01B46:  DATA 66,6F
01B48:  DATA 72,20
01B4A:  DATA 42,4F
01B4C:  DATA 53,53
01B4E:  DATA 20,50
01B50:  DATA 49,43
01B52:  DATA 20,63
01B54:  DATA 6F,6D
01B56:  DATA 6D,61
01B58:  DATA 6E,64
01B5A:  DATA 00,00
01B5C:  DATA 0D,0A
01B5E:  DATA 77,61
01B60:  DATA 69,74
01B62:  DATA 69,6E
01B64:  DATA 67,20
01B66:  DATA 66,6F
01B68:  DATA 72,20
01B6A:  DATA 42,4F
01B6C:  DATA 53,53
01B6E:  DATA 20,50
01B70:  DATA 49,43
01B72:  DATA 20,63
01B74:  DATA 6F,6D
01B76:  DATA 6D,61
01B78:  DATA 6E,64
01B7A:  DATA 00,00
01B7C:  DATA 0D,0A
01B7E:  DATA 0D,0A
01B80:  DATA 3D,3D
01B82:  DATA 3D,3D
01B84:  DATA 3D,3D
01B86:  DATA 0D,0A
01B88:  DATA 0D,0A
01B8A:  DATA 46,69
01B8C:  DATA 6E,69
01B8E:  DATA 73,68
01B90:  DATA 65,64
01B92:  DATA 20,70
01B94:  DATA 72,6F
01B96:  DATA 63,65
01B98:  DATA 73,73
01B9A:  DATA 2E,0D
01B9C:  DATA 0A,57
01B9E:  DATA 61,69
01BA0:  DATA 74,20
01BA2:  DATA 66,6F
01BA4:  DATA 72,20
01BA6:  DATA 42,4F
01BA8:  DATA 53,53
01BAA:  DATA 20,50
01BAC:  DATA 49,43
01BAE:  DATA 20,74
01BB0:  DATA 75,72
01BB2:  DATA 6E,20
01BB4:  DATA 6F,66
01BB6:  DATA 66,20
01BB8:  DATA 6D,65
01BBA:  DATA 00,00
01BBC:  DATA 45,6E
01BBE:  DATA 64,20
01BC0:  DATA 6D,61
01BC2:  DATA 69,6E
01BC4:  DATA 0D,0A
01BC6:  DATA 00,00
*
01BF6:  TBLRD*+
01BF8:  MOVF   FF5,F
01BFA:  BTFSC  FD8.2
01BFC:  GOTO   1C2A
01C00:  MOVFF  FF6,9E9
01C04:  MOVFF  FF7,9EA
01C08:  MOVFF  FF8,9EB
01C0C:  MOVF   FF5,W
01C0E:  BTFSS  FA6.6
01C10:  GOTO   1C0E
01C14:  MOVLB  E
01C16:  MOVWF  xF9
01C18:  MOVFF  9E9,FF6
01C1C:  MOVFF  9EA,FF7
01C20:  MOVFF  9EB,FF8
01C24:  MOVLB  0
01C26:  GOTO   1BF6
01C2A:  RETURN 0
01C2C:  TBLRD*+
01C2E:  MOVFF  FF6,9EA
01C32:  MOVFF  FF7,9EB
01C36:  MOVFF  FF8,9EC
01C3A:  MOVF   FF5,W
01C3C:  BTFSS  FA6.6
01C3E:  GOTO   1C3C
01C42:  MOVLB  E
01C44:  MOVWF  xF9
01C46:  MOVFF  9EA,FF6
01C4A:  MOVFF  9EB,FF7
01C4E:  MOVFF  9EC,FF8
01C52:  MOVLB  9
01C54:  DECFSZ xE9,F
01C56:  BRA    1C5C
01C58:  BRA    1C62
01C5A:  MOVLB  0
01C5C:  MOVLB  0
01C5E:  GOTO   1C2C
01C62:  MOVLB  0
01C64:  RETURN 0
*
01E3C:  MOVLB  A
01E3E:  BTFSS  x49.7
01E40:  BRA    1E48
01E42:  MOVLB  0
01E44:  GOTO   1E7E
01E48:  MOVLW  0F
01E4A:  MOVWF  00
01E4C:  SWAPF  x48,W
01E4E:  ANDWF  00,F
01E50:  MOVLW  0A
01E52:  SUBWF  00,W
01E54:  BTFSS  FD8.0
01E56:  BRA    1E5E
01E58:  MOVLB  0
01E5A:  GOTO   1E68
01E5E:  MOVLW  30
01E60:  ADDWF  00,F
01E62:  MOVLB  0
01E64:  GOTO   1E70
01E68:  MOVLB  A
01E6A:  MOVF   x49,W
01E6C:  ADDWF  00,F
01E6E:  MOVLB  0
01E70:  MOVF   00,W
01E72:  BTFSS  FA6.6
01E74:  GOTO   1E72
01E78:  MOVLB  E
01E7A:  MOVWF  xF9
01E7C:  MOVLB  0
01E7E:  MOVLW  0F
01E80:  MOVLB  A
01E82:  ANDWF  x48,F
01E84:  MOVLW  0A
01E86:  SUBWF  x48,W
01E88:  BTFSS  FD8.0
01E8A:  BRA    1E92
01E8C:  MOVLB  0
01E8E:  GOTO   1E9A
01E92:  MOVLW  30
01E94:  MOVLB  0
01E96:  GOTO   1EA2
01E9A:  MOVLB  A
01E9C:  BCF    x49.7
01E9E:  MOVF   x49,W
01EA0:  MOVLB  0
01EA2:  MOVLB  A
01EA4:  ADDWF  x48,F
01EA6:  MOVF   x48,W
01EA8:  MOVLB  0
01EAA:  BTFSS  FA6.6
01EAC:  GOTO   1EAA
01EB0:  MOVLB  E
01EB2:  MOVWF  xF9
01EB4:  MOVLB  0
01EB6:  RETURN 0
*
02364:  MOVLB  A
02366:  MOVF   xA9,W
02368:  ANDLW  07
0236A:  MOVWF  00
0236C:  RRCF   xA9,W
0236E:  MOVWF  01
02370:  RRCF   01,F
02372:  RRCF   01,F
02374:  MOVLW  1F
02376:  ANDWF  01,F
02378:  MOVF   01,W
0237A:  ADDWF  xAB,W
0237C:  MOVWF  FE9
0237E:  MOVLW  00
02380:  ADDWFC xAC,W
02382:  MOVWF  FEA
02384:  CLRF   01
02386:  INCF   01,F
02388:  INCF   00,F
0238A:  MOVLB  0
0238C:  GOTO   2392
02390:  RLCF   01,F
02392:  DECFSZ 00,F
02394:  GOTO   2390
02398:  MOVLB  A
0239A:  MOVF   xAA,F
0239C:  BTFSS  FD8.2
0239E:  BRA    23A6
023A0:  MOVLB  0
023A2:  GOTO   23B0
023A6:  MOVF   01,W
023A8:  IORWF  FEF,F
023AA:  MOVLB  0
023AC:  GOTO   23B6
023B0:  COMF   01,F
023B2:  MOVF   01,W
023B4:  ANDWF  FEF,F
023B6:  RETURN 0
*
027AC:  TSTFSZ 01
027AE:  GOTO   27BC
027B2:  TSTFSZ 02
027B4:  GOTO   27BE
027B8:  GOTO   27CE
027BC:  INCF   02,F
027BE:  MOVFF  00,FEE
027C2:  DECFSZ 01,F
027C4:  GOTO   27BE
027C8:  DECFSZ 02,F
027CA:  GOTO   27BE
027CE:  RETURN 0
*
07BC0:  MOVFF  FEA,1DF
07BC4:  MOVFF  FE9,1DE
07BC8:  MOVLB  1
07BCA:  SWAPF  xD8,W
07BCC:  IORLW  F0
07BCE:  MOVWF  xDA
07BD0:  ADDWF  xDA,F
07BD2:  ADDLW  E2
07BD4:  MOVWF  xDB
07BD6:  ADDLW  32
07BD8:  MOVWF  xDD
07BDA:  MOVF   xD8,W
07BDC:  ANDLW  0F
07BDE:  ADDWF  xDB,F
07BE0:  ADDWF  xDB,F
07BE2:  ADDWF  xDD,F
07BE4:  ADDLW  E9
07BE6:  MOVWF  xDC
07BE8:  ADDWF  xDC,F
07BEA:  ADDWF  xDC,F
07BEC:  SWAPF  xD7,W
07BEE:  ANDLW  0F
07BF0:  ADDWF  xDC,F
07BF2:  ADDWF  xDD,F
07BF4:  RLCF   xDC,F
07BF6:  RLCF   xDD,F
07BF8:  COMF   xDD,F
07BFA:  RLCF   xDD,F
07BFC:  MOVF   xD7,W
07BFE:  ANDLW  0F
07C00:  ADDWF  xDD,F
07C02:  RLCF   xDA,F
07C04:  MOVLW  07
07C06:  MOVWF  xD9
07C08:  MOVLW  0A
07C0A:  MOVLB  0
07C0C:  MOVLB  1
07C0E:  DECF   xDC,F
07C10:  ADDWF  xDD,F
07C12:  BTFSC  FD8.0
07C14:  BRA    7C1C
07C16:  MOVLB  0
07C18:  GOTO   7C0C
07C1C:  MOVLB  0
07C1E:  MOVLB  1
07C20:  DECF   xDB,F
07C22:  ADDWF  xDC,F
07C24:  BTFSC  FD8.0
07C26:  BRA    7C2E
07C28:  MOVLB  0
07C2A:  GOTO   7C1E
07C2E:  MOVLB  0
07C30:  MOVLB  1
07C32:  DECF   xDA,F
07C34:  ADDWF  xDB,F
07C36:  BTFSC  FD8.0
07C38:  BRA    7C40
07C3A:  MOVLB  0
07C3C:  GOTO   7C30
07C40:  MOVLB  0
07C42:  MOVLB  1
07C44:  DECF   xD9,F
07C46:  ADDWF  xDA,F
07C48:  BTFSC  FD8.0
07C4A:  BRA    7C52
07C4C:  MOVLB  0
07C4E:  GOTO   7C42
07C52:  MOVLW  01
07C54:  MOVWF  FEA
07C56:  MOVLW  D9
07C58:  MOVWF  FE9
07C5A:  MOVLW  07
07C5C:  ANDWF  xDE,W
07C5E:  BCF    xDE.6
07C60:  MOVLB  0
07C62:  ADDWF  FE9,F
07C64:  MOVLW  00
07C66:  ADDWFC FEA,F
07C68:  MOVF   FE9,W
07C6A:  SUBLW  DD
07C6C:  BTFSS  FD8.2
07C6E:  GOTO   7C7E
07C72:  DECFSZ FEA,W
07C74:  GOTO   7C7E
07C78:  MOVLB  1
07C7A:  BSF    xDE.6
07C7C:  MOVLB  0
07C7E:  MOVF   FEF,W
07C80:  MOVWF  00
07C82:  BTFSS  FD8.2
07C84:  GOTO   7CB0
07C88:  MOVLB  1
07C8A:  BTFSS  xDE.6
07C8C:  BRA    7C94
07C8E:  MOVLB  0
07C90:  GOTO   7CB0
07C94:  BTFSS  xDE.4
07C96:  BRA    7C9E
07C98:  MOVLB  0
07C9A:  GOTO   7CCA
07C9E:  BTFSS  xDE.3
07CA0:  BRA    7CA8
07CA2:  MOVLB  0
07CA4:  GOTO   7CB0
07CA8:  MOVLW  20
07CAA:  MOVLB  0
07CAC:  GOTO   7CBA
07CB0:  MOVLB  1
07CB2:  BSF    xDE.3
07CB4:  BCF    xDE.4
07CB6:  MOVLW  30
07CB8:  MOVLB  0
07CBA:  ADDWF  00,F
07CBC:  MOVF   00,W
07CBE:  BTFSS  FA6.6
07CC0:  GOTO   7CBE
07CC4:  MOVLB  E
07CC6:  MOVWF  xF9
07CC8:  MOVLB  0
07CCA:  MOVF   FEE,W
07CCC:  MOVLB  1
07CCE:  BTFSC  xDE.6
07CD0:  BRA    7CD8
07CD2:  MOVLB  0
07CD4:  GOTO   7C68
07CD8:  MOVLB  0
07CDA:  RETURN 0
*
0A8B4:  MOVLB  3
0A8B6:  MOVF   x1E,W
0A8B8:  CLRF   01
0A8BA:  SUBWF  x1D,W
0A8BC:  BTFSS  FD8.0
0A8BE:  BRA    A8C6
0A8C0:  MOVLB  0
0A8C2:  GOTO   A8D0
0A8C6:  MOVF   x1D,W
0A8C8:  MOVWF  00
0A8CA:  MOVLB  0
0A8CC:  GOTO   A8FA
0A8D0:  CLRF   00
0A8D2:  MOVLW  08
0A8D4:  MOVLB  3
0A8D6:  MOVWF  x1F
0A8D8:  MOVLB  0
0A8DA:  MOVLB  3
0A8DC:  RLCF   x1D,F
0A8DE:  RLCF   00,F
0A8E0:  MOVF   x1E,W
0A8E2:  SUBWF  00,W
0A8E4:  BTFSC  FD8.0
0A8E6:  MOVWF  00
0A8E8:  RLCF   01,F
0A8EA:  DECFSZ x1F,F
0A8EC:  BRA    A8F2
0A8EE:  BRA    A8F8
0A8F0:  MOVLB  0
0A8F2:  MOVLB  0
0A8F4:  GOTO   A8DA
0A8F8:  MOVLB  0
0A8FA:  RETURN 0
0A8FC:  MOVF   01,W
0A8FE:  MOVFF  298,31D
0A902:  MOVLW  64
0A904:  MOVLB  3
0A906:  MOVWF  x1E
0A908:  MOVLB  0
0A90A:  CALL   A8B4
0A90E:  MOVFF  00,298
0A912:  MOVF   01,W
0A914:  MOVLW  30
0A916:  BTFSS  FD8.2
0A918:  GOTO   A93C
0A91C:  MOVLB  2
0A91E:  BTFSC  x99.1
0A920:  BRA    A928
0A922:  MOVLB  0
0A924:  GOTO   A956
0A928:  BTFSS  x99.3
0A92A:  BRA    A932
0A92C:  MOVLB  0
0A92E:  GOTO   A956
0A932:  BTFSC  x99.4
0A934:  MOVLW  20
0A936:  MOVLB  0
0A938:  GOTO   A946
0A93C:  MOVLB  2
0A93E:  BCF    x99.3
0A940:  BCF    x99.4
0A942:  BSF    x99.0
0A944:  MOVLB  0
0A946:  ADDWF  01,F
0A948:  MOVF   01,W
0A94A:  BTFSS  FA6.6
0A94C:  GOTO   A94A
0A950:  MOVLB  E
0A952:  MOVWF  xF9
0A954:  MOVLB  0
0A956:  MOVFF  298,31D
0A95A:  MOVLW  0A
0A95C:  MOVLB  3
0A95E:  MOVWF  x1E
0A960:  MOVLB  0
0A962:  CALL   A8B4
0A966:  MOVFF  00,298
0A96A:  MOVF   01,W
0A96C:  MOVLW  30
0A96E:  BTFSS  FD8.2
0A970:  GOTO   A990
0A974:  MOVLB  2
0A976:  BTFSS  x99.3
0A978:  BRA    A980
0A97A:  MOVLB  0
0A97C:  GOTO   A9A0
0A980:  BTFSC  x99.0
0A982:  BRA    A98A
0A984:  MOVLB  0
0A986:  GOTO   A9A0
0A98A:  BTFSC  x99.4
0A98C:  MOVLW  20
0A98E:  MOVLB  0
0A990:  ADDWF  01,F
0A992:  MOVF   01,W
0A994:  BTFSS  FA6.6
0A996:  GOTO   A994
0A99A:  MOVLB  E
0A99C:  MOVWF  xF9
0A99E:  MOVLB  0
0A9A0:  MOVLW  30
0A9A2:  MOVLB  2
0A9A4:  ADDWF  x98,F
0A9A6:  MOVF   x98,W
0A9A8:  MOVLB  0
0A9AA:  BTFSS  FA6.6
0A9AC:  GOTO   A9AA
0A9B0:  MOVLB  E
0A9B2:  MOVWF  xF9
0A9B4:  MOVLB  0
0A9B6:  RETURN 0
0A9B8:  BTFSC  FD8.1
0A9BA:  GOTO   A9C6
0A9BE:  MOVLW  02
0A9C0:  MOVWF  FEA
0A9C2:  MOVLW  A8
0A9C4:  MOVWF  FE9
0A9C6:  CLRF   00
0A9C8:  CLRF   01
0A9CA:  CLRF   02
0A9CC:  CLRF   03
0A9CE:  MOVLB  2
0A9D0:  CLRF   xA8
0A9D2:  CLRF   xA9
0A9D4:  CLRF   xAA
0A9D6:  CLRF   xAB
0A9D8:  MOVF   xA7,W
0A9DA:  IORWF  xA6,W
0A9DC:  IORWF  xA5,W
0A9DE:  IORWF  xA4,W
0A9E0:  BTFSS  FD8.2
0A9E2:  BRA    A9EA
0A9E4:  MOVLB  0
0A9E6:  GOTO   AA7A
0A9EA:  MOVLB  0
0A9EC:  MOVLW  20
0A9EE:  MOVLB  2
0A9F0:  MOVWF  xAC
0A9F2:  MOVLB  0
0A9F4:  BCF    FD8.0
0A9F6:  MOVLB  2
0A9F8:  RLCF   xA0,F
0A9FA:  RLCF   xA1,F
0A9FC:  RLCF   xA2,F
0A9FE:  RLCF   xA3,F
0AA00:  RLCF   xA8,F
0AA02:  RLCF   xA9,F
0AA04:  RLCF   xAA,F
0AA06:  RLCF   xAB,F
0AA08:  MOVF   xA7,W
0AA0A:  SUBWF  xAB,W
0AA0C:  BTFSC  FD8.2
0AA0E:  BRA    AA16
0AA10:  MOVLB  0
0AA12:  GOTO   AA38
0AA16:  MOVF   xA6,W
0AA18:  SUBWF  xAA,W
0AA1A:  BTFSC  FD8.2
0AA1C:  BRA    AA24
0AA1E:  MOVLB  0
0AA20:  GOTO   AA38
0AA24:  MOVF   xA5,W
0AA26:  SUBWF  xA9,W
0AA28:  BTFSC  FD8.2
0AA2A:  BRA    AA32
0AA2C:  MOVLB  0
0AA2E:  GOTO   AA38
0AA32:  MOVF   xA4,W
0AA34:  SUBWF  xA8,W
0AA36:  MOVLB  0
0AA38:  BTFSS  FD8.0
0AA3A:  GOTO   AA60
0AA3E:  MOVLB  2
0AA40:  MOVF   xA4,W
0AA42:  SUBWF  xA8,F
0AA44:  MOVF   xA5,W
0AA46:  BTFSS  FD8.0
0AA48:  INCFSZ xA5,W
0AA4A:  SUBWF  xA9,F
0AA4C:  MOVF   xA6,W
0AA4E:  BTFSS  FD8.0
0AA50:  INCFSZ xA6,W
0AA52:  SUBWF  xAA,F
0AA54:  MOVF   xA7,W
0AA56:  BTFSS  FD8.0
0AA58:  INCFSZ xA7,W
0AA5A:  SUBWF  xAB,F
0AA5C:  BSF    FD8.0
0AA5E:  MOVLB  0
0AA60:  RLCF   00,F
0AA62:  RLCF   01,F
0AA64:  RLCF   02,F
0AA66:  RLCF   03,F
0AA68:  MOVLB  2
0AA6A:  DECFSZ xAC,F
0AA6C:  BRA    AA72
0AA6E:  BRA    AA78
0AA70:  MOVLB  0
0AA72:  MOVLB  0
0AA74:  GOTO   A9F4
0AA78:  MOVLB  0
0AA7A:  MOVFF  2A8,FEF
0AA7E:  MOVFF  2A9,FEC
0AA82:  MOVFF  2AA,FEC
0AA86:  MOVFF  2AB,FEC
0AA8A:  MOVF   FED,F
0AA8C:  MOVF   FED,F
0AA8E:  MOVF   FED,F
0AA90:  RETURN 0
0AA92:  MOVF   FE9,W
0AA94:  MOVLB  2
0AA96:  MOVWF  x98
0AA98:  BTFSC  x97.7
0AA9A:  BRA    AAA2
0AA9C:  MOVLB  0
0AA9E:  GOTO   AABE
0AAA2:  DECF   x98,F
0AAA4:  BSF    x98.5
0AAA6:  COMF   x94,F
0AAA8:  COMF   x95,F
0AAAA:  COMF   x96,F
0AAAC:  COMF   x97,F
0AAAE:  INCF   x94,F
0AAB0:  BTFSC  FD8.2
0AAB2:  INCF   x95,F
0AAB4:  BTFSC  FD8.2
0AAB6:  INCF   x96,F
0AAB8:  BTFSC  FD8.2
0AABA:  INCF   x97,F
0AABC:  MOVLB  0
0AABE:  MOVLW  3B
0AAC0:  MOVLB  2
0AAC2:  MOVWF  x9F
0AAC4:  MOVLW  9A
0AAC6:  MOVWF  x9E
0AAC8:  MOVLW  CA
0AACA:  MOVWF  x9D
0AACC:  CLRF   x9C
0AACE:  MOVLW  0A
0AAD0:  MOVWF  x9A
0AAD2:  MOVLB  0
0AAD4:  BSF    FD8.1
0AAD6:  MOVLW  02
0AAD8:  MOVWF  FEA
0AADA:  MOVLW  94
0AADC:  MOVWF  FE9
0AADE:  MOVFF  297,2A3
0AAE2:  MOVFF  296,2A2
0AAE6:  MOVFF  295,2A1
0AAEA:  MOVFF  294,2A0
0AAEE:  MOVFF  29F,2A7
0AAF2:  MOVFF  29E,2A6
0AAF6:  MOVFF  29D,2A5
0AAFA:  MOVFF  29C,2A4
0AAFE:  CALL   A9B8
0AB02:  MOVF   01,W
0AB04:  MOVF   00,F
0AB06:  BTFSS  FD8.2
0AB08:  GOTO   AB60
0AB0C:  MOVLB  2
0AB0E:  MOVF   x9A,W
0AB10:  XORLW  01
0AB12:  BTFSS  FD8.2
0AB14:  BRA    AB1C
0AB16:  MOVLB  0
0AB18:  GOTO   AB60
0AB1C:  MOVF   x98,W
0AB1E:  BTFSS  FD8.2
0AB20:  BRA    AB28
0AB22:  MOVLB  0
0AB24:  GOTO   AB68
0AB28:  ANDLW  0F
0AB2A:  SUBWF  x9A,W
0AB2C:  BTFSS  FD8.2
0AB2E:  BRA    AB36
0AB30:  MOVLB  0
0AB32:  GOTO   AB42
0AB36:  BTFSS  FD8.0
0AB38:  BRA    AB40
0AB3A:  MOVLB  0
0AB3C:  GOTO   ABD0
0AB40:  MOVLB  0
0AB42:  MOVLB  2
0AB44:  BTFSS  x98.7
0AB46:  BRA    AB4E
0AB48:  MOVLB  0
0AB4A:  GOTO   ABD0
0AB4E:  BTFSS  x98.6
0AB50:  BRA    AB58
0AB52:  MOVLB  0
0AB54:  GOTO   AB68
0AB58:  MOVLW  20
0AB5A:  MOVLB  0
0AB5C:  GOTO   ABC0
0AB60:  MOVLW  20
0AB62:  MOVLB  2
0AB64:  ANDWF  x98,F
0AB66:  MOVLB  0
0AB68:  MOVLB  2
0AB6A:  BTFSC  x98.5
0AB6C:  BRA    AB74
0AB6E:  MOVLB  0
0AB70:  GOTO   AB92
0AB74:  BCF    x98.5
0AB76:  MOVF   00,W
0AB78:  MOVWF  x98
0AB7A:  MOVLW  2D
0AB7C:  MOVLB  0
0AB7E:  BTFSS  FA6.6
0AB80:  GOTO   AB7E
0AB84:  MOVLB  E
0AB86:  MOVWF  xF9
0AB88:  MOVLB  2
0AB8A:  MOVF   x98,W
0AB8C:  MOVWF  00
0AB8E:  CLRF   x98
0AB90:  MOVLB  0
0AB92:  MOVLW  30
0AB94:  MOVLB  2
0AB96:  BTFSC  x98.5
0AB98:  BRA    ABA0
0AB9A:  MOVLB  0
0AB9C:  GOTO   ABC0
0ABA0:  BCF    x98.5
0ABA2:  MOVF   00,W
0ABA4:  MOVWF  x98
0ABA6:  MOVLW  2D
0ABA8:  MOVLB  0
0ABAA:  BTFSS  FA6.6
0ABAC:  GOTO   ABAA
0ABB0:  MOVLB  E
0ABB2:  MOVWF  xF9
0ABB4:  MOVLB  2
0ABB6:  MOVF   x98,W
0ABB8:  MOVWF  00
0ABBA:  CLRF   x98
0ABBC:  MOVLW  30
0ABBE:  MOVLB  0
0ABC0:  ADDWF  00,F
0ABC2:  MOVF   00,W
0ABC4:  BTFSS  FA6.6
0ABC6:  GOTO   ABC4
0ABCA:  MOVLB  E
0ABCC:  MOVWF  xF9
0ABCE:  MOVLB  0
0ABD0:  BCF    FD8.1
0ABD2:  MOVFF  29F,2A3
0ABD6:  MOVFF  29E,2A2
0ABDA:  MOVFF  29D,2A1
0ABDE:  MOVFF  29C,2A0
0ABE2:  MOVLB  2
0ABE4:  CLRF   xA7
0ABE6:  CLRF   xA6
0ABE8:  CLRF   xA5
0ABEA:  MOVLW  0A
0ABEC:  MOVWF  xA4
0ABEE:  MOVLB  0
0ABF0:  CALL   A9B8
0ABF4:  MOVFF  03,29F
0ABF8:  MOVFF  02,29E
0ABFC:  MOVFF  01,29D
0AC00:  MOVFF  00,29C
0AC04:  MOVLB  2
0AC06:  DECFSZ x9A,F
0AC08:  BRA    AC0E
0AC0A:  BRA    AC14
0AC0C:  MOVLB  0
0AC0E:  MOVLB  0
0AC10:  GOTO   AAD4
0AC14:  MOVLB  0
0AC16:  RETURN 0
*
0B02E:  MOVLW  20
0B030:  MOVLB  3
0B032:  BTFSS  x18.4
0B034:  MOVLW  30
0B036:  MOVWF  x19
0B038:  MOVFF  317,00
0B03C:  BTFSC  00.7
0B03E:  BRA    B046
0B040:  MOVLB  0
0B042:  GOTO   B058
0B046:  COMF   00,F
0B048:  INCF   00,F
0B04A:  MOVFF  00,317
0B04E:  MOVLW  2D
0B050:  MOVWF  x19
0B052:  BSF    x18.7
0B054:  BSF    x18.0
0B056:  MOVLB  0
0B058:  MOVF   01,W
0B05A:  MOVFF  317,31D
0B05E:  MOVLW  64
0B060:  MOVLB  3
0B062:  MOVWF  x1E
0B064:  MOVLB  0
0B066:  CALL   A8B4
0B06A:  MOVFF  00,317
0B06E:  MOVLW  30
0B070:  ADDWF  01,W
0B072:  MOVLB  3
0B074:  MOVWF  x1A
0B076:  MOVFF  317,31D
0B07A:  MOVLW  0A
0B07C:  MOVWF  x1E
0B07E:  MOVLB  0
0B080:  CALL   A8B4
0B084:  MOVLW  30
0B086:  ADDWF  00,W
0B088:  MOVLB  3
0B08A:  MOVWF  x1C
0B08C:  MOVLW  30
0B08E:  ADDWF  01,W
0B090:  MOVWF  x1B
0B092:  MOVFF  319,00
0B096:  MOVLB  0
0B098:  MOVLW  30
0B09A:  MOVLB  3
0B09C:  SUBWF  x1A,W
0B09E:  BTFSS  FD8.2
0B0A0:  BRA    B0A8
0B0A2:  MOVLB  0
0B0A4:  GOTO   B0B4
0B0A8:  BSF    x18.1
0B0AA:  BTFSC  x18.7
0B0AC:  BSF    x18.2
0B0AE:  MOVLB  0
0B0B0:  GOTO   B0F4
0B0B4:  MOVFF  319,31A
0B0B8:  MOVLW  20
0B0BA:  MOVLB  3
0B0BC:  MOVWF  x19
0B0BE:  MOVLW  30
0B0C0:  SUBWF  x1B,W
0B0C2:  BTFSS  FD8.2
0B0C4:  BRA    B0CC
0B0C6:  MOVLB  0
0B0C8:  GOTO   B0D8
0B0CC:  BSF    x18.0
0B0CE:  BTFSC  x18.7
0B0D0:  BSF    x18.1
0B0D2:  MOVLB  0
0B0D4:  GOTO   B0F4
0B0D8:  BTFSC  FD8.2
0B0DA:  BRA    B0E2
0B0DC:  MOVLB  3
0B0DE:  BSF    x18.0
0B0E0:  MOVLB  0
0B0E2:  BTFSS  FD8.2
0B0E4:  GOTO   B0F4
0B0E8:  MOVFF  31A,31B
0B0EC:  MOVLW  20
0B0EE:  MOVLB  3
0B0F0:  MOVWF  x1A
0B0F2:  MOVLB  0
0B0F4:  MOVLB  3
0B0F6:  BTFSS  x18.2
0B0F8:  BRA    B100
0B0FA:  MOVLB  0
0B0FC:  GOTO   B11A
0B100:  BTFSS  x18.1
0B102:  BRA    B10A
0B104:  MOVLB  0
0B106:  GOTO   B12C
0B10A:  BTFSS  x18.0
0B10C:  BRA    B114
0B10E:  MOVLB  0
0B110:  GOTO   B13E
0B114:  MOVLB  0
0B116:  GOTO   B150
0B11A:  MOVLB  3
0B11C:  MOVF   x19,W
0B11E:  MOVLB  0
0B120:  BTFSS  FA6.6
0B122:  GOTO   B120
0B126:  MOVLB  E
0B128:  MOVWF  xF9
0B12A:  MOVLB  0
0B12C:  MOVLB  3
0B12E:  MOVF   x1A,W
0B130:  MOVLB  0
0B132:  BTFSS  FA6.6
0B134:  GOTO   B132
0B138:  MOVLB  E
0B13A:  MOVWF  xF9
0B13C:  MOVLB  0
0B13E:  MOVLB  3
0B140:  MOVF   x1B,W
0B142:  MOVLB  0
0B144:  BTFSS  FA6.6
0B146:  GOTO   B144
0B14A:  MOVLB  E
0B14C:  MOVWF  xF9
0B14E:  MOVLB  0
0B150:  MOVLB  3
0B152:  MOVF   x1C,W
0B154:  MOVLB  0
0B156:  BTFSS  FA6.6
0B158:  GOTO   B156
0B15C:  MOVLB  E
0B15E:  MOVWF  xF9
0B160:  MOVLB  0
0B162:  RETURN 0
*
0BD1C:  MOVF   FE9,W
0BD1E:  MOVLB  2
0BD20:  MOVWF  x1D
0BD22:  MOVLW  3B
0BD24:  MOVWF  x24
0BD26:  MOVLW  9A
0BD28:  MOVWF  x23
0BD2A:  MOVLW  CA
0BD2C:  MOVWF  x22
0BD2E:  CLRF   x21
0BD30:  MOVLW  0A
0BD32:  MOVWF  x1F
0BD34:  MOVLB  0
0BD36:  BSF    FD8.1
0BD38:  MOVLW  02
0BD3A:  MOVWF  FEA
0BD3C:  MOVLW  19
0BD3E:  MOVWF  FE9
0BD40:  MOVFF  21C,2A3
0BD44:  MOVFF  21B,2A2
0BD48:  MOVFF  21A,2A1
0BD4C:  MOVFF  219,2A0
0BD50:  MOVFF  224,2A7
0BD54:  MOVFF  223,2A6
0BD58:  MOVFF  222,2A5
0BD5C:  MOVFF  221,2A4
0BD60:  CALL   A9B8
0BD64:  MOVF   01,W
0BD66:  MOVF   00,F
0BD68:  BTFSS  FD8.2
0BD6A:  GOTO   BDC2
0BD6E:  MOVLB  2
0BD70:  MOVF   x1F,W
0BD72:  XORLW  01
0BD74:  BTFSS  FD8.2
0BD76:  BRA    BD7E
0BD78:  MOVLB  0
0BD7A:  GOTO   BDC2
0BD7E:  MOVF   x1D,W
0BD80:  BTFSS  FD8.2
0BD82:  BRA    BD8A
0BD84:  MOVLB  0
0BD86:  GOTO   BDC8
0BD8A:  ANDLW  0F
0BD8C:  SUBWF  x1F,W
0BD8E:  BTFSS  FD8.2
0BD90:  BRA    BD98
0BD92:  MOVLB  0
0BD94:  GOTO   BDA4
0BD98:  BTFSS  FD8.0
0BD9A:  BRA    BDA2
0BD9C:  MOVLB  0
0BD9E:  GOTO   BDDA
0BDA2:  MOVLB  0
0BDA4:  MOVLB  2
0BDA6:  BTFSS  x1D.7
0BDA8:  BRA    BDB0
0BDAA:  MOVLB  0
0BDAC:  GOTO   BDDA
0BDB0:  BTFSS  x1D.6
0BDB2:  BRA    BDBA
0BDB4:  MOVLB  0
0BDB6:  GOTO   BDC8
0BDBA:  MOVLW  20
0BDBC:  MOVLB  0
0BDBE:  GOTO   BDCA
0BDC2:  MOVLB  2
0BDC4:  CLRF   x1D
0BDC6:  MOVLB  0
0BDC8:  MOVLW  30
0BDCA:  ADDWF  00,F
0BDCC:  MOVF   00,W
0BDCE:  BTFSS  FA6.6
0BDD0:  GOTO   BDCE
0BDD4:  MOVLB  E
0BDD6:  MOVWF  xF9
0BDD8:  MOVLB  0
0BDDA:  BCF    FD8.1
0BDDC:  MOVFF  224,2A3
0BDE0:  MOVFF  223,2A2
0BDE4:  MOVFF  222,2A1
0BDE8:  MOVFF  221,2A0
0BDEC:  MOVLB  2
0BDEE:  CLRF   xA7
0BDF0:  CLRF   xA6
0BDF2:  CLRF   xA5
0BDF4:  MOVLW  0A
0BDF6:  MOVWF  xA4
0BDF8:  MOVLB  0
0BDFA:  CALL   A9B8
0BDFE:  MOVFF  03,224
0BE02:  MOVFF  02,223
0BE06:  MOVFF  01,222
0BE0A:  MOVFF  00,221
0BE0E:  MOVLB  2
0BE10:  DECFSZ x1F,F
0BE12:  BRA    BE18
0BE14:  BRA    BE1E
0BE16:  MOVLB  0
0BE18:  MOVLB  0
0BE1A:  GOTO   BD36
0BE1E:  MOVLB  0
0BE20:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01BC8:  MOVLW  0A
01BCA:  MOVWF  FEA
01BCC:  MOVLW  A3
01BCE:  MOVWF  FE9
01BD0:  MOVF   FEF,W
01BD2:  BTFSC  FD8.2
01BD4:  GOTO   1BF4
01BD8:  MOVLW  05
01BDA:  MOVWF  01
01BDC:  CLRF   00
01BDE:  DECFSZ 00,F
01BE0:  BRA    1BDE
01BE2:  DECFSZ 01,F
01BE4:  BRA    1BDC
01BE6:  MOVLW  2E
01BE8:  MOVWF  00
01BEA:  DECFSZ 00,F
01BEC:  BRA    1BEA
01BEE:  BRA    1BF0
01BF0:  DECFSZ FEF,F
01BF2:  BRA    1BD8
01BF4:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
0010A:  BTFSS  FA6.5
0010C:  GOTO   010A
00110:  MOVLB  F
00112:  MOVF   x2F,W
00114:  MOVWF  1B
00116:  MOVLB  0
00118:  MOVLB  F
0011A:  MOVF   x2A,W
0011C:  MOVWF  01
0011E:  BTFSC  1B.1
00120:  BRA    0128
00122:  MOVLB  0
00124:  GOTO   012C
00128:  BCF    x2F.4
0012A:  BSF    x2F.4
0012C:  MOVLB  0
0012E:  GOTO   0168 (RETURN)
*
05264:  BTFSS  FA6.4
05266:  GOTO   5264
0526A:  MOVLB  F
0526C:  MOVWF  x29
0526E:  MOVLB  0
05270:  GOTO   52A6 (RETURN)
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
02434:  MOVLB  A
02436:  MOVF   xC6,W
02438:  SUBLW  08
0243A:  BTFSS  FD8.2
0243C:  BRA    2444
0243E:  MOVLB  0
02440:  GOTO   245C
02444:  MOVWF  xC8
02446:  MOVLB  0
02448:  MOVLB  A
0244A:  RLCF   xC5,F
0244C:  DECFSZ xC8,F
0244E:  BRA    2454
02450:  BRA    245A
02452:  MOVLB  0
02454:  MOVLB  0
02456:  GOTO   2448
0245A:  MOVLB  0
0245C:  BSF    F92.1
0245E:  BCF    F92.0
02460:  BCF    F92.3
02462:  BCF    F89.3
02464:  MOVFF  AC6,AC8
02468:  MOVLB  A
0246A:  BTFSS  xC5.7
0246C:  BCF    F89.0
0246E:  BTFSC  xC5.7
02470:  BSF    F89.0
02472:  RLCF   xC5,F
02474:  BSF    F89.3
02476:  MOVLW  02
02478:  MOVWF  xC9
0247A:  MOVLB  0
0247C:  MOVLB  A
0247E:  DECFSZ xC9,F
02480:  BRA    2486
02482:  BRA    248C
02484:  MOVLB  0
02486:  MOVLB  0
02488:  GOTO   247C
0248C:  RLCF   01,F
0248E:  BTFSS  F80.1
02490:  BCF    01.0
02492:  BTFSC  F80.1
02494:  BSF    01.0
02496:  BCF    F89.3
02498:  MOVLB  0
0249A:  BRA    249C
0249C:  MOVLB  A
0249E:  DECFSZ xC8,F
024A0:  BRA    24A6
024A2:  BRA    24AC
024A4:  MOVLB  0
024A6:  MOVLB  0
024A8:  GOTO   2468
024AC:  MOVLB  0
024AE:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
023B8:  MOVLB  A
023BA:  MOVF   xC6,W
023BC:  SUBLW  08
023BE:  BTFSS  FD8.2
023C0:  BRA    23C8
023C2:  MOVLB  0
023C4:  GOTO   23E0
023C8:  MOVWF  xC8
023CA:  MOVLB  0
023CC:  MOVLB  A
023CE:  RLCF   xC5,F
023D0:  DECFSZ xC8,F
023D2:  BRA    23D8
023D4:  BRA    23DE
023D6:  MOVLB  0
023D8:  MOVLB  0
023DA:  GOTO   23CC
023DE:  MOVLB  0
023E0:  BSF    F96.0
023E2:  BCF    F96.6
023E4:  BCF    F96.1
023E6:  BCF    F8D.1
023E8:  MOVFF  AC6,AC8
023EC:  MOVLB  A
023EE:  BTFSS  xC5.7
023F0:  BCF    F8D.6
023F2:  BTFSC  xC5.7
023F4:  BSF    F8D.6
023F6:  RLCF   xC5,F
023F8:  BSF    F8D.1
023FA:  MOVLW  02
023FC:  MOVWF  xC9
023FE:  MOVLB  0
02400:  MOVLB  A
02402:  DECFSZ xC9,F
02404:  BRA    240A
02406:  BRA    2410
02408:  MOVLB  0
0240A:  MOVLB  0
0240C:  GOTO   2400
02410:  RLCF   01,F
02412:  BTFSS  F84.0
02414:  BCF    01.0
02416:  BTFSC  F84.0
02418:  BSF    01.0
0241A:  BCF    F8D.1
0241C:  MOVLB  0
0241E:  BRA    2420
02420:  MOVLB  A
02422:  DECFSZ xC8,F
02424:  BRA    242A
02426:  BRA    2430
02428:  MOVLB  0
0242A:  MOVLB  0
0242C:  GOTO   23EC
02430:  MOVLB  0
02432:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01D44:  MOVLB  A
01D46:  MOVF   x04,W
01D48:  SUBLW  10
01D4A:  BTFSS  FD8.2
01D4C:  BRA    1D54
01D4E:  MOVLB  0
01D50:  GOTO   1D6E
01D54:  MOVWF  x06
01D56:  MOVLB  0
01D58:  MOVLB  A
01D5A:  RLCF   x02,F
01D5C:  RLCF   x03,F
01D5E:  DECFSZ x06,F
01D60:  BRA    1D66
01D62:  BRA    1D6C
01D64:  MOVLB  0
01D66:  MOVLB  0
01D68:  GOTO   1D58
01D6C:  MOVLB  0
01D6E:  BSF    F93.4
01D70:  BCF    F93.5
01D72:  BCF    F93.2
01D74:  BSF    F8A.2
01D76:  MOVFF  A04,A06
01D7A:  MOVLB  A
01D7C:  BTFSS  x03.7
01D7E:  BCF    F8A.5
01D80:  BTFSC  x03.7
01D82:  BSF    F8A.5
01D84:  RLCF   x02,F
01D86:  RLCF   x03,F
01D88:  BCF    F8A.2
01D8A:  RLCF   01,F
01D8C:  RLCF   02,F
01D8E:  BTFSS  F81.4
01D90:  BCF    01.0
01D92:  BTFSC  F81.4
01D94:  BSF    01.0
01D96:  BSF    F8A.2
01D98:  DECFSZ x06,F
01D9A:  BRA    1DA0
01D9C:  BRA    1DA6
01D9E:  MOVLB  0
01DA0:  MOVLB  0
01DA2:  GOTO   1D7A
01DA6:  MOVLB  0
01DA8:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "hal/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... int32 tick_10ms = 0; 
.................... 
.................... unsigned int32 dsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_10msec(unsigned int32 new_10msec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "hal/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA3
.................... static void boss_receive_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "hal/gpio.h"
.................... #ifndef GPIO_H
.................... #define GPIO_H
.................... 
.................... void gpio_init();
.................... void enable_negative_power();
.................... void disable_negative_power();
.................... void connect_port1();
.................... void disconnect_port1();
.................... void connect_port2();
.................... void disconnect_port2();
.................... 
.................... #endif // GPIO_H
.................... 
.................... #include "device_driver/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "device_driver/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "domain/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... #define HEADER_SIZE 5  // START_MAKER + time (4バイト)
.................... #define ENV_SIZE    6  // pd + temp_py_top + temp_py_bot + temp_mis7 packed
.................... #define DATA_SIZE_PER_STEP 3 // data0 + data1 12bitずつ
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "domain/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../hal/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "domain/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "application/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "application/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define CMD_LENGTH 9
.................... 
.................... // ______________CMD ID________________
.................... // Operation Command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_DEBUG 0xA1
.................... #define ID_MEAS_ENV 0xA2
.................... #define ID_MEAS_ENV_DEBUG 0xA3
.................... 
.................... // ______________MODE FUNCTIONS____________
.................... void mode_meas_iv(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_iv_debug(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_env(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_env_debug(unsigned int8 *uplinkcmd_ptr);
.................... 
.................... 
.................... typedef union {
....................     unsigned int8 raw;
....................     struct {
....................         unsigned int8 mission_continue : 1;
....................         unsigned int8 erase_and_save : 1;
....................         unsigned int8 reserved : 6;
....................     } flag;
.................... } mission_state_t;
.................... 
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     mission_state_t mission_state; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "application/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... // 実装は各 .c からビルドするためヘッダーでの取り込みは不要。必要なら下記のように直下参照に修正。
.................... #include "hal/timer.c"
.................... #include "timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... int32 tick_10ms = 0; 
.................... 
.................... unsigned int32 dsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_10msec(unsigned int32 new_10msec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... int8 subsec;
.................... 
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1(TIMER_ISR_10MSEC); 
*
000CA:  MOVLW  FE
000CC:  MOVWF  FCF
000CE:  MOVLW  A8
000D0:  MOVWF  FCE
000D2:  NOP   
....................    tick_10ms++;
000D4:  MOVLW  01
000D6:  ADDWF  1C,F
000D8:  BTFSC  FD8.0
000DA:  INCF   1D,F
000DC:  BTFSC  FD8.2
000DE:  INCF   1E,F
000E0:  BTFSC  FD8.2
000E2:  INCF   1F,F
000E4:  BCF    F9E.0
000E6:  GOTO   0074
.................... }
.................... 
.................... void timer_init()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01C90:  MOVLW  EA
01C92:  MOVWF  FF6
01C94:  MOVLW  00
01C96:  MOVWF  FF7
01C98:  MOVLW  00
01C9A:  MOVWF  FF8
01C9C:  CALL   1BF6
....................    clear_interrupt(INT_TIMER1);
01CA0:  BCF    F9E.0
....................    tick_10ms = 0;
01CA2:  CLRF   1F
01CA4:  CLRF   1E
01CA6:  CLRF   1D
01CA8:  CLRF   1C
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01CAA:  MOVLW  8F
01CAC:  MOVWF  FCD
01CAE:  CLRF   FAA
....................    set_timer1(TIMER_ISR_10MSEC); 
01CB0:  MOVLW  FE
01CB2:  MOVWF  FCF
01CB4:  MOVLW  A8
01CB6:  MOVWF  FCE
01CB8:  NOP   
....................    enable_interrupts(INT_TIMER1);   
01CBA:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01CBC:  MOVLW  C0
01CBE:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01CC0:  MOVLW  FE
01CC2:  MOVWF  FF6
01CC4:  MOVLW  00
01CC6:  MOVWF  FF7
01CC8:  MOVLW  00
01CCA:  MOVWF  FF8
01CCC:  CALL   1BF6
01CD0:  GOTO   CEF4 (RETURN)
.................... }
.................... 
.................... void set_current_10msec(unsigned int32 new_10msec)
.................... {
....................    tick_10ms = new_10msec;
.................... }
.................... 
.................... unsigned int32 get_current_time_10ms()
.................... {
....................    return tick_10ms;
*
07CDC:  MOVFF  1C,00
07CE0:  MOVFF  1D,01
07CE4:  MOVFF  1E,02
07CE8:  MOVFF  1F,03
07CEC:  RETURN 0
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return subsec;
*
03BA8:  MOVFF  135,00
03BAC:  CLRF   01
03BAE:  CLRF   02
03BB0:  CLRF   03
03BB2:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... 
.................... 
.................... void add_current_msec(unsigned int32 add_msec)
.................... {
....................    subsec += add_msec; // Convert milliseconds to deci-seconds
.................... }
.................... 
.................... #include "hal/uart.c"
.................... #include "uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA3
.................... static void boss_receive_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #INT_RDA3
.................... static void boss_receive_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00132:  GOTO   0136
00136:  GOTO   0140
0013A:  BTFSS  4B.0
0013C:  GOTO   0174
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00140:  MOVF   4A,W
00142:  SUBLW  1F
00144:  BTFSS  FD8.0
00146:  GOTO   0174
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
0014A:  MOVF   4A,W
0014C:  INCF   4A,F
0014E:  ANDLW  1F
00150:  CLRF   03
00152:  ADDLW  2A
00154:  MOVWF  FE9
00156:  MOVLW  00
00158:  ADDWFC 03,W
0015A:  MOVWF  FEA
0015C:  MOVFF  FEA,AFB
00160:  MOVFF  FE9,AFA
00164:  GOTO   010A
00168:  MOVFF  AFB,FEA
0016C:  MOVFF  AFA,FE9
00170:  MOVF   01,W
00172:  MOVWF  FEF
00174:  BCF    FA6.5
00176:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01C66:  MOVLW  7A
01C68:  MOVWF  FF6
01C6A:  MOVLW  01
01C6C:  MOVWF  FF7
01C6E:  MOVLW  00
01C70:  MOVWF  FF8
01C72:  CALL   1BF6
....................    enable_interrupts(INT_RDA3);
01C76:  BSF    F61.5
....................    enable_interrupts(GLOBAL);
01C78:  MOVLW  C0
01C7A:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01C7C:  MOVLW  8C
01C7E:  MOVWF  FF6
01C80:  MOVLW  01
01C82:  MOVWF  FF7
01C84:  MOVLW  00
01C86:  MOVWF  FF8
01C88:  CALL   1BF6
01C8C:  GOTO   CEF0 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
05226:  MOVFF  1BB,03
0522A:  MOVLB  1
0522C:  MOVF   xBA,W
0522E:  MOVWF  FE9
05230:  MOVFF  03,FEA
05234:  MOVFF  FEF,1BC
05238:  MOVFF  1B9,FEA
0523C:  MOVFF  1B8,FE9
05240:  CLRF   00
05242:  CLRF   02
05244:  MOVFF  1BC,01
05248:  MOVLB  0
0524A:  CALL   27AC
....................    *receive_signal_size = 0;
0524E:  MOVFF  1BB,03
05252:  MOVLB  1
05254:  MOVF   xBA,W
05256:  MOVWF  FE9
05258:  MOVFF  03,FEA
0525C:  CLRF   FEF
0525E:  MOVLB  0
05260:  GOTO   CFB4 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "hal/gpio.c"
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "gpio.h"
.................... #ifndef GPIO_H
.................... #define GPIO_H
.................... 
.................... void gpio_init();
.................... void enable_negative_power();
.................... void disable_negative_power();
.................... void connect_port1();
.................... void disconnect_port1();
.................... void connect_port2();
.................... void disconnect_port2();
.................... 
.................... #endif // GPIO_H
.................... 
.................... 
.................... void gpio_init() {
....................     enable_negative_power();
....................     disconnect_port1();
....................     disconnect_port2();
.................... }
.................... 
.................... void enable_negative_power() {
....................     output_low(EN_NPWR);
*
04CF2:  MOVLW  57
04CF4:  MOVWF  F94
04CF6:  BCF    F8B.7
04CF8:  GOTO   CF26 (RETURN)
.................... }
.................... 
.................... void disable_negative_power() {
....................     output_high(EN_NPWR);
.................... }
.................... 
.................... void connect_port1(){
....................     output_high(CONNECT_CIGS1);
04CFC:  MOVLW  57
04CFE:  MOVWF  F94
04D00:  BSF    F8B.3
04D02:  RETURN 0
.................... }
.................... 
.................... void disconnect_port1(){
....................     output_low(CONNECT_CIGS1);
.................... }
.................... 
.................... void connect_port2(){
....................     output_high(CONNECT_CIGS2);
04D04:  MOVLW  57
04D06:  MOVWF  F94
04D08:  BSF    F8B.5
04D0A:  RETURN 0
.................... }
.................... 
.................... void disconnect_port2(){
....................     output_low(CONNECT_CIGS2);
.................... }
.................... 
.................... 
.................... #include "device_driver/ad7490_driver.c"
.................... #include "ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01EB8:  MOVLW  98
01EBA:  MOVWF  FF6
01EBC:  MOVLW  01
01EBE:  MOVWF  FF7
01EC0:  MOVLW  00
01EC2:  MOVWF  FF8
01EC4:  CALL   1BF6
....................     output_high(ADC_CS); 
01EC8:  MOVLW  F4
01ECA:  MOVWF  F93
01ECC:  BSF    F8A.1
....................     delay_ms(10); 
01ECE:  MOVLW  0A
01ED0:  MOVLB  A
01ED2:  MOVWF  xA3
01ED4:  MOVLB  0
01ED6:  CALL   1BC8
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR);
01EDA:  MOVLW  05
01EDC:  MOVLB  9
01EDE:  MOVWF  xFB
01EE0:  MOVLB  0
01EE2:  CALL   1DAA
01EE6:  MOVFF  02,1B9
01EEA:  MOVFF  01,1B8
....................     delay_ms(1);
01EEE:  MOVLW  01
01EF0:  MOVLB  A
01EF2:  MOVWF  xA3
01EF4:  MOVLB  0
01EF6:  CALL   1BC8
....................     fprintf(PC, "\t%04LX\r\n", readdata);
01EFA:  MOVLW  09
01EFC:  BTFSS  FA6.6
01EFE:  GOTO   1EFC
01F02:  MOVLB  E
01F04:  MOVWF  xF9
01F06:  MOVFF  1B9,A48
01F0A:  MOVLW  37
01F0C:  MOVLB  A
01F0E:  MOVWF  x49
01F10:  MOVLB  0
01F12:  CALL   1E3C
01F16:  MOVFF  1B8,A48
01F1A:  MOVLW  37
01F1C:  MOVLB  A
01F1E:  MOVWF  x49
01F20:  MOVLB  0
01F22:  CALL   1E3C
01F26:  MOVLW  0D
01F28:  BTFSS  FA6.6
01F2A:  GOTO   1F28
01F2E:  MOVLB  E
01F30:  MOVWF  xF9
01F32:  MOVLW  0A
01F34:  MOVLB  0
01F36:  BTFSS  FA6.6
01F38:  GOTO   1F36
01F3C:  MOVLB  E
01F3E:  MOVWF  xF9
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
01F40:  MOVLB  1
01F42:  INCFSZ xB8,W
01F44:  BRA    1F4A
01F46:  BRA    1F50
01F48:  MOVLB  0
01F4A:  MOVLB  0
01F4C:  GOTO   1F68
01F50:  MOVLB  0
01F52:  MOVLB  1
01F54:  INCFSZ xB9,W
01F56:  BRA    1F5C
01F58:  BRA    1F62
01F5A:  MOVLB  0
01F5C:  MOVLB  0
01F5E:  GOTO   1F68
01F62:  MOVLB  0
01F64:  GOTO   1F88
01F68:  MOVLB  1
01F6A:  MOVF   xB8,F
01F6C:  BTFSC  FD8.2
01F6E:  BRA    1F76
01F70:  MOVLB  0
01F72:  GOTO   1F9C
01F76:  MOVLB  0
01F78:  MOVLB  1
01F7A:  MOVF   xB9,F
01F7C:  BTFSC  FD8.2
01F7E:  BRA    1F86
01F80:  MOVLB  0
01F82:  GOTO   1F9C
01F86:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
01F88:  MOVLW  AC
01F8A:  MOVWF  FF6
01F8C:  MOVLW  01
01F8E:  MOVWF  FF7
01F90:  MOVLW  00
01F92:  MOVWF  FF8
01F94:  CALL   1BF6
....................     } else {
01F98:  GOTO   1FAC
....................         fprintf(PC, "\tConnect successful\r\n");
01F9C:  MOVLW  BE
01F9E:  MOVWF  FF6
01FA0:  MOVLW  01
01FA2:  MOVWF  FF7
01FA4:  MOVLW  00
01FA6:  MOVWF  FF8
01FA8:  CALL   1BF6
....................     }
....................     fprintf(PC, "\tComplete\r\n");
01FAC:  MOVLW  D4
01FAE:  MOVWF  FF6
01FB0:  MOVLW  01
01FB2:  MOVWF  FF7
01FB4:  MOVLW  00
01FB6:  MOVWF  FF8
01FB8:  CALL   1BF6
01FBC:  GOTO   CEF8 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01DAA:  MOVFF  9FB,A02
01DAE:  GOTO   1CD4
01DB2:  MOVFF  02,9FD
01DB6:  MOVFF  01,9FC
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     output_low(ADC_CS); 
01DBA:  MOVLW  F4
01DBC:  MOVWF  F93
01DBE:  BCF    F8A.1
....................     delay_us(10); 
01DC0:  MOVLW  0D
01DC2:  MOVWF  00
01DC4:  DECFSZ 00,F
01DC6:  BRA    1DC4
....................     spi_xfer(ADC_STREAM, cmd); 
01DC8:  MOVFF  9FD,A03
01DCC:  MOVFF  9FC,A02
01DD0:  MOVLW  10
01DD2:  MOVLB  A
01DD4:  MOVWF  x04
01DD6:  MOVLW  01
01DD8:  MOVWF  x05
01DDA:  MOVLB  0
01DDC:  CALL   1D44
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     output_high(ADC_CS); 
01DE0:  MOVLW  F4
01DE2:  MOVWF  F93
01DE4:  BSF    F8A.1
....................     delay_us(10);
01DE6:  MOVLW  0D
01DE8:  MOVWF  00
01DEA:  DECFSZ 00,F
01DEC:  BRA    1DEA
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01DEE:  MOVLW  F4
01DF0:  MOVWF  F93
01DF2:  BCF    F8A.1
....................     delay_us(10);
01DF4:  MOVLW  0D
01DF6:  MOVWF  00
01DF8:  DECFSZ 00,F
01DFA:  BRA    1DF8
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000);
01DFC:  MOVLB  A
01DFE:  CLRF   x03
01E00:  CLRF   x02
01E02:  MOVLW  10
01E04:  MOVWF  x04
01E06:  MOVLW  01
01E08:  MOVWF  x05
01E0A:  MOVLB  0
01E0C:  CALL   1D44
01E10:  MOVFF  02,9FF
01E14:  MOVFF  01,9FE
....................     output_high(ADC_CS); 
01E18:  MOVLW  F4
01E1A:  MOVWF  F93
01E1C:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01E1E:  MOVLB  9
01E20:  MOVF   xFE,W
01E22:  MOVLB  A
01E24:  MOVWF  x00
01E26:  MOVLB  9
01E28:  MOVF   xFF,W
01E2A:  ANDLW  0F
01E2C:  MOVLB  A
01E2E:  MOVWF  x01
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01E30:  MOVF   x00,W
01E32:  MOVWF  01
01E34:  MOVF   x01,W
01E36:  MOVWF  02
01E38:  MOVLB  0
01E3A:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "device_driver/mcp4901_driver.c"
.................... #include "mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
02198:  MOVLW  E0
0219A:  MOVWF  FF6
0219C:  MOVLW  01
0219E:  MOVWF  FF7
021A0:  MOVLW  00
021A2:  MOVWF  FF8
021A4:  CALL   1BF6
....................     output_high(DAC1_CS); 
021A8:  MOVLW  F4
021AA:  MOVWF  F93
021AC:  BSF    F8A.3
....................     output_high(DAC2_CS); 
021AE:  MOVLW  F4
021B0:  MOVWF  F93
021B2:  BSF    F8A.0
....................     delay_ms(10); 
021B4:  MOVLW  0A
021B6:  MOVLB  A
021B8:  MOVWF  xA3
021BA:  MOVLB  0
021BC:  CALL   1BC8
....................     mcp4901_1_write(10); 
021C0:  MOVLB  9
021C2:  CLRF   xEA
021C4:  MOVLW  0A
021C6:  MOVWF  xE9
021C8:  MOVLB  0
021CA:  CALL   2114
....................     mcp4901_2_write(10); 
021CE:  MOVLB  9
021D0:  CLRF   xEA
021D2:  MOVLW  0A
021D4:  MOVWF  xE9
021D6:  MOVLB  0
021D8:  CALL   2156
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
021DC:  MOVLW  08
021DE:  MOVLB  9
021E0:  MOVWF  xFB
021E2:  MOVLB  0
021E4:  CALL   1DAA
021E8:  MOVFF  02,1B9
021EC:  MOVFF  01,1B8
....................     fprintf(PC, "%04LX\r\n", readdata);
021F0:  MOVFF  1B9,A48
021F4:  MOVLW  37
021F6:  MOVLB  A
021F8:  MOVWF  x49
021FA:  MOVLB  0
021FC:  CALL   1E3C
02200:  MOVFF  1B8,A48
02204:  MOVLW  37
02206:  MOVLB  A
02208:  MOVWF  x49
0220A:  MOVLB  0
0220C:  CALL   1E3C
02210:  MOVLW  0D
02212:  BTFSS  FA6.6
02214:  GOTO   2212
02218:  MOVLB  E
0221A:  MOVWF  xF9
0221C:  MOVLW  0A
0221E:  MOVLB  0
02220:  BTFSS  FA6.6
02222:  GOTO   2220
02226:  MOVLB  E
02228:  MOVWF  xF9
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
0222A:  MOVLB  1
0222C:  INCFSZ xB8,W
0222E:  BRA    2234
02230:  BRA    223A
02232:  MOVLB  0
02234:  MOVLB  0
02236:  GOTO   2252
0223A:  MOVLB  0
0223C:  MOVLB  1
0223E:  INCFSZ xB9,W
02240:  BRA    2246
02242:  BRA    224C
02244:  MOVLB  0
02246:  MOVLB  0
02248:  GOTO   2252
0224C:  MOVLB  0
0224E:  GOTO   2272
02252:  MOVLB  1
02254:  MOVF   xB8,F
02256:  BTFSC  FD8.2
02258:  BRA    2260
0225A:  MOVLB  0
0225C:  GOTO   2286
02260:  MOVLB  0
02262:  MOVLB  1
02264:  MOVF   xB9,F
02266:  BTFSC  FD8.2
02268:  BRA    2270
0226A:  MOVLB  0
0226C:  GOTO   2286
02270:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
02272:  MOVLW  F6
02274:  MOVWF  FF6
02276:  MOVLW  01
02278:  MOVWF  FF7
0227A:  MOVLW  00
0227C:  MOVWF  FF8
0227E:  CALL   1BF6
....................     } else {
02282:  GOTO   2296
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
02286:  MOVLW  16
02288:  MOVWF  FF6
0228A:  MOVLW  02
0228C:  MOVWF  FF7
0228E:  MOVLW  00
02290:  MOVWF  FF8
02292:  CALL   1BF6
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
02296:  MOVFF  1B9,A48
0229A:  MOVLW  37
0229C:  MOVLB  A
0229E:  MOVWF  x49
022A0:  MOVLB  0
022A2:  CALL   1E3C
022A6:  MOVFF  1B8,A48
022AA:  MOVLW  37
022AC:  MOVLB  A
022AE:  MOVWF  x49
022B0:  MOVLB  0
022B2:  CALL   1E3C
022B6:  MOVLW  0D
022B8:  BTFSS  FA6.6
022BA:  GOTO   22B8
022BE:  MOVLB  E
022C0:  MOVWF  xF9
022C2:  MOVLW  0A
022C4:  MOVLB  0
022C6:  BTFSS  FA6.6
022C8:  GOTO   22C6
022CC:  MOVLB  E
022CE:  MOVWF  xF9
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
022D0:  MOVLW  09
022D2:  MOVLB  9
022D4:  MOVWF  xFB
022D6:  MOVLB  0
022D8:  CALL   1DAA
022DC:  MOVFF  02,1B9
022E0:  MOVFF  01,1B8
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
022E4:  MOVLB  1
022E6:  INCFSZ xB8,W
022E8:  BRA    22EE
022EA:  BRA    22F4
022EC:  MOVLB  0
022EE:  MOVLB  0
022F0:  GOTO   230C
022F4:  MOVLB  0
022F6:  MOVLB  1
022F8:  INCFSZ xB9,W
022FA:  BRA    2300
022FC:  BRA    2306
022FE:  MOVLB  0
02300:  MOVLB  0
02302:  GOTO   230C
02306:  MOVLB  0
02308:  GOTO   232C
0230C:  MOVLB  1
0230E:  MOVF   xB8,F
02310:  BTFSC  FD8.2
02312:  BRA    231A
02314:  MOVLB  0
02316:  GOTO   2340
0231A:  MOVLB  0
0231C:  MOVLB  1
0231E:  MOVF   xB9,F
02320:  BTFSC  FD8.2
02322:  BRA    232A
02324:  MOVLB  0
02326:  GOTO   2340
0232A:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
0232C:  MOVLW  3A
0232E:  MOVWF  FF6
02330:  MOVLW  02
02332:  MOVWF  FF7
02334:  MOVLW  00
02336:  MOVWF  FF8
02338:  CALL   1BF6
....................     } else {
0233C:  GOTO   2350
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02340:  MOVLW  5A
02342:  MOVWF  FF6
02344:  MOVLW  02
02346:  MOVWF  FF7
02348:  MOVLW  00
0234A:  MOVWF  FF8
0234C:  CALL   1BF6
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02350:  MOVLW  7E
02352:  MOVWF  FF6
02354:  MOVLW  02
02356:  MOVWF  FF7
02358:  MOVLW  00
0235A:  MOVWF  FF8
0235C:  CALL   1BF6
02360:  GOTO   CEFC (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
02114:  MOVFF  9EA,9EE
02118:  MOVFF  9E9,9ED
0211C:  CALL   1FC0
02120:  MOVFF  02,9EC
02124:  MOVFF  01,9EB
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
02128:  MOVLW  F4
0212A:  MOVWF  F93
0212C:  BCF    F8A.3
....................    delay_us(10); 
0212E:  MOVLW  0D
02130:  MOVWF  00
02132:  DECFSZ 00,F
02134:  BRA    2132
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02136:  MOVFF  9EC,A03
0213A:  MOVFF  9EB,A02
0213E:  MOVLW  10
02140:  MOVLB  A
02142:  MOVWF  x04
02144:  MOVLW  01
02146:  MOVWF  x05
02148:  MOVLB  0
0214A:  CALL   1D44
....................    output_high(DAC1_CS); 
0214E:  MOVLW  F4
02150:  MOVWF  F93
02152:  BSF    F8A.3
02154:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
02156:  MOVFF  9EA,9EE
0215A:  MOVFF  9E9,9ED
0215E:  CALL   1FC0
02162:  MOVFF  02,9EC
02166:  MOVFF  01,9EB
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
0216A:  MOVLW  F4
0216C:  MOVWF  F93
0216E:  BCF    F8A.0
....................    delay_us(10); 
02170:  MOVLW  0D
02172:  MOVWF  00
02174:  DECFSZ 00,F
02176:  BRA    2174
....................    spi_xfer(ADCDAC_STREAM, cmd); 
02178:  MOVFF  9EC,A03
0217C:  MOVFF  9EB,A02
02180:  MOVLW  10
02182:  MOVLB  A
02184:  MOVWF  x04
02186:  MOVLW  01
02188:  MOVWF  x05
0218A:  MOVLB  0
0218C:  CALL   1D44
....................    output_high(DAC2_CS); 
02190:  MOVLW  F4
02192:  MOVWF  F93
02194:  BSF    F8A.0
02196:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01CD4:  MOVLB  A
01CD6:  BCF    x03.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01CD8:  BCF    x03.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01CDA:  BCF    x03.2
....................     cmd.fields.reserved3 = 0;
01CDC:  BCF    x03.3
....................     cmd.fields.coding = 1; // Two's complement
01CDE:  BSF    x03.4
....................     cmd.fields.range = 0; // Normal mode
01CE0:  BCF    x03.5
....................     cmd.fields.weak_tri = 0; // Strong trigger
01CE2:  BCF    x03.6
....................     cmd.fields.shadow = 0; // Direct access
01CE4:  BCF    x03.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01CE6:  BSF    x04.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01CE8:  BSF    x04.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01CEA:  MOVF   x02,W
01CEC:  ANDLW  01
01CEE:  MOVWF  01
01CF0:  BCF    x04.2
01CF2:  BTFSC  01.0
01CF4:  BSF    x04.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01CF6:  BCF    FD8.0
01CF8:  RRCF   x02,W
01CFA:  ANDLW  01
01CFC:  MOVWF  01
01CFE:  BCF    x04.3
01D00:  BTFSC  01.0
01D02:  BSF    x04.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01D04:  RRCF   x02,W
01D06:  MOVWF  00
01D08:  RRCF   00,F
01D0A:  MOVLW  3F
01D0C:  ANDWF  00,F
01D0E:  MOVF   00,W
01D10:  ANDLW  01
01D12:  MOVWF  01
01D14:  BCF    x04.4
01D16:  BTFSC  01.0
01D18:  BSF    x04.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01D1A:  RRCF   x02,W
01D1C:  MOVWF  00
01D1E:  RRCF   00,F
01D20:  RRCF   00,F
01D22:  MOVLW  1F
01D24:  ANDWF  00,F
01D26:  MOVF   00,W
01D28:  ANDLW  01
01D2A:  MOVWF  01
01D2C:  BCF    x04.5
01D2E:  BTFSC  01.0
01D30:  BSF    x04.5
....................     cmd.fields.seq = 0; // Random mode
01D32:  BCF    x04.6
....................     cmd.fields.write = 1; // Read operation
01D34:  BSF    x04.7
.................... 
.................... 
....................     return cmd.value;
01D36:  MOVF   x03,W
01D38:  MOVWF  01
01D3A:  MOVF   x04,W
01D3C:  MOVWF  02
01D3E:  MOVLB  0
01D40:  GOTO   1DB2 (RETURN)
.................... }
.................... 
.................... #include "../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
01FC0:  MOVLB  9
01FC2:  BCF    xF0.7
....................    cmd.fields.buffer = 1; // Buffer used
01FC4:  BSF    xF0.6
....................    cmd.fields.gain = 1; // Gain 1x
01FC6:  BSF    xF0.5
....................    cmd.fields.shutdown = 1; // Normal operation
01FC8:  BSF    xF0.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
01FCA:  RRCF   xEE,W
01FCC:  MOVWF  xF2
01FCE:  RRCF   xED,W
01FD0:  MOVWF  xF1
01FD2:  RRCF   xF2,F
01FD4:  RRCF   xF1,F
01FD6:  RRCF   xF2,F
01FD8:  RRCF   xF1,F
01FDA:  RRCF   xF2,F
01FDC:  RRCF   xF1,F
01FDE:  RRCF   xF2,F
01FE0:  RRCF   xF1,F
01FE2:  RRCF   xF2,F
01FE4:  RRCF   xF1,F
01FE6:  RRCF   xF2,F
01FE8:  RRCF   xF1,F
01FEA:  MOVLW  01
01FEC:  ANDWF  xF2,F
01FEE:  MOVF   xF1,W
01FF0:  ANDLW  01
01FF2:  MOVWF  00
01FF4:  CLRF   03
01FF6:  MOVF   00,W
01FF8:  MOVWF  01
01FFA:  BCF    xF0.3
01FFC:  BTFSC  01.0
01FFE:  BSF    xF0.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
02000:  RRCF   xEE,W
02002:  MOVWF  xF2
02004:  RRCF   xED,W
02006:  MOVWF  xF1
02008:  RRCF   xF2,F
0200A:  RRCF   xF1,F
0200C:  RRCF   xF2,F
0200E:  RRCF   xF1,F
02010:  RRCF   xF2,F
02012:  RRCF   xF1,F
02014:  RRCF   xF2,F
02016:  RRCF   xF1,F
02018:  RRCF   xF2,F
0201A:  RRCF   xF1,F
0201C:  MOVLW  03
0201E:  ANDWF  xF2,F
02020:  MOVF   xF1,W
02022:  ANDLW  01
02024:  MOVWF  00
02026:  CLRF   03
02028:  MOVF   00,W
0202A:  MOVWF  01
0202C:  BCF    xF0.2
0202E:  BTFSC  01.0
02030:  BSF    xF0.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
02032:  RRCF   xEE,W
02034:  MOVWF  xF2
02036:  RRCF   xED,W
02038:  MOVWF  xF1
0203A:  RRCF   xF2,F
0203C:  RRCF   xF1,F
0203E:  RRCF   xF2,F
02040:  RRCF   xF1,F
02042:  RRCF   xF2,F
02044:  RRCF   xF1,F
02046:  RRCF   xF2,F
02048:  RRCF   xF1,F
0204A:  MOVLW  07
0204C:  ANDWF  xF2,F
0204E:  MOVF   xF1,W
02050:  ANDLW  01
02052:  MOVWF  00
02054:  CLRF   03
02056:  MOVF   00,W
02058:  MOVWF  01
0205A:  BCF    xF0.1
0205C:  BTFSC  01.0
0205E:  BSF    xF0.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
02060:  RRCF   xEE,W
02062:  MOVWF  xF2
02064:  RRCF   xED,W
02066:  MOVWF  xF1
02068:  RRCF   xF2,F
0206A:  RRCF   xF1,F
0206C:  RRCF   xF2,F
0206E:  RRCF   xF1,F
02070:  RRCF   xF2,F
02072:  RRCF   xF1,F
02074:  MOVLW  0F
02076:  ANDWF  xF2,F
02078:  MOVF   xF1,W
0207A:  ANDLW  01
0207C:  MOVWF  00
0207E:  CLRF   03
02080:  MOVF   00,W
02082:  MOVWF  01
02084:  BCF    xF0.0
02086:  BTFSC  01.0
02088:  BSF    xF0.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
0208A:  RRCF   xEE,W
0208C:  MOVWF  xF2
0208E:  RRCF   xED,W
02090:  MOVWF  xF1
02092:  RRCF   xF2,F
02094:  RRCF   xF1,F
02096:  RRCF   xF2,F
02098:  RRCF   xF1,F
0209A:  MOVLW  1F
0209C:  ANDWF  xF2,F
0209E:  MOVF   xF1,W
020A0:  ANDLW  01
020A2:  MOVWF  00
020A4:  CLRF   03
020A6:  MOVF   00,W
020A8:  MOVWF  01
020AA:  BCF    xEF.7
020AC:  BTFSC  01.0
020AE:  BSF    xEF.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
020B0:  RRCF   xEE,W
020B2:  MOVWF  xF2
020B4:  RRCF   xED,W
020B6:  MOVWF  xF1
020B8:  RRCF   xF2,F
020BA:  RRCF   xF1,F
020BC:  MOVLW  3F
020BE:  ANDWF  xF2,F
020C0:  MOVF   xF1,W
020C2:  ANDLW  01
020C4:  MOVWF  00
020C6:  CLRF   03
020C8:  MOVF   00,W
020CA:  MOVWF  01
020CC:  BCF    xEF.6
020CE:  BTFSC  01.0
020D0:  BSF    xEF.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
020D2:  BCF    FD8.0
020D4:  RRCF   xEE,W
020D6:  MOVWF  xF2
020D8:  RRCF   xED,W
020DA:  MOVWF  xF1
020DC:  MOVF   xF1,W
020DE:  ANDLW  01
020E0:  MOVWF  00
020E2:  CLRF   03
020E4:  MOVF   00,W
020E6:  MOVWF  01
020E8:  BCF    xEF.5
020EA:  BTFSC  01.0
020EC:  BSF    xEF.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
020EE:  MOVF   xED,W
020F0:  ANDLW  01
020F2:  MOVWF  00
020F4:  CLRF   03
020F6:  MOVF   00,W
020F8:  MOVWF  01
020FA:  BCF    xEF.4
020FC:  BTFSC  01.0
020FE:  BSF    xEF.4
....................    cmd.fields.reserved = 0; // Reserved bits
02100:  BCF    xEF.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
02102:  BCF    xEF.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
02104:  BCF    xEF.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
02106:  BCF    xEF.0
.................... 
....................    return cmd.value;
02108:  MOVF   xEF,W
0210A:  MOVWF  01
0210C:  MOVF   xF0,W
0210E:  MOVWF  02
02110:  MOVLB  0
02112:  RETURN 0
.................... }
.................... 
.................... #include "../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
03BB4:  MOVLB  A
03BB6:  MOVF   xA3,W
03BB8:  XORLW  00
03BBA:  MOVLB  0
03BBC:  BTFSC  FD8.2
03BBE:  GOTO   3BCE
03BC2:  XORLW  01
03BC4:  BTFSC  FD8.2
03BC6:  GOTO   3C36
03BCA:  GOTO   3C9E
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03BCE:  MOVLB  A
03BD0:  CLRF   xAC
03BD2:  CLRF   xAB
03BD4:  MOVLB  0
03BD6:  MOVLB  A
03BD8:  MOVF   xAC,W
03BDA:  SUBWF  xAA,W
03BDC:  BTFSC  FD8.0
03BDE:  BRA    3BE6
03BE0:  MOVLB  0
03BE2:  GOTO   3C32
03BE6:  MOVLB  0
03BE8:  BTFSS  FD8.2
03BEA:  GOTO   3C00
03BEE:  MOVLB  A
03BF0:  MOVF   xA9,W
03BF2:  SUBWF  xAB,W
03BF4:  BTFSS  FD8.0
03BF6:  BRA    3BFE
03BF8:  MOVLB  0
03BFA:  GOTO   3C32
03BFE:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
03C00:  MOVLB  A
03C02:  MOVF   xA7,W
03C04:  ADDWF  xAB,W
03C06:  MOVWF  FE9
03C08:  MOVF   xA8,W
03C0A:  ADDWFC xAC,W
03C0C:  MOVWF  FEA
03C0E:  MOVFF  FEF,AAF
03C12:  MOVFF  AAF,AC5
03C16:  MOVLW  08
03C18:  MOVWF  xC6
03C1A:  MOVLW  01
03C1C:  MOVWF  xC7
03C1E:  MOVLB  0
03C20:  CALL   23B8
03C24:  MOVLB  A
03C26:  INCF   xAB,F
03C28:  BTFSC  FD8.2
03C2A:  INCF   xAC,F
03C2C:  MOVLB  0
03C2E:  GOTO   3BD6
....................          break;
03C32:  GOTO   3CA2
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03C36:  MOVLB  A
03C38:  CLRF   xAE
03C3A:  CLRF   xAD
03C3C:  MOVLB  0
03C3E:  MOVLB  A
03C40:  MOVF   xAE,W
03C42:  SUBWF  xAA,W
03C44:  BTFSC  FD8.0
03C46:  BRA    3C4E
03C48:  MOVLB  0
03C4A:  GOTO   3C9A
03C4E:  MOVLB  0
03C50:  BTFSS  FD8.2
03C52:  GOTO   3C68
03C56:  MOVLB  A
03C58:  MOVF   xA9,W
03C5A:  SUBWF  xAD,W
03C5C:  BTFSS  FD8.0
03C5E:  BRA    3C66
03C60:  MOVLB  0
03C62:  GOTO   3C9A
03C66:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
03C68:  MOVLB  A
03C6A:  MOVF   xA7,W
03C6C:  ADDWF  xAD,W
03C6E:  MOVWF  FE9
03C70:  MOVF   xA8,W
03C72:  ADDWFC xAE,W
03C74:  MOVWF  FEA
03C76:  MOVFF  FEF,AAF
03C7A:  MOVFF  AAF,AC5
03C7E:  MOVLW  08
03C80:  MOVWF  xC6
03C82:  MOVLW  01
03C84:  MOVWF  xC7
03C86:  MOVLB  0
03C88:  CALL   2434
03C8C:  MOVLB  A
03C8E:  INCF   xAD,F
03C90:  BTFSC  FD8.2
03C92:  INCF   xAE,F
03C94:  MOVLB  0
03C96:  GOTO   3C3E
....................          break;
03C9A:  GOTO   3CA2
....................          
....................       default:
....................          break;
03C9E:  GOTO   3CA2
....................    }
....................    return;
03CA2:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
024B0:  MOVLB  A
024B2:  MOVF   xA9,W
024B4:  XORLW  00
024B6:  MOVLB  0
024B8:  BTFSC  FD8.2
024BA:  GOTO   24CA
024BE:  XORLW  01
024C0:  BTFSC  FD8.2
024C2:  GOTO   25D4
024C6:  GOTO   26DE
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
024CA:  MOVLB  A
024CC:  CLRF   xB8
024CE:  CLRF   xB7
024D0:  MOVLB  0
024D2:  MOVLB  A
024D4:  MOVF   xB8,W
024D6:  SUBWF  xB0,W
024D8:  BTFSC  FD8.0
024DA:  BRA    24E2
024DC:  MOVLB  0
024DE:  GOTO   252E
024E2:  MOVLB  0
024E4:  BTFSS  FD8.2
024E6:  GOTO   24FC
024EA:  MOVLB  A
024EC:  MOVF   xAF,W
024EE:  SUBWF  xB7,W
024F0:  BTFSS  FD8.0
024F2:  BRA    24FA
024F4:  MOVLB  0
024F6:  GOTO   252E
024FA:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
024FC:  MOVLB  A
024FE:  MOVF   xAD,W
02500:  ADDWF  xB7,W
02502:  MOVWF  FE9
02504:  MOVF   xAE,W
02506:  ADDWFC xB8,W
02508:  MOVWF  FEA
0250A:  MOVFF  FEF,AC3
0250E:  MOVFF  AC3,AC5
02512:  MOVLW  08
02514:  MOVWF  xC6
02516:  MOVLW  01
02518:  MOVWF  xC7
0251A:  MOVLB  0
0251C:  CALL   23B8
02520:  MOVLB  A
02522:  INCF   xB7,F
02524:  BTFSC  FD8.2
02526:  INCF   xB8,F
02528:  MOVLB  0
0252A:  GOTO   24D2
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0252E:  MOVLB  A
02530:  CLRF   xBC
02532:  CLRF   xBB
02534:  CLRF   xBA
02536:  CLRF   xB9
02538:  MOVLB  0
0253A:  MOVLB  A
0253C:  MOVF   xBC,W
0253E:  SUBWF  xB6,W
02540:  BTFSC  FD8.0
02542:  BRA    254A
02544:  MOVLB  0
02546:  GOTO   25D0
0254A:  MOVLB  0
0254C:  BTFSS  FD8.2
0254E:  GOTO   2594
02552:  MOVLB  A
02554:  MOVF   xBB,W
02556:  SUBWF  xB5,W
02558:  BTFSC  FD8.0
0255A:  BRA    2562
0255C:  MOVLB  0
0255E:  GOTO   25D0
02562:  MOVLB  0
02564:  BTFSS  FD8.2
02566:  GOTO   2594
0256A:  MOVLB  A
0256C:  MOVF   xBA,W
0256E:  SUBWF  xB4,W
02570:  BTFSC  FD8.0
02572:  BRA    257A
02574:  MOVLB  0
02576:  GOTO   25D0
0257A:  MOVLB  0
0257C:  BTFSS  FD8.2
0257E:  GOTO   2594
02582:  MOVLB  A
02584:  MOVF   xB3,W
02586:  SUBWF  xB9,W
02588:  BTFSS  FD8.0
0258A:  BRA    2592
0258C:  MOVLB  0
0258E:  GOTO   25D0
02592:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
02594:  MOVLB  A
02596:  MOVF   xB1,W
02598:  ADDWF  xB9,W
0259A:  MOVWF  FE9
0259C:  MOVF   xB2,W
0259E:  ADDWFC xBA,W
025A0:  MOVWF  FEA
025A2:  MOVLW  02
025A4:  MOVWF  xC5
025A6:  MOVLW  08
025A8:  MOVWF  xC6
025AA:  MOVLW  01
025AC:  MOVWF  xC7
025AE:  MOVLB  0
025B0:  CALL   23B8
025B4:  MOVFF  01,FEF
025B8:  MOVLW  01
025BA:  MOVLB  A
025BC:  ADDWF  xB9,F
025BE:  BTFSC  FD8.0
025C0:  INCF   xBA,F
025C2:  BTFSC  FD8.2
025C4:  INCF   xBB,F
025C6:  BTFSC  FD8.2
025C8:  INCF   xBC,F
025CA:  MOVLB  0
025CC:  GOTO   253A
....................          break;
025D0:  GOTO   26E2
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025D4:  MOVLB  A
025D6:  CLRF   xBE
025D8:  CLRF   xBD
025DA:  MOVLB  0
025DC:  MOVLB  A
025DE:  MOVF   xBE,W
025E0:  SUBWF  xB0,W
025E2:  BTFSC  FD8.0
025E4:  BRA    25EC
025E6:  MOVLB  0
025E8:  GOTO   2638
025EC:  MOVLB  0
025EE:  BTFSS  FD8.2
025F0:  GOTO   2606
025F4:  MOVLB  A
025F6:  MOVF   xAF,W
025F8:  SUBWF  xBD,W
025FA:  BTFSS  FD8.0
025FC:  BRA    2604
025FE:  MOVLB  0
02600:  GOTO   2638
02604:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
02606:  MOVLB  A
02608:  MOVF   xAD,W
0260A:  ADDWF  xBD,W
0260C:  MOVWF  FE9
0260E:  MOVF   xAE,W
02610:  ADDWFC xBE,W
02612:  MOVWF  FEA
02614:  MOVFF  FEF,AC3
02618:  MOVFF  AC3,AC5
0261C:  MOVLW  08
0261E:  MOVWF  xC6
02620:  MOVLW  01
02622:  MOVWF  xC7
02624:  MOVLB  0
02626:  CALL   2434
0262A:  MOVLB  A
0262C:  INCF   xBD,F
0262E:  BTFSC  FD8.2
02630:  INCF   xBE,F
02632:  MOVLB  0
02634:  GOTO   25DC
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02638:  MOVLB  A
0263A:  CLRF   xC2
0263C:  CLRF   xC1
0263E:  CLRF   xC0
02640:  CLRF   xBF
02642:  MOVLB  0
02644:  MOVLB  A
02646:  MOVF   xC2,W
02648:  SUBWF  xB6,W
0264A:  BTFSC  FD8.0
0264C:  BRA    2654
0264E:  MOVLB  0
02650:  GOTO   26DA
02654:  MOVLB  0
02656:  BTFSS  FD8.2
02658:  GOTO   269E
0265C:  MOVLB  A
0265E:  MOVF   xC1,W
02660:  SUBWF  xB5,W
02662:  BTFSC  FD8.0
02664:  BRA    266C
02666:  MOVLB  0
02668:  GOTO   26DA
0266C:  MOVLB  0
0266E:  BTFSS  FD8.2
02670:  GOTO   269E
02674:  MOVLB  A
02676:  MOVF   xC0,W
02678:  SUBWF  xB4,W
0267A:  BTFSC  FD8.0
0267C:  BRA    2684
0267E:  MOVLB  0
02680:  GOTO   26DA
02684:  MOVLB  0
02686:  BTFSS  FD8.2
02688:  GOTO   269E
0268C:  MOVLB  A
0268E:  MOVF   xB3,W
02690:  SUBWF  xBF,W
02692:  BTFSS  FD8.0
02694:  BRA    269C
02696:  MOVLB  0
02698:  GOTO   26DA
0269C:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
0269E:  MOVLB  A
026A0:  MOVF   xB1,W
026A2:  ADDWF  xBF,W
026A4:  MOVWF  FE9
026A6:  MOVF   xB2,W
026A8:  ADDWFC xC0,W
026AA:  MOVWF  FEA
026AC:  MOVLW  01
026AE:  MOVWF  xC5
026B0:  MOVLW  08
026B2:  MOVWF  xC6
026B4:  MOVLW  01
026B6:  MOVWF  xC7
026B8:  MOVLB  0
026BA:  CALL   2434
026BE:  MOVFF  01,FEF
026C2:  MOVLW  01
026C4:  MOVLB  A
026C6:  ADDWF  xBF,F
026C8:  BTFSC  FD8.0
026CA:  INCF   xC0,F
026CC:  BTFSC  FD8.2
026CE:  INCF   xC1,F
026D0:  BTFSC  FD8.2
026D2:  INCF   xC2,F
026D4:  MOVLB  0
026D6:  GOTO   2644
....................          break;
026DA:  GOTO   26E2
....................    
....................          
....................       default:
....................          break;
026DE:  GOTO   26E2
....................    }
....................    return;
026E2:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
03CA4:  MOVLB  A
03CA6:  MOVF   xA3,W
03CA8:  XORLW  00
03CAA:  MOVLB  0
03CAC:  BTFSC  FD8.2
03CAE:  GOTO   3CBE
03CB2:  XORLW  01
03CB4:  BTFSC  FD8.2
03CB6:  GOTO   3D6C
03CBA:  GOTO   3E1A
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
03CBE:  MOVLB  A
03CC0:  CLRF   xAE
03CC2:  MOVLB  0
03CC4:  MOVLB  A
03CC6:  MOVF   xA9,W
03CC8:  SUBWF  xAE,W
03CCA:  BTFSS  FD8.0
03CCC:  BRA    3CD4
03CCE:  MOVLB  0
03CD0:  GOTO   3D04
03CD4:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
03CD6:  MOVLB  A
03CD8:  MOVF   xAE,W
03CDA:  ADDWF  xA7,W
03CDC:  MOVWF  FE9
03CDE:  MOVLW  00
03CE0:  ADDWFC xA8,W
03CE2:  MOVWF  FEA
03CE4:  MOVFF  FEF,AB4
03CE8:  MOVFF  AB4,AC5
03CEC:  MOVLW  08
03CEE:  MOVWF  xC6
03CF0:  MOVLW  01
03CF2:  MOVWF  xC7
03CF4:  MOVLB  0
03CF6:  CALL   23B8
03CFA:  MOVLB  A
03CFC:  INCF   xAE,F
03CFE:  MOVLB  0
03D00:  GOTO   3CC4
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03D04:  MOVLB  A
03D06:  CLRF   xB0
03D08:  CLRF   xAF
03D0A:  MOVLB  0
03D0C:  MOVLB  A
03D0E:  MOVF   xB0,W
03D10:  SUBWF  xAD,W
03D12:  BTFSC  FD8.0
03D14:  BRA    3D1C
03D16:  MOVLB  0
03D18:  GOTO   3D68
03D1C:  MOVLB  0
03D1E:  BTFSS  FD8.2
03D20:  GOTO   3D36
03D24:  MOVLB  A
03D26:  MOVF   xAC,W
03D28:  SUBWF  xAF,W
03D2A:  BTFSS  FD8.0
03D2C:  BRA    3D34
03D2E:  MOVLB  0
03D30:  GOTO   3D68
03D34:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
03D36:  MOVLB  A
03D38:  MOVF   xAA,W
03D3A:  ADDWF  xAF,W
03D3C:  MOVWF  FE9
03D3E:  MOVF   xAB,W
03D40:  ADDWFC xB0,W
03D42:  MOVWF  FEA
03D44:  MOVFF  FEF,AB4
03D48:  MOVFF  AB4,AC5
03D4C:  MOVLW  08
03D4E:  MOVWF  xC6
03D50:  MOVLW  01
03D52:  MOVWF  xC7
03D54:  MOVLB  0
03D56:  CALL   23B8
03D5A:  MOVLB  A
03D5C:  INCF   xAF,F
03D5E:  BTFSC  FD8.2
03D60:  INCF   xB0,F
03D62:  MOVLB  0
03D64:  GOTO   3D0C
....................          break;
03D68:  GOTO   3E1E
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
03D6C:  MOVLB  A
03D6E:  CLRF   xB1
03D70:  MOVLB  0
03D72:  MOVLB  A
03D74:  MOVF   xA9,W
03D76:  SUBWF  xB1,W
03D78:  BTFSS  FD8.0
03D7A:  BRA    3D82
03D7C:  MOVLB  0
03D7E:  GOTO   3DB2
03D82:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
03D84:  MOVLB  A
03D86:  MOVF   xB1,W
03D88:  ADDWF  xA7,W
03D8A:  MOVWF  FE9
03D8C:  MOVLW  00
03D8E:  ADDWFC xA8,W
03D90:  MOVWF  FEA
03D92:  MOVFF  FEF,AB4
03D96:  MOVFF  AB4,AC5
03D9A:  MOVLW  08
03D9C:  MOVWF  xC6
03D9E:  MOVLW  01
03DA0:  MOVWF  xC7
03DA2:  MOVLB  0
03DA4:  CALL   2434
03DA8:  MOVLB  A
03DAA:  INCF   xB1,F
03DAC:  MOVLB  0
03DAE:  GOTO   3D72
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03DB2:  MOVLB  A
03DB4:  CLRF   xB3
03DB6:  CLRF   xB2
03DB8:  MOVLB  0
03DBA:  MOVLB  A
03DBC:  MOVF   xB3,W
03DBE:  SUBWF  xAD,W
03DC0:  BTFSC  FD8.0
03DC2:  BRA    3DCA
03DC4:  MOVLB  0
03DC6:  GOTO   3E16
03DCA:  MOVLB  0
03DCC:  BTFSS  FD8.2
03DCE:  GOTO   3DE4
03DD2:  MOVLB  A
03DD4:  MOVF   xAC,W
03DD6:  SUBWF  xB2,W
03DD8:  BTFSS  FD8.0
03DDA:  BRA    3DE2
03DDC:  MOVLB  0
03DDE:  GOTO   3E16
03DE2:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
03DE4:  MOVLB  A
03DE6:  MOVF   xAA,W
03DE8:  ADDWF  xB2,W
03DEA:  MOVWF  FE9
03DEC:  MOVF   xAB,W
03DEE:  ADDWFC xB3,W
03DF0:  MOVWF  FEA
03DF2:  MOVFF  FEF,AB4
03DF6:  MOVFF  AB4,AC5
03DFA:  MOVLW  08
03DFC:  MOVWF  xC6
03DFE:  MOVLW  01
03E00:  MOVWF  xC7
03E02:  MOVLB  0
03E04:  CALL   2434
03E08:  MOVLB  A
03E0A:  INCF   xB2,F
03E0C:  BTFSC  FD8.2
03E0E:  INCF   xB3,F
03E10:  MOVLB  0
03E12:  GOTO   3DBA
....................          break;
03E16:  GOTO   3E1E
....................          
....................       default:
....................          break;
03E1A:  GOTO   3E1E
....................    }
....................    return;
03E1E:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
060C8:  MOVFF  2CE,AA9
060CC:  MOVLW  01
060CE:  MOVLB  A
060D0:  MOVWF  xAA
060D2:  MOVLW  0F
060D4:  MOVWF  xAC
060D6:  MOVLW  89
060D8:  MOVWF  xAB
060DA:  MOVLB  0
060DC:  CALL   2364
060E0:  MOVFF  2CE,AA9
060E4:  MOVLB  A
060E6:  CLRF   xAA
060E8:  MOVLW  0F
060EA:  MOVWF  xAC
060EC:  MOVLW  92
060EE:  MOVWF  xAB
060F0:  MOVLB  0
060F2:  CALL   2364
060F6:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
03E20:  MOVLW  05
03E22:  MOVLB  A
03E24:  MOVWF  xA7
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
03E26:  MOVFF  AA5,AA9
03E2A:  CLRF   xAA
03E2C:  MOVLW  0F
03E2E:  MOVWF  xAC
03E30:  MOVLW  89
03E32:  MOVWF  xAB
03E34:  MOVLB  0
03E36:  CALL   2364
03E3A:  MOVFF  AA5,AA9
03E3E:  MOVLB  A
03E40:  CLRF   xAA
03E42:  MOVLW  0F
03E44:  MOVWF  xAC
03E46:  MOVLW  92
03E48:  MOVWF  xAB
03E4A:  MOVLB  0
03E4C:  CALL   2364
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
03E50:  MOVFF  AA6,AAC
03E54:  MOVFF  AA5,AAB
03E58:  MOVFF  AA4,AAA
03E5C:  MOVFF  AA3,AA9
03E60:  MOVLW  0A
03E62:  MOVLB  A
03E64:  MOVWF  xAE
03E66:  MOVLW  A7
03E68:  MOVWF  xAD
03E6A:  CLRF   xB0
03E6C:  MOVLW  01
03E6E:  MOVWF  xAF
03E70:  MOVLW  0A
03E72:  MOVWF  xB2
03E74:  MOVLW  A8
03E76:  MOVWF  xB1
03E78:  CLRF   xB6
03E7A:  CLRF   xB5
03E7C:  CLRF   xB4
03E7E:  MOVLW  01
03E80:  MOVWF  xB3
03E82:  MOVLB  0
03E84:  CALL   24B0
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
03E88:  MOVFF  AA5,AA9
03E8C:  MOVLW  01
03E8E:  MOVLB  A
03E90:  MOVWF  xAA
03E92:  MOVLW  0F
03E94:  MOVWF  xAC
03E96:  MOVLW  89
03E98:  MOVWF  xAB
03E9A:  MOVLB  0
03E9C:  CALL   2364
03EA0:  MOVFF  AA5,AA9
03EA4:  MOVLB  A
03EA6:  CLRF   xAA
03EA8:  MOVLW  0F
03EAA:  MOVWF  xAC
03EAC:  MOVLW  92
03EAE:  MOVWF  xAB
03EB0:  MOVLB  0
03EB2:  CALL   2364
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
03EB6:  MOVLB  A
03EB8:  MOVF   xA8,W
03EBA:  MOVWF  01
03EBC:  MOVLB  0
03EBE:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
045DC:  MOVLB  A
045DE:  MOVF   x8A,F
045E0:  BTFSC  FD8.2
045E2:  BRA    45EA
045E4:  MOVLB  0
045E6:  GOTO   4740
045EA:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
045EC:  MOVLW  06
045EE:  MOVLB  A
045F0:  MOVWF  x91
045F2:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
045F4:  MOVLW  D8
045F6:  MOVLB  A
045F8:  MOVWF  x92
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
045FA:  MOVFF  A8F,A9E
045FE:  MOVFF  A90,A9F
04602:  CLRF   xA0
04604:  CLRF   xA1
04606:  MOVF   x9E,W
04608:  MOVWF  00
0460A:  CLRF   01
0460C:  CLRF   02
0460E:  CLRF   03
04610:  MOVFF  00,A93
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04614:  MOVFF  A8E,A9E
04618:  MOVFF  A8F,A9F
0461C:  MOVFF  A90,AA0
04620:  CLRF   xA1
04622:  MOVF   x9E,W
04624:  MOVWF  00
04626:  CLRF   01
04628:  CLRF   02
0462A:  CLRF   03
0462C:  MOVFF  00,A94
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
04630:  MOVF   x8D,W
04632:  MOVWF  00
04634:  CLRF   01
04636:  CLRF   02
04638:  CLRF   03
0463A:  MOVFF  00,A95
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
0463E:  MOVFF  A8B,AA9
04642:  CLRF   xAA
04644:  MOVLW  0F
04646:  MOVWF  xAC
04648:  MOVLW  89
0464A:  MOVWF  xAB
0464C:  MOVLB  0
0464E:  CALL   2364
04652:  MOVFF  A8B,AA9
04656:  MOVLB  A
04658:  CLRF   xAA
0465A:  MOVLW  0F
0465C:  MOVWF  xAC
0465E:  MOVLW  92
04660:  MOVWF  xAB
04662:  MOVLB  0
04664:  CALL   2364
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04668:  MOVFF  A8C,AA6
0466C:  MOVFF  A8B,AA5
04670:  MOVFF  A8A,AA4
04674:  MOVFF  A89,AA3
04678:  MOVLW  0A
0467A:  MOVLB  A
0467C:  MOVWF  xA8
0467E:  MOVLW  91
04680:  MOVWF  xA7
04682:  CLRF   xAA
04684:  MOVLW  01
04686:  MOVWF  xA9
04688:  MOVLB  0
0468A:  CALL   3BB4
....................       output_high(flash_stream.cs_pin);
0468E:  MOVFF  A8B,AA9
04692:  MOVLW  01
04694:  MOVLB  A
04696:  MOVWF  xAA
04698:  MOVLW  0F
0469A:  MOVWF  xAC
0469C:  MOVLW  89
0469E:  MOVWF  xAB
046A0:  MOVLB  0
046A2:  CALL   2364
046A6:  MOVFF  A8B,AA9
046AA:  MOVLB  A
046AC:  CLRF   xAA
046AE:  MOVLW  0F
046B0:  MOVWF  xAC
046B2:  MOVLW  92
046B4:  MOVWF  xAB
046B6:  MOVLB  0
046B8:  CALL   2364
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
046BC:  MOVFF  A8B,AA9
046C0:  MOVLB  A
046C2:  CLRF   xAA
046C4:  MOVLW  0F
046C6:  MOVWF  xAC
046C8:  MOVLW  89
046CA:  MOVWF  xAB
046CC:  MOVLB  0
046CE:  CALL   2364
046D2:  MOVFF  A8B,AA9
046D6:  MOVLB  A
046D8:  CLRF   xAA
046DA:  MOVLW  0F
046DC:  MOVWF  xAC
046DE:  MOVLW  92
046E0:  MOVWF  xAB
046E2:  MOVLB  0
046E4:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
046E8:  MOVFF  A8C,AA6
046EC:  MOVFF  A8B,AA5
046F0:  MOVFF  A8A,AA4
046F4:  MOVFF  A89,AA3
046F8:  MOVLW  0A
046FA:  MOVLB  A
046FC:  MOVWF  xA8
046FE:  MOVLW  92
04700:  MOVWF  xA7
04702:  CLRF   xAA
04704:  MOVLW  04
04706:  MOVWF  xA9
04708:  MOVLB  0
0470A:  CALL   3BB4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0470E:  MOVFF  A8B,AA9
04712:  MOVLW  01
04714:  MOVLB  A
04716:  MOVWF  xAA
04718:  MOVLW  0F
0471A:  MOVWF  xAC
0471C:  MOVLW  89
0471E:  MOVWF  xAB
04720:  MOVLB  0
04722:  CALL   2364
04726:  MOVFF  A8B,AA9
0472A:  MOVLB  A
0472C:  CLRF   xAA
0472E:  MOVLW  0F
04730:  MOVWF  xAC
04732:  MOVLW  92
04734:  MOVWF  xAB
04736:  MOVLB  0
04738:  CALL   2364
....................    }
0473C:  GOTO   48BE
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04740:  MOVLB  A
04742:  DECFSZ x8A,W
04744:  BRA    474A
04746:  BRA    4750
04748:  MOVLB  0
0474A:  MOVLB  0
0474C:  GOTO   48BE
04750:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04752:  MOVLW  06
04754:  MOVLB  A
04756:  MOVWF  x96
04758:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
0475A:  MOVLW  DC
0475C:  MOVLB  A
0475E:  MOVWF  x97
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04760:  MOVFF  A90,A9E
04764:  CLRF   x9F
04766:  CLRF   xA0
04768:  CLRF   xA1
0476A:  MOVF   x9E,W
0476C:  MOVWF  00
0476E:  CLRF   01
04770:  CLRF   02
04772:  CLRF   03
04774:  MOVFF  00,A98
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04778:  MOVFF  A8F,A9E
0477C:  MOVFF  A90,A9F
04780:  CLRF   xA0
04782:  CLRF   xA1
04784:  MOVF   x9E,W
04786:  MOVWF  00
04788:  CLRF   01
0478A:  CLRF   02
0478C:  CLRF   03
0478E:  MOVFF  00,A99
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04792:  MOVFF  A8E,A9E
04796:  MOVFF  A8F,A9F
0479A:  MOVFF  A90,AA0
0479E:  CLRF   xA1
047A0:  MOVF   x9E,W
047A2:  MOVWF  00
047A4:  CLRF   01
047A6:  CLRF   02
047A8:  CLRF   03
047AA:  MOVFF  00,A9A
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
047AE:  MOVF   x8D,W
047B0:  MOVWF  00
047B2:  CLRF   01
047B4:  CLRF   02
047B6:  CLRF   03
047B8:  MOVFF  00,A9B
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
047BC:  MOVFF  A8B,AA9
047C0:  CLRF   xAA
047C2:  MOVLW  0F
047C4:  MOVWF  xAC
047C6:  MOVLW  89
047C8:  MOVWF  xAB
047CA:  MOVLB  0
047CC:  CALL   2364
047D0:  MOVFF  A8B,AA9
047D4:  MOVLB  A
047D6:  CLRF   xAA
047D8:  MOVLW  0F
047DA:  MOVWF  xAC
047DC:  MOVLW  92
047DE:  MOVWF  xAB
047E0:  MOVLB  0
047E2:  CALL   2364
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
047E6:  MOVFF  A8C,AA6
047EA:  MOVFF  A8B,AA5
047EE:  MOVFF  A8A,AA4
047F2:  MOVFF  A89,AA3
047F6:  MOVLW  0A
047F8:  MOVLB  A
047FA:  MOVWF  xA8
047FC:  MOVLW  96
047FE:  MOVWF  xA7
04800:  CLRF   xAA
04802:  MOVLW  01
04804:  MOVWF  xA9
04806:  MOVLB  0
04808:  CALL   3BB4
....................       output_high(flash_stream.cs_pin);
0480C:  MOVFF  A8B,AA9
04810:  MOVLW  01
04812:  MOVLB  A
04814:  MOVWF  xAA
04816:  MOVLW  0F
04818:  MOVWF  xAC
0481A:  MOVLW  89
0481C:  MOVWF  xAB
0481E:  MOVLB  0
04820:  CALL   2364
04824:  MOVFF  A8B,AA9
04828:  MOVLB  A
0482A:  CLRF   xAA
0482C:  MOVLW  0F
0482E:  MOVWF  xAC
04830:  MOVLW  92
04832:  MOVWF  xAB
04834:  MOVLB  0
04836:  CALL   2364
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
0483A:  MOVFF  A8B,AA9
0483E:  MOVLB  A
04840:  CLRF   xAA
04842:  MOVLW  0F
04844:  MOVWF  xAC
04846:  MOVLW  89
04848:  MOVWF  xAB
0484A:  MOVLB  0
0484C:  CALL   2364
04850:  MOVFF  A8B,AA9
04854:  MOVLB  A
04856:  CLRF   xAA
04858:  MOVLW  0F
0485A:  MOVWF  xAC
0485C:  MOVLW  92
0485E:  MOVWF  xAB
04860:  MOVLB  0
04862:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04866:  MOVFF  A8C,AA6
0486A:  MOVFF  A8B,AA5
0486E:  MOVFF  A8A,AA4
04872:  MOVFF  A89,AA3
04876:  MOVLW  0A
04878:  MOVLB  A
0487A:  MOVWF  xA8
0487C:  MOVLW  97
0487E:  MOVWF  xA7
04880:  CLRF   xAA
04882:  MOVLW  05
04884:  MOVWF  xA9
04886:  MOVLB  0
04888:  CALL   3BB4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0488C:  MOVFF  A8B,AA9
04890:  MOVLW  01
04892:  MOVLB  A
04894:  MOVWF  xAA
04896:  MOVLW  0F
04898:  MOVWF  xAC
0489A:  MOVLW  89
0489C:  MOVWF  xAB
0489E:  MOVLB  0
048A0:  CALL   2364
048A4:  MOVFF  A8B,AA9
048A8:  MOVLB  A
048AA:  CLRF   xAA
048AC:  MOVLW  0F
048AE:  MOVWF  xAC
048B0:  MOVLW  92
048B2:  MOVWF  xAB
048B4:  MOVLB  0
048B6:  CALL   2364
....................    }
048BA:  GOTO   48BE
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
048BE:  MOVLB  A
048C0:  CLRF   x9C
048C2:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
048C4:  MOVFF  A8C,AA6
048C8:  MOVFF  A8B,AA5
048CC:  MOVFF  A8A,AA4
048D0:  MOVFF  A89,AA3
048D4:  CALL   3E20
048D8:  MOVF   01,W
048DA:  ANDLW  01
048DC:  SUBLW  01
048DE:  BTFSS  FD8.2
048E0:  GOTO   4932
....................       if(timeout_counter > 10)
048E4:  MOVLB  A
048E6:  MOVF   x9C,W
048E8:  SUBLW  0A
048EA:  BTFSS  FD8.0
048EC:  BRA    48F4
048EE:  MOVLB  0
048F0:  GOTO   4906
048F4:  MOVLB  0
....................          delay_ms(200);
048F6:  MOVLW  C8
048F8:  MOVLB  A
048FA:  MOVWF  xA3
048FC:  MOVLB  0
048FE:  CALL   1BC8
04902:  GOTO   4912
....................       else
....................          delay_ms(10);   
04906:  MOVLW  0A
04908:  MOVLB  A
0490A:  MOVWF  xA3
0490C:  MOVLB  0
0490E:  CALL   1BC8
....................       
....................       if(timeout_counter > 100){
04912:  MOVLB  A
04914:  MOVF   x9C,W
04916:  SUBLW  64
04918:  BTFSS  FD8.0
0491A:  BRA    4922
0491C:  MOVLB  0
0491E:  GOTO   4928
04922:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
04924:  GOTO   4932
....................       }  
....................       timeout_counter++;
04928:  MOVLB  A
0492A:  INCF   x9C,F
0492C:  MOVLB  0
0492E:  GOTO   48C4
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
04932:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
05650:  MOVLB  3
05652:  MOVF   x17,F
05654:  BTFSC  FD8.2
05656:  BRA    565E
05658:  MOVLB  0
0565A:  GOTO   57B6
0565E:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
05660:  MOVLW  06
05662:  MOVLB  3
05664:  MOVWF  x1E
05666:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
05668:  MOVLW  20
0566A:  MOVLB  3
0566C:  MOVWF  x1F
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
0566E:  MOVFF  31C,32B
05672:  MOVFF  31D,32C
05676:  CLRF   x2D
05678:  CLRF   x2E
0567A:  MOVF   x2B,W
0567C:  MOVWF  00
0567E:  CLRF   01
05680:  CLRF   02
05682:  CLRF   03
05684:  MOVFF  00,320
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
05688:  MOVFF  31B,32B
0568C:  MOVFF  31C,32C
05690:  MOVFF  31D,32D
05694:  CLRF   x2E
05696:  MOVF   x2B,W
05698:  MOVWF  00
0569A:  CLRF   01
0569C:  CLRF   02
0569E:  CLRF   03
056A0:  MOVFF  00,321
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
056A4:  MOVF   x1A,W
056A6:  MOVWF  00
056A8:  CLRF   01
056AA:  CLRF   02
056AC:  CLRF   03
056AE:  MOVFF  00,322
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
056B2:  MOVFF  318,AA9
056B6:  MOVLB  A
056B8:  CLRF   xAA
056BA:  MOVLW  0F
056BC:  MOVWF  xAC
056BE:  MOVLW  89
056C0:  MOVWF  xAB
056C2:  MOVLB  0
056C4:  CALL   2364
056C8:  MOVFF  318,AA9
056CC:  MOVLB  A
056CE:  CLRF   xAA
056D0:  MOVLW  0F
056D2:  MOVWF  xAC
056D4:  MOVLW  92
056D6:  MOVWF  xAB
056D8:  MOVLB  0
056DA:  CALL   2364
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
056DE:  MOVFF  319,AA6
056E2:  MOVFF  318,AA5
056E6:  MOVFF  317,AA4
056EA:  MOVFF  316,AA3
056EE:  MOVLW  03
056F0:  MOVLB  A
056F2:  MOVWF  xA8
056F4:  MOVLW  1E
056F6:  MOVWF  xA7
056F8:  CLRF   xAA
056FA:  MOVLW  01
056FC:  MOVWF  xA9
056FE:  MOVLB  0
05700:  CALL   3BB4
....................       output_high(flash_stream.cs_pin);
05704:  MOVFF  318,AA9
05708:  MOVLW  01
0570A:  MOVLB  A
0570C:  MOVWF  xAA
0570E:  MOVLW  0F
05710:  MOVWF  xAC
05712:  MOVLW  89
05714:  MOVWF  xAB
05716:  MOVLB  0
05718:  CALL   2364
0571C:  MOVFF  318,AA9
05720:  MOVLB  A
05722:  CLRF   xAA
05724:  MOVLW  0F
05726:  MOVWF  xAC
05728:  MOVLW  92
0572A:  MOVWF  xAB
0572C:  MOVLB  0
0572E:  CALL   2364
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
05732:  MOVFF  318,AA9
05736:  MOVLB  A
05738:  CLRF   xAA
0573A:  MOVLW  0F
0573C:  MOVWF  xAC
0573E:  MOVLW  89
05740:  MOVWF  xAB
05742:  MOVLB  0
05744:  CALL   2364
05748:  MOVFF  318,AA9
0574C:  MOVLB  A
0574E:  CLRF   xAA
05750:  MOVLW  0F
05752:  MOVWF  xAC
05754:  MOVLW  92
05756:  MOVWF  xAB
05758:  MOVLB  0
0575A:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
0575E:  MOVFF  319,AA6
05762:  MOVFF  318,AA5
05766:  MOVFF  317,AA4
0576A:  MOVFF  316,AA3
0576E:  MOVLW  03
05770:  MOVLB  A
05772:  MOVWF  xA8
05774:  MOVLW  1F
05776:  MOVWF  xA7
05778:  CLRF   xAA
0577A:  MOVLW  04
0577C:  MOVWF  xA9
0577E:  MOVLB  0
05780:  CALL   3BB4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
05784:  MOVFF  318,AA9
05788:  MOVLW  01
0578A:  MOVLB  A
0578C:  MOVWF  xAA
0578E:  MOVLW  0F
05790:  MOVWF  xAC
05792:  MOVLW  89
05794:  MOVWF  xAB
05796:  MOVLB  0
05798:  CALL   2364
0579C:  MOVFF  318,AA9
057A0:  MOVLB  A
057A2:  CLRF   xAA
057A4:  MOVLW  0F
057A6:  MOVWF  xAC
057A8:  MOVLW  92
057AA:  MOVWF  xAB
057AC:  MOVLB  0
057AE:  CALL   2364
....................    }
057B2:  GOTO   5936
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
057B6:  MOVLB  3
057B8:  DECFSZ x17,W
057BA:  BRA    57C0
057BC:  BRA    57C6
057BE:  MOVLB  0
057C0:  MOVLB  0
057C2:  GOTO   5936
057C6:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
057C8:  MOVLW  06
057CA:  MOVLB  3
057CC:  MOVWF  x23
057CE:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
057D0:  MOVLW  21
057D2:  MOVLB  3
057D4:  MOVWF  x24
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
057D6:  MOVFF  31D,32B
057DA:  CLRF   x2C
057DC:  CLRF   x2D
057DE:  CLRF   x2E
057E0:  MOVF   x2B,W
057E2:  MOVWF  00
057E4:  CLRF   01
057E6:  CLRF   02
057E8:  CLRF   03
057EA:  MOVFF  00,325
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
057EE:  MOVFF  31C,32B
057F2:  MOVFF  31D,32C
057F6:  CLRF   x2D
057F8:  CLRF   x2E
057FA:  MOVF   x2B,W
057FC:  MOVWF  00
057FE:  CLRF   01
05800:  CLRF   02
05802:  CLRF   03
05804:  MOVFF  00,326
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
05808:  MOVFF  31B,32B
0580C:  MOVFF  31C,32C
05810:  MOVFF  31D,32D
05814:  CLRF   x2E
05816:  MOVF   x2B,W
05818:  MOVWF  00
0581A:  CLRF   01
0581C:  CLRF   02
0581E:  CLRF   03
05820:  MOVFF  00,327
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
05824:  MOVF   x1A,W
05826:  MOVWF  00
05828:  CLRF   01
0582A:  CLRF   02
0582C:  CLRF   03
0582E:  MOVFF  00,328
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
05832:  MOVFF  318,AA9
05836:  MOVLB  A
05838:  CLRF   xAA
0583A:  MOVLW  0F
0583C:  MOVWF  xAC
0583E:  MOVLW  89
05840:  MOVWF  xAB
05842:  MOVLB  0
05844:  CALL   2364
05848:  MOVFF  318,AA9
0584C:  MOVLB  A
0584E:  CLRF   xAA
05850:  MOVLW  0F
05852:  MOVWF  xAC
05854:  MOVLW  92
05856:  MOVWF  xAB
05858:  MOVLB  0
0585A:  CALL   2364
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
0585E:  MOVFF  319,AA6
05862:  MOVFF  318,AA5
05866:  MOVFF  317,AA4
0586A:  MOVFF  316,AA3
0586E:  MOVLW  03
05870:  MOVLB  A
05872:  MOVWF  xA8
05874:  MOVLW  23
05876:  MOVWF  xA7
05878:  CLRF   xAA
0587A:  MOVLW  01
0587C:  MOVWF  xA9
0587E:  MOVLB  0
05880:  CALL   3BB4
....................       output_high(flash_stream.cs_pin);
05884:  MOVFF  318,AA9
05888:  MOVLW  01
0588A:  MOVLB  A
0588C:  MOVWF  xAA
0588E:  MOVLW  0F
05890:  MOVWF  xAC
05892:  MOVLW  89
05894:  MOVWF  xAB
05896:  MOVLB  0
05898:  CALL   2364
0589C:  MOVFF  318,AA9
058A0:  MOVLB  A
058A2:  CLRF   xAA
058A4:  MOVLW  0F
058A6:  MOVWF  xAC
058A8:  MOVLW  92
058AA:  MOVWF  xAB
058AC:  MOVLB  0
058AE:  CALL   2364
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
058B2:  MOVFF  318,AA9
058B6:  MOVLB  A
058B8:  CLRF   xAA
058BA:  MOVLW  0F
058BC:  MOVWF  xAC
058BE:  MOVLW  89
058C0:  MOVWF  xAB
058C2:  MOVLB  0
058C4:  CALL   2364
058C8:  MOVFF  318,AA9
058CC:  MOVLB  A
058CE:  CLRF   xAA
058D0:  MOVLW  0F
058D2:  MOVWF  xAC
058D4:  MOVLW  92
058D6:  MOVWF  xAB
058D8:  MOVLB  0
058DA:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
058DE:  MOVFF  319,AA6
058E2:  MOVFF  318,AA5
058E6:  MOVFF  317,AA4
058EA:  MOVFF  316,AA3
058EE:  MOVLW  03
058F0:  MOVLB  A
058F2:  MOVWF  xA8
058F4:  MOVLW  24
058F6:  MOVWF  xA7
058F8:  CLRF   xAA
058FA:  MOVLW  05
058FC:  MOVWF  xA9
058FE:  MOVLB  0
05900:  CALL   3BB4
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
05904:  MOVFF  318,AA9
05908:  MOVLW  01
0590A:  MOVLB  A
0590C:  MOVWF  xAA
0590E:  MOVLW  0F
05910:  MOVWF  xAC
05912:  MOVLW  89
05914:  MOVWF  xAB
05916:  MOVLB  0
05918:  CALL   2364
0591C:  MOVFF  318,AA9
05920:  MOVLB  A
05922:  CLRF   xAA
05924:  MOVLW  0F
05926:  MOVWF  xAC
05928:  MOVLW  92
0592A:  MOVWF  xAB
0592C:  MOVLB  0
0592E:  CALL   2364
....................    }
05932:  GOTO   5936
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
05936:  MOVLB  3
05938:  CLRF   x29
0593A:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
0593C:  MOVFF  319,AA6
05940:  MOVFF  318,AA5
05944:  MOVFF  317,AA4
05948:  MOVFF  316,AA3
0594C:  CALL   3E20
05950:  MOVF   01,W
05952:  ANDLW  01
05954:  SUBLW  01
05956:  BTFSS  FD8.2
05958:  GOTO   59AA
....................       if(timeout_counter > 10)
0595C:  MOVLB  3
0595E:  MOVF   x29,W
05960:  SUBLW  0A
05962:  BTFSS  FD8.0
05964:  BRA    596C
05966:  MOVLB  0
05968:  GOTO   597E
0596C:  MOVLB  0
....................          delay_ms(200);
0596E:  MOVLW  C8
05970:  MOVLB  A
05972:  MOVWF  xA3
05974:  MOVLB  0
05976:  CALL   1BC8
0597A:  GOTO   598A
....................       else
....................          delay_ms(10);   
0597E:  MOVLW  0A
05980:  MOVLB  A
05982:  MOVWF  xA3
05984:  MOVLB  0
05986:  CALL   1BC8
....................       
....................       if(timeout_counter > 100){
0598A:  MOVLB  3
0598C:  MOVF   x29,W
0598E:  SUBLW  64
05990:  BTFSS  FD8.0
05992:  BRA    599A
05994:  MOVLB  0
05996:  GOTO   59A0
0599A:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
0599C:  GOTO   59AA
....................       }  
....................       timeout_counter++;
059A0:  MOVLB  3
059A2:  INCF   x29,F
059A4:  MOVLB  0
059A6:  GOTO   593C
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
059AA:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
027D0:  MOVLB  3
027D2:  MOVF   x17,F
027D4:  BTFSC  FD8.2
027D6:  BRA    27DE
027D8:  MOVLB  0
027DA:  GOTO   28D0
027DE:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
027E0:  MOVLW  03
027E2:  MOVLB  3
027E4:  MOVWF  x24
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
027E6:  MOVFF  31C,32E
027EA:  MOVFF  31D,32F
027EE:  CLRF   x30
027F0:  CLRF   x31
027F2:  MOVF   x2E,W
027F4:  MOVWF  00
027F6:  CLRF   01
027F8:  CLRF   02
027FA:  CLRF   03
027FC:  MOVFF  00,325
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
02800:  MOVFF  31B,32E
02804:  MOVFF  31C,32F
02808:  MOVFF  31D,330
0280C:  CLRF   x31
0280E:  MOVF   x2E,W
02810:  MOVWF  00
02812:  CLRF   01
02814:  CLRF   02
02816:  CLRF   03
02818:  MOVFF  00,326
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
0281C:  MOVF   x1A,W
0281E:  MOVWF  00
02820:  CLRF   01
02822:  CLRF   02
02824:  CLRF   03
02826:  MOVFF  00,327
....................             
....................       output_low(flash_stream.cs_pin);
0282A:  MOVFF  318,AA9
0282E:  MOVLB  A
02830:  CLRF   xAA
02832:  MOVLW  0F
02834:  MOVWF  xAC
02836:  MOVLW  89
02838:  MOVWF  xAB
0283A:  MOVLB  0
0283C:  CALL   2364
02840:  MOVFF  318,AA9
02844:  MOVLB  A
02846:  CLRF   xAA
02848:  MOVLW  0F
0284A:  MOVWF  xAC
0284C:  MOVLW  92
0284E:  MOVWF  xAB
02850:  MOVLB  0
02852:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
02856:  MOVFF  319,AAC
0285A:  MOVFF  318,AAB
0285E:  MOVFF  317,AAA
02862:  MOVFF  316,AA9
02866:  MOVLW  03
02868:  MOVLB  A
0286A:  MOVWF  xAE
0286C:  MOVLW  24
0286E:  MOVWF  xAD
02870:  CLRF   xB0
02872:  MOVLW  04
02874:  MOVWF  xAF
02876:  MOVFF  31F,AB2
0287A:  MOVFF  31E,AB1
0287E:  MOVFF  323,AB6
02882:  MOVFF  322,AB5
02886:  MOVFF  321,AB4
0288A:  MOVFF  320,AB3
0288E:  MOVLB  0
02890:  CALL   24B0
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
02894:  MOVLW  02
02896:  MOVWF  00
02898:  DECFSZ 00,F
0289A:  BRA    2898
0289C:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0289E:  MOVFF  318,AA9
028A2:  MOVLW  01
028A4:  MOVLB  A
028A6:  MOVWF  xAA
028A8:  MOVLW  0F
028AA:  MOVWF  xAC
028AC:  MOVLW  89
028AE:  MOVWF  xAB
028B0:  MOVLB  0
028B2:  CALL   2364
028B6:  MOVFF  318,AA9
028BA:  MOVLB  A
028BC:  CLRF   xAA
028BE:  MOVLW  0F
028C0:  MOVWF  xAC
028C2:  MOVLW  92
028C4:  MOVWF  xAB
028C6:  MOVLB  0
028C8:  CALL   2364
....................    }
028CC:  GOTO   29E6
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
028D0:  MOVLB  3
028D2:  DECFSZ x17,W
028D4:  BRA    28DA
028D6:  BRA    28E0
028D8:  MOVLB  0
028DA:  MOVLB  0
028DC:  GOTO   29E6
028E0:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
028E2:  MOVLW  13
028E4:  MOVLB  3
028E6:  MOVWF  x28
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
028E8:  MOVFF  31D,32E
028EC:  CLRF   x2F
028EE:  CLRF   x30
028F0:  CLRF   x31
028F2:  MOVF   x2E,W
028F4:  MOVWF  00
028F6:  CLRF   01
028F8:  CLRF   02
028FA:  CLRF   03
028FC:  MOVFF  00,329
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
02900:  MOVFF  31C,32E
02904:  MOVFF  31D,32F
02908:  CLRF   x30
0290A:  CLRF   x31
0290C:  MOVF   x2E,W
0290E:  MOVWF  00
02910:  CLRF   01
02912:  CLRF   02
02914:  CLRF   03
02916:  MOVFF  00,32A
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0291A:  MOVFF  31B,32E
0291E:  MOVFF  31C,32F
02922:  MOVFF  31D,330
02926:  CLRF   x31
02928:  MOVF   x2E,W
0292A:  MOVWF  00
0292C:  CLRF   01
0292E:  CLRF   02
02930:  CLRF   03
02932:  MOVFF  00,32B
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02936:  MOVF   x1A,W
02938:  MOVWF  00
0293A:  CLRF   01
0293C:  CLRF   02
0293E:  CLRF   03
02940:  MOVFF  00,32C
....................    
....................       output_low(flash_stream.cs_pin);
02944:  MOVFF  318,AA9
02948:  MOVLB  A
0294A:  CLRF   xAA
0294C:  MOVLW  0F
0294E:  MOVWF  xAC
02950:  MOVLW  89
02952:  MOVWF  xAB
02954:  MOVLB  0
02956:  CALL   2364
0295A:  MOVFF  318,AA9
0295E:  MOVLB  A
02960:  CLRF   xAA
02962:  MOVLW  0F
02964:  MOVWF  xAC
02966:  MOVLW  92
02968:  MOVWF  xAB
0296A:  MOVLB  0
0296C:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02970:  MOVFF  319,AAC
02974:  MOVFF  318,AAB
02978:  MOVFF  317,AAA
0297C:  MOVFF  316,AA9
02980:  MOVLW  03
02982:  MOVLB  A
02984:  MOVWF  xAE
02986:  MOVLW  28
02988:  MOVWF  xAD
0298A:  CLRF   xB0
0298C:  MOVLW  05
0298E:  MOVWF  xAF
02990:  MOVFF  31F,AB2
02994:  MOVFF  31E,AB1
02998:  MOVFF  323,AB6
0299C:  MOVFF  322,AB5
029A0:  MOVFF  321,AB4
029A4:  MOVFF  320,AB3
029A8:  MOVLB  0
029AA:  CALL   24B0
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029AE:  MOVLW  02
029B0:  MOVWF  00
029B2:  DECFSZ 00,F
029B4:  BRA    29B2
029B6:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029B8:  MOVFF  318,AA9
029BC:  MOVLW  01
029BE:  MOVLB  A
029C0:  MOVWF  xAA
029C2:  MOVLW  0F
029C4:  MOVWF  xAC
029C6:  MOVLW  89
029C8:  MOVWF  xAB
029CA:  MOVLB  0
029CC:  CALL   2364
029D0:  MOVFF  318,AA9
029D4:  MOVLB  A
029D6:  CLRF   xAA
029D8:  MOVLW  0F
029DA:  MOVWF  xAC
029DC:  MOVLW  92
029DE:  MOVWF  xAB
029E0:  MOVLB  0
029E2:  CALL   2364
....................    }
....................    return;
029E6:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
03EC0:  MOVLB  A
03EC2:  MOVF   x8C,F
03EC4:  BTFSC  FD8.2
03EC6:  BRA    3ECE
03EC8:  MOVLB  0
03ECA:  GOTO   403C
03ECE:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
03ED0:  MOVLW  06
03ED2:  MOVLB  A
03ED4:  MOVWF  x97
03ED6:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
03ED8:  MOVLW  02
03EDA:  MOVLB  A
03EDC:  MOVWF  x98
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03EDE:  MOVFF  A91,AA4
03EE2:  MOVFF  A92,AA5
03EE6:  CLRF   xA6
03EE8:  CLRF   xA7
03EEA:  MOVF   xA4,W
03EEC:  MOVWF  00
03EEE:  CLRF   01
03EF0:  CLRF   02
03EF2:  CLRF   03
03EF4:  MOVFF  00,A99
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03EF8:  MOVFF  A90,AA4
03EFC:  MOVFF  A91,AA5
03F00:  MOVFF  A92,AA6
03F04:  CLRF   xA7
03F06:  MOVF   xA4,W
03F08:  MOVWF  00
03F0A:  CLRF   01
03F0C:  CLRF   02
03F0E:  CLRF   03
03F10:  MOVFF  00,A9A
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
03F14:  MOVF   x8F,W
03F16:  MOVWF  00
03F18:  CLRF   01
03F1A:  CLRF   02
03F1C:  CLRF   03
03F1E:  MOVFF  00,A9B
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03F22:  MOVFF  A8D,AA9
03F26:  CLRF   xAA
03F28:  MOVLW  0F
03F2A:  MOVWF  xAC
03F2C:  MOVLW  89
03F2E:  MOVWF  xAB
03F30:  MOVLB  0
03F32:  CALL   2364
03F36:  MOVFF  A8D,AA9
03F3A:  MOVLB  A
03F3C:  CLRF   xAA
03F3E:  MOVLW  0F
03F40:  MOVWF  xAC
03F42:  MOVLW  92
03F44:  MOVWF  xAB
03F46:  MOVLB  0
03F48:  CALL   2364
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
03F4C:  MOVFF  A8E,AA6
03F50:  MOVFF  A8D,AA5
03F54:  MOVFF  A8C,AA4
03F58:  MOVFF  A8B,AA3
03F5C:  MOVLW  0A
03F5E:  MOVLB  A
03F60:  MOVWF  xA8
03F62:  MOVLW  97
03F64:  MOVWF  xA7
03F66:  CLRF   xAA
03F68:  MOVLW  01
03F6A:  MOVWF  xA9
03F6C:  MOVLB  0
03F6E:  CALL   3BB4
....................       output_high(flash_stream.cs_pin);
03F72:  MOVFF  A8D,AA9
03F76:  MOVLW  01
03F78:  MOVLB  A
03F7A:  MOVWF  xAA
03F7C:  MOVLW  0F
03F7E:  MOVWF  xAC
03F80:  MOVLW  89
03F82:  MOVWF  xAB
03F84:  MOVLB  0
03F86:  CALL   2364
03F8A:  MOVFF  A8D,AA9
03F8E:  MOVLB  A
03F90:  CLRF   xAA
03F92:  MOVLW  0F
03F94:  MOVWF  xAC
03F96:  MOVLW  92
03F98:  MOVWF  xAB
03F9A:  MOVLB  0
03F9C:  CALL   2364
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
03FA0:  MOVFF  A8D,AA9
03FA4:  MOVLB  A
03FA6:  CLRF   xAA
03FA8:  MOVLW  0F
03FAA:  MOVWF  xAC
03FAC:  MOVLW  89
03FAE:  MOVWF  xAB
03FB0:  MOVLB  0
03FB2:  CALL   2364
03FB6:  MOVFF  A8D,AA9
03FBA:  MOVLB  A
03FBC:  CLRF   xAA
03FBE:  MOVLW  0F
03FC0:  MOVWF  xAC
03FC2:  MOVLW  92
03FC4:  MOVWF  xAB
03FC6:  MOVLB  0
03FC8:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
03FCC:  MOVFF  A8E,AA6
03FD0:  MOVFF  A8D,AA5
03FD4:  MOVFF  A8C,AA4
03FD8:  MOVFF  A8B,AA3
03FDC:  MOVLW  0A
03FDE:  MOVLB  A
03FE0:  MOVWF  xA8
03FE2:  MOVLW  98
03FE4:  MOVWF  xA7
03FE6:  MOVLW  04
03FE8:  MOVWF  xA9
03FEA:  MOVFF  A94,AAB
03FEE:  MOVFF  A93,AAA
03FF2:  MOVFF  A96,AAD
03FF6:  MOVFF  A95,AAC
03FFA:  MOVLB  0
03FFC:  CALL   3CA4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
04000:  MOVLW  02
04002:  MOVWF  00
04004:  DECFSZ 00,F
04006:  BRA    4004
04008:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0400A:  MOVFF  A8D,AA9
0400E:  MOVLW  01
04010:  MOVLB  A
04012:  MOVWF  xAA
04014:  MOVLW  0F
04016:  MOVWF  xAC
04018:  MOVLW  89
0401A:  MOVWF  xAB
0401C:  MOVLB  0
0401E:  CALL   2364
04022:  MOVFF  A8D,AA9
04026:  MOVLB  A
04028:  CLRF   xAA
0402A:  MOVLW  0F
0402C:  MOVWF  xAC
0402E:  MOVLW  92
04030:  MOVWF  xAB
04032:  MOVLB  0
04034:  CALL   2364
....................    }
04038:  GOTO   41CE
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
0403C:  MOVLB  A
0403E:  DECFSZ x8C,W
04040:  BRA    4046
04042:  BRA    404C
04044:  MOVLB  0
04046:  MOVLB  0
04048:  GOTO   41CE
0404C:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
0404E:  MOVLW  06
04050:  MOVLB  A
04052:  MOVWF  x9C
04054:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
04056:  MOVLW  12
04058:  MOVLB  A
0405A:  MOVWF  x9D
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
0405C:  MOVFF  A92,AA4
04060:  CLRF   xA5
04062:  CLRF   xA6
04064:  CLRF   xA7
04066:  MOVF   xA4,W
04068:  MOVWF  00
0406A:  CLRF   01
0406C:  CLRF   02
0406E:  CLRF   03
04070:  MOVFF  00,A9E
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04074:  MOVFF  A91,AA4
04078:  MOVFF  A92,AA5
0407C:  CLRF   xA6
0407E:  CLRF   xA7
04080:  MOVF   xA4,W
04082:  MOVWF  00
04084:  CLRF   01
04086:  CLRF   02
04088:  CLRF   03
0408A:  MOVFF  00,A9F
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0408E:  MOVFF  A90,AA4
04092:  MOVFF  A91,AA5
04096:  MOVFF  A92,AA6
0409A:  CLRF   xA7
0409C:  MOVF   xA4,W
0409E:  MOVWF  00
040A0:  CLRF   01
040A2:  CLRF   02
040A4:  CLRF   03
040A6:  MOVFF  00,AA0
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
040AA:  MOVF   x8F,W
040AC:  MOVWF  00
040AE:  CLRF   01
040B0:  CLRF   02
040B2:  CLRF   03
040B4:  MOVFF  00,AA1
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
040B8:  MOVFF  A8D,AA9
040BC:  CLRF   xAA
040BE:  MOVLW  0F
040C0:  MOVWF  xAC
040C2:  MOVLW  89
040C4:  MOVWF  xAB
040C6:  MOVLB  0
040C8:  CALL   2364
040CC:  MOVFF  A8D,AA9
040D0:  MOVLB  A
040D2:  CLRF   xAA
040D4:  MOVLW  0F
040D6:  MOVWF  xAC
040D8:  MOVLW  92
040DA:  MOVWF  xAB
040DC:  MOVLB  0
040DE:  CALL   2364
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
040E2:  MOVFF  A8E,AA6
040E6:  MOVFF  A8D,AA5
040EA:  MOVFF  A8C,AA4
040EE:  MOVFF  A8B,AA3
040F2:  MOVLW  0A
040F4:  MOVLB  A
040F6:  MOVWF  xA8
040F8:  MOVLW  9C
040FA:  MOVWF  xA7
040FC:  CLRF   xAA
040FE:  MOVLW  01
04100:  MOVWF  xA9
04102:  MOVLB  0
04104:  CALL   3BB4
....................       output_high(flash_stream.cs_pin);
04108:  MOVFF  A8D,AA9
0410C:  MOVLW  01
0410E:  MOVLB  A
04110:  MOVWF  xAA
04112:  MOVLW  0F
04114:  MOVWF  xAC
04116:  MOVLW  89
04118:  MOVWF  xAB
0411A:  MOVLB  0
0411C:  CALL   2364
04120:  MOVFF  A8D,AA9
04124:  MOVLB  A
04126:  CLRF   xAA
04128:  MOVLW  0F
0412A:  MOVWF  xAC
0412C:  MOVLW  92
0412E:  MOVWF  xAB
04130:  MOVLB  0
04132:  CALL   2364
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
04136:  MOVFF  A8D,AA9
0413A:  MOVLB  A
0413C:  CLRF   xAA
0413E:  MOVLW  0F
04140:  MOVWF  xAC
04142:  MOVLW  89
04144:  MOVWF  xAB
04146:  MOVLB  0
04148:  CALL   2364
0414C:  MOVFF  A8D,AA9
04150:  MOVLB  A
04152:  CLRF   xAA
04154:  MOVLW  0F
04156:  MOVWF  xAC
04158:  MOVLW  92
0415A:  MOVWF  xAB
0415C:  MOVLB  0
0415E:  CALL   2364
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
04162:  MOVFF  A8E,AA6
04166:  MOVFF  A8D,AA5
0416A:  MOVFF  A8C,AA4
0416E:  MOVFF  A8B,AA3
04172:  MOVLW  0A
04174:  MOVLB  A
04176:  MOVWF  xA8
04178:  MOVLW  9D
0417A:  MOVWF  xA7
0417C:  MOVLW  05
0417E:  MOVWF  xA9
04180:  MOVFF  A94,AAB
04184:  MOVFF  A93,AAA
04188:  MOVFF  A96,AAD
0418C:  MOVFF  A95,AAC
04190:  MOVLB  0
04192:  CALL   3CA4
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
04196:  MOVLW  02
04198:  MOVWF  00
0419A:  DECFSZ 00,F
0419C:  BRA    419A
0419E:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
041A0:  MOVFF  A8D,AA9
041A4:  MOVLW  01
041A6:  MOVLB  A
041A8:  MOVWF  xAA
041AA:  MOVLW  0F
041AC:  MOVWF  xAC
041AE:  MOVLW  89
041B0:  MOVWF  xAB
041B2:  MOVLB  0
041B4:  CALL   2364
041B8:  MOVFF  A8D,AA9
041BC:  MOVLB  A
041BE:  CLRF   xAA
041C0:  MOVLW  0F
041C2:  MOVWF  xAC
041C4:  MOVLW  92
041C6:  MOVWF  xAB
041C8:  MOVLB  0
041CA:  CALL   2364
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
041CE:  MOVLB  A
041D0:  CLRF   xA2
041D2:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
041D4:  MOVFF  A8E,AA6
041D8:  MOVFF  A8D,AA5
041DC:  MOVFF  A8C,AA4
041E0:  MOVFF  A8B,AA3
041E4:  CALL   3E20
041E8:  MOVF   01,W
041EA:  ANDLW  01
041EC:  SUBLW  01
041EE:  BTFSS  FD8.2
041F0:  GOTO   4242
....................       if(timeout_counter > 10)
041F4:  MOVLB  A
041F6:  MOVF   xA2,W
041F8:  SUBLW  0A
041FA:  BTFSS  FD8.0
041FC:  BRA    4204
041FE:  MOVLB  0
04200:  GOTO   4216
04204:  MOVLB  0
....................          delay_ms(200);
04206:  MOVLW  C8
04208:  MOVLB  A
0420A:  MOVWF  xA3
0420C:  MOVLB  0
0420E:  CALL   1BC8
04212:  GOTO   4222
....................       else
....................          delay_ms(10);   
04216:  MOVLW  0A
04218:  MOVLB  A
0421A:  MOVWF  xA3
0421C:  MOVLB  0
0421E:  CALL   1BC8
....................       
....................       if(timeout_counter > 100){
04222:  MOVLB  A
04224:  MOVF   xA2,W
04226:  SUBLW  64
04228:  BTFSS  FD8.0
0422A:  BRA    4232
0422C:  MOVLB  0
0422E:  GOTO   4238
04232:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
04234:  GOTO   4242
....................       }  
....................       timeout_counter++;
04238:  MOVLB  A
0423A:  INCF   xA2,F
0423C:  MOVLB  0
0423E:  GOTO   41D4
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
04242:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
026E4:  MOVLW  9F
026E6:  MOVLB  2
026E8:  MOVWF  xAC
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
026EA:  MOVFF  296,AA9
026EE:  MOVLB  A
026F0:  CLRF   xAA
026F2:  MOVLW  0F
026F4:  MOVWF  xAC
026F6:  MOVLW  89
026F8:  MOVWF  xAB
026FA:  MOVLB  0
026FC:  CALL   2364
02700:  MOVFF  296,AA9
02704:  MOVLB  A
02706:  CLRF   xAA
02708:  MOVLW  0F
0270A:  MOVWF  xAC
0270C:  MOVLW  92
0270E:  MOVWF  xAB
02710:  MOVLB  0
02712:  CALL   2364
....................    delay_us(10);  
02716:  MOVLW  0D
02718:  MOVWF  00
0271A:  DECFSZ 00,F
0271C:  BRA    271A
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
0271E:  MOVFF  297,AAC
02722:  MOVFF  296,AAB
02726:  MOVFF  295,AAA
0272A:  MOVFF  294,AA9
0272E:  MOVLW  02
02730:  MOVLB  A
02732:  MOVWF  xAE
02734:  MOVLW  AC
02736:  MOVWF  xAD
02738:  CLRF   xB0
0273A:  MOVLW  01
0273C:  MOVWF  xAF
0273E:  MOVLW  02
02740:  MOVWF  xB2
02742:  MOVLW  98
02744:  MOVWF  xB1
02746:  CLRF   xB6
02748:  CLRF   xB5
0274A:  CLRF   xB4
0274C:  MOVLW  14
0274E:  MOVWF  xB3
02750:  MOVLB  0
02752:  CALL   24B0
....................    output_high(flash_stream.cs_pin);
02756:  MOVFF  296,AA9
0275A:  MOVLW  01
0275C:  MOVLB  A
0275E:  MOVWF  xAA
02760:  MOVLW  0F
02762:  MOVWF  xAC
02764:  MOVLW  89
02766:  MOVWF  xAB
02768:  MOVLB  0
0276A:  CALL   2364
0276E:  MOVFF  296,AA9
02772:  MOVLB  A
02774:  CLRF   xAA
02776:  MOVLW  0F
02778:  MOVWF  xAC
0277A:  MOVLW  92
0277C:  MOVWF  xAB
0277E:  MOVLB  0
02780:  CALL   2364
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
02784:  MOVLB  2
02786:  MOVF   x98,W
02788:  SUBLW  20
0278A:  BTFSC  FD8.2
0278C:  BRA    2794
0278E:  MOVLB  0
02790:  GOTO   27A2
02794:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
02796:  MOVLW  01
02798:  MOVWF  01
0279A:  GOTO   27AA
....................    }
0279E:  GOTO   27AA
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
027A2:  MOVLW  00
027A4:  MOVWF  01
027A6:  GOTO   27AA
....................    }
027AA:  RETURN 0
.................... }
.................... 
.................... #include "../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
029E8:  MOVLB  A
029EA:  MOVF   xEC,F
029EC:  BTFSC  FD8.2
029EE:  BRA    29F6
029F0:  MOVLB  0
029F2:  GOTO   2A00
029F6:  MOVLB  0
029F8:  MOVLW  00
029FA:  MOVWF  01
029FC:  GOTO   2A52
.................... 
....................    unsigned int8 crc = *frame++;
02A00:  MOVLB  A
02A02:  MOVF   xEB,W
02A04:  MOVWF  03
02A06:  MOVF   xEA,W
02A08:  INCF   xEA,F
02A0A:  BTFSC  FD8.2
02A0C:  INCF   xEB,F
02A0E:  MOVWF  FE9
02A10:  MOVFF  03,FEA
02A14:  MOVFF  FEF,AED
02A18:  MOVLB  0
....................    while (--payload_size > 0)
02A1A:  MOVLB  A
02A1C:  DECF   xEC,F
02A1E:  MOVF   xEC,F
02A20:  BTFSS  FD8.2
02A22:  BRA    2A2A
02A24:  MOVLB  0
02A26:  GOTO   2A4A
02A2A:  MOVLB  0
....................       crc ^= *frame++;
02A2C:  MOVLB  A
02A2E:  MOVF   xEB,W
02A30:  MOVWF  03
02A32:  MOVF   xEA,W
02A34:  INCF   xEA,F
02A36:  BTFSC  FD8.2
02A38:  INCF   xEB,F
02A3A:  MOVWF  FE9
02A3C:  MOVFF  03,FEA
02A40:  MOVF   FEF,W
02A42:  XORWF  xED,F
02A44:  MOVLB  0
02A46:  GOTO   2A1A
.................... 
....................    return crc;
02A4A:  MOVLB  A
02A4C:  MOVF   xED,W
02A4E:  MOVWF  01
02A50:  MOVLB  0
02A52:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
0AEAC:  MOVLW  01
0AEAE:  MOVLB  3
0AEB0:  SUBWF  x18,W
0AEB2:  ADDWF  x16,W
0AEB4:  MOVWF  FE9
0AEB6:  MOVLW  00
0AEB8:  ADDWFC x17,W
0AEBA:  MOVWF  FEA
0AEBC:  MOVFF  FEF,319
0AEC0:  MOVLW  01
0AEC2:  SUBWF  x18,W
0AEC4:  MOVWF  x1B
0AEC6:  MOVFF  317,AEB
0AECA:  MOVFF  316,AEA
0AECE:  MOVFF  31B,AEC
0AED2:  MOVLB  0
0AED4:  CALL   29E8
0AED8:  MOVFF  01,31A
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
0AEDC:  MOVLB  3
0AEDE:  MOVF   x1A,W
0AEE0:  SUBWF  x19,W
0AEE2:  BTFSS  FD8.2
0AEE4:  BRA    AEEC
0AEE6:  MOVLB  0
0AEE8:  GOTO   AEF4
0AEEC:  MOVLB  0
0AEEE:  MOVLW  00
0AEF0:  GOTO   AEF6
0AEF4:  MOVLW  01
0AEF6:  MOVWF  01
0AEF8:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... // End of file
.................... 
.................... #include "../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
.................... {   
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
*
07404:  MOVLW  8A
07406:  MOVWF  FF6
07408:  MOVLW  02
0740A:  MOVWF  FF7
0740C:  MOVLW  00
0740E:  MOVWF  FF8
07410:  CALL   1BF6
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
07414:  MOVLW  01
07416:  MOVLB  1
07418:  ADDWF  x11,W
0741A:  ANDLW  0F
0741C:  MOVWF  xE1
.................... 
....................    if(next_tail == flash_queue.head_index)
0741E:  MOVF   x10,W
07420:  SUBWF  xE1,W
07422:  BTFSC  FD8.2
07424:  BRA    742C
07426:  MOVLB  0
07428:  GOTO   7442
0742C:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
0742E:  MOVLW  A4
07430:  MOVWF  FF6
07432:  MOVLW  02
07434:  MOVWF  FF7
07436:  MOVLW  00
07438:  MOVWF  FF8
0743A:  CALL   1BF6
0743E:  GOTO   7660
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
07442:  MOVLB  1
07444:  MOVF   x11,W
07446:  MULLW  0C
07448:  MOVF   FF3,W
0744A:  CLRF   xE3
0744C:  MOVWF  xE2
0744E:  MOVLW  50
07450:  ADDWF  xE2,W
07452:  MOVWF  01
07454:  MOVLW  00
07456:  ADDWFC xE3,W
07458:  MOVWF  03
0745A:  MOVF   01,W
0745C:  MOVWF  xE4
0745E:  MOVFF  03,1E5
07462:  MOVF   xDF,W
07464:  MOVWF  FE9
07466:  MOVF   xE0,W
07468:  MOVWF  FEA
0746A:  MOVF   FEF,W
0746C:  MOVWF  xE6
0746E:  MOVFF  1E5,FEA
07472:  MOVFF  1E4,FE9
07476:  MOVFF  1E6,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
0747A:  MOVF   x11,W
0747C:  MULLW  0C
0747E:  MOVF   FF3,W
07480:  CLRF   xE3
07482:  MOVWF  xE2
07484:  MOVLW  01
07486:  ADDWF  xE2,W
07488:  MOVWF  01
0748A:  MOVLW  00
0748C:  ADDWFC xE3,W
0748E:  MOVWF  03
07490:  MOVF   01,W
07492:  ADDLW  50
07494:  MOVWF  01
07496:  MOVLW  00
07498:  ADDWFC 03,F
0749A:  MOVF   01,W
0749C:  MOVWF  xE2
0749E:  MOVFF  03,1E3
074A2:  MOVLW  01
074A4:  ADDWF  xDF,W
074A6:  MOVWF  FE9
074A8:  MOVLW  00
074AA:  ADDWFC xE0,W
074AC:  MOVWF  FEA
074AE:  MOVF   FEF,W
074B0:  MOVWF  xE4
074B2:  MOVFF  1E3,FEA
074B6:  MOVFF  1E2,FE9
074BA:  MOVFF  1E4,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
074BE:  MOVF   x11,W
074C0:  MULLW  0C
074C2:  MOVF   FF3,W
074C4:  CLRF   xE3
074C6:  MOVWF  xE2
074C8:  MOVLW  02
074CA:  ADDWF  xE2,W
074CC:  MOVWF  01
074CE:  MOVLW  00
074D0:  ADDWFC xE3,W
074D2:  MOVWF  03
074D4:  MOVF   01,W
074D6:  ADDLW  50
074D8:  MOVWF  01
074DA:  MOVLW  00
074DC:  ADDWFC 03,F
074DE:  MOVF   01,W
074E0:  MOVWF  xE2
074E2:  MOVFF  03,1E3
074E6:  MOVLW  02
074E8:  ADDWF  xDF,W
074EA:  MOVWF  FE9
074EC:  MOVLW  00
074EE:  ADDWFC xE0,W
074F0:  MOVWF  FEA
074F2:  MOVF   FEF,W
074F4:  MOVWF  xE4
074F6:  MOVFF  1E3,FEA
074FA:  MOVFF  1E2,FE9
074FE:  MOVFF  1E4,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
07502:  MOVF   x11,W
07504:  MULLW  0C
07506:  MOVF   FF3,W
07508:  CLRF   xE3
0750A:  MOVWF  xE2
0750C:  MOVLW  03
0750E:  ADDWF  xE2,W
07510:  MOVWF  01
07512:  MOVLW  00
07514:  ADDWFC xE3,W
07516:  MOVWF  03
07518:  MOVF   01,W
0751A:  ADDLW  50
0751C:  MOVWF  01
0751E:  MOVLW  00
07520:  ADDWFC 03,F
07522:  MOVF   01,W
07524:  MOVWF  xE2
07526:  MOVFF  03,1E3
0752A:  MOVLW  03
0752C:  ADDWF  xDF,W
0752E:  MOVWF  01
07530:  MOVLW  00
07532:  ADDWFC xE0,W
07534:  MOVWF  03
07536:  MOVF   01,W
07538:  MOVWF  FE9
0753A:  MOVFF  03,FEA
0753E:  MOVLW  00
07540:  BTFSC  FEF.0
07542:  MOVLW  01
07544:  MOVWF  01
07546:  BTFSS  01.0
07548:  BRA    7550
0754A:  MOVLB  0
0754C:  GOTO   7560
07550:  MOVLB  0
07552:  MOVFF  1E3,FEA
07556:  MOVFF  1E2,FE9
0755A:  BCF    FEF.0
0755C:  GOTO   756A
07560:  MOVFF  1E3,FEA
07564:  MOVFF  1E2,FE9
07568:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
0756A:  MOVLB  1
0756C:  MOVF   x11,W
0756E:  MULLW  0C
07570:  MOVF   FF3,W
07572:  CLRF   xE3
07574:  MOVWF  xE2
07576:  MOVLW  04
07578:  ADDWF  xE2,W
0757A:  MOVWF  01
0757C:  MOVLW  00
0757E:  ADDWFC xE3,W
07580:  MOVWF  03
07582:  MOVF   01,W
07584:  ADDLW  50
07586:  MOVWF  01
07588:  MOVLW  00
0758A:  ADDWFC 03,F
0758C:  MOVF   01,W
0758E:  MOVWF  xE2
07590:  MOVFF  03,1E3
07594:  MOVLW  04
07596:  ADDWF  xDF,W
07598:  MOVWF  FE9
0759A:  MOVLW  00
0759C:  ADDWFC xE0,W
0759E:  MOVWF  FEA
075A0:  MOVFF  FEF,00
075A4:  MOVFF  FEC,01
075A8:  MOVFF  FEC,02
075AC:  MOVFF  FEC,03
075B0:  MOVF   FED,F
075B2:  MOVF   FED,F
075B4:  MOVF   FED,F
075B6:  MOVFF  03,1E7
075BA:  MOVFF  02,1E6
075BE:  MOVFF  01,1E5
075C2:  MOVFF  00,1E4
075C6:  MOVFF  1E3,FEA
075CA:  MOVFF  1E2,FE9
075CE:  MOVFF  1E4,FEF
075D2:  MOVFF  1E5,FEC
075D6:  MOVFF  1E6,FEC
075DA:  MOVFF  1E7,FEC
075DE:  MOVF   FED,F
075E0:  MOVF   FED,F
075E2:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
075E4:  MOVF   x11,W
075E6:  MULLW  0C
075E8:  MOVF   FF3,W
075EA:  CLRF   xE3
075EC:  MOVWF  xE2
075EE:  MOVLW  08
075F0:  ADDWF  xE2,W
075F2:  MOVWF  01
075F4:  MOVLW  00
075F6:  ADDWFC xE3,W
075F8:  MOVWF  03
075FA:  MOVF   01,W
075FC:  ADDLW  50
075FE:  MOVWF  01
07600:  MOVLW  00
07602:  ADDWFC 03,F
07604:  MOVF   01,W
07606:  MOVWF  xE2
07608:  MOVFF  03,1E3
0760C:  MOVLW  08
0760E:  ADDWF  xDF,W
07610:  MOVWF  FE9
07612:  MOVLW  00
07614:  ADDWFC xE0,W
07616:  MOVWF  FEA
07618:  MOVFF  FEF,00
0761C:  MOVFF  FEC,01
07620:  MOVFF  FEC,02
07624:  MOVFF  FEC,03
07628:  MOVF   FED,F
0762A:  MOVF   FED,F
0762C:  MOVF   FED,F
0762E:  MOVFF  03,1E7
07632:  MOVFF  02,1E6
07636:  MOVFF  01,1E5
0763A:  MOVFF  00,1E4
0763E:  MOVFF  1E3,FEA
07642:  MOVFF  1E2,FE9
07646:  MOVFF  1E4,FEF
0764A:  MOVFF  1E5,FEC
0764E:  MOVFF  1E6,FEC
07652:  MOVFF  1E7,FEC
07656:  MOVF   FED,F
07658:  MOVF   FED,F
0765A:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
0765C:  MOVFF  1E1,111
07660:  MOVLB  0
....................    }
07662:  GOTO   7BAC (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
0A852:  MOVLB  1
0A854:  MOVF   x11,W
0A856:  SUBWF  x10,W
0A858:  BTFSC  FD8.2
0A85A:  BRA    A862
0A85C:  MOVLB  0
0A85E:  GOTO   A884
0A862:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
0A864:  MOVLW  BE
0A866:  MOVWF  FF6
0A868:  MOVLW  02
0A86A:  MOVWF  FF7
0A86C:  MOVLW  00
0A86E:  MOVWF  FF8
0A870:  CALL   1BF6
....................       return 0x00;
0A874:  MOVLW  00
0A876:  MOVWF  01
0A878:  MOVLW  00
0A87A:  MOVWF  02
0A87C:  GOTO   A8B0
....................    }
0A880:  GOTO   A8B0
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
0A884:  MOVFF  110,1BF
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
0A888:  MOVLW  01
0A88A:  MOVLB  1
0A88C:  ADDWF  x10,W
0A88E:  ANDLW  0F
0A890:  MOVWF  x10
.................... 
.................... 
....................       return &flash_queue.entries[current_head];
0A892:  MOVF   xBF,W
0A894:  MULLW  0C
0A896:  MOVF   FF3,W
0A898:  CLRF   03
0A89A:  ADDLW  50
0A89C:  MOVWF  01
0A89E:  MOVLW  00
0A8A0:  ADDWFC 03,F
0A8A2:  MOVF   01,W
0A8A4:  MOVWF  01
0A8A6:  MOVF   03,W
0A8A8:  MOVWF  02
0A8AA:  MOVLB  0
0A8AC:  GOTO   A8B0
....................    }
0A8B0:  GOTO   C762 (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
0A75C:  MOVLB  1
0A75E:  MOVF   x11,W
0A760:  SUBWF  x10,W
0A762:  BTFSS  FD8.2
0A764:  BRA    A76C
0A766:  MOVLB  0
0A768:  GOTO   A774
0A76C:  MOVLB  0
0A76E:  MOVLW  00
0A770:  GOTO   A776
0A774:  MOVLW  01
0A776:  MOVWF  01
0A778:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
0AC18:  MOVLB  2
0AC1A:  CLRF   x9C
0AC1C:  CLRF   x9D
0AC1E:  CLRF   x9E
0AC20:  CLRF   x9F
0AC22:  CLRF   xA0
0AC24:  CLRF   xA1
0AC26:  CLRF   xA2
0AC28:  CLRF   xA3
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0AC2A:  MOVF   x9B,F
0AC2C:  BTFSC  FD8.2
0AC2E:  BRA    AC36
0AC30:  MOVLB  0
0AC32:  GOTO   AC5A
0AC36:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
0AC38:  MOVLW  06
0AC3A:  MOVLB  2
0AC3C:  MOVWF  x9F
0AC3E:  MOVLW  AA
0AC40:  MOVWF  x9E
0AC42:  CLRF   x9D
0AC44:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
0AC46:  MOVLW  06
0AC48:  MOVWF  xA3
0AC4A:  MOVLW  AA
0AC4C:  MOVWF  xA2
0AC4E:  MOVLW  0F
0AC50:  MOVWF  xA1
0AC52:  SETF   xA0
0AC54:  MOVLB  0
....................    }
0AC56:  GOTO   AD9A
....................    else if (mission_id == CIGS_PICLOG_DATA)
0AC5A:  MOVLB  2
0AC5C:  DECFSZ x9B,W
0AC5E:  BRA    AC64
0AC60:  BRA    AC6A
0AC62:  MOVLB  0
0AC64:  MOVLB  0
0AC66:  GOTO   AC90
0AC6A:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
0AC6C:  MOVLW  06
0AC6E:  MOVLB  2
0AC70:  MOVWF  x9F
0AC72:  MOVLW  AA
0AC74:  MOVWF  x9E
0AC76:  MOVLW  10
0AC78:  MOVWF  x9D
0AC7A:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
0AC7C:  MOVLW  06
0AC7E:  MOVWF  xA3
0AC80:  MOVLW  AA
0AC82:  MOVWF  xA2
0AC84:  MOVLW  1F
0AC86:  MOVWF  xA1
0AC88:  SETF   xA0
0AC8A:  MOVLB  0
....................    }
0AC8C:  GOTO   AD9A
....................    else if (mission_id == CIGS_ENVIRO_DATA)
0AC90:  MOVLB  2
0AC92:  MOVF   x9B,W
0AC94:  SUBLW  02
0AC96:  BTFSC  FD8.2
0AC98:  BRA    ACA0
0AC9A:  MOVLB  0
0AC9C:  GOTO   ACC6
0ACA0:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
0ACA2:  MOVLW  06
0ACA4:  MOVLB  2
0ACA6:  MOVWF  x9F
0ACA8:  MOVLW  AA
0ACAA:  MOVWF  x9E
0ACAC:  MOVLW  10
0ACAE:  MOVWF  x9D
0ACB0:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
0ACB2:  MOVLW  06
0ACB4:  MOVWF  xA3
0ACB6:  MOVLW  AA
0ACB8:  MOVWF  xA2
0ACBA:  MOVLW  1F
0ACBC:  MOVWF  xA1
0ACBE:  SETF   xA0
0ACC0:  MOVLB  0
....................    }
0ACC2:  GOTO   AD9A
....................    else if (mission_id == CIGS_IV1_HEADER)
0ACC6:  MOVLB  2
0ACC8:  MOVF   x9B,W
0ACCA:  SUBLW  03
0ACCC:  BTFSC  FD8.2
0ACCE:  BRA    ACD6
0ACD0:  MOVLB  0
0ACD2:  GOTO   ACFC
0ACD6:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_HEADER_START_ADDRESS;
0ACD8:  MOVLW  06
0ACDA:  MOVLB  2
0ACDC:  MOVWF  x9F
0ACDE:  MOVLW  B4
0ACE0:  MOVWF  x9E
0ACE2:  MOVLW  20
0ACE4:  MOVWF  x9D
0ACE6:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_IV1_HEADER_END_ADDRESS;
0ACE8:  MOVLW  06
0ACEA:  MOVWF  xA3
0ACEC:  MOVLW  BE
0ACEE:  MOVWF  xA2
0ACF0:  MOVLW  1F
0ACF2:  MOVWF  xA1
0ACF4:  SETF   xA0
0ACF6:  MOVLB  0
....................    }
0ACF8:  GOTO   AD9A
....................    else if (mission_id == CIGS_IV1_DATA)
0ACFC:  MOVLB  2
0ACFE:  MOVF   x9B,W
0AD00:  SUBLW  04
0AD02:  BTFSC  FD8.2
0AD04:  BRA    AD0C
0AD06:  MOVLB  0
0AD08:  GOTO   AD32
0AD0C:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_DATA_START_ADDRESS;
0AD0E:  MOVLW  06
0AD10:  MOVLB  2
0AD12:  MOVWF  x9F
0AD14:  MOVLW  BE
0AD16:  MOVWF  x9E
0AD18:  MOVLW  20
0AD1A:  MOVWF  x9D
0AD1C:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_IV1_DATA_END_ADDRESS;
0AD1E:  MOVLW  06
0AD20:  MOVWF  xA3
0AD22:  MOVLW  FE
0AD24:  MOVWF  xA2
0AD26:  MOVLW  2F
0AD28:  MOVWF  xA1
0AD2A:  SETF   xA0
0AD2C:  MOVLB  0
....................    }
0AD2E:  GOTO   AD9A
....................       else if (mission_id == CIGS_IV2_HEADER)
0AD32:  MOVLB  2
0AD34:  MOVF   x9B,W
0AD36:  SUBLW  05
0AD38:  BTFSC  FD8.2
0AD3A:  BRA    AD42
0AD3C:  MOVLB  0
0AD3E:  GOTO   AD68
0AD42:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV2_HEADER_START_ADDRESS;
0AD44:  MOVLW  06
0AD46:  MOVLB  2
0AD48:  MOVWF  x9F
0AD4A:  MOVLW  FE
0AD4C:  MOVWF  x9E
0AD4E:  MOVLW  30
0AD50:  MOVWF  x9D
0AD52:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_IV2_HEADER_END_ADDRESS;
0AD54:  MOVLW  07
0AD56:  MOVWF  xA3
0AD58:  MOVLW  08
0AD5A:  MOVWF  xA2
0AD5C:  MOVLW  2F
0AD5E:  MOVWF  xA1
0AD60:  SETF   xA0
0AD62:  MOVLB  0
....................    }
0AD64:  GOTO   AD9A
....................    else if (mission_id == CIGS_IV2_DATA)
0AD68:  MOVLB  2
0AD6A:  MOVF   x9B,W
0AD6C:  SUBLW  06
0AD6E:  BTFSC  FD8.2
0AD70:  BRA    AD78
0AD72:  MOVLB  0
0AD74:  GOTO   AD9A
0AD78:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV2_DATA_START_ADDRESS;
0AD7A:  MOVLW  07
0AD7C:  MOVLB  2
0AD7E:  MOVWF  x9F
0AD80:  MOVLW  08
0AD82:  MOVWF  x9E
0AD84:  MOVLW  30
0AD86:  MOVWF  x9D
0AD88:  CLRF   x9C
....................       mis_struct.end_address   = CIGS_IV2_DATA_END_ADDRESS;
0AD8A:  MOVLW  07
0AD8C:  MOVWF  xA3
0AD8E:  MOVLW  48
0AD90:  MOVWF  xA2
0AD92:  MOVLW  3F
0AD94:  MOVWF  xA1
0AD96:  SETF   xA0
0AD98:  MOVLB  0
....................    }
....................    return mis_struct;
0AD9A:  MOVLW  9C
0AD9C:  MOVWF  01
0AD9E:  MOVLW  02
0ADA0:  MOVWF  02
0ADA2:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
05024:  MOVLB  1
05026:  CLRF   xC1
05028:  CLRF   xC2
0502A:  CLRF   xC3
0502C:  CLRF   xC4
0502E:  CLRF   xC5
05030:  CLRF   xC6
05032:  CLRF   xC7
05034:  CLRF   xC8
05036:  CLRF   xC9
05038:  CLRF   xCA
0503A:  CLRF   xCB
0503C:  CLRF   xCC
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
0503E:  MOVLW  D6
05040:  MOVWF  FF6
05042:  MOVLW  02
05044:  MOVWF  FF7
05046:  MOVLW  00
05048:  MOVWF  FF8
0504A:  MOVLB  0
0504C:  CALL   1BF6
....................    fprintf(PC, "\t[BOSS] >>> ");
05050:  MOVLW  F6
05052:  MOVWF  FF6
05054:  MOVLW  02
05056:  MOVWF  FF7
05058:  MOVLW  00
0505A:  MOVWF  FF8
0505C:  CALL   1BF6
....................    for (int8 i = 0; i < receive_signal_size; i++)
05060:  MOVLB  1
05062:  CLRF   xCD
05064:  MOVLB  0
05066:  MOVLB  1
05068:  MOVF   xC0,W
0506A:  SUBWF  xCD,W
0506C:  BTFSS  FD8.0
0506E:  BRA    5076
05070:  MOVLB  0
05072:  GOTO   50B2
05076:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
05078:  MOVLB  1
0507A:  MOVF   xCD,W
0507C:  ADDWF  xBE,W
0507E:  MOVWF  FE9
05080:  MOVLW  00
05082:  ADDWFC xBF,W
05084:  MOVWF  FEA
05086:  MOVFF  FEF,1D4
0508A:  MOVFF  1D4,A48
0508E:  MOVLW  37
05090:  MOVLB  A
05092:  MOVWF  x49
05094:  MOVLB  0
05096:  CALL   1E3C
0509A:  MOVLW  20
0509C:  BTFSS  FA6.6
0509E:  GOTO   509C
050A2:  MOVLB  E
050A4:  MOVWF  xF9
050A6:  MOVLB  0
050A8:  MOVLB  1
050AA:  INCF   xCD,F
050AC:  MOVLB  0
050AE:  GOTO   5066
....................    fprintf(PC, "\r\n");
050B2:  MOVLW  0D
050B4:  BTFSS  FA6.6
050B6:  GOTO   50B4
050BA:  MOVLB  E
050BC:  MOVWF  xF9
050BE:  MOVLW  0A
050C0:  MOVLB  0
050C2:  BTFSS  FA6.6
050C4:  GOTO   50C2
050C8:  MOVLB  E
050CA:  MOVWF  xF9
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
050CC:  MOVFF  1BF,1D5
050D0:  MOVFF  1BE,1D4
050D4:  MOVFF  1C0,1D6
050D8:  MOVLB  0
050DA:  GOTO   4D0C
050DE:  MOVFF  01,1CE
....................    if (frame_start_position == -1)
050E2:  MOVLB  1
050E4:  MOVF   xCE,W
050E6:  SUBLW  FF
050E8:  BTFSC  FD8.2
050EA:  BRA    50F2
050EC:  MOVLB  0
050EE:  GOTO   5100
050F2:  MOVLB  0
....................       return command;
050F4:  MOVLW  C1
050F6:  MOVWF  01
050F8:  MOVLW  01
050FA:  MOVWF  02
050FC:  GOTO   5222
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
05100:  MOVLB  1
05102:  MOVF   xCE,W
05104:  ADDWF  xBE,W
05106:  MOVWF  01
05108:  MOVLW  00
0510A:  ADDWFC xBF,W
0510C:  MOVWF  03
0510E:  MOVF   01,W
05110:  MOVWF  xCF
05112:  MOVFF  03,1D0
05116:  MOVF   xCF,W
05118:  MOVWF  FE9
0511A:  MOVF   xD0,W
0511C:  MOVWF  FEA
0511E:  MOVF   FEF,W
05120:  ANDLW  0F
05122:  MOVWF  xD1
05124:  MOVFF  1D1,1D4
05128:  MOVLB  0
0512A:  GOTO   4DB4
0512E:  MOVFF  01,1D2
....................    if (content_size == -1)
05132:  MOVLB  1
05134:  MOVF   xD2,W
05136:  SUBLW  FF
05138:  BTFSC  FD8.2
0513A:  BRA    5142
0513C:  MOVLB  0
0513E:  GOTO   5150
05142:  MOVLB  0
....................       return command;
05144:  MOVLW  C1
05146:  MOVWF  01
05148:  MOVLW  01
0514A:  MOVWF  02
0514C:  GOTO   5222
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
05150:  MOVLB  1
05152:  MOVF   xCE,W
05154:  SUBWF  xC0,W
05156:  MOVWF  xD3
....................    
....................    if (!check_crc(frame, receive_frame_size))
05158:  MOVFF  1D0,1D5
0515C:  MOVFF  1CF,1D4
05160:  MOVFF  1D3,1D6
05164:  MOVLB  0
05166:  GOTO   4E74
0516A:  MOVF   01,F
0516C:  BTFSS  FD8.2
0516E:  GOTO   517E
....................       return command;
05172:  MOVLW  C1
05174:  MOVWF  01
05176:  MOVLW  01
05178:  MOVWF  02
0517A:  GOTO   5222
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
0517E:  MOVLB  1
05180:  MOVF   xCF,W
05182:  MOVWF  FE9
05184:  MOVF   xD0,W
05186:  MOVWF  FEA
05188:  MOVF   FEF,W
0518A:  ANDLW  F0
0518C:  MOVWF  00
0518E:  SWAPF  00,W
05190:  MOVWF  xD4
05192:  MOVLW  0F
05194:  ANDWF  xD4,F
05196:  MOVFF  1D4,1D5
0519A:  MOVLB  0
0519C:  GOTO   4F64
051A0:  MOVF   01,F
051A2:  BTFSS  FD8.2
051A4:  GOTO   51B4
....................       return command;
051A8:  MOVLW  C1
051AA:  MOVWF  01
051AC:  MOVLW  01
051AE:  MOVWF  02
051B0:  GOTO   5222
.................... 
....................    command.frame_id = frame_id;
051B4:  MOVFF  1D1,1C1
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
051B8:  MOVLW  01
051BA:  MOVLB  1
051BC:  ADDWF  xCF,W
051BE:  MOVWF  01
051C0:  MOVLW  00
051C2:  ADDWFC xD0,W
051C4:  MOVWF  03
051C6:  MOVF   01,W
051C8:  MOVWF  xD4
051CA:  MOVFF  03,1D5
051CE:  MOVLW  02
051D0:  SUBWF  xD3,W
051D2:  MOVWF  xD6
051D4:  MOVLW  01
051D6:  MOVWF  FEA
051D8:  MOVLW  C4
051DA:  MOVWF  FE9
051DC:  MOVFF  1D5,FE2
051E0:  MOVFF  1D4,FE1
051E4:  MOVF   xD6,W
051E6:  MOVWF  01
051E8:  BTFSS  FD8.2
051EA:  BRA    51F2
051EC:  MOVLB  0
051EE:  GOTO   51FE
051F2:  MOVLB  0
051F4:  MOVFF  FE6,FEE
051F8:  DECFSZ 01,F
051FA:  GOTO   51F4
....................    command.size = receive_frame_size-2;
051FE:  MOVLW  02
05200:  MOVLB  1
05202:  SUBWF  xD3,W
05204:  MOVWF  xC2
....................    command.is_exist = TRUE;
05206:  BSF    xC3.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
05208:  MOVLW  04
0520A:  MOVWF  FF6
0520C:  MOVLW  03
0520E:  MOVWF  FF7
05210:  MOVLW  00
05212:  MOVWF  FF8
05214:  MOVLB  0
05216:  CALL   1BF6
....................    return command;
0521A:  MOVLW  C1
0521C:  MOVWF  01
0521E:  MOVLW  01
05220:  MOVWF  02
05222:  GOTO   CF7E (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
04D0C:  MOVLB  1
04D0E:  CLRF   xD7
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
04D10:  CLRF   xD7
04D12:  MOVLB  0
04D14:  MOVLW  01
04D16:  MOVLB  1
04D18:  SUBWF  xD6,W
04D1A:  SUBWF  xD7,W
04D1C:  BTFSS  FD8.0
04D1E:  BRA    4D26
04D20:  MOVLB  0
04D22:  GOTO   4D5E
04D26:  MOVLB  0
....................       if(receive_signal[i] == SFD)
04D28:  MOVLB  1
04D2A:  MOVF   xD7,W
04D2C:  ADDWF  xD4,W
04D2E:  MOVWF  FE9
04D30:  MOVLW  00
04D32:  ADDWFC xD5,W
04D34:  MOVWF  FEA
04D36:  MOVF   FEF,W
04D38:  SUBLW  AA
04D3A:  BTFSC  FD8.2
04D3C:  BRA    4D44
04D3E:  MOVLB  0
04D40:  GOTO   4D54
04D44:  MOVLB  0
....................          return i+1;
04D46:  MOVLW  01
04D48:  MOVLB  1
04D4A:  ADDWF  xD7,W
04D4C:  MOVWF  01
04D4E:  MOVLB  0
04D50:  GOTO   4DB0
04D54:  MOVLB  1
04D56:  INCF   xD7,F
04D58:  MOVLB  0
04D5A:  GOTO   4D14
....................    if (receive_signal[i] == SFD)
04D5E:  MOVLB  1
04D60:  MOVF   xD7,W
04D62:  ADDWF  xD4,W
04D64:  MOVWF  FE9
04D66:  MOVLW  00
04D68:  ADDWFC xD5,W
04D6A:  MOVWF  FEA
04D6C:  MOVF   FEF,W
04D6E:  SUBLW  AA
04D70:  BTFSC  FD8.2
04D72:  BRA    4D7A
04D74:  MOVLB  0
04D76:  GOTO   4D98
04D7A:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
04D7C:  MOVLW  20
04D7E:  MOVWF  FF6
04D80:  MOVLW  03
04D82:  MOVWF  FF7
04D84:  MOVLW  00
04D86:  MOVWF  FF8
04D88:  CALL   1BF6
....................       return -1;
04D8C:  MOVLW  FF
04D8E:  MOVWF  01
04D90:  GOTO   4DB0
....................    }
04D94:  GOTO   4DB0
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
04D98:  MOVLW  36
04D9A:  MOVWF  FF6
04D9C:  MOVLW  03
04D9E:  MOVWF  FF7
04DA0:  MOVLW  00
04DA2:  MOVWF  FF8
04DA4:  CALL   1BF6
....................       return -1;
04DA8:  MOVLW  FF
04DAA:  MOVWF  01
04DAC:  GOTO   4DB0
....................    }
04DB0:  GOTO   50DE (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
04DB4:  MOVLB  1
04DB6:  CLRF   xD5
04DB8:  MOVLB  0
04DBA:  MOVLB  1
04DBC:  MOVF   xD5,W
04DBE:  SUBLW  02
04DC0:  BTFSC  FD8.0
04DC2:  BRA    4DCA
04DC4:  MOVLB  0
04DC6:  GOTO   4E28
04DCA:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
04DCC:  BCF    FD8.0
04DCE:  MOVLB  1
04DD0:  RLCF   xD5,W
04DD2:  CLRF   xD7
04DD4:  MOVWF  xD6
04DD6:  MOVLW  1A
04DD8:  ADDWF  xD6,W
04DDA:  MOVWF  FE9
04DDC:  MOVLW  01
04DDE:  ADDWFC xD7,W
04DE0:  MOVWF  FEA
04DE2:  MOVF   FEF,W
04DE4:  SUBWF  xD4,W
04DE6:  BTFSC  FD8.2
04DE8:  BRA    4DF0
04DEA:  MOVLB  0
04DEC:  GOTO   4E1E
04DF0:  MOVLB  0
....................          return frame_ids[i].length;
04DF2:  BCF    FD8.0
04DF4:  MOVLB  1
04DF6:  RLCF   xD5,W
04DF8:  CLRF   xD7
04DFA:  MOVWF  xD6
04DFC:  MOVLW  01
04DFE:  ADDWF  xD6,W
04E00:  MOVWF  01
04E02:  MOVLW  00
04E04:  ADDWFC xD7,W
04E06:  MOVWF  03
04E08:  MOVF   01,W
04E0A:  ADDLW  1A
04E0C:  MOVWF  FE9
04E0E:  MOVLW  01
04E10:  ADDWFC 03,W
04E12:  MOVWF  FEA
04E14:  MOVF   FEF,W
04E16:  MOVWF  01
04E18:  MOVLB  0
04E1A:  GOTO   4E6E
04E1E:  MOVLB  1
04E20:  INCF   xD5,F
04E22:  MOVLB  0
04E24:  GOTO   4DBA
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
04E28:  MOVLW  48
04E2A:  MOVWF  FF6
04E2C:  MOVLW  03
04E2E:  MOVWF  FF7
04E30:  MOVLW  00
04E32:  MOVWF  FF8
04E34:  MOVLW  1F
04E36:  MOVLB  9
04E38:  MOVWF  xE9
04E3A:  MOVLB  0
04E3C:  CALL   1C2C
04E40:  MOVFF  1D4,A48
04E44:  MOVLW  37
04E46:  MOVLB  A
04E48:  MOVWF  x49
04E4A:  MOVLB  0
04E4C:  CALL   1E3C
04E50:  MOVLW  0D
04E52:  BTFSS  FA6.6
04E54:  GOTO   4E52
04E58:  MOVLB  E
04E5A:  MOVWF  xF9
04E5C:  MOVLW  0A
04E5E:  MOVLB  0
04E60:  BTFSS  FA6.6
04E62:  GOTO   4E60
04E66:  MOVLB  E
04E68:  MOVWF  xF9
....................    return -1;
04E6A:  MOVLW  FF
04E6C:  MOVWF  01
04E6E:  MOVLB  0
04E70:  GOTO   512E (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
04E74:  MOVLW  01
04E76:  MOVLB  1
04E78:  SUBWF  xD6,W
04E7A:  ADDWF  xD4,W
04E7C:  MOVWF  FE9
04E7E:  MOVLW  00
04E80:  ADDWFC xD5,W
04E82:  MOVWF  FEA
04E84:  MOVFF  FEF,1D7
04E88:  MOVLW  01
04E8A:  SUBWF  xD6,W
04E8C:  MOVWF  xD9
04E8E:  MOVFF  1D5,AEB
04E92:  MOVFF  1D4,AEA
04E96:  MOVFF  1D9,AEC
04E9A:  MOVLB  0
04E9C:  CALL   29E8
04EA0:  MOVFF  01,1D8
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
04EA4:  MOVLB  1
04EA6:  MOVF   xD8,W
04EA8:  SUBWF  xD7,W
04EAA:  BTFSC  FD8.2
04EAC:  BRA    4EB4
04EAE:  MOVLB  0
04EB0:  GOTO   4EC2
04EB4:  MOVLB  0
....................       return TRUE;
04EB6:  MOVLW  01
04EB8:  MOVWF  01
04EBA:  GOTO   4F60
04EBE:  GOTO   4F60
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
04EC2:  MOVLW  6C
04EC4:  MOVWF  FF6
04EC6:  MOVLW  03
04EC8:  MOVWF  FF7
04ECA:  MOVLW  00
04ECC:  MOVWF  FF8
04ECE:  CALL   1BF6
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
04ED2:  MOVLW  7E
04ED4:  MOVWF  FF6
04ED6:  MOVLW  03
04ED8:  MOVWF  FF7
04EDA:  MOVLW  00
04EDC:  MOVWF  FF8
04EDE:  MOVLW  13
04EE0:  MOVLB  9
04EE2:  MOVWF  xE9
04EE4:  MOVLB  0
04EE6:  CALL   1C2C
04EEA:  MOVFF  1D7,A48
04EEE:  MOVLW  37
04EF0:  MOVLB  A
04EF2:  MOVWF  x49
04EF4:  MOVLB  0
04EF6:  CALL   1E3C
04EFA:  MOVLW  0D
04EFC:  BTFSS  FA6.6
04EFE:  GOTO   4EFC
04F02:  MOVLB  E
04F04:  MOVWF  xF9
04F06:  MOVLW  0A
04F08:  MOVLB  0
04F0A:  BTFSS  FA6.6
04F0C:  GOTO   4F0A
04F10:  MOVLB  E
04F12:  MOVWF  xF9
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
04F14:  MOVLW  96
04F16:  MOVWF  FF6
04F18:  MOVLW  03
04F1A:  MOVWF  FF7
04F1C:  MOVLW  00
04F1E:  MOVWF  FF8
04F20:  MOVLW  13
04F22:  MOVLB  9
04F24:  MOVWF  xE9
04F26:  MOVLB  0
04F28:  CALL   1C2C
04F2C:  MOVFF  1D8,A48
04F30:  MOVLW  37
04F32:  MOVLB  A
04F34:  MOVWF  x49
04F36:  MOVLB  0
04F38:  CALL   1E3C
04F3C:  MOVLW  0D
04F3E:  BTFSS  FA6.6
04F40:  GOTO   4F3E
04F44:  MOVLB  E
04F46:  MOVWF  xF9
04F48:  MOVLW  0A
04F4A:  MOVLB  0
04F4C:  BTFSS  FA6.6
04F4E:  GOTO   4F4C
04F52:  MOVLB  E
04F54:  MOVWF  xF9
....................       return FALSE;
04F56:  MOVLW  00
04F58:  MOVWF  01
04F5A:  MOVLB  0
04F5C:  GOTO   4F60
....................    }
04F60:  GOTO   516A (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
04F64:  MOVLB  1
04F66:  MOVF   xD5,W
04F68:  SUBLW  0C
04F6A:  BTFSC  FD8.2
04F6C:  BRA    4F74
04F6E:  MOVLB  0
04F70:  GOTO   4F82
04F74:  MOVLB  0
....................       return TRUE;
04F76:  MOVLW  01
04F78:  MOVWF  01
04F7A:  GOTO   5020
04F7E:  GOTO   5020
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
04F82:  MOVLW  AE
04F84:  MOVWF  FF6
04F86:  MOVLW  03
04F88:  MOVWF  FF7
04F8A:  MOVLW  00
04F8C:  MOVWF  FF8
04F8E:  CALL   1BF6
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
04F92:  MOVLW  D0
04F94:  MOVWF  FF6
04F96:  MOVLW  03
04F98:  MOVWF  FF7
04F9A:  MOVLW  00
04F9C:  MOVWF  FF8
04F9E:  MOVLW  13
04FA0:  MOVLB  9
04FA2:  MOVWF  xE9
04FA4:  MOVLB  0
04FA6:  CALL   1C2C
04FAA:  MOVFF  1D5,A48
04FAE:  MOVLW  37
04FB0:  MOVLB  A
04FB2:  MOVWF  x49
04FB4:  MOVLB  0
04FB6:  CALL   1E3C
04FBA:  MOVLW  0D
04FBC:  BTFSS  FA6.6
04FBE:  GOTO   4FBC
04FC2:  MOVLB  E
04FC4:  MOVWF  xF9
04FC6:  MOVLW  0A
04FC8:  MOVLB  0
04FCA:  BTFSS  FA6.6
04FCC:  GOTO   4FCA
04FD0:  MOVLB  E
04FD2:  MOVWF  xF9
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
04FD4:  MOVLW  E8
04FD6:  MOVWF  FF6
04FD8:  MOVLW  03
04FDA:  MOVWF  FF7
04FDC:  MOVLW  00
04FDE:  MOVWF  FF8
04FE0:  MOVLW  13
04FE2:  MOVLB  9
04FE4:  MOVWF  xE9
04FE6:  MOVLB  0
04FE8:  CALL   1C2C
04FEC:  MOVLW  0C
04FEE:  MOVLB  A
04FF0:  MOVWF  x48
04FF2:  MOVLW  37
04FF4:  MOVWF  x49
04FF6:  MOVLB  0
04FF8:  CALL   1E3C
04FFC:  MOVLW  0D
04FFE:  BTFSS  FA6.6
05000:  GOTO   4FFE
05004:  MOVLB  E
05006:  MOVWF  xF9
05008:  MOVLW  0A
0500A:  MOVLB  0
0500C:  BTFSS  FA6.6
0500E:  GOTO   500C
05012:  MOVLB  E
05014:  MOVWF  xF9
....................       return FALSE;  
05016:  MOVLW  00
05018:  MOVWF  01
0501A:  MOVLB  0
0501C:  GOTO   5020
....................    }
05020:  GOTO   51A0 (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
05332:  MOVLW  AA
05334:  MOVLB  1
05336:  MOVWF  xC3
....................    data[1] = (BOSS_PIC << 4) | frame_id;
05338:  MOVF   xBF,W
0533A:  IORLW  50
0533C:  MOVWF  xC4
....................    memcpy(&data[2], content, size);
0533E:  MOVLW  01
05340:  MOVWF  FEA
05342:  MOVLW  C5
05344:  MOVWF  FE9
05346:  MOVFF  1C1,FE2
0534A:  MOVFF  1C0,FE1
0534E:  MOVF   xC2,W
05350:  MOVWF  01
05352:  BTFSS  FD8.2
05354:  BRA    535C
05356:  MOVLB  0
05358:  GOTO   5368
0535C:  MOVLB  0
0535E:  MOVFF  FE6,FEE
05362:  DECFSZ 01,F
05364:  GOTO   535E
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
05368:  MOVLW  02
0536A:  MOVLB  1
0536C:  ADDWF  xC2,W
0536E:  MOVWF  xD3
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
05370:  CLRF   03
05372:  MOVF   xD3,W
05374:  ADDLW  C3
05376:  MOVWF  01
05378:  MOVLW  01
0537A:  ADDWFC 03,F
0537C:  MOVF   01,W
0537E:  MOVWF  xD5
05380:  MOVFF  03,1D6
05384:  MOVLW  01
05386:  SUBWF  xD3,W
05388:  MOVWF  xD7
0538A:  MOVLW  01
0538C:  MOVLB  A
0538E:  MOVWF  xEB
05390:  MOVLW  C4
05392:  MOVWF  xEA
05394:  MOVFF  1D7,AEC
05398:  MOVLB  0
0539A:  CALL   29E8
0539E:  MOVFF  1D6,FEA
053A2:  MOVFF  1D5,FE9
053A6:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
053AA:  MOVLW  01
053AC:  MOVLB  1
053AE:  ADDWF  xD3,W
053B0:  MOVWF  xD4
....................    
....................    transmit(data, data_size);
053B2:  MOVLW  01
053B4:  MOVWF  xD6
053B6:  MOVLW  C3
053B8:  MOVWF  xD5
053BA:  MOVFF  1D4,1D7
053BE:  MOVLB  0
053C0:  GOTO   5274
053C4:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
05274:  MOVLB  1
05276:  CLRF   xD8
05278:  MOVLB  0
0527A:  MOVLB  1
0527C:  MOVF   xD7,W
0527E:  SUBWF  xD8,W
05280:  BTFSS  FD8.0
05282:  BRA    528A
05284:  MOVLB  0
05286:  GOTO   52B0
0528A:  MOVLB  0
....................       fputc(data[i], BOSS);
0528C:  MOVLB  1
0528E:  MOVF   xD8,W
05290:  ADDWF  xD5,W
05292:  MOVWF  FE9
05294:  MOVLW  00
05296:  ADDWFC xD6,W
05298:  MOVWF  FEA
0529A:  MOVFF  FEF,1DA
0529E:  MOVF   xDA,W
052A0:  MOVLB  0
052A2:  GOTO   5264
052A6:  MOVLB  1
052A8:  INCF   xD8,F
052AA:  MOVLB  0
052AC:  GOTO   527A
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
052B0:  MOVLW  00
052B2:  MOVWF  FF6
052B4:  MOVLW  04
052B6:  MOVWF  FF7
052B8:  MOVLW  00
052BA:  MOVWF  FF8
052BC:  CALL   1BF6
....................    for(int i = 0; i < data_size; i++)
052C0:  MOVLB  1
052C2:  CLRF   xD9
052C4:  MOVLB  0
052C6:  MOVLB  1
052C8:  MOVF   xD7,W
052CA:  SUBWF  xD9,W
052CC:  BTFSS  FD8.0
052CE:  BRA    52D6
052D0:  MOVLB  0
052D2:  GOTO   5312
052D6:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
052D8:  MOVLB  1
052DA:  MOVF   xD9,W
052DC:  ADDWF  xD5,W
052DE:  MOVWF  FE9
052E0:  MOVLW  00
052E2:  ADDWFC xD6,W
052E4:  MOVWF  FEA
052E6:  MOVFF  FEF,1DA
052EA:  MOVFF  1DA,A48
052EE:  MOVLW  37
052F0:  MOVLB  A
052F2:  MOVWF  x49
052F4:  MOVLB  0
052F6:  CALL   1E3C
052FA:  MOVLW  20
052FC:  BTFSS  FA6.6
052FE:  GOTO   52FC
05302:  MOVLB  E
05304:  MOVWF  xF9
05306:  MOVLB  0
05308:  MOVLB  1
0530A:  INCF   xD9,F
0530C:  MOVLB  0
0530E:  GOTO   52C6
....................    fprintf(PC, "\r\n");
05312:  MOVLW  0D
05314:  BTFSS  FA6.6
05316:  GOTO   5314
0531A:  MOVLB  E
0531C:  MOVWF  xF9
0531E:  MOVLW  0A
05320:  MOVLB  0
05322:  BTFSS  FA6.6
05324:  GOTO   5322
05328:  MOVLB  E
0532A:  MOVWF  xF9
0532C:  MOVLB  0
0532E:  GOTO   53C4 (RETURN)
.................... }
.................... 
.................... #include "../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
053C6:  MOVLW  0F
053C8:  MOVLB  1
053CA:  MOVWF  xBF
053CC:  CLRF   xC1
053CE:  CLRF   xC0
053D0:  CLRF   xC2
053D2:  MOVLB  0
053D4:  CALL   5332
053D8:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
0A7E2:  MOVLW  03
0A7E4:  MOVLB  1
0A7E6:  MOVWF  xBF
0A7E8:  CLRF   xC1
0A7EA:  MOVLW  4C
0A7EC:  MOVWF  xC0
0A7EE:  MOVLW  04
0A7F0:  MOVWF  xC2
0A7F2:  MOVLB  0
0A7F4:  CALL   5332
0A7F8:  GOTO   A820 (RETURN)
.................... }
.................... 
.................... 
.................... #include "../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "domain/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... #define HEADER_SIZE 5  // START_MAKER + time (4バイト)
.................... #define ENV_SIZE    6  // pd + temp_py_top + temp_py_bot + temp_mis7 packed
.................... #define DATA_SIZE_PER_STEP 3 // data0 + data1 12bitずつ
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../device_driver/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../device_driver/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hal/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... int32 tick_10ms = 0; 
.................... 
.................... unsigned int32 dsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_10msec(unsigned int32 new_10msec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, ".");
*
089CE:  MOVLW  2E
089D0:  BTFSS  FA6.6
089D2:  GOTO   89D0
089D6:  MOVLB  E
089D8:  MOVWF  xF9
....................     
....................     // Enable both CIGS ports
....................     connect_port1();
089DA:  MOVLB  0
089DC:  CALL   4CFC
....................     connect_port2();
089E0:  CALL   4D04
....................     mcp4901_1_write(0); 
089E4:  MOVLB  9
089E6:  CLRF   xEA
089E8:  CLRF   xE9
089EA:  MOVLB  0
089EC:  CALL   2114
....................     mcp4901_2_write(0);
089F0:  MOVLB  9
089F2:  CLRF   xEA
089F4:  CLRF   xE9
089F6:  MOVLB  0
089F8:  CALL   2156
....................     delay_ms(100);
089FC:  MOVLW  64
089FE:  MOVLB  A
08A00:  MOVWF  xA3
08A02:  MOVLB  0
08A04:  CALL   1BC8
....................     
....................     // Init Port1
....................     sweep_config_t port1 = {0};
08A08:  MOVLB  1
08A0A:  CLRF   xDB
08A0C:  CLRF   xDC
08A0E:  CLRF   xDD
08A10:  CLRF   xDE
08A12:  CLRF   xDF
08A14:  CLRF   xE0
08A16:  CLRF   xE1
08A18:  CLRF   xE2
08A1A:  CLRF   xE3
08A1C:  CLRF   xE4
08A1E:  CLRF   xE5
08A20:  CLRF   xE6
08A22:  CLRF   xE7
08A24:  CLRF   xE8
08A26:  CLRF   xE9
08A28:  CLRF   xEA
08A2A:  CLRF   xEB
08A2C:  CLRF   xEC
08A2E:  CLRF   xED
08A30:  CLRF   xEE
08A32:  CLRF   xEF
08A34:  CLRF   xF0
08A36:  CLRF   xF1
08A38:  CLRF   xF2
08A3A:  CLRF   xF3
08A3C:  CLRF   xF4
08A3E:  CLRF   xF5
08A40:  CLRF   xF6
08A42:  CLRF   xF7
08A44:  CLRF   xF8
08A46:  CLRF   xF9
08A48:  CLRF   xFA
08A4A:  CLRF   xFB
08A4C:  CLRF   xFC
08A4E:  CLRF   xFD
08A50:  CLRF   xFE
08A52:  CLRF   xFF
08A54:  MOVLB  2
08A56:  CLRF   x00
08A58:  CLRF   x01
08A5A:  CLRF   x02
08A5C:  CLRF   x03
08A5E:  CLRF   x04
08A60:  CLRF   x05
08A62:  CLRF   x06
08A64:  CLRF   x07
08A66:  CLRF   x08
08A68:  CLRF   x09
08A6A:  CLRF   x0A
08A6C:  CLRF   x0B
08A6E:  CLRF   x0C
08A70:  CLRF   x0D
08A72:  CLRF   x0E
08A74:  CLRF   x0F
08A76:  CLRF   x10
08A78:  CLRF   x11
08A7A:  CLRF   x12
08A7C:  CLRF   x13
08A7E:  CLRF   x14
08A80:  CLRF   x15
08A82:  CLRF   x16
08A84:  CLRF   x17
08A86:  CLRF   x18
08A88:  CLRF   x19
08A8A:  CLRF   x1A
08A8C:  CLRF   x1B
08A8E:  CLRF   x1C
08A90:  CLRF   x1D
08A92:  CLRF   x1E
08A94:  CLRF   x1F
08A96:  CLRF   x20
08A98:  CLRF   x21
08A9A:  CLRF   x22
08A9C:  CLRF   x23
08A9E:  CLRF   x24
08AA0:  CLRF   x25
08AA2:  CLRF   x26
08AA4:  CLRF   x27
08AA6:  CLRF   x28
08AA8:  CLRF   x29
08AAA:  CLRF   x2A
08AAC:  CLRF   x2B
08AAE:  CLRF   x2C
08AB0:  CLRF   x2D
08AB2:  CLRF   x2E
08AB4:  CLRF   x2F
08AB6:  CLRF   x30
08AB8:  CLRF   x31
08ABA:  CLRF   x32
08ABC:  CLRF   x33
08ABE:  CLRF   x34
08AC0:  CLRF   x35
08AC2:  CLRF   x36
08AC4:  CLRF   x37
08AC6:  CLRF   x38
08AC8:  CLRF   x39
08ACA:  CLRF   x3A
08ACC:  CLRF   x3B
08ACE:  CLRF   x3C
08AD0:  CLRF   x3D
08AD2:  CLRF   x3E
08AD4:  CLRF   x3F
08AD6:  CLRF   x40
08AD8:  CLRF   x41
08ADA:  CLRF   x42
08ADC:  CLRF   x43
08ADE:  CLRF   x44
08AE0:  CLRF   x45
08AE2:  CLRF   x46
08AE4:  CLRF   x47
08AE6:  CLRF   x48
08AE8:  CLRF   x49
08AEA:  CLRF   x4A
08AEC:  CLRF   x4B
08AEE:  CLRF   x4C
08AF0:  CLRF   x4D
08AF2:  CLRF   x4E
08AF4:  CLRF   x4F
08AF6:  CLRF   x50
08AF8:  CLRF   x51
08AFA:  CLRF   x52
08AFC:  CLRF   x53
08AFE:  CLRF   x54
08B00:  CLRF   x55
08B02:  CLRF   x56
08B04:  CLRF   x57
08B06:  CLRF   x58
08B08:  CLRF   x59
08B0A:  CLRF   x5A
08B0C:  CLRF   x5B
08B0E:  CLRF   x5C
08B10:  CLRF   x5D
08B12:  CLRF   x5E
08B14:  CLRF   x5F
08B16:  CLRF   x60
08B18:  CLRF   x61
08B1A:  CLRF   x62
08B1C:  CLRF   x63
08B1E:  CLRF   x64
08B20:  CLRF   x65
08B22:  CLRF   x66
08B24:  CLRF   x67
08B26:  CLRF   x68
08B28:  CLRF   x69
08B2A:  CLRF   x6A
08B2C:  CLRF   x6B
08B2E:  CLRF   x6C
08B30:  CLRF   x6D
08B32:  CLRF   x6E
08B34:  CLRF   x6F
08B36:  CLRF   x70
08B38:  CLRF   x71
08B3A:  CLRF   x72
08B3C:  CLRF   x73
08B3E:  CLRF   x74
08B40:  CLRF   x75
08B42:  CLRF   x76
08B44:  CLRF   x77
08B46:  CLRF   x78
08B48:  CLRF   x79
08B4A:  CLRF   x7A
08B4C:  CLRF   x7B
08B4E:  CLRF   x7C
08B50:  CLRF   x7D
08B52:  CLRF   x7E
08B54:  CLRF   x7F
08B56:  CLRF   x80
08B58:  CLRF   x81
08B5A:  CLRF   x82
08B5C:  CLRF   x83
08B5E:  CLRF   x84
08B60:  CLRF   x85
08B62:  CLRF   x86
08B64:  CLRF   x87
08B66:  CLRF   x88
08B68:  CLRF   x89
08B6A:  CLRF   x8A
08B6C:  CLRF   x8B
08B6E:  CLRF   x8C
08B70:  CLRF   x8D
08B72:  CLRF   x8E
08B74:  CLRF   x8F
08B76:  CLRF   x90
08B78:  CLRF   x91
08B7A:  CLRF   x92
08B7C:  CLRF   x93
08B7E:  CLRF   x94
08B80:  CLRF   x95
08B82:  CLRF   x96
08B84:  CLRF   x97
08B86:  CLRF   x98
08B88:  CLRF   x99
08B8A:  CLRF   x9A
08B8C:  CLRF   x9B
08B8E:  CLRF   x9C
08B90:  CLRF   x9D
08B92:  CLRF   x9E
08B94:  CLRF   x9F
08B96:  CLRF   xA0
08B98:  CLRF   xA1
08B9A:  CLRF   xA2
08B9C:  CLRF   xA3
08B9E:  CLRF   xA4
08BA0:  CLRF   xA5
08BA2:  CLRF   xA6
08BA4:  CLRF   xA7
08BA6:  CLRF   xA8
08BA8:  CLRF   xA9
08BAA:  CLRF   xAA
08BAC:  CLRF   xAB
08BAE:  CLRF   xAC
08BB0:  CLRF   xAD
08BB2:  CLRF   xAE
08BB4:  CLRF   xAF
08BB6:  CLRF   xB0
08BB8:  CLRF   xB1
08BBA:  CLRF   xB2
08BBC:  CLRF   xB3
08BBE:  CLRF   xB4
08BC0:  CLRF   xB5
08BC2:  CLRF   xB6
08BC4:  CLRF   xB7
08BC6:  CLRF   xB8
08BC8:  CLRF   xB9
08BCA:  CLRF   xBA
08BCC:  CLRF   xBB
08BCE:  CLRF   xBC
08BD0:  CLRF   xBD
08BD2:  CLRF   xBE
08BD4:  CLRF   xBF
08BD6:  CLRF   xC0
08BD8:  CLRF   xC1
08BDA:  CLRF   xC2
08BDC:  CLRF   xC3
08BDE:  CLRF   xC4
08BE0:  CLRF   xC5
08BE2:  CLRF   xC6
08BE4:  CLRF   xC7
08BE6:  CLRF   xC8
08BE8:  CLRF   xC9
08BEA:  CLRF   xCA
08BEC:  CLRF   xCB
08BEE:  CLRF   xCC
08BF0:  CLRF   xCD
08BF2:  CLRF   xCE
08BF4:  CLRF   xCF
08BF6:  CLRF   xD0
08BF8:  CLRF   xD1
08BFA:  CLRF   xD2
08BFC:  CLRF   xD3
08BFE:  CLRF   xD4
08C00:  CLRF   xD5
08C02:  CLRF   xD6
08C04:  CLRF   xD7
08C06:  CLRF   xD8
08C08:  CLRF   xD9
08C0A:  CLRF   xDA
08C0C:  CLRF   xDB
08C0E:  CLRF   xDC
08C10:  CLRF   xDD
08C12:  CLRF   xDE
08C14:  CLRF   xDF
08C16:  CLRF   xE0
08C18:  CLRF   xE1
08C1A:  CLRF   xE2
08C1C:  CLRF   xE3
08C1E:  CLRF   xE4
08C20:  CLRF   xE5
08C22:  CLRF   xE6
08C24:  CLRF   xE7
08C26:  CLRF   xE8
08C28:  CLRF   xE9
08C2A:  CLRF   xEA
08C2C:  CLRF   xEB
08C2E:  CLRF   xEC
08C30:  CLRF   xED
08C32:  CLRF   xEE
08C34:  CLRF   xEF
08C36:  CLRF   xF0
08C38:  CLRF   xF1
08C3A:  CLRF   xF2
08C3C:  CLRF   xF3
08C3E:  CLRF   xF4
08C40:  CLRF   xF5
08C42:  CLRF   xF6
08C44:  CLRF   xF7
08C46:  CLRF   xF8
08C48:  CLRF   xF9
08C4A:  CLRF   xFA
08C4C:  CLRF   xFB
08C4E:  CLRF   xFC
08C50:  CLRF   xFD
08C52:  CLRF   xFE
08C54:  CLRF   xFF
08C56:  MOVLB  3
08C58:  CLRF   x00
08C5A:  CLRF   x01
08C5C:  CLRF   x02
08C5E:  CLRF   x03
08C60:  CLRF   x04
08C62:  CLRF   x05
08C64:  CLRF   x06
08C66:  CLRF   x07
08C68:  CLRF   x08
08C6A:  CLRF   x09
08C6C:  CLRF   x0A
08C6E:  CLRF   x0B
08C70:  CLRF   x0C
08C72:  CLRF   x0D
08C74:  CLRF   x0E
08C76:  CLRF   x0F
08C78:  CLRF   x10
08C7A:  CLRF   x11
08C7C:  CLRF   x12
08C7E:  CLRF   x13
08C80:  CLRF   x14
08C82:  CLRF   x15
08C84:  CLRF   x16
08C86:  CLRF   x17
08C88:  CLRF   x18
08C8A:  CLRF   x19
08C8C:  CLRF   x1A
08C8E:  CLRF   x1B
08C90:  CLRF   x1C
08C92:  CLRF   x1D
08C94:  CLRF   x1E
08C96:  CLRF   x1F
08C98:  CLRF   x20
08C9A:  CLRF   x21
08C9C:  CLRF   x22
08C9E:  CLRF   x23
08CA0:  CLRF   x24
08CA2:  CLRF   x25
08CA4:  CLRF   x26
08CA6:  CLRF   x27
08CA8:  CLRF   x28
08CAA:  CLRF   x29
08CAC:  CLRF   x2A
08CAE:  CLRF   x2B
08CB0:  CLRF   x2C
08CB2:  CLRF   x2D
08CB4:  CLRF   x2E
08CB6:  CLRF   x2F
08CB8:  CLRF   x30
08CBA:  CLRF   x31
08CBC:  CLRF   x32
08CBE:  CLRF   x33
08CC0:  CLRF   x34
08CC2:  CLRF   x35
08CC4:  CLRF   x36
08CC6:  CLRF   x37
08CC8:  CLRF   x38
08CCA:  CLRF   x39
08CCC:  CLRF   x3A
08CCE:  CLRF   x3B
08CD0:  CLRF   x3C
08CD2:  CLRF   x3D
08CD4:  CLRF   x3E
08CD6:  CLRF   x3F
08CD8:  CLRF   x40
08CDA:  CLRF   x41
08CDC:  CLRF   x42
08CDE:  CLRF   x43
08CE0:  CLRF   x44
08CE2:  CLRF   x45
08CE4:  CLRF   x46
08CE6:  CLRF   x47
08CE8:  CLRF   x48
08CEA:  CLRF   x49
08CEC:  CLRF   x4A
08CEE:  CLRF   x4B
08CF0:  CLRF   x4C
08CF2:  CLRF   x4D
08CF4:  CLRF   x4E
08CF6:  CLRF   x4F
08CF8:  CLRF   x50
08CFA:  CLRF   x51
08CFC:  CLRF   x52
08CFE:  CLRF   x53
08D00:  CLRF   x54
08D02:  CLRF   x55
08D04:  CLRF   x56
08D06:  CLRF   x57
08D08:  CLRF   x58
08D0A:  CLRF   x59
08D0C:  CLRF   x5A
08D0E:  CLRF   x5B
08D10:  CLRF   x5C
08D12:  CLRF   x5D
08D14:  CLRF   x5E
08D16:  CLRF   x5F
08D18:  CLRF   x60
08D1A:  CLRF   x61
08D1C:  CLRF   x62
08D1E:  CLRF   x63
08D20:  CLRF   x64
08D22:  CLRF   x65
08D24:  CLRF   x66
08D26:  CLRF   x67
08D28:  CLRF   x68
08D2A:  CLRF   x69
08D2C:  CLRF   x6A
08D2E:  CLRF   x6B
08D30:  CLRF   x6C
08D32:  CLRF   x6D
08D34:  CLRF   x6E
08D36:  CLRF   x6F
08D38:  CLRF   x70
08D3A:  CLRF   x71
08D3C:  CLRF   x72
08D3E:  CLRF   x73
08D40:  CLRF   x74
08D42:  CLRF   x75
08D44:  CLRF   x76
08D46:  CLRF   x77
08D48:  CLRF   x78
08D4A:  CLRF   x79
08D4C:  CLRF   x7A
08D4E:  CLRF   x7B
08D50:  CLRF   x7C
08D52:  CLRF   x7D
08D54:  CLRF   x7E
08D56:  CLRF   x7F
08D58:  CLRF   x80
08D5A:  CLRF   x81
08D5C:  CLRF   x82
08D5E:  CLRF   x83
08D60:  CLRF   x84
08D62:  CLRF   x85
08D64:  CLRF   x86
08D66:  CLRF   x87
08D68:  CLRF   x88
08D6A:  CLRF   x89
08D6C:  CLRF   x8A
08D6E:  CLRF   x8B
08D70:  CLRF   x8C
08D72:  CLRF   x8D
08D74:  CLRF   x8E
08D76:  CLRF   x8F
08D78:  CLRF   x90
08D7A:  CLRF   x91
08D7C:  CLRF   x92
08D7E:  CLRF   x93
08D80:  CLRF   x94
08D82:  CLRF   x95
08D84:  CLRF   x96
08D86:  CLRF   x97
08D88:  CLRF   x98
08D8A:  CLRF   x99
08D8C:  CLRF   x9A
08D8E:  CLRF   x9B
08D90:  CLRF   x9C
08D92:  CLRF   x9D
08D94:  CLRF   x9E
08D96:  CLRF   x9F
08D98:  CLRF   xA0
08D9A:  CLRF   xA1
08D9C:  CLRF   xA2
08D9E:  CLRF   xA3
08DA0:  CLRF   xA4
08DA2:  CLRF   xA5
08DA4:  CLRF   xA6
08DA6:  CLRF   xA7
08DA8:  CLRF   xA8
08DAA:  CLRF   xA9
08DAC:  CLRF   xAA
08DAE:  CLRF   xAB
08DB0:  CLRF   xAC
08DB2:  CLRF   xAD
08DB4:  CLRF   xAE
08DB6:  CLRF   xAF
08DB8:  CLRF   xB0
08DBA:  CLRF   xB1
08DBC:  CLRF   xB2
08DBE:  CLRF   xB3
08DC0:  CLRF   xB4
08DC2:  CLRF   xB5
08DC4:  CLRF   xB6
08DC6:  CLRF   xB7
08DC8:  CLRF   xB8
08DCA:  CLRF   xB9
08DCC:  CLRF   xBA
08DCE:  CLRF   xBB
08DD0:  CLRF   xBC
08DD2:  CLRF   xBD
08DD4:  CLRF   xBE
08DD6:  CLRF   xBF
08DD8:  CLRF   xC0
08DDA:  CLRF   xC1
08DDC:  CLRF   xC2
08DDE:  CLRF   xC3
08DE0:  CLRF   xC4
08DE2:  CLRF   xC5
08DE4:  CLRF   xC6
08DE6:  CLRF   xC7
08DE8:  CLRF   xC8
08DEA:  CLRF   xC9
08DEC:  CLRF   xCA
08DEE:  CLRF   xCB
08DF0:  CLRF   xCC
08DF2:  CLRF   xCD
08DF4:  CLRF   xCE
08DF6:  CLRF   xCF
08DF8:  CLRF   xD0
08DFA:  CLRF   xD1
08DFC:  CLRF   xD2
08DFE:  CLRF   xD3
08E00:  CLRF   xD4
08E02:  CLRF   xD5
08E04:  CLRF   xD6
08E06:  CLRF   xD7
08E08:  CLRF   xD8
08E0A:  CLRF   xD9
08E0C:  CLRF   xDA
08E0E:  CLRF   xDB
08E10:  CLRF   xDC
08E12:  CLRF   xDD
08E14:  CLRF   xDE
08E16:  CLRF   xDF
08E18:  CLRF   xE0
08E1A:  CLRF   xE1
08E1C:  CLRF   xE2
08E1E:  CLRF   xE3
08E20:  CLRF   xE4
08E22:  CLRF   xE5
08E24:  CLRF   xE6
08E26:  CLRF   xE7
08E28:  CLRF   xE8
08E2A:  CLRF   xE9
08E2C:  CLRF   xEA
08E2E:  CLRF   xEB
08E30:  CLRF   xEC
08E32:  CLRF   xED
08E34:  CLRF   xEE
08E36:  CLRF   xEF
08E38:  CLRF   xF0
08E3A:  CLRF   xF1
08E3C:  CLRF   xF2
08E3E:  CLRF   xF3
08E40:  CLRF   xF4
08E42:  CLRF   xF5
08E44:  CLRF   xF6
08E46:  CLRF   xF7
08E48:  CLRF   xF8
08E4A:  CLRF   xF9
08E4C:  CLRF   xFA
08E4E:  CLRF   xFB
08E50:  CLRF   xFC
08E52:  CLRF   xFD
08E54:  CLRF   xFE
08E56:  CLRF   xFF
08E58:  MOVLB  4
08E5A:  CLRF   x00
08E5C:  CLRF   x01
08E5E:  CLRF   x02
08E60:  CLRF   x03
08E62:  CLRF   x04
08E64:  CLRF   x05
08E66:  CLRF   x06
08E68:  CLRF   x07
08E6A:  CLRF   x08
08E6C:  CLRF   x09
08E6E:  CLRF   x0A
08E70:  CLRF   x0B
08E72:  CLRF   x0C
08E74:  CLRF   x0D
08E76:  CLRF   x0E
08E78:  CLRF   x0F
08E7A:  CLRF   x10
08E7C:  CLRF   x11
08E7E:  CLRF   x12
08E80:  CLRF   x13
08E82:  CLRF   x14
08E84:  CLRF   x15
08E86:  CLRF   x16
08E88:  CLRF   x17
08E8A:  CLRF   x18
08E8C:  CLRF   x19
08E8E:  CLRF   x1A
08E90:  CLRF   x1B
08E92:  CLRF   x1C
08E94:  CLRF   x1D
08E96:  CLRF   x1E
08E98:  CLRF   x1F
08E9A:  CLRF   x20
08E9C:  CLRF   x21
08E9E:  CLRF   x22
08EA0:  CLRF   x23
08EA2:  CLRF   x24
08EA4:  CLRF   x25
08EA6:  CLRF   x26
08EA8:  CLRF   x27
08EAA:  CLRF   x28
08EAC:  CLRF   x29
08EAE:  CLRF   x2A
08EB0:  CLRF   x2B
08EB2:  CLRF   x2C
08EB4:  CLRF   x2D
08EB6:  CLRF   x2E
08EB8:  CLRF   x2F
08EBA:  CLRF   x30
08EBC:  CLRF   x31
08EBE:  CLRF   x32
08EC0:  CLRF   x33
08EC2:  CLRF   x34
08EC4:  CLRF   x35
08EC6:  CLRF   x36
08EC8:  CLRF   x37
08ECA:  CLRF   x38
08ECC:  CLRF   x39
08ECE:  CLRF   x3A
08ED0:  CLRF   x3B
08ED2:  CLRF   x3C
08ED4:  CLRF   x3D
08ED6:  CLRF   x3E
08ED8:  CLRF   x3F
08EDA:  CLRF   x40
08EDC:  CLRF   x41
08EDE:  CLRF   x42
08EE0:  CLRF   x43
08EE2:  CLRF   x44
08EE4:  CLRF   x45
08EE6:  CLRF   x46
08EE8:  CLRF   x47
08EEA:  CLRF   x48
08EEC:  CLRF   x49
08EEE:  CLRF   x4A
08EF0:  CLRF   x4B
08EF2:  CLRF   x4C
08EF4:  CLRF   x4D
08EF6:  CLRF   x4E
08EF8:  CLRF   x4F
08EFA:  CLRF   x50
08EFC:  CLRF   x51
08EFE:  CLRF   x52
08F00:  CLRF   x53
08F02:  CLRF   x54
08F04:  CLRF   x55
08F06:  CLRF   x56
08F08:  CLRF   x57
08F0A:  CLRF   x58
08F0C:  CLRF   x59
08F0E:  CLRF   x5A
08F10:  CLRF   x5B
08F12:  CLRF   x5C
08F14:  CLRF   x5D
08F16:  CLRF   x5E
08F18:  CLRF   x5F
08F1A:  CLRF   x60
08F1C:  CLRF   x61
08F1E:  CLRF   x62
08F20:  CLRF   x63
08F22:  CLRF   x64
08F24:  CLRF   x65
08F26:  CLRF   x66
08F28:  CLRF   x67
08F2A:  CLRF   x68
08F2C:  CLRF   x69
08F2E:  CLRF   x6A
08F30:  CLRF   x6B
08F32:  CLRF   x6C
08F34:  CLRF   x6D
08F36:  CLRF   x6E
08F38:  CLRF   x6F
08F3A:  CLRF   x70
08F3C:  CLRF   x71
08F3E:  CLRF   x72
08F40:  CLRF   x73
08F42:  CLRF   x74
08F44:  CLRF   x75
08F46:  CLRF   x76
08F48:  CLRF   x77
08F4A:  CLRF   x78
08F4C:  CLRF   x79
08F4E:  CLRF   x7A
08F50:  CLRF   x7B
08F52:  CLRF   x7C
08F54:  CLRF   x7D
08F56:  CLRF   x7E
08F58:  CLRF   x7F
08F5A:  CLRF   x80
08F5C:  CLRF   x81
08F5E:  CLRF   x82
08F60:  CLRF   x83
08F62:  CLRF   x84
08F64:  CLRF   x85
08F66:  CLRF   x86
08F68:  CLRF   x87
08F6A:  CLRF   x88
08F6C:  CLRF   x89
08F6E:  CLRF   x8A
08F70:  CLRF   x8B
08F72:  CLRF   x8C
08F74:  CLRF   x8D
08F76:  CLRF   x8E
08F78:  CLRF   x8F
08F7A:  CLRF   x90
08F7C:  CLRF   x91
08F7E:  CLRF   x92
08F80:  CLRF   x93
08F82:  CLRF   x94
08F84:  CLRF   x95
08F86:  CLRF   x96
08F88:  CLRF   x97
08F8A:  CLRF   x98
08F8C:  CLRF   x99
08F8E:  CLRF   x9A
08F90:  CLRF   x9B
08F92:  CLRF   x9C
08F94:  CLRF   x9D
08F96:  CLRF   x9E
08F98:  CLRF   x9F
08F9A:  CLRF   xA0
08F9C:  CLRF   xA1
08F9E:  CLRF   xA2
08FA0:  CLRF   xA3
08FA2:  CLRF   xA4
08FA4:  CLRF   xA5
08FA6:  CLRF   xA6
08FA8:  CLRF   xA7
08FAA:  CLRF   xA8
08FAC:  CLRF   xA9
08FAE:  CLRF   xAA
08FB0:  CLRF   xAB
08FB2:  CLRF   xAC
08FB4:  CLRF   xAD
08FB6:  CLRF   xAE
08FB8:  CLRF   xAF
08FBA:  CLRF   xB0
08FBC:  CLRF   xB1
08FBE:  CLRF   xB2
08FC0:  CLRF   xB3
08FC2:  CLRF   xB4
08FC4:  CLRF   xB5
08FC6:  CLRF   xB6
08FC8:  CLRF   xB7
08FCA:  CLRF   xB8
08FCC:  CLRF   xB9
08FCE:  CLRF   xBA
08FD0:  CLRF   xBB
08FD2:  CLRF   xBC
08FD4:  CLRF   xBD
08FD6:  CLRF   xBE
08FD8:  CLRF   xBF
08FDA:  CLRF   xC0
08FDC:  CLRF   xC1
08FDE:  CLRF   xC2
08FE0:  CLRF   xC3
08FE2:  CLRF   xC4
08FE4:  CLRF   xC5
08FE6:  CLRF   xC6
08FE8:  CLRF   xC7
08FEA:  CLRF   xC8
08FEC:  CLRF   xC9
08FEE:  CLRF   xCA
08FF0:  CLRF   xCB
08FF2:  CLRF   xCC
08FF4:  CLRF   xCD
08FF6:  CLRF   xCE
08FF8:  CLRF   xCF
08FFA:  CLRF   xD0
08FFC:  CLRF   xD1
08FFE:  CLRF   xD2
09000:  CLRF   xD3
09002:  CLRF   xD4
09004:  CLRF   xD5
09006:  CLRF   xD6
09008:  CLRF   xD7
0900A:  CLRF   xD8
0900C:  CLRF   xD9
0900E:  CLRF   xDA
09010:  CLRF   xDB
09012:  CLRF   xDC
09014:  CLRF   xDD
09016:  CLRF   xDE
09018:  CLRF   xDF
0901A:  CLRF   xE0
0901C:  CLRF   xE1
0901E:  CLRF   xE2
09020:  CLRF   xE3
09022:  CLRF   xE4
09024:  CLRF   xE5
09026:  CLRF   xE6
09028:  CLRF   xE7
0902A:  CLRF   xE8
0902C:  CLRF   xE9
0902E:  CLRF   xEA
09030:  CLRF   xEB
09032:  CLRF   xEC
09034:  CLRF   xED
09036:  CLRF   xEE
09038:  CLRF   xEF
0903A:  CLRF   xF0
0903C:  CLRF   xF1
0903E:  CLRF   xF2
09040:  CLRF   xF3
09042:  CLRF   xF4
09044:  CLRF   xF5
09046:  CLRF   xF6
09048:  CLRF   xF7
0904A:  CLRF   xF8
0904C:  CLRF   xF9
0904E:  CLRF   xFA
09050:  CLRF   xFB
09052:  CLRF   xFC
09054:  CLRF   xFD
09056:  CLRF   xFE
09058:  CLRF   xFF
0905A:  MOVLB  5
0905C:  CLRF   x00
0905E:  CLRF   x01
09060:  CLRF   x02
09062:  CLRF   x03
09064:  CLRF   x04
09066:  CLRF   x05
09068:  CLRF   x06
0906A:  CLRF   x07
0906C:  CLRF   x08
0906E:  CLRF   x09
09070:  CLRF   x0A
09072:  CLRF   x0B
09074:  CLRF   x0C
09076:  CLRF   x0D
09078:  CLRF   x0E
0907A:  CLRF   x0F
0907C:  CLRF   x10
0907E:  CLRF   x11
09080:  CLRF   x12
09082:  CLRF   x13
09084:  CLRF   x14
09086:  CLRF   x15
09088:  CLRF   x16
0908A:  CLRF   x17
0908C:  CLRF   x18
0908E:  CLRF   x19
09090:  CLRF   x1A
09092:  CLRF   x1B
09094:  CLRF   x1C
09096:  CLRF   x1D
09098:  CLRF   x1E
0909A:  CLRF   x1F
0909C:  CLRF   x20
0909E:  CLRF   x21
090A0:  CLRF   x22
090A2:  CLRF   x23
090A4:  CLRF   x24
090A6:  CLRF   x25
090A8:  CLRF   x26
090AA:  CLRF   x27
090AC:  CLRF   x28
090AE:  CLRF   x29
090B0:  CLRF   x2A
090B2:  CLRF   x2B
090B4:  CLRF   x2C
090B6:  CLRF   x2D
090B8:  CLRF   x2E
090BA:  CLRF   x2F
090BC:  CLRF   x30
090BE:  CLRF   x31
090C0:  CLRF   x32
090C2:  CLRF   x33
090C4:  CLRF   x34
090C6:  CLRF   x35
090C8:  CLRF   x36
090CA:  CLRF   x37
090CC:  CLRF   x38
090CE:  CLRF   x39
090D0:  CLRF   x3A
090D2:  CLRF   x3B
090D4:  CLRF   x3C
090D6:  CLRF   x3D
090D8:  CLRF   x3E
090DA:  CLRF   x3F
090DC:  CLRF   x40
090DE:  CLRF   x41
090E0:  CLRF   x42
090E2:  CLRF   x43
090E4:  CLRF   x44
090E6:  CLRF   x45
090E8:  CLRF   x46
090EA:  CLRF   x47
090EC:  CLRF   x48
090EE:  CLRF   x49
090F0:  CLRF   x4A
090F2:  CLRF   x4B
090F4:  CLRF   x4C
090F6:  CLRF   x4D
090F8:  CLRF   x4E
090FA:  CLRF   x4F
090FC:  CLRF   x50
090FE:  CLRF   x51
09100:  CLRF   x52
09102:  CLRF   x53
09104:  CLRF   x54
09106:  CLRF   x55
09108:  CLRF   x56
0910A:  CLRF   x57
0910C:  CLRF   x58
0910E:  CLRF   x59
09110:  CLRF   x5A
09112:  CLRF   x5B
09114:  CLRF   x5C
09116:  CLRF   x5D
09118:  CLRF   x5E
0911A:  CLRF   x5F
0911C:  CLRF   x60
0911E:  CLRF   x61
09120:  CLRF   x62
09122:  CLRF   x63
09124:  CLRF   x64
09126:  CLRF   x65
09128:  CLRF   x66
0912A:  CLRF   x67
0912C:  CLRF   x68
0912E:  CLRF   x69
09130:  CLRF   x6A
09132:  CLRF   x6B
09134:  CLRF   x6C
09136:  CLRF   x6D
09138:  CLRF   x6E
0913A:  CLRF   x6F
0913C:  CLRF   x70
0913E:  CLRF   x71
09140:  CLRF   x72
09142:  CLRF   x73
09144:  CLRF   x74
09146:  CLRF   x75
09148:  CLRF   x76
0914A:  CLRF   x77
0914C:  CLRF   x78
0914E:  CLRF   x79
09150:  CLRF   x7A
09152:  CLRF   x7B
09154:  CLRF   x7C
09156:  CLRF   x7D
09158:  CLRF   x7E
0915A:  CLRF   x7F
0915C:  CLRF   x80
0915E:  CLRF   x81
09160:  CLRF   x82
09162:  CLRF   x83
09164:  CLRF   x84
09166:  CLRF   x85
09168:  CLRF   x86
0916A:  CLRF   x87
0916C:  CLRF   x88
0916E:  CLRF   x89
09170:  CLRF   x8A
09172:  CLRF   x8B
09174:  CLRF   x8C
09176:  CLRF   x8D
09178:  CLRF   x8E
0917A:  CLRF   x8F
0917C:  CLRF   x90
0917E:  CLRF   x91
09180:  CLRF   x92
09182:  CLRF   x93
09184:  CLRF   x94
09186:  CLRF   x95
09188:  CLRF   x96
0918A:  CLRF   x97
0918C:  CLRF   x98
0918E:  CLRF   x99
09190:  CLRF   x9A
09192:  CLRF   x9B
09194:  CLRF   x9C
09196:  CLRF   x9D
09198:  CLRF   x9E
0919A:  CLRF   x9F
0919C:  CLRF   xA0
0919E:  CLRF   xA1
091A0:  CLRF   xA2
091A2:  CLRF   xA3
091A4:  CLRF   xA4
091A6:  CLRF   xA5
091A8:  CLRF   xA6
091AA:  CLRF   xA7
091AC:  CLRF   xA8
091AE:  CLRF   xA9
091B0:  CLRF   xAA
091B2:  CLRF   xAB
091B4:  CLRF   xAC
091B6:  CLRF   xAD
091B8:  CLRF   xAE
091BA:  CLRF   xAF
091BC:  CLRF   xB0
091BE:  CLRF   xB1
091C0:  CLRF   xB2
091C2:  CLRF   xB3
091C4:  CLRF   xB4
091C6:  CLRF   xB5
091C8:  CLRF   xB6
091CA:  CLRF   xB7
091CC:  CLRF   xB8
091CE:  CLRF   xB9
091D0:  CLRF   xBA
091D2:  CLRF   xBB
091D4:  CLRF   xBC
091D6:  CLRF   xBD
091D8:  CLRF   xBE
091DA:  CLRF   xBF
091DC:  CLRF   xC0
091DE:  CLRF   xC1
091E0:  CLRF   xC2
091E2:  CLRF   xC3
091E4:  CLRF   xC4
091E6:  CLRF   xC5
091E8:  CLRF   xC6
091EA:  CLRF   xC7
091EC:  CLRF   xC8
091EE:  CLRF   xC9
091F0:  CLRF   xCA
091F2:  CLRF   xCB
091F4:  CLRF   xCC
091F6:  CLRF   xCD
091F8:  CLRF   xCE
091FA:  CLRF   xCF
091FC:  CLRF   xD0
091FE:  CLRF   xD1
09200:  CLRF   xD2
09202:  CLRF   xD3
09204:  CLRF   xD4
09206:  CLRF   xD5
09208:  CLRF   xD6
0920A:  CLRF   xD7
0920C:  CLRF   xD8
0920E:  CLRF   xD9
09210:  CLRF   xDA
....................     port1.port_num = 1;
09212:  MOVLW  01
09214:  MOVLB  1
09216:  MOVWF  xDB
....................     port1.sweep_step = 0;
09218:  CLRF   xDD
0921A:  CLRF   xDC
....................     port1.active = 1;
0921C:  MOVLB  5
0921E:  BSF    xDA.0
.................... 
....................     // Init Port2
....................     sweep_config_t port2 = {0};
09220:  CLRF   xDB
09222:  CLRF   xDC
09224:  CLRF   xDD
09226:  CLRF   xDE
09228:  CLRF   xDF
0922A:  CLRF   xE0
0922C:  CLRF   xE1
0922E:  CLRF   xE2
09230:  CLRF   xE3
09232:  CLRF   xE4
09234:  CLRF   xE5
09236:  CLRF   xE6
09238:  CLRF   xE7
0923A:  CLRF   xE8
0923C:  CLRF   xE9
0923E:  CLRF   xEA
09240:  CLRF   xEB
09242:  CLRF   xEC
09244:  CLRF   xED
09246:  CLRF   xEE
09248:  CLRF   xEF
0924A:  CLRF   xF0
0924C:  CLRF   xF1
0924E:  CLRF   xF2
09250:  CLRF   xF3
09252:  CLRF   xF4
09254:  CLRF   xF5
09256:  CLRF   xF6
09258:  CLRF   xF7
0925A:  CLRF   xF8
0925C:  CLRF   xF9
0925E:  CLRF   xFA
09260:  CLRF   xFB
09262:  CLRF   xFC
09264:  CLRF   xFD
09266:  CLRF   xFE
09268:  CLRF   xFF
0926A:  MOVLB  6
0926C:  CLRF   x00
0926E:  CLRF   x01
09270:  CLRF   x02
09272:  CLRF   x03
09274:  CLRF   x04
09276:  CLRF   x05
09278:  CLRF   x06
0927A:  CLRF   x07
0927C:  CLRF   x08
0927E:  CLRF   x09
09280:  CLRF   x0A
09282:  CLRF   x0B
09284:  CLRF   x0C
09286:  CLRF   x0D
09288:  CLRF   x0E
0928A:  CLRF   x0F
0928C:  CLRF   x10
0928E:  CLRF   x11
09290:  CLRF   x12
09292:  CLRF   x13
09294:  CLRF   x14
09296:  CLRF   x15
09298:  CLRF   x16
0929A:  CLRF   x17
0929C:  CLRF   x18
0929E:  CLRF   x19
092A0:  CLRF   x1A
092A2:  CLRF   x1B
092A4:  CLRF   x1C
092A6:  CLRF   x1D
092A8:  CLRF   x1E
092AA:  CLRF   x1F
092AC:  CLRF   x20
092AE:  CLRF   x21
092B0:  CLRF   x22
092B2:  CLRF   x23
092B4:  CLRF   x24
092B6:  CLRF   x25
092B8:  CLRF   x26
092BA:  CLRF   x27
092BC:  CLRF   x28
092BE:  CLRF   x29
092C0:  CLRF   x2A
092C2:  CLRF   x2B
092C4:  CLRF   x2C
092C6:  CLRF   x2D
092C8:  CLRF   x2E
092CA:  CLRF   x2F
092CC:  CLRF   x30
092CE:  CLRF   x31
092D0:  CLRF   x32
092D2:  CLRF   x33
092D4:  CLRF   x34
092D6:  CLRF   x35
092D8:  CLRF   x36
092DA:  CLRF   x37
092DC:  CLRF   x38
092DE:  CLRF   x39
092E0:  CLRF   x3A
092E2:  CLRF   x3B
092E4:  CLRF   x3C
092E6:  CLRF   x3D
092E8:  CLRF   x3E
092EA:  CLRF   x3F
092EC:  CLRF   x40
092EE:  CLRF   x41
092F0:  CLRF   x42
092F2:  CLRF   x43
092F4:  CLRF   x44
092F6:  CLRF   x45
092F8:  CLRF   x46
092FA:  CLRF   x47
092FC:  CLRF   x48
092FE:  CLRF   x49
09300:  CLRF   x4A
09302:  CLRF   x4B
09304:  CLRF   x4C
09306:  CLRF   x4D
09308:  CLRF   x4E
0930A:  CLRF   x4F
0930C:  CLRF   x50
0930E:  CLRF   x51
09310:  CLRF   x52
09312:  CLRF   x53
09314:  CLRF   x54
09316:  CLRF   x55
09318:  CLRF   x56
0931A:  CLRF   x57
0931C:  CLRF   x58
0931E:  CLRF   x59
09320:  CLRF   x5A
09322:  CLRF   x5B
09324:  CLRF   x5C
09326:  CLRF   x5D
09328:  CLRF   x5E
0932A:  CLRF   x5F
0932C:  CLRF   x60
0932E:  CLRF   x61
09330:  CLRF   x62
09332:  CLRF   x63
09334:  CLRF   x64
09336:  CLRF   x65
09338:  CLRF   x66
0933A:  CLRF   x67
0933C:  CLRF   x68
0933E:  CLRF   x69
09340:  CLRF   x6A
09342:  CLRF   x6B
09344:  CLRF   x6C
09346:  CLRF   x6D
09348:  CLRF   x6E
0934A:  CLRF   x6F
0934C:  CLRF   x70
0934E:  CLRF   x71
09350:  CLRF   x72
09352:  CLRF   x73
09354:  CLRF   x74
09356:  CLRF   x75
09358:  CLRF   x76
0935A:  CLRF   x77
0935C:  CLRF   x78
0935E:  CLRF   x79
09360:  CLRF   x7A
09362:  CLRF   x7B
09364:  CLRF   x7C
09366:  CLRF   x7D
09368:  CLRF   x7E
0936A:  CLRF   x7F
0936C:  CLRF   x80
0936E:  CLRF   x81
09370:  CLRF   x82
09372:  CLRF   x83
09374:  CLRF   x84
09376:  CLRF   x85
09378:  CLRF   x86
0937A:  CLRF   x87
0937C:  CLRF   x88
0937E:  CLRF   x89
09380:  CLRF   x8A
09382:  CLRF   x8B
09384:  CLRF   x8C
09386:  CLRF   x8D
09388:  CLRF   x8E
0938A:  CLRF   x8F
0938C:  CLRF   x90
0938E:  CLRF   x91
09390:  CLRF   x92
09392:  CLRF   x93
09394:  CLRF   x94
09396:  CLRF   x95
09398:  CLRF   x96
0939A:  CLRF   x97
0939C:  CLRF   x98
0939E:  CLRF   x99
093A0:  CLRF   x9A
093A2:  CLRF   x9B
093A4:  CLRF   x9C
093A6:  CLRF   x9D
093A8:  CLRF   x9E
093AA:  CLRF   x9F
093AC:  CLRF   xA0
093AE:  CLRF   xA1
093B0:  CLRF   xA2
093B2:  CLRF   xA3
093B4:  CLRF   xA4
093B6:  CLRF   xA5
093B8:  CLRF   xA6
093BA:  CLRF   xA7
093BC:  CLRF   xA8
093BE:  CLRF   xA9
093C0:  CLRF   xAA
093C2:  CLRF   xAB
093C4:  CLRF   xAC
093C6:  CLRF   xAD
093C8:  CLRF   xAE
093CA:  CLRF   xAF
093CC:  CLRF   xB0
093CE:  CLRF   xB1
093D0:  CLRF   xB2
093D2:  CLRF   xB3
093D4:  CLRF   xB4
093D6:  CLRF   xB5
093D8:  CLRF   xB6
093DA:  CLRF   xB7
093DC:  CLRF   xB8
093DE:  CLRF   xB9
093E0:  CLRF   xBA
093E2:  CLRF   xBB
093E4:  CLRF   xBC
093E6:  CLRF   xBD
093E8:  CLRF   xBE
093EA:  CLRF   xBF
093EC:  CLRF   xC0
093EE:  CLRF   xC1
093F0:  CLRF   xC2
093F2:  CLRF   xC3
093F4:  CLRF   xC4
093F6:  CLRF   xC5
093F8:  CLRF   xC6
093FA:  CLRF   xC7
093FC:  CLRF   xC8
093FE:  CLRF   xC9
09400:  CLRF   xCA
09402:  CLRF   xCB
09404:  CLRF   xCC
09406:  CLRF   xCD
09408:  CLRF   xCE
0940A:  CLRF   xCF
0940C:  CLRF   xD0
0940E:  CLRF   xD1
09410:  CLRF   xD2
09412:  CLRF   xD3
09414:  CLRF   xD4
09416:  CLRF   xD5
09418:  CLRF   xD6
0941A:  CLRF   xD7
0941C:  CLRF   xD8
0941E:  CLRF   xD9
09420:  CLRF   xDA
09422:  CLRF   xDB
09424:  CLRF   xDC
09426:  CLRF   xDD
09428:  CLRF   xDE
0942A:  CLRF   xDF
0942C:  CLRF   xE0
0942E:  CLRF   xE1
09430:  CLRF   xE2
09432:  CLRF   xE3
09434:  CLRF   xE4
09436:  CLRF   xE5
09438:  CLRF   xE6
0943A:  CLRF   xE7
0943C:  CLRF   xE8
0943E:  CLRF   xE9
09440:  CLRF   xEA
09442:  CLRF   xEB
09444:  CLRF   xEC
09446:  CLRF   xED
09448:  CLRF   xEE
0944A:  CLRF   xEF
0944C:  CLRF   xF0
0944E:  CLRF   xF1
09450:  CLRF   xF2
09452:  CLRF   xF3
09454:  CLRF   xF4
09456:  CLRF   xF5
09458:  CLRF   xF6
0945A:  CLRF   xF7
0945C:  CLRF   xF8
0945E:  CLRF   xF9
09460:  CLRF   xFA
09462:  CLRF   xFB
09464:  CLRF   xFC
09466:  CLRF   xFD
09468:  CLRF   xFE
0946A:  CLRF   xFF
0946C:  MOVLB  7
0946E:  CLRF   x00
09470:  CLRF   x01
09472:  CLRF   x02
09474:  CLRF   x03
09476:  CLRF   x04
09478:  CLRF   x05
0947A:  CLRF   x06
0947C:  CLRF   x07
0947E:  CLRF   x08
09480:  CLRF   x09
09482:  CLRF   x0A
09484:  CLRF   x0B
09486:  CLRF   x0C
09488:  CLRF   x0D
0948A:  CLRF   x0E
0948C:  CLRF   x0F
0948E:  CLRF   x10
09490:  CLRF   x11
09492:  CLRF   x12
09494:  CLRF   x13
09496:  CLRF   x14
09498:  CLRF   x15
0949A:  CLRF   x16
0949C:  CLRF   x17
0949E:  CLRF   x18
094A0:  CLRF   x19
094A2:  CLRF   x1A
094A4:  CLRF   x1B
094A6:  CLRF   x1C
094A8:  CLRF   x1D
094AA:  CLRF   x1E
094AC:  CLRF   x1F
094AE:  CLRF   x20
094B0:  CLRF   x21
094B2:  CLRF   x22
094B4:  CLRF   x23
094B6:  CLRF   x24
094B8:  CLRF   x25
094BA:  CLRF   x26
094BC:  CLRF   x27
094BE:  CLRF   x28
094C0:  CLRF   x29
094C2:  CLRF   x2A
094C4:  CLRF   x2B
094C6:  CLRF   x2C
094C8:  CLRF   x2D
094CA:  CLRF   x2E
094CC:  CLRF   x2F
094CE:  CLRF   x30
094D0:  CLRF   x31
094D2:  CLRF   x32
094D4:  CLRF   x33
094D6:  CLRF   x34
094D8:  CLRF   x35
094DA:  CLRF   x36
094DC:  CLRF   x37
094DE:  CLRF   x38
094E0:  CLRF   x39
094E2:  CLRF   x3A
094E4:  CLRF   x3B
094E6:  CLRF   x3C
094E8:  CLRF   x3D
094EA:  CLRF   x3E
094EC:  CLRF   x3F
094EE:  CLRF   x40
094F0:  CLRF   x41
094F2:  CLRF   x42
094F4:  CLRF   x43
094F6:  CLRF   x44
094F8:  CLRF   x45
094FA:  CLRF   x46
094FC:  CLRF   x47
094FE:  CLRF   x48
09500:  CLRF   x49
09502:  CLRF   x4A
09504:  CLRF   x4B
09506:  CLRF   x4C
09508:  CLRF   x4D
0950A:  CLRF   x4E
0950C:  CLRF   x4F
0950E:  CLRF   x50
09510:  CLRF   x51
09512:  CLRF   x52
09514:  CLRF   x53
09516:  CLRF   x54
09518:  CLRF   x55
0951A:  CLRF   x56
0951C:  CLRF   x57
0951E:  CLRF   x58
09520:  CLRF   x59
09522:  CLRF   x5A
09524:  CLRF   x5B
09526:  CLRF   x5C
09528:  CLRF   x5D
0952A:  CLRF   x5E
0952C:  CLRF   x5F
0952E:  CLRF   x60
09530:  CLRF   x61
09532:  CLRF   x62
09534:  CLRF   x63
09536:  CLRF   x64
09538:  CLRF   x65
0953A:  CLRF   x66
0953C:  CLRF   x67
0953E:  CLRF   x68
09540:  CLRF   x69
09542:  CLRF   x6A
09544:  CLRF   x6B
09546:  CLRF   x6C
09548:  CLRF   x6D
0954A:  CLRF   x6E
0954C:  CLRF   x6F
0954E:  CLRF   x70
09550:  CLRF   x71
09552:  CLRF   x72
09554:  CLRF   x73
09556:  CLRF   x74
09558:  CLRF   x75
0955A:  CLRF   x76
0955C:  CLRF   x77
0955E:  CLRF   x78
09560:  CLRF   x79
09562:  CLRF   x7A
09564:  CLRF   x7B
09566:  CLRF   x7C
09568:  CLRF   x7D
0956A:  CLRF   x7E
0956C:  CLRF   x7F
0956E:  CLRF   x80
09570:  CLRF   x81
09572:  CLRF   x82
09574:  CLRF   x83
09576:  CLRF   x84
09578:  CLRF   x85
0957A:  CLRF   x86
0957C:  CLRF   x87
0957E:  CLRF   x88
09580:  CLRF   x89
09582:  CLRF   x8A
09584:  CLRF   x8B
09586:  CLRF   x8C
09588:  CLRF   x8D
0958A:  CLRF   x8E
0958C:  CLRF   x8F
0958E:  CLRF   x90
09590:  CLRF   x91
09592:  CLRF   x92
09594:  CLRF   x93
09596:  CLRF   x94
09598:  CLRF   x95
0959A:  CLRF   x96
0959C:  CLRF   x97
0959E:  CLRF   x98
095A0:  CLRF   x99
095A2:  CLRF   x9A
095A4:  CLRF   x9B
095A6:  CLRF   x9C
095A8:  CLRF   x9D
095AA:  CLRF   x9E
095AC:  CLRF   x9F
095AE:  CLRF   xA0
095B0:  CLRF   xA1
095B2:  CLRF   xA2
095B4:  CLRF   xA3
095B6:  CLRF   xA4
095B8:  CLRF   xA5
095BA:  CLRF   xA6
095BC:  CLRF   xA7
095BE:  CLRF   xA8
095C0:  CLRF   xA9
095C2:  CLRF   xAA
095C4:  CLRF   xAB
095C6:  CLRF   xAC
095C8:  CLRF   xAD
095CA:  CLRF   xAE
095CC:  CLRF   xAF
095CE:  CLRF   xB0
095D0:  CLRF   xB1
095D2:  CLRF   xB2
095D4:  CLRF   xB3
095D6:  CLRF   xB4
095D8:  CLRF   xB5
095DA:  CLRF   xB6
095DC:  CLRF   xB7
095DE:  CLRF   xB8
095E0:  CLRF   xB9
095E2:  CLRF   xBA
095E4:  CLRF   xBB
095E6:  CLRF   xBC
095E8:  CLRF   xBD
095EA:  CLRF   xBE
095EC:  CLRF   xBF
095EE:  CLRF   xC0
095F0:  CLRF   xC1
095F2:  CLRF   xC2
095F4:  CLRF   xC3
095F6:  CLRF   xC4
095F8:  CLRF   xC5
095FA:  CLRF   xC6
095FC:  CLRF   xC7
095FE:  CLRF   xC8
09600:  CLRF   xC9
09602:  CLRF   xCA
09604:  CLRF   xCB
09606:  CLRF   xCC
09608:  CLRF   xCD
0960A:  CLRF   xCE
0960C:  CLRF   xCF
0960E:  CLRF   xD0
09610:  CLRF   xD1
09612:  CLRF   xD2
09614:  CLRF   xD3
09616:  CLRF   xD4
09618:  CLRF   xD5
0961A:  CLRF   xD6
0961C:  CLRF   xD7
0961E:  CLRF   xD8
09620:  CLRF   xD9
09622:  CLRF   xDA
09624:  CLRF   xDB
09626:  CLRF   xDC
09628:  CLRF   xDD
0962A:  CLRF   xDE
0962C:  CLRF   xDF
0962E:  CLRF   xE0
09630:  CLRF   xE1
09632:  CLRF   xE2
09634:  CLRF   xE3
09636:  CLRF   xE4
09638:  CLRF   xE5
0963A:  CLRF   xE6
0963C:  CLRF   xE7
0963E:  CLRF   xE8
09640:  CLRF   xE9
09642:  CLRF   xEA
09644:  CLRF   xEB
09646:  CLRF   xEC
09648:  CLRF   xED
0964A:  CLRF   xEE
0964C:  CLRF   xEF
0964E:  CLRF   xF0
09650:  CLRF   xF1
09652:  CLRF   xF2
09654:  CLRF   xF3
09656:  CLRF   xF4
09658:  CLRF   xF5
0965A:  CLRF   xF6
0965C:  CLRF   xF7
0965E:  CLRF   xF8
09660:  CLRF   xF9
09662:  CLRF   xFA
09664:  CLRF   xFB
09666:  CLRF   xFC
09668:  CLRF   xFD
0966A:  CLRF   xFE
0966C:  CLRF   xFF
0966E:  MOVLB  8
09670:  CLRF   x00
09672:  CLRF   x01
09674:  CLRF   x02
09676:  CLRF   x03
09678:  CLRF   x04
0967A:  CLRF   x05
0967C:  CLRF   x06
0967E:  CLRF   x07
09680:  CLRF   x08
09682:  CLRF   x09
09684:  CLRF   x0A
09686:  CLRF   x0B
09688:  CLRF   x0C
0968A:  CLRF   x0D
0968C:  CLRF   x0E
0968E:  CLRF   x0F
09690:  CLRF   x10
09692:  CLRF   x11
09694:  CLRF   x12
09696:  CLRF   x13
09698:  CLRF   x14
0969A:  CLRF   x15
0969C:  CLRF   x16
0969E:  CLRF   x17
096A0:  CLRF   x18
096A2:  CLRF   x19
096A4:  CLRF   x1A
096A6:  CLRF   x1B
096A8:  CLRF   x1C
096AA:  CLRF   x1D
096AC:  CLRF   x1E
096AE:  CLRF   x1F
096B0:  CLRF   x20
096B2:  CLRF   x21
096B4:  CLRF   x22
096B6:  CLRF   x23
096B8:  CLRF   x24
096BA:  CLRF   x25
096BC:  CLRF   x26
096BE:  CLRF   x27
096C0:  CLRF   x28
096C2:  CLRF   x29
096C4:  CLRF   x2A
096C6:  CLRF   x2B
096C8:  CLRF   x2C
096CA:  CLRF   x2D
096CC:  CLRF   x2E
096CE:  CLRF   x2F
096D0:  CLRF   x30
096D2:  CLRF   x31
096D4:  CLRF   x32
096D6:  CLRF   x33
096D8:  CLRF   x34
096DA:  CLRF   x35
096DC:  CLRF   x36
096DE:  CLRF   x37
096E0:  CLRF   x38
096E2:  CLRF   x39
096E4:  CLRF   x3A
096E6:  CLRF   x3B
096E8:  CLRF   x3C
096EA:  CLRF   x3D
096EC:  CLRF   x3E
096EE:  CLRF   x3F
096F0:  CLRF   x40
096F2:  CLRF   x41
096F4:  CLRF   x42
096F6:  CLRF   x43
096F8:  CLRF   x44
096FA:  CLRF   x45
096FC:  CLRF   x46
096FE:  CLRF   x47
09700:  CLRF   x48
09702:  CLRF   x49
09704:  CLRF   x4A
09706:  CLRF   x4B
09708:  CLRF   x4C
0970A:  CLRF   x4D
0970C:  CLRF   x4E
0970E:  CLRF   x4F
09710:  CLRF   x50
09712:  CLRF   x51
09714:  CLRF   x52
09716:  CLRF   x53
09718:  CLRF   x54
0971A:  CLRF   x55
0971C:  CLRF   x56
0971E:  CLRF   x57
09720:  CLRF   x58
09722:  CLRF   x59
09724:  CLRF   x5A
09726:  CLRF   x5B
09728:  CLRF   x5C
0972A:  CLRF   x5D
0972C:  CLRF   x5E
0972E:  CLRF   x5F
09730:  CLRF   x60
09732:  CLRF   x61
09734:  CLRF   x62
09736:  CLRF   x63
09738:  CLRF   x64
0973A:  CLRF   x65
0973C:  CLRF   x66
0973E:  CLRF   x67
09740:  CLRF   x68
09742:  CLRF   x69
09744:  CLRF   x6A
09746:  CLRF   x6B
09748:  CLRF   x6C
0974A:  CLRF   x6D
0974C:  CLRF   x6E
0974E:  CLRF   x6F
09750:  CLRF   x70
09752:  CLRF   x71
09754:  CLRF   x72
09756:  CLRF   x73
09758:  CLRF   x74
0975A:  CLRF   x75
0975C:  CLRF   x76
0975E:  CLRF   x77
09760:  CLRF   x78
09762:  CLRF   x79
09764:  CLRF   x7A
09766:  CLRF   x7B
09768:  CLRF   x7C
0976A:  CLRF   x7D
0976C:  CLRF   x7E
0976E:  CLRF   x7F
09770:  CLRF   x80
09772:  CLRF   x81
09774:  CLRF   x82
09776:  CLRF   x83
09778:  CLRF   x84
0977A:  CLRF   x85
0977C:  CLRF   x86
0977E:  CLRF   x87
09780:  CLRF   x88
09782:  CLRF   x89
09784:  CLRF   x8A
09786:  CLRF   x8B
09788:  CLRF   x8C
0978A:  CLRF   x8D
0978C:  CLRF   x8E
0978E:  CLRF   x8F
09790:  CLRF   x90
09792:  CLRF   x91
09794:  CLRF   x92
09796:  CLRF   x93
09798:  CLRF   x94
0979A:  CLRF   x95
0979C:  CLRF   x96
0979E:  CLRF   x97
097A0:  CLRF   x98
097A2:  CLRF   x99
097A4:  CLRF   x9A
097A6:  CLRF   x9B
097A8:  CLRF   x9C
097AA:  CLRF   x9D
097AC:  CLRF   x9E
097AE:  CLRF   x9F
097B0:  CLRF   xA0
097B2:  CLRF   xA1
097B4:  CLRF   xA2
097B6:  CLRF   xA3
097B8:  CLRF   xA4
097BA:  CLRF   xA5
097BC:  CLRF   xA6
097BE:  CLRF   xA7
097C0:  CLRF   xA8
097C2:  CLRF   xA9
097C4:  CLRF   xAA
097C6:  CLRF   xAB
097C8:  CLRF   xAC
097CA:  CLRF   xAD
097CC:  CLRF   xAE
097CE:  CLRF   xAF
097D0:  CLRF   xB0
097D2:  CLRF   xB1
097D4:  CLRF   xB2
097D6:  CLRF   xB3
097D8:  CLRF   xB4
097DA:  CLRF   xB5
097DC:  CLRF   xB6
097DE:  CLRF   xB7
097E0:  CLRF   xB8
097E2:  CLRF   xB9
097E4:  CLRF   xBA
097E6:  CLRF   xBB
097E8:  CLRF   xBC
097EA:  CLRF   xBD
097EC:  CLRF   xBE
097EE:  CLRF   xBF
097F0:  CLRF   xC0
097F2:  CLRF   xC1
097F4:  CLRF   xC2
097F6:  CLRF   xC3
097F8:  CLRF   xC4
097FA:  CLRF   xC5
097FC:  CLRF   xC6
097FE:  CLRF   xC7
09800:  CLRF   xC8
09802:  CLRF   xC9
09804:  CLRF   xCA
09806:  CLRF   xCB
09808:  CLRF   xCC
0980A:  CLRF   xCD
0980C:  CLRF   xCE
0980E:  CLRF   xCF
09810:  CLRF   xD0
09812:  CLRF   xD1
09814:  CLRF   xD2
09816:  CLRF   xD3
09818:  CLRF   xD4
0981A:  CLRF   xD5
0981C:  CLRF   xD6
0981E:  CLRF   xD7
09820:  CLRF   xD8
09822:  CLRF   xD9
09824:  CLRF   xDA
09826:  CLRF   xDB
09828:  CLRF   xDC
0982A:  CLRF   xDD
0982C:  CLRF   xDE
0982E:  CLRF   xDF
09830:  CLRF   xE0
09832:  CLRF   xE1
09834:  CLRF   xE2
09836:  CLRF   xE3
09838:  CLRF   xE4
0983A:  CLRF   xE5
0983C:  CLRF   xE6
0983E:  CLRF   xE7
09840:  CLRF   xE8
09842:  CLRF   xE9
09844:  CLRF   xEA
09846:  CLRF   xEB
09848:  CLRF   xEC
0984A:  CLRF   xED
0984C:  CLRF   xEE
0984E:  CLRF   xEF
09850:  CLRF   xF0
09852:  CLRF   xF1
09854:  CLRF   xF2
09856:  CLRF   xF3
09858:  CLRF   xF4
0985A:  CLRF   xF5
0985C:  CLRF   xF6
0985E:  CLRF   xF7
09860:  CLRF   xF8
09862:  CLRF   xF9
09864:  CLRF   xFA
09866:  CLRF   xFB
09868:  CLRF   xFC
0986A:  CLRF   xFD
0986C:  CLRF   xFE
0986E:  CLRF   xFF
09870:  MOVLB  9
09872:  CLRF   x00
09874:  CLRF   x01
09876:  CLRF   x02
09878:  CLRF   x03
0987A:  CLRF   x04
0987C:  CLRF   x05
0987E:  CLRF   x06
09880:  CLRF   x07
09882:  CLRF   x08
09884:  CLRF   x09
09886:  CLRF   x0A
09888:  CLRF   x0B
0988A:  CLRF   x0C
0988C:  CLRF   x0D
0988E:  CLRF   x0E
09890:  CLRF   x0F
09892:  CLRF   x10
09894:  CLRF   x11
09896:  CLRF   x12
09898:  CLRF   x13
0989A:  CLRF   x14
0989C:  CLRF   x15
0989E:  CLRF   x16
098A0:  CLRF   x17
098A2:  CLRF   x18
098A4:  CLRF   x19
098A6:  CLRF   x1A
098A8:  CLRF   x1B
098AA:  CLRF   x1C
098AC:  CLRF   x1D
098AE:  CLRF   x1E
098B0:  CLRF   x1F
098B2:  CLRF   x20
098B4:  CLRF   x21
098B6:  CLRF   x22
098B8:  CLRF   x23
098BA:  CLRF   x24
098BC:  CLRF   x25
098BE:  CLRF   x26
098C0:  CLRF   x27
098C2:  CLRF   x28
098C4:  CLRF   x29
098C6:  CLRF   x2A
098C8:  CLRF   x2B
098CA:  CLRF   x2C
098CC:  CLRF   x2D
098CE:  CLRF   x2E
098D0:  CLRF   x2F
098D2:  CLRF   x30
098D4:  CLRF   x31
098D6:  CLRF   x32
098D8:  CLRF   x33
098DA:  CLRF   x34
098DC:  CLRF   x35
098DE:  CLRF   x36
098E0:  CLRF   x37
098E2:  CLRF   x38
098E4:  CLRF   x39
098E6:  CLRF   x3A
098E8:  CLRF   x3B
098EA:  CLRF   x3C
098EC:  CLRF   x3D
098EE:  CLRF   x3E
098F0:  CLRF   x3F
098F2:  CLRF   x40
098F4:  CLRF   x41
098F6:  CLRF   x42
098F8:  CLRF   x43
098FA:  CLRF   x44
098FC:  CLRF   x45
098FE:  CLRF   x46
09900:  CLRF   x47
09902:  CLRF   x48
09904:  CLRF   x49
09906:  CLRF   x4A
09908:  CLRF   x4B
0990A:  CLRF   x4C
0990C:  CLRF   x4D
0990E:  CLRF   x4E
09910:  CLRF   x4F
09912:  CLRF   x50
09914:  CLRF   x51
09916:  CLRF   x52
09918:  CLRF   x53
0991A:  CLRF   x54
0991C:  CLRF   x55
0991E:  CLRF   x56
09920:  CLRF   x57
09922:  CLRF   x58
09924:  CLRF   x59
09926:  CLRF   x5A
09928:  CLRF   x5B
0992A:  CLRF   x5C
0992C:  CLRF   x5D
0992E:  CLRF   x5E
09930:  CLRF   x5F
09932:  CLRF   x60
09934:  CLRF   x61
09936:  CLRF   x62
09938:  CLRF   x63
0993A:  CLRF   x64
0993C:  CLRF   x65
0993E:  CLRF   x66
09940:  CLRF   x67
09942:  CLRF   x68
09944:  CLRF   x69
09946:  CLRF   x6A
09948:  CLRF   x6B
0994A:  CLRF   x6C
0994C:  CLRF   x6D
0994E:  CLRF   x6E
09950:  CLRF   x6F
09952:  CLRF   x70
09954:  CLRF   x71
09956:  CLRF   x72
09958:  CLRF   x73
0995A:  CLRF   x74
0995C:  CLRF   x75
0995E:  CLRF   x76
09960:  CLRF   x77
09962:  CLRF   x78
09964:  CLRF   x79
09966:  CLRF   x7A
09968:  CLRF   x7B
0996A:  CLRF   x7C
0996C:  CLRF   x7D
0996E:  CLRF   x7E
09970:  CLRF   x7F
09972:  CLRF   x80
09974:  CLRF   x81
09976:  CLRF   x82
09978:  CLRF   x83
0997A:  CLRF   x84
0997C:  CLRF   x85
0997E:  CLRF   x86
09980:  CLRF   x87
09982:  CLRF   x88
09984:  CLRF   x89
09986:  CLRF   x8A
09988:  CLRF   x8B
0998A:  CLRF   x8C
0998C:  CLRF   x8D
0998E:  CLRF   x8E
09990:  CLRF   x8F
09992:  CLRF   x90
09994:  CLRF   x91
09996:  CLRF   x92
09998:  CLRF   x93
0999A:  CLRF   x94
0999C:  CLRF   x95
0999E:  CLRF   x96
099A0:  CLRF   x97
099A2:  CLRF   x98
099A4:  CLRF   x99
099A6:  CLRF   x9A
099A8:  CLRF   x9B
099AA:  CLRF   x9C
099AC:  CLRF   x9D
099AE:  CLRF   x9E
099B0:  CLRF   x9F
099B2:  CLRF   xA0
099B4:  CLRF   xA1
099B6:  CLRF   xA2
099B8:  CLRF   xA3
099BA:  CLRF   xA4
099BC:  CLRF   xA5
099BE:  CLRF   xA6
099C0:  CLRF   xA7
099C2:  CLRF   xA8
099C4:  CLRF   xA9
099C6:  CLRF   xAA
099C8:  CLRF   xAB
099CA:  CLRF   xAC
099CC:  CLRF   xAD
099CE:  CLRF   xAE
099D0:  CLRF   xAF
099D2:  CLRF   xB0
099D4:  CLRF   xB1
099D6:  CLRF   xB2
099D8:  CLRF   xB3
099DA:  CLRF   xB4
099DC:  CLRF   xB5
099DE:  CLRF   xB6
099E0:  CLRF   xB7
099E2:  CLRF   xB8
099E4:  CLRF   xB9
099E6:  CLRF   xBA
099E8:  CLRF   xBB
099EA:  CLRF   xBC
099EC:  CLRF   xBD
099EE:  CLRF   xBE
099F0:  CLRF   xBF
099F2:  CLRF   xC0
099F4:  CLRF   xC1
099F6:  CLRF   xC2
099F8:  CLRF   xC3
099FA:  CLRF   xC4
099FC:  CLRF   xC5
099FE:  CLRF   xC6
09A00:  CLRF   xC7
09A02:  CLRF   xC8
09A04:  CLRF   xC9
09A06:  CLRF   xCA
09A08:  CLRF   xCB
09A0A:  CLRF   xCC
09A0C:  CLRF   xCD
09A0E:  CLRF   xCE
09A10:  CLRF   xCF
09A12:  CLRF   xD0
09A14:  CLRF   xD1
09A16:  CLRF   xD2
09A18:  CLRF   xD3
09A1A:  CLRF   xD4
09A1C:  CLRF   xD5
09A1E:  CLRF   xD6
09A20:  CLRF   xD7
09A22:  CLRF   xD8
09A24:  CLRF   xD9
09A26:  CLRF   xDA
....................     port2.port_num = 2; 
09A28:  MOVLW  02
09A2A:  MOVLB  5
09A2C:  MOVWF  xDB
....................     port2.sweep_step = 0;
09A2E:  CLRF   xDD
09A30:  CLRF   xDC
....................     port2.active = 1;
09A32:  MOVLB  9
09A34:  BSF    xDA.0
.................... 
....................     int16 count = 1;
....................     iv_env_t measured_data = create_meas_data();
09A36:  CLRF   xDC
09A38:  MOVLW  01
09A3A:  MOVWF  xDB
09A3C:  MOVLB  0
09A3E:  GOTO   7CEE
09A42:  MOVFF  02,03
09A46:  MOVF   01,W
09A48:  MOVWF  FE1
09A4A:  MOVFF  03,FE2
09A4E:  MOVLW  09
09A50:  MOVWF  FEA
09A52:  MOVLW  DD
09A54:  MOVWF  FE9
09A56:  MOVLW  0C
09A58:  MOVWF  01
09A5A:  MOVFF  FE6,FEE
09A5E:  DECFSZ 01,F
09A60:  GOTO   9A5A
.................... 
....................     while (port1.active || port2.active)
09A64:  MOVLB  5
09A66:  BTFSS  xDA.0
09A68:  BRA    9A70
09A6A:  MOVLB  0
09A6C:  GOTO   9A80
09A70:  MOVLB  0
09A72:  MOVLB  9
09A74:  BTFSC  xDA.0
09A76:  BRA    9A7E
09A78:  MOVLB  0
09A7A:  GOTO   9CE0
09A7E:  MOVLB  0
....................     {
....................         // 出力設定
....................         if (port1.active) {
09A80:  MOVLB  5
09A82:  BTFSC  xDA.0
09A84:  BRA    9A8C
09A86:  MOVLB  0
09A88:  GOTO   9A9E
09A8C:  MOVLB  0
....................             mcp4901_1_write(count);
09A8E:  MOVFF  9DC,9EA
09A92:  MOVFF  9DB,9E9
09A96:  CALL   2114
....................         } else {
09A9A:  GOTO   9AAA
....................             mcp4901_1_write(0);  // 閾値到達後は0出力
09A9E:  MOVLB  9
09AA0:  CLRF   xEA
09AA2:  CLRF   xE9
09AA4:  MOVLB  0
09AA6:  CALL   2114
....................         }
.................... 
....................         if (port2.active) {
09AAA:  MOVLB  9
09AAC:  BTFSC  xDA.0
09AAE:  BRA    9AB6
09AB0:  MOVLB  0
09AB2:  GOTO   9AC8
09AB6:  MOVLB  0
....................             mcp4901_2_write(count);
09AB8:  MOVFF  9DC,9EA
09ABC:  MOVFF  9DB,9E9
09AC0:  CALL   2156
....................         } else {
09AC4:  GOTO   9AD4
....................             mcp4901_2_write(0);
09AC8:  MOVLB  9
09ACA:  CLRF   xEA
09ACC:  CLRF   xE9
09ACE:  MOVLB  0
09AD0:  CALL   2156
....................         }
.................... 
....................         delay_us(100);
09AD4:  MOVLW  85
09AD6:  MOVWF  00
09AD8:  DECFSZ 00,F
09ADA:  BRA    9AD8
.................... 
....................         // データ取得
....................         if (port1.active) {
09ADC:  MOVLB  5
09ADE:  BTFSC  xDA.0
09AE0:  BRA    9AE8
09AE2:  MOVLB  0
09AE4:  GOTO   9BC6
09AE8:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
09AEA:  BCF    FD8.0
09AEC:  MOVLB  9
09AEE:  RLCF   xDB,W
09AF0:  MOVWF  02
09AF2:  RLCF   xDC,W
09AF4:  MOVWF  03
09AF6:  MOVF   02,W
09AF8:  ADDLW  DE
09AFA:  MOVWF  01
09AFC:  MOVLW  01
09AFE:  ADDWFC 03,F
09B00:  MOVF   01,W
09B02:  MOVWF  xE9
09B04:  MOVFF  03,9EA
09B08:  MOVLW  02
09B0A:  MOVWF  xFB
09B0C:  MOVLB  0
09B0E:  CALL   1DAA
09B12:  MOVFF  9EA,FEA
09B16:  MOVFF  9E9,FE9
09B1A:  MOVFF  02,FEC
09B1E:  MOVF   FED,F
09B20:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
09B24:  BCF    FD8.0
09B26:  MOVLB  9
09B28:  RLCF   xDB,W
09B2A:  MOVWF  02
09B2C:  RLCF   xDC,W
09B2E:  MOVWF  03
09B30:  MOVF   02,W
09B32:  ADDLW  DC
09B34:  MOVWF  01
09B36:  MOVLW  03
09B38:  ADDWFC 03,F
09B3A:  MOVF   01,W
09B3C:  MOVWF  xE9
09B3E:  MOVFF  03,9EA
09B42:  MOVLW  01
09B44:  MOVWF  xFB
09B46:  MOVLB  0
09B48:  CALL   1DAA
09B4C:  MOVFF  9EA,FEA
09B50:  MOVFF  9E9,FE9
09B54:  MOVFF  02,FEC
09B58:  MOVF   FED,F
09B5A:  MOVFF  01,FEF
....................             port1.sweep_step = count + 1;
09B5E:  MOVLW  01
09B60:  MOVLB  9
09B62:  ADDWF  xDB,W
09B64:  MOVLB  1
09B66:  MOVWF  xDC
09B68:  MOVLW  00
09B6A:  MOVLB  9
09B6C:  ADDWFC xDC,W
09B6E:  MOVLB  1
09B70:  MOVWF  xDD
....................             if (port1.data_buffer[1][count] < curr_limit) {
09B72:  BCF    FD8.0
09B74:  MOVLB  9
09B76:  RLCF   xDB,W
09B78:  MOVWF  02
09B7A:  RLCF   xDC,W
09B7C:  MOVWF  03
09B7E:  MOVF   02,W
09B80:  ADDLW  DC
09B82:  MOVWF  FE9
09B84:  MOVLW  03
09B86:  ADDWFC 03,W
09B88:  MOVWF  FEA
09B8A:  MOVFF  FEC,9EA
09B8E:  MOVF   FED,F
09B90:  MOVFF  FEF,9E9
09B94:  MOVF   xEA,W
09B96:  MOVLB  1
09B98:  SUBWF  xDA,W
09B9A:  BTFSC  FD8.0
09B9C:  BRA    9BA4
09B9E:  MOVLB  0
09BA0:  GOTO   9BC6
09BA4:  MOVLB  0
09BA6:  BTFSS  FD8.2
09BA8:  GOTO   9BC0
09BAC:  MOVLB  1
09BAE:  MOVF   xD9,W
09BB0:  MOVLB  9
09BB2:  SUBWF  xE9,W
09BB4:  BTFSS  FD8.0
09BB6:  BRA    9BBE
09BB8:  MOVLB  0
09BBA:  GOTO   9BC6
09BBE:  MOVLB  0
....................                 port1.active = 0;  // 閾値到達で測定終了
09BC0:  MOVLB  5
09BC2:  BCF    xDA.0
09BC4:  MOVLB  0
....................             }
....................         }
.................... 
....................         if (port2.active) {
09BC6:  MOVLB  9
09BC8:  BTFSC  xDA.0
09BCA:  BRA    9BD2
09BCC:  MOVLB  0
09BCE:  GOTO   9CB0
09BD2:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
09BD4:  BCF    FD8.0
09BD6:  MOVLB  9
09BD8:  RLCF   xDB,W
09BDA:  MOVWF  02
09BDC:  RLCF   xDC,W
09BDE:  MOVWF  03
09BE0:  MOVF   02,W
09BE2:  ADDLW  DE
09BE4:  MOVWF  01
09BE6:  MOVLW  05
09BE8:  ADDWFC 03,F
09BEA:  MOVF   01,W
09BEC:  MOVWF  xE9
09BEE:  MOVFF  03,9EA
09BF2:  MOVLW  06
09BF4:  MOVWF  xFB
09BF6:  MOVLB  0
09BF8:  CALL   1DAA
09BFC:  MOVFF  9EA,FEA
09C00:  MOVFF  9E9,FE9
09C04:  MOVFF  02,FEC
09C08:  MOVF   FED,F
09C0A:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
09C0E:  BCF    FD8.0
09C10:  MOVLB  9
09C12:  RLCF   xDB,W
09C14:  MOVWF  02
09C16:  RLCF   xDC,W
09C18:  MOVWF  03
09C1A:  MOVF   02,W
09C1C:  ADDLW  DC
09C1E:  MOVWF  01
09C20:  MOVLW  07
09C22:  ADDWFC 03,F
09C24:  MOVF   01,W
09C26:  MOVWF  xE9
09C28:  MOVFF  03,9EA
09C2C:  MOVLW  05
09C2E:  MOVWF  xFB
09C30:  MOVLB  0
09C32:  CALL   1DAA
09C36:  MOVFF  9EA,FEA
09C3A:  MOVFF  9E9,FE9
09C3E:  MOVFF  02,FEC
09C42:  MOVF   FED,F
09C44:  MOVFF  01,FEF
....................             port2.sweep_step = count + 1;
09C48:  MOVLW  01
09C4A:  MOVLB  9
09C4C:  ADDWF  xDB,W
09C4E:  MOVLB  5
09C50:  MOVWF  xDC
09C52:  MOVLW  00
09C54:  MOVLB  9
09C56:  ADDWFC xDC,W
09C58:  MOVLB  5
09C5A:  MOVWF  xDD
....................             if (port2.data_buffer[1][count] < curr_limit) {
09C5C:  BCF    FD8.0
09C5E:  MOVLB  9
09C60:  RLCF   xDB,W
09C62:  MOVWF  02
09C64:  RLCF   xDC,W
09C66:  MOVWF  03
09C68:  MOVF   02,W
09C6A:  ADDLW  DC
09C6C:  MOVWF  FE9
09C6E:  MOVLW  07
09C70:  ADDWFC 03,W
09C72:  MOVWF  FEA
09C74:  MOVFF  FEC,9EA
09C78:  MOVF   FED,F
09C7A:  MOVFF  FEF,9E9
09C7E:  MOVF   xEA,W
09C80:  MOVLB  1
09C82:  SUBWF  xDA,W
09C84:  BTFSC  FD8.0
09C86:  BRA    9C8E
09C88:  MOVLB  0
09C8A:  GOTO   9CB0
09C8E:  MOVLB  0
09C90:  BTFSS  FD8.2
09C92:  GOTO   9CAA
09C96:  MOVLB  1
09C98:  MOVF   xD9,W
09C9A:  MOVLB  9
09C9C:  SUBWF  xE9,W
09C9E:  BTFSS  FD8.0
09CA0:  BRA    9CA8
09CA2:  MOVLB  0
09CA4:  GOTO   9CB0
09CA8:  MOVLB  0
....................                 port2.active = 0;
09CAA:  MOVLB  9
09CAC:  BCF    xDA.0
09CAE:  MOVLB  0
....................             }
....................         }
.................... 
....................         count++;
09CB0:  MOVLB  9
09CB2:  INCF   xDB,F
09CB4:  BTFSC  FD8.2
09CB6:  INCF   xDC,F
....................         if (count >= 255) {
09CB8:  MOVF   xDC,F
09CBA:  BTFSC  FD8.2
09CBC:  BRA    9CC4
09CBE:  MOVLB  0
09CC0:  GOTO   9CD8
09CC4:  MOVLB  0
09CC6:  MOVLB  9
09CC8:  MOVF   xDB,W
09CCA:  SUBLW  FE
09CCC:  BTFSS  FD8.0
09CCE:  BRA    9CD6
09CD0:  MOVLB  0
09CD2:  GOTO   9CDC
09CD6:  MOVLB  0
....................             break;
09CD8:  GOTO   9CE0
....................         }
09CDC:  GOTO   9A64
....................     }
.................... 
....................     fprintf(PC, "sweep step : %04LX\r\n", count);
09CE0:  MOVLW  14
09CE2:  MOVWF  FF6
09CE4:  MOVLW  05
09CE6:  MOVWF  FF7
09CE8:  MOVLW  00
09CEA:  MOVWF  FF8
09CEC:  MOVLW  0D
09CEE:  MOVLB  9
09CF0:  MOVWF  xE9
09CF2:  MOVLB  0
09CF4:  CALL   1C2C
09CF8:  MOVFF  9DC,A48
09CFC:  MOVLW  37
09CFE:  MOVLB  A
09D00:  MOVWF  x49
09D02:  MOVLB  0
09D04:  CALL   1E3C
09D08:  MOVFF  9DB,A48
09D0C:  MOVLW  37
09D0E:  MOVLB  A
09D10:  MOVWF  x49
09D12:  MOVLB  0
09D14:  CALL   1E3C
09D18:  MOVLW  0D
09D1A:  BTFSS  FA6.6
09D1C:  GOTO   9D1A
09D20:  MOVLB  E
09D22:  MOVWF  xF9
09D24:  MOVLW  0A
09D26:  MOVLB  0
09D28:  BTFSS  FA6.6
09D2A:  GOTO   9D28
09D2E:  MOVLB  E
09D30:  MOVWF  xF9
.................... 
....................     // 接続は維持
....................     fprintf(PC, "port1\r\n");
09D32:  MOVLW  2A
09D34:  MOVWF  FF6
09D36:  MOVLW  05
09D38:  MOVWF  FF7
09D3A:  MOVLW  00
09D3C:  MOVWF  FF8
09D3E:  MOVLB  0
09D40:  CALL   1BF6
....................     log_meas_data_with_print(&measured_data, &port1);
09D44:  MOVLW  09
09D46:  MOVLB  9
09D48:  MOVWF  xEA
09D4A:  MOVLW  DD
09D4C:  MOVWF  xE9
09D4E:  MOVLW  01
09D50:  MOVWF  xEC
09D52:  MOVLW  DB
09D54:  MOVWF  xEB
09D56:  MOVLB  0
09D58:  CALL   7D72
....................     fprintf(PC, "port2\r\n");
09D5C:  MOVLW  32
09D5E:  MOVWF  FF6
09D60:  MOVLW  05
09D62:  MOVWF  FF7
09D64:  MOVLW  00
09D66:  MOVWF  FF8
09D68:  CALL   1BF6
....................     log_meas_data_with_print(&measured_data, &port2);
09D6C:  MOVLW  09
09D6E:  MOVLB  9
09D70:  MOVWF  xEA
09D72:  MOVLW  DD
09D74:  MOVWF  xE9
09D76:  MOVLW  05
09D78:  MOVWF  xEC
09D7A:  MOVLW  DB
09D7C:  MOVWF  xEB
09D7E:  MOVLB  0
09D80:  CALL   7D72
09D84:  GOTO   9F8A (RETURN)
.................... }
.................... 
.................... 
.................... void sweep(  unsigned int16 curr_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, ".");
....................    
....................     // Enable both CIGS ports
....................     connect_port1();
....................     connect_port2();
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     sweep_config_t port1 = {0};
....................     port1.port_num = 1;
....................     port1.sweep_step = 0;
....................     port1.active = 1;
.................... 
....................     // Init Port2
....................     sweep_config_t port2 = {0};
....................     port2.port_num = 2;
....................     port2.sweep_step = 0;
....................     port2.active = 1;
.................... 
....................     int16 count = 0;
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
....................     mcp4901_2_write(1);
.................... 
....................     iv_env_t measured_data = create_meas_data();
....................     while (port1.active || port2.active)
....................     {
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         delay_us(10); 
....................         if (port1.active) {
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
....................         }
....................         if (port2.active) {
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................             // fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
....................         }
....................         count++;
....................         if (count >= 255) {
....................             // fprintf(PC, "Maximum step count reached: %ld\r\n", count);
....................             break;
....................         }
....................         if (port1.active) {
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
....................                 // fprintf(PC, "CIGS1 current limit reached:");
....................                 port1.active = 0;
....................                 disconnect_port1(); // Disconnect CIGS1
....................             }
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
....................                 // fprintf(PC, "CIGS1 current below threshold");
....................                 port1.active = 0;
....................                 disconnect_port1();
....................             }
....................         }
....................         if (port2.active) {
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
....................                 // fprintf(PC, "CIGS2 current limit reached: ");
....................                 port2.active = 0;
....................                 disconnect_port2();
....................             }
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
....................                 // fprintf(PC, "CIGS2 current below threshold:");
....................                 port2.active = 0;
....................                 disconnect_port2();
....................             }
....................         }
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     disconnect_port1();
....................     disconnect_port2();
....................     log_meas_data(&measured_data, &port1);
....................     log_meas_data(&measured_data, &port2);
.................... }
.................... 
.................... 
.................... void log_meas_data(iv_env_t *measured_data_ptr, sweep_config_t *port_data_ptr)
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; 
....................     unsigned int8 packetdata_index = 0;
.................... 
....................     /*
....................     // Header creation
....................     packetdata[0] = START_MAKER;
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data_ptr->port_num & 0x0F);
....................     packetdata[2] = measured_data_ptr->time >> 24 & 0xFF;
....................     packetdata[3] = measured_data_ptr->time >> 16 & 0xFF;
....................     packetdata[4] = measured_data_ptr->time >> 8 & 0xFF;
....................     packetdata[5] = measured_data_ptr->time_sec & 0xFF;
....................     packetdata[6] = (measured_data_ptr->time_msec & 0x0F) >>4 | measured_data_ptr->pd >> 8 & 0x0F;
....................     packetdata[7] = measured_data_ptr->pd & 0xFF;
....................     packetdata[8] = (measured_data_ptr->open_voltage >> 4) & 0xFF; // PD start low byte
....................     packetdata[9] = (measured_data_ptr->open_voltage & 0x0F) << 4 | (measured_data_ptr->temp_py_top >> 8) & 0x0F;
....................     packetdata[10] = measured_data_ptr->temp_py_top & 0xFF;
....................     packetdata[11] = (measured_data_ptr->temp_py_bot >> 4) & 0xFF; // PD start low byte
....................     packetdata[12] = (measured_data_ptr->temp_py_bot & 0x0F) << 4 | (measured_data_ptr->temp_mis7 >> 8) & 0x0F;
....................     packetdata[13] = measured_data_ptr->temp_mis7 & 0xFF;
....................     */
....................     packetdata_index = 14; // Start index for data
.................... 
....................     for (unsigned int16 i = 0; i < port_data_ptr->sweep_step ; i++) {
....................         unsigned int16 data0 = port_data_ptr->data_buffer[0][i];
....................         unsigned int16 data1 = port_data_ptr->data_buffer[1][i];
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
....................         packetdata[packetdata_index++] = data1 & 0xFF;
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
....................            unsigned int32 write_address;
....................             
....................             switch (port_data_ptr -> port_num) {
....................                 case 1:
....................                     write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................                     iv1_data_ptr->used_counter += PACKET_SIZE;
....................                     iv1_data_ptr->uncopied_counter += PACKET_SIZE;
....................                     break;
....................                 case 2:
....................                     write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................                     iv2_data_ptr->used_counter += PACKET_SIZE;
....................                     iv2_data_ptr->uncopied_counter += PACKET_SIZE;
....................                     break;
....................                 default:
....................                     break;
....................             }
....................             packetdata_index = 0;
....................             memset(packetdata, 0x00, PACKET_SIZE);
....................         }
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
....................             packetdata[j] = 0x00;
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
....................       unsigned int32 write_address;
....................         switch (port_data_ptr->port_num)
....................         {
....................         case 1:
....................             write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................             iv1_data_ptr->used_counter += PACKET_SIZE;
....................             iv1_data_ptr->uncopied_counter += PACKET_SIZE;
....................             break;
....................         case 2:
....................          write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................             iv2_data_ptr->used_counter += PACKET_SIZE;
....................             iv2_data_ptr->uncopied_counter += PACKET_SIZE;
....................             break;
....................         default:
....................             break;
....................         }
.................... 
....................     }
....................     // fprintf(PC, "End CIGS data conversion\r\n");
....................     write_misf_address_area(); // Write the mission flash address area
.................... }
.................... 
.................... void log_meas_data_with_print(iv_env_t *measured_data_ptr, sweep_config_t *port_data_ptr)
*
07DF6:  CLRF   x2D
07DF8:  BSF    x2E.0
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; 
*
07D72:  MOVLB  9
07D74:  CLRF   xED
07D76:  CLRF   xEE
07D78:  CLRF   xEF
07D7A:  CLRF   xF0
07D7C:  CLRF   xF1
07D7E:  CLRF   xF2
07D80:  CLRF   xF3
07D82:  CLRF   xF4
07D84:  CLRF   xF5
07D86:  CLRF   xF6
07D88:  CLRF   xF7
07D8A:  CLRF   xF8
07D8C:  CLRF   xF9
07D8E:  CLRF   xFA
07D90:  CLRF   xFB
07D92:  CLRF   xFC
07D94:  CLRF   xFD
07D96:  CLRF   xFE
07D98:  CLRF   xFF
07D9A:  MOVLB  A
07D9C:  CLRF   x00
07D9E:  CLRF   x01
07DA0:  CLRF   x02
07DA2:  CLRF   x03
07DA4:  CLRF   x04
07DA6:  CLRF   x05
07DA8:  CLRF   x06
07DAA:  CLRF   x07
07DAC:  CLRF   x08
07DAE:  CLRF   x09
07DB0:  CLRF   x0A
07DB2:  CLRF   x0B
07DB4:  CLRF   x0C
07DB6:  CLRF   x0D
07DB8:  CLRF   x0E
07DBA:  CLRF   x0F
07DBC:  CLRF   x10
07DBE:  CLRF   x11
07DC0:  CLRF   x12
07DC2:  CLRF   x13
07DC4:  CLRF   x14
07DC6:  CLRF   x15
07DC8:  CLRF   x16
07DCA:  CLRF   x17
07DCC:  CLRF   x18
07DCE:  CLRF   x19
07DD0:  CLRF   x1A
07DD2:  CLRF   x1B
07DD4:  CLRF   x1C
07DD6:  CLRF   x1D
07DD8:  CLRF   x1E
07DDA:  CLRF   x1F
07DDC:  CLRF   x20
07DDE:  CLRF   x21
07DE0:  CLRF   x22
07DE2:  CLRF   x23
07DE4:  CLRF   x24
07DE6:  CLRF   x25
07DE8:  CLRF   x26
07DEA:  CLRF   x27
07DEC:  CLRF   x28
07DEE:  CLRF   x29
07DF0:  CLRF   x2A
07DF2:  CLRF   x2B
07DF4:  CLRF   x2C
....................     unsigned int8 packetdata_index = 0;
....................     int1 first_packet = true; // 最初のパケットフラグ
.................... 
....................     // ==== データステップ書き込み ====
....................     for (unsigned int16 i = 0; i < port_data_ptr->sweep_step; i++) {
*
07DFA:  CLRF   x30
07DFC:  CLRF   x2F
07DFE:  MOVLB  0
07E00:  MOVLW  01
07E02:  MOVLB  9
07E04:  ADDWF  xEB,W
07E06:  MOVWF  FE9
07E08:  MOVLW  00
07E0A:  ADDWFC xEC,W
07E0C:  MOVWF  FEA
07E0E:  MOVFF  FEC,03
07E12:  MOVF   FED,F
07E14:  MOVF   FEF,W
07E16:  MOVWF  01
07E18:  MOVLB  A
07E1A:  MOVF   x30,W
07E1C:  SUBWF  03,W
07E1E:  BTFSC  FD8.0
07E20:  BRA    7E28
07E22:  MOVLB  0
07E24:  GOTO   86A8
07E28:  MOVLB  0
07E2A:  BTFSS  FD8.2
07E2C:  GOTO   7E42
07E30:  MOVF   01,W
07E32:  MOVLB  A
07E34:  SUBWF  x2F,W
07E36:  BTFSS  FD8.0
07E38:  BRA    7E40
07E3A:  MOVLB  0
07E3C:  GOTO   86A8
07E40:  MOVLB  0
....................         unsigned int16 data0 = port_data_ptr->data_buffer[0][i];
....................         unsigned int16 data1 = port_data_ptr->data_buffer[1][i];
07E42:  BCF    FD8.0
07E44:  MOVLB  A
07E46:  RLCF   x2F,W
07E48:  MOVWF  02
07E4A:  RLCF   x30,W
07E4C:  MOVWF  03
07E4E:  MOVF   02,W
07E50:  ADDLW  03
07E52:  MOVWF  01
07E54:  MOVLW  00
07E56:  ADDWFC 03,F
07E58:  MOVF   01,W
07E5A:  MOVLB  9
07E5C:  ADDWF  xEB,W
07E5E:  MOVWF  FE9
07E60:  MOVF   xEC,W
07E62:  ADDWFC 03,W
07E64:  MOVWF  FEA
07E66:  MOVFF  FEC,A32
07E6A:  MOVF   FED,F
07E6C:  MOVFF  FEF,A31
07E70:  BCF    FD8.0
07E72:  MOVLB  A
07E74:  RLCF   x2F,W
07E76:  MOVWF  02
07E78:  RLCF   x30,W
07E7A:  MOVWF  03
07E7C:  MOVF   02,W
07E7E:  ADDLW  01
07E80:  MOVWF  01
07E82:  MOVLW  02
07E84:  ADDWFC 03,F
07E86:  MOVF   01,W
07E88:  MOVLB  9
07E8A:  ADDWF  xEB,W
07E8C:  MOVWF  FE9
07E8E:  MOVF   xEC,W
07E90:  ADDWFC 03,W
07E92:  MOVWF  FEA
07E94:  MOVFF  FEC,A34
07E98:  MOVF   FED,F
07E9A:  MOVFF  FEF,A33
07E9E:  MOVLB  0
.................... 
....................         // パケットがいっぱいになる前にヘッダ＋環境データを入れる
....................         if (packetdata_index == 0) {
07EA0:  MOVLB  A
07EA2:  MOVF   x2D,F
07EA4:  BTFSC  FD8.2
07EA6:  BRA    7EAE
07EA8:  MOVLB  0
07EAA:  GOTO   82F4
07EAE:  MOVLB  0
....................             unsigned int8 idx = 0;
07EB0:  MOVLB  A
07EB2:  CLRF   x35
07EB4:  MOVLB  0
....................             if (first_packet) {
07EB6:  MOVLB  A
07EB8:  BTFSC  x2E.0
07EBA:  BRA    7EC2
07EBC:  MOVLB  0
07EBE:  GOTO   7EDC
07EC2:  MOVLB  0
....................                 packetdata[idx++] = START_MAKER;  // 最初のパケットだけ
07EC4:  MOVLB  A
07EC6:  MOVF   x35,W
07EC8:  INCF   x35,F
07ECA:  CLRF   03
07ECC:  ADDLW  ED
07ECE:  MOVWF  FE9
07ED0:  MOVLW  09
07ED2:  ADDWFC 03,W
07ED4:  MOVWF  FEA
07ED6:  SETF   FEF
....................                 first_packet = false;
07ED8:  BCF    x2E.0
07EDA:  MOVLB  0
....................             }
.................... 
....................             // timeヘッダ
....................             packetdata[idx++] = (measured_data_ptr->time >> 24) & 0xFF;
07EDC:  MOVLB  A
07EDE:  MOVF   x35,W
07EE0:  INCF   x35,F
07EE2:  CLRF   03
07EE4:  ADDLW  ED
07EE6:  MOVWF  01
07EE8:  MOVLW  09
07EEA:  ADDWFC 03,F
07EEC:  MOVF   01,W
07EEE:  MOVWF  x47
07EF0:  MOVFF  03,A48
07EF4:  MOVLB  9
07EF6:  MOVF   xE9,W
07EF8:  MOVWF  FE9
07EFA:  MOVF   xEA,W
07EFC:  MOVWF  FEA
07EFE:  MOVFF  FEF,A49
07F02:  MOVFF  FEC,A4A
07F06:  MOVFF  FEC,A4B
07F0A:  MOVFF  FEC,A4C
07F0E:  MOVF   FED,F
07F10:  MOVF   FED,F
07F12:  MOVF   FED,F
07F14:  MOVFF  A4C,A49
07F18:  MOVLB  A
07F1A:  CLRF   x4A
07F1C:  CLRF   x4B
07F1E:  CLRF   x4C
07F20:  MOVF   x49,W
07F22:  MOVWF  00
07F24:  CLRF   01
07F26:  CLRF   02
07F28:  CLRF   03
07F2A:  MOVFF  03,A4C
07F2E:  MOVFF  02,A4B
07F32:  MOVFF  01,A4A
07F36:  MOVFF  00,A49
07F3A:  MOVFF  A48,FEA
07F3E:  MOVFF  A47,FE9
07F42:  MOVFF  A49,FEF
....................             packetdata[idx++] = (measured_data_ptr->time >> 16) & 0xFF;
07F46:  MOVF   x35,W
07F48:  INCF   x35,F
07F4A:  CLRF   03
07F4C:  ADDLW  ED
07F4E:  MOVWF  01
07F50:  MOVLW  09
07F52:  ADDWFC 03,F
07F54:  MOVF   01,W
07F56:  MOVWF  x47
07F58:  MOVFF  03,A48
07F5C:  MOVLB  9
07F5E:  MOVF   xE9,W
07F60:  MOVWF  FE9
07F62:  MOVF   xEA,W
07F64:  MOVWF  FEA
07F66:  MOVFF  FEF,A49
07F6A:  MOVFF  FEC,A4A
07F6E:  MOVFF  FEC,A4B
07F72:  MOVFF  FEC,A4C
07F76:  MOVF   FED,F
07F78:  MOVF   FED,F
07F7A:  MOVF   FED,F
07F7C:  MOVFF  A4B,A49
07F80:  MOVFF  A4C,A4A
07F84:  MOVLB  A
07F86:  CLRF   x4B
07F88:  CLRF   x4C
07F8A:  MOVF   x49,W
07F8C:  MOVWF  00
07F8E:  CLRF   01
07F90:  CLRF   02
07F92:  CLRF   03
07F94:  MOVFF  03,A4C
07F98:  MOVFF  02,A4B
07F9C:  MOVFF  01,A4A
07FA0:  MOVFF  00,A49
07FA4:  MOVFF  A48,FEA
07FA8:  MOVFF  A47,FE9
07FAC:  MOVFF  A49,FEF
....................             packetdata[idx++] = (measured_data_ptr->time >> 8) & 0xFF;
07FB0:  MOVF   x35,W
07FB2:  INCF   x35,F
07FB4:  CLRF   03
07FB6:  ADDLW  ED
07FB8:  MOVWF  01
07FBA:  MOVLW  09
07FBC:  ADDWFC 03,F
07FBE:  MOVF   01,W
07FC0:  MOVWF  x47
07FC2:  MOVFF  03,A48
07FC6:  MOVLB  9
07FC8:  MOVF   xE9,W
07FCA:  MOVWF  FE9
07FCC:  MOVF   xEA,W
07FCE:  MOVWF  FEA
07FD0:  MOVFF  FEF,A49
07FD4:  MOVFF  FEC,A4A
07FD8:  MOVFF  FEC,A4B
07FDC:  MOVFF  FEC,A4C
07FE0:  MOVF   FED,F
07FE2:  MOVF   FED,F
07FE4:  MOVF   FED,F
07FE6:  MOVFF  A4A,A49
07FEA:  MOVFF  A4B,A4A
07FEE:  MOVFF  A4C,A4B
07FF2:  MOVLB  A
07FF4:  CLRF   x4C
07FF6:  MOVF   x49,W
07FF8:  MOVWF  00
07FFA:  CLRF   01
07FFC:  CLRF   02
07FFE:  CLRF   03
08000:  MOVFF  03,A4C
08004:  MOVFF  02,A4B
08008:  MOVFF  01,A4A
0800C:  MOVFF  00,A49
08010:  MOVFF  A48,FEA
08014:  MOVFF  A47,FE9
08018:  MOVFF  A49,FEF
....................             packetdata[idx++] = measured_data_ptr->time & 0xFF;
0801C:  MOVF   x35,W
0801E:  INCF   x35,F
08020:  CLRF   03
08022:  ADDLW  ED
08024:  MOVWF  01
08026:  MOVLW  09
08028:  ADDWFC 03,F
0802A:  MOVF   01,W
0802C:  MOVWF  x47
0802E:  MOVFF  03,A48
08032:  MOVLB  9
08034:  MOVF   xE9,W
08036:  MOVWF  FE9
08038:  MOVF   xEA,W
0803A:  MOVWF  FEA
0803C:  MOVFF  FEF,A49
08040:  MOVFF  FEC,A4A
08044:  MOVFF  FEC,A4B
08048:  MOVFF  FEC,A4C
0804C:  MOVF   FED,F
0804E:  MOVF   FED,F
08050:  MOVF   FED,F
08052:  MOVLB  A
08054:  MOVF   x49,W
08056:  MOVWF  00
08058:  CLRF   01
0805A:  CLRF   02
0805C:  CLRF   03
0805E:  MOVFF  03,A4C
08062:  MOVFF  02,A4B
08066:  MOVFF  01,A4A
0806A:  MOVFF  00,A49
0806E:  MOVFF  A48,FEA
08072:  MOVFF  A47,FE9
08076:  MOVFF  A49,FEF
.................... 
....................             // 環境データ
....................             packetdata[idx++] = (measured_data_ptr->pd >> 4) & 0xFF;
0807A:  MOVF   x35,W
0807C:  INCF   x35,F
0807E:  CLRF   03
08080:  ADDLW  ED
08082:  MOVWF  01
08084:  MOVLW  09
08086:  ADDWFC 03,F
08088:  MOVF   01,W
0808A:  MOVWF  x47
0808C:  MOVFF  03,A48
08090:  MOVLW  04
08092:  MOVLB  9
08094:  ADDWF  xE9,W
08096:  MOVWF  FE9
08098:  MOVLW  00
0809A:  ADDWFC xEA,W
0809C:  MOVWF  FEA
0809E:  MOVFF  FEC,A4A
080A2:  MOVF   FED,F
080A4:  MOVFF  FEF,A49
080A8:  MOVLB  A
080AA:  RRCF   x4A,F
080AC:  RRCF   x49,F
080AE:  RRCF   x4A,F
080B0:  RRCF   x49,F
080B2:  RRCF   x4A,F
080B4:  RRCF   x49,F
080B6:  RRCF   x4A,F
080B8:  RRCF   x49,F
080BA:  MOVLW  0F
080BC:  ANDWF  x4A,F
080BE:  MOVF   x49,W
080C0:  MOVWF  00
080C2:  CLRF   03
080C4:  MOVF   00,W
080C6:  MOVWF  x49
080C8:  MOVFF  03,A4A
080CC:  MOVFF  A48,FEA
080D0:  MOVFF  A47,FE9
080D4:  MOVFF  A49,FEF
....................             packetdata[idx++] = ((measured_data_ptr->pd & 0x0F) << 4) | ((measured_data_ptr->temp_py_top >> 8) & 0x0F);
080D8:  MOVF   x35,W
080DA:  INCF   x35,F
080DC:  CLRF   03
080DE:  ADDLW  ED
080E0:  MOVWF  01
080E2:  MOVLW  09
080E4:  ADDWFC 03,F
080E6:  MOVF   01,W
080E8:  MOVWF  x47
080EA:  MOVFF  03,A48
080EE:  MOVLW  04
080F0:  MOVLB  9
080F2:  ADDWF  xE9,W
080F4:  MOVWF  FE9
080F6:  MOVLW  00
080F8:  ADDWFC xEA,W
080FA:  MOVWF  FEA
080FC:  MOVFF  FEC,A4A
08100:  MOVF   FED,F
08102:  MOVFF  FEF,A49
08106:  MOVLW  0F
08108:  MOVLB  A
0810A:  ANDWF  x49,F
0810C:  CLRF   x4A
0810E:  RLCF   x49,F
08110:  RLCF   x4A,F
08112:  RLCF   x49,F
08114:  RLCF   x4A,F
08116:  RLCF   x49,F
08118:  RLCF   x4A,F
0811A:  RLCF   x49,F
0811C:  RLCF   x4A,F
0811E:  MOVLW  F0
08120:  ANDWF  x49,F
08122:  MOVLW  06
08124:  MOVLB  9
08126:  ADDWF  xE9,W
08128:  MOVWF  FE9
0812A:  MOVLW  00
0812C:  ADDWFC xEA,W
0812E:  MOVWF  FEA
08130:  MOVFF  FEC,A4C
08134:  MOVF   FED,F
08136:  MOVFF  FEF,A4B
0813A:  MOVFF  A4C,A4B
0813E:  MOVLB  A
08140:  CLRF   x4C
08142:  MOVF   x4B,W
08144:  ANDLW  0F
08146:  MOVWF  00
08148:  CLRF   03
0814A:  MOVF   00,W
0814C:  IORWF  x49,W
0814E:  MOVWF  00
08150:  MOVF   03,W
08152:  IORWF  x4A,W
08154:  MOVWF  03
08156:  MOVF   00,W
08158:  MOVWF  x49
0815A:  MOVFF  03,A4A
0815E:  MOVFF  A48,FEA
08162:  MOVFF  A47,FE9
08166:  MOVFF  A49,FEF
....................             packetdata[idx++] = measured_data_ptr->temp_py_top & 0xFF;
0816A:  MOVF   x35,W
0816C:  INCF   x35,F
0816E:  CLRF   03
08170:  ADDLW  ED
08172:  MOVWF  01
08174:  MOVLW  09
08176:  ADDWFC 03,F
08178:  MOVF   01,W
0817A:  MOVWF  x47
0817C:  MOVFF  03,A48
08180:  MOVLW  06
08182:  MOVLB  9
08184:  ADDWF  xE9,W
08186:  MOVWF  FE9
08188:  MOVLW  00
0818A:  ADDWFC xEA,W
0818C:  MOVWF  FEA
0818E:  MOVFF  FEC,A4A
08192:  MOVF   FED,F
08194:  MOVFF  FEF,A49
08198:  MOVLB  A
0819A:  MOVF   x49,W
0819C:  MOVWF  00
0819E:  CLRF   03
081A0:  MOVF   00,W
081A2:  MOVWF  x49
081A4:  MOVFF  03,A4A
081A8:  MOVFF  A48,FEA
081AC:  MOVFF  A47,FE9
081B0:  MOVFF  A49,FEF
....................             packetdata[idx++] = (measured_data_ptr->temp_py_bot >> 4) & 0xFF;
081B4:  MOVF   x35,W
081B6:  INCF   x35,F
081B8:  CLRF   03
081BA:  ADDLW  ED
081BC:  MOVWF  01
081BE:  MOVLW  09
081C0:  ADDWFC 03,F
081C2:  MOVF   01,W
081C4:  MOVWF  x47
081C6:  MOVFF  03,A48
081CA:  MOVLW  08
081CC:  MOVLB  9
081CE:  ADDWF  xE9,W
081D0:  MOVWF  FE9
081D2:  MOVLW  00
081D4:  ADDWFC xEA,W
081D6:  MOVWF  FEA
081D8:  MOVFF  FEC,A4A
081DC:  MOVF   FED,F
081DE:  MOVFF  FEF,A49
081E2:  MOVLB  A
081E4:  RRCF   x4A,F
081E6:  RRCF   x49,F
081E8:  RRCF   x4A,F
081EA:  RRCF   x49,F
081EC:  RRCF   x4A,F
081EE:  RRCF   x49,F
081F0:  RRCF   x4A,F
081F2:  RRCF   x49,F
081F4:  MOVLW  0F
081F6:  ANDWF  x4A,F
081F8:  MOVF   x49,W
081FA:  MOVWF  00
081FC:  CLRF   03
081FE:  MOVF   00,W
08200:  MOVWF  x49
08202:  MOVFF  03,A4A
08206:  MOVFF  A48,FEA
0820A:  MOVFF  A47,FE9
0820E:  MOVFF  A49,FEF
....................             packetdata[idx++] = ((measured_data_ptr->temp_py_bot & 0x0F) << 4) | ((measured_data_ptr->temp_mis7 >> 8) & 0x0F);
08212:  MOVF   x35,W
08214:  INCF   x35,F
08216:  CLRF   03
08218:  ADDLW  ED
0821A:  MOVWF  01
0821C:  MOVLW  09
0821E:  ADDWFC 03,F
08220:  MOVF   01,W
08222:  MOVWF  x47
08224:  MOVFF  03,A48
08228:  MOVLW  08
0822A:  MOVLB  9
0822C:  ADDWF  xE9,W
0822E:  MOVWF  FE9
08230:  MOVLW  00
08232:  ADDWFC xEA,W
08234:  MOVWF  FEA
08236:  MOVFF  FEC,A4A
0823A:  MOVF   FED,F
0823C:  MOVFF  FEF,A49
08240:  MOVLW  0F
08242:  MOVLB  A
08244:  ANDWF  x49,F
08246:  CLRF   x4A
08248:  RLCF   x49,F
0824A:  RLCF   x4A,F
0824C:  RLCF   x49,F
0824E:  RLCF   x4A,F
08250:  RLCF   x49,F
08252:  RLCF   x4A,F
08254:  RLCF   x49,F
08256:  RLCF   x4A,F
08258:  MOVLW  F0
0825A:  ANDWF  x49,F
0825C:  MOVLW  0A
0825E:  MOVLB  9
08260:  ADDWF  xE9,W
08262:  MOVWF  FE9
08264:  MOVLW  00
08266:  ADDWFC xEA,W
08268:  MOVWF  FEA
0826A:  MOVFF  FEC,A4C
0826E:  MOVF   FED,F
08270:  MOVFF  FEF,A4B
08274:  MOVFF  A4C,A4B
08278:  MOVLB  A
0827A:  CLRF   x4C
0827C:  MOVF   x4B,W
0827E:  ANDLW  0F
08280:  MOVWF  00
08282:  CLRF   03
08284:  MOVF   00,W
08286:  IORWF  x49,W
08288:  MOVWF  00
0828A:  MOVF   03,W
0828C:  IORWF  x4A,W
0828E:  MOVWF  03
08290:  MOVF   00,W
08292:  MOVWF  x49
08294:  MOVFF  03,A4A
08298:  MOVFF  A48,FEA
0829C:  MOVFF  A47,FE9
082A0:  MOVFF  A49,FEF
....................             packetdata[idx++] = measured_data_ptr->temp_mis7 & 0xFF;
082A4:  MOVF   x35,W
082A6:  INCF   x35,F
082A8:  CLRF   03
082AA:  ADDLW  ED
082AC:  MOVWF  01
082AE:  MOVLW  09
082B0:  ADDWFC 03,F
082B2:  MOVF   01,W
082B4:  MOVWF  x47
082B6:  MOVFF  03,A48
082BA:  MOVLW  0A
082BC:  MOVLB  9
082BE:  ADDWF  xE9,W
082C0:  MOVWF  FE9
082C2:  MOVLW  00
082C4:  ADDWFC xEA,W
082C6:  MOVWF  FEA
082C8:  MOVFF  FEC,A4A
082CC:  MOVF   FED,F
082CE:  MOVFF  FEF,A49
082D2:  MOVLB  A
082D4:  MOVF   x49,W
082D6:  MOVWF  00
082D8:  CLRF   03
082DA:  MOVF   00,W
082DC:  MOVWF  x49
082DE:  MOVFF  03,A4A
082E2:  MOVFF  A48,FEA
082E6:  MOVFF  A47,FE9
082EA:  MOVFF  A49,FEF
.................... 
....................             packetdata_index = idx;
082EE:  MOVFF  A35,A2D
082F2:  MOVLB  0
....................         }
.................... 
....................         // パケットに収まるかチェック
....................         if (packetdata_index + DATA_SIZE_PER_STEP >= PACKET_SIZE) {
082F4:  MOVLW  03
082F6:  MOVLB  A
082F8:  ADDWF  x2D,W
082FA:  SUBLW  3F
082FC:  BTFSS  FD8.0
082FE:  BRA    8306
08300:  MOVLB  0
08302:  GOTO   8600
08306:  MOVLB  0
....................             // CRC 計算
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
08308:  MOVLW  09
0830A:  MOVLB  A
0830C:  MOVWF  xEB
0830E:  MOVLW  ED
08310:  MOVWF  xEA
08312:  MOVLW  3F
08314:  MOVWF  xEC
08316:  MOVLB  0
08318:  CALL   29E8
0831C:  MOVFF  01,A2C
.................... 
....................             // フラッシュ書き込み
....................             unsigned int32 write_address = MISF_CIGS_IV_DATA_START;
08320:  MOVLB  A
08322:  CLRF   x39
08324:  MOVLW  7C
08326:  MOVWF  x38
08328:  MOVLW  10
0832A:  MOVWF  x37
0832C:  CLRF   x36
....................             switch (port_data_ptr->port_num) {
0832E:  MOVLB  9
08330:  MOVF   xEB,W
08332:  MOVWF  FE9
08334:  MOVF   xEC,W
08336:  MOVWF  FEA
08338:  MOVF   FEF,W
0833A:  XORLW  01
0833C:  MOVLB  0
0833E:  BTFSC  FD8.2
08340:  GOTO   8350
08344:  XORLW  03
08346:  BTFSC  FD8.2
08348:  GOTO   8442
0834C:  GOTO   8534
....................                 case 1:
....................                     write_address += iv1_data_ptr->used_counter;
08350:  MOVLW  01
08352:  MOVLB  1
08354:  ADDWF  x2A,W
08356:  MOVWF  FE9
08358:  MOVLW  00
0835A:  ADDWFC x2B,W
0835C:  MOVWF  FEA
0835E:  MOVFF  FEF,00
08362:  MOVFF  FEC,01
08366:  MOVFF  FEC,02
0836A:  MOVFF  FEC,03
0836E:  MOVF   FED,F
08370:  MOVF   FED,F
08372:  MOVF   FED,F
08374:  MOVF   00,W
08376:  MOVLB  A
08378:  ADDWF  x36,F
0837A:  MOVF   01,W
0837C:  ADDWFC x37,F
0837E:  MOVF   02,W
08380:  ADDWFC x38,F
08382:  MOVF   03,W
08384:  ADDWFC x39,F
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
08386:  MOVFF  115,A8E
0838A:  MOVFF  114,A8D
0838E:  MOVFF  113,A8C
08392:  MOVFF  112,A8B
08396:  MOVFF  A39,A92
0839A:  MOVFF  A38,A91
0839E:  MOVFF  A37,A90
083A2:  MOVFF  A36,A8F
083A6:  MOVLW  09
083A8:  MOVWF  x94
083AA:  MOVLW  ED
083AC:  MOVWF  x93
083AE:  CLRF   x96
083B0:  MOVLW  40
083B2:  MOVWF  x95
083B4:  MOVLB  0
083B6:  CALL   3EC0
....................                     iv1_data_ptr->used_counter += PACKET_SIZE;
083BA:  MOVLW  01
083BC:  MOVLB  1
083BE:  ADDWF  x2A,W
083C0:  MOVWF  FE9
083C2:  MOVLW  00
083C4:  ADDWFC x2B,W
083C6:  MOVWF  FEA
083C8:  MOVLW  40
083CA:  ADDWF  FEF,W
083CC:  MOVWF  00
083CE:  MOVLW  00
083D0:  ADDWFC FEC,W
083D2:  MOVWF  01
083D4:  MOVLW  00
083D6:  ADDWFC FEC,W
083D8:  MOVWF  02
083DA:  MOVLW  00
083DC:  ADDWFC FEC,W
083DE:  MOVWF  03
083E0:  MOVF   FED,F
083E2:  MOVF   FED,F
083E4:  MOVF   FED,F
083E6:  MOVFF  00,FEF
083EA:  MOVFF  01,FEC
083EE:  MOVFF  02,FEC
083F2:  MOVFF  03,FEC
083F6:  MOVF   FED,F
083F8:  MOVF   FED,F
083FA:  MOVF   FED,F
....................                     iv1_data_ptr->uncopied_counter += PACKET_SIZE;
083FC:  MOVLW  05
083FE:  ADDWF  x2A,W
08400:  MOVWF  FE9
08402:  MOVLW  00
08404:  ADDWFC x2B,W
08406:  MOVWF  FEA
08408:  MOVLW  40
0840A:  ADDWF  FEF,W
0840C:  MOVWF  00
0840E:  MOVLW  00
08410:  ADDWFC FEC,W
08412:  MOVWF  01
08414:  MOVLW  00
08416:  ADDWFC FEC,W
08418:  MOVWF  02
0841A:  MOVLW  00
0841C:  ADDWFC FEC,W
0841E:  MOVWF  03
08420:  MOVF   FED,F
08422:  MOVF   FED,F
08424:  MOVF   FED,F
08426:  MOVFF  00,FEF
0842A:  MOVFF  01,FEC
0842E:  MOVFF  02,FEC
08432:  MOVFF  03,FEC
08436:  MOVF   FED,F
08438:  MOVF   FED,F
0843A:  MOVF   FED,F
....................                     break;
0843C:  MOVLB  0
0843E:  GOTO   8538
....................                 case 2:
....................                     write_address += iv2_data_ptr->used_counter;
08442:  MOVLW  01
08444:  MOVLB  1
08446:  ADDWF  x2E,W
08448:  MOVWF  FE9
0844A:  MOVLW  00
0844C:  ADDWFC x2F,W
0844E:  MOVWF  FEA
08450:  MOVFF  FEF,00
08454:  MOVFF  FEC,01
08458:  MOVFF  FEC,02
0845C:  MOVFF  FEC,03
08460:  MOVF   FED,F
08462:  MOVF   FED,F
08464:  MOVF   FED,F
08466:  MOVF   00,W
08468:  MOVLB  A
0846A:  ADDWF  x36,F
0846C:  MOVF   01,W
0846E:  ADDWFC x37,F
08470:  MOVF   02,W
08472:  ADDWFC x38,F
08474:  MOVF   03,W
08476:  ADDWFC x39,F
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
08478:  MOVFF  115,A8E
0847C:  MOVFF  114,A8D
08480:  MOVFF  113,A8C
08484:  MOVFF  112,A8B
08488:  MOVFF  A39,A92
0848C:  MOVFF  A38,A91
08490:  MOVFF  A37,A90
08494:  MOVFF  A36,A8F
08498:  MOVLW  09
0849A:  MOVWF  x94
0849C:  MOVLW  ED
0849E:  MOVWF  x93
084A0:  CLRF   x96
084A2:  MOVLW  40
084A4:  MOVWF  x95
084A6:  MOVLB  0
084A8:  CALL   3EC0
....................                     iv2_data_ptr->used_counter += PACKET_SIZE;
084AC:  MOVLW  01
084AE:  MOVLB  1
084B0:  ADDWF  x2E,W
084B2:  MOVWF  FE9
084B4:  MOVLW  00
084B6:  ADDWFC x2F,W
084B8:  MOVWF  FEA
084BA:  MOVLW  40
084BC:  ADDWF  FEF,W
084BE:  MOVWF  00
084C0:  MOVLW  00
084C2:  ADDWFC FEC,W
084C4:  MOVWF  01
084C6:  MOVLW  00
084C8:  ADDWFC FEC,W
084CA:  MOVWF  02
084CC:  MOVLW  00
084CE:  ADDWFC FEC,W
084D0:  MOVWF  03
084D2:  MOVF   FED,F
084D4:  MOVF   FED,F
084D6:  MOVF   FED,F
084D8:  MOVFF  00,FEF
084DC:  MOVFF  01,FEC
084E0:  MOVFF  02,FEC
084E4:  MOVFF  03,FEC
084E8:  MOVF   FED,F
084EA:  MOVF   FED,F
084EC:  MOVF   FED,F
....................                     iv2_data_ptr->uncopied_counter += PACKET_SIZE;
084EE:  MOVLW  05
084F0:  ADDWF  x2E,W
084F2:  MOVWF  FE9
084F4:  MOVLW  00
084F6:  ADDWFC x2F,W
084F8:  MOVWF  FEA
084FA:  MOVLW  40
084FC:  ADDWF  FEF,W
084FE:  MOVWF  00
08500:  MOVLW  00
08502:  ADDWFC FEC,W
08504:  MOVWF  01
08506:  MOVLW  00
08508:  ADDWFC FEC,W
0850A:  MOVWF  02
0850C:  MOVLW  00
0850E:  ADDWFC FEC,W
08510:  MOVWF  03
08512:  MOVF   FED,F
08514:  MOVF   FED,F
08516:  MOVF   FED,F
08518:  MOVFF  00,FEF
0851C:  MOVFF  01,FEC
08520:  MOVFF  02,FEC
08524:  MOVFF  03,FEC
08528:  MOVF   FED,F
0852A:  MOVF   FED,F
0852C:  MOVF   FED,F
....................                     break;
0852E:  MOVLB  0
08530:  GOTO   8538
....................                 default:
....................                     break;
08534:  GOTO   8538
....................             }
.................... 
....................             // デバッグ表示
....................             fprintf(PC, "\r\n");
08538:  MOVLW  0D
0853A:  BTFSS  FA6.6
0853C:  GOTO   853A
08540:  MOVLB  E
08542:  MOVWF  xF9
08544:  MOVLW  0A
08546:  MOVLB  0
08548:  BTFSS  FA6.6
0854A:  GOTO   8548
0854E:  MOVLB  E
08550:  MOVWF  xF9
....................             for (unsigned int32 j = 0; j < PACKET_SIZE; j++) {
08552:  MOVLB  A
08554:  CLRF   x3D
08556:  CLRF   x3C
08558:  CLRF   x3B
0855A:  CLRF   x3A
0855C:  MOVLB  0
0855E:  MOVLB  A
08560:  MOVF   x3D,F
08562:  BTFSC  FD8.2
08564:  BRA    856C
08566:  MOVLB  0
08568:  GOTO   85E6
0856C:  MOVLB  0
0856E:  MOVLB  A
08570:  MOVF   x3C,F
08572:  BTFSC  FD8.2
08574:  BRA    857C
08576:  MOVLB  0
08578:  GOTO   85E6
0857C:  MOVLB  0
0857E:  MOVLB  A
08580:  MOVF   x3B,F
08582:  BTFSC  FD8.2
08584:  BRA    858C
08586:  MOVLB  0
08588:  GOTO   85E6
0858C:  MOVLB  0
0858E:  MOVLB  A
08590:  MOVF   x3A,W
08592:  SUBLW  3F
08594:  BTFSC  FD8.0
08596:  BRA    859E
08598:  MOVLB  0
0859A:  GOTO   85E6
0859E:  MOVLB  0
....................                 fprintf(PC, "%02X ", packetdata[j]);
085A0:  MOVLW  ED
085A2:  MOVLB  A
085A4:  ADDWF  x3A,W
085A6:  MOVWF  FE9
085A8:  MOVLW  09
085AA:  ADDWFC x3B,W
085AC:  MOVWF  FEA
085AE:  MOVFF  FEF,A47
085B2:  MOVFF  A47,A48
085B6:  MOVLW  37
085B8:  MOVWF  x49
085BA:  MOVLB  0
085BC:  CALL   1E3C
085C0:  MOVLW  20
085C2:  BTFSS  FA6.6
085C4:  GOTO   85C2
085C8:  MOVLB  E
085CA:  MOVWF  xF9
085CC:  MOVLB  0
085CE:  MOVLW  01
085D0:  MOVLB  A
085D2:  ADDWF  x3A,F
085D4:  BTFSC  FD8.0
085D6:  INCF   x3B,F
085D8:  BTFSC  FD8.2
085DA:  INCF   x3C,F
085DC:  BTFSC  FD8.2
085DE:  INCF   x3D,F
085E0:  MOVLB  0
085E2:  GOTO   855E
....................             }
.................... 
....................             // パケット初期化
....................             packetdata_index = 0;
085E6:  MOVLB  A
085E8:  CLRF   x2D
....................             memset(packetdata, 0x00, PACKET_SIZE);
085EA:  MOVLW  09
085EC:  MOVWF  FEA
085EE:  MOVLW  ED
085F0:  MOVWF  FE9
085F2:  CLRF   00
085F4:  CLRF   02
085F6:  MOVLW  40
085F8:  MOVWF  01
085FA:  MOVLB  0
085FC:  CALL   27AC
....................         }
.................... 
....................         // データ書き込み
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
08600:  MOVLB  A
08602:  MOVF   x2D,W
08604:  INCF   x2D,F
08606:  CLRF   03
08608:  ADDLW  ED
0860A:  MOVWF  FE9
0860C:  MOVLW  09
0860E:  ADDWFC 03,W
08610:  MOVWF  FEA
08612:  RRCF   x32,W
08614:  MOVWF  x4A
08616:  RRCF   x31,W
08618:  MOVWF  x49
0861A:  RRCF   x4A,F
0861C:  RRCF   x49,F
0861E:  RRCF   x4A,F
08620:  RRCF   x49,F
08622:  RRCF   x4A,F
08624:  RRCF   x49,F
08626:  MOVLW  0F
08628:  ANDWF  x4A,F
0862A:  MOVF   x49,W
0862C:  MOVWF  00
0862E:  CLRF   03
08630:  MOVF   00,W
08632:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
08634:  MOVF   x2D,W
08636:  INCF   x2D,F
08638:  CLRF   03
0863A:  ADDLW  ED
0863C:  MOVWF  FE9
0863E:  MOVLW  09
08640:  ADDWFC 03,W
08642:  MOVWF  FEA
08644:  MOVF   x31,W
08646:  ANDLW  0F
08648:  MOVWF  x49
0864A:  CLRF   x4A
0864C:  RLCF   x49,F
0864E:  RLCF   x4A,F
08650:  RLCF   x49,F
08652:  RLCF   x4A,F
08654:  RLCF   x49,F
08656:  RLCF   x4A,F
08658:  RLCF   x49,F
0865A:  RLCF   x4A,F
0865C:  MOVLW  F0
0865E:  ANDWF  x49,F
08660:  MOVFF  A34,A4B
08664:  CLRF   x4C
08666:  MOVF   x4B,W
08668:  ANDLW  0F
0866A:  MOVWF  00
0866C:  CLRF   03
0866E:  MOVF   00,W
08670:  IORWF  x49,W
08672:  MOVWF  00
08674:  MOVF   03,W
08676:  IORWF  x4A,W
08678:  MOVWF  03
0867A:  MOVF   00,W
0867C:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
0867E:  MOVF   x2D,W
08680:  INCF   x2D,F
08682:  CLRF   03
08684:  ADDLW  ED
08686:  MOVWF  FE9
08688:  MOVLW  09
0868A:  ADDWFC 03,W
0868C:  MOVWF  FEA
0868E:  MOVF   x33,W
08690:  MOVWF  00
08692:  CLRF   03
08694:  MOVF   00,W
08696:  MOVWF  FEF
08698:  MOVLB  0
0869A:  MOVLB  A
0869C:  INCF   x2F,F
0869E:  BTFSC  FD8.2
086A0:  INCF   x30,F
086A2:  MOVLB  0
086A4:  GOTO   7E00
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
086A8:  MOVLB  A
086AA:  MOVF   x2D,F
086AC:  BTFSS  FD8.2
086AE:  BRA    86B6
086B0:  MOVLB  0
086B2:  GOTO   891A
086B6:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
086B8:  MOVFF  A2D,A3E
086BC:  MOVLB  A
086BE:  MOVF   x3E,W
086C0:  SUBLW  3E
086C2:  BTFSC  FD8.0
086C4:  BRA    86CC
086C6:  MOVLB  0
086C8:  GOTO   86EC
086CC:  MOVLB  0
....................             packetdata[j] = 0x00;
086CE:  CLRF   03
086D0:  MOVLB  A
086D2:  MOVF   x3E,W
086D4:  ADDLW  ED
086D6:  MOVWF  FE9
086D8:  MOVLW  09
086DA:  ADDWFC 03,W
086DC:  MOVWF  FEA
086DE:  CLRF   FEF
086E0:  MOVLB  0
086E2:  MOVLB  A
086E4:  INCF   x3E,F
086E6:  MOVLB  0
086E8:  GOTO   86BC
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
086EC:  MOVLW  09
086EE:  MOVLB  A
086F0:  MOVWF  xEB
086F2:  MOVLW  ED
086F4:  MOVWF  xEA
086F6:  MOVLW  3F
086F8:  MOVWF  xEC
086FA:  MOVLB  0
086FC:  CALL   29E8
08700:  MOVFF  01,A2C
....................       unsigned int32 write_address;
....................         switch (port_data_ptr->port_num)
08704:  MOVLB  9
08706:  MOVF   xEB,W
08708:  MOVWF  FE9
0870A:  MOVF   xEC,W
0870C:  MOVWF  FEA
0870E:  MOVF   FEF,W
08710:  XORLW  01
08712:  MOVLB  0
08714:  BTFSC  FD8.2
08716:  GOTO   8726
0871A:  XORLW  03
0871C:  BTFSC  FD8.2
0871E:  GOTO   881E
08722:  GOTO   8916
....................         {
....................         case 1:
....................             write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
08726:  MOVLW  01
08728:  MOVLB  1
0872A:  ADDWF  x2A,W
0872C:  MOVWF  FE9
0872E:  MOVLW  00
08730:  ADDWFC x2B,W
08732:  MOVWF  FEA
08734:  MOVFF  FEF,00
08738:  MOVFF  FEC,01
0873C:  MOVFF  FEC,02
08740:  MOVFF  FEC,03
08744:  MOVF   FED,F
08746:  MOVF   FED,F
08748:  MOVF   FED,F
0874A:  MOVF   00,W
0874C:  MOVLB  A
0874E:  MOVWF  x3F
08750:  MOVLW  10
08752:  ADDWF  01,W
08754:  MOVWF  x40
08756:  MOVLW  7C
08758:  ADDWFC 02,W
0875A:  MOVWF  x41
0875C:  MOVLW  00
0875E:  ADDWFC 03,W
08760:  MOVWF  x42
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
08762:  MOVFF  115,A8E
08766:  MOVFF  114,A8D
0876A:  MOVFF  113,A8C
0876E:  MOVFF  112,A8B
08772:  MOVFF  A42,A92
08776:  MOVFF  A41,A91
0877A:  MOVFF  A40,A90
0877E:  MOVFF  A3F,A8F
08782:  MOVLW  09
08784:  MOVWF  x94
08786:  MOVLW  ED
08788:  MOVWF  x93
0878A:  CLRF   x96
0878C:  MOVLW  40
0878E:  MOVWF  x95
08790:  MOVLB  0
08792:  CALL   3EC0
....................             iv1_data_ptr->used_counter += PACKET_SIZE;
08796:  MOVLW  01
08798:  MOVLB  1
0879A:  ADDWF  x2A,W
0879C:  MOVWF  FE9
0879E:  MOVLW  00
087A0:  ADDWFC x2B,W
087A2:  MOVWF  FEA
087A4:  MOVLW  40
087A6:  ADDWF  FEF,W
087A8:  MOVWF  00
087AA:  MOVLW  00
087AC:  ADDWFC FEC,W
087AE:  MOVWF  01
087B0:  MOVLW  00
087B2:  ADDWFC FEC,W
087B4:  MOVWF  02
087B6:  MOVLW  00
087B8:  ADDWFC FEC,W
087BA:  MOVWF  03
087BC:  MOVF   FED,F
087BE:  MOVF   FED,F
087C0:  MOVF   FED,F
087C2:  MOVFF  00,FEF
087C6:  MOVFF  01,FEC
087CA:  MOVFF  02,FEC
087CE:  MOVFF  03,FEC
087D2:  MOVF   FED,F
087D4:  MOVF   FED,F
087D6:  MOVF   FED,F
....................             iv1_data_ptr->uncopied_counter += PACKET_SIZE;
087D8:  MOVLW  05
087DA:  ADDWF  x2A,W
087DC:  MOVWF  FE9
087DE:  MOVLW  00
087E0:  ADDWFC x2B,W
087E2:  MOVWF  FEA
087E4:  MOVLW  40
087E6:  ADDWF  FEF,W
087E8:  MOVWF  00
087EA:  MOVLW  00
087EC:  ADDWFC FEC,W
087EE:  MOVWF  01
087F0:  MOVLW  00
087F2:  ADDWFC FEC,W
087F4:  MOVWF  02
087F6:  MOVLW  00
087F8:  ADDWFC FEC,W
087FA:  MOVWF  03
087FC:  MOVF   FED,F
087FE:  MOVF   FED,F
08800:  MOVF   FED,F
08802:  MOVFF  00,FEF
08806:  MOVFF  01,FEC
0880A:  MOVFF  02,FEC
0880E:  MOVFF  03,FEC
08812:  MOVF   FED,F
08814:  MOVF   FED,F
08816:  MOVF   FED,F
....................             break;
08818:  MOVLB  0
0881A:  GOTO   891A
....................         case 2:
....................          write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
0881E:  MOVLW  01
08820:  MOVLB  1
08822:  ADDWF  x2E,W
08824:  MOVWF  FE9
08826:  MOVLW  00
08828:  ADDWFC x2F,W
0882A:  MOVWF  FEA
0882C:  MOVFF  FEF,00
08830:  MOVFF  FEC,01
08834:  MOVFF  FEC,02
08838:  MOVFF  FEC,03
0883C:  MOVF   FED,F
0883E:  MOVF   FED,F
08840:  MOVF   FED,F
08842:  MOVF   00,W
08844:  MOVLB  A
08846:  MOVWF  x3F
08848:  MOVLW  10
0884A:  ADDWF  01,W
0884C:  MOVWF  x40
0884E:  MOVLW  7C
08850:  ADDWFC 02,W
08852:  MOVWF  x41
08854:  MOVLW  00
08856:  ADDWFC 03,W
08858:  MOVWF  x42
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
0885A:  MOVFF  115,A8E
0885E:  MOVFF  114,A8D
08862:  MOVFF  113,A8C
08866:  MOVFF  112,A8B
0886A:  MOVFF  A42,A92
0886E:  MOVFF  A41,A91
08872:  MOVFF  A40,A90
08876:  MOVFF  A3F,A8F
0887A:  MOVLW  09
0887C:  MOVWF  x94
0887E:  MOVLW  ED
08880:  MOVWF  x93
08882:  CLRF   x96
08884:  MOVLW  40
08886:  MOVWF  x95
08888:  MOVLB  0
0888A:  CALL   3EC0
....................             iv2_data_ptr->used_counter += PACKET_SIZE;
0888E:  MOVLW  01
08890:  MOVLB  1
08892:  ADDWF  x2E,W
08894:  MOVWF  FE9
08896:  MOVLW  00
08898:  ADDWFC x2F,W
0889A:  MOVWF  FEA
0889C:  MOVLW  40
0889E:  ADDWF  FEF,W
088A0:  MOVWF  00
088A2:  MOVLW  00
088A4:  ADDWFC FEC,W
088A6:  MOVWF  01
088A8:  MOVLW  00
088AA:  ADDWFC FEC,W
088AC:  MOVWF  02
088AE:  MOVLW  00
088B0:  ADDWFC FEC,W
088B2:  MOVWF  03
088B4:  MOVF   FED,F
088B6:  MOVF   FED,F
088B8:  MOVF   FED,F
088BA:  MOVFF  00,FEF
088BE:  MOVFF  01,FEC
088C2:  MOVFF  02,FEC
088C6:  MOVFF  03,FEC
088CA:  MOVF   FED,F
088CC:  MOVF   FED,F
088CE:  MOVF   FED,F
....................             iv2_data_ptr->uncopied_counter += PACKET_SIZE;
088D0:  MOVLW  05
088D2:  ADDWF  x2E,W
088D4:  MOVWF  FE9
088D6:  MOVLW  00
088D8:  ADDWFC x2F,W
088DA:  MOVWF  FEA
088DC:  MOVLW  40
088DE:  ADDWF  FEF,W
088E0:  MOVWF  00
088E2:  MOVLW  00
088E4:  ADDWFC FEC,W
088E6:  MOVWF  01
088E8:  MOVLW  00
088EA:  ADDWFC FEC,W
088EC:  MOVWF  02
088EE:  MOVLW  00
088F0:  ADDWFC FEC,W
088F2:  MOVWF  03
088F4:  MOVF   FED,F
088F6:  MOVF   FED,F
088F8:  MOVF   FED,F
088FA:  MOVFF  00,FEF
088FE:  MOVFF  01,FEC
08902:  MOVFF  02,FEC
08906:  MOVFF  03,FEC
0890A:  MOVF   FED,F
0890C:  MOVF   FED,F
0890E:  MOVF   FED,F
....................             break;
08910:  MOVLB  0
08912:  GOTO   891A
....................         default:
....................             break;
08916:  GOTO   891A
....................         }
.................... 
....................     }
....................                 // デバッグ表示
....................     fprintf(PC, "\r\n");
0891A:  MOVLW  0D
0891C:  BTFSS  FA6.6
0891E:  GOTO   891C
08922:  MOVLB  E
08924:  MOVWF  xF9
08926:  MOVLW  0A
08928:  MOVLB  0
0892A:  BTFSS  FA6.6
0892C:  GOTO   892A
08930:  MOVLB  E
08932:  MOVWF  xF9
....................     for (unsigned int32 j = 0; j < PACKET_SIZE; j++) {
08934:  MOVLB  A
08936:  CLRF   x46
08938:  CLRF   x45
0893A:  CLRF   x44
0893C:  CLRF   x43
0893E:  MOVLB  0
08940:  MOVLB  A
08942:  MOVF   x46,F
08944:  BTFSC  FD8.2
08946:  BRA    894E
08948:  MOVLB  0
0894A:  GOTO   89C8
0894E:  MOVLB  0
08950:  MOVLB  A
08952:  MOVF   x45,F
08954:  BTFSC  FD8.2
08956:  BRA    895E
08958:  MOVLB  0
0895A:  GOTO   89C8
0895E:  MOVLB  0
08960:  MOVLB  A
08962:  MOVF   x44,F
08964:  BTFSC  FD8.2
08966:  BRA    896E
08968:  MOVLB  0
0896A:  GOTO   89C8
0896E:  MOVLB  0
08970:  MOVLB  A
08972:  MOVF   x43,W
08974:  SUBLW  3F
08976:  BTFSC  FD8.0
08978:  BRA    8980
0897A:  MOVLB  0
0897C:  GOTO   89C8
08980:  MOVLB  0
....................         fprintf(PC, "%02X ", packetdata[j]);
08982:  MOVLW  ED
08984:  MOVLB  A
08986:  ADDWF  x43,W
08988:  MOVWF  FE9
0898A:  MOVLW  09
0898C:  ADDWFC x44,W
0898E:  MOVWF  FEA
08990:  MOVFF  FEF,A47
08994:  MOVFF  A47,A48
08998:  MOVLW  37
0899A:  MOVWF  x49
0899C:  MOVLB  0
0899E:  CALL   1E3C
089A2:  MOVLW  20
089A4:  BTFSS  FA6.6
089A6:  GOTO   89A4
089AA:  MOVLB  E
089AC:  MOVWF  xF9
089AE:  MOVLB  0
089B0:  MOVLW  01
089B2:  MOVLB  A
089B4:  ADDWF  x43,F
089B6:  BTFSC  FD8.0
089B8:  INCF   x44,F
089BA:  BTFSC  FD8.2
089BC:  INCF   x45,F
089BE:  BTFSC  FD8.2
089C0:  INCF   x46,F
089C2:  MOVLB  0
089C4:  GOTO   8940
....................     }
....................     // fprintf(PC, "End CIGS data conversion\r\n");
....................     write_misf_address_area(); // Write the mission flash address area
089C8:  CALL   4934
089CC:  RETURN 0
.................... }
.................... 
.................... 
.................... iv_env_t create_meas_data()
.................... {
....................     iv_env_t data;
....................     memset(&data, 0, sizeof(data));
*
07CEE:  MOVLW  09
07CF0:  MOVWF  FEA
07CF2:  MOVLW  EF
07CF4:  MOVWF  FE9
07CF6:  CLRF   00
07CF8:  CLRF   02
07CFA:  MOVLW  0C
07CFC:  MOVWF  01
07CFE:  CALL   27AC
....................     data.time           = get_current_sec();
07D02:  CALL   3BA8
07D06:  MOVFF  03,9F2
07D0A:  MOVFF  02,9F1
07D0E:  MOVFF  01,9F0
07D12:  MOVFF  00,9EF
....................     data.temp_py_top    = ad7490_read(ADC_TEMP_PY_TOP);
07D16:  MOVLW  0D
07D18:  MOVLB  9
07D1A:  MOVWF  xFB
07D1C:  MOVLB  0
07D1E:  CALL   1DAA
07D22:  MOVFF  02,9F6
07D26:  MOVFF  01,9F5
....................     data.temp_py_bot    = ad7490_read(ADC_TEMP_PY_BOT);
07D2A:  MOVLW  0E
07D2C:  MOVLB  9
07D2E:  MOVWF  xFB
07D30:  MOVLB  0
07D32:  CALL   1DAA
07D36:  MOVFF  02,9F8
07D3A:  MOVFF  01,9F7
....................     data.temp_mis7      = ad7490_read(ADC_TEMP_MIS7);
07D3E:  MOVLW  0C
07D40:  MOVLB  9
07D42:  MOVWF  xFB
07D44:  MOVLB  0
07D46:  CALL   1DAA
07D4A:  MOVFF  02,9FA
07D4E:  MOVFF  01,9F9
....................     data.pd             = ad7490_read(ADC_PD);
07D52:  MOVLW  0F
07D54:  MOVLB  9
07D56:  MOVWF  xFB
07D58:  MOVLB  0
07D5A:  CALL   1DAA
07D5E:  MOVFF  02,9F4
07D62:  MOVFF  01,9F3
....................     return data;
07D66:  MOVLW  EF
07D68:  MOVWF  01
07D6A:  MOVLW  09
07D6C:  MOVWF  02
07D6E:  GOTO   9A42 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "domain/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... int32 tick_10ms = 0; 
.................... 
.................... unsigned int32 dsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_10msec(unsigned int32 new_10msec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
*
049C2:  MOVLW  02
049C4:  MOVLB  2
049C6:  MOVWF  x1D
049C8:  MOVLW  16
049CA:  MOVWF  x1C
.................... {
....................     piclog_t piclog;
....................     piclog_t *piclog_ptr = &piclog;
....................     memset(piclog_ptr, 0x00, PICLOG_PACKET_SIZE);
049CC:  MOVFF  21D,FEA
049D0:  MOVFF  21C,FE9
049D4:  CLRF   00
049D6:  CLRF   02
049D8:  MOVLW  06
049DA:  MOVWF  01
049DC:  MOVLB  0
049DE:  CALL   27AC
....................     piclog_ptr->fields.time = get_current_sec();
049E2:  MOVLB  2
049E4:  MOVF   x1C,W
049E6:  MOVWF  01
049E8:  MOVF   x1D,W
049EA:  MOVWF  03
049EC:  MOVF   01,W
049EE:  MOVWF  x23
049F0:  MOVFF  03,224
049F4:  MOVLB  0
049F6:  CALL   3BA8
049FA:  MOVFF  224,FEA
049FE:  MOVFF  223,FE9
04A02:  MOVFF  00,FEF
04A06:  MOVFF  01,FEC
04A0A:  MOVFF  02,FEC
04A0E:  MOVFF  03,FEC
04A12:  MOVF   FED,F
04A14:  MOVF   FED,F
04A16:  MOVF   FED,F
....................     piclog_ptr->fields.function = function;
04A18:  MOVLW  04
04A1A:  MOVLB  2
04A1C:  ADDWF  x1C,W
04A1E:  MOVWF  FE9
04A20:  MOVLW  00
04A22:  ADDWFC x1D,W
04A24:  MOVWF  FEA
04A26:  MOVFF  214,FEF
....................     piclog_ptr->fields.parameter = parameter;
04A2A:  MOVLW  05
04A2C:  ADDWF  x1C,W
04A2E:  MOVWF  FE9
04A30:  MOVLW  00
04A32:  ADDWFC x1D,W
04A34:  MOVWF  FEA
04A36:  MOVFF  215,FEF
.................... 
....................     printf("[PICLOG] : ");
04A3A:  MOVLW  3A
04A3C:  MOVWF  FF6
04A3E:  MOVLW  05
04A40:  MOVWF  FF7
04A42:  MOVLW  00
04A44:  MOVWF  FF8
04A46:  MOVLB  0
04A48:  CALL   1BF6
....................     for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
04A4C:  MOVLB  2
04A4E:  CLRF   x1E
04A50:  MOVLB  0
04A52:  MOVLB  2
04A54:  MOVF   x1E,W
04A56:  SUBLW  05
04A58:  BTFSC  FD8.0
04A5A:  BRA    4A62
04A5C:  MOVLB  0
04A5E:  GOTO   4A9E
04A62:  MOVLB  0
....................         printf("%02X ", piclog_ptr->bytes[i]);
04A64:  MOVLB  2
04A66:  MOVF   x1E,W
04A68:  ADDWF  x1C,W
04A6A:  MOVWF  FE9
04A6C:  MOVLW  00
04A6E:  ADDWFC x1D,W
04A70:  MOVWF  FEA
04A72:  MOVFF  FEF,223
04A76:  MOVFF  223,A48
04A7A:  MOVLW  37
04A7C:  MOVLB  A
04A7E:  MOVWF  x49
04A80:  MOVLB  0
04A82:  CALL   1E3C
04A86:  MOVLW  20
04A88:  BTFSS  FA6.6
04A8A:  GOTO   4A88
04A8E:  MOVLB  E
04A90:  MOVWF  xF9
04A92:  MOVLB  0
04A94:  MOVLB  2
04A96:  INCF   x1E,F
04A98:  MOVLB  0
04A9A:  GOTO   4A52
....................     }
....................     printf("\r\n");
04A9E:  MOVLW  0D
04AA0:  BTFSS  FA6.6
04AA2:  GOTO   4AA0
04AA6:  MOVLB  E
04AA8:  MOVWF  xF9
04AAA:  MOVLW  0A
04AAC:  MOVLB  0
04AAE:  BTFSS  FA6.6
04AB0:  GOTO   4AAE
04AB4:  MOVLB  E
04AB6:  MOVWF  xF9
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data_ptr->used_counter;
04AB8:  MOVLW  01
04ABA:  MOVLB  1
04ABC:  ADDWF  x24,W
04ABE:  MOVWF  FE9
04AC0:  MOVLW  00
04AC2:  ADDWFC x25,W
04AC4:  MOVWF  FEA
04AC6:  MOVFF  FEF,00
04ACA:  MOVFF  FEC,01
04ACE:  MOVFF  FEC,02
04AD2:  MOVFF  FEC,03
04AD6:  MOVF   FED,F
04AD8:  MOVF   FED,F
04ADA:  MOVF   FED,F
04ADC:  MOVF   00,W
04ADE:  MOVLB  2
04AE0:  MOVWF  x1F
04AE2:  MOVF   01,W
04AE4:  MOVWF  x20
04AE6:  MOVLW  01
04AE8:  ADDWF  02,W
04AEA:  MOVWF  x21
04AEC:  MOVLW  00
04AEE:  ADDWFC 03,W
04AF0:  MOVWF  x22
....................     write_data_bytes(mis_fm, write_address, piclog_ptr->bytes, PICLOG_PACKET_SIZE);
04AF2:  MOVF   x1C,W
04AF4:  MOVWF  01
04AF6:  MOVF   x1D,W
04AF8:  MOVWF  03
04AFA:  MOVF   01,W
04AFC:  MOVWF  x23
04AFE:  MOVFF  03,224
04B02:  MOVFF  115,A8E
04B06:  MOVFF  114,A8D
04B0A:  MOVFF  113,A8C
04B0E:  MOVFF  112,A8B
04B12:  MOVFF  222,A92
04B16:  MOVFF  221,A91
04B1A:  MOVFF  220,A90
04B1E:  MOVFF  21F,A8F
04B22:  MOVFF  224,A94
04B26:  MOVFF  223,A93
04B2A:  MOVLB  A
04B2C:  CLRF   x96
04B2E:  MOVLW  06
04B30:  MOVWF  x95
04B32:  MOVLB  0
04B34:  CALL   3EC0
.................... 
....................     piclog_data_ptr->used_counter += PICLOG_PACKET_SIZE;
04B38:  MOVLW  01
04B3A:  MOVLB  1
04B3C:  ADDWF  x24,W
04B3E:  MOVWF  FE9
04B40:  MOVLW  00
04B42:  ADDWFC x25,W
04B44:  MOVWF  FEA
04B46:  MOVLW  06
04B48:  ADDWF  FEF,W
04B4A:  MOVWF  00
04B4C:  MOVLW  00
04B4E:  ADDWFC FEC,W
04B50:  MOVWF  01
04B52:  MOVLW  00
04B54:  ADDWFC FEC,W
04B56:  MOVWF  02
04B58:  MOVLW  00
04B5A:  ADDWFC FEC,W
04B5C:  MOVWF  03
04B5E:  MOVF   FED,F
04B60:  MOVF   FED,F
04B62:  MOVF   FED,F
04B64:  MOVFF  00,FEF
04B68:  MOVFF  01,FEC
04B6C:  MOVFF  02,FEC
04B70:  MOVFF  03,FEC
04B74:  MOVF   FED,F
04B76:  MOVF   FED,F
04B78:  MOVF   FED,F
....................     piclog_data_ptr->uncopied_counter += PICLOG_PACKET_SIZE;
04B7A:  MOVLW  05
04B7C:  ADDWF  x24,W
04B7E:  MOVWF  FE9
04B80:  MOVLW  00
04B82:  ADDWFC x25,W
04B84:  MOVWF  FEA
04B86:  MOVLW  06
04B88:  ADDWF  FEF,W
04B8A:  MOVWF  00
04B8C:  MOVLW  00
04B8E:  ADDWFC FEC,W
04B90:  MOVWF  01
04B92:  MOVLW  00
04B94:  ADDWFC FEC,W
04B96:  MOVWF  02
04B98:  MOVLW  00
04B9A:  ADDWFC FEC,W
04B9C:  MOVWF  03
04B9E:  MOVF   FED,F
04BA0:  MOVF   FED,F
04BA2:  MOVF   FED,F
04BA4:  MOVFF  00,FEF
04BA8:  MOVFF  01,FEC
04BAC:  MOVFF  02,FEC
04BB0:  MOVFF  03,FEC
04BB4:  MOVF   FED,F
04BB6:  MOVF   FED,F
04BB8:  MOVF   FED,F
....................     piclog_data_ptr->reserve_counter1 += PICLOG_PACKET_SIZE;
04BBA:  MOVLW  09
04BBC:  ADDWF  x24,W
04BBE:  MOVWF  FE9
04BC0:  MOVLW  00
04BC2:  ADDWFC x25,W
04BC4:  MOVWF  FEA
04BC6:  MOVLW  06
04BC8:  ADDWF  FEF,W
04BCA:  MOVWF  FEF
.................... 
....................     // Next Packet
....................     if (piclog_data_ptr->reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
04BCC:  MOVLW  09
04BCE:  ADDWF  x24,W
04BD0:  MOVWF  FE9
04BD2:  MOVLW  00
04BD4:  ADDWFC x25,W
04BD6:  MOVWF  FEA
04BD8:  MOVLW  06
04BDA:  ADDWF  FEF,W
04BDC:  SUBLW  3F
04BDE:  BTFSS  FD8.0
04BE0:  BRA    4BE8
04BE2:  MOVLB  0
04BE4:  GOTO   4CEC
04BE8:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data_ptr->used_counter;
04BEA:  MOVLW  01
04BEC:  MOVLB  1
04BEE:  ADDWF  x24,W
04BF0:  MOVWF  FE9
04BF2:  MOVLW  00
04BF4:  ADDWFC x25,W
04BF6:  MOVWF  FEA
04BF8:  MOVFF  FEF,00
04BFC:  MOVFF  FEC,01
04C00:  MOVFF  FEC,02
04C04:  MOVFF  FEC,03
04C08:  MOVF   FED,F
04C0A:  MOVF   FED,F
04C0C:  MOVF   FED,F
04C0E:  MOVF   00,W
04C10:  MOVLB  2
04C12:  MOVWF  x1F
04C14:  MOVF   01,W
04C16:  MOVWF  x20
04C18:  MOVLW  01
04C1A:  ADDWF  02,W
04C1C:  MOVWF  x21
04C1E:  MOVLW  00
04C20:  ADDWFC 03,W
04C22:  MOVWF  x22
....................         write_data_bytes(mis_fm, write_address, PICLOG_BLANK_DATA, sizeof(PICLOG_BLANK_DATA));
04C24:  MOVFF  115,A8E
04C28:  MOVFF  114,A8D
04C2C:  MOVFF  113,A8C
04C30:  MOVFF  112,A8B
04C34:  MOVFF  222,A92
04C38:  MOVFF  221,A91
04C3C:  MOVFF  220,A90
04C40:  MOVFF  21F,A8F
04C44:  MOVLW  01
04C46:  MOVLB  A
04C48:  MOVWF  x94
04C4A:  MOVLW  30
04C4C:  MOVWF  x93
04C4E:  CLRF   x96
04C50:  MOVLW  04
04C52:  MOVWF  x95
04C54:  MOVLB  0
04C56:  CALL   3EC0
....................         piclog_data_ptr->used_counter += sizeof(PICLOG_BLANK_DATA);
04C5A:  MOVLW  01
04C5C:  MOVLB  1
04C5E:  ADDWF  x24,W
04C60:  MOVWF  FE9
04C62:  MOVLW  00
04C64:  ADDWFC x25,W
04C66:  MOVWF  FEA
04C68:  MOVLW  04
04C6A:  ADDWF  FEF,W
04C6C:  MOVWF  00
04C6E:  MOVLW  00
04C70:  ADDWFC FEC,W
04C72:  MOVWF  01
04C74:  MOVLW  00
04C76:  ADDWFC FEC,W
04C78:  MOVWF  02
04C7A:  MOVLW  00
04C7C:  ADDWFC FEC,W
04C7E:  MOVWF  03
04C80:  MOVF   FED,F
04C82:  MOVF   FED,F
04C84:  MOVF   FED,F
04C86:  MOVFF  00,FEF
04C8A:  MOVFF  01,FEC
04C8E:  MOVFF  02,FEC
04C92:  MOVFF  03,FEC
04C96:  MOVF   FED,F
04C98:  MOVF   FED,F
04C9A:  MOVF   FED,F
....................         piclog_data_ptr->uncopied_counter += sizeof(PICLOG_BLANK_DATA);
04C9C:  MOVLW  05
04C9E:  ADDWF  x24,W
04CA0:  MOVWF  FE9
04CA2:  MOVLW  00
04CA4:  ADDWFC x25,W
04CA6:  MOVWF  FEA
04CA8:  MOVLW  04
04CAA:  ADDWF  FEF,W
04CAC:  MOVWF  00
04CAE:  MOVLW  00
04CB0:  ADDWFC FEC,W
04CB2:  MOVWF  01
04CB4:  MOVLW  00
04CB6:  ADDWFC FEC,W
04CB8:  MOVWF  02
04CBA:  MOVLW  00
04CBC:  ADDWFC FEC,W
04CBE:  MOVWF  03
04CC0:  MOVF   FED,F
04CC2:  MOVF   FED,F
04CC4:  MOVF   FED,F
04CC6:  MOVFF  00,FEF
04CCA:  MOVFF  01,FEC
04CCE:  MOVFF  02,FEC
04CD2:  MOVFF  03,FEC
04CD6:  MOVF   FED,F
04CD8:  MOVF   FED,F
04CDA:  MOVF   FED,F
....................         piclog_data_ptr->reserve_counter1 = 0;
04CDC:  MOVLW  09
04CDE:  ADDWF  x24,W
04CE0:  MOVWF  FE9
04CE2:  MOVLW  00
04CE4:  ADDWFC x25,W
04CE6:  MOVWF  FEA
04CE8:  CLRF   FEF
04CEA:  MOVLB  0
....................     }
.................... 
....................     write_misf_address_area(); // Update the address area after writing
04CEC:  CALL   4934
04CF0:  RETURN 0
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "domain/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
*
06BA2:  MOVLB  2
06BA4:  CLRF   x07
06BA6:  CLRF   x08
06BA8:  CLRF   x09
06BAA:  CLRF   x0A
06BAC:  CLRF   x0B
06BAE:  CLRF   x0C
06BB0:  CLRF   x0D
06BB2:  CLRF   x0E
06BB4:  CLRF   x0F
06BB6:  CLRF   x10
06BB8:  CLRF   x11
06BBA:  CLRF   x12
06BBC:  CLRF   x13
06BBE:  CLRF   x14
06BC0:  CLRF   x15
06BC2:  CLRF   x16
06BC4:  CLRF   x17
06BC6:  CLRF   x18
06BC8:  CLRF   x19
06BCA:  CLRF   x1A
06BCC:  CLRF   x1B
06BCE:  CLRF   x1C
06BD0:  CLRF   x1D
06BD2:  CLRF   x1E
06BD4:  CLRF   x1F
06BD6:  CLRF   x20
06BD8:  CLRF   x21
06BDA:  CLRF   x22
06BDC:  CLRF   x23
06BDE:  CLRF   x24
06BE0:  CLRF   x25
06BE2:  CLRF   x26
06BE4:  CLRF   x27
06BE6:  CLRF   x28
06BE8:  CLRF   x29
06BEA:  CLRF   x2A
06BEC:  CLRF   x2B
06BEE:  CLRF   x2C
06BF0:  CLRF   x2D
06BF2:  CLRF   x2E
06BF4:  CLRF   x2F
06BF6:  CLRF   x30
06BF8:  CLRF   x31
06BFA:  CLRF   x32
06BFC:  CLRF   x33
06BFE:  CLRF   x34
06C00:  CLRF   x35
06C02:  CLRF   x36
06C04:  CLRF   x37
06C06:  CLRF   x38
06C08:  CLRF   x39
06C0A:  CLRF   x3A
06C0C:  CLRF   x3B
06C0E:  CLRF   x3C
06C10:  CLRF   x3D
06C12:  CLRF   x3E
06C14:  CLRF   x3F
06C16:  CLRF   x40
06C18:  CLRF   x41
06C1A:  CLRF   x42
06C1C:  CLRF   x43
06C1E:  CLRF   x44
06C20:  CLRF   x45
06C22:  CLRF   x46
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
06C24:  MOVLW  02
06C26:  MOVLB  A
06C28:  MOVWF  xEB
06C2A:  MOVLW  07
06C2C:  MOVWF  xEA
06C2E:  MOVLW  3F
06C30:  MOVWF  xEC
06C32:  MOVLB  0
06C34:  CALL   29E8
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
06C38:  MOVFF  119,A8E
06C3C:  MOVFF  118,A8D
06C40:  MOVFF  117,A8C
06C44:  MOVFF  116,A8B
06C48:  MOVLW  06
06C4A:  MOVLB  A
06C4C:  MOVWF  x92
06C4E:  MOVLW  AA
06C50:  MOVWF  x91
06C52:  CLRF   x90
06C54:  CLRF   x8F
06C56:  MOVLW  02
06C58:  MOVWF  x94
06C5A:  MOVLW  07
06C5C:  MOVWF  x93
06C5E:  CLRF   x96
06C60:  MOVLW  40
06C62:  MOVWF  x95
06C64:  MOVLB  0
06C66:  CALL   3EC0
06C6A:  GOTO   6DBE (RETURN)
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
0AEFA:  MOVLB  2
0AEFC:  MOVF   x94,W
0AEFE:  MOVWF  01
0AF00:  MOVF   x95,W
0AF02:  MOVWF  03
0AF04:  MOVF   01,W
0AF06:  MOVWF  x97
0AF08:  MOVFF  03,298
0AF0C:  MOVFF  119,319
0AF10:  MOVFF  118,318
0AF14:  MOVFF  117,317
0AF18:  MOVFF  116,316
0AF1C:  MOVLW  06
0AF1E:  MOVLB  3
0AF20:  MOVWF  x1D
0AF22:  MOVLW  AA
0AF24:  MOVWF  x1C
0AF26:  CLRF   x1B
0AF28:  CLRF   x1A
0AF2A:  MOVFF  298,31F
0AF2E:  MOVFF  297,31E
0AF32:  CLRF   x23
0AF34:  CLRF   x22
0AF36:  CLRF   x21
0AF38:  MOVLW  40
0AF3A:  MOVWF  x20
0AF3C:  MOVLB  0
0AF3E:  CALL   27D0
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0AF42:  MOVLB  2
0AF44:  CLRF   x96
0AF46:  MOVLB  0
0AF48:  MOVLB  2
0AF4A:  MOVF   x96,W
0AF4C:  SUBLW  04
0AF4E:  BTFSC  FD8.0
0AF50:  BRA    AF58
0AF52:  MOVLB  0
0AF54:  GOTO   B02A
0AF58:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
0AF5A:  MOVLB  2
0AF5C:  MOVF   x94,W
0AF5E:  MOVWF  01
0AF60:  MOVF   x95,W
0AF62:  MOVWF  03
0AF64:  MOVF   01,W
0AF66:  MOVWF  x97
0AF68:  MOVFF  03,298
0AF6C:  MOVFF  119,319
0AF70:  MOVFF  118,318
0AF74:  MOVFF  117,317
0AF78:  MOVFF  116,316
0AF7C:  MOVLW  06
0AF7E:  MOVLB  3
0AF80:  MOVWF  x1D
0AF82:  MOVLW  AA
0AF84:  MOVWF  x1C
0AF86:  CLRF   x1B
0AF88:  CLRF   x1A
0AF8A:  MOVFF  298,31F
0AF8E:  MOVFF  297,31E
0AF92:  CLRF   x23
0AF94:  CLRF   x22
0AF96:  CLRF   x21
0AF98:  MOVLW  40
0AF9A:  MOVWF  x20
0AF9C:  MOVLB  0
0AF9E:  CALL   27D0
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
0AFA2:  MOVLB  2
0AFA4:  MOVF   x94,W
0AFA6:  MOVWF  01
0AFA8:  MOVF   x95,W
0AFAA:  MOVWF  03
0AFAC:  MOVF   01,W
0AFAE:  MOVWF  x97
0AFB0:  MOVFF  03,298
0AFB4:  MOVFF  298,317
0AFB8:  MOVFF  297,316
0AFBC:  MOVLW  3F
0AFBE:  MOVLB  3
0AFC0:  MOVWF  x18
0AFC2:  MOVLB  0
0AFC4:  CALL   AEAC
0AFC8:  MOVF   01,F
0AFCA:  BTFSC  FD8.2
0AFCC:  GOTO   B020
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
0AFD0:  MOVLW  01
0AFD2:  MOVLB  2
0AFD4:  ADDWF  x96,W
0AFD6:  MOVWF  x97
0AFD8:  MOVLW  46
0AFDA:  MOVWF  FF6
0AFDC:  MOVLW  05
0AFDE:  MOVWF  FF7
0AFE0:  MOVLW  00
0AFE2:  MOVWF  FF8
0AFE4:  MOVLW  23
0AFE6:  MOVLB  9
0AFE8:  MOVWF  xE9
0AFEA:  MOVLB  0
0AFEC:  CALL   1C2C
0AFF0:  MOVFF  297,298
0AFF4:  MOVLW  1B
0AFF6:  MOVLB  2
0AFF8:  MOVWF  x99
0AFFA:  MOVLB  0
0AFFC:  CALL   A8FC
0B000:  MOVLW  0D
0B002:  BTFSS  FA6.6
0B004:  GOTO   B002
0B008:  MOVLB  E
0B00A:  MOVWF  xF9
0B00C:  MOVLW  0A
0B00E:  MOVLB  0
0B010:  BTFSS  FA6.6
0B012:  GOTO   B010
0B016:  MOVLB  E
0B018:  MOVWF  xF9
....................             break;
0B01A:  MOVLB  0
0B01C:  GOTO   B02A
....................         }
0B020:  MOVLB  2
0B022:  INCF   x96,F
0B024:  MOVLB  0
0B026:  GOTO   AF48
....................     }
0B02A:  GOTO   B4E2 (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
0B168:  CALL   4244
0B16C:  MOVFF  02,03
0B170:  MOVF   01,W
0B172:  MOVWF  FE1
0B174:  MOVFF  03,FE2
0B178:  MOVLW  02
0B17A:  MOVWF  FEA
0B17C:  MOVLW  94
0B17E:  MOVWF  FE9
0B180:  MOVLW  40
0B182:  MOVWF  01
0B184:  MOVFF  FE6,FEE
0B188:  DECFSZ 01,F
0B18A:  GOTO   B184
0B18E:  MOVLB  3
0B190:  BCF    x14.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0B192:  CLRF   x15
0B194:  MOVLB  0
0B196:  MOVLB  3
0B198:  MOVF   x15,W
0B19A:  SUBLW  04
0B19C:  BTFSC  FD8.0
0B19E:  BRA    B1A6
0B1A0:  MOVLB  0
0B1A2:  GOTO   B2AA
0B1A6:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
0B1A8:  MOVFF  119,319
0B1AC:  MOVFF  118,318
0B1B0:  MOVFF  117,317
0B1B4:  MOVFF  116,316
0B1B8:  MOVLW  06
0B1BA:  MOVLB  3
0B1BC:  MOVWF  x1D
0B1BE:  MOVLW  AA
0B1C0:  MOVWF  x1C
0B1C2:  CLRF   x1B
0B1C4:  CLRF   x1A
0B1C6:  MOVLB  0
0B1C8:  CALL   5650
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
0B1CC:  MOVFF  119,A8E
0B1D0:  MOVFF  118,A8D
0B1D4:  MOVFF  117,A8C
0B1D8:  MOVFF  116,A8B
0B1DC:  MOVLW  06
0B1DE:  MOVLB  A
0B1E0:  MOVWF  x92
0B1E2:  MOVLW  AA
0B1E4:  MOVWF  x91
0B1E6:  CLRF   x90
0B1E8:  CLRF   x8F
0B1EA:  MOVLW  02
0B1EC:  MOVWF  x94
0B1EE:  MOVLW  94
0B1F0:  MOVWF  x93
0B1F2:  CLRF   x96
0B1F4:  MOVLW  40
0B1F6:  MOVWF  x95
0B1F8:  MOVLB  0
0B1FA:  CALL   3EC0
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
0B1FE:  MOVFF  119,319
0B202:  MOVFF  118,318
0B206:  MOVFF  117,317
0B20A:  MOVFF  116,316
0B20E:  MOVLW  06
0B210:  MOVLB  3
0B212:  MOVWF  x1D
0B214:  MOVLW  AA
0B216:  MOVWF  x1C
0B218:  CLRF   x1B
0B21A:  CLRF   x1A
0B21C:  MOVLW  02
0B21E:  MOVWF  x1F
0B220:  MOVLW  D4
0B222:  MOVWF  x1E
0B224:  CLRF   x23
0B226:  CLRF   x22
0B228:  CLRF   x21
0B22A:  MOVLW  40
0B22C:  MOVWF  x20
0B22E:  MOVLB  0
0B230:  CALL   27D0
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
0B234:  MOVLW  02
0B236:  MOVLB  3
0B238:  MOVWF  x17
0B23A:  MOVLW  D4
0B23C:  MOVWF  x16
0B23E:  MOVLW  3F
0B240:  MOVWF  x18
0B242:  MOVLB  0
0B244:  CALL   AEAC
0B248:  MOVF   01,F
0B24A:  BTFSC  FD8.2
0B24C:  GOTO   B2A0
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
0B250:  MOVLW  01
0B252:  MOVLB  3
0B254:  ADDWF  x15,W
0B256:  MOVWF  x16
0B258:  MOVLW  6E
0B25A:  MOVWF  FF6
0B25C:  MOVLW  05
0B25E:  MOVWF  FF7
0B260:  MOVLW  00
0B262:  MOVWF  FF8
0B264:  MOVLW  23
0B266:  MOVLB  9
0B268:  MOVWF  xE9
0B26A:  MOVLB  0
0B26C:  CALL   1C2C
0B270:  MOVFF  316,317
0B274:  MOVLW  18
0B276:  MOVLB  3
0B278:  MOVWF  x18
0B27A:  MOVLB  0
0B27C:  CALL   B02E
0B280:  MOVLW  0D
0B282:  BTFSS  FA6.6
0B284:  GOTO   B282
0B288:  MOVLB  E
0B28A:  MOVWF  xF9
0B28C:  MOVLW  0A
0B28E:  MOVLB  0
0B290:  BTFSS  FA6.6
0B292:  GOTO   B290
0B296:  MOVLB  E
0B298:  MOVWF  xF9
....................             break;
0B29A:  MOVLB  0
0B29C:  GOTO   B2AA
....................         }
0B2A0:  MOVLB  3
0B2A2:  INCF   x15,F
0B2A4:  MOVLB  0
0B2A6:  GOTO   B196
....................     }
....................     if (!crc_valid)
0B2AA:  MOVLB  3
0B2AC:  BTFSS  x14.0
0B2AE:  BRA    B2B6
0B2B0:  MOVLB  0
0B2B2:  GOTO   B2F8
0B2B6:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
0B2B8:  MOVLW  96
0B2BA:  MOVWF  FF6
0B2BC:  MOVLW  05
0B2BE:  MOVWF  FF7
0B2C0:  MOVLW  00
0B2C2:  MOVWF  FF8
0B2C4:  MOVLW  25
0B2C6:  MOVLB  9
0B2C8:  MOVWF  xE9
0B2CA:  MOVLB  0
0B2CC:  CALL   1C2C
0B2D0:  MOVLW  05
0B2D2:  MOVLB  3
0B2D4:  MOVWF  x17
0B2D6:  MOVLW  18
0B2D8:  MOVWF  x18
0B2DA:  MOVLB  0
0B2DC:  CALL   B02E
0B2E0:  MOVLW  BD
0B2E2:  MOVWF  FF6
0B2E4:  MOVLW  05
0B2E6:  MOVWF  FF7
0B2E8:  MOVLW  00
0B2EA:  MOVWF  FF8
0B2EC:  MOVLW  0B
0B2EE:  MOVLB  9
0B2F0:  MOVWF  xE9
0B2F2:  MOVLB  0
0B2F4:  CALL   1C2C
....................         // return; 
....................     }
0B2F8:  GOTO   BC46 (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0B300:  MOVLW  CA
0B302:  MOVWF  FF6
0B304:  MOVLW  05
0B306:  MOVWF  FF7
0B308:  MOVLW  00
0B30A:  MOVWF  FF8
0B30C:  CALL   1BF6
....................     fprintf(PC, "_____Start copy_data____\r\n");
0B310:  MOVLW  E4
0B312:  MOVWF  FF6
0B314:  MOVLW  05
0B316:  MOVWF  FF7
0B318:  MOVLW  00
0B31A:  MOVWF  FF8
0B31C:  CALL   1BF6
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
.................... 
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
0B320:  MOVLB  1
0B322:  MOVF   xBF,W
0B324:  MOVWF  FE9
0B326:  MOVF   xC0,W
0B328:  MOVWF  FEA
0B32A:  MOVFF  FEF,294
0B32E:  MOVFF  294,29B
0B332:  MOVLB  0
0B334:  CALL   AC18
0B338:  MOVFF  02,03
0B33C:  MOVF   01,W
0B33E:  MOVWF  FE1
0B340:  MOVFF  03,FE2
0B344:  MOVLW  02
0B346:  MOVWF  FEA
0B348:  MOVLW  01
0B34A:  MOVWF  FE9
0B34C:  MOVLW  08
0B34E:  MOVWF  01
0B350:  MOVFF  FE6,FEE
0B354:  DECFSZ 01,F
0B356:  GOTO   B350
0B35A:  MOVFF  204,20C
0B35E:  MOVFF  203,20B
0B362:  MOVFF  202,20A
0B366:  MOVFF  201,209
0B36A:  MOVFF  208,210
0B36E:  MOVFF  207,20F
0B372:  MOVFF  206,20E
0B376:  MOVFF  205,20D
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
0B37A:  MOVLW  03
0B37C:  MOVLB  1
0B37E:  ADDWF  xBF,W
0B380:  MOVWF  01
0B382:  MOVLW  00
0B384:  ADDWFC xC0,W
0B386:  MOVWF  03
0B388:  MOVF   01,W
0B38A:  MOVWF  FE9
0B38C:  MOVFF  03,FEA
0B390:  BTFSS  FEF.0
0B392:  BRA    B39A
0B394:  MOVLB  0
0B396:  GOTO   B410
0B39A:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
0B39C:  MOVLB  1
0B39E:  MOVF   xBF,W
0B3A0:  MOVWF  FE9
0B3A2:  MOVF   xC0,W
0B3A4:  MOVWF  FEA
0B3A6:  MOVFF  FEF,294
0B3AA:  MOVFF  294,29B
0B3AE:  MOVLB  0
0B3B0:  GOTO   ADA4
0B3B4:  MOVFF  02,03
0B3B8:  MOVF   01,W
0B3BA:  MOVWF  FE1
0B3BC:  MOVFF  03,FE2
0B3C0:  MOVLW  02
0B3C2:  MOVWF  FEA
0B3C4:  MOVLW  19
0B3C6:  MOVWF  FE9
0B3C8:  MOVLW  08
0B3CA:  MOVWF  01
0B3CC:  MOVFF  FE6,FEE
0B3D0:  DECFSZ 01,F
0B3D2:  GOTO   B3CC
....................         write_src = misf_address.start_address;
0B3D6:  MOVFF  21C,214
0B3DA:  MOVFF  21B,213
0B3DE:  MOVFF  21A,212
0B3E2:  MOVFF  219,211
....................         write_size = iv1_data_ptr->uncopied_counter;
0B3E6:  MOVLW  05
0B3E8:  MOVLB  1
0B3EA:  ADDWF  x2A,W
0B3EC:  MOVWF  FE9
0B3EE:  MOVLW  00
0B3F0:  ADDWFC x2B,W
0B3F2:  MOVWF  FEA
0B3F4:  MOVFF  FEF,215
0B3F8:  MOVFF  FEC,216
0B3FC:  MOVFF  FEC,217
0B400:  MOVFF  FEC,218
0B404:  MOVF   FED,F
0B406:  MOVF   FED,F
0B408:  MOVF   FED,F
0B40A:  MOVLB  0
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
0B40C:  GOTO   B47A
0B410:  MOVLW  03
0B412:  MOVLB  1
0B414:  ADDWF  xBF,W
0B416:  MOVWF  01
0B418:  MOVLW  00
0B41A:  ADDWFC xC0,W
0B41C:  MOVWF  03
0B41E:  MOVF   01,W
0B420:  MOVWF  FE9
0B422:  MOVFF  03,FEA
0B426:  BTFSC  FEF.0
0B428:  BRA    B430
0B42A:  MOVLB  0
0B42C:  GOTO   B47A
0B430:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
0B432:  MOVLW  04
0B434:  MOVLB  1
0B436:  ADDWF  xBF,W
0B438:  MOVWF  FE9
0B43A:  MOVLW  00
0B43C:  ADDWFC xC0,W
0B43E:  MOVWF  FEA
0B440:  MOVFF  FEF,211
0B444:  MOVFF  FEC,212
0B448:  MOVFF  FEC,213
0B44C:  MOVFF  FEC,214
0B450:  MOVF   FED,F
0B452:  MOVF   FED,F
0B454:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
0B456:  MOVLW  08
0B458:  ADDWF  xBF,W
0B45A:  MOVWF  FE9
0B45C:  MOVLW  00
0B45E:  ADDWFC xC0,W
0B460:  MOVWF  FEA
0B462:  MOVFF  FEF,215
0B466:  MOVFF  FEC,216
0B46A:  MOVFF  FEC,217
0B46E:  MOVFF  FEC,218
0B472:  MOVF   FED,F
0B474:  MOVF   FED,F
0B476:  MOVF   FED,F
0B478:  MOVLB  0
....................     }
.................... 
....................     // 接続確認
....................     if (!is_connect(mis_fm))
0B47A:  MOVFF  115,297
0B47E:  MOVFF  114,296
0B482:  MOVFF  113,295
0B486:  MOVFF  112,294
0B48A:  CALL   26E4
0B48E:  MOVF   01,F
0B490:  BTFSS  FD8.2
0B492:  GOTO   B4A6
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
0B496:  MOVLW  00
0B498:  MOVWF  FF6
0B49A:  MOVLW  06
0B49C:  MOVWF  FF7
0B49E:  MOVLW  00
0B4A0:  MOVWF  FF8
0B4A2:  CALL   1BF6
....................     }    
....................     if (!is_connect(smf))
0B4A6:  MOVFF  119,297
0B4AA:  MOVFF  118,296
0B4AE:  MOVFF  117,295
0B4B2:  MOVFF  116,294
0B4B6:  CALL   26E4
0B4BA:  MOVF   01,F
0B4BC:  BTFSS  FD8.2
0B4BE:  GOTO   B4D2
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0B4C2:  MOVLW  22
0B4C4:  MOVWF  FF6
0B4C6:  MOVLW  06
0B4C8:  MOVWF  FF7
0B4CA:  MOVLW  00
0B4CC:  MOVWF  FF8
0B4CE:  CALL   1BF6
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
0B4D2:  MOVLW  01
0B4D4:  MOVLB  2
0B4D6:  MOVWF  x95
0B4D8:  MOVLW  C1
0B4DA:  MOVWF  x94
0B4DC:  MOVLB  0
0B4DE:  GOTO   AEFA
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
0B4E2:  MOVFF  13B,224
0B4E6:  MOVFF  13A,223
0B4EA:  MOVFF  139,222
0B4EE:  MOVFF  138,221
0B4F2:  MOVFF  13C,225
....................     fprintf(PC, "Size area read\r\n");
0B4F6:  MOVLW  40
0B4F8:  MOVWF  FF6
0B4FA:  MOVLW  06
0B4FC:  MOVWF  FF7
0B4FE:  MOVLW  00
0B500:  MOVWF  FF8
0B502:  CALL   1BF6
....................     fprintf(PC, "smf_used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
0B506:  MOVLW  52
0B508:  MOVWF  FF6
0B50A:  MOVLW  06
0B50C:  MOVWF  FF7
0B50E:  MOVLW  00
0B510:  MOVWF  FF8
0B512:  MOVLW  10
0B514:  MOVLB  9
0B516:  MOVWF  xE9
0B518:  MOVLB  0
0B51A:  CALL   1C2C
0B51E:  MOVLW  41
0B520:  MOVWF  FE9
0B522:  MOVFF  224,297
0B526:  MOVFF  223,296
0B52A:  MOVFF  222,295
0B52E:  MOVFF  221,294
0B532:  CALL   AA92
0B536:  MOVLW  65
0B538:  MOVWF  FF6
0B53A:  MOVLW  06
0B53C:  MOVWF  FF7
0B53E:  MOVLW  00
0B540:  MOVWF  FF8
0B542:  MOVLW  08
0B544:  MOVLB  9
0B546:  MOVWF  xE9
0B548:  MOVLB  0
0B54A:  CALL   1C2C
0B54E:  MOVFF  20C,A48
0B552:  MOVLW  37
0B554:  MOVLB  A
0B556:  MOVWF  x49
0B558:  MOVLB  0
0B55A:  CALL   1E3C
0B55E:  MOVFF  20B,A48
0B562:  MOVLW  37
0B564:  MOVLB  A
0B566:  MOVWF  x49
0B568:  MOVLB  0
0B56A:  CALL   1E3C
0B56E:  MOVFF  20A,A48
0B572:  MOVLW  37
0B574:  MOVLB  A
0B576:  MOVWF  x49
0B578:  MOVLB  0
0B57A:  CALL   1E3C
0B57E:  MOVFF  209,A48
0B582:  MOVLW  37
0B584:  MOVLB  A
0B586:  MOVWF  x49
0B588:  MOVLB  0
0B58A:  CALL   1E3C
0B58E:  MOVLW  72
0B590:  MOVWF  FF6
0B592:  MOVLW  06
0B594:  MOVWF  FF7
0B596:  MOVLW  00
0B598:  MOVWF  FF8
0B59A:  MOVLW  03
0B59C:  MOVLB  9
0B59E:  MOVWF  xE9
0B5A0:  MOVLB  0
0B5A2:  CALL   1C2C
....................     fprintf(PC, "smf_loop count= %d  (src 0x%08LX)\r\n", loop_count, mis_start_address + 4);
0B5A6:  MOVLW  04
0B5A8:  MOVLB  2
0B5AA:  ADDWF  x09,W
0B5AC:  MOVWF  x94
0B5AE:  MOVLW  00
0B5B0:  ADDWFC x0A,W
0B5B2:  MOVWF  x95
0B5B4:  MOVLW  00
0B5B6:  ADDWFC x0B,W
0B5B8:  MOVWF  x96
0B5BA:  MOVLW  00
0B5BC:  ADDWFC x0C,W
0B5BE:  MOVWF  x97
0B5C0:  MOVLW  76
0B5C2:  MOVWF  FF6
0B5C4:  MOVLW  06
0B5C6:  MOVWF  FF7
0B5C8:  MOVLW  00
0B5CA:  MOVWF  FF8
0B5CC:  MOVLW  10
0B5CE:  MOVLB  9
0B5D0:  MOVWF  xE9
0B5D2:  MOVLB  0
0B5D4:  CALL   1C2C
0B5D8:  MOVFF  225,317
0B5DC:  MOVLW  18
0B5DE:  MOVLB  3
0B5E0:  MOVWF  x18
0B5E2:  MOVLB  0
0B5E4:  CALL   B02E
0B5E8:  MOVLW  88
0B5EA:  MOVWF  FF6
0B5EC:  MOVLW  06
0B5EE:  MOVWF  FF7
0B5F0:  MOVLW  00
0B5F2:  MOVWF  FF8
0B5F4:  MOVLW  09
0B5F6:  MOVLB  9
0B5F8:  MOVWF  xE9
0B5FA:  MOVLB  0
0B5FC:  CALL   1C2C
0B600:  MOVFF  297,A48
0B604:  MOVLW  37
0B606:  MOVLB  A
0B608:  MOVWF  x49
0B60A:  MOVLB  0
0B60C:  CALL   1E3C
0B610:  MOVFF  296,A48
0B614:  MOVLW  37
0B616:  MOVLB  A
0B618:  MOVWF  x49
0B61A:  MOVLB  0
0B61C:  CALL   1E3C
0B620:  MOVFF  295,A48
0B624:  MOVLW  37
0B626:  MOVLB  A
0B628:  MOVWF  x49
0B62A:  MOVLB  0
0B62C:  CALL   1E3C
0B630:  MOVFF  294,A48
0B634:  MOVLW  37
0B636:  MOVLB  A
0B638:  MOVWF  x49
0B63A:  MOVLB  0
0B63C:  CALL   1E3C
0B640:  MOVLW  96
0B642:  MOVWF  FF6
0B644:  MOVLW  06
0B646:  MOVWF  FF7
0B648:  MOVLW  00
0B64A:  MOVWF  FF8
0B64C:  MOVLW  03
0B64E:  MOVLB  9
0B650:  MOVWF  xE9
0B652:  MOVLB  0
0B654:  CALL   1C2C
....................     fprintf(PC, "misf_write_source = 0x%08LX\r\n", write_src);
0B658:  MOVLW  9A
0B65A:  MOVWF  FF6
0B65C:  MOVLW  06
0B65E:  MOVWF  FF7
0B660:  MOVLW  00
0B662:  MOVWF  FF8
0B664:  MOVLW  16
0B666:  MOVLB  9
0B668:  MOVWF  xE9
0B66A:  MOVLB  0
0B66C:  CALL   1C2C
0B670:  MOVFF  214,A48
0B674:  MOVLW  37
0B676:  MOVLB  A
0B678:  MOVWF  x49
0B67A:  MOVLB  0
0B67C:  CALL   1E3C
0B680:  MOVFF  213,A48
0B684:  MOVLW  37
0B686:  MOVLB  A
0B688:  MOVWF  x49
0B68A:  MOVLB  0
0B68C:  CALL   1E3C
0B690:  MOVFF  212,A48
0B694:  MOVLW  37
0B696:  MOVLB  A
0B698:  MOVWF  x49
0B69A:  MOVLB  0
0B69C:  CALL   1E3C
0B6A0:  MOVFF  211,A48
0B6A4:  MOVLW  37
0B6A6:  MOVLB  A
0B6A8:  MOVWF  x49
0B6AA:  MOVLB  0
0B6AC:  CALL   1E3C
0B6B0:  MOVLW  0D
0B6B2:  BTFSS  FA6.6
0B6B4:  GOTO   B6B2
0B6B8:  MOVLB  E
0B6BA:  MOVWF  xF9
0B6BC:  MOVLW  0A
0B6BE:  MOVLB  0
0B6C0:  BTFSS  FA6.6
0B6C2:  GOTO   B6C0
0B6C6:  MOVLB  E
0B6C8:  MOVWF  xF9
....................     fprintf(PC, "misf_write_size = 0x%08LX\r\n", write_size);
0B6CA:  MOVLW  B8
0B6CC:  MOVWF  FF6
0B6CE:  MOVLW  06
0B6D0:  MOVWF  FF7
0B6D2:  MOVLW  00
0B6D4:  MOVWF  FF8
0B6D6:  MOVLW  14
0B6D8:  MOVLB  9
0B6DA:  MOVWF  xE9
0B6DC:  MOVLB  0
0B6DE:  CALL   1C2C
0B6E2:  MOVFF  218,A48
0B6E6:  MOVLW  37
0B6E8:  MOVLB  A
0B6EA:  MOVWF  x49
0B6EC:  MOVLB  0
0B6EE:  CALL   1E3C
0B6F2:  MOVFF  217,A48
0B6F6:  MOVLW  37
0B6F8:  MOVLB  A
0B6FA:  MOVWF  x49
0B6FC:  MOVLB  0
0B6FE:  CALL   1E3C
0B702:  MOVFF  216,A48
0B706:  MOVLW  37
0B708:  MOVLB  A
0B70A:  MOVWF  x49
0B70C:  MOVLB  0
0B70E:  CALL   1E3C
0B712:  MOVFF  215,A48
0B716:  MOVLW  37
0B718:  MOVLB  A
0B71A:  MOVWF  x49
0B71C:  MOVLB  0
0B71E:  CALL   1E3C
0B722:  MOVLW  0D
0B724:  BTFSS  FA6.6
0B726:  GOTO   B724
0B72A:  MOVLB  E
0B72C:  MOVWF  xF9
0B72E:  MOVLW  0A
0B730:  MOVLB  0
0B732:  BTFSS  FA6.6
0B734:  GOTO   B732
0B738:  MOVLB  E
0B73A:  MOVWF  xF9
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
0B73C:  MOVLB  2
0B73E:  MOVF   x09,W
0B740:  MOVWF  x26
0B742:  MOVLW  10
0B744:  ADDWF  x0A,W
0B746:  MOVWF  x27
0B748:  MOVLW  00
0B74A:  ADDWFC x0B,W
0B74C:  MOVWF  x28
0B74E:  MOVLW  00
0B750:  ADDWFC x0C,W
0B752:  MOVWF  x29
0B754:  MOVFF  210,22D
0B758:  MOVFF  20F,22C
0B75C:  MOVFF  20E,22B
0B760:  MOVFF  20D,22A
0B764:  MOVF   x26,W
0B766:  SUBWF  x2A,W
0B768:  MOVWF  x2E
0B76A:  MOVF   x27,W
0B76C:  SUBWFB x2B,W
0B76E:  MOVWF  x2F
0B770:  MOVF   x28,W
0B772:  SUBWFB x2C,W
0B774:  MOVWF  x30
0B776:  MOVF   x29,W
0B778:  SUBWFB x2D,W
0B77A:  MOVWF  x31
0B77C:  MOVF   x21,W
0B77E:  ADDWF  x26,W
0B780:  MOVWF  x32
0B782:  MOVF   x22,W
0B784:  ADDWFC x27,W
0B786:  MOVWF  x33
0B788:  MOVF   x23,W
0B78A:  ADDWFC x28,W
0B78C:  MOVWF  x34
0B78E:  MOVF   x24,W
0B790:  ADDWFC x29,W
0B792:  MOVWF  x35
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
0B794:  MOVF   x15,W
0B796:  ADDWF  x21,W
0B798:  MOVWF  x94
0B79A:  MOVF   x16,W
0B79C:  ADDWFC x22,W
0B79E:  MOVWF  x95
0B7A0:  MOVF   x17,W
0B7A2:  ADDWFC x23,W
0B7A4:  MOVWF  x96
0B7A6:  MOVF   x18,W
0B7A8:  ADDWFC x24,W
0B7AA:  MOVWF  x97
0B7AC:  MOVF   x31,W
0B7AE:  SUBWF  x97,W
0B7B0:  BTFSC  FD8.0
0B7B2:  BRA    B7BA
0B7B4:  MOVLB  0
0B7B6:  GOTO   B8EA
0B7BA:  MOVLB  0
0B7BC:  BTFSS  FD8.2
0B7BE:  GOTO   B804
0B7C2:  MOVLB  2
0B7C4:  MOVF   x30,W
0B7C6:  SUBWF  x96,W
0B7C8:  BTFSC  FD8.0
0B7CA:  BRA    B7D2
0B7CC:  MOVLB  0
0B7CE:  GOTO   B8EA
0B7D2:  MOVLB  0
0B7D4:  BTFSS  FD8.2
0B7D6:  GOTO   B804
0B7DA:  MOVLB  2
0B7DC:  MOVF   x2F,W
0B7DE:  SUBWF  x95,W
0B7E0:  BTFSC  FD8.0
0B7E2:  BRA    B7EA
0B7E4:  MOVLB  0
0B7E6:  GOTO   B8EA
0B7EA:  MOVLB  0
0B7EC:  BTFSS  FD8.2
0B7EE:  GOTO   B804
0B7F2:  MOVLB  2
0B7F4:  MOVF   x94,W
0B7F6:  SUBWF  x2E,W
0B7F8:  BTFSS  FD8.0
0B7FA:  BRA    B802
0B7FC:  MOVLB  0
0B7FE:  GOTO   B8EA
0B802:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
0B804:  MOVLW  D4
0B806:  MOVWF  FF6
0B808:  MOVLW  06
0B80A:  MOVWF  FF7
0B80C:  MOVLW  00
0B80E:  MOVWF  FF8
0B810:  CALL   1BF6
....................         loop_count++;
0B814:  MOVLB  2
0B816:  INCF   x25,F
....................         used_size = 0;
0B818:  CLRF   x24
0B81A:  CLRF   x23
0B81C:  CLRF   x22
0B81E:  CLRF   x21
....................         data_write_addr = data_region_start;
0B820:  MOVFF  229,235
0B824:  MOVFF  228,234
0B828:  MOVFF  227,233
0B82C:  MOVFF  226,232
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
0B830:  MOVLB  1
0B832:  MOVF   xBF,W
0B834:  MOVWF  FE9
0B836:  MOVF   xC0,W
0B838:  MOVWF  FEA
0B83A:  MOVFF  FEF,294
0B83E:  MOVFF  294,295
0B842:  MOVLB  0
0B844:  GOTO   B164
....................         
....................         unsigned int32 erase_ptr = data_region_start;
0B848:  MOVFF  229,239
0B84C:  MOVFF  228,238
0B850:  MOVFF  227,237
0B854:  MOVFF  226,236
....................         while (erase_ptr < data_region_end)
0B858:  MOVLB  2
0B85A:  MOVF   x39,W
0B85C:  SUBWF  x2D,W
0B85E:  BTFSC  FD8.0
0B860:  BRA    B868
0B862:  MOVLB  0
0B864:  GOTO   B8EA
0B868:  MOVLB  0
0B86A:  BTFSS  FD8.2
0B86C:  GOTO   B8B2
0B870:  MOVLB  2
0B872:  MOVF   x38,W
0B874:  SUBWF  x2C,W
0B876:  BTFSC  FD8.0
0B878:  BRA    B880
0B87A:  MOVLB  0
0B87C:  GOTO   B8EA
0B880:  MOVLB  0
0B882:  BTFSS  FD8.2
0B884:  GOTO   B8B2
0B888:  MOVLB  2
0B88A:  MOVF   x37,W
0B88C:  SUBWF  x2B,W
0B88E:  BTFSC  FD8.0
0B890:  BRA    B898
0B892:  MOVLB  0
0B894:  GOTO   B8EA
0B898:  MOVLB  0
0B89A:  BTFSS  FD8.2
0B89C:  GOTO   B8B2
0B8A0:  MOVLB  2
0B8A2:  MOVF   x2A,W
0B8A4:  SUBWF  x36,W
0B8A6:  BTFSS  FD8.0
0B8A8:  BRA    B8B0
0B8AA:  MOVLB  0
0B8AC:  GOTO   B8EA
0B8B0:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
0B8B2:  MOVFF  119,319
0B8B6:  MOVFF  118,318
0B8BA:  MOVFF  117,317
0B8BE:  MOVFF  116,316
0B8C2:  MOVFF  239,31D
0B8C6:  MOVFF  238,31C
0B8CA:  MOVFF  237,31B
0B8CE:  MOVFF  236,31A
0B8D2:  CALL   5650
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
0B8D6:  MOVLW  10
0B8D8:  MOVLB  2
0B8DA:  ADDWF  x37,F
0B8DC:  MOVLW  00
0B8DE:  ADDWFC x38,F
0B8E0:  MOVLW  00
0B8E2:  ADDWFC x39,F
0B8E4:  MOVLB  0
0B8E6:  GOTO   B858
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
0B8EA:  MOVLB  2
0B8EC:  CLRF   x3A
0B8EE:  MOVF   x33,W
0B8F0:  ANDLW  F0
0B8F2:  MOVWF  x3B
0B8F4:  CLRF   x3C
0B8F6:  CLRF   x3D
0B8F8:  MOVF   x15,W
0B8FA:  ADDWF  x32,W
0B8FC:  MOVWF  x94
0B8FE:  MOVF   x16,W
0B900:  ADDWFC x33,W
0B902:  MOVWF  x95
0B904:  MOVF   x17,W
0B906:  ADDWFC x34,W
0B908:  MOVWF  x96
0B90A:  MOVF   x18,W
0B90C:  ADDWFC x35,W
0B90E:  MOVWF  x97
0B910:  MOVLW  FF
0B912:  ADDWF  x94,F
0B914:  MOVLW  0F
0B916:  ADDWFC x95,F
0B918:  MOVLW  00
0B91A:  ADDWFC x96,F
0B91C:  MOVLW  00
0B91E:  ADDWFC x97,F
0B920:  CLRF   x3E
0B922:  MOVF   x95,W
0B924:  ANDLW  F0
0B926:  MOVWF  x3F
0B928:  CLRF   x40
0B92A:  CLRF   x41
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
0B92C:  MOVFF  23D,245
0B930:  MOVFF  23C,244
0B934:  MOVFF  23B,243
0B938:  MOVFF  23A,242
0B93C:  MOVLB  0
0B93E:  MOVLB  2
0B940:  MOVF   x45,W
0B942:  SUBWF  x41,W
0B944:  BTFSC  FD8.0
0B946:  BRA    B94E
0B948:  MOVLB  0
0B94A:  GOTO   BA2A
0B94E:  MOVLB  0
0B950:  BTFSS  FD8.2
0B952:  GOTO   B998
0B956:  MOVLB  2
0B958:  MOVF   x44,W
0B95A:  SUBWF  x40,W
0B95C:  BTFSC  FD8.0
0B95E:  BRA    B966
0B960:  MOVLB  0
0B962:  GOTO   BA2A
0B966:  MOVLB  0
0B968:  BTFSS  FD8.2
0B96A:  GOTO   B998
0B96E:  MOVLB  2
0B970:  MOVF   x43,W
0B972:  SUBWF  x3F,W
0B974:  BTFSC  FD8.0
0B976:  BRA    B97E
0B978:  MOVLB  0
0B97A:  GOTO   BA2A
0B97E:  MOVLB  0
0B980:  BTFSS  FD8.2
0B982:  GOTO   B998
0B986:  MOVLB  2
0B988:  MOVF   x3E,W
0B98A:  SUBWF  x42,W
0B98C:  BTFSS  FD8.0
0B98E:  BRA    B996
0B990:  MOVLB  0
0B992:  GOTO   BA2A
0B996:  MOVLB  0
0B998:  MOVLB  2
0B99A:  MOVF   x45,W
0B99C:  SUBWF  x10,W
0B99E:  BTFSC  FD8.0
0B9A0:  BRA    B9A8
0B9A2:  MOVLB  0
0B9A4:  GOTO   BA2A
0B9A8:  MOVLB  0
0B9AA:  BTFSS  FD8.2
0B9AC:  GOTO   B9F2
0B9B0:  MOVLB  2
0B9B2:  MOVF   x44,W
0B9B4:  SUBWF  x0F,W
0B9B6:  BTFSC  FD8.0
0B9B8:  BRA    B9C0
0B9BA:  MOVLB  0
0B9BC:  GOTO   BA2A
0B9C0:  MOVLB  0
0B9C2:  BTFSS  FD8.2
0B9C4:  GOTO   B9F2
0B9C8:  MOVLB  2
0B9CA:  MOVF   x43,W
0B9CC:  SUBWF  x0E,W
0B9CE:  BTFSC  FD8.0
0B9D0:  BRA    B9D8
0B9D2:  MOVLB  0
0B9D4:  GOTO   BA2A
0B9D8:  MOVLB  0
0B9DA:  BTFSS  FD8.2
0B9DC:  GOTO   B9F2
0B9E0:  MOVLB  2
0B9E2:  MOVF   x0D,W
0B9E4:  SUBWF  x42,W
0B9E6:  BTFSS  FD8.0
0B9E8:  BRA    B9F0
0B9EA:  MOVLB  0
0B9EC:  GOTO   BA2A
0B9F0:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
0B9F2:  MOVFF  119,319
0B9F6:  MOVFF  118,318
0B9FA:  MOVFF  117,317
0B9FE:  MOVFF  116,316
0BA02:  MOVFF  245,31D
0BA06:  MOVFF  244,31C
0BA0A:  MOVFF  243,31B
0BA0E:  MOVFF  242,31A
0BA12:  CALL   5650
0BA16:  MOVLW  10
0BA18:  MOVLB  2
0BA1A:  ADDWF  x43,F
0BA1C:  MOVLW  00
0BA1E:  ADDWFC x44,F
0BA20:  MOVLW  00
0BA22:  ADDWFC x45,F
0BA24:  MOVLB  0
0BA26:  GOTO   B93E
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
0BA2A:  MOVFF  218,249
0BA2E:  MOVFF  217,248
0BA32:  MOVFF  216,247
0BA36:  MOVFF  215,246
0BA3A:  MOVFF  214,24D
0BA3E:  MOVFF  213,24C
0BA42:  MOVFF  212,24B
0BA46:  MOVFF  211,24A
....................     while (remaining > 0)
0BA4A:  MOVLB  2
0BA4C:  MOVF   x46,F
0BA4E:  BTFSC  FD8.2
0BA50:  BRA    BA58
0BA52:  MOVLB  0
0BA54:  GOTO   BA8A
0BA58:  MOVLB  0
0BA5A:  MOVLB  2
0BA5C:  MOVF   x47,F
0BA5E:  BTFSC  FD8.2
0BA60:  BRA    BA68
0BA62:  MOVLB  0
0BA64:  GOTO   BA8A
0BA68:  MOVLB  0
0BA6A:  MOVLB  2
0BA6C:  MOVF   x48,F
0BA6E:  BTFSC  FD8.2
0BA70:  BRA    BA78
0BA72:  MOVLB  0
0BA74:  GOTO   BA8A
0BA78:  MOVLB  0
0BA7A:  MOVLB  2
0BA7C:  MOVF   x49,F
0BA7E:  BTFSS  FD8.2
0BA80:  BRA    BA88
0BA82:  MOVLB  0
0BA84:  GOTO   BC42
0BA88:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
0BA8A:  MOVLB  2
0BA8C:  MOVF   x49,F
0BA8E:  BTFSC  FD8.2
0BA90:  BRA    BA98
0BA92:  MOVLB  0
0BA94:  GOTO   BACC
0BA98:  MOVLB  0
0BA9A:  MOVLB  2
0BA9C:  MOVF   x48,F
0BA9E:  BTFSC  FD8.2
0BAA0:  BRA    BAA8
0BAA2:  MOVLB  0
0BAA4:  GOTO   BACC
0BAA8:  MOVLB  0
0BAAA:  MOVLB  2
0BAAC:  MOVF   x47,F
0BAAE:  BTFSC  FD8.2
0BAB0:  BRA    BAB8
0BAB2:  MOVLB  0
0BAB4:  GOTO   BACC
0BAB8:  MOVLB  0
0BABA:  MOVLB  2
0BABC:  MOVF   x46,W
0BABE:  SUBLW  40
0BAC0:  BTFSS  FD8.0
0BAC2:  BRA    BACA
0BAC4:  MOVLB  0
0BAC6:  GOTO   BAD4
0BACA:  MOVLB  0
0BACC:  CLRF   03
0BACE:  MOVLW  40
0BAD0:  GOTO   BADE
0BAD4:  MOVFF  247,03
0BAD8:  MOVLB  2
0BADA:  MOVF   x46,W
0BADC:  MOVLB  0
0BADE:  MOVLB  2
0BAE0:  MOVWF  x8E
0BAE2:  MOVFF  03,28F
0BAE6:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
0BAE8:  MOVFF  115,319
0BAEC:  MOVFF  114,318
0BAF0:  MOVFF  113,317
0BAF4:  MOVFF  112,316
0BAF8:  MOVFF  24D,31D
0BAFC:  MOVFF  24C,31C
0BB00:  MOVFF  24B,31B
0BB04:  MOVFF  24A,31A
0BB08:  MOVLW  02
0BB0A:  MOVLB  3
0BB0C:  MOVWF  x1F
0BB0E:  MOVLW  4E
0BB10:  MOVWF  x1E
0BB12:  CLRF   x23
0BB14:  CLRF   x22
0BB16:  MOVFF  28F,321
0BB1A:  MOVFF  28E,320
0BB1E:  MOVLB  0
0BB20:  CALL   27D0
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
0BB24:  MOVFF  119,A8E
0BB28:  MOVFF  118,A8D
0BB2C:  MOVFF  117,A8C
0BB30:  MOVFF  116,A8B
0BB34:  MOVFF  235,A92
0BB38:  MOVFF  234,A91
0BB3C:  MOVFF  233,A90
0BB40:  MOVFF  232,A8F
0BB44:  MOVLW  02
0BB46:  MOVLB  A
0BB48:  MOVWF  x94
0BB4A:  MOVLW  4E
0BB4C:  MOVWF  x93
0BB4E:  MOVFF  28F,A96
0BB52:  MOVFF  28E,A95
0BB56:  MOVLB  0
0BB58:  CALL   3EC0
....................         for (unsigned int32 i = 0; i < chunk; i++)
0BB5C:  MOVLB  2
0BB5E:  CLRF   x93
0BB60:  CLRF   x92
0BB62:  CLRF   x91
0BB64:  CLRF   x90
0BB66:  MOVLB  0
0BB68:  MOVLB  2
0BB6A:  MOVF   x93,F
0BB6C:  BTFSC  FD8.2
0BB6E:  BRA    BB76
0BB70:  MOVLB  0
0BB72:  GOTO   BBFA
0BB76:  MOVLB  0
0BB78:  MOVLB  2
0BB7A:  MOVF   x92,F
0BB7C:  BTFSC  FD8.2
0BB7E:  BRA    BB86
0BB80:  MOVLB  0
0BB82:  GOTO   BBFA
0BB86:  MOVLB  0
0BB88:  MOVLB  2
0BB8A:  MOVF   x91,W
0BB8C:  SUBWF  x8F,W
0BB8E:  BTFSC  FD8.0
0BB90:  BRA    BB98
0BB92:  MOVLB  0
0BB94:  GOTO   BBFA
0BB98:  MOVLB  0
0BB9A:  BTFSS  FD8.2
0BB9C:  GOTO   BBB2
0BBA0:  MOVLB  2
0BBA2:  MOVF   x8E,W
0BBA4:  SUBWF  x90,W
0BBA6:  BTFSS  FD8.0
0BBA8:  BRA    BBB0
0BBAA:  MOVLB  0
0BBAC:  GOTO   BBFA
0BBB0:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0BBB2:  MOVLW  4E
0BBB4:  MOVLB  2
0BBB6:  ADDWF  x90,W
0BBB8:  MOVWF  FE9
0BBBA:  MOVLW  02
0BBBC:  ADDWFC x91,W
0BBBE:  MOVWF  FEA
0BBC0:  MOVFF  FEF,294
0BBC4:  MOVFF  294,A48
0BBC8:  MOVLW  37
0BBCA:  MOVLB  A
0BBCC:  MOVWF  x49
0BBCE:  MOVLB  0
0BBD0:  CALL   1E3C
0BBD4:  MOVLW  20
0BBD6:  BTFSS  FA6.6
0BBD8:  GOTO   BBD6
0BBDC:  MOVLB  E
0BBDE:  MOVWF  xF9
0BBE0:  MOVLB  0
0BBE2:  MOVLW  01
0BBE4:  MOVLB  2
0BBE6:  ADDWF  x90,F
0BBE8:  BTFSC  FD8.0
0BBEA:  INCF   x91,F
0BBEC:  BTFSC  FD8.2
0BBEE:  INCF   x92,F
0BBF0:  BTFSC  FD8.2
0BBF2:  INCF   x93,F
0BBF4:  MOVLB  0
0BBF6:  GOTO   BB68
....................         }
....................         src_addr += chunk;
0BBFA:  MOVLB  2
0BBFC:  MOVF   x8E,W
0BBFE:  ADDWF  x4A,F
0BC00:  MOVF   x8F,W
0BC02:  ADDWFC x4B,F
0BC04:  MOVLW  00
0BC06:  ADDWFC x4C,F
0BC08:  MOVLW  00
0BC0A:  ADDWFC x4D,F
....................         data_write_addr += chunk;
0BC0C:  MOVF   x8E,W
0BC0E:  ADDWF  x32,F
0BC10:  MOVF   x8F,W
0BC12:  ADDWFC x33,F
0BC14:  MOVLW  00
0BC16:  ADDWFC x34,F
0BC18:  MOVLW  00
0BC1A:  ADDWFC x35,F
....................         used_size += chunk;
0BC1C:  MOVF   x8E,W
0BC1E:  ADDWF  x21,F
0BC20:  MOVF   x8F,W
0BC22:  ADDWFC x22,F
0BC24:  MOVLW  00
0BC26:  ADDWFC x23,F
0BC28:  MOVLW  00
0BC2A:  ADDWFC x24,F
....................         remaining -= chunk;
0BC2C:  MOVF   x8E,W
0BC2E:  SUBWF  x46,F
0BC30:  MOVF   x8F,W
0BC32:  SUBWFB x47,F
0BC34:  MOVLW  00
0BC36:  SUBWFB x48,F
0BC38:  MOVLW  00
0BC3A:  SUBWFB x49,F
0BC3C:  MOVLB  0
0BC3E:  GOTO   BA4A
....................     }
....................     // write size area
....................     write_smf_header();
0BC42:  GOTO   B168
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0BC46:  MOVLB  1
0BC48:  MOVF   xBF,W
0BC4A:  MOVWF  FE9
0BC4C:  MOVF   xC0,W
0BC4E:  MOVWF  FEA
0BC50:  MOVFF  FEF,294
0BC54:  MOVFF  294,295
0BC58:  MOVFF  218,299
0BC5C:  MOVFF  217,298
0BC60:  MOVFF  216,297
0BC64:  MOVFF  215,296
0BC68:  MOVLB  0
0BC6A:  GOTO   B2FC
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0BC6E:  MOVLW  0A
0BC70:  MOVWF  FF6
0BC72:  MOVLW  07
0BC74:  MOVWF  FF7
0BC76:  MOVLW  00
0BC78:  MOVWF  FF8
0BC7A:  MOVLW  0C
0BC7C:  MOVLB  9
0BC7E:  MOVWF  xE9
0BC80:  MOVLB  0
0BC82:  CALL   1C2C
0BC86:  MOVLW  41
0BC88:  MOVWF  FE9
0BC8A:  MOVFF  224,297
0BC8E:  MOVFF  223,296
0BC92:  MOVFF  222,295
0BC96:  MOVFF  221,294
0BC9A:  CALL   AA92
0BC9E:  MOVLW  0D
0BCA0:  BTFSS  FA6.6
0BCA2:  GOTO   BCA0
0BCA6:  MOVLB  E
0BCA8:  MOVWF  xF9
0BCAA:  MOVLW  0A
0BCAC:  MOVLB  0
0BCAE:  BTFSS  FA6.6
0BCB0:  GOTO   BCAE
0BCB4:  MOVLB  E
0BCB6:  MOVWF  xF9
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0BCB8:  MOVLW  1C
0BCBA:  MOVWF  FF6
0BCBC:  MOVLW  07
0BCBE:  MOVWF  FF7
0BCC0:  MOVLW  00
0BCC2:  MOVWF  FF8
0BCC4:  MOVLW  0D
0BCC6:  MOVLB  9
0BCC8:  MOVWF  xE9
0BCCA:  MOVLB  0
0BCCC:  CALL   1C2C
0BCD0:  MOVFF  225,298
0BCD4:  MOVLW  1B
0BCD6:  MOVLB  2
0BCD8:  MOVWF  x99
0BCDA:  MOVLB  0
0BCDC:  CALL   A8FC
0BCE0:  MOVLW  2B
0BCE2:  MOVWF  FF6
0BCE4:  MOVLW  07
0BCE6:  MOVWF  FF7
0BCE8:  MOVLW  00
0BCEA:  MOVWF  FF8
0BCEC:  MOVLW  04
0BCEE:  MOVLB  9
0BCF0:  MOVWF  xE9
0BCF2:  MOVLB  0
0BCF4:  CALL   1C2C
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0BCF8:  MOVLW  30
0BCFA:  MOVWF  FF6
0BCFC:  MOVLW  07
0BCFE:  MOVWF  FF7
0BD00:  MOVLW  00
0BD02:  MOVWF  FF8
0BD04:  CALL   1BF6
....................     fprintf(PC, "____________________\r\n\r\n");
0BD08:  MOVLW  4A
0BD0A:  MOVWF  FF6
0BD0C:  MOVLW  07
0BD0E:  MOVWF  FF7
0BD10:  MOVLW  00
0BD12:  MOVWF  FF8
0BD14:  CALL   1BF6
0BD18:  GOTO   C904 (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0BE22:  MOVLW  64
0BE24:  MOVWF  FF6
0BE26:  MOVLW  07
0BE28:  MOVWF  FF7
0BE2A:  MOVLW  00
0BE2C:  MOVWF  FF8
0BE2E:  CALL   1BF6
....................     fprintf(PC, "___Start SMF Read____\r\n");
0BE32:  MOVLW  7E
0BE34:  MOVWF  FF6
0BE36:  MOVLW  07
0BE38:  MOVWF  FF7
0BE3A:  MOVLW  00
0BE3C:  MOVWF  FF8
0BE3E:  CALL   1BF6
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0BE42:  MOVLB  1
0BE44:  MOVF   xBF,W
0BE46:  MOVWF  FE9
0BE48:  MOVF   xC0,W
0BE4A:  MOVWF  FEA
0BE4C:  MOVFF  FEF,219
0BE50:  MOVFF  219,29B
0BE54:  MOVLB  0
0BE56:  CALL   AC18
0BE5A:  MOVFF  02,03
0BE5E:  MOVF   01,W
0BE60:  MOVWF  FE1
0BE62:  MOVFF  03,FE2
0BE66:  MOVLW  02
0BE68:  MOVWF  FEA
0BE6A:  MOVLW  01
0BE6C:  MOVWF  FE9
0BE6E:  MOVLW  08
0BE70:  MOVWF  01
0BE72:  MOVFF  FE6,FEE
0BE76:  DECFSZ 01,F
0BE78:  GOTO   BE72
0BE7C:  MOVLW  04
0BE7E:  MOVLB  1
0BE80:  ADDWF  xBF,W
0BE82:  MOVWF  FE9
0BE84:  MOVLW  00
0BE86:  ADDWFC xC0,W
0BE88:  MOVWF  FEA
0BE8A:  MOVFF  FEF,209
0BE8E:  MOVFF  FEC,20A
0BE92:  MOVFF  FEC,20B
0BE96:  MOVFF  FEC,20C
0BE9A:  MOVF   FED,F
0BE9C:  MOVF   FED,F
0BE9E:  MOVF   FED,F
0BEA0:  MOVLW  08
0BEA2:  ADDWF  xBF,W
0BEA4:  MOVWF  FE9
0BEA6:  MOVLW  00
0BEA8:  ADDWFC xC0,W
0BEAA:  MOVWF  FEA
0BEAC:  MOVFF  FEF,20D
0BEB0:  MOVFF  FEC,20E
0BEB4:  MOVFF  FEC,20F
0BEB8:  MOVFF  FEC,210
0BEBC:  MOVF   FED,F
0BEBE:  MOVF   FED,F
0BEC0:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0BEC2:  MOVLW  96
0BEC4:  MOVWF  FF6
0BEC6:  MOVLW  07
0BEC8:  MOVWF  FF7
0BECA:  MOVLW  00
0BECC:  MOVWF  FF8
0BECE:  MOVLW  21
0BED0:  MOVLB  9
0BED2:  MOVWF  xE9
0BED4:  MOVLB  0
0BED6:  CALL   1C2C
0BEDA:  MOVFF  20C,A48
0BEDE:  MOVLW  37
0BEE0:  MOVLB  A
0BEE2:  MOVWF  x49
0BEE4:  MOVLB  0
0BEE6:  CALL   1E3C
0BEEA:  MOVFF  20B,A48
0BEEE:  MOVLW  37
0BEF0:  MOVLB  A
0BEF2:  MOVWF  x49
0BEF4:  MOVLB  0
0BEF6:  CALL   1E3C
0BEFA:  MOVFF  20A,A48
0BEFE:  MOVLW  37
0BF00:  MOVLB  A
0BF02:  MOVWF  x49
0BF04:  MOVLB  0
0BF06:  CALL   1E3C
0BF0A:  MOVFF  209,A48
0BF0E:  MOVLW  37
0BF10:  MOVLB  A
0BF12:  MOVWF  x49
0BF14:  MOVLB  0
0BF16:  CALL   1E3C
0BF1A:  MOVLW  0D
0BF1C:  BTFSS  FA6.6
0BF1E:  GOTO   BF1C
0BF22:  MOVLB  E
0BF24:  MOVWF  xF9
0BF26:  MOVLW  0A
0BF28:  MOVLB  0
0BF2A:  BTFSS  FA6.6
0BF2C:  GOTO   BF2A
0BF30:  MOVLB  E
0BF32:  MOVWF  xF9
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0BF34:  MOVLW  BE
0BF36:  MOVWF  FF6
0BF38:  MOVLW  07
0BF3A:  MOVWF  FF7
0BF3C:  MOVLW  00
0BF3E:  MOVWF  FF8
0BF40:  MOVLW  21
0BF42:  MOVLB  9
0BF44:  MOVWF  xE9
0BF46:  MOVLB  0
0BF48:  CALL   1C2C
0BF4C:  MOVLW  41
0BF4E:  MOVWF  FE9
0BF50:  MOVFF  210,21C
0BF54:  MOVFF  20F,21B
0BF58:  MOVFF  20E,21A
0BF5C:  MOVFF  20D,219
0BF60:  CALL   BD1C
0BF64:  MOVLW  E2
0BF66:  MOVWF  FF6
0BF68:  MOVLW  07
0BF6A:  MOVWF  FF7
0BF6C:  MOVLW  00
0BF6E:  MOVWF  FF8
0BF70:  MOVLW  04
0BF72:  MOVLB  9
0BF74:  MOVWF  xE9
0BF76:  MOVLB  0
0BF78:  CALL   1C2C
0BF7C:  MOVFF  210,A48
0BF80:  MOVLW  57
0BF82:  MOVLB  A
0BF84:  MOVWF  x49
0BF86:  MOVLB  0
0BF88:  CALL   1E3C
0BF8C:  MOVFF  20F,A48
0BF90:  MOVLW  57
0BF92:  MOVLB  A
0BF94:  MOVWF  x49
0BF96:  MOVLB  0
0BF98:  CALL   1E3C
0BF9C:  MOVFF  20E,A48
0BFA0:  MOVLW  57
0BFA2:  MOVLB  A
0BFA4:  MOVWF  x49
0BFA6:  MOVLB  0
0BFA8:  CALL   1E3C
0BFAC:  MOVFF  20D,A48
0BFB0:  MOVLW  57
0BFB2:  MOVLB  A
0BFB4:  MOVWF  x49
0BFB6:  MOVLB  0
0BFB8:  CALL   1E3C
0BFBC:  MOVLW  E9
0BFBE:  MOVWF  FF6
0BFC0:  MOVLW  07
0BFC2:  MOVWF  FF7
0BFC4:  MOVLW  00
0BFC6:  MOVWF  FF8
0BFC8:  MOVLW  05
0BFCA:  MOVLB  9
0BFCC:  MOVWF  xE9
0BFCE:  MOVLB  0
0BFD0:  CALL   1C2C
.................... 
....................     if (!is_connect(smf)){
0BFD4:  MOVFF  119,297
0BFD8:  MOVFF  118,296
0BFDC:  MOVFF  117,295
0BFE0:  MOVFF  116,294
0BFE4:  CALL   26E4
0BFE8:  MOVF   01,F
0BFEA:  BTFSS  FD8.2
0BFEC:  GOTO   C000
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0BFF0:  MOVLW  F0
0BFF2:  MOVWF  FF6
0BFF4:  MOVLW  07
0BFF6:  MOVWF  FF7
0BFF8:  MOVLW  00
0BFFA:  MOVWF  FF8
0BFFC:  CALL   1BF6
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0C000:  MOVLW  0E
0C002:  MOVWF  FF6
0C004:  MOVLW  08
0C006:  MOVWF  FF7
0C008:  MOVLW  00
0C00A:  MOVWF  FF8
0C00C:  CALL   1BF6
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0C010:  MOVFF  20C,214
0C014:  MOVFF  20B,213
0C018:  MOVFF  20A,212
0C01C:  MOVFF  209,211
0C020:  MOVLB  2
0C022:  MOVF   x0D,W
0C024:  ADDWF  x09,W
0C026:  MOVWF  00
0C028:  MOVF   x0E,W
0C02A:  ADDWFC x0A,W
0C02C:  MOVWF  01
0C02E:  MOVF   x0F,W
0C030:  ADDWFC x0B,W
0C032:  MOVWF  02
0C034:  MOVF   x10,W
0C036:  ADDWFC x0C,W
0C038:  MOVWF  03
0C03A:  MOVF   x14,W
0C03C:  SUBWF  03,W
0C03E:  BTFSC  FD8.0
0C040:  BRA    C048
0C042:  MOVLB  0
0C044:  GOTO   C196
0C048:  MOVLB  0
0C04A:  BTFSS  FD8.2
0C04C:  GOTO   C092
0C050:  MOVLB  2
0C052:  MOVF   x13,W
0C054:  SUBWF  02,W
0C056:  BTFSC  FD8.0
0C058:  BRA    C060
0C05A:  MOVLB  0
0C05C:  GOTO   C196
0C060:  MOVLB  0
0C062:  BTFSS  FD8.2
0C064:  GOTO   C092
0C068:  MOVLB  2
0C06A:  MOVF   x12,W
0C06C:  SUBWF  01,W
0C06E:  BTFSC  FD8.0
0C070:  BRA    C078
0C072:  MOVLB  0
0C074:  GOTO   C196
0C078:  MOVLB  0
0C07A:  BTFSS  FD8.2
0C07C:  GOTO   C092
0C080:  MOVF   00,W
0C082:  MOVLB  2
0C084:  SUBWF  x11,W
0C086:  BTFSS  FD8.0
0C088:  BRA    C090
0C08A:  MOVLB  0
0C08C:  GOTO   C196
0C090:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0C092:  MOVFF  119,319
0C096:  MOVFF  118,318
0C09A:  MOVFF  117,317
0C09E:  MOVFF  116,316
0C0A2:  MOVFF  214,31D
0C0A6:  MOVFF  213,31C
0C0AA:  MOVFF  212,31B
0C0AE:  MOVFF  211,31A
0C0B2:  MOVLW  01
0C0B4:  MOVLB  3
0C0B6:  MOVWF  x1F
0C0B8:  MOVLW  C1
0C0BA:  MOVWF  x1E
0C0BC:  CLRF   x23
0C0BE:  CLRF   x22
0C0C0:  CLRF   x21
0C0C2:  MOVLW  40
0C0C4:  MOVWF  x20
0C0C6:  MOVLB  0
0C0C8:  CALL   27D0
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0C0CC:  MOVLB  2
0C0CE:  CLRF   x18
0C0D0:  CLRF   x17
0C0D2:  CLRF   x16
0C0D4:  CLRF   x15
0C0D6:  MOVLB  0
0C0D8:  MOVLB  2
0C0DA:  MOVF   x18,F
0C0DC:  BTFSC  FD8.2
0C0DE:  BRA    C0E6
0C0E0:  MOVLB  0
0C0E2:  GOTO   C162
0C0E6:  MOVLB  0
0C0E8:  MOVLB  2
0C0EA:  MOVF   x17,F
0C0EC:  BTFSC  FD8.2
0C0EE:  BRA    C0F6
0C0F0:  MOVLB  0
0C0F2:  GOTO   C162
0C0F6:  MOVLB  0
0C0F8:  MOVLB  2
0C0FA:  MOVF   x16,F
0C0FC:  BTFSC  FD8.2
0C0FE:  BRA    C106
0C100:  MOVLB  0
0C102:  GOTO   C162
0C106:  MOVLB  0
0C108:  MOVLB  2
0C10A:  MOVF   x15,W
0C10C:  SUBLW  3F
0C10E:  BTFSC  FD8.0
0C110:  BRA    C118
0C112:  MOVLB  0
0C114:  GOTO   C162
0C118:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0C11A:  MOVLW  C1
0C11C:  MOVLB  2
0C11E:  ADDWF  x15,W
0C120:  MOVWF  FE9
0C122:  MOVLW  01
0C124:  ADDWFC x16,W
0C126:  MOVWF  FEA
0C128:  MOVFF  FEF,219
0C12C:  MOVFF  219,A48
0C130:  MOVLW  37
0C132:  MOVLB  A
0C134:  MOVWF  x49
0C136:  MOVLB  0
0C138:  CALL   1E3C
0C13C:  MOVLW  20
0C13E:  BTFSS  FA6.6
0C140:  GOTO   C13E
0C144:  MOVLB  E
0C146:  MOVWF  xF9
0C148:  MOVLB  0
0C14A:  MOVLW  01
0C14C:  MOVLB  2
0C14E:  ADDWF  x15,F
0C150:  BTFSC  FD8.0
0C152:  INCF   x16,F
0C154:  BTFSC  FD8.2
0C156:  INCF   x17,F
0C158:  BTFSC  FD8.2
0C15A:  INCF   x18,F
0C15C:  MOVLB  0
0C15E:  GOTO   C0D8
....................         }
....................         fprintf(PC, "\r\n");
0C162:  MOVLW  0D
0C164:  BTFSS  FA6.6
0C166:  GOTO   C164
0C16A:  MOVLB  E
0C16C:  MOVWF  xF9
0C16E:  MOVLW  0A
0C170:  MOVLB  0
0C172:  BTFSS  FA6.6
0C174:  GOTO   C172
0C178:  MOVLB  E
0C17A:  MOVWF  xF9
0C17C:  MOVLB  0
0C17E:  MOVLW  40
0C180:  MOVLB  2
0C182:  ADDWF  x11,F
0C184:  MOVLW  00
0C186:  ADDWFC x12,F
0C188:  MOVLW  00
0C18A:  ADDWFC x13,F
0C18C:  MOVLW  00
0C18E:  ADDWFC x14,F
0C190:  MOVLB  0
0C192:  GOTO   C020
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0C196:  MOVLW  26
0C198:  MOVWF  FF6
0C19A:  MOVLW  08
0C19C:  MOVWF  FF7
0C19E:  MOVLW  00
0C1A0:  MOVWF  FF8
0C1A2:  CALL   1BF6
....................     fprintf(PC, "____________________\r\n\r\n");
0C1A6:  MOVLW  3E
0C1A8:  MOVWF  FF6
0C1AA:  MOVLW  08
0C1AC:  MOVWF  FF7
0C1AE:  MOVLW  00
0C1B0:  MOVWF  FF8
0C1B2:  CALL   1BF6
0C1B6:  GOTO   C914 (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0C1BA:  MOVLW  58
0C1BC:  MOVWF  FF6
0C1BE:  MOVLW  08
0C1C0:  MOVWF  FF7
0C1C2:  MOVLW  00
0C1C4:  MOVWF  FF8
0C1C6:  CALL   1BF6
....................     fprintf(PC, "___Start smf_erase____\r\n");
0C1CA:  MOVLW  72
0C1CC:  MOVWF  FF6
0C1CE:  MOVLW  08
0C1D0:  MOVWF  FF7
0C1D2:  MOVLW  00
0C1D4:  MOVWF  FF8
0C1D6:  CALL   1BF6
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0C1DA:  MOVLB  1
0C1DC:  MOVF   xBF,W
0C1DE:  MOVWF  FE9
0C1E0:  MOVF   xC0,W
0C1E2:  MOVWF  FEA
0C1E4:  MOVFF  FEF,1D1
0C1E8:  MOVFF  1D1,29B
0C1EC:  MOVLB  0
0C1EE:  CALL   AC18
0C1F2:  MOVFF  02,03
0C1F6:  MOVF   01,W
0C1F8:  MOVWF  FE1
0C1FA:  MOVFF  03,FE2
0C1FE:  MOVLW  01
0C200:  MOVWF  FEA
0C202:  MOVLW  C1
0C204:  MOVWF  FE9
0C206:  MOVLW  08
0C208:  MOVWF  01
0C20A:  MOVFF  FE6,FEE
0C20E:  DECFSZ 01,F
0C210:  GOTO   C20A
0C214:  MOVLW  04
0C216:  MOVLB  1
0C218:  ADDWF  xBF,W
0C21A:  MOVWF  FE9
0C21C:  MOVLW  00
0C21E:  ADDWFC xC0,W
0C220:  MOVWF  FEA
0C222:  MOVFF  FEF,1C9
0C226:  MOVFF  FEC,1CA
0C22A:  MOVFF  FEC,1CB
0C22E:  MOVFF  FEC,1CC
0C232:  MOVF   FED,F
0C234:  MOVF   FED,F
0C236:  MOVF   FED,F
0C238:  MOVLW  08
0C23A:  ADDWF  xBF,W
0C23C:  MOVWF  FE9
0C23E:  MOVLW  00
0C240:  ADDWFC xC0,W
0C242:  MOVWF  FEA
0C244:  MOVFF  FEF,1CD
0C248:  MOVFF  FEC,1CE
0C24C:  MOVFF  FEC,1CF
0C250:  MOVFF  FEC,1D0
0C254:  MOVF   FED,F
0C256:  MOVF   FED,F
0C258:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0C25A:  MOVLW  8C
0C25C:  MOVWF  FF6
0C25E:  MOVLW  08
0C260:  MOVWF  FF7
0C262:  MOVLW  00
0C264:  MOVWF  FF8
0C266:  MOVLW  22
0C268:  MOVLB  9
0C26A:  MOVWF  xE9
0C26C:  MOVLB  0
0C26E:  CALL   1C2C
0C272:  MOVFF  1CC,A48
0C276:  MOVLW  37
0C278:  MOVLB  A
0C27A:  MOVWF  x49
0C27C:  MOVLB  0
0C27E:  CALL   1E3C
0C282:  MOVFF  1CB,A48
0C286:  MOVLW  37
0C288:  MOVLB  A
0C28A:  MOVWF  x49
0C28C:  MOVLB  0
0C28E:  CALL   1E3C
0C292:  MOVFF  1CA,A48
0C296:  MOVLW  37
0C298:  MOVLB  A
0C29A:  MOVWF  x49
0C29C:  MOVLB  0
0C29E:  CALL   1E3C
0C2A2:  MOVFF  1C9,A48
0C2A6:  MOVLW  37
0C2A8:  MOVLB  A
0C2AA:  MOVWF  x49
0C2AC:  MOVLB  0
0C2AE:  CALL   1E3C
0C2B2:  MOVLW  0D
0C2B4:  BTFSS  FA6.6
0C2B6:  GOTO   C2B4
0C2BA:  MOVLB  E
0C2BC:  MOVWF  xF9
0C2BE:  MOVLW  0A
0C2C0:  MOVLB  0
0C2C2:  BTFSS  FA6.6
0C2C4:  GOTO   C2C2
0C2C8:  MOVLB  E
0C2CA:  MOVWF  xF9
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0C2CC:  MOVLW  B4
0C2CE:  MOVWF  FF6
0C2D0:  MOVLW  08
0C2D2:  MOVWF  FF7
0C2D4:  MOVLW  00
0C2D6:  MOVWF  FF8
0C2D8:  MOVLW  22
0C2DA:  MOVLB  9
0C2DC:  MOVWF  xE9
0C2DE:  MOVLB  0
0C2E0:  CALL   1C2C
0C2E4:  MOVLW  41
0C2E6:  MOVWF  FE9
0C2E8:  MOVFF  1D0,21C
0C2EC:  MOVFF  1CF,21B
0C2F0:  MOVFF  1CE,21A
0C2F4:  MOVFF  1CD,219
0C2F8:  CALL   BD1C
0C2FC:  MOVLW  D9
0C2FE:  MOVWF  FF6
0C300:  MOVLW  08
0C302:  MOVWF  FF7
0C304:  MOVLW  00
0C306:  MOVWF  FF8
0C308:  MOVLW  04
0C30A:  MOVLB  9
0C30C:  MOVWF  xE9
0C30E:  MOVLB  0
0C310:  CALL   1C2C
0C314:  MOVFF  1D0,A48
0C318:  MOVLW  57
0C31A:  MOVLB  A
0C31C:  MOVWF  x49
0C31E:  MOVLB  0
0C320:  CALL   1E3C
0C324:  MOVFF  1CF,A48
0C328:  MOVLW  57
0C32A:  MOVLB  A
0C32C:  MOVWF  x49
0C32E:  MOVLB  0
0C330:  CALL   1E3C
0C334:  MOVFF  1CE,A48
0C338:  MOVLW  57
0C33A:  MOVLB  A
0C33C:  MOVWF  x49
0C33E:  MOVLB  0
0C340:  CALL   1E3C
0C344:  MOVFF  1CD,A48
0C348:  MOVLW  57
0C34A:  MOVLB  A
0C34C:  MOVWF  x49
0C34E:  MOVLB  0
0C350:  CALL   1E3C
0C354:  MOVLW  E0
0C356:  MOVWF  FF6
0C358:  MOVLW  08
0C35A:  MOVWF  FF7
0C35C:  MOVLW  00
0C35E:  MOVWF  FF8
0C360:  MOVLW  05
0C362:  MOVLB  9
0C364:  MOVWF  xE9
0C366:  MOVLB  0
0C368:  CALL   1C2C
.................... 
....................     if (!is_connect(smf)){
0C36C:  MOVFF  119,297
0C370:  MOVFF  118,296
0C374:  MOVFF  117,295
0C378:  MOVFF  116,294
0C37C:  CALL   26E4
0C380:  MOVF   01,F
0C382:  BTFSS  FD8.2
0C384:  GOTO   C39C
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0C388:  MOVLW  E6
0C38A:  MOVWF  FF6
0C38C:  MOVLW  08
0C38E:  MOVWF  FF7
0C390:  MOVLW  00
0C392:  MOVWF  FF8
0C394:  CALL   1BF6
....................         return;
0C398:  GOTO   C6DA
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0C39C:  MOVLB  1
0C39E:  MOVF   xCC,W
0C3A0:  SUBWF  xC4,W
0C3A2:  BTFSC  FD8.0
0C3A4:  BRA    C3AC
0C3A6:  MOVLB  0
0C3A8:  GOTO   C3F6
0C3AC:  MOVLB  0
0C3AE:  BTFSS  FD8.2
0C3B0:  GOTO   C450
0C3B4:  MOVLB  1
0C3B6:  MOVF   xCB,W
0C3B8:  SUBWF  xC3,W
0C3BA:  BTFSC  FD8.0
0C3BC:  BRA    C3C4
0C3BE:  MOVLB  0
0C3C0:  GOTO   C3F6
0C3C4:  MOVLB  0
0C3C6:  BTFSS  FD8.2
0C3C8:  GOTO   C450
0C3CC:  MOVLB  1
0C3CE:  MOVF   xCA,W
0C3D0:  SUBWF  xC2,W
0C3D2:  BTFSC  FD8.0
0C3D4:  BRA    C3DC
0C3D6:  MOVLB  0
0C3D8:  GOTO   C3F6
0C3DC:  MOVLB  0
0C3DE:  BTFSS  FD8.2
0C3E0:  GOTO   C450
0C3E4:  MOVLB  1
0C3E6:  MOVF   xC1,W
0C3E8:  SUBWF  xC9,W
0C3EA:  BTFSC  FD8.0
0C3EC:  BRA    C3F4
0C3EE:  MOVLB  0
0C3F0:  GOTO   C450
0C3F4:  MOVLB  0
0C3F6:  MOVLB  1
0C3F8:  MOVF   xC8,W
0C3FA:  SUBWF  xCC,W
0C3FC:  BTFSC  FD8.0
0C3FE:  BRA    C406
0C400:  MOVLB  0
0C402:  GOTO   C574
0C406:  MOVLB  0
0C408:  BTFSS  FD8.2
0C40A:  GOTO   C450
0C40E:  MOVLB  1
0C410:  MOVF   xC7,W
0C412:  SUBWF  xCB,W
0C414:  BTFSC  FD8.0
0C416:  BRA    C41E
0C418:  MOVLB  0
0C41A:  GOTO   C574
0C41E:  MOVLB  0
0C420:  BTFSS  FD8.2
0C422:  GOTO   C450
0C426:  MOVLB  1
0C428:  MOVF   xC6,W
0C42A:  SUBWF  xCA,W
0C42C:  BTFSC  FD8.0
0C42E:  BRA    C436
0C430:  MOVLB  0
0C432:  GOTO   C574
0C436:  MOVLB  0
0C438:  BTFSS  FD8.2
0C43A:  GOTO   C450
0C43E:  MOVLB  1
0C440:  MOVF   xC5,W
0C442:  SUBWF  xC9,W
0C444:  BTFSC  FD8.0
0C446:  BRA    C44E
0C448:  MOVLB  0
0C44A:  GOTO   C574
0C44E:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0C450:  MOVLW  04
0C452:  MOVWF  FF6
0C454:  MOVLW  09
0C456:  MOVWF  FF7
0C458:  MOVLW  00
0C45A:  MOVWF  FF8
0C45C:  MOVLW  1E
0C45E:  MOVLB  9
0C460:  MOVWF  xE9
0C462:  MOVLB  0
0C464:  CALL   1C2C
0C468:  MOVFF  1CC,A48
0C46C:  MOVLW  37
0C46E:  MOVLB  A
0C470:  MOVWF  x49
0C472:  MOVLB  0
0C474:  CALL   1E3C
0C478:  MOVFF  1CB,A48
0C47C:  MOVLW  37
0C47E:  MOVLB  A
0C480:  MOVWF  x49
0C482:  MOVLB  0
0C484:  CALL   1E3C
0C488:  MOVFF  1CA,A48
0C48C:  MOVLW  37
0C48E:  MOVLB  A
0C490:  MOVWF  x49
0C492:  MOVLB  0
0C494:  CALL   1E3C
0C498:  MOVFF  1C9,A48
0C49C:  MOVLW  37
0C49E:  MOVLB  A
0C4A0:  MOVWF  x49
0C4A2:  MOVLB  0
0C4A4:  CALL   1E3C
0C4A8:  MOVLW  25
0C4AA:  MOVWF  FF6
0C4AC:  MOVLW  09
0C4AE:  MOVWF  FF7
0C4B0:  MOVLW  00
0C4B2:  MOVWF  FF8
0C4B4:  MOVLW  1D
0C4B6:  MOVLB  9
0C4B8:  MOVWF  xE9
0C4BA:  MOVLB  0
0C4BC:  CALL   1C2C
0C4C0:  MOVFF  1C4,A48
0C4C4:  MOVLW  37
0C4C6:  MOVLB  A
0C4C8:  MOVWF  x49
0C4CA:  MOVLB  0
0C4CC:  CALL   1E3C
0C4D0:  MOVFF  1C3,A48
0C4D4:  MOVLW  37
0C4D6:  MOVLB  A
0C4D8:  MOVWF  x49
0C4DA:  MOVLB  0
0C4DC:  CALL   1E3C
0C4E0:  MOVFF  1C2,A48
0C4E4:  MOVLW  37
0C4E6:  MOVLB  A
0C4E8:  MOVWF  x49
0C4EA:  MOVLB  0
0C4EC:  CALL   1E3C
0C4F0:  MOVFF  1C1,A48
0C4F4:  MOVLW  37
0C4F6:  MOVLB  A
0C4F8:  MOVWF  x49
0C4FA:  MOVLB  0
0C4FC:  CALL   1E3C
0C500:  MOVLW  45
0C502:  MOVWF  FF6
0C504:  MOVLW  09
0C506:  MOVWF  FF7
0C508:  MOVLW  00
0C50A:  MOVWF  FF8
0C50C:  MOVLW  05
0C50E:  MOVLB  9
0C510:  MOVWF  xE9
0C512:  MOVLB  0
0C514:  CALL   1C2C
0C518:  MOVFF  1C8,A48
0C51C:  MOVLW  37
0C51E:  MOVLB  A
0C520:  MOVWF  x49
0C522:  MOVLB  0
0C524:  CALL   1E3C
0C528:  MOVFF  1C7,A48
0C52C:  MOVLW  37
0C52E:  MOVLB  A
0C530:  MOVWF  x49
0C532:  MOVLB  0
0C534:  CALL   1E3C
0C538:  MOVFF  1C6,A48
0C53C:  MOVLW  37
0C53E:  MOVLB  A
0C540:  MOVWF  x49
0C542:  MOVLB  0
0C544:  CALL   1E3C
0C548:  MOVFF  1C5,A48
0C54C:  MOVLW  37
0C54E:  MOVLB  A
0C550:  MOVWF  x49
0C552:  MOVLB  0
0C554:  CALL   1E3C
0C558:  MOVLW  4D
0C55A:  MOVWF  FF6
0C55C:  MOVLW  09
0C55E:  MOVWF  FF7
0C560:  MOVLW  00
0C562:  MOVWF  FF8
0C564:  MOVLW  03
0C566:  MOVLB  9
0C568:  MOVWF  xE9
0C56A:  MOVLB  0
0C56C:  CALL   1C2C
....................         return;
0C570:  GOTO   C6DA
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0C574:  MOVLB  1
0C576:  MOVF   xCD,W
0C578:  ADDWF  xC9,W
0C57A:  MOVWF  xD1
0C57C:  MOVF   xCE,W
0C57E:  ADDWFC xCA,W
0C580:  MOVWF  xD2
0C582:  MOVF   xCF,W
0C584:  ADDWFC xCB,W
0C586:  MOVWF  xD3
0C588:  MOVF   xD0,W
0C58A:  ADDWFC xCC,W
0C58C:  MOVWF  xD4
0C58E:  MOVF   xC8,W
0C590:  SUBWF  xD4,W
0C592:  BTFSC  FD8.0
0C594:  BRA    C59C
0C596:  MOVLB  0
0C598:  GOTO   C686
0C59C:  MOVLB  0
0C59E:  BTFSS  FD8.2
0C5A0:  GOTO   C5E6
0C5A4:  MOVLB  1
0C5A6:  MOVF   xC7,W
0C5A8:  SUBWF  xD3,W
0C5AA:  BTFSC  FD8.0
0C5AC:  BRA    C5B4
0C5AE:  MOVLB  0
0C5B0:  GOTO   C686
0C5B4:  MOVLB  0
0C5B6:  BTFSS  FD8.2
0C5B8:  GOTO   C5E6
0C5BC:  MOVLB  1
0C5BE:  MOVF   xC6,W
0C5C0:  SUBWF  xD2,W
0C5C2:  BTFSC  FD8.0
0C5C4:  BRA    C5CC
0C5C6:  MOVLB  0
0C5C8:  GOTO   C686
0C5CC:  MOVLB  0
0C5CE:  BTFSS  FD8.2
0C5D0:  GOTO   C5E6
0C5D4:  MOVLB  1
0C5D6:  MOVF   xD1,W
0C5D8:  SUBWF  xC5,W
0C5DA:  BTFSS  FD8.0
0C5DC:  BRA    C5E4
0C5DE:  MOVLB  0
0C5E0:  GOTO   C686
0C5E4:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0C5E6:  MOVLW  52
0C5E8:  MOVWF  FF6
0C5EA:  MOVLW  09
0C5EC:  MOVWF  FF7
0C5EE:  MOVLW  00
0C5F0:  MOVWF  FF8
0C5F2:  MOVLW  3A
0C5F4:  MOVLB  9
0C5F6:  MOVWF  xE9
0C5F8:  MOVLB  0
0C5FA:  CALL   1C2C
0C5FE:  MOVFF  1C8,A48
0C602:  MOVLW  37
0C604:  MOVLB  A
0C606:  MOVWF  x49
0C608:  MOVLB  0
0C60A:  CALL   1E3C
0C60E:  MOVFF  1C7,A48
0C612:  MOVLW  37
0C614:  MOVLB  A
0C616:  MOVWF  x49
0C618:  MOVLB  0
0C61A:  CALL   1E3C
0C61E:  MOVFF  1C6,A48
0C622:  MOVLW  37
0C624:  MOVLB  A
0C626:  MOVWF  x49
0C628:  MOVLB  0
0C62A:  CALL   1E3C
0C62E:  MOVFF  1C5,A48
0C632:  MOVLW  37
0C634:  MOVLB  A
0C636:  MOVWF  x49
0C638:  MOVLB  0
0C63A:  CALL   1E3C
0C63E:  MOVLW  0D
0C640:  BTFSS  FA6.6
0C642:  GOTO   C640
0C646:  MOVLB  E
0C648:  MOVWF  xF9
0C64A:  MOVLW  0A
0C64C:  MOVLB  0
0C64E:  BTFSS  FA6.6
0C650:  GOTO   C64E
0C654:  MOVLB  E
0C656:  MOVWF  xF9
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0C658:  MOVLW  92
0C65A:  MOVWF  FF6
0C65C:  MOVLW  09
0C65E:  MOVWF  FF7
0C660:  MOVLW  00
0C662:  MOVWF  FF8
0C664:  MOVLB  0
0C666:  CALL   1BF6
....................         erase_size = mission_type.end_address - erase_address;
0C66A:  MOVLB  1
0C66C:  MOVF   xC9,W
0C66E:  SUBWF  xC5,W
0C670:  MOVWF  xCD
0C672:  MOVF   xCA,W
0C674:  SUBWFB xC6,W
0C676:  MOVWF  xCE
0C678:  MOVF   xCB,W
0C67A:  SUBWFB xC7,W
0C67C:  MOVWF  xCF
0C67E:  MOVF   xCC,W
0C680:  SUBWFB xC8,W
0C682:  MOVWF  xD0
0C684:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0C686:  MOVLW  C6
0C688:  MOVWF  FF6
0C68A:  MOVLW  09
0C68C:  MOVWF  FF7
0C68E:  MOVLW  00
0C690:  MOVWF  FF8
0C692:  CALL   1BF6
....................     subsector_4kByte_erase(smf, erase_address);
0C696:  MOVFF  119,319
0C69A:  MOVFF  118,318
0C69E:  MOVFF  117,317
0C6A2:  MOVFF  116,316
0C6A6:  MOVFF  1CC,31D
0C6AA:  MOVFF  1CB,31C
0C6AE:  MOVFF  1CA,31B
0C6B2:  MOVFF  1C9,31A
0C6B6:  CALL   5650
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0C6BA:  MOVLW  F8
0C6BC:  MOVWF  FF6
0C6BE:  MOVLW  09
0C6C0:  MOVWF  FF7
0C6C2:  MOVLW  00
0C6C4:  MOVWF  FF8
0C6C6:  CALL   1BF6
....................     fprintf(PC, "____________________\r\n\r\n");
0C6CA:  MOVLW  12
0C6CC:  MOVWF  FF6
0C6CE:  MOVLW  0A
0C6D0:  MOVWF  FF7
0C6D2:  MOVLW  00
0C6D4:  MOVWF  FF8
0C6D6:  CALL   1BF6
0C6DA:  GOTO   C924 (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
0B2FC:  GOTO   BC6E (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
0B164:  GOTO   B848 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "domain/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mt25q.h"                
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/tool/calc_tools.h"             
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../lib/tool/smf_queue.h"              
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... // 実体宣言
.................... Flash_t data_table = {FLASH_ID_DATA_TABLE, 0, 0, 0};
.................... Flash_t piclog_data = {FLASH_ID_PICLOG, 0, 0, 0};
.................... Flash_t environment_data = {FLASH_ID_ENVIRONMENT, 0, 0, 0};
.................... Flash_t iv1_header = {FLASH_ID_IV1_HEADER, 0, 0, 0};
.................... Flash_t iv1_data = {FLASH_ID_IV1_DATA, 0, 0, 0};
.................... Flash_t iv2_header = {FLASH_ID_IV2_HEADER, 0, 0, 0};
.................... Flash_t iv2_data = {FLASH_ID_IV2_DATA, 0, 0, 0};
.................... 
.................... // ポインタ設定
.................... Flash_t *data_table_ptr = &data_table;
.................... Flash_t *piclog_data_ptr = &piclog_data;
.................... Flash_t *environment_data_ptr = &environment_data;
.................... Flash_t *iv1_header_ptr = &iv1_header;
.................... Flash_t *iv1_data_ptr = &iv1_data;
.................... Flash_t *iv2_header_ptr = &iv2_header;
.................... Flash_t *iv2_data_ptr = &iv2_data;
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
032FC:  MOVLW  98
032FE:  MOVWF  FF6
03300:  MOVLW  0A
03302:  MOVWF  FF7
03304:  MOVLW  00
03306:  MOVWF  FF8
03308:  CALL   1BF6
....................     output_high(MIS_FM_CS);
0330C:  MOVLW  DB
0330E:  MOVWF  F92
03310:  BSF    F89.5
....................     output_high(SMF_CS);
03312:  MOVLW  DB
03314:  MOVWF  F92
03316:  BSF    F89.2
.................... 
....................     // 接続処理
....................     if (is_connect(mis_fm)) {
03318:  MOVFF  115,297
0331C:  MOVFF  114,296
03320:  MOVFF  113,295
03324:  MOVFF  112,294
03328:  CALL   26E4
0332C:  MOVF   01,F
0332E:  BTFSC  FD8.2
03330:  GOTO   3348
....................         fprintf(PC, "\t[MIS FM] Connected\r\n");
03334:  MOVLW  B4
03336:  MOVWF  FF6
03338:  MOVLW  0A
0333A:  MOVWF  FF7
0333C:  MOVLW  00
0333E:  MOVWF  FF8
03340:  CALL   1BF6
....................     } else {
03344:  GOTO   3358
....................         fprintf(PC, "\t[MIS FM] Not Connected\r\n");
03348:  MOVLW  CA
0334A:  MOVWF  FF6
0334C:  MOVLW  0A
0334E:  MOVWF  FF7
03350:  MOVLW  00
03352:  MOVWF  FF8
03354:  CALL   1BF6
....................     }
....................     if (is_connect(smf)) {
03358:  MOVFF  119,297
0335C:  MOVFF  118,296
03360:  MOVFF  117,295
03364:  MOVFF  116,294
03368:  CALL   26E4
0336C:  MOVF   01,F
0336E:  BTFSC  FD8.2
03370:  GOTO   3388
....................         fprintf(PC, "\t[SMF] Connected\r\n");
03374:  MOVLW  E4
03376:  MOVWF  FF6
03378:  MOVLW  0A
0337A:  MOVWF  FF7
0337C:  MOVLW  00
0337E:  MOVWF  FF8
03380:  CALL   1BF6
....................     } else {
03384:  GOTO   3398
....................         fprintf(PC, "\t[SMF] Not Connected\r\n");
03388:  MOVLW  F8
0338A:  MOVWF  FF6
0338C:  MOVLW  0A
0338E:  MOVWF  FF7
03390:  MOVLW  00
03392:  MOVWF  FF8
03394:  CALL   1BF6
....................     }
.................... 
....................     //=== MIS_FM カウンタテーブル読出し ===//
....................     FlashData_t read_header;
....................     FlashData_t *read_header_ptr = &read_header;
03398:  MOVLW  02
0339A:  MOVLB  2
0339C:  MOVWF  x48
0339E:  MOVLW  07
033A0:  MOVWF  x47
....................     memset(read_header_ptr, 0x00, sizeof(FlashData_t));
033A2:  MOVFF  248,FEA
033A6:  MOVFF  247,FE9
033AA:  CLRF   00
033AC:  CLRF   02
033AE:  MOVLW  40
033B0:  MOVWF  01
033B2:  MOVLB  0
033B4:  CALL   27AC
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, read_header_ptr->bytes, PACKET_SIZE);
033B8:  MOVLB  2
033BA:  MOVF   x47,W
033BC:  MOVWF  01
033BE:  MOVF   x48,W
033C0:  MOVWF  03
033C2:  MOVF   01,W
033C4:  MOVWF  x49
033C6:  MOVFF  03,24A
033CA:  MOVFF  115,319
033CE:  MOVFF  114,318
033D2:  MOVFF  113,317
033D6:  MOVFF  112,316
033DA:  MOVLB  3
033DC:  CLRF   x1D
033DE:  CLRF   x1C
033E0:  CLRF   x1B
033E2:  CLRF   x1A
033E4:  MOVFF  24A,31F
033E8:  MOVFF  249,31E
033EC:  CLRF   x23
033EE:  CLRF   x22
033F0:  CLRF   x21
033F2:  MOVLW  40
033F4:  MOVWF  x20
033F6:  MOVLB  0
033F8:  CALL   27D0
.................... 
....................     // CRC 検証
....................     if (read_header_ptr->packet.crc != calc_crc8(read_header_ptr->bytes, PACKET_SIZE - 1)) {
033FC:  MOVLW  3F
033FE:  MOVLB  2
03400:  ADDWF  x47,W
03402:  MOVWF  FE9
03404:  MOVLW  00
03406:  ADDWFC x48,W
03408:  MOVWF  FEA
0340A:  MOVFF  FEF,249
0340E:  MOVF   x47,W
03410:  MOVWF  01
03412:  MOVF   x48,W
03414:  MOVWF  03
03416:  MOVF   01,W
03418:  MOVWF  x4A
0341A:  MOVFF  03,24B
0341E:  MOVFF  24B,AEB
03422:  MOVFF  24A,AEA
03426:  MOVLW  3F
03428:  MOVLB  A
0342A:  MOVWF  xEC
0342C:  MOVLB  0
0342E:  CALL   29E8
03432:  MOVF   01,W
03434:  MOVLB  2
03436:  SUBWF  x49,W
03438:  BTFSS  FD8.2
0343A:  BRA    3442
0343C:  MOVLB  0
0343E:  GOTO   3454
03442:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error -> initialize counters\r\n");
03444:  MOVLW  10
03446:  MOVWF  FF6
03448:  MOVLW  0B
0344A:  MOVWF  FF7
0344C:  MOVLW  00
0344E:  MOVWF  FF8
03450:  CALL   1BF6
....................         // デフォルト初期化
....................         /*
....................         piclog_data.id        = FLASH_ID_PICLOG;
....................         environment_data.id   = FLASH_ID_ENVIRONMENT;
....................         iv_header.id          = FLASH_ID_IV_HEADER;
....................         iv_data.id            = FLASH_ID_IV_DATA;
....................         piclog_data.used_counter = 0;
....................         piclog_data.uncopied_counter = 0;
....................         environment_data.used_counter = 0;
....................         environment_data.uncopied_counter = 0;
....................         iv_header.used_counter = 0;
....................         iv_header.uncopied_counter = 0;
....................         iv_data.used_counter = 0;
....................         iv_data.uncopied_counter = 0;
....................         write_misf_address_area();   // 初期テーブル書込み
....................         print_flash_status();
....................         return;
....................         */
....................     }
....................     //=== 個別コピー (キャスト禁止) ===//
....................     // PICLOG
....................     piclog_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.piclog.used_counter;
03454:  MOVLW  01
03456:  MOVLB  1
03458:  ADDWF  x24,W
0345A:  MOVWF  01
0345C:  MOVLW  00
0345E:  ADDWFC x25,W
03460:  MOVWF  03
03462:  MOVF   01,W
03464:  MOVLB  2
03466:  MOVWF  x49
03468:  MOVFF  03,24A
0346C:  MOVF   x47,W
0346E:  MOVWF  FE9
03470:  MOVF   x48,W
03472:  MOVWF  FEA
03474:  MOVFF  FEF,00
03478:  MOVFF  FEC,01
0347C:  MOVFF  FEC,02
03480:  MOVFF  FEC,03
03484:  MOVF   FED,F
03486:  MOVF   FED,F
03488:  MOVF   FED,F
0348A:  MOVFF  03,24E
0348E:  MOVFF  02,24D
03492:  MOVFF  01,24C
03496:  MOVFF  00,24B
0349A:  MOVFF  24A,FEA
0349E:  MOVFF  249,FE9
034A2:  MOVFF  24B,FEF
034A6:  MOVFF  24C,FEC
034AA:  MOVFF  24D,FEC
034AE:  MOVFF  24E,FEC
034B2:  MOVF   FED,F
034B4:  MOVF   FED,F
034B6:  MOVF   FED,F
....................     piclog_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.piclog.uncopied_counter;
034B8:  MOVLW  05
034BA:  MOVLB  1
034BC:  ADDWF  x24,W
034BE:  MOVWF  01
034C0:  MOVLW  00
034C2:  ADDWFC x25,W
034C4:  MOVWF  03
034C6:  MOVF   01,W
034C8:  MOVLB  2
034CA:  MOVWF  x49
034CC:  MOVFF  03,24A
034D0:  MOVLW  04
034D2:  ADDWF  x47,W
034D4:  MOVWF  FE9
034D6:  MOVLW  00
034D8:  ADDWFC x48,W
034DA:  MOVWF  FEA
034DC:  MOVFF  FEF,00
034E0:  MOVFF  FEC,01
034E4:  MOVFF  FEC,02
034E8:  MOVFF  FEC,03
034EC:  MOVF   FED,F
034EE:  MOVF   FED,F
034F0:  MOVF   FED,F
034F2:  MOVFF  03,24E
034F6:  MOVFF  02,24D
034FA:  MOVFF  01,24C
034FE:  MOVFF  00,24B
03502:  MOVFF  24A,FEA
03506:  MOVFF  249,FE9
0350A:  MOVFF  24B,FEF
0350E:  MOVFF  24C,FEC
03512:  MOVFF  24D,FEC
03516:  MOVFF  24E,FEC
0351A:  MOVF   FED,F
0351C:  MOVF   FED,F
0351E:  MOVF   FED,F
....................     piclog_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.piclog.reserve_counter1;
03520:  MOVLW  09
03522:  MOVLB  1
03524:  ADDWF  x24,W
03526:  MOVWF  01
03528:  MOVLW  00
0352A:  ADDWFC x25,W
0352C:  MOVWF  03
0352E:  MOVF   01,W
03530:  MOVLB  2
03532:  MOVWF  x49
03534:  MOVFF  03,24A
03538:  MOVLW  08
0353A:  ADDWF  x47,W
0353C:  MOVWF  FE9
0353E:  MOVLW  00
03540:  ADDWFC x48,W
03542:  MOVWF  FEA
03544:  MOVF   FEF,W
03546:  MOVWF  x4B
03548:  MOVFF  24A,FEA
0354C:  MOVFF  249,FE9
03550:  MOVFF  24B,FEF
....................     piclog_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.piclog.reserve_counter2;
03554:  MOVLW  0A
03556:  MOVLB  1
03558:  ADDWF  x24,W
0355A:  MOVWF  01
0355C:  MOVLW  00
0355E:  ADDWFC x25,W
03560:  MOVWF  03
03562:  MOVF   01,W
03564:  MOVLB  2
03566:  MOVWF  x49
03568:  MOVFF  03,24A
0356C:  MOVLW  09
0356E:  ADDWF  x47,W
03570:  MOVWF  FE9
03572:  MOVLW  00
03574:  ADDWFC x48,W
03576:  MOVWF  FEA
03578:  MOVF   FEF,W
0357A:  MOVWF  x4B
0357C:  MOVFF  24A,FEA
03580:  MOVFF  249,FE9
03584:  MOVFF  24B,FEF
....................     // 環境データ
....................     environment_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.environment.used_counter;
03588:  MOVLW  01
0358A:  MOVLB  1
0358C:  ADDWF  x26,W
0358E:  MOVWF  01
03590:  MOVLW  00
03592:  ADDWFC x27,W
03594:  MOVWF  03
03596:  MOVF   01,W
03598:  MOVLB  2
0359A:  MOVWF  x49
0359C:  MOVFF  03,24A
035A0:  MOVLW  0A
035A2:  ADDWF  x47,W
035A4:  MOVWF  FE9
035A6:  MOVLW  00
035A8:  ADDWFC x48,W
035AA:  MOVWF  FEA
035AC:  MOVFF  FEF,00
035B0:  MOVFF  FEC,01
035B4:  MOVFF  FEC,02
035B8:  MOVFF  FEC,03
035BC:  MOVF   FED,F
035BE:  MOVF   FED,F
035C0:  MOVF   FED,F
035C2:  MOVFF  03,24E
035C6:  MOVFF  02,24D
035CA:  MOVFF  01,24C
035CE:  MOVFF  00,24B
035D2:  MOVFF  24A,FEA
035D6:  MOVFF  249,FE9
035DA:  MOVFF  24B,FEF
035DE:  MOVFF  24C,FEC
035E2:  MOVFF  24D,FEC
035E6:  MOVFF  24E,FEC
035EA:  MOVF   FED,F
035EC:  MOVF   FED,F
035EE:  MOVF   FED,F
....................     environment_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.environment.uncopied_counter;
035F0:  MOVLW  05
035F2:  MOVLB  1
035F4:  ADDWF  x26,W
035F6:  MOVWF  01
035F8:  MOVLW  00
035FA:  ADDWFC x27,W
035FC:  MOVWF  03
035FE:  MOVF   01,W
03600:  MOVLB  2
03602:  MOVWF  x49
03604:  MOVFF  03,24A
03608:  MOVLW  0E
0360A:  ADDWF  x47,W
0360C:  MOVWF  FE9
0360E:  MOVLW  00
03610:  ADDWFC x48,W
03612:  MOVWF  FEA
03614:  MOVFF  FEF,00
03618:  MOVFF  FEC,01
0361C:  MOVFF  FEC,02
03620:  MOVFF  FEC,03
03624:  MOVF   FED,F
03626:  MOVF   FED,F
03628:  MOVF   FED,F
0362A:  MOVFF  03,24E
0362E:  MOVFF  02,24D
03632:  MOVFF  01,24C
03636:  MOVFF  00,24B
0363A:  MOVFF  24A,FEA
0363E:  MOVFF  249,FE9
03642:  MOVFF  24B,FEF
03646:  MOVFF  24C,FEC
0364A:  MOVFF  24D,FEC
0364E:  MOVFF  24E,FEC
03652:  MOVF   FED,F
03654:  MOVF   FED,F
03656:  MOVF   FED,F
....................     environment_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.environment.reserve_counter1;
03658:  MOVLW  09
0365A:  MOVLB  1
0365C:  ADDWF  x26,W
0365E:  MOVWF  01
03660:  MOVLW  00
03662:  ADDWFC x27,W
03664:  MOVWF  03
03666:  MOVF   01,W
03668:  MOVLB  2
0366A:  MOVWF  x49
0366C:  MOVFF  03,24A
03670:  MOVLW  12
03672:  ADDWF  x47,W
03674:  MOVWF  FE9
03676:  MOVLW  00
03678:  ADDWFC x48,W
0367A:  MOVWF  FEA
0367C:  MOVF   FEF,W
0367E:  MOVWF  x4B
03680:  MOVFF  24A,FEA
03684:  MOVFF  249,FE9
03688:  MOVFF  24B,FEF
....................     environment_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.environment.reserve_counter2;
0368C:  MOVLW  0A
0368E:  MOVLB  1
03690:  ADDWF  x26,W
03692:  MOVWF  01
03694:  MOVLW  00
03696:  ADDWFC x27,W
03698:  MOVWF  03
0369A:  MOVF   01,W
0369C:  MOVLB  2
0369E:  MOVWF  x49
036A0:  MOVFF  03,24A
036A4:  MOVLW  13
036A6:  ADDWF  x47,W
036A8:  MOVWF  FE9
036AA:  MOVLW  00
036AC:  ADDWFC x48,W
036AE:  MOVWF  FEA
036B0:  MOVF   FEF,W
036B2:  MOVWF  x4B
036B4:  MOVFF  24A,FEA
036B8:  MOVFF  249,FE9
036BC:  MOVFF  24B,FEF
....................     // IV1 ヘッダ
....................     iv1_header_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv1_header.used_counter;
036C0:  MOVLW  01
036C2:  MOVLB  1
036C4:  ADDWF  x28,W
036C6:  MOVWF  01
036C8:  MOVLW  00
036CA:  ADDWFC x29,W
036CC:  MOVWF  03
036CE:  MOVF   01,W
036D0:  MOVLB  2
036D2:  MOVWF  x49
036D4:  MOVFF  03,24A
036D8:  MOVLW  14
036DA:  ADDWF  x47,W
036DC:  MOVWF  FE9
036DE:  MOVLW  00
036E0:  ADDWFC x48,W
036E2:  MOVWF  FEA
036E4:  MOVFF  FEF,00
036E8:  MOVFF  FEC,01
036EC:  MOVFF  FEC,02
036F0:  MOVFF  FEC,03
036F4:  MOVF   FED,F
036F6:  MOVF   FED,F
036F8:  MOVF   FED,F
036FA:  MOVFF  03,24E
036FE:  MOVFF  02,24D
03702:  MOVFF  01,24C
03706:  MOVFF  00,24B
0370A:  MOVFF  24A,FEA
0370E:  MOVFF  249,FE9
03712:  MOVFF  24B,FEF
03716:  MOVFF  24C,FEC
0371A:  MOVFF  24D,FEC
0371E:  MOVFF  24E,FEC
03722:  MOVF   FED,F
03724:  MOVF   FED,F
03726:  MOVF   FED,F
....................     iv1_header_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv1_header.uncopied_counter;
03728:  MOVLW  05
0372A:  MOVLB  1
0372C:  ADDWF  x28,W
0372E:  MOVWF  01
03730:  MOVLW  00
03732:  ADDWFC x29,W
03734:  MOVWF  03
03736:  MOVF   01,W
03738:  MOVLB  2
0373A:  MOVWF  x49
0373C:  MOVFF  03,24A
03740:  MOVLW  18
03742:  ADDWF  x47,W
03744:  MOVWF  FE9
03746:  MOVLW  00
03748:  ADDWFC x48,W
0374A:  MOVWF  FEA
0374C:  MOVFF  FEF,00
03750:  MOVFF  FEC,01
03754:  MOVFF  FEC,02
03758:  MOVFF  FEC,03
0375C:  MOVF   FED,F
0375E:  MOVF   FED,F
03760:  MOVF   FED,F
03762:  MOVFF  03,24E
03766:  MOVFF  02,24D
0376A:  MOVFF  01,24C
0376E:  MOVFF  00,24B
03772:  MOVFF  24A,FEA
03776:  MOVFF  249,FE9
0377A:  MOVFF  24B,FEF
0377E:  MOVFF  24C,FEC
03782:  MOVFF  24D,FEC
03786:  MOVFF  24E,FEC
0378A:  MOVF   FED,F
0378C:  MOVF   FED,F
0378E:  MOVF   FED,F
....................     iv1_header_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv1_header.reserve_counter1;
03790:  MOVLW  09
03792:  MOVLB  1
03794:  ADDWF  x28,W
03796:  MOVWF  01
03798:  MOVLW  00
0379A:  ADDWFC x29,W
0379C:  MOVWF  03
0379E:  MOVF   01,W
037A0:  MOVLB  2
037A2:  MOVWF  x49
037A4:  MOVFF  03,24A
037A8:  MOVLW  1C
037AA:  ADDWF  x47,W
037AC:  MOVWF  FE9
037AE:  MOVLW  00
037B0:  ADDWFC x48,W
037B2:  MOVWF  FEA
037B4:  MOVF   FEF,W
037B6:  MOVWF  x4B
037B8:  MOVFF  24A,FEA
037BC:  MOVFF  249,FE9
037C0:  MOVFF  24B,FEF
....................     iv1_header_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv1_header.reserve_counter2;
037C4:  MOVLW  0A
037C6:  MOVLB  1
037C8:  ADDWF  x28,W
037CA:  MOVWF  01
037CC:  MOVLW  00
037CE:  ADDWFC x29,W
037D0:  MOVWF  03
037D2:  MOVF   01,W
037D4:  MOVLB  2
037D6:  MOVWF  x49
037D8:  MOVFF  03,24A
037DC:  MOVLW  1D
037DE:  ADDWF  x47,W
037E0:  MOVWF  FE9
037E2:  MOVLW  00
037E4:  ADDWFC x48,W
037E6:  MOVWF  FEA
037E8:  MOVF   FEF,W
037EA:  MOVWF  x4B
037EC:  MOVFF  24A,FEA
037F0:  MOVFF  249,FE9
037F4:  MOVFF  24B,FEF
....................     // IV1 データ
....................     iv1_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv1_data.used_counter;
037F8:  MOVLW  01
037FA:  MOVLB  1
037FC:  ADDWF  x2A,W
037FE:  MOVWF  01
03800:  MOVLW  00
03802:  ADDWFC x2B,W
03804:  MOVWF  03
03806:  MOVF   01,W
03808:  MOVLB  2
0380A:  MOVWF  x49
0380C:  MOVFF  03,24A
03810:  MOVLW  1E
03812:  ADDWF  x47,W
03814:  MOVWF  FE9
03816:  MOVLW  00
03818:  ADDWFC x48,W
0381A:  MOVWF  FEA
0381C:  MOVFF  FEF,00
03820:  MOVFF  FEC,01
03824:  MOVFF  FEC,02
03828:  MOVFF  FEC,03
0382C:  MOVF   FED,F
0382E:  MOVF   FED,F
03830:  MOVF   FED,F
03832:  MOVFF  03,24E
03836:  MOVFF  02,24D
0383A:  MOVFF  01,24C
0383E:  MOVFF  00,24B
03842:  MOVFF  24A,FEA
03846:  MOVFF  249,FE9
0384A:  MOVFF  24B,FEF
0384E:  MOVFF  24C,FEC
03852:  MOVFF  24D,FEC
03856:  MOVFF  24E,FEC
0385A:  MOVF   FED,F
0385C:  MOVF   FED,F
0385E:  MOVF   FED,F
....................     iv1_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv1_data.uncopied_counter;
03860:  MOVLW  05
03862:  MOVLB  1
03864:  ADDWF  x2A,W
03866:  MOVWF  01
03868:  MOVLW  00
0386A:  ADDWFC x2B,W
0386C:  MOVWF  03
0386E:  MOVF   01,W
03870:  MOVLB  2
03872:  MOVWF  x49
03874:  MOVFF  03,24A
03878:  MOVLW  22
0387A:  ADDWF  x47,W
0387C:  MOVWF  FE9
0387E:  MOVLW  00
03880:  ADDWFC x48,W
03882:  MOVWF  FEA
03884:  MOVFF  FEF,00
03888:  MOVFF  FEC,01
0388C:  MOVFF  FEC,02
03890:  MOVFF  FEC,03
03894:  MOVF   FED,F
03896:  MOVF   FED,F
03898:  MOVF   FED,F
0389A:  MOVFF  03,24E
0389E:  MOVFF  02,24D
038A2:  MOVFF  01,24C
038A6:  MOVFF  00,24B
038AA:  MOVFF  24A,FEA
038AE:  MOVFF  249,FE9
038B2:  MOVFF  24B,FEF
038B6:  MOVFF  24C,FEC
038BA:  MOVFF  24D,FEC
038BE:  MOVFF  24E,FEC
038C2:  MOVF   FED,F
038C4:  MOVF   FED,F
038C6:  MOVF   FED,F
....................     iv1_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv1_data.reserve_counter1;
038C8:  MOVLW  09
038CA:  MOVLB  1
038CC:  ADDWF  x2A,W
038CE:  MOVWF  01
038D0:  MOVLW  00
038D2:  ADDWFC x2B,W
038D4:  MOVWF  03
038D6:  MOVF   01,W
038D8:  MOVLB  2
038DA:  MOVWF  x49
038DC:  MOVFF  03,24A
038E0:  MOVLW  26
038E2:  ADDWF  x47,W
038E4:  MOVWF  FE9
038E6:  MOVLW  00
038E8:  ADDWFC x48,W
038EA:  MOVWF  FEA
038EC:  MOVF   FEF,W
038EE:  MOVWF  x4B
038F0:  MOVFF  24A,FEA
038F4:  MOVFF  249,FE9
038F8:  MOVFF  24B,FEF
....................     iv1_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv1_data.reserve_counter2;
038FC:  MOVLW  0A
038FE:  MOVLB  1
03900:  ADDWF  x2A,W
03902:  MOVWF  01
03904:  MOVLW  00
03906:  ADDWFC x2B,W
03908:  MOVWF  03
0390A:  MOVF   01,W
0390C:  MOVLB  2
0390E:  MOVWF  x49
03910:  MOVFF  03,24A
03914:  MOVLW  27
03916:  ADDWF  x47,W
03918:  MOVWF  FE9
0391A:  MOVLW  00
0391C:  ADDWFC x48,W
0391E:  MOVWF  FEA
03920:  MOVF   FEF,W
03922:  MOVWF  x4B
03924:  MOVFF  24A,FEA
03928:  MOVFF  249,FE9
0392C:  MOVFF  24B,FEF
....................     // IV2 ヘッダ
....................     iv2_header_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv2_header.used_counter;
03930:  MOVLW  01
03932:  MOVLB  1
03934:  ADDWF  x2C,W
03936:  MOVWF  01
03938:  MOVLW  00
0393A:  ADDWFC x2D,W
0393C:  MOVWF  03
0393E:  MOVF   01,W
03940:  MOVLB  2
03942:  MOVWF  x49
03944:  MOVFF  03,24A
03948:  MOVLW  28
0394A:  ADDWF  x47,W
0394C:  MOVWF  FE9
0394E:  MOVLW  00
03950:  ADDWFC x48,W
03952:  MOVWF  FEA
03954:  MOVFF  FEF,00
03958:  MOVFF  FEC,01
0395C:  MOVFF  FEC,02
03960:  MOVFF  FEC,03
03964:  MOVF   FED,F
03966:  MOVF   FED,F
03968:  MOVF   FED,F
0396A:  MOVFF  03,24E
0396E:  MOVFF  02,24D
03972:  MOVFF  01,24C
03976:  MOVFF  00,24B
0397A:  MOVFF  24A,FEA
0397E:  MOVFF  249,FE9
03982:  MOVFF  24B,FEF
03986:  MOVFF  24C,FEC
0398A:  MOVFF  24D,FEC
0398E:  MOVFF  24E,FEC
03992:  MOVF   FED,F
03994:  MOVF   FED,F
03996:  MOVF   FED,F
....................     iv2_header_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv2_header.uncopied_counter;
03998:  MOVLW  05
0399A:  MOVLB  1
0399C:  ADDWF  x2C,W
0399E:  MOVWF  01
039A0:  MOVLW  00
039A2:  ADDWFC x2D,W
039A4:  MOVWF  03
039A6:  MOVF   01,W
039A8:  MOVLB  2
039AA:  MOVWF  x49
039AC:  MOVFF  03,24A
039B0:  MOVLW  2C
039B2:  ADDWF  x47,W
039B4:  MOVWF  FE9
039B6:  MOVLW  00
039B8:  ADDWFC x48,W
039BA:  MOVWF  FEA
039BC:  MOVFF  FEF,00
039C0:  MOVFF  FEC,01
039C4:  MOVFF  FEC,02
039C8:  MOVFF  FEC,03
039CC:  MOVF   FED,F
039CE:  MOVF   FED,F
039D0:  MOVF   FED,F
039D2:  MOVFF  03,24E
039D6:  MOVFF  02,24D
039DA:  MOVFF  01,24C
039DE:  MOVFF  00,24B
039E2:  MOVFF  24A,FEA
039E6:  MOVFF  249,FE9
039EA:  MOVFF  24B,FEF
039EE:  MOVFF  24C,FEC
039F2:  MOVFF  24D,FEC
039F6:  MOVFF  24E,FEC
039FA:  MOVF   FED,F
039FC:  MOVF   FED,F
039FE:  MOVF   FED,F
....................     iv2_header_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv2_header.reserve_counter1;
03A00:  MOVLW  09
03A02:  MOVLB  1
03A04:  ADDWF  x2C,W
03A06:  MOVWF  01
03A08:  MOVLW  00
03A0A:  ADDWFC x2D,W
03A0C:  MOVWF  03
03A0E:  MOVF   01,W
03A10:  MOVLB  2
03A12:  MOVWF  x49
03A14:  MOVFF  03,24A
03A18:  MOVLW  30
03A1A:  ADDWF  x47,W
03A1C:  MOVWF  FE9
03A1E:  MOVLW  00
03A20:  ADDWFC x48,W
03A22:  MOVWF  FEA
03A24:  MOVF   FEF,W
03A26:  MOVWF  x4B
03A28:  MOVFF  24A,FEA
03A2C:  MOVFF  249,FE9
03A30:  MOVFF  24B,FEF
....................     iv2_header_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv2_header.reserve_counter2;
03A34:  MOVLW  0A
03A36:  MOVLB  1
03A38:  ADDWF  x2C,W
03A3A:  MOVWF  01
03A3C:  MOVLW  00
03A3E:  ADDWFC x2D,W
03A40:  MOVWF  03
03A42:  MOVF   01,W
03A44:  MOVLB  2
03A46:  MOVWF  x49
03A48:  MOVFF  03,24A
03A4C:  MOVLW  31
03A4E:  ADDWF  x47,W
03A50:  MOVWF  FE9
03A52:  MOVLW  00
03A54:  ADDWFC x48,W
03A56:  MOVWF  FEA
03A58:  MOVF   FEF,W
03A5A:  MOVWF  x4B
03A5C:  MOVFF  24A,FEA
03A60:  MOVFF  249,FE9
03A64:  MOVFF  24B,FEF
....................     // IV2 データ
....................     iv2_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv2_data.used_counter;
03A68:  MOVLW  01
03A6A:  MOVLB  1
03A6C:  ADDWF  x2E,W
03A6E:  MOVWF  01
03A70:  MOVLW  00
03A72:  ADDWFC x2F,W
03A74:  MOVWF  03
03A76:  MOVF   01,W
03A78:  MOVLB  2
03A7A:  MOVWF  x49
03A7C:  MOVFF  03,24A
03A80:  MOVLW  32
03A82:  ADDWF  x47,W
03A84:  MOVWF  FE9
03A86:  MOVLW  00
03A88:  ADDWFC x48,W
03A8A:  MOVWF  FEA
03A8C:  MOVFF  FEF,00
03A90:  MOVFF  FEC,01
03A94:  MOVFF  FEC,02
03A98:  MOVFF  FEC,03
03A9C:  MOVF   FED,F
03A9E:  MOVF   FED,F
03AA0:  MOVF   FED,F
03AA2:  MOVFF  03,24E
03AA6:  MOVFF  02,24D
03AAA:  MOVFF  01,24C
03AAE:  MOVFF  00,24B
03AB2:  MOVFF  24A,FEA
03AB6:  MOVFF  249,FE9
03ABA:  MOVFF  24B,FEF
03ABE:  MOVFF  24C,FEC
03AC2:  MOVFF  24D,FEC
03AC6:  MOVFF  24E,FEC
03ACA:  MOVF   FED,F
03ACC:  MOVF   FED,F
03ACE:  MOVF   FED,F
....................     iv2_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv2_data.uncopied_counter;
03AD0:  MOVLW  05
03AD2:  MOVLB  1
03AD4:  ADDWF  x2E,W
03AD6:  MOVWF  01
03AD8:  MOVLW  00
03ADA:  ADDWFC x2F,W
03ADC:  MOVWF  03
03ADE:  MOVF   01,W
03AE0:  MOVLB  2
03AE2:  MOVWF  x49
03AE4:  MOVFF  03,24A
03AE8:  MOVLW  36
03AEA:  ADDWF  x47,W
03AEC:  MOVWF  FE9
03AEE:  MOVLW  00
03AF0:  ADDWFC x48,W
03AF2:  MOVWF  FEA
03AF4:  MOVFF  FEF,00
03AF8:  MOVFF  FEC,01
03AFC:  MOVFF  FEC,02
03B00:  MOVFF  FEC,03
03B04:  MOVF   FED,F
03B06:  MOVF   FED,F
03B08:  MOVF   FED,F
03B0A:  MOVFF  03,24E
03B0E:  MOVFF  02,24D
03B12:  MOVFF  01,24C
03B16:  MOVFF  00,24B
03B1A:  MOVFF  24A,FEA
03B1E:  MOVFF  249,FE9
03B22:  MOVFF  24B,FEF
03B26:  MOVFF  24C,FEC
03B2A:  MOVFF  24D,FEC
03B2E:  MOVFF  24E,FEC
03B32:  MOVF   FED,F
03B34:  MOVF   FED,F
03B36:  MOVF   FED,F
....................     iv2_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv2_data.reserve_counter1;
03B38:  MOVLW  09
03B3A:  MOVLB  1
03B3C:  ADDWF  x2E,W
03B3E:  MOVWF  01
03B40:  MOVLW  00
03B42:  ADDWFC x2F,W
03B44:  MOVWF  03
03B46:  MOVF   01,W
03B48:  MOVLB  2
03B4A:  MOVWF  x49
03B4C:  MOVFF  03,24A
03B50:  MOVLW  3A
03B52:  ADDWF  x47,W
03B54:  MOVWF  FE9
03B56:  MOVLW  00
03B58:  ADDWFC x48,W
03B5A:  MOVWF  FEA
03B5C:  MOVF   FEF,W
03B5E:  MOVWF  x4B
03B60:  MOVFF  24A,FEA
03B64:  MOVFF  249,FE9
03B68:  MOVFF  24B,FEF
....................     iv2_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv2_data.reserve_counter2;
03B6C:  MOVLW  0A
03B6E:  MOVLB  1
03B70:  ADDWF  x2E,W
03B72:  MOVWF  01
03B74:  MOVLW  00
03B76:  ADDWFC x2F,W
03B78:  MOVWF  03
03B7A:  MOVF   01,W
03B7C:  MOVLB  2
03B7E:  MOVWF  x49
03B80:  MOVFF  03,24A
03B84:  MOVLW  3B
03B86:  ADDWF  x47,W
03B88:  MOVWF  FE9
03B8A:  MOVLW  00
03B8C:  ADDWFC x48,W
03B8E:  MOVWF  FEA
03B90:  MOVF   FEF,W
03B92:  MOVWF  x4B
03B94:  MOVFF  24A,FEA
03B98:  MOVFF  249,FE9
03B9C:  MOVFF  24B,FEF
....................     
....................     print_flash_status();
03BA0:  MOVLB  0
03BA2:  GOTO   2A54
03BA6:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table()
*
04244:  MOVLW  0A
04246:  MOVLB  A
04248:  MOVWF  xD0
0424A:  MOVLW  8F
0424C:  MOVWF  xCF
.................... {
....................     FlashData_t flash_data;
....................     FlashData_t *flash_data_ptr = &flash_data;
....................     memset(flash_data_ptr->bytes, 0, sizeof(flash_data_ptr->bytes));
0424E:  MOVF   xCF,W
04250:  MOVWF  01
04252:  MOVF   xD0,W
04254:  MOVWF  03
04256:  MOVF   01,W
04258:  MOVWF  xEA
0425A:  MOVFF  03,AEB
0425E:  MOVFF  AEB,FEA
04262:  MOVFF  AEA,FE9
04266:  CLRF   00
04268:  CLRF   02
0426A:  MOVLW  40
0426C:  MOVWF  01
0426E:  MOVLB  0
04270:  CALL   27AC
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv1_header,
....................         &flash_data.packet.payload.logdata.iv1_data,
....................         &flash_data.packet.payload.logdata.iv2_header,
....................         &flash_data.packet.payload.logdata.iv2_data
....................     };
04274:  MOVLW  0A
04276:  MOVLB  A
04278:  MOVWF  xD2
0427A:  MOVLW  8F
0427C:  MOVWF  xD1
0427E:  MOVLW  0A
04280:  MOVWF  xD4
04282:  MOVLW  99
04284:  MOVWF  xD3
04286:  MOVLW  0A
04288:  MOVWF  xD6
0428A:  MOVLW  A3
0428C:  MOVWF  xD5
0428E:  MOVLW  0A
04290:  MOVWF  xD8
04292:  MOVLW  AD
04294:  MOVWF  xD7
04296:  MOVLW  0A
04298:  MOVWF  xDA
0429A:  MOVLW  B7
0429C:  MOVWF  xD9
0429E:  MOVLW  0A
042A0:  MOVWF  xDC
042A2:  MOVLW  C1
042A4:  MOVWF  xDB
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv1_header,
....................         &iv1_data,
....................         &iv2_header,
....................         &iv2_data
....................     };
042A6:  MOVLW  01
042A8:  MOVWF  xDE
042AA:  MOVLW  69
042AC:  MOVWF  xDD
042AE:  MOVLW  01
042B0:  MOVWF  xE0
042B2:  MOVLW  74
042B4:  MOVWF  xDF
042B6:  MOVLW  01
042B8:  MOVWF  xE2
042BA:  MOVLW  7F
042BC:  MOVWF  xE1
042BE:  MOVLW  01
042C0:  MOVWF  xE4
042C2:  MOVLW  8A
042C4:  MOVWF  xE3
042C6:  MOVLW  01
042C8:  MOVWF  xE6
042CA:  MOVLW  95
042CC:  MOVWF  xE5
042CE:  MOVLW  01
042D0:  MOVWF  xE8
042D2:  MOVLW  A0
042D4:  MOVWF  xE7
.................... 
....................     for (int i = 0; i < FLASH_ID_COUNT; i++) {
042D6:  CLRF   xE9
042D8:  MOVLB  0
042DA:  MOVLB  A
042DC:  MOVF   xE9,W
042DE:  SUBLW  06
042E0:  BTFSC  FD8.0
042E2:  BRA    42EA
042E4:  MOVLB  0
042E6:  GOTO   459E
042EA:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
042EC:  CLRF   03
042EE:  MOVLB  A
042F0:  MOVF   xE9,W
042F2:  MOVWF  02
042F4:  BCF    FD8.0
042F6:  RLCF   02,F
042F8:  RLCF   03,F
042FA:  MOVF   02,W
042FC:  ADDLW  D1
042FE:  MOVWF  01
04300:  MOVLW  0A
04302:  ADDWFC 03,F
04304:  MOVF   01,W
04306:  MOVWF  xEA
04308:  MOVFF  03,AEB
0430C:  MOVFF  AEB,FEA
04310:  MOVFF  AEA,FE9
04314:  MOVFF  FEC,AED
04318:  MOVF   FED,F
0431A:  MOVFF  FEF,AEC
0431E:  MOVF   xEC,W
04320:  MOVWF  01
04322:  MOVF   xED,W
04324:  MOVWF  03
04326:  MOVF   01,W
04328:  MOVWF  xEE
0432A:  MOVFF  03,AEF
0432E:  CLRF   03
04330:  MOVF   xE9,W
04332:  MOVWF  02
04334:  BCF    FD8.0
04336:  RLCF   02,F
04338:  RLCF   03,F
0433A:  MOVF   02,W
0433C:  ADDLW  DD
0433E:  MOVWF  01
04340:  MOVLW  0A
04342:  ADDWFC 03,F
04344:  MOVF   01,W
04346:  MOVWF  xF0
04348:  MOVFF  03,AF1
0434C:  MOVFF  AF1,FEA
04350:  MOVFF  AF0,FE9
04354:  MOVFF  FEC,AF3
04358:  MOVF   FED,F
0435A:  MOVFF  FEF,AF2
0435E:  MOVLW  01
04360:  ADDWF  xF2,W
04362:  MOVWF  FE9
04364:  MOVLW  00
04366:  ADDWFC xF3,W
04368:  MOVWF  FEA
0436A:  MOVFF  FEF,00
0436E:  MOVFF  FEC,01
04372:  MOVFF  FEC,02
04376:  MOVFF  FEC,03
0437A:  MOVF   FED,F
0437C:  MOVF   FED,F
0437E:  MOVF   FED,F
04380:  MOVFF  03,AF7
04384:  MOVFF  02,AF6
04388:  MOVFF  01,AF5
0438C:  MOVFF  00,AF4
04390:  MOVFF  AEF,FEA
04394:  MOVFF  AEE,FE9
04398:  MOVFF  AF4,FEF
0439C:  MOVFF  AF5,FEC
043A0:  MOVFF  AF6,FEC
043A4:  MOVFF  AF7,FEC
043A8:  MOVF   FED,F
043AA:  MOVF   FED,F
043AC:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
043AE:  CLRF   03
043B0:  MOVF   xE9,W
043B2:  MOVWF  02
043B4:  BCF    FD8.0
043B6:  RLCF   02,F
043B8:  RLCF   03,F
043BA:  MOVF   02,W
043BC:  ADDLW  D1
043BE:  MOVWF  01
043C0:  MOVLW  0A
043C2:  ADDWFC 03,F
043C4:  MOVF   01,W
043C6:  MOVWF  xEA
043C8:  MOVFF  03,AEB
043CC:  MOVFF  AEB,FEA
043D0:  MOVFF  AEA,FE9
043D4:  MOVFF  FEC,AED
043D8:  MOVF   FED,F
043DA:  MOVFF  FEF,AEC
043DE:  MOVLW  04
043E0:  ADDWF  xEC,W
043E2:  MOVWF  01
043E4:  MOVLW  00
043E6:  ADDWFC xED,W
043E8:  MOVWF  03
043EA:  MOVF   01,W
043EC:  MOVWF  xEE
043EE:  MOVFF  03,AEF
043F2:  CLRF   03
043F4:  MOVF   xE9,W
043F6:  MOVWF  02
043F8:  BCF    FD8.0
043FA:  RLCF   02,F
043FC:  RLCF   03,F
043FE:  MOVF   02,W
04400:  ADDLW  DD
04402:  MOVWF  01
04404:  MOVLW  0A
04406:  ADDWFC 03,F
04408:  MOVF   01,W
0440A:  MOVWF  xF0
0440C:  MOVFF  03,AF1
04410:  MOVFF  AF1,FEA
04414:  MOVFF  AF0,FE9
04418:  MOVFF  FEC,AF3
0441C:  MOVF   FED,F
0441E:  MOVFF  FEF,AF2
04422:  MOVLW  05
04424:  ADDWF  xF2,W
04426:  MOVWF  FE9
04428:  MOVLW  00
0442A:  ADDWFC xF3,W
0442C:  MOVWF  FEA
0442E:  MOVFF  FEF,00
04432:  MOVFF  FEC,01
04436:  MOVFF  FEC,02
0443A:  MOVFF  FEC,03
0443E:  MOVF   FED,F
04440:  MOVF   FED,F
04442:  MOVF   FED,F
04444:  MOVFF  03,AF7
04448:  MOVFF  02,AF6
0444C:  MOVFF  01,AF5
04450:  MOVFF  00,AF4
04454:  MOVFF  AEF,FEA
04458:  MOVFF  AEE,FE9
0445C:  MOVFF  AF4,FEF
04460:  MOVFF  AF5,FEC
04464:  MOVFF  AF6,FEC
04468:  MOVFF  AF7,FEC
0446C:  MOVF   FED,F
0446E:  MOVF   FED,F
04470:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
04472:  CLRF   03
04474:  MOVF   xE9,W
04476:  MOVWF  02
04478:  BCF    FD8.0
0447A:  RLCF   02,F
0447C:  RLCF   03,F
0447E:  MOVF   02,W
04480:  ADDLW  D1
04482:  MOVWF  01
04484:  MOVLW  0A
04486:  ADDWFC 03,F
04488:  MOVF   01,W
0448A:  MOVWF  xEA
0448C:  MOVFF  03,AEB
04490:  MOVFF  AEB,FEA
04494:  MOVFF  AEA,FE9
04498:  MOVFF  FEC,AED
0449C:  MOVF   FED,F
0449E:  MOVFF  FEF,AEC
044A2:  MOVLW  08
044A4:  ADDWF  xEC,W
044A6:  MOVWF  01
044A8:  MOVLW  00
044AA:  ADDWFC xED,W
044AC:  MOVWF  03
044AE:  MOVF   01,W
044B0:  MOVWF  xEE
044B2:  MOVFF  03,AEF
044B6:  CLRF   03
044B8:  MOVF   xE9,W
044BA:  MOVWF  02
044BC:  BCF    FD8.0
044BE:  RLCF   02,F
044C0:  RLCF   03,F
044C2:  MOVF   02,W
044C4:  ADDLW  DD
044C6:  MOVWF  01
044C8:  MOVLW  0A
044CA:  ADDWFC 03,F
044CC:  MOVF   01,W
044CE:  MOVWF  xF0
044D0:  MOVFF  03,AF1
044D4:  MOVFF  AF1,FEA
044D8:  MOVFF  AF0,FE9
044DC:  MOVFF  FEC,AF3
044E0:  MOVF   FED,F
044E2:  MOVFF  FEF,AF2
044E6:  MOVLW  09
044E8:  ADDWF  xF2,W
044EA:  MOVWF  FE9
044EC:  MOVLW  00
044EE:  ADDWFC xF3,W
044F0:  MOVWF  FEA
044F2:  MOVF   FEF,W
044F4:  MOVWF  xF4
044F6:  MOVFF  AEF,FEA
044FA:  MOVFF  AEE,FE9
044FE:  MOVFF  AF4,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
04502:  CLRF   03
04504:  MOVF   xE9,W
04506:  MOVWF  02
04508:  BCF    FD8.0
0450A:  RLCF   02,F
0450C:  RLCF   03,F
0450E:  MOVF   02,W
04510:  ADDLW  D1
04512:  MOVWF  01
04514:  MOVLW  0A
04516:  ADDWFC 03,F
04518:  MOVF   01,W
0451A:  MOVWF  xEA
0451C:  MOVFF  03,AEB
04520:  MOVFF  AEB,FEA
04524:  MOVFF  AEA,FE9
04528:  MOVFF  FEC,AED
0452C:  MOVF   FED,F
0452E:  MOVFF  FEF,AEC
04532:  MOVLW  09
04534:  ADDWF  xEC,W
04536:  MOVWF  01
04538:  MOVLW  00
0453A:  ADDWFC xED,W
0453C:  MOVWF  03
0453E:  MOVF   01,W
04540:  MOVWF  xEE
04542:  MOVFF  03,AEF
04546:  CLRF   03
04548:  MOVF   xE9,W
0454A:  MOVWF  02
0454C:  BCF    FD8.0
0454E:  RLCF   02,F
04550:  RLCF   03,F
04552:  MOVF   02,W
04554:  ADDLW  DD
04556:  MOVWF  01
04558:  MOVLW  0A
0455A:  ADDWFC 03,F
0455C:  MOVF   01,W
0455E:  MOVWF  xF0
04560:  MOVFF  03,AF1
04564:  MOVFF  AF1,FEA
04568:  MOVFF  AF0,FE9
0456C:  MOVFF  FEC,AF3
04570:  MOVF   FED,F
04572:  MOVFF  FEF,AF2
04576:  MOVLW  0A
04578:  ADDWF  xF2,W
0457A:  MOVWF  FE9
0457C:  MOVLW  00
0457E:  ADDWFC xF3,W
04580:  MOVWF  FEA
04582:  MOVF   FEF,W
04584:  MOVWF  xF4
04586:  MOVFF  AEF,FEA
0458A:  MOVFF  AEE,FE9
0458E:  MOVFF  AF4,FEF
04592:  MOVLB  0
04594:  MOVLB  A
04596:  INCF   xE9,F
04598:  MOVLB  0
0459A:  GOTO   42DA
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
0459E:  MOVLW  0A
045A0:  MOVLB  A
045A2:  MOVWF  xEB
045A4:  MOVLW  8F
045A6:  MOVWF  xEA
045A8:  MOVLW  3F
045AA:  MOVWF  xEC
045AC:  MOVLB  0
045AE:  CALL   29E8
045B2:  MOVFF  01,ACE
....................     fprintf(PC, "\r\n");
045B6:  MOVLW  0D
045B8:  BTFSS  FA6.6
045BA:  GOTO   45B8
045BE:  MOVLB  E
045C0:  MOVWF  xF9
045C2:  MOVLW  0A
045C4:  MOVLB  0
045C6:  BTFSS  FA6.6
045C8:  GOTO   45C6
045CC:  MOVLB  E
045CE:  MOVWF  xF9
....................     return flash_data;
045D0:  MOVLW  8F
045D2:  MOVWF  01
045D4:  MOVLW  0A
045D6:  MOVWF  02
045D8:  MOVLB  0
045DA:  RETURN 0
.................... }
.................... 
.................... 
.................... void write_misf_address_area(void)
*
04934:  CALL   4244
04938:  MOVFF  02,03
0493C:  MOVF   01,W
0493E:  MOVWF  FE1
04940:  MOVFF  03,FE2
04944:  MOVLW  0A
04946:  MOVWF  FEA
04948:  MOVLW  47
0494A:  MOVWF  FE9
0494C:  MOVLW  40
0494E:  MOVWF  01
04950:  MOVFF  FE6,FEE
04954:  DECFSZ 01,F
04956:  GOTO   4950
0495A:  MOVLW  0A
0495C:  MOVLB  A
0495E:  MOVWF  x88
04960:  MOVLW  47
04962:  MOVWF  x87
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
....................     FlashData_t *flash_data_ptr = &flash_data;
....................     sector_erase(mis_fm, MISF_CIGS_DATA_TABLE_START);
04964:  MOVFF  115,A8C
04968:  MOVFF  114,A8B
0496C:  MOVFF  113,A8A
04970:  MOVFF  112,A89
04974:  CLRF   x90
04976:  CLRF   x8F
04978:  CLRF   x8E
0497A:  CLRF   x8D
0497C:  MOVLB  0
0497E:  CALL   45DC
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data_ptr->bytes, PACKET_SIZE);
04982:  MOVLB  A
04984:  MOVF   x87,W
04986:  MOVWF  01
04988:  MOVF   x88,W
0498A:  MOVWF  03
0498C:  MOVF   01,W
0498E:  MOVWF  x89
04990:  MOVFF  03,A8A
04994:  MOVFF  115,A8E
04998:  MOVFF  114,A8D
0499C:  MOVFF  113,A8C
049A0:  MOVFF  112,A8B
049A4:  CLRF   x92
049A6:  CLRF   x91
049A8:  CLRF   x90
049AA:  CLRF   x8F
049AC:  MOVFF  A8A,A94
049B0:  MOVFF  A89,A93
049B4:  CLRF   x96
049B6:  MOVLW  40
049B8:  MOVWF  x95
049BA:  MOVLB  0
049BC:  CALL   3EC0
049C0:  RETURN 0
.................... }
.................... 
.................... // PICLOG 更新後に呼ばれる関数例 (piclog_write 内で既に write_misf_address_area 呼んでいる場合は不要)
.................... static void update_piclog_counters_after_write(unsigned int16 wrote_size)
.................... {
....................     piclog_data.used_counter     += wrote_size;
....................     piclog_data.uncopied_counter += wrote_size;
....................     // 必要なら wrap 処理追加
....................     write_misf_address_area();
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG     | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02A54:  MOVLW  3E
02A56:  MOVWF  FF6
02A58:  MOVLW  0B
02A5A:  MOVWF  FF7
02A5C:  MOVLW  00
02A5E:  MOVWF  FF8
02A60:  MOVLW  2C
02A62:  MOVLB  9
02A64:  MOVWF  xE9
02A66:  MOVLB  0
02A68:  CALL   1C2C
02A6C:  MOVFF  16D,A48
02A70:  MOVLW  37
02A72:  MOVLB  A
02A74:  MOVWF  x49
02A76:  MOVLB  0
02A78:  CALL   1E3C
02A7C:  MOVFF  16C,A48
02A80:  MOVLW  37
02A82:  MOVLB  A
02A84:  MOVWF  x49
02A86:  MOVLB  0
02A88:  CALL   1E3C
02A8C:  MOVFF  16B,A48
02A90:  MOVLW  37
02A92:  MOVLB  A
02A94:  MOVWF  x49
02A96:  MOVLB  0
02A98:  CALL   1E3C
02A9C:  MOVFF  16A,A48
02AA0:  MOVLW  37
02AA2:  MOVLB  A
02AA4:  MOVWF  x49
02AA6:  MOVLB  0
02AA8:  CALL   1E3C
02AAC:  MOVLW  0D
02AAE:  BTFSS  FA6.6
02AB0:  GOTO   2AAE
02AB4:  MOVLB  E
02AB6:  MOVWF  xF9
02AB8:  MOVLW  0A
02ABA:  MOVLB  0
02ABC:  BTFSS  FA6.6
02ABE:  GOTO   2ABC
02AC2:  MOVLB  E
02AC4:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | PICLOG     | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02AC6:  MOVLW  72
02AC8:  MOVWF  FF6
02ACA:  MOVLW  0B
02ACC:  MOVWF  FF7
02ACE:  MOVLW  00
02AD0:  MOVWF  FF8
02AD2:  MOVLW  2C
02AD4:  MOVLB  9
02AD6:  MOVWF  xE9
02AD8:  MOVLB  0
02ADA:  CALL   1C2C
02ADE:  MOVFF  171,A48
02AE2:  MOVLW  37
02AE4:  MOVLB  A
02AE6:  MOVWF  x49
02AE8:  MOVLB  0
02AEA:  CALL   1E3C
02AEE:  MOVFF  170,A48
02AF2:  MOVLW  37
02AF4:  MOVLB  A
02AF6:  MOVWF  x49
02AF8:  MOVLB  0
02AFA:  CALL   1E3C
02AFE:  MOVFF  16F,A48
02B02:  MOVLW  37
02B04:  MOVLB  A
02B06:  MOVWF  x49
02B08:  MOVLB  0
02B0A:  CALL   1E3C
02B0E:  MOVFF  16E,A48
02B12:  MOVLW  37
02B14:  MOVLB  A
02B16:  MOVWF  x49
02B18:  MOVLB  0
02B1A:  CALL   1E3C
02B1E:  MOVLW  0D
02B20:  BTFSS  FA6.6
02B22:  GOTO   2B20
02B26:  MOVLB  E
02B28:  MOVWF  xF9
02B2A:  MOVLW  0A
02B2C:  MOVLB  0
02B2E:  BTFSS  FA6.6
02B30:  GOTO   2B2E
02B34:  MOVLB  E
02B36:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | PICLOG     | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02B38:  MOVLW  A6
02B3A:  MOVWF  FF6
02B3C:  MOVLW  0B
02B3E:  MOVWF  FF7
02B40:  MOVLW  00
02B42:  MOVWF  FF8
02B44:  MOVLW  2C
02B46:  MOVLB  9
02B48:  MOVWF  xE9
02B4A:  MOVLB  0
02B4C:  CALL   1C2C
02B50:  MOVFF  172,A48
02B54:  MOVLW  37
02B56:  MOVLB  A
02B58:  MOVWF  x49
02B5A:  MOVLB  0
02B5C:  CALL   1E3C
02B60:  MOVLW  0D
02B62:  BTFSS  FA6.6
02B64:  GOTO   2B62
02B68:  MOVLB  E
02B6A:  MOVWF  xF9
02B6C:  MOVLW  0A
02B6E:  MOVLB  0
02B70:  BTFSS  FA6.6
02B72:  GOTO   2B70
02B76:  MOVLB  E
02B78:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | PICLOG     | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02B7A:  MOVLW  DA
02B7C:  MOVWF  FF6
02B7E:  MOVLW  0B
02B80:  MOVWF  FF7
02B82:  MOVLW  00
02B84:  MOVWF  FF8
02B86:  MOVLW  2C
02B88:  MOVLB  9
02B8A:  MOVWF  xE9
02B8C:  MOVLB  0
02B8E:  CALL   1C2C
02B92:  MOVFF  173,A48
02B96:  MOVLW  37
02B98:  MOVLB  A
02B9A:  MOVWF  x49
02B9C:  MOVLB  0
02B9E:  CALL   1E3C
02BA2:  MOVLW  0D
02BA4:  BTFSS  FA6.6
02BA6:  GOTO   2BA4
02BAA:  MOVLB  E
02BAC:  MOVWF  xF9
02BAE:  MOVLW  0A
02BB0:  MOVLB  0
02BB2:  BTFSS  FA6.6
02BB4:  GOTO   2BB2
02BB8:  MOVLB  E
02BBA:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | ENVIRO     | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02BBC:  MOVLW  0E
02BBE:  MOVWF  FF6
02BC0:  MOVLW  0C
02BC2:  MOVWF  FF7
02BC4:  MOVLW  00
02BC6:  MOVWF  FF8
02BC8:  MOVLW  2C
02BCA:  MOVLB  9
02BCC:  MOVWF  xE9
02BCE:  MOVLB  0
02BD0:  CALL   1C2C
02BD4:  MOVFF  178,A48
02BD8:  MOVLW  37
02BDA:  MOVLB  A
02BDC:  MOVWF  x49
02BDE:  MOVLB  0
02BE0:  CALL   1E3C
02BE4:  MOVFF  177,A48
02BE8:  MOVLW  37
02BEA:  MOVLB  A
02BEC:  MOVWF  x49
02BEE:  MOVLB  0
02BF0:  CALL   1E3C
02BF4:  MOVFF  176,A48
02BF8:  MOVLW  37
02BFA:  MOVLB  A
02BFC:  MOVWF  x49
02BFE:  MOVLB  0
02C00:  CALL   1E3C
02C04:  MOVFF  175,A48
02C08:  MOVLW  37
02C0A:  MOVLB  A
02C0C:  MOVWF  x49
02C0E:  MOVLB  0
02C10:  CALL   1E3C
02C14:  MOVLW  0D
02C16:  BTFSS  FA6.6
02C18:  GOTO   2C16
02C1C:  MOVLB  E
02C1E:  MOVWF  xF9
02C20:  MOVLW  0A
02C22:  MOVLB  0
02C24:  BTFSS  FA6.6
02C26:  GOTO   2C24
02C2A:  MOVLB  E
02C2C:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | ENVIRO     | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02C2E:  MOVLW  42
02C30:  MOVWF  FF6
02C32:  MOVLW  0C
02C34:  MOVWF  FF7
02C36:  MOVLW  00
02C38:  MOVWF  FF8
02C3A:  MOVLW  2C
02C3C:  MOVLB  9
02C3E:  MOVWF  xE9
02C40:  MOVLB  0
02C42:  CALL   1C2C
02C46:  MOVFF  17C,A48
02C4A:  MOVLW  37
02C4C:  MOVLB  A
02C4E:  MOVWF  x49
02C50:  MOVLB  0
02C52:  CALL   1E3C
02C56:  MOVFF  17B,A48
02C5A:  MOVLW  37
02C5C:  MOVLB  A
02C5E:  MOVWF  x49
02C60:  MOVLB  0
02C62:  CALL   1E3C
02C66:  MOVFF  17A,A48
02C6A:  MOVLW  37
02C6C:  MOVLB  A
02C6E:  MOVWF  x49
02C70:  MOVLB  0
02C72:  CALL   1E3C
02C76:  MOVFF  179,A48
02C7A:  MOVLW  37
02C7C:  MOVLB  A
02C7E:  MOVWF  x49
02C80:  MOVLB  0
02C82:  CALL   1E3C
02C86:  MOVLW  0D
02C88:  BTFSS  FA6.6
02C8A:  GOTO   2C88
02C8E:  MOVLB  E
02C90:  MOVWF  xF9
02C92:  MOVLW  0A
02C94:  MOVLB  0
02C96:  BTFSS  FA6.6
02C98:  GOTO   2C96
02C9C:  MOVLB  E
02C9E:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | ENVIRO     | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02CA0:  MOVLW  76
02CA2:  MOVWF  FF6
02CA4:  MOVLW  0C
02CA6:  MOVWF  FF7
02CA8:  MOVLW  00
02CAA:  MOVWF  FF8
02CAC:  MOVLW  2C
02CAE:  MOVLB  9
02CB0:  MOVWF  xE9
02CB2:  MOVLB  0
02CB4:  CALL   1C2C
02CB8:  MOVFF  17D,A48
02CBC:  MOVLW  37
02CBE:  MOVLB  A
02CC0:  MOVWF  x49
02CC2:  MOVLB  0
02CC4:  CALL   1E3C
02CC8:  MOVLW  0D
02CCA:  BTFSS  FA6.6
02CCC:  GOTO   2CCA
02CD0:  MOVLB  E
02CD2:  MOVWF  xF9
02CD4:  MOVLW  0A
02CD6:  MOVLB  0
02CD8:  BTFSS  FA6.6
02CDA:  GOTO   2CD8
02CDE:  MOVLB  E
02CE0:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | ENVIRO     | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02CE2:  MOVLW  AA
02CE4:  MOVWF  FF6
02CE6:  MOVLW  0C
02CE8:  MOVWF  FF7
02CEA:  MOVLW  00
02CEC:  MOVWF  FF8
02CEE:  MOVLW  2C
02CF0:  MOVLB  9
02CF2:  MOVWF  xE9
02CF4:  MOVLB  0
02CF6:  CALL   1C2C
02CFA:  MOVFF  17E,A48
02CFE:  MOVLW  37
02D00:  MOVLB  A
02D02:  MOVWF  x49
02D04:  MOVLB  0
02D06:  CALL   1E3C
02D0A:  MOVLW  0D
02D0C:  BTFSS  FA6.6
02D0E:  GOTO   2D0C
02D12:  MOVLB  E
02D14:  MOVWF  xF9
02D16:  MOVLW  0A
02D18:  MOVLB  0
02D1A:  BTFSS  FA6.6
02D1C:  GOTO   2D1A
02D20:  MOVLB  E
02D22:  MOVWF  xF9
....................     delay_ms(10);
02D24:  MOVLW  0A
02D26:  MOVLB  A
02D28:  MOVWF  xA3
02D2A:  MOVLB  0
02D2C:  CALL   1BC8
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Use Counter      : 0x%08LX\r\n", iv1_header.used_counter);
02D30:  MOVLW  DE
02D32:  MOVWF  FF6
02D34:  MOVLW  0C
02D36:  MOVWF  FF7
02D38:  MOVLW  00
02D3A:  MOVWF  FF8
02D3C:  MOVLW  2C
02D3E:  MOVLB  9
02D40:  MOVWF  xE9
02D42:  MOVLB  0
02D44:  CALL   1C2C
02D48:  MOVFF  183,A48
02D4C:  MOVLW  37
02D4E:  MOVLB  A
02D50:  MOVWF  x49
02D52:  MOVLB  0
02D54:  CALL   1E3C
02D58:  MOVFF  182,A48
02D5C:  MOVLW  37
02D5E:  MOVLB  A
02D60:  MOVWF  x49
02D62:  MOVLB  0
02D64:  CALL   1E3C
02D68:  MOVFF  181,A48
02D6C:  MOVLW  37
02D6E:  MOVLB  A
02D70:  MOVWF  x49
02D72:  MOVLB  0
02D74:  CALL   1E3C
02D78:  MOVFF  180,A48
02D7C:  MOVLW  37
02D7E:  MOVLB  A
02D80:  MOVWF  x49
02D82:  MOVLB  0
02D84:  CALL   1E3C
02D88:  MOVLW  0D
02D8A:  BTFSS  FA6.6
02D8C:  GOTO   2D8A
02D90:  MOVLB  E
02D92:  MOVWF  xF9
02D94:  MOVLW  0A
02D96:  MOVLB  0
02D98:  BTFSS  FA6.6
02D9A:  GOTO   2D98
02D9E:  MOVLB  E
02DA0:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Uncopyed Counter : 0x%08LX\r\n", iv1_header.uncopied_counter);
02DA2:  MOVLW  12
02DA4:  MOVWF  FF6
02DA6:  MOVLW  0D
02DA8:  MOVWF  FF7
02DAA:  MOVLW  00
02DAC:  MOVWF  FF8
02DAE:  MOVLW  2C
02DB0:  MOVLB  9
02DB2:  MOVWF  xE9
02DB4:  MOVLB  0
02DB6:  CALL   1C2C
02DBA:  MOVFF  187,A48
02DBE:  MOVLW  37
02DC0:  MOVLB  A
02DC2:  MOVWF  x49
02DC4:  MOVLB  0
02DC6:  CALL   1E3C
02DCA:  MOVFF  186,A48
02DCE:  MOVLW  37
02DD0:  MOVLB  A
02DD2:  MOVWF  x49
02DD4:  MOVLB  0
02DD6:  CALL   1E3C
02DDA:  MOVFF  185,A48
02DDE:  MOVLW  37
02DE0:  MOVLB  A
02DE2:  MOVWF  x49
02DE4:  MOVLB  0
02DE6:  CALL   1E3C
02DEA:  MOVFF  184,A48
02DEE:  MOVLW  37
02DF0:  MOVLB  A
02DF2:  MOVWF  x49
02DF4:  MOVLB  0
02DF6:  CALL   1E3C
02DFA:  MOVLW  0D
02DFC:  BTFSS  FA6.6
02DFE:  GOTO   2DFC
02E02:  MOVLB  E
02E04:  MOVWF  xF9
02E06:  MOVLW  0A
02E08:  MOVLB  0
02E0A:  BTFSS  FA6.6
02E0C:  GOTO   2E0A
02E10:  MOVLB  E
02E12:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Reserve Counter1 : 0x%02X\r\n", iv1_header.reserve_counter1);
02E14:  MOVLW  46
02E16:  MOVWF  FF6
02E18:  MOVLW  0D
02E1A:  MOVWF  FF7
02E1C:  MOVLW  00
02E1E:  MOVWF  FF8
02E20:  MOVLW  2C
02E22:  MOVLB  9
02E24:  MOVWF  xE9
02E26:  MOVLB  0
02E28:  CALL   1C2C
02E2C:  MOVFF  188,A48
02E30:  MOVLW  37
02E32:  MOVLB  A
02E34:  MOVWF  x49
02E36:  MOVLB  0
02E38:  CALL   1E3C
02E3C:  MOVLW  0D
02E3E:  BTFSS  FA6.6
02E40:  GOTO   2E3E
02E44:  MOVLB  E
02E46:  MOVWF  xF9
02E48:  MOVLW  0A
02E4A:  MOVLB  0
02E4C:  BTFSS  FA6.6
02E4E:  GOTO   2E4C
02E52:  MOVLB  E
02E54:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Reserve Counter2 : 0x%02X\r\n", iv1_header.reserve_counter2);
02E56:  MOVLW  7A
02E58:  MOVWF  FF6
02E5A:  MOVLW  0D
02E5C:  MOVWF  FF7
02E5E:  MOVLW  00
02E60:  MOVWF  FF8
02E62:  MOVLW  2C
02E64:  MOVLB  9
02E66:  MOVWF  xE9
02E68:  MOVLB  0
02E6A:  CALL   1C2C
02E6E:  MOVFF  189,A48
02E72:  MOVLW  37
02E74:  MOVLB  A
02E76:  MOVWF  x49
02E78:  MOVLB  0
02E7A:  CALL   1E3C
02E7E:  MOVLW  0D
02E80:  BTFSS  FA6.6
02E82:  GOTO   2E80
02E86:  MOVLB  E
02E88:  MOVWF  xF9
02E8A:  MOVLW  0A
02E8C:  MOVLB  0
02E8E:  BTFSS  FA6.6
02E90:  GOTO   2E8E
02E94:  MOVLB  E
02E96:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Use Counter      : 0x%08LX\r\n", iv1_data.used_counter);
02E98:  MOVLW  AE
02E9A:  MOVWF  FF6
02E9C:  MOVLW  0D
02E9E:  MOVWF  FF7
02EA0:  MOVLW  00
02EA2:  MOVWF  FF8
02EA4:  MOVLW  2C
02EA6:  MOVLB  9
02EA8:  MOVWF  xE9
02EAA:  MOVLB  0
02EAC:  CALL   1C2C
02EB0:  MOVFF  18E,A48
02EB4:  MOVLW  37
02EB6:  MOVLB  A
02EB8:  MOVWF  x49
02EBA:  MOVLB  0
02EBC:  CALL   1E3C
02EC0:  MOVFF  18D,A48
02EC4:  MOVLW  37
02EC6:  MOVLB  A
02EC8:  MOVWF  x49
02ECA:  MOVLB  0
02ECC:  CALL   1E3C
02ED0:  MOVFF  18C,A48
02ED4:  MOVLW  37
02ED6:  MOVLB  A
02ED8:  MOVWF  x49
02EDA:  MOVLB  0
02EDC:  CALL   1E3C
02EE0:  MOVFF  18B,A48
02EE4:  MOVLW  37
02EE6:  MOVLB  A
02EE8:  MOVWF  x49
02EEA:  MOVLB  0
02EEC:  CALL   1E3C
02EF0:  MOVLW  0D
02EF2:  BTFSS  FA6.6
02EF4:  GOTO   2EF2
02EF8:  MOVLB  E
02EFA:  MOVWF  xF9
02EFC:  MOVLW  0A
02EFE:  MOVLB  0
02F00:  BTFSS  FA6.6
02F02:  GOTO   2F00
02F06:  MOVLB  E
02F08:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Uncopyed Counter : 0x%08LX\r\n", iv1_data.uncopied_counter);
02F0A:  MOVLW  E2
02F0C:  MOVWF  FF6
02F0E:  MOVLW  0D
02F10:  MOVWF  FF7
02F12:  MOVLW  00
02F14:  MOVWF  FF8
02F16:  MOVLW  2C
02F18:  MOVLB  9
02F1A:  MOVWF  xE9
02F1C:  MOVLB  0
02F1E:  CALL   1C2C
02F22:  MOVFF  192,A48
02F26:  MOVLW  37
02F28:  MOVLB  A
02F2A:  MOVWF  x49
02F2C:  MOVLB  0
02F2E:  CALL   1E3C
02F32:  MOVFF  191,A48
02F36:  MOVLW  37
02F38:  MOVLB  A
02F3A:  MOVWF  x49
02F3C:  MOVLB  0
02F3E:  CALL   1E3C
02F42:  MOVFF  190,A48
02F46:  MOVLW  37
02F48:  MOVLB  A
02F4A:  MOVWF  x49
02F4C:  MOVLB  0
02F4E:  CALL   1E3C
02F52:  MOVFF  18F,A48
02F56:  MOVLW  37
02F58:  MOVLB  A
02F5A:  MOVWF  x49
02F5C:  MOVLB  0
02F5E:  CALL   1E3C
02F62:  MOVLW  0D
02F64:  BTFSS  FA6.6
02F66:  GOTO   2F64
02F6A:  MOVLB  E
02F6C:  MOVWF  xF9
02F6E:  MOVLW  0A
02F70:  MOVLB  0
02F72:  BTFSS  FA6.6
02F74:  GOTO   2F72
02F78:  MOVLB  E
02F7A:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Reserve Counter1 : 0x%02X\r\n", iv1_data.reserve_counter1);
02F7C:  MOVLW  16
02F7E:  MOVWF  FF6
02F80:  MOVLW  0E
02F82:  MOVWF  FF7
02F84:  MOVLW  00
02F86:  MOVWF  FF8
02F88:  MOVLW  2C
02F8A:  MOVLB  9
02F8C:  MOVWF  xE9
02F8E:  MOVLB  0
02F90:  CALL   1C2C
02F94:  MOVFF  193,A48
02F98:  MOVLW  37
02F9A:  MOVLB  A
02F9C:  MOVWF  x49
02F9E:  MOVLB  0
02FA0:  CALL   1E3C
02FA4:  MOVLW  0D
02FA6:  BTFSS  FA6.6
02FA8:  GOTO   2FA6
02FAC:  MOVLB  E
02FAE:  MOVWF  xF9
02FB0:  MOVLW  0A
02FB2:  MOVLB  0
02FB4:  BTFSS  FA6.6
02FB6:  GOTO   2FB4
02FBA:  MOVLB  E
02FBC:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Reserve Counter2 : 0x%02X\r\n", iv1_data.reserve_counter2);
02FBE:  MOVLW  4A
02FC0:  MOVWF  FF6
02FC2:  MOVLW  0E
02FC4:  MOVWF  FF7
02FC6:  MOVLW  00
02FC8:  MOVWF  FF8
02FCA:  MOVLW  2C
02FCC:  MOVLB  9
02FCE:  MOVWF  xE9
02FD0:  MOVLB  0
02FD2:  CALL   1C2C
02FD6:  MOVFF  194,A48
02FDA:  MOVLW  37
02FDC:  MOVLB  A
02FDE:  MOVWF  x49
02FE0:  MOVLB  0
02FE2:  CALL   1E3C
02FE6:  MOVLW  0D
02FE8:  BTFSS  FA6.6
02FEA:  GOTO   2FE8
02FEE:  MOVLB  E
02FF0:  MOVWF  xF9
02FF2:  MOVLW  0A
02FF4:  MOVLB  0
02FF6:  BTFSS  FA6.6
02FF8:  GOTO   2FF6
02FFC:  MOVLB  E
02FFE:  MOVWF  xF9
....................     delay_ms(10);
03000:  MOVLW  0A
03002:  MOVLB  A
03004:  MOVWF  xA3
03006:  MOVLB  0
03008:  CALL   1BC8
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Use Counter      : 0x%08LX\r\n", iv2_header.used_counter);
0300C:  MOVLW  7E
0300E:  MOVWF  FF6
03010:  MOVLW  0E
03012:  MOVWF  FF7
03014:  MOVLW  00
03016:  MOVWF  FF8
03018:  MOVLW  2C
0301A:  MOVLB  9
0301C:  MOVWF  xE9
0301E:  MOVLB  0
03020:  CALL   1C2C
03024:  MOVFF  199,A48
03028:  MOVLW  37
0302A:  MOVLB  A
0302C:  MOVWF  x49
0302E:  MOVLB  0
03030:  CALL   1E3C
03034:  MOVFF  198,A48
03038:  MOVLW  37
0303A:  MOVLB  A
0303C:  MOVWF  x49
0303E:  MOVLB  0
03040:  CALL   1E3C
03044:  MOVFF  197,A48
03048:  MOVLW  37
0304A:  MOVLB  A
0304C:  MOVWF  x49
0304E:  MOVLB  0
03050:  CALL   1E3C
03054:  MOVFF  196,A48
03058:  MOVLW  37
0305A:  MOVLB  A
0305C:  MOVWF  x49
0305E:  MOVLB  0
03060:  CALL   1E3C
03064:  MOVLW  0D
03066:  BTFSS  FA6.6
03068:  GOTO   3066
0306C:  MOVLB  E
0306E:  MOVWF  xF9
03070:  MOVLW  0A
03072:  MOVLB  0
03074:  BTFSS  FA6.6
03076:  GOTO   3074
0307A:  MOVLB  E
0307C:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Uncopyed Counter : 0x%08LX\r\n", iv2_header.uncopied_counter);
0307E:  MOVLW  B2
03080:  MOVWF  FF6
03082:  MOVLW  0E
03084:  MOVWF  FF7
03086:  MOVLW  00
03088:  MOVWF  FF8
0308A:  MOVLW  2C
0308C:  MOVLB  9
0308E:  MOVWF  xE9
03090:  MOVLB  0
03092:  CALL   1C2C
03096:  MOVFF  19D,A48
0309A:  MOVLW  37
0309C:  MOVLB  A
0309E:  MOVWF  x49
030A0:  MOVLB  0
030A2:  CALL   1E3C
030A6:  MOVFF  19C,A48
030AA:  MOVLW  37
030AC:  MOVLB  A
030AE:  MOVWF  x49
030B0:  MOVLB  0
030B2:  CALL   1E3C
030B6:  MOVFF  19B,A48
030BA:  MOVLW  37
030BC:  MOVLB  A
030BE:  MOVWF  x49
030C0:  MOVLB  0
030C2:  CALL   1E3C
030C6:  MOVFF  19A,A48
030CA:  MOVLW  37
030CC:  MOVLB  A
030CE:  MOVWF  x49
030D0:  MOVLB  0
030D2:  CALL   1E3C
030D6:  MOVLW  0D
030D8:  BTFSS  FA6.6
030DA:  GOTO   30D8
030DE:  MOVLB  E
030E0:  MOVWF  xF9
030E2:  MOVLW  0A
030E4:  MOVLB  0
030E6:  BTFSS  FA6.6
030E8:  GOTO   30E6
030EC:  MOVLB  E
030EE:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Reserve Counter1 : 0x%02X\r\n", iv2_header.reserve_counter1);
030F0:  MOVLW  E6
030F2:  MOVWF  FF6
030F4:  MOVLW  0E
030F6:  MOVWF  FF7
030F8:  MOVLW  00
030FA:  MOVWF  FF8
030FC:  MOVLW  2C
030FE:  MOVLB  9
03100:  MOVWF  xE9
03102:  MOVLB  0
03104:  CALL   1C2C
03108:  MOVFF  19E,A48
0310C:  MOVLW  37
0310E:  MOVLB  A
03110:  MOVWF  x49
03112:  MOVLB  0
03114:  CALL   1E3C
03118:  MOVLW  0D
0311A:  BTFSS  FA6.6
0311C:  GOTO   311A
03120:  MOVLB  E
03122:  MOVWF  xF9
03124:  MOVLW  0A
03126:  MOVLB  0
03128:  BTFSS  FA6.6
0312A:  GOTO   3128
0312E:  MOVLB  E
03130:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Reserve Counter2 : 0x%02X\r\n", iv2_header.reserve_counter2);
03132:  MOVLW  1A
03134:  MOVWF  FF6
03136:  MOVLW  0F
03138:  MOVWF  FF7
0313A:  MOVLW  00
0313C:  MOVWF  FF8
0313E:  MOVLW  2C
03140:  MOVLB  9
03142:  MOVWF  xE9
03144:  MOVLB  0
03146:  CALL   1C2C
0314A:  MOVFF  19F,A48
0314E:  MOVLW  37
03150:  MOVLB  A
03152:  MOVWF  x49
03154:  MOVLB  0
03156:  CALL   1E3C
0315A:  MOVLW  0D
0315C:  BTFSS  FA6.6
0315E:  GOTO   315C
03162:  MOVLB  E
03164:  MOVWF  xF9
03166:  MOVLW  0A
03168:  MOVLB  0
0316A:  BTFSS  FA6.6
0316C:  GOTO   316A
03170:  MOVLB  E
03172:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Use Counter      : 0x%08LX\r\n", iv2_data.used_counter);
03174:  MOVLW  4E
03176:  MOVWF  FF6
03178:  MOVLW  0F
0317A:  MOVWF  FF7
0317C:  MOVLW  00
0317E:  MOVWF  FF8
03180:  MOVLW  2C
03182:  MOVLB  9
03184:  MOVWF  xE9
03186:  MOVLB  0
03188:  CALL   1C2C
0318C:  MOVFF  1A4,A48
03190:  MOVLW  37
03192:  MOVLB  A
03194:  MOVWF  x49
03196:  MOVLB  0
03198:  CALL   1E3C
0319C:  MOVFF  1A3,A48
031A0:  MOVLW  37
031A2:  MOVLB  A
031A4:  MOVWF  x49
031A6:  MOVLB  0
031A8:  CALL   1E3C
031AC:  MOVFF  1A2,A48
031B0:  MOVLW  37
031B2:  MOVLB  A
031B4:  MOVWF  x49
031B6:  MOVLB  0
031B8:  CALL   1E3C
031BC:  MOVFF  1A1,A48
031C0:  MOVLW  37
031C2:  MOVLB  A
031C4:  MOVWF  x49
031C6:  MOVLB  0
031C8:  CALL   1E3C
031CC:  MOVLW  0D
031CE:  BTFSS  FA6.6
031D0:  GOTO   31CE
031D4:  MOVLB  E
031D6:  MOVWF  xF9
031D8:  MOVLW  0A
031DA:  MOVLB  0
031DC:  BTFSS  FA6.6
031DE:  GOTO   31DC
031E2:  MOVLB  E
031E4:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Uncopyed Counter : 0x%08LX\r\n", iv2_data.uncopied_counter);
031E6:  MOVLW  82
031E8:  MOVWF  FF6
031EA:  MOVLW  0F
031EC:  MOVWF  FF7
031EE:  MOVLW  00
031F0:  MOVWF  FF8
031F2:  MOVLW  2C
031F4:  MOVLB  9
031F6:  MOVWF  xE9
031F8:  MOVLB  0
031FA:  CALL   1C2C
031FE:  MOVFF  1A8,A48
03202:  MOVLW  37
03204:  MOVLB  A
03206:  MOVWF  x49
03208:  MOVLB  0
0320A:  CALL   1E3C
0320E:  MOVFF  1A7,A48
03212:  MOVLW  37
03214:  MOVLB  A
03216:  MOVWF  x49
03218:  MOVLB  0
0321A:  CALL   1E3C
0321E:  MOVFF  1A6,A48
03222:  MOVLW  37
03224:  MOVLB  A
03226:  MOVWF  x49
03228:  MOVLB  0
0322A:  CALL   1E3C
0322E:  MOVFF  1A5,A48
03232:  MOVLW  37
03234:  MOVLB  A
03236:  MOVWF  x49
03238:  MOVLB  0
0323A:  CALL   1E3C
0323E:  MOVLW  0D
03240:  BTFSS  FA6.6
03242:  GOTO   3240
03246:  MOVLB  E
03248:  MOVWF  xF9
0324A:  MOVLW  0A
0324C:  MOVLB  0
0324E:  BTFSS  FA6.6
03250:  GOTO   324E
03254:  MOVLB  E
03256:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Reserve Counter1 : 0x%02X\r\n", iv2_data.reserve_counter1);
03258:  MOVLW  B6
0325A:  MOVWF  FF6
0325C:  MOVLW  0F
0325E:  MOVWF  FF7
03260:  MOVLW  00
03262:  MOVWF  FF8
03264:  MOVLW  2C
03266:  MOVLB  9
03268:  MOVWF  xE9
0326A:  MOVLB  0
0326C:  CALL   1C2C
03270:  MOVFF  1A9,A48
03274:  MOVLW  37
03276:  MOVLB  A
03278:  MOVWF  x49
0327A:  MOVLB  0
0327C:  CALL   1E3C
03280:  MOVLW  0D
03282:  BTFSS  FA6.6
03284:  GOTO   3282
03288:  MOVLB  E
0328A:  MOVWF  xF9
0328C:  MOVLW  0A
0328E:  MOVLB  0
03290:  BTFSS  FA6.6
03292:  GOTO   3290
03296:  MOVLB  E
03298:  MOVWF  xF9
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Reserve Counter2 : 0x%02X\r\n", iv2_data.reserve_counter2);
0329A:  MOVLW  EA
0329C:  MOVWF  FF6
0329E:  MOVLW  0F
032A0:  MOVWF  FF7
032A2:  MOVLW  00
032A4:  MOVWF  FF8
032A6:  MOVLW  2C
032A8:  MOVLB  9
032AA:  MOVWF  xE9
032AC:  MOVLB  0
032AE:  CALL   1C2C
032B2:  MOVFF  1AA,A48
032B6:  MOVLW  37
032B8:  MOVLB  A
032BA:  MOVWF  x49
032BC:  MOVLB  0
032BE:  CALL   1E3C
032C2:  MOVLW  0D
032C4:  BTFSS  FA6.6
032C6:  GOTO   32C4
032CA:  MOVLB  E
032CC:  MOVWF  xF9
032CE:  MOVLW  0A
032D0:  MOVLB  0
032D2:  BTFSS  FA6.6
032D4:  GOTO   32D2
032D8:  MOVLB  E
032DA:  MOVWF  xF9
....................     delay_ms(10);
032DC:  MOVLW  0A
032DE:  MOVLB  A
032E0:  MOVWF  xA3
032E2:  MOVLB  0
032E4:  CALL   1BC8
....................     fprintf(PC, "\tComplete\r\n");
032E8:  MOVLW  1E
032EA:  MOVWF  FF6
032EC:  MOVLW  10
032EE:  MOVWF  FF7
032F0:  MOVLW  00
032F2:  MOVWF  FF8
032F4:  CALL   1BF6
032F8:  GOTO   3BA6 (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
0ADA4:  MOVLB  2
0ADA6:  CLRF   x9C
0ADA8:  CLRF   x9D
0ADAA:  CLRF   x9E
0ADAC:  CLRF   x9F
0ADAE:  CLRF   xA0
0ADB0:  CLRF   xA1
0ADB2:  CLRF   xA2
0ADB4:  CLRF   xA3
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0ADB6:  MOVF   x9B,F
0ADB8:  BTFSC  FD8.2
0ADBA:  BRA    ADC2
0ADBC:  MOVLB  0
0ADBE:  GOTO   ADDE
0ADC2:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
0ADC4:  MOVLB  2
0ADC6:  CLRF   x9F
0ADC8:  CLRF   x9E
0ADCA:  CLRF   x9D
0ADCC:  CLRF   x9C
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
0ADCE:  CLRF   xA3
0ADD0:  CLRF   xA2
0ADD2:  MOVLW  0F
0ADD4:  MOVWF  xA1
0ADD6:  SETF   xA0
0ADD8:  MOVLB  0
....................    }
0ADDA:  GOTO   AEA0
....................    else if (mission_id == CIGS_PICLOG_DATA)
0ADDE:  MOVLB  2
0ADE0:  DECFSZ x9B,W
0ADE2:  BRA    ADE8
0ADE4:  BRA    ADEE
0ADE6:  MOVLB  0
0ADE8:  MOVLB  0
0ADEA:  GOTO   AE0E
0ADEE:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
0ADF0:  MOVLB  2
0ADF2:  CLRF   x9F
0ADF4:  MOVLW  01
0ADF6:  MOVWF  x9E
0ADF8:  CLRF   x9D
0ADFA:  CLRF   x9C
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
0ADFC:  CLRF   xA3
0ADFE:  MOVLW  14
0AE00:  MOVWF  xA2
0AE02:  MOVLW  0F
0AE04:  MOVWF  xA1
0AE06:  SETF   xA0
0AE08:  MOVLB  0
....................    }
0AE0A:  GOTO   AEA0
....................    else if (mission_id == CIGS_ENVIRO_DATA)
0AE0E:  MOVLB  2
0AE10:  MOVF   x9B,W
0AE12:  SUBLW  02
0AE14:  BTFSC  FD8.2
0AE16:  BRA    AE1E
0AE18:  MOVLB  0
0AE1A:  GOTO   AE40
0AE1E:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
0AE20:  MOVLB  2
0AE22:  CLRF   x9F
0AE24:  MOVLW  28
0AE26:  MOVWF  x9E
0AE28:  MOVLW  10
0AE2A:  MOVWF  x9D
0AE2C:  CLRF   x9C
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
0AE2E:  CLRF   xA3
0AE30:  MOVLW  32
0AE32:  MOVWF  xA2
0AE34:  MOVLW  0F
0AE36:  MOVWF  xA1
0AE38:  SETF   xA0
0AE3A:  MOVLB  0
....................    }
0AE3C:  GOTO   AEA0
....................    else if (mission_id == CIGS_IV1_HEADER)
0AE40:  MOVLB  2
0AE42:  MOVF   x9B,W
0AE44:  SUBLW  03
0AE46:  BTFSC  FD8.2
0AE48:  BRA    AE50
0AE4A:  MOVLB  0
0AE4C:  GOTO   AE72
0AE50:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
0AE52:  MOVLB  2
0AE54:  CLRF   x9F
0AE56:  MOVLW  72
0AE58:  MOVWF  x9E
0AE5A:  MOVLW  10
0AE5C:  MOVWF  x9D
0AE5E:  CLRF   x9C
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
0AE60:  CLRF   xA3
0AE62:  MOVLW  7C
0AE64:  MOVWF  xA2
0AE66:  MOVLW  0F
0AE68:  MOVWF  xA1
0AE6A:  SETF   xA0
0AE6C:  MOVLB  0
....................    }
0AE6E:  GOTO   AEA0
....................    else if (mission_id == CIGS_IV1_DATA)
0AE72:  MOVLB  2
0AE74:  MOVF   x9B,W
0AE76:  SUBLW  04
0AE78:  BTFSC  FD8.2
0AE7A:  BRA    AE82
0AE7C:  MOVLB  0
0AE7E:  GOTO   AEA0
0AE82:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
0AE84:  MOVLB  2
0AE86:  CLRF   x9F
0AE88:  MOVLW  7C
0AE8A:  MOVWF  x9E
0AE8C:  MOVLW  10
0AE8E:  MOVWF  x9D
0AE90:  CLRF   x9C
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
0AE92:  CLRF   xA3
0AE94:  MOVLW  BC
0AE96:  MOVWF  xA2
0AE98:  MOVLW  0F
0AE9A:  MOVWF  xA1
0AE9C:  SETF   xA0
0AE9E:  MOVLB  0
....................    }
....................    return mis_struct;
0AEA0:  MOVLW  9C
0AEA2:  MOVWF  01
0AEA4:  MOVLW  02
0AEA6:  MOVWF  02
0AEA8:  GOTO   B3B4 (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV1_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv1_header.used_counter - iv1_header.uncopied_counter;
....................         mis_write_struct.size = iv1_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV1_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv1_data.used_counter - iv1_data.uncopied_counter;
....................         mis_write_struct.size = iv1_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... // End of file
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "application/mmj_cigs_excute_mission.c"
.................... #include "../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../hal/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
....................     #pin_select TX4=PIN_E5
....................     #pin_select RX4=PIN_D4  
....................     #use rs232(baud=9600,parity=N, UART4, bits=8,stream=PC, ERRORS)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E4, bits=8,stream=PC)
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C3
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define CMD_LENGTH 9
.................... 
.................... // ______________CMD ID________________
.................... // Operation Command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_DEBUG 0xA1
.................... #define ID_MEAS_ENV 0xA2
.................... #define ID_MEAS_ENV_DEBUG 0xA3
.................... 
.................... // ______________MODE FUNCTIONS____________
.................... void mode_meas_iv(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_iv_debug(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_env(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_env_debug(unsigned int8 *uplinkcmd_ptr);
.................... 
.................... 
.................... typedef union {
....................     unsigned int8 raw;
....................     struct {
....................         unsigned int8 mission_continue : 1;
....................         unsigned int8 erase_and_save : 1;
....................         unsigned int8 reserved : 6;
....................     } flag;
.................... } mission_state_t;
.................... 
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     mission_state_t mission_state; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "../domain/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../domain/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... #define HEADER_SIZE 5  // START_MAKER + time (4バイト)
.................... #define ENV_SIZE    6  // pd + temp_py_top + temp_py_bot + temp_mis7 packed
.................... #define DATA_SIZE_PER_STEP 3 // data0 + data1 12bitずつ
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
0A4B2:  MOVLB  1
0A4B4:  MOVF   xBE,W
0A4B6:  MOVWF  FE9
0A4B8:  MOVF   xBF,W
0A4BA:  MOVWF  FEA
0A4BC:  MOVFF  FEF,1C0
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
0A4C0:  MOVLW  86
0A4C2:  MOVWF  FF6
0A4C4:  MOVLW  10
0A4C6:  MOVWF  FF7
0A4C8:  MOVLW  00
0A4CA:  MOVWF  FF8
0A4CC:  MOVLB  0
0A4CE:  CALL   1BF6
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
0A4D2:  MOVLW  CC
0A4D4:  MOVWF  FF6
0A4D6:  MOVLW  10
0A4D8:  MOVWF  FF7
0A4DA:  MOVLW  00
0A4DC:  MOVWF  FF8
0A4DE:  MOVLW  0C
0A4E0:  MOVLB  9
0A4E2:  MOVWF  xE9
0A4E4:  MOVLB  0
0A4E6:  CALL   1C2C
0A4EA:  MOVFF  1C0,A48
0A4EE:  MOVLW  37
0A4F0:  MOVLB  A
0A4F2:  MOVWF  x49
0A4F4:  MOVLB  0
0A4F6:  CALL   1E3C
0A4FA:  MOVLW  DA
0A4FC:  MOVWF  FF6
0A4FE:  MOVLW  10
0A500:  MOVWF  FF7
0A502:  MOVLW  00
0A504:  MOVWF  FF8
0A506:  MOVLW  04
0A508:  MOVLB  9
0A50A:  MOVWF  xE9
0A50C:  MOVLB  0
0A50E:  CALL   1C2C
....................    switch(command_id)
0A512:  MOVLB  1
0A514:  MOVF   xC0,W
0A516:  XORLW  10
0A518:  MOVLB  0
0A51A:  BTFSC  FD8.2
0A51C:  GOTO   A5E4
0A520:  XORLW  01
0A522:  BTFSC  FD8.2
0A524:  GOTO   A5E8
0A528:  XORLW  03
0A52A:  BTFSC  FD8.2
0A52C:  GOTO   A5EC
0A530:  XORLW  13
0A532:  BTFSC  FD8.2
0A534:  GOTO   A5F0
0A538:  XORLW  12
0A53A:  BTFSC  FD8.2
0A53C:  GOTO   A5F4
0A540:  XORLW  93
0A542:  BTFSC  FD8.2
0A544:  GOTO   A5F8
0A548:  XORLW  01
0A54A:  BTFSC  FD8.2
0A54C:  GOTO   A608
0A550:  XORLW  03
0A552:  BTFSC  FD8.2
0A554:  GOTO   A618
0A558:  XORLW  01
0A55A:  BTFSC  FD8.2
0A55C:  GOTO   A628
0A560:  XORLW  07
0A562:  BTFSC  FD8.2
0A564:  GOTO   A638
0A568:  XORLW  01
0A56A:  BTFSC  FD8.2
0A56C:  GOTO   A648
0A570:  XORLW  03
0A572:  BTFSC  FD8.2
0A574:  GOTO   A658
0A578:  XORLW  01
0A57A:  BTFSC  FD8.2
0A57C:  GOTO   A668
0A580:  XORLW  0F
0A582:  BTFSC  FD8.2
0A584:  GOTO   A678
0A588:  XORLW  18
0A58A:  BTFSC  FD8.2
0A58C:  GOTO   A688
0A590:  XORLW  01
0A592:  BTFSC  FD8.2
0A594:  GOTO   A698
0A598:  XORLW  03
0A59A:  BTFSC  FD8.2
0A59C:  GOTO   A6A8
0A5A0:  XORLW  01
0A5A2:  BTFSC  FD8.2
0A5A4:  GOTO   A6B8
0A5A8:  XORLW  07
0A5AA:  BTFSC  FD8.2
0A5AC:  GOTO   A6C8
0A5B0:  XORLW  01
0A5B2:  BTFSC  FD8.2
0A5B4:  GOTO   A6D8
0A5B8:  XORLW  03
0A5BA:  BTFSC  FD8.2
0A5BC:  GOTO   A6E8
0A5C0:  XORLW  36
0A5C2:  BTFSC  FD8.2
0A5C4:  GOTO   A6F8
0A5C8:  XORLW  01
0A5CA:  BTFSC  FD8.2
0A5CC:  GOTO   A708
0A5D0:  XORLW  03
0A5D2:  BTFSC  FD8.2
0A5D4:  GOTO   A718
0A5D8:  XORLW  01
0A5DA:  BTFSC  FD8.2
0A5DC:  GOTO   A728
0A5E0:  GOTO   A738
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
0A5E4:  GOTO   A748
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
0A5E8:  GOTO   A748
....................       case 0x12:
....................          // test_adc();
....................          break;
0A5EC:  GOTO   A748
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
0A5F0:  GOTO   A748
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
0A5F4:  GOTO   A748
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
0A5F8:  MOVFF  1BF,1C4
0A5FC:  MOVFF  1BE,1C3
0A600:  CALL   53DA
....................          break;
0A604:  GOTO   A748
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
0A608:  MOVFF  1BF,1C2
0A60C:  MOVFF  1BE,1C1
0A610:  GOTO   54B8
....................          break;
0A614:  GOTO   A748
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
0A618:  MOVFF  1BF,1C2
0A61C:  MOVFF  1BE,1C1
0A620:  GOTO   59AC
....................          break;
0A624:  GOTO   A748
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
0A628:  MOVFF  1BF,1C2
0A62C:  MOVFF  1BE,1C1
0A630:  GOTO   5B40
....................          break;
0A634:  GOTO   A748
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
0A638:  MOVFF  1BF,1C2
0A63C:  MOVFF  1BE,1C1
0A640:  GOTO   5CB4
....................          break;
0A644:  GOTO   A748
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
0A648:  MOVFF  1BF,1C2
0A64C:  MOVFF  1BE,1C1
0A650:  GOTO   60F8
....................          break;
0A654:  GOTO   A748
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
0A658:  MOVFF  1BF,1C2
0A65C:  MOVFF  1BE,1C1
0A660:  GOTO   6170
....................          break;
0A664:  GOTO   A748
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
0A668:  MOVFF  1BF,1C2
0A66C:  MOVFF  1BE,1C1
0A670:  GOTO   6640
....................          break;
0A674:  GOTO   A748
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
0A678:  MOVFF  1BF,1C2
0A67C:  MOVFF  1BE,1C1
0A680:  GOTO   6948
....................          break;
0A684:  GOTO   A748
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
0A688:  MOVFF  1BF,1C2
0A68C:  MOVFF  1BE,1C1
0A690:  GOTO   69A0
....................          break;
0A694:  GOTO   A748
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
0A698:  MOVFF  1BF,1C2
0A69C:  MOVFF  1BE,1C1
0A6A0:  GOTO   6A7C
....................          break;
0A6A4:  GOTO   A748
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
0A6A8:  MOVFF  1BF,1C2
0A6AC:  MOVFF  1BE,1C1
0A6B0:  GOTO   6B3A
....................          break;
0A6B4:  GOTO   A748
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
0A6B8:  MOVFF  1BF,1C2
0A6BC:  MOVFF  1BE,1C1
0A6C0:  CALL   6C6E
....................          break;
0A6C4:  GOTO   A748
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
0A6C8:  MOVFF  1BF,1C2
0A6CC:  MOVFF  1BE,1C1
0A6D0:  GOTO   6DEC
....................          break;
0A6D4:  GOTO   A748
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
0A6D8:  MOVFF  1BF,1C2
0A6DC:  MOVFF  1BE,1C1
0A6E0:  GOTO   721C
....................          break;
0A6E4:  GOTO   A748
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
0A6E8:  MOVFF  1BF,1C2
0A6EC:  MOVFF  1BE,1C1
0A6F0:  CALL   6C6E
....................          break;
0A6F4:  GOTO   A748
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
0A6F8:  MOVFF  1BF,1C2
0A6FC:  MOVFF  1BE,1C1
0A700:  GOTO   7666
....................          break;
0A704:  GOTO   A748
....................       case ID_MEAS_DEBUG:
....................          mode_meas_iv_debug(content);
0A708:  MOVFF  1BF,1C2
0A70C:  MOVFF  1BE,1C1
0A710:  GOTO   9D88
....................          break;;
0A714:  GOTO   A748
....................       case ID_MEAS_ENV:
....................          mode_meas_env(content);
0A718:  MOVFF  1BF,1C2
0A71C:  MOVFF  1BE,1C1
0A720:  GOTO   9FAC
....................          break;
0A724:  GOTO   A748
....................       case ID_MEAS_ENV_DEBUG:
....................          mode_meas_env_debug(content);
0A728:  MOVFF  1BF,1C2
0A72C:  MOVFF  1BE,1C1
0A730:  GOTO   A48E
....................          break;
0A734:  GOTO   A748
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
0A738:  MOVLW  E0
0A73A:  MOVWF  FF6
0A73C:  MOVLW  10
0A73E:  MOVWF  FF7
0A740:  MOVLW  00
0A742:  MOVWF  FF8
0A744:  CALL   1BF6
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
0A748:  MOVLW  F8
0A74A:  MOVWF  FF6
0A74C:  MOVLW  10
0A74E:  MOVWF  FF7
0A750:  MOVLW  00
0A752:  MOVWF  FF8
0A754:  CALL   1BF6
0A758:  GOTO   A7C6 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0C9D4:  MOVLW  3E
0C9D6:  MOVWF  FF6
0C9D8:  MOVLW  11
0C9DA:  MOVWF  FF7
0C9DC:  MOVLW  00
0C9DE:  MOVWF  FF8
0C9E0:  CALL   1BF6
....................    
....................    switch(command->frame_id)
0C9E4:  MOVLB  1
0C9E6:  MOVF   xB8,W
0C9E8:  MOVWF  FE9
0C9EA:  MOVF   xB9,W
0C9EC:  MOVWF  FEA
0C9EE:  MOVF   FEF,W
0C9F0:  XORLW  00
0C9F2:  MOVLB  0
0C9F4:  BTFSC  FD8.2
0C9F6:  GOTO   CA0E
0C9FA:  XORLW  01
0C9FC:  BTFSC  FD8.2
0C9FE:  GOTO   CA1E
0CA02:  XORLW  03
0CA04:  BTFSC  FD8.2
0CA06:  GOTO   CA3E
0CA0A:  GOTO   CA4E
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0CA0E:  MOVFF  1B9,1BB
0CA12:  MOVFF  1B8,1BA
0CA16:  GOTO   A77A
....................          break;
0CA1A:  GOTO   CA4E
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0CA1E:  MOVFF  1B9,1BB
0CA22:  MOVFF  1B8,1BA
0CA26:  GOTO   A7FC
0CA2A:  MOVF   01,F
0CA2C:  BTFSC  FD8.2
0CA2E:  GOTO   CA3A
....................             return TRUE; // if status is finished, return TRUE
0CA32:  MOVLW  01
0CA34:  MOVWF  01
0CA36:  GOTO   CA52
....................          }        
....................          break;
0CA3A:  GOTO   CA4E
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0CA3E:  MOVFF  1B9,1BB
0CA42:  MOVFF  1B8,1BA
0CA46:  GOTO   C6DE
....................          break;
0CA4A:  GOTO   CA4E
....................    }
....................    return FALSE;
0CA4E:  MOVLW  00
0CA50:  MOVWF  01
0CA52:  GOTO   CFD2 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
0A77A:  MOVLW  56
0A77C:  MOVWF  FF6
0A77E:  MOVLW  11
0A780:  MOVWF  FF7
0A782:  MOVLW  00
0A784:  MOVWF  FF8
0A786:  CALL   1BF6
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
0A78A:  MOVLW  6C
0A78C:  MOVWF  FF6
0A78E:  MOVLW  11
0A790:  MOVWF  FF7
0A792:  MOVLW  00
0A794:  MOVWF  FF8
0A796:  CALL   1BF6
....................    transmit_ack();
0A79A:  CALL   53C6
.................... 
....................    status[0] = EXECUTING_MISSION;
0A79E:  MOVLW  02
0A7A0:  MOVWF  4C
....................    execute_mission(command->content);
0A7A2:  MOVLW  03
0A7A4:  MOVLB  1
0A7A6:  ADDWF  xBA,W
0A7A8:  MOVWF  01
0A7AA:  MOVLW  00
0A7AC:  ADDWFC xBB,W
0A7AE:  MOVWF  03
0A7B0:  MOVF   01,W
0A7B2:  MOVWF  xBC
0A7B4:  MOVFF  03,1BD
0A7B8:  MOVFF  1BD,1BF
0A7BC:  MOVFF  1BC,1BE
0A7C0:  MOVLB  0
0A7C2:  GOTO   A4B2
....................    if (is_empty_flash_queue())
0A7C6:  CALL   A75C
0A7CA:  MOVF   01,F
0A7CC:  BTFSC  FD8.2
0A7CE:  GOTO   A7DA
....................       status[0] = FINISHED;
0A7D2:  MOVLW  06
0A7D4:  MOVWF  4C
0A7D6:  GOTO   A7DE
....................    else
....................       status[0] = SMF_USE_REQ;
0A7DA:  MOVLW  04
0A7DC:  MOVWF  4C
0A7DE:  GOTO   CA1A (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
0A7FC:  MOVLW  86
0A7FE:  MOVWF  FF6
0A800:  MOVLW  11
0A802:  MOVWF  FF7
0A804:  MOVLW  00
0A806:  MOVWF  FF8
0A808:  CALL   1BF6
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
0A80C:  MOVLW  9A
0A80E:  MOVWF  FF6
0A810:  MOVLW  11
0A812:  MOVWF  FF7
0A814:  MOVLW  00
0A816:  MOVWF  FF8
0A818:  CALL   1BF6
....................    transmit_status();
0A81C:  GOTO   A7E2
....................    if (status[0] == FINISHED)
0A820:  MOVF   4C,W
0A822:  SUBLW  06
0A824:  BTFSS  FD8.2
0A826:  GOTO   A846
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
0A82A:  MOVLW  B8
0A82C:  MOVWF  FF6
0A82E:  MOVLW  11
0A830:  MOVWF  FF7
0A832:  MOVLW  00
0A834:  MOVWF  FF8
0A836:  CALL   1BF6
....................       return TRUE;
0A83A:  MOVLW  01
0A83C:  MOVWF  01
0A83E:  GOTO   A84E
....................    }
0A842:  GOTO   A84E
....................    else{
....................       return FALSE;
0A846:  MOVLW  00
0A848:  MOVWF  01
0A84A:  GOTO   A84E
....................    }
0A84E:  GOTO   CA2A (RETURN)
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command)
.................... {
....................     fprintf(PC, "\t-> SMF available check\r\n");
*
0C6DE:  MOVLW  D4
0C6E0:  MOVWF  FF6
0C6E2:  MOVLW  11
0C6E4:  MOVWF  FF7
0C6E6:  MOVLW  00
0C6E8:  MOVWF  FF8
0C6EA:  CALL   1BF6
....................     fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0C6EE:  MOVLW  EE
0C6F0:  MOVWF  FF6
0C6F2:  MOVLW  11
0C6F4:  MOVWF  FF7
0C6F6:  MOVLW  00
0C6F8:  MOVWF  FF8
0C6FA:  CALL   1BF6
....................     transmit_ack();
0C6FE:  CALL   53C6
.................... 
....................     if (command->content[0] != ALLOW) {
0C702:  MOVLW  03
0C704:  MOVLB  1
0C706:  ADDWF  xBA,W
0C708:  MOVWF  FE9
0C70A:  MOVLW  00
0C70C:  ADDWFC xBB,W
0C70E:  MOVWF  FEA
0C710:  DECFSZ FEF,W
0C712:  BRA    C718
0C714:  BRA    C71E
0C716:  MOVLB  0
0C718:  MOVLB  0
0C71A:  GOTO   C724
0C71E:  MOVLB  0
0C720:  GOTO   C738
....................         fprintf(PC, "\t\t-> denied\r\n");
0C724:  MOVLW  0E
0C726:  MOVWF  FF6
0C728:  MOVLW  12
0C72A:  MOVWF  FF7
0C72C:  MOVLW  00
0C72E:  MOVWF  FF8
0C730:  CALL   1BF6
....................         return;
0C734:  GOTO   C9D0
....................     }
.................... 
....................     fprintf(PC, "\t\t-> allowed\r\n");
0C738:  MOVLW  1C
0C73A:  MOVWF  FF6
0C73C:  MOVLW  12
0C73E:  MOVWF  FF7
0C740:  MOVLW  00
0C742:  MOVWF  FF8
0C744:  CALL   1BF6
....................     status[0] = COPYING;
0C748:  MOVLW  05
0C74A:  MOVWF  4C
.................... 
....................     int8 processed_count = 0;
0C74C:  MOVLB  1
0C74E:  CLRF   xBC
0C750:  MOVLB  0
.................... 
....................     while (!is_empty_flash_queue()) {
0C752:  CALL   A75C
0C756:  MOVF   01,F
0C758:  BTFSS  FD8.2
0C75A:  GOTO   C98C
....................         FlashOperationStruct *smf_data = dequeue_flash_operation();
0C75E:  GOTO   A852
0C762:  MOVFF  02,1BE
0C766:  MOVFF  01,1BD
....................         if (smf_data == NULL) {
0C76A:  MOVLB  1
0C76C:  MOVF   xBD,F
0C76E:  BTFSC  FD8.2
0C770:  BRA    C778
0C772:  MOVLB  0
0C774:  GOTO   C79E
0C778:  MOVLB  0
0C77A:  MOVLB  1
0C77C:  MOVF   xBE,F
0C77E:  BTFSC  FD8.2
0C780:  BRA    C788
0C782:  MOVLB  0
0C784:  GOTO   C79E
0C788:  MOVLB  0
....................             fprintf(PC, "\t\t-> dequeue NULL (break)\r\n");
0C78A:  MOVLW  2C
0C78C:  MOVWF  FF6
0C78E:  MOVLW  12
0C790:  MOVWF  FF7
0C792:  MOVLW  00
0C794:  MOVWF  FF8
0C796:  CALL   1BF6
....................             break;
0C79A:  GOTO   C98C
....................         }
.................... 
....................         fprintf(PC, "\t\t-> Dequeued: func=%u mission=%u size=%ld addr=%ld\r\n",
....................                 (unsigned int)smf_data->func_type,
....................                 (unsigned int)smf_data->mission_id,
....................                 smf_data->misf_size,
....................                 smf_data->misf_start_addr);
0C79E:  MOVLW  01
0C7A0:  MOVLB  1
0C7A2:  ADDWF  xBD,W
0C7A4:  MOVWF  FE9
0C7A6:  MOVLW  00
0C7A8:  ADDWFC xBE,W
0C7AA:  MOVWF  FEA
0C7AC:  MOVFF  FEF,1BF
0C7B0:  MOVF   xBD,W
0C7B2:  MOVWF  FE9
0C7B4:  MOVF   xBE,W
0C7B6:  MOVWF  FEA
0C7B8:  MOVFF  FEF,1C0
0C7BC:  MOVLW  08
0C7BE:  ADDWF  xBD,W
0C7C0:  MOVWF  FE9
0C7C2:  MOVLW  00
0C7C4:  ADDWFC xBE,W
0C7C6:  MOVWF  FEA
0C7C8:  MOVFF  FEF,1C1
0C7CC:  MOVFF  FEC,1C2
0C7D0:  MOVFF  FEC,1C3
0C7D4:  MOVFF  FEC,1C4
0C7D8:  MOVF   FED,F
0C7DA:  MOVF   FED,F
0C7DC:  MOVF   FED,F
0C7DE:  MOVLW  04
0C7E0:  ADDWF  xBD,W
0C7E2:  MOVWF  FE9
0C7E4:  MOVLW  00
0C7E6:  ADDWFC xBE,W
0C7E8:  MOVWF  FEA
0C7EA:  MOVFF  FEF,1C5
0C7EE:  MOVFF  FEC,1C6
0C7F2:  MOVFF  FEC,1C7
0C7F6:  MOVFF  FEC,1C8
0C7FA:  MOVF   FED,F
0C7FC:  MOVF   FED,F
0C7FE:  MOVF   FED,F
0C800:  MOVLW  48
0C802:  MOVWF  FF6
0C804:  MOVLW  12
0C806:  MOVWF  FF7
0C808:  MOVLW  00
0C80A:  MOVWF  FF8
0C80C:  MOVLW  14
0C80E:  MOVLB  9
0C810:  MOVWF  xE9
0C812:  MOVLB  0
0C814:  CALL   1C2C
0C818:  MOVFF  1BF,298
0C81C:  MOVLW  1B
0C81E:  MOVLB  2
0C820:  MOVWF  x99
0C822:  MOVLB  0
0C824:  CALL   A8FC
0C828:  MOVLW  5E
0C82A:  MOVWF  FF6
0C82C:  MOVLW  12
0C82E:  MOVWF  FF7
0C830:  MOVLW  00
0C832:  MOVWF  FF8
0C834:  MOVLW  09
0C836:  MOVLB  9
0C838:  MOVWF  xE9
0C83A:  MOVLB  0
0C83C:  CALL   1C2C
0C840:  MOVFF  1C0,298
0C844:  MOVLW  1B
0C846:  MOVLB  2
0C848:  MOVWF  x99
0C84A:  MOVLB  0
0C84C:  CALL   A8FC
0C850:  MOVLW  69
0C852:  MOVWF  FF6
0C854:  MOVLW  12
0C856:  MOVWF  FF7
0C858:  MOVLW  00
0C85A:  MOVWF  FF8
0C85C:  MOVLW  06
0C85E:  MOVLB  9
0C860:  MOVWF  xE9
0C862:  MOVLB  0
0C864:  CALL   1C2C
0C868:  MOVLW  41
0C86A:  MOVWF  FE9
0C86C:  MOVFF  1C4,297
0C870:  MOVFF  1C3,296
0C874:  MOVFF  1C2,295
0C878:  MOVFF  1C1,294
0C87C:  CALL   AA92
0C880:  MOVLW  72
0C882:  MOVWF  FF6
0C884:  MOVLW  12
0C886:  MOVWF  FF7
0C888:  MOVLW  00
0C88A:  MOVWF  FF8
0C88C:  MOVLW  06
0C88E:  MOVLB  9
0C890:  MOVWF  xE9
0C892:  MOVLB  0
0C894:  CALL   1C2C
0C898:  MOVLW  41
0C89A:  MOVWF  FE9
0C89C:  MOVFF  1C8,297
0C8A0:  MOVFF  1C7,296
0C8A4:  MOVFF  1C6,295
0C8A8:  MOVFF  1C5,294
0C8AC:  CALL   AA92
0C8B0:  MOVLW  0D
0C8B2:  BTFSS  FA6.6
0C8B4:  GOTO   C8B2
0C8B8:  MOVLB  E
0C8BA:  MOVWF  xF9
0C8BC:  MOVLW  0A
0C8BE:  MOVLB  0
0C8C0:  BTFSS  FA6.6
0C8C2:  GOTO   C8C0
0C8C6:  MOVLB  E
0C8C8:  MOVWF  xF9
.................... 
....................         switch (smf_data->func_type) {
0C8CA:  MOVLW  01
0C8CC:  MOVLB  1
0C8CE:  ADDWF  xBD,W
0C8D0:  MOVWF  FE9
0C8D2:  MOVLW  00
0C8D4:  ADDWFC xBE,W
0C8D6:  MOVWF  FEA
0C8D8:  MOVF   FEF,W
0C8DA:  XORLW  00
0C8DC:  MOVLB  0
0C8DE:  BTFSC  FD8.2
0C8E0:  GOTO   C8F8
0C8E4:  XORLW  01
0C8E6:  BTFSC  FD8.2
0C8E8:  GOTO   C908
0C8EC:  XORLW  03
0C8EE:  BTFSC  FD8.2
0C8F0:  GOTO   C918
0C8F4:  GOTO   C928
....................             case ENUM_SMF_WRITE:
....................                 smf_write(smf_data);
0C8F8:  MOVFF  1BE,1C0
0C8FC:  MOVFF  1BD,1BF
0C900:  GOTO   B300
....................                 break;
0C904:  GOTO   C982
....................             case ENUM_SMF_READ:
....................                 smf_read(smf_data);
0C908:  MOVFF  1BE,1C0
0C90C:  MOVFF  1BD,1BF
0C910:  GOTO   BE22
....................                 break;
0C914:  GOTO   C982
....................             case ENUM_SMF_ERASE:
....................                 smf_erase(smf_data);
0C918:  MOVFF  1BE,1C0
0C91C:  MOVFF  1BD,1BF
0C920:  GOTO   C1BA
....................                 break;
0C924:  GOTO   C982
....................             default:
....................                 fprintf(PC, "\t\t   Unknown func_type=%u\r\n",
....................                         (unsigned int)smf_data->func_type);
0C928:  MOVLW  01
0C92A:  MOVLB  1
0C92C:  ADDWF  xBD,W
0C92E:  MOVWF  FE9
0C930:  MOVLW  00
0C932:  ADDWFC xBE,W
0C934:  MOVWF  FEA
0C936:  MOVFF  FEF,1BF
0C93A:  MOVLW  7E
0C93C:  MOVWF  FF6
0C93E:  MOVLW  12
0C940:  MOVWF  FF7
0C942:  MOVLW  00
0C944:  MOVWF  FF8
0C946:  MOVLW  17
0C948:  MOVLB  9
0C94A:  MOVWF  xE9
0C94C:  MOVLB  0
0C94E:  CALL   1C2C
0C952:  MOVFF  1BF,298
0C956:  MOVLW  1B
0C958:  MOVLB  2
0C95A:  MOVWF  x99
0C95C:  MOVLB  0
0C95E:  CALL   A8FC
0C962:  MOVLW  0D
0C964:  BTFSS  FA6.6
0C966:  GOTO   C964
0C96A:  MOVLB  E
0C96C:  MOVWF  xF9
0C96E:  MOVLW  0A
0C970:  MOVLB  0
0C972:  BTFSS  FA6.6
0C974:  GOTO   C972
0C978:  MOVLB  E
0C97A:  MOVWF  xF9
....................                 break;
0C97C:  MOVLB  0
0C97E:  GOTO   C982
....................         }
....................         processed_count++;
0C982:  MOVLB  1
0C984:  INCF   xBC,F
0C986:  MOVLB  0
0C988:  GOTO   C752
....................     }
.................... 
....................     fprintf(PC, "\t\t-> Completed %u operations\r\n",
....................             (unsigned int)processed_count);
0C98C:  MOVLW  9A
0C98E:  MOVWF  FF6
0C990:  MOVLW  12
0C992:  MOVWF  FF7
0C994:  MOVLW  00
0C996:  MOVWF  FF8
0C998:  MOVLW  0F
0C99A:  MOVLB  9
0C99C:  MOVWF  xE9
0C99E:  MOVLB  0
0C9A0:  CALL   1C2C
0C9A4:  MOVFF  1BC,298
0C9A8:  MOVLW  1B
0C9AA:  MOVLB  2
0C9AC:  MOVWF  x99
0C9AE:  MOVLB  0
0C9B0:  CALL   A8FC
0C9B4:  MOVLW  AB
0C9B6:  MOVWF  FF6
0C9B8:  MOVLW  12
0C9BA:  MOVWF  FF7
0C9BC:  MOVLW  00
0C9BE:  MOVWF  FF8
0C9C0:  MOVLW  0D
0C9C2:  MOVLB  9
0C9C4:  MOVWF  xE9
0C9C6:  MOVLB  0
0C9C8:  CALL   1C2C
.................... 
....................     status[0] = FINISHED;
0C9CC:  MOVLW  06
0C9CE:  MOVWF  4C
0C9D0:  GOTO   CA4A (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "application/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define CMD_LENGTH 9
.................... 
.................... // ______________CMD ID________________
.................... // Operation Command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_DEBUG 0xA1
.................... #define ID_MEAS_ENV 0xA2
.................... #define ID_MEAS_ENV_DEBUG 0xA3
.................... 
.................... // ______________MODE FUNCTIONS____________
.................... void mode_meas_iv(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_iv_debug(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_env(unsigned int8 *uplinkcmd_ptr);
.................... void mode_meas_env_debug(unsigned int8 *uplinkcmd_ptr);
.................... 
.................... 
.................... typedef union {
....................     unsigned int8 raw;
....................     struct {
....................         unsigned int8 mission_continue : 1;
....................         unsigned int8 erase_and_save : 1;
....................         unsigned int8 reserved : 6;
....................     } flag;
.................... } mission_state_t;
.................... 
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     mission_state_t mission_state; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... #define HEADER_SIZE 5  // START_MAKER + time (4バイト)
.................... #define ENV_SIZE    6  // pd + temp_py_top + temp_py_bot + temp_mis7 packed
.................... #define DATA_SIZE_PER_STEP 3 // data0 + data1 12bitずつ
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd_ptr)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
07666:  MOVLW  BA
07668:  MOVWF  FF6
0766A:  MOVLW  12
0766C:  MOVWF  FF7
0766E:  MOVLW  00
07670:  MOVWF  FF8
07672:  CALL   1BF6
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd_ptr); // Create the measurement command structure
07676:  MOVFF  1C2,1E6
0767A:  MOVFF  1C1,1E5
0767E:  CALL   7308
07682:  MOVFF  02,03
07686:  MOVF   01,W
07688:  MOVWF  FE1
0768A:  MOVFF  03,FE2
0768E:  MOVLW  01
07690:  MOVWF  FEA
07692:  MOVLW  C3
07694:  MOVWF  FE9
07696:  MOVLW  0C
07698:  MOVWF  01
0769A:  MOVFF  FE6,FEE
0769E:  DECFSZ 01,F
076A0:  GOTO   769A
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
076A4:  MOVLW  D0
076A6:  MOVWF  FF6
076A8:  MOVLW  12
076AA:  MOVWF  FF7
076AC:  MOVLW  00
076AE:  MOVWF  FF8
076B0:  MOVLW  05
076B2:  MOVLB  9
076B4:  MOVWF  xE9
076B6:  MOVLB  0
076B8:  CALL   1C2C
076BC:  MOVFF  1C3,A48
076C0:  MOVLW  37
076C2:  MOVLB  A
076C4:  MOVWF  x49
076C6:  MOVLB  0
076C8:  CALL   1E3C
076CC:  MOVLW  0D
076CE:  BTFSS  FA6.6
076D0:  GOTO   76CE
076D4:  MOVLB  E
076D6:  MOVWF  xF9
076D8:  MOVLW  0A
076DA:  MOVLB  0
076DC:  BTFSS  FA6.6
076DE:  GOTO   76DC
076E2:  MOVLB  E
076E4:  MOVWF  xF9
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
076E6:  MOVLW  DC
076E8:  MOVWF  FF6
076EA:  MOVLW  12
076EC:  MOVWF  FF7
076EE:  MOVLW  00
076F0:  MOVWF  FF8
076F2:  MOVLW  0D
076F4:  MOVLB  9
076F6:  MOVWF  xE9
076F8:  MOVLB  0
076FA:  CALL   1C2C
076FE:  MOVFF  1C5,A48
07702:  MOVLW  37
07704:  MOVLB  A
07706:  MOVWF  x49
07708:  MOVLB  0
0770A:  CALL   1E3C
0770E:  MOVFF  1C4,A48
07712:  MOVLW  37
07714:  MOVLB  A
07716:  MOVWF  x49
07718:  MOVLB  0
0771A:  CALL   1E3C
0771E:  MOVLW  EE
07720:  MOVWF  FF6
07722:  MOVLW  12
07724:  MOVWF  FF7
07726:  MOVLW  00
07728:  MOVWF  FF8
0772A:  MOVLW  05
0772C:  MOVLB  9
0772E:  MOVWF  xE9
07730:  MOVLB  0
07732:  CALL   1C2C
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
07736:  MOVLW  F4
07738:  MOVWF  FF6
0773A:  MOVLW  12
0773C:  MOVWF  FF7
0773E:  MOVLW  00
07740:  MOVWF  FF8
07742:  MOVLW  14
07744:  MOVLB  9
07746:  MOVWF  xE9
07748:  MOVLB  0
0774A:  CALL   1C2C
0774E:  MOVFF  1C7,A48
07752:  MOVLW  37
07754:  MOVLB  A
07756:  MOVWF  x49
07758:  MOVLB  0
0775A:  CALL   1E3C
0775E:  MOVFF  1C6,A48
07762:  MOVLW  37
07764:  MOVLB  A
07766:  MOVWF  x49
07768:  MOVLB  0
0776A:  CALL   1E3C
0776E:  MOVLW  0D
07770:  MOVWF  FF6
07772:  MOVLW  13
07774:  MOVWF  FF7
07776:  MOVLW  00
07778:  MOVWF  FF8
0777A:  MOVLW  05
0777C:  MOVLB  9
0777E:  MOVWF  xE9
07780:  MOVLB  0
07782:  CALL   1C2C
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
07786:  MOVLW  14
07788:  MOVWF  FF6
0778A:  MOVLW  13
0778C:  MOVWF  FF7
0778E:  MOVLW  00
07790:  MOVWF  FF8
07792:  MOVLW  0F
07794:  MOVLB  9
07796:  MOVWF  xE9
07798:  MOVLB  0
0779A:  CALL   1C2C
0779E:  MOVFF  1C9,A48
077A2:  MOVLW  37
077A4:  MOVLB  A
077A6:  MOVWF  x49
077A8:  MOVLB  0
077AA:  CALL   1E3C
077AE:  MOVFF  1C8,A48
077B2:  MOVLW  37
077B4:  MOVLB  A
077B6:  MOVWF  x49
077B8:  MOVLB  0
077BA:  CALL   1E3C
077BE:  MOVLW  28
077C0:  MOVWF  FF6
077C2:  MOVLW  13
077C4:  MOVWF  FF7
077C6:  MOVLW  00
077C8:  MOVWF  FF8
077CA:  MOVLW  05
077CC:  MOVLB  9
077CE:  MOVWF  xE9
077D0:  MOVLB  0
077D2:  CALL   1C2C
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
077D6:  MOVLW  2E
077D8:  MOVWF  FF6
077DA:  MOVLW  13
077DC:  MOVWF  FF7
077DE:  MOVLW  00
077E0:  MOVWF  FF8
077E2:  MOVLW  10
077E4:  MOVLB  9
077E6:  MOVWF  xE9
077E8:  MOVLB  0
077EA:  CALL   1C2C
077EE:  MOVFF  1CB,A48
077F2:  MOVLW  37
077F4:  MOVLB  A
077F6:  MOVWF  x49
077F8:  MOVLB  0
077FA:  CALL   1E3C
077FE:  MOVFF  1CA,A48
07802:  MOVLW  37
07804:  MOVLB  A
07806:  MOVWF  x49
07808:  MOVLB  0
0780A:  CALL   1E3C
0780E:  MOVLW  43
07810:  MOVWF  FF6
07812:  MOVLW  13
07814:  MOVWF  FF7
07816:  MOVLW  00
07818:  MOVWF  FF8
0781A:  MOVLW  05
0781C:  MOVLB  9
0781E:  MOVWF  xE9
07820:  MOVLB  0
07822:  CALL   1C2C
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
07826:  MOVLW  4A
07828:  MOVWF  FF6
0782A:  MOVLW  13
0782C:  MOVWF  FF7
0782E:  MOVLW  00
07830:  MOVWF  FF8
07832:  MOVLW  13
07834:  MOVLB  9
07836:  MOVWF  xE9
07838:  MOVLB  0
0783A:  CALL   1C2C
0783E:  MOVFF  1CD,A48
07842:  MOVLW  37
07844:  MOVLB  A
07846:  MOVWF  x49
07848:  MOVLB  0
0784A:  CALL   1E3C
0784E:  MOVFF  1CC,A48
07852:  MOVLW  37
07854:  MOVLB  A
07856:  MOVWF  x49
07858:  MOVLB  0
0785A:  CALL   1E3C
0785E:  MOVLW  62
07860:  MOVWF  FF6
07862:  MOVLW  13
07864:  MOVWF  FF7
07866:  MOVLW  00
07868:  MOVWF  FF8
0786A:  MOVLW  04
0786C:  MOVLB  9
0786E:  MOVWF  xE9
07870:  MOVLB  0
07872:  CALL   1C2C
.................... //!   fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
07876:  MOVFF  1C3,214
0787A:  MOVLB  2
0787C:  CLRF   x15
0787E:  MOVLB  0
07880:  CALL   49C2
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
07884:  CALL   3BA8
07888:  MOVFF  01,1D0
0788C:  MOVFF  00,1CF
07890:  MOVLB  1
07892:  CLRF   xD2
07894:  CLRF   xD1
07896:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
07898:  CALL   3BA8
0789C:  MOVFF  03,1E2
078A0:  MOVFF  02,1E1
078A4:  MOVFF  01,1E0
078A8:  MOVFF  00,1DF
078AC:  MOVLB  1
078AE:  MOVF   xCF,W
078B0:  SUBWF  xDF,F
078B2:  MOVF   xD0,W
078B4:  SUBWFB xE0,F
078B6:  MOVLW  00
078B8:  SUBWFB xE1,F
078BA:  MOVLW  00
078BC:  SUBWFB xE2,F
078BE:  MOVF   xE2,F
078C0:  BTFSC  FD8.2
078C2:  BRA    78CA
078C4:  MOVLB  0
078C6:  GOTO   7978
078CA:  MOVLB  0
078CC:  MOVLB  1
078CE:  MOVF   xE1,F
078D0:  BTFSC  FD8.2
078D2:  BRA    78DA
078D4:  MOVLB  0
078D6:  GOTO   7978
078DA:  MOVLB  0
078DC:  MOVLB  1
078DE:  MOVF   xE0,W
078E0:  SUBWF  xCD,W
078E2:  BTFSC  FD8.0
078E4:  BRA    78EC
078E6:  MOVLB  0
078E8:  GOTO   7978
078EC:  MOVLB  0
078EE:  BTFSS  FD8.2
078F0:  GOTO   7906
078F4:  MOVLB  1
078F6:  MOVF   xCC,W
078F8:  SUBWF  xDF,W
078FA:  BTFSS  FD8.0
078FC:  BRA    7904
078FE:  MOVLB  0
07900:  GOTO   7978
07904:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
07906:  CALL   3BA8
0790A:  MOVFF  01,1D2
0790E:  MOVFF  00,1D1
....................       if (current_sec - start_time >= cmd.meas_time) {
07912:  MOVLB  1
07914:  MOVF   xCF,W
07916:  SUBWF  xD1,W
07918:  MOVWF  xDF
0791A:  MOVF   xD0,W
0791C:  SUBWFB xD2,W
0791E:  MOVWF  xE0
07920:  MOVF   xCD,W
07922:  SUBWF  xE0,W
07924:  BTFSC  FD8.0
07926:  BRA    792E
07928:  MOVLB  0
0792A:  GOTO   794C
0792E:  MOVLB  0
07930:  BTFSS  FD8.2
07932:  GOTO   7948
07936:  MOVLB  1
07938:  MOVF   xCC,W
0793A:  SUBWF  xDF,W
0793C:  BTFSC  FD8.0
0793E:  BRA    7946
07940:  MOVLB  0
07942:  GOTO   794C
07946:  MOVLB  0
....................           break;
07948:  GOTO   7978
....................       }
....................       //sweep(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
....................       delay_ms(cmd.sleep_time);
0794C:  MOVFF  1C5,1DF
07950:  MOVLB  1
07952:  INCF   xDF,F
07954:  MOVLB  0
07956:  MOVLB  1
07958:  DECFSZ xDF,F
0795A:  BRA    7960
0795C:  MOVLB  0
0795E:  BRA    796C
07960:  MOVLB  A
07962:  SETF   xA3
07964:  MOVLB  0
07966:  CALL   1BC8
0796A:  BRA    7956
0796C:  MOVFF  1C4,AA3
07970:  CALL   1BC8
07974:  GOTO   7898
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
07978:  MOVFF  1C3,214
0797C:  MOVLB  2
0797E:  SETF   x15
07980:  MOVLB  0
07982:  CALL   49C2
.................... 
....................    FlashOperationStruct data = {0};
07986:  MOVLB  1
07988:  CLRF   xD3
0798A:  CLRF   xD4
0798C:  CLRF   xD5
0798E:  CLRF   xD6
07990:  CLRF   xD7
07992:  CLRF   xD8
07994:  CLRF   xD9
07996:  CLRF   xDA
07998:  CLRF   xDB
0799A:  CLRF   xDC
0799C:  CLRF   xDD
0799E:  CLRF   xDE
....................    data.func_type = ENUM_SMF_WRITE;
079A0:  CLRF   xD4
....................    data.mission_id = CIGS_IV1_DATA; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
079A2:  MOVLW  04
079A4:  MOVWF  xD3
....................    data.write_mode = SMF_WRITE_CIRCULAR;
079A6:  MOVLW  02
079A8:  MOVWF  xD5
....................    data.source_type = SOURCE_MISF_UNCOPIED;
079AA:  BCF    xD6.0
....................    // data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    // data.size = 0; // コピーするデータのサイズ
.................... 
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
079AC:  MOVLW  68
079AE:  MOVWF  FF6
079B0:  MOVLW  13
079B2:  MOVWF  FF7
079B4:  MOVLW  00
079B6:  MOVWF  FF8
079B8:  MOVLB  0
079BA:  CALL   1BF6
....................    fprintf(PC, "Mission ID:   %02X\r\n", data.mission_id);
079BE:  MOVLW  82
079C0:  MOVWF  FF6
079C2:  MOVLW  13
079C4:  MOVWF  FF7
079C6:  MOVLW  00
079C8:  MOVWF  FF8
079CA:  MOVLW  0E
079CC:  MOVLB  9
079CE:  MOVWF  xE9
079D0:  MOVLB  0
079D2:  CALL   1C2C
079D6:  MOVFF  1D3,A48
079DA:  MOVLW  37
079DC:  MOVLB  A
079DE:  MOVWF  x49
079E0:  MOVLB  0
079E2:  CALL   1E3C
079E6:  MOVLW  0D
079E8:  BTFSS  FA6.6
079EA:  GOTO   79E8
079EE:  MOVLB  E
079F0:  MOVWF  xF9
079F2:  MOVLW  0A
079F4:  MOVLB  0
079F6:  BTFSS  FA6.6
079F8:  GOTO   79F6
079FC:  MOVLB  E
079FE:  MOVWF  xF9
....................    fprintf(PC, "Function Type:%02X\r\n", data.func_type);
07A00:  MOVLW  98
07A02:  MOVWF  FF6
07A04:  MOVLW  13
07A06:  MOVWF  FF7
07A08:  MOVLW  00
07A0A:  MOVWF  FF8
07A0C:  MOVLW  0E
07A0E:  MOVLB  9
07A10:  MOVWF  xE9
07A12:  MOVLB  0
07A14:  CALL   1C2C
07A18:  MOVFF  1D4,A48
07A1C:  MOVLW  37
07A1E:  MOVLB  A
07A20:  MOVWF  x49
07A22:  MOVLB  0
07A24:  CALL   1E3C
07A28:  MOVLW  0D
07A2A:  BTFSS  FA6.6
07A2C:  GOTO   7A2A
07A30:  MOVLB  E
07A32:  MOVWF  xF9
07A34:  MOVLW  0A
07A36:  MOVLB  0
07A38:  BTFSS  FA6.6
07A3A:  GOTO   7A38
07A3E:  MOVLB  E
07A40:  MOVWF  xF9
....................    fprintf(PC, "Write Mode:   %02X\r\n", data.write_mode);
07A42:  MOVLW  AE
07A44:  MOVWF  FF6
07A46:  MOVLW  13
07A48:  MOVWF  FF7
07A4A:  MOVLW  00
07A4C:  MOVWF  FF8
07A4E:  MOVLW  0E
07A50:  MOVLB  9
07A52:  MOVWF  xE9
07A54:  MOVLB  0
07A56:  CALL   1C2C
07A5A:  MOVFF  1D5,A48
07A5E:  MOVLW  37
07A60:  MOVLB  A
07A62:  MOVWF  x49
07A64:  MOVLB  0
07A66:  CALL   1E3C
07A6A:  MOVLW  0D
07A6C:  BTFSS  FA6.6
07A6E:  GOTO   7A6C
07A72:  MOVLB  E
07A74:  MOVWF  xF9
07A76:  MOVLW  0A
07A78:  MOVLB  0
07A7A:  BTFSS  FA6.6
07A7C:  GOTO   7A7A
07A80:  MOVLB  E
07A82:  MOVWF  xF9
....................    fprintf(PC, "Source Type:  %02X\r\n", data.source_type);
07A84:  MOVLW  00
07A86:  MOVLB  1
07A88:  BTFSC  xD6.0
07A8A:  MOVLW  01
07A8C:  MOVWF  xDF
07A8E:  MOVLW  C4
07A90:  MOVWF  FF6
07A92:  MOVLW  13
07A94:  MOVWF  FF7
07A96:  MOVLW  00
07A98:  MOVWF  FF8
07A9A:  MOVLW  0E
07A9C:  MOVLB  9
07A9E:  MOVWF  xE9
07AA0:  MOVLB  0
07AA2:  CALL   1C2C
07AA6:  MOVFF  1DF,A48
07AAA:  MOVLW  37
07AAC:  MOVLB  A
07AAE:  MOVWF  x49
07AB0:  MOVLB  0
07AB2:  CALL   1E3C
07AB6:  MOVLW  0D
07AB8:  BTFSS  FA6.6
07ABA:  GOTO   7AB8
07ABE:  MOVLB  E
07AC0:  MOVWF  xF9
07AC2:  MOVLW  0A
07AC4:  MOVLB  0
07AC6:  BTFSS  FA6.6
07AC8:  GOTO   7AC6
07ACC:  MOVLB  E
07ACE:  MOVWF  xF9
....................    fprintf(PC, "Start Address:%04X\r\n", data.misf_start_addr);
07AD0:  MOVLW  DA
07AD2:  MOVWF  FF6
07AD4:  MOVLW  13
07AD6:  MOVWF  FF7
07AD8:  MOVLW  00
07ADA:  MOVWF  FF8
07ADC:  MOVLW  0E
07ADE:  MOVLB  9
07AE0:  MOVWF  xE9
07AE2:  MOVLB  0
07AE4:  CALL   1C2C
07AE8:  MOVLW  02
07AEA:  MOVLB  1
07AEC:  MOVWF  xDF
07AEE:  MOVLB  0
07AF0:  MOVLW  30
07AF2:  BTFSS  FA6.6
07AF4:  GOTO   7AF2
07AF8:  MOVLB  E
07AFA:  MOVWF  xF9
07AFC:  MOVLB  1
07AFE:  DECFSZ xDF,F
07B00:  BRA    7B06
07B02:  BRA    7B0C
07B04:  MOVLB  0
07B06:  MOVLB  0
07B08:  GOTO   7AF0
07B0C:  MOVFF  1D7,A48
07B10:  MOVLW  37
07B12:  MOVLB  A
07B14:  MOVWF  x49
07B16:  MOVLB  0
07B18:  CALL   1E3C
07B1C:  MOVLW  0D
07B1E:  BTFSS  FA6.6
07B20:  GOTO   7B1E
07B24:  MOVLB  E
07B26:  MOVWF  xF9
07B28:  MOVLW  0A
07B2A:  MOVLB  0
07B2C:  BTFSS  FA6.6
07B2E:  GOTO   7B2C
07B32:  MOVLB  E
07B34:  MOVWF  xF9
....................    fprintf(PC, "Size:         %04X\r\n", data.misf_size);
07B36:  MOVLW  F0
07B38:  MOVWF  FF6
07B3A:  MOVLW  13
07B3C:  MOVWF  FF7
07B3E:  MOVLW  00
07B40:  MOVWF  FF8
07B42:  MOVLW  0E
07B44:  MOVLB  9
07B46:  MOVWF  xE9
07B48:  MOVLB  0
07B4A:  CALL   1C2C
07B4E:  MOVLW  02
07B50:  MOVLB  1
07B52:  MOVWF  xDF
07B54:  MOVLB  0
07B56:  MOVLW  30
07B58:  BTFSS  FA6.6
07B5A:  GOTO   7B58
07B5E:  MOVLB  E
07B60:  MOVWF  xF9
07B62:  MOVLB  1
07B64:  DECFSZ xDF,F
07B66:  BRA    7B6C
07B68:  BRA    7B72
07B6A:  MOVLB  0
07B6C:  MOVLB  0
07B6E:  GOTO   7B56
07B72:  MOVFF  1DB,A48
07B76:  MOVLW  37
07B78:  MOVLB  A
07B7A:  MOVWF  x49
07B7C:  MOVLB  0
07B7E:  CALL   1E3C
07B82:  MOVLW  0D
07B84:  BTFSS  FA6.6
07B86:  GOTO   7B84
07B8A:  MOVLB  E
07B8C:  MOVWF  xF9
07B8E:  MOVLW  0A
07B90:  MOVLB  0
07B92:  BTFSS  FA6.6
07B94:  GOTO   7B92
07B98:  MOVLB  E
07B9A:  MOVWF  xF9
.................... 
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
07B9C:  MOVLW  01
07B9E:  MOVLB  1
07BA0:  MOVWF  xE0
07BA2:  MOVLW  D3
07BA4:  MOVWF  xDF
07BA6:  MOVLB  0
07BA8:  GOTO   7404
.................... 
....................    fprintf(PC, "End MODE MEAS IV mission\r\n");
07BAC:  MOVLW  06
07BAE:  MOVWF  FF6
07BB0:  MOVLW  14
07BB2:  MOVWF  FF7
07BB4:  MOVLW  00
07BB6:  MOVWF  FF8
07BB8:  CALL   1BF6
07BBC:  GOTO   A704 (RETURN)
.................... }
.................... 
.................... void mode_meas_iv_debug(unsigned int8 *uplinkcmd_ptr)
.................... {
....................    fprintf(PC, "[IVDBG] Start MODE IV DEBUG\r\n");
*
09D88:  MOVLW  22
09D8A:  MOVWF  FF6
09D8C:  MOVLW  14
09D8E:  MOVWF  FF7
09D90:  MOVLW  00
09D92:  MOVWF  FF8
09D94:  CALL   1BF6
.................... 
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd_ptr); // Create the measurement command structure
09D98:  MOVFF  1C2,1E6
09D9C:  MOVFF  1C1,1E5
09DA0:  CALL   7308
09DA4:  MOVFF  02,03
09DA8:  MOVF   01,W
09DAA:  MOVWF  FE1
09DAC:  MOVFF  03,FE2
09DB0:  MOVLW  01
09DB2:  MOVWF  FEA
09DB4:  MOVLW  C3
09DB6:  MOVWF  FE9
09DB8:  MOVLW  0C
09DBA:  MOVWF  01
09DBC:  MOVFF  FE6,FEE
09DC0:  DECFSZ 01,F
09DC2:  GOTO   9DBC
.................... 
....................    fprintf(PC, "[IVDBG] ID: %02X\r\n", cmd.id);
09DC6:  MOVLW  40
09DC8:  MOVWF  FF6
09DCA:  MOVLW  14
09DCC:  MOVWF  FF7
09DCE:  MOVLW  00
09DD0:  MOVWF  FF8
09DD2:  MOVLW  0C
09DD4:  MOVLB  9
09DD6:  MOVWF  xE9
09DD8:  MOVLB  0
09DDA:  CALL   1C2C
09DDE:  MOVFF  1C3,A48
09DE2:  MOVLW  37
09DE4:  MOVLB  A
09DE6:  MOVWF  x49
09DE8:  MOVLB  0
09DEA:  CALL   1E3C
09DEE:  MOVLW  0D
09DF0:  BTFSS  FA6.6
09DF2:  GOTO   9DF0
09DF6:  MOVLB  E
09DF8:  MOVWF  xF9
09DFA:  MOVLW  0A
09DFC:  MOVLB  0
09DFE:  BTFSS  FA6.6
09E00:  GOTO   9DFE
09E04:  MOVLB  E
09E06:  MOVWF  xF9
....................    fprintf(PC, "[IVDBG] Sleep Time: %lu ms\r\n", cmd.sleep_time);
09E08:  MOVLW  54
09E0A:  MOVWF  FF6
09E0C:  MOVLW  14
09E0E:  MOVWF  FF7
09E10:  MOVLW  00
09E12:  MOVWF  FF8
09E14:  MOVLW  14
09E16:  MOVLB  9
09E18:  MOVWF  xE9
09E1A:  MOVLB  0
09E1C:  CALL   1C2C
09E20:  MOVLW  10
09E22:  MOVWF  FE9
09E24:  MOVFF  1C5,1D8
09E28:  MOVFF  1C4,1D7
09E2C:  CALL   7BC0
09E30:  MOVLW  6B
09E32:  MOVWF  FF6
09E34:  MOVLW  14
09E36:  MOVWF  FF7
09E38:  MOVLW  00
09E3A:  MOVWF  FF8
09E3C:  MOVLW  05
09E3E:  MOVLB  9
09E40:  MOVWF  xE9
09E42:  MOVLB  0
09E44:  CALL   1C2C
....................    fprintf(PC, "[IVDBG] Current Threshold: %lu mA\r\n", cmd.curr_threshold);
09E48:  MOVLW  72
09E4A:  MOVWF  FF6
09E4C:  MOVLW  14
09E4E:  MOVWF  FF7
09E50:  MOVLW  00
09E52:  MOVWF  FF8
09E54:  MOVLW  1B
09E56:  MOVLB  9
09E58:  MOVWF  xE9
09E5A:  MOVLB  0
09E5C:  CALL   1C2C
09E60:  MOVLW  10
09E62:  MOVWF  FE9
09E64:  MOVFF  1C7,1D8
09E68:  MOVFF  1C6,1D7
09E6C:  CALL   7BC0
09E70:  MOVLW  90
09E72:  MOVWF  FF6
09E74:  MOVLW  14
09E76:  MOVWF  FF7
09E78:  MOVLW  00
09E7A:  MOVWF  FF8
09E7C:  MOVLW  05
09E7E:  MOVLB  9
09E80:  MOVWF  xE9
09E82:  MOVLB  0
09E84:  CALL   1C2C
....................    fprintf(PC, "[IVDBG] PD Threshold: %lu mA\r\n", cmd.pd_threshold);
09E88:  MOVLW  96
09E8A:  MOVWF  FF6
09E8C:  MOVLW  14
09E8E:  MOVWF  FF7
09E90:  MOVLW  00
09E92:  MOVWF  FF8
09E94:  MOVLW  16
09E96:  MOVLB  9
09E98:  MOVWF  xE9
09E9A:  MOVLB  0
09E9C:  CALL   1C2C
09EA0:  MOVLW  10
09EA2:  MOVWF  FE9
09EA4:  MOVFF  1C9,1D8
09EA8:  MOVFF  1C8,1D7
09EAC:  CALL   7BC0
09EB0:  MOVLW  AF
09EB2:  MOVWF  FF6
09EB4:  MOVLW  14
09EB6:  MOVWF  FF7
09EB8:  MOVLW  00
09EBA:  MOVWF  FF8
09EBC:  MOVLW  05
09EBE:  MOVLB  9
09EC0:  MOVWF  xE9
09EC2:  MOVLB  0
09EC4:  CALL   1C2C
....................    fprintf(PC, "[IVDBG] Current Limit: %lu mA\r\n", cmd.curr_limit);
09EC8:  MOVLW  B6
09ECA:  MOVWF  FF6
09ECC:  MOVLW  14
09ECE:  MOVWF  FF7
09ED0:  MOVLW  00
09ED2:  MOVWF  FF8
09ED4:  MOVLW  17
09ED6:  MOVLB  9
09ED8:  MOVWF  xE9
09EDA:  MOVLB  0
09EDC:  CALL   1C2C
09EE0:  MOVLW  10
09EE2:  MOVWF  FE9
09EE4:  MOVFF  1CB,1D8
09EE8:  MOVFF  1CA,1D7
09EEC:  CALL   7BC0
09EF0:  MOVLW  D0
09EF2:  MOVWF  FF6
09EF4:  MOVLW  14
09EF6:  MOVWF  FF7
09EF8:  MOVLW  00
09EFA:  MOVWF  FF8
09EFC:  MOVLW  05
09EFE:  MOVLB  9
09F00:  MOVWF  xE9
09F02:  MOVLB  0
09F04:  CALL   1C2C
....................    fprintf(PC, "[IVDBG] Measurement Time: %lu s\r\n", cmd.meas_time);
09F08:  MOVLW  D6
09F0A:  MOVWF  FF6
09F0C:  MOVLW  14
09F0E:  MOVWF  FF7
09F10:  MOVLW  00
09F12:  MOVWF  FF8
09F14:  MOVLW  1A
09F16:  MOVLB  9
09F18:  MOVWF  xE9
09F1A:  MOVLB  0
09F1C:  CALL   1C2C
09F20:  MOVLW  10
09F22:  MOVWF  FE9
09F24:  MOVFF  1CD,1D8
09F28:  MOVFF  1CC,1D7
09F2C:  CALL   7BC0
09F30:  MOVLW  F3
09F32:  MOVWF  FF6
09F34:  MOVLW  14
09F36:  MOVWF  FF7
09F38:  MOVLW  00
09F3A:  MOVWF  FF8
09F3C:  MOVLW  04
09F3E:  MOVLB  9
09F40:  MOVWF  xE9
09F42:  MOVLB  0
09F44:  CALL   1C2C
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log start
09F48:  MOVFF  1C3,214
09F4C:  MOVLB  2
09F4E:  CLRF   x15
09F50:  MOVLB  0
09F52:  CALL   49C2
.................... 
....................    unsigned int32 start_time = get_current_time_10ms();
....................    unsigned int32 current_time = 0;
09F56:  CALL   7CDC
09F5A:  MOVFF  03,1D2
09F5E:  MOVFF  02,1D1
09F62:  MOVFF  01,1D0
09F66:  MOVFF  00,1CF
09F6A:  MOVLB  1
09F6C:  CLRF   xD6
09F6E:  CLRF   xD5
09F70:  CLRF   xD4
09F72:  CLRF   xD3
....................    test_sweep(cmd.curr_threshold, cmd.curr_limit);
09F74:  MOVFF  1C7,1D8
09F78:  MOVFF  1C6,1D7
09F7C:  MOVFF  1CB,1DA
09F80:  MOVFF  1CA,1D9
09F84:  MOVLB  0
09F86:  GOTO   89CE
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_END);
09F8A:  MOVFF  1C3,214
09F8E:  MOVLB  2
09F90:  SETF   x15
09F92:  MOVLB  0
09F94:  CALL   49C2
....................    fprintf(PC, "[IVDBG] End MODE IV DEBUG\r\n");
09F98:  MOVLW  F8
09F9A:  MOVWF  FF6
09F9C:  MOVLW  14
09F9E:  MOVWF  FF7
09FA0:  MOVLW  00
09FA2:  MOVWF  FF8
09FA4:  CALL   1BF6
09FA8:  GOTO   A714 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
07308:  MOVLB  1
0730A:  MOVF   xE5,W
0730C:  MOVWF  FE9
0730E:  MOVF   xE6,W
07310:  MOVWF  FEA
07312:  MOVFF  FEF,1E7
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
07316:  MOVLW  01
07318:  ADDWF  xE5,W
0731A:  MOVWF  FE9
0731C:  MOVLW  00
0731E:  ADDWFC xE6,W
07320:  MOVWF  FEA
07322:  MOVF   FEF,W
07324:  CLRF   xF4
07326:  MOVWF  xF3
07328:  MOVFF  1F3,1F4
0732C:  CLRF   xF3
0732E:  MOVLW  02
07330:  ADDWF  xE5,W
07332:  MOVWF  FE9
07334:  MOVLW  00
07336:  ADDWFC xE6,W
07338:  MOVWF  FEA
0733A:  MOVF   FEF,W
0733C:  CLRF   03
0733E:  IORWF  xF3,W
07340:  MOVWF  xE8
07342:  MOVF   03,W
07344:  IORWF  xF4,W
07346:  MOVWF  xE9
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
07348:  MOVLW  03
0734A:  ADDWF  xE5,W
0734C:  MOVWF  FE9
0734E:  MOVLW  00
07350:  ADDWFC xE6,W
07352:  MOVWF  FEA
07354:  MOVF   FEF,W
07356:  CLRF   xF4
07358:  MOVWF  xF3
0735A:  RLCF   xF3,W
0735C:  MOVWF  xEA
0735E:  RLCF   xF4,W
07360:  MOVWF  xEB
07362:  RLCF   xEA,F
07364:  RLCF   xEB,F
07366:  RLCF   xEA,F
07368:  RLCF   xEB,F
0736A:  RLCF   xEA,F
0736C:  RLCF   xEB,F
0736E:  MOVLW  F0
07370:  ANDWF  xEA,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
07372:  MOVLW  04
07374:  ADDWF  xE5,W
07376:  MOVWF  FE9
07378:  MOVLW  00
0737A:  ADDWFC xE6,W
0737C:  MOVWF  FEA
0737E:  MOVF   FEF,W
07380:  CLRF   xF4
07382:  MOVWF  xF3
07384:  RLCF   xF3,W
07386:  MOVWF  xEC
07388:  RLCF   xF4,W
0738A:  MOVWF  xED
0738C:  RLCF   xEC,F
0738E:  RLCF   xED,F
07390:  RLCF   xEC,F
07392:  RLCF   xED,F
07394:  RLCF   xEC,F
07396:  RLCF   xED,F
07398:  MOVLW  F0
0739A:  ANDWF  xEC,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
0739C:  MOVLW  05
0739E:  ADDWF  xE5,W
073A0:  MOVWF  FE9
073A2:  MOVLW  00
073A4:  ADDWFC xE6,W
073A6:  MOVWF  FEA
073A8:  MOVF   FEF,W
073AA:  CLRF   xF4
073AC:  MOVWF  xF3
073AE:  RLCF   xF3,W
073B0:  MOVWF  xEE
073B2:  RLCF   xF4,W
073B4:  MOVWF  xEF
073B6:  RLCF   xEE,F
073B8:  RLCF   xEF,F
073BA:  RLCF   xEE,F
073BC:  RLCF   xEF,F
073BE:  RLCF   xEE,F
073C0:  RLCF   xEF,F
073C2:  MOVLW  F0
073C4:  ANDWF  xEE,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
073C6:  MOVLW  06
073C8:  ADDWF  xE5,W
073CA:  MOVWF  FE9
073CC:  MOVLW  00
073CE:  ADDWFC xE6,W
073D0:  MOVWF  FEA
073D2:  MOVF   FEF,W
073D4:  CLRF   xF4
073D6:  MOVWF  xF3
073D8:  MOVFF  1F3,1F4
073DC:  CLRF   xF3
073DE:  MOVLW  07
073E0:  ADDWF  xE5,W
073E2:  MOVWF  FE9
073E4:  MOVLW  00
073E6:  ADDWFC xE6,W
073E8:  MOVWF  FEA
073EA:  MOVF   FEF,W
073EC:  CLRF   03
073EE:  IORWF  xF3,W
073F0:  MOVWF  xF0
073F2:  MOVF   03,W
073F4:  IORWF  xF4,W
073F6:  MOVWF  xF1
.................... //!  cmd.is_finished = uplinkcmd[8];
....................    return cmd;
073F8:  MOVLW  E7
073FA:  MOVWF  01
073FC:  MOVLW  01
073FE:  MOVWF  02
07400:  MOVLB  0
07402:  RETURN 0
.................... }
.................... 
.................... void mode_meas_env(unsigned int8 *uplinkcmd_ptr)
*
09FAC:  MOVLB  1
09FAE:  CLRF   xC4
09FB0:  MOVLW  64
09FB2:  MOVWF  xC3
09FB4:  SETF   xC6
09FB6:  SETF   xC5
09FB8:  MOVLB  0
09FBA:  CALL   7CDC
09FBE:  MOVFF  03,1CA
09FC2:  MOVFF  02,1C9
09FC6:  MOVFF  01,1C8
09FCA:  MOVFF  00,1C7
09FCE:  MOVLB  1
09FD0:  MOVF   xC3,W
09FD2:  SUBWF  xC7,W
09FD4:  MOVWF  xCB
09FD6:  MOVF   xC4,W
09FD8:  SUBWFB xC8,W
09FDA:  MOVWF  xCC
09FDC:  MOVLW  00
09FDE:  SUBWFB xC9,W
09FE0:  MOVWF  xCD
09FE2:  MOVLW  00
09FE4:  SUBWFB xCA,W
09FE6:  MOVWF  xCE
.................... {
....................    unsigned int16 interval = 100;   // 測定間隔 [秒]
....................    unsigned int16 end_time = 0xFFFF;
.................... 
....................    unsigned int32 current_time = get_current_time_10ms();
....................    unsigned int32 last_time = current_time - interval;  // 最初にすぐ測定するため
.................... 
....................    // loging data
....................    unsigned int8 logdata[6];
....................    unsigned int16 temp_top;
....................    unsigned int16 temp_bot;
....................    unsigned int16 temp_mis7;
....................    unsigned int16 PD;
.................... 
....................    // Flash Write 
....................    unsigned int32 write_address;
.................... 
....................    fprintf(PC, "temp_top, temp_bot, temp_mis7, pd\r\n");
09FE8:  MOVLW  14
09FEA:  MOVWF  FF6
09FEC:  MOVLW  15
09FEE:  MOVWF  FF7
09FF0:  MOVLW  00
09FF2:  MOVWF  FF8
09FF4:  MOVLB  0
09FF6:  CALL   1BF6
.................... 
....................    while (true) {
....................        current_time = get_current_time_10ms();
09FFA:  CALL   7CDC
09FFE:  MOVFF  03,1CA
0A002:  MOVFF  02,1C9
0A006:  MOVFF  01,1C8
0A00A:  MOVFF  00,1C7
.................... 
....................        // intervalごとに測定
....................        if ((current_time - last_time) >= interval) {
0A00E:  MOVLB  1
0A010:  MOVF   xCB,W
0A012:  SUBWF  xC7,W
0A014:  MOVWF  xE5
0A016:  MOVF   xCC,W
0A018:  SUBWFB xC8,W
0A01A:  MOVWF  xE6
0A01C:  MOVF   xCD,W
0A01E:  SUBWFB xC9,W
0A020:  MOVWF  xE7
0A022:  MOVF   xCE,W
0A024:  SUBWFB xCA,W
0A026:  MOVWF  xE8
0A028:  MOVF   xE8,F
0A02A:  BTFSC  FD8.2
0A02C:  BRA    A034
0A02E:  MOVLB  0
0A030:  GOTO   A070
0A034:  MOVLB  0
0A036:  MOVLB  1
0A038:  MOVF   xE7,F
0A03A:  BTFSC  FD8.2
0A03C:  BRA    A044
0A03E:  MOVLB  0
0A040:  GOTO   A070
0A044:  MOVLB  0
0A046:  MOVLB  1
0A048:  MOVF   xC4,W
0A04A:  SUBWF  xE6,W
0A04C:  BTFSC  FD8.0
0A04E:  BRA    A056
0A050:  MOVLB  0
0A052:  GOTO   A47A
0A056:  MOVLB  0
0A058:  BTFSS  FD8.2
0A05A:  GOTO   A070
0A05E:  MOVLB  1
0A060:  MOVF   xC3,W
0A062:  SUBWF  xE5,W
0A064:  BTFSC  FD8.0
0A066:  BRA    A06E
0A068:  MOVLB  0
0A06A:  GOTO   A47A
0A06E:  MOVLB  0
....................            last_time = current_time;
0A070:  MOVFF  1CA,1CE
0A074:  MOVFF  1C9,1CD
0A078:  MOVFF  1C8,1CC
0A07C:  MOVFF  1C7,1CB
.................... 
....................            // ★ 次の測定データ(6バイト)で64バイト境界を超えるか確認
....................            if (environment_data_ptr->reserve_counter1 + 6 > PACKET_SIZE) {
0A080:  MOVLW  09
0A082:  MOVLB  1
0A084:  ADDWF  x26,W
0A086:  MOVWF  FE9
0A088:  MOVLW  00
0A08A:  ADDWFC x27,W
0A08C:  MOVWF  FEA
0A08E:  MOVLW  06
0A090:  ADDWF  FEF,W
0A092:  SUBLW  40
0A094:  BTFSS  FD8.0
0A096:  BRA    A09E
0A098:  MOVLB  0
0A09A:  GOTO   A1B2
0A09E:  MOVLB  0
....................                unsigned int8 bankdata[4] = {0};
0A0A0:  MOVLB  1
0A0A2:  CLRF   xE1
0A0A4:  CLRF   xE2
0A0A6:  CLRF   xE3
0A0A8:  CLRF   xE4
0A0AA:  MOVLB  0
....................                write_address = MISF_CIGS_ENVIRO_START + environment_data_ptr->used_counter;
0A0AC:  MOVLW  01
0A0AE:  MOVLB  1
0A0B0:  ADDWF  x26,W
0A0B2:  MOVWF  FE9
0A0B4:  MOVLW  00
0A0B6:  ADDWFC x27,W
0A0B8:  MOVWF  FEA
0A0BA:  MOVFF  FEF,00
0A0BE:  MOVFF  FEC,01
0A0C2:  MOVFF  FEC,02
0A0C6:  MOVFF  FEC,03
0A0CA:  MOVF   FED,F
0A0CC:  MOVF   FED,F
0A0CE:  MOVF   FED,F
0A0D0:  MOVF   00,W
0A0D2:  MOVWF  xDD
0A0D4:  MOVLW  10
0A0D6:  ADDWF  01,W
0A0D8:  MOVWF  xDE
0A0DA:  MOVLW  28
0A0DC:  ADDWFC 02,W
0A0DE:  MOVWF  xDF
0A0E0:  MOVLW  00
0A0E2:  ADDWFC 03,W
0A0E4:  MOVWF  xE0
....................                write_data_bytes(mis_fm, write_address, bankdata, 4);
0A0E6:  MOVFF  115,A8E
0A0EA:  MOVFF  114,A8D
0A0EE:  MOVFF  113,A8C
0A0F2:  MOVFF  112,A8B
0A0F6:  MOVFF  1E0,A92
0A0FA:  MOVFF  1DF,A91
0A0FE:  MOVFF  1DE,A90
0A102:  MOVFF  1DD,A8F
0A106:  MOVLW  01
0A108:  MOVLB  A
0A10A:  MOVWF  x94
0A10C:  MOVLW  E1
0A10E:  MOVWF  x93
0A110:  CLRF   x96
0A112:  MOVLW  04
0A114:  MOVWF  x95
0A116:  MOVLB  0
0A118:  CALL   3EC0
....................                environment_data_ptr->used_counter   += 4;
0A11C:  MOVLW  01
0A11E:  MOVLB  1
0A120:  ADDWF  x26,W
0A122:  MOVWF  FE9
0A124:  MOVLW  00
0A126:  ADDWFC x27,W
0A128:  MOVWF  FEA
0A12A:  MOVLW  04
0A12C:  ADDWF  FEF,W
0A12E:  MOVWF  00
0A130:  MOVLW  00
0A132:  ADDWFC FEC,W
0A134:  MOVWF  01
0A136:  MOVLW  00
0A138:  ADDWFC FEC,W
0A13A:  MOVWF  02
0A13C:  MOVLW  00
0A13E:  ADDWFC FEC,W
0A140:  MOVWF  03
0A142:  MOVF   FED,F
0A144:  MOVF   FED,F
0A146:  MOVF   FED,F
0A148:  MOVFF  00,FEF
0A14C:  MOVFF  01,FEC
0A150:  MOVFF  02,FEC
0A154:  MOVFF  03,FEC
0A158:  MOVF   FED,F
0A15A:  MOVF   FED,F
0A15C:  MOVF   FED,F
....................                environment_data_ptr->uncopied_counter += 4;
0A15E:  MOVLW  05
0A160:  ADDWF  x26,W
0A162:  MOVWF  FE9
0A164:  MOVLW  00
0A166:  ADDWFC x27,W
0A168:  MOVWF  FEA
0A16A:  MOVLW  04
0A16C:  ADDWF  FEF,W
0A16E:  MOVWF  00
0A170:  MOVLW  00
0A172:  ADDWFC FEC,W
0A174:  MOVWF  01
0A176:  MOVLW  00
0A178:  ADDWFC FEC,W
0A17A:  MOVWF  02
0A17C:  MOVLW  00
0A17E:  ADDWFC FEC,W
0A180:  MOVWF  03
0A182:  MOVF   FED,F
0A184:  MOVF   FED,F
0A186:  MOVF   FED,F
0A188:  MOVFF  00,FEF
0A18C:  MOVFF  01,FEC
0A190:  MOVFF  02,FEC
0A194:  MOVFF  03,FEC
0A198:  MOVF   FED,F
0A19A:  MOVF   FED,F
0A19C:  MOVF   FED,F
....................                environment_data_ptr->reserve_counter1 = 0;
0A19E:  MOVLW  09
0A1A0:  ADDWF  x26,W
0A1A2:  MOVWF  FE9
0A1A4:  MOVLW  00
0A1A6:  ADDWFC x27,W
0A1A8:  MOVWF  FEA
0A1AA:  CLRF   FEF
....................                write_misf_address_area();
0A1AC:  MOVLB  0
0A1AE:  CALL   4934
....................            }
.................... 
....................            // 環境データ読み取り
....................            temp_top  = ad7490_read(ADC_TEMP_PY_TOP);
0A1B2:  MOVLW  0D
0A1B4:  MOVLB  9
0A1B6:  MOVWF  xFB
0A1B8:  MOVLB  0
0A1BA:  CALL   1DAA
0A1BE:  MOVFF  02,1D6
0A1C2:  MOVFF  01,1D5
....................            temp_bot  = ad7490_read(ADC_TEMP_PY_BOT);
0A1C6:  MOVLW  0E
0A1C8:  MOVLB  9
0A1CA:  MOVWF  xFB
0A1CC:  MOVLB  0
0A1CE:  CALL   1DAA
0A1D2:  MOVFF  02,1D8
0A1D6:  MOVFF  01,1D7
....................            temp_mis7 = ad7490_read(ADC_TEMP_MIS7);
0A1DA:  MOVLW  0C
0A1DC:  MOVLB  9
0A1DE:  MOVWF  xFB
0A1E0:  MOVLB  0
0A1E2:  CALL   1DAA
0A1E6:  MOVFF  02,1DA
0A1EA:  MOVFF  01,1D9
....................            PD        = ad7490_read(ADC_PD);
0A1EE:  MOVLW  0F
0A1F0:  MOVLB  9
0A1F2:  MOVWF  xFB
0A1F4:  MOVLB  0
0A1F6:  CALL   1DAA
0A1FA:  MOVFF  02,1DC
0A1FE:  MOVFF  01,1DB
.................... 
....................            logdata[0] = (temp_top >> 4) & 0xFF;
0A202:  MOVLB  1
0A204:  RRCF   xD6,W
0A206:  MOVWF  xE6
0A208:  RRCF   xD5,W
0A20A:  MOVWF  xE5
0A20C:  RRCF   xE6,F
0A20E:  RRCF   xE5,F
0A210:  RRCF   xE6,F
0A212:  RRCF   xE5,F
0A214:  RRCF   xE6,F
0A216:  RRCF   xE5,F
0A218:  MOVLW  0F
0A21A:  ANDWF  xE6,F
0A21C:  MOVF   xE5,W
0A21E:  MOVWF  xCF
....................            logdata[1] = ((temp_top & 0x0F) << 4) | ((temp_bot >> 8) & 0x0F);
0A220:  MOVF   xD5,W
0A222:  ANDLW  0F
0A224:  MOVWF  xE5
0A226:  CLRF   xE6
0A228:  RLCF   xE5,F
0A22A:  RLCF   xE6,F
0A22C:  RLCF   xE5,F
0A22E:  RLCF   xE6,F
0A230:  RLCF   xE5,F
0A232:  RLCF   xE6,F
0A234:  RLCF   xE5,F
0A236:  RLCF   xE6,F
0A238:  MOVLW  F0
0A23A:  ANDWF  xE5,F
0A23C:  MOVFF  1D8,1E7
0A240:  CLRF   xE8
0A242:  MOVF   xE7,W
0A244:  ANDLW  0F
0A246:  MOVWF  00
0A248:  CLRF   03
0A24A:  MOVF   00,W
0A24C:  IORWF  xE5,W
0A24E:  MOVWF  xD0
....................            logdata[2] = temp_bot & 0xFF;
0A250:  MOVF   xD7,W
0A252:  MOVWF  xD1
....................            logdata[3] = (temp_mis7 >> 4) & 0xFF;
0A254:  RRCF   xDA,W
0A256:  MOVWF  xE6
0A258:  RRCF   xD9,W
0A25A:  MOVWF  xE5
0A25C:  RRCF   xE6,F
0A25E:  RRCF   xE5,F
0A260:  RRCF   xE6,F
0A262:  RRCF   xE5,F
0A264:  RRCF   xE6,F
0A266:  RRCF   xE5,F
0A268:  MOVLW  0F
0A26A:  ANDWF  xE6,F
0A26C:  MOVF   xE5,W
0A26E:  MOVWF  xD2
....................            logdata[4] = temp_mis7 & 0xFF;
0A270:  MOVF   xD9,W
0A272:  MOVWF  xD3
....................            logdata[5] = PD & 0xFF;
0A274:  MOVF   xDB,W
0A276:  MOVWF  xD4
.................... 
....................            // 書き込み
....................            write_address = MISF_CIGS_ENVIRO_START + environment_data_ptr->used_counter;
0A278:  MOVLW  01
0A27A:  ADDWF  x26,W
0A27C:  MOVWF  FE9
0A27E:  MOVLW  00
0A280:  ADDWFC x27,W
0A282:  MOVWF  FEA
0A284:  MOVFF  FEF,00
0A288:  MOVFF  FEC,01
0A28C:  MOVFF  FEC,02
0A290:  MOVFF  FEC,03
0A294:  MOVF   FED,F
0A296:  MOVF   FED,F
0A298:  MOVF   FED,F
0A29A:  MOVF   00,W
0A29C:  MOVWF  xDD
0A29E:  MOVLW  10
0A2A0:  ADDWF  01,W
0A2A2:  MOVWF  xDE
0A2A4:  MOVLW  28
0A2A6:  ADDWFC 02,W
0A2A8:  MOVWF  xDF
0A2AA:  MOVLW  00
0A2AC:  ADDWFC 03,W
0A2AE:  MOVWF  xE0
....................            write_data_bytes(mis_fm, write_address, logdata, 6);
0A2B0:  MOVFF  115,A8E
0A2B4:  MOVFF  114,A8D
0A2B8:  MOVFF  113,A8C
0A2BC:  MOVFF  112,A8B
0A2C0:  MOVFF  1E0,A92
0A2C4:  MOVFF  1DF,A91
0A2C8:  MOVFF  1DE,A90
0A2CC:  MOVFF  1DD,A8F
0A2D0:  MOVLW  01
0A2D2:  MOVLB  A
0A2D4:  MOVWF  x94
0A2D6:  MOVLW  CF
0A2D8:  MOVWF  x93
0A2DA:  CLRF   x96
0A2DC:  MOVLW  06
0A2DE:  MOVWF  x95
0A2E0:  MOVLB  0
0A2E2:  CALL   3EC0
....................            environment_data_ptr->used_counter   += 6;
0A2E6:  MOVLW  01
0A2E8:  MOVLB  1
0A2EA:  ADDWF  x26,W
0A2EC:  MOVWF  FE9
0A2EE:  MOVLW  00
0A2F0:  ADDWFC x27,W
0A2F2:  MOVWF  FEA
0A2F4:  MOVLW  06
0A2F6:  ADDWF  FEF,W
0A2F8:  MOVWF  00
0A2FA:  MOVLW  00
0A2FC:  ADDWFC FEC,W
0A2FE:  MOVWF  01
0A300:  MOVLW  00
0A302:  ADDWFC FEC,W
0A304:  MOVWF  02
0A306:  MOVLW  00
0A308:  ADDWFC FEC,W
0A30A:  MOVWF  03
0A30C:  MOVF   FED,F
0A30E:  MOVF   FED,F
0A310:  MOVF   FED,F
0A312:  MOVFF  00,FEF
0A316:  MOVFF  01,FEC
0A31A:  MOVFF  02,FEC
0A31E:  MOVFF  03,FEC
0A322:  MOVF   FED,F
0A324:  MOVF   FED,F
0A326:  MOVF   FED,F
....................            environment_data_ptr->uncopied_counter += 6;
0A328:  MOVLW  05
0A32A:  ADDWF  x26,W
0A32C:  MOVWF  FE9
0A32E:  MOVLW  00
0A330:  ADDWFC x27,W
0A332:  MOVWF  FEA
0A334:  MOVLW  06
0A336:  ADDWF  FEF,W
0A338:  MOVWF  00
0A33A:  MOVLW  00
0A33C:  ADDWFC FEC,W
0A33E:  MOVWF  01
0A340:  MOVLW  00
0A342:  ADDWFC FEC,W
0A344:  MOVWF  02
0A346:  MOVLW  00
0A348:  ADDWFC FEC,W
0A34A:  MOVWF  03
0A34C:  MOVF   FED,F
0A34E:  MOVF   FED,F
0A350:  MOVF   FED,F
0A352:  MOVFF  00,FEF
0A356:  MOVFF  01,FEC
0A35A:  MOVFF  02,FEC
0A35E:  MOVFF  03,FEC
0A362:  MOVF   FED,F
0A364:  MOVF   FED,F
0A366:  MOVF   FED,F
....................            environment_data_ptr->reserve_counter1 += 6;
0A368:  MOVLW  09
0A36A:  ADDWF  x26,W
0A36C:  MOVWF  FE9
0A36E:  MOVLW  00
0A370:  ADDWFC x27,W
0A372:  MOVWF  FEA
0A374:  MOVLW  06
0A376:  ADDWF  FEF,W
0A378:  MOVWF  FEF
....................            fprintf(PC, "0x%04LX, 0x%04LX, 0x%04LX, 0x%04LX\r\n", temp_top, temp_bot, temp_mis7, PD);
0A37A:  MOVLW  30
0A37C:  MOVLB  0
0A37E:  BTFSS  FA6.6
0A380:  GOTO   A37E
0A384:  MOVLB  E
0A386:  MOVWF  xF9
0A388:  MOVLW  78
0A38A:  MOVLB  0
0A38C:  BTFSS  FA6.6
0A38E:  GOTO   A38C
0A392:  MOVLB  E
0A394:  MOVWF  xF9
0A396:  MOVFF  1D6,A48
0A39A:  MOVLW  37
0A39C:  MOVLB  A
0A39E:  MOVWF  x49
0A3A0:  MOVLB  0
0A3A2:  CALL   1E3C
0A3A6:  MOVFF  1D5,A48
0A3AA:  MOVLW  37
0A3AC:  MOVLB  A
0A3AE:  MOVWF  x49
0A3B0:  MOVLB  0
0A3B2:  CALL   1E3C
0A3B6:  MOVLW  3F
0A3B8:  MOVWF  FF6
0A3BA:  MOVLW  15
0A3BC:  MOVWF  FF7
0A3BE:  MOVLW  00
0A3C0:  MOVWF  FF8
0A3C2:  MOVLW  04
0A3C4:  MOVLB  9
0A3C6:  MOVWF  xE9
0A3C8:  MOVLB  0
0A3CA:  CALL   1C2C
0A3CE:  MOVFF  1D8,A48
0A3D2:  MOVLW  37
0A3D4:  MOVLB  A
0A3D6:  MOVWF  x49
0A3D8:  MOVLB  0
0A3DA:  CALL   1E3C
0A3DE:  MOVFF  1D7,A48
0A3E2:  MOVLW  37
0A3E4:  MOVLB  A
0A3E6:  MOVWF  x49
0A3E8:  MOVLB  0
0A3EA:  CALL   1E3C
0A3EE:  MOVLW  48
0A3F0:  MOVWF  FF6
0A3F2:  MOVLW  15
0A3F4:  MOVWF  FF7
0A3F6:  MOVLW  00
0A3F8:  MOVWF  FF8
0A3FA:  MOVLW  04
0A3FC:  MOVLB  9
0A3FE:  MOVWF  xE9
0A400:  MOVLB  0
0A402:  CALL   1C2C
0A406:  MOVFF  1DA,A48
0A40A:  MOVLW  37
0A40C:  MOVLB  A
0A40E:  MOVWF  x49
0A410:  MOVLB  0
0A412:  CALL   1E3C
0A416:  MOVFF  1D9,A48
0A41A:  MOVLW  37
0A41C:  MOVLB  A
0A41E:  MOVWF  x49
0A420:  MOVLB  0
0A422:  CALL   1E3C
0A426:  MOVLW  51
0A428:  MOVWF  FF6
0A42A:  MOVLW  15
0A42C:  MOVWF  FF7
0A42E:  MOVLW  00
0A430:  MOVWF  FF8
0A432:  MOVLW  04
0A434:  MOVLB  9
0A436:  MOVWF  xE9
0A438:  MOVLB  0
0A43A:  CALL   1C2C
0A43E:  MOVFF  1DC,A48
0A442:  MOVLW  37
0A444:  MOVLB  A
0A446:  MOVWF  x49
0A448:  MOVLB  0
0A44A:  CALL   1E3C
0A44E:  MOVFF  1DB,A48
0A452:  MOVLW  37
0A454:  MOVLB  A
0A456:  MOVWF  x49
0A458:  MOVLB  0
0A45A:  CALL   1E3C
0A45E:  MOVLW  0D
0A460:  BTFSS  FA6.6
0A462:  GOTO   A460
0A466:  MOVLB  E
0A468:  MOVWF  xF9
0A46A:  MOVLW  0A
0A46C:  MOVLB  0
0A46E:  BTFSS  FA6.6
0A470:  GOTO   A46E
0A474:  MOVLB  E
0A476:  MOVWF  xF9
0A478:  MOVLB  0
....................        }
.................... 
....................        delay_ms(1);  // 過負荷防止用
0A47A:  MOVLW  01
0A47C:  MOVLB  A
0A47E:  MOVWF  xA3
0A480:  MOVLB  0
0A482:  CALL   1BC8
0A486:  GOTO   9FFA
....................    }
0A48A:  GOTO   A724 (RETURN)
.................... }
.................... 
.................... void mode_meas_env_debug(unsigned int8 *uplinkcmd_ptr)
.................... {
....................    fprintf(PC, "Start MODE MEAS ENV DEBUG\r\n");
0A48E:  MOVLW  5E
0A490:  MOVWF  FF6
0A492:  MOVLW  15
0A494:  MOVWF  FF7
0A496:  MOVLW  00
0A498:  MOVWF  FF8
0A49A:  CALL   1BF6
....................    // Add debug-specific implementation here
....................    fprintf(PC, "End MODE MEAS ENV DEBUG\r\n");
0A49E:  MOVLW  7A
0A4A0:  MOVWF  FF6
0A4A2:  MOVLW  15
0A4A4:  MOVWF  FF7
0A4A6:  MOVLW  00
0A4A8:  MOVWF  FF8
0A4AA:  CALL   1BF6
0A4AE:  GOTO   A734 (RETURN)
.................... }
.................... 
.................... #include "application/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... #define HEADER_SIZE 5  // START_MAKER + time (4バイト)
.................... #define ENV_SIZE    6  // pd + temp_py_top + temp_py_bot + temp_mis7 packed
.................... #define DATA_SIZE_PER_STEP 3 // data0 + data1 12bitずつ
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../domain/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
053DA:  MOVLW  94
053DC:  MOVWF  FF6
053DE:  MOVLW  15
053E0:  MOVWF  FF7
053E2:  MOVLW  00
053E4:  MOVWF  FF8
053E6:  CALL   1BF6
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
053EA:  MOVLB  1
053EC:  MOVF   xC3,W
053EE:  MOVWF  FE9
053F0:  MOVF   xC4,W
053F2:  MOVWF  FEA
053F4:  MOVFF  FEF,1C5
....................    piclog_make(cmd, 0x00); // Log the command execution
053F8:  MOVFF  1C5,214
053FC:  MOVLB  2
053FE:  CLRF   x15
05400:  MOVLB  0
05402:  CALL   49C2
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
05406:  MOVLB  1
05408:  CLRF   xC9
0540A:  CLRF   xC8
0540C:  CLRF   xC7
0540E:  CLRF   xC6
05410:  MOVLB  0
05412:  MOVLB  1
05414:  MOVF   xC9,F
05416:  BTFSC  FD8.2
05418:  BRA    5420
0541A:  MOVLB  0
0541C:  GOTO   5498
05420:  MOVLB  0
05422:  MOVLB  1
05424:  MOVF   xC8,W
05426:  SUBLW  0F
05428:  BTFSC  FD8.0
0542A:  BRA    5432
0542C:  MOVLB  0
0542E:  GOTO   5498
05432:  MOVLB  0
05434:  BTFSS  FD8.2
05436:  GOTO   5464
0543A:  MOVLB  1
0543C:  MOVF   xC7,W
0543E:  SUBLW  FF
05440:  BTFSC  FD8.0
05442:  BRA    544A
05444:  MOVLB  0
05446:  GOTO   5498
0544A:  MOVLB  0
0544C:  BTFSS  FD8.2
0544E:  GOTO   5464
05452:  MOVLB  1
05454:  MOVF   xC6,W
05456:  SUBLW  FE
05458:  BTFSC  FD8.0
0545A:  BRA    5462
0545C:  MOVLB  0
0545E:  GOTO   5498
05462:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
05464:  MOVFF  115,A8C
05468:  MOVFF  114,A8B
0546C:  MOVFF  113,A8A
05470:  MOVFF  112,A89
05474:  MOVFF  1C9,A90
05478:  MOVFF  1C8,A8F
0547C:  MOVFF  1C7,A8E
05480:  MOVFF  1C6,A8D
05484:  CALL   45DC
05488:  MOVLW  01
0548A:  MOVLB  1
0548C:  ADDWF  xC8,F
0548E:  MOVLW  00
05490:  ADDWFC xC9,F
05492:  MOVLB  0
05494:  GOTO   5412
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05498:  MOVFF  1C5,214
0549C:  MOVLB  2
0549E:  SETF   x15
054A0:  MOVLB  0
054A2:  CALL   49C2
....................    printf("End Flash Erase All\r\n");
054A6:  MOVLW  AC
054A8:  MOVWF  FF6
054AA:  MOVLW  15
054AC:  MOVWF  FF7
054AE:  MOVLW  00
054B0:  MOVWF  FF8
054B2:  CALL   1BF6
054B6:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
054B8:  MOVLW  C2
054BA:  MOVWF  FF6
054BC:  MOVLW  15
054BE:  MOVWF  FF7
054C0:  MOVLW  00
054C2:  MOVWF  FF8
054C4:  CALL   1BF6
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
054C8:  MOVLB  1
054CA:  MOVF   xC1,W
054CC:  MOVWF  FE9
054CE:  MOVF   xC2,W
054D0:  MOVWF  FEA
054D2:  MOVFF  FEF,1C3
054D6:  MOVLW  01
054D8:  ADDWF  xC1,W
054DA:  MOVWF  FE9
054DC:  MOVLW  00
054DE:  ADDWFC xC2,W
054E0:  MOVWF  FEA
054E2:  MOVF   FEF,W
054E4:  CLRF   xCB
054E6:  CLRF   xCA
054E8:  CLRF   xC9
054EA:  MOVWF  xC8
054EC:  MOVFF  1C8,1CB
054F0:  CLRF   xC8
054F2:  CLRF   xC9
054F4:  CLRF   xCA
054F6:  MOVLW  02
054F8:  ADDWF  xC1,W
054FA:  MOVWF  FE9
054FC:  MOVLW  00
054FE:  ADDWFC xC2,W
05500:  MOVWF  FEA
05502:  MOVF   FEF,W
05504:  CLRF   xD0
05506:  CLRF   xCF
05508:  CLRF   xCE
0550A:  MOVWF  xCD
0550C:  MOVFF  1CE,03
05510:  MOVFF  1CD,02
05514:  CLRF   00
05516:  CLRF   01
05518:  MOVF   00,W
0551A:  IORWF  xC8,F
0551C:  MOVF   01,W
0551E:  IORWF  xC9,F
05520:  MOVF   02,W
05522:  IORWF  xCA,F
05524:  MOVF   03,W
05526:  IORWF  xCB,F
05528:  MOVLW  03
0552A:  ADDWF  xC1,W
0552C:  MOVWF  FE9
0552E:  MOVLW  00
05530:  ADDWFC xC2,W
05532:  MOVWF  FEA
05534:  MOVF   FEF,W
05536:  CLRF   xD0
05538:  CLRF   xCF
0553A:  CLRF   xCE
0553C:  MOVWF  xCD
0553E:  MOVFF  1CF,03
05542:  MOVFF  1CE,02
05546:  MOVFF  1CD,01
0554A:  CLRF   00
0554C:  MOVF   00,W
0554E:  IORWF  xC8,F
05550:  MOVF   01,W
05552:  IORWF  xC9,F
05554:  MOVF   02,W
05556:  IORWF  xCA,F
05558:  MOVF   03,W
0555A:  IORWF  xCB,F
0555C:  MOVLW  04
0555E:  ADDWF  xC1,W
05560:  MOVWF  FE9
05562:  MOVLW  00
05564:  ADDWFC xC2,W
05566:  MOVWF  FEA
05568:  MOVF   FEF,W
0556A:  MOVWF  00
0556C:  CLRF   01
0556E:  CLRF   02
05570:  CLRF   03
05572:  MOVF   00,W
05574:  IORWF  xC8,W
05576:  MOVWF  xC4
05578:  MOVF   01,W
0557A:  IORWF  xC9,W
0557C:  MOVWF  xC5
0557E:  MOVF   02,W
05580:  IORWF  xCA,W
05582:  MOVWF  xC6
05584:  MOVF   03,W
05586:  IORWF  xCB,W
05588:  MOVWF  xC7
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
0558A:  MOVLW  E0
0558C:  MOVWF  FF6
0558E:  MOVLW  15
05590:  MOVWF  FF7
05592:  MOVLW  00
05594:  MOVWF  FF8
05596:  MOVLW  13
05598:  MOVLB  9
0559A:  MOVWF  xE9
0559C:  MOVLB  0
0559E:  CALL   1C2C
055A2:  MOVFF  1C7,A48
055A6:  MOVLW  37
055A8:  MOVLB  A
055AA:  MOVWF  x49
055AC:  MOVLB  0
055AE:  CALL   1E3C
055B2:  MOVFF  1C6,A48
055B6:  MOVLW  37
055B8:  MOVLB  A
055BA:  MOVWF  x49
055BC:  MOVLB  0
055BE:  CALL   1E3C
055C2:  MOVFF  1C5,A48
055C6:  MOVLW  37
055C8:  MOVLB  A
055CA:  MOVWF  x49
055CC:  MOVLB  0
055CE:  CALL   1E3C
055D2:  MOVFF  1C4,A48
055D6:  MOVLW  37
055D8:  MOVLB  A
055DA:  MOVWF  x49
055DC:  MOVLB  0
055DE:  CALL   1E3C
055E2:  MOVLW  0D
055E4:  BTFSS  FA6.6
055E6:  GOTO   55E4
055EA:  MOVLB  E
055EC:  MOVWF  xF9
055EE:  MOVLW  0A
055F0:  MOVLB  0
055F2:  BTFSS  FA6.6
055F4:  GOTO   55F2
055F8:  MOVLB  E
055FA:  MOVWF  xF9
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
055FC:  MOVFF  1C3,214
05600:  MOVLB  2
05602:  CLRF   x15
05604:  MOVLB  0
05606:  CALL   49C2
....................    
....................    sector_erase(mis_fm, sector_address);
0560A:  MOVFF  115,A8C
0560E:  MOVFF  114,A8B
05612:  MOVFF  113,A8A
05616:  MOVFF  112,A89
0561A:  MOVFF  1C7,A90
0561E:  MOVFF  1C6,A8F
05622:  MOVFF  1C5,A8E
05626:  MOVFF  1C4,A8D
0562A:  CALL   45DC
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0562E:  MOVFF  1C3,214
05632:  MOVLB  2
05634:  SETF   x15
05636:  MOVLB  0
05638:  CALL   49C2
....................    printf("End Flash Erase 1 Sector\r\n");
0563C:  MOVLW  FC
0563E:  MOVWF  FF6
05640:  MOVLW  15
05642:  MOVWF  FF7
05644:  MOVLW  00
05646:  MOVWF  FF8
05648:  CALL   1BF6
0564C:  GOTO   A614 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
059AC:  MOVLW  18
059AE:  MOVWF  FF6
059B0:  MOVLW  16
059B2:  MOVWF  FF7
059B4:  MOVLW  00
059B6:  MOVWF  FF8
059B8:  CALL   1BF6
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
059BC:  MOVLB  1
059BE:  MOVF   xC1,W
059C0:  MOVWF  FE9
059C2:  MOVF   xC2,W
059C4:  MOVWF  FEA
059C6:  MOVFF  FEF,1C3
059CA:  MOVLW  01
059CC:  ADDWF  xC1,W
059CE:  MOVWF  FE9
059D0:  MOVLW  00
059D2:  ADDWFC xC2,W
059D4:  MOVWF  FEA
059D6:  MOVF   FEF,W
059D8:  CLRF   xCB
059DA:  CLRF   xCA
059DC:  CLRF   xC9
059DE:  MOVWF  xC8
059E0:  MOVFF  1C8,1CB
059E4:  CLRF   xC8
059E6:  CLRF   xC9
059E8:  CLRF   xCA
059EA:  MOVLW  02
059EC:  ADDWF  xC1,W
059EE:  MOVWF  FE9
059F0:  MOVLW  00
059F2:  ADDWFC xC2,W
059F4:  MOVWF  FEA
059F6:  MOVF   FEF,W
059F8:  CLRF   xD0
059FA:  CLRF   xCF
059FC:  CLRF   xCE
059FE:  MOVWF  xCD
05A00:  MOVFF  1CE,03
05A04:  MOVFF  1CD,02
05A08:  CLRF   00
05A0A:  CLRF   01
05A0C:  MOVF   00,W
05A0E:  IORWF  xC8,F
05A10:  MOVF   01,W
05A12:  IORWF  xC9,F
05A14:  MOVF   02,W
05A16:  IORWF  xCA,F
05A18:  MOVF   03,W
05A1A:  IORWF  xCB,F
05A1C:  MOVLW  03
05A1E:  ADDWF  xC1,W
05A20:  MOVWF  FE9
05A22:  MOVLW  00
05A24:  ADDWFC xC2,W
05A26:  MOVWF  FEA
05A28:  MOVF   FEF,W
05A2A:  CLRF   xD0
05A2C:  CLRF   xCF
05A2E:  CLRF   xCE
05A30:  MOVWF  xCD
05A32:  MOVFF  1CF,03
05A36:  MOVFF  1CE,02
05A3A:  MOVFF  1CD,01
05A3E:  CLRF   00
05A40:  MOVF   00,W
05A42:  IORWF  xC8,F
05A44:  MOVF   01,W
05A46:  IORWF  xC9,F
05A48:  MOVF   02,W
05A4A:  IORWF  xCA,F
05A4C:  MOVF   03,W
05A4E:  IORWF  xCB,F
05A50:  MOVLW  04
05A52:  ADDWF  xC1,W
05A54:  MOVWF  FE9
05A56:  MOVLW  00
05A58:  ADDWFC xC2,W
05A5A:  MOVWF  FEA
05A5C:  MOVF   FEF,W
05A5E:  MOVWF  00
05A60:  CLRF   01
05A62:  CLRF   02
05A64:  CLRF   03
05A66:  MOVF   00,W
05A68:  IORWF  xC8,W
05A6A:  MOVWF  xC4
05A6C:  MOVF   01,W
05A6E:  IORWF  xC9,W
05A70:  MOVWF  xC5
05A72:  MOVF   02,W
05A74:  IORWF  xCA,W
05A76:  MOVWF  xC6
05A78:  MOVF   03,W
05A7A:  IORWF  xCB,W
05A7C:  MOVWF  xC7
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
05A7E:  MOVLW  34
05A80:  MOVWF  FF6
05A82:  MOVLW  16
05A84:  MOVWF  FF7
05A86:  MOVLW  00
05A88:  MOVWF  FF8
05A8A:  MOVLW  16
05A8C:  MOVLB  9
05A8E:  MOVWF  xE9
05A90:  MOVLB  0
05A92:  CALL   1C2C
05A96:  MOVFF  1C7,A48
05A9A:  MOVLW  37
05A9C:  MOVLB  A
05A9E:  MOVWF  x49
05AA0:  MOVLB  0
05AA2:  CALL   1E3C
05AA6:  MOVFF  1C6,A48
05AAA:  MOVLW  37
05AAC:  MOVLB  A
05AAE:  MOVWF  x49
05AB0:  MOVLB  0
05AB2:  CALL   1E3C
05AB6:  MOVFF  1C5,A48
05ABA:  MOVLW  37
05ABC:  MOVLB  A
05ABE:  MOVWF  x49
05AC0:  MOVLB  0
05AC2:  CALL   1E3C
05AC6:  MOVFF  1C4,A48
05ACA:  MOVLW  37
05ACC:  MOVLB  A
05ACE:  MOVWF  x49
05AD0:  MOVLB  0
05AD2:  CALL   1E3C
05AD6:  MOVLW  0D
05AD8:  BTFSS  FA6.6
05ADA:  GOTO   5AD8
05ADE:  MOVLB  E
05AE0:  MOVWF  xF9
05AE2:  MOVLW  0A
05AE4:  MOVLB  0
05AE6:  BTFSS  FA6.6
05AE8:  GOTO   5AE6
05AEC:  MOVLB  E
05AEE:  MOVWF  xF9
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05AF0:  MOVFF  1C3,214
05AF4:  MOVLB  2
05AF6:  CLRF   x15
05AF8:  MOVLB  0
05AFA:  CALL   49C2
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
05AFE:  MOVFF  115,319
05B02:  MOVFF  114,318
05B06:  MOVFF  113,317
05B0A:  MOVFF  112,316
05B0E:  MOVLB  3
05B10:  CLRF   x1D
05B12:  CLRF   x1C
05B14:  CLRF   x1B
05B16:  CLRF   x1A
05B18:  MOVLB  0
05B1A:  CALL   5650
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05B1E:  MOVFF  1C3,214
05B22:  MOVLB  2
05B24:  SETF   x15
05B26:  MOVLB  0
05B28:  CALL   49C2
....................    printf("End Flash Copy 1 Sector\r\n");
05B2C:  MOVLW  52
05B2E:  MOVWF  FF6
05B30:  MOVLW  16
05B32:  MOVWF  FF7
05B34:  MOVLW  00
05B36:  MOVWF  FF8
05B38:  CALL   1BF6
05B3C:  GOTO   A624 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
05B40:  MOVLW  6C
05B42:  MOVWF  FF6
05B44:  MOVLW  16
05B46:  MOVWF  FF7
05B48:  MOVLW  00
05B4A:  MOVWF  FF8
05B4C:  CALL   1BF6
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
05B50:  MOVLB  1
05B52:  MOVF   xC1,W
05B54:  MOVWF  FE9
05B56:  MOVF   xC2,W
05B58:  MOVWF  FEA
05B5A:  MOVFF  FEF,1C3
05B5E:  MOVLW  01
05B60:  ADDWF  xC1,W
05B62:  MOVWF  FE9
05B64:  MOVLW  00
05B66:  ADDWFC xC2,W
05B68:  MOVWF  FEA
05B6A:  MOVF   FEF,W
05B6C:  CLRF   xCB
05B6E:  CLRF   xCA
05B70:  CLRF   xC9
05B72:  MOVWF  xC8
05B74:  MOVFF  1C8,1CB
05B78:  CLRF   xC8
05B7A:  CLRF   xC9
05B7C:  CLRF   xCA
05B7E:  MOVLW  02
05B80:  ADDWF  xC1,W
05B82:  MOVWF  FE9
05B84:  MOVLW  00
05B86:  ADDWFC xC2,W
05B88:  MOVWF  FEA
05B8A:  MOVF   FEF,W
05B8C:  CLRF   xD0
05B8E:  CLRF   xCF
05B90:  CLRF   xCE
05B92:  MOVWF  xCD
05B94:  MOVFF  1CE,03
05B98:  MOVFF  1CD,02
05B9C:  CLRF   00
05B9E:  CLRF   01
05BA0:  MOVF   00,W
05BA2:  IORWF  xC8,F
05BA4:  MOVF   01,W
05BA6:  IORWF  xC9,F
05BA8:  MOVF   02,W
05BAA:  IORWF  xCA,F
05BAC:  MOVF   03,W
05BAE:  IORWF  xCB,F
05BB0:  MOVLW  03
05BB2:  ADDWF  xC1,W
05BB4:  MOVWF  FE9
05BB6:  MOVLW  00
05BB8:  ADDWFC xC2,W
05BBA:  MOVWF  FEA
05BBC:  MOVF   FEF,W
05BBE:  CLRF   xD0
05BC0:  CLRF   xCF
05BC2:  CLRF   xCE
05BC4:  MOVWF  xCD
05BC6:  MOVFF  1CF,03
05BCA:  MOVFF  1CE,02
05BCE:  MOVFF  1CD,01
05BD2:  CLRF   00
05BD4:  MOVF   00,W
05BD6:  IORWF  xC8,F
05BD8:  MOVF   01,W
05BDA:  IORWF  xC9,F
05BDC:  MOVF   02,W
05BDE:  IORWF  xCA,F
05BE0:  MOVF   03,W
05BE2:  IORWF  xCB,F
05BE4:  MOVLW  04
05BE6:  ADDWF  xC1,W
05BE8:  MOVWF  FE9
05BEA:  MOVLW  00
05BEC:  ADDWFC xC2,W
05BEE:  MOVWF  FEA
05BF0:  MOVF   FEF,W
05BF2:  MOVWF  00
05BF4:  CLRF   01
05BF6:  CLRF   02
05BF8:  CLRF   03
05BFA:  MOVF   00,W
05BFC:  IORWF  xC8,W
05BFE:  MOVWF  xC4
05C00:  MOVF   01,W
05C02:  IORWF  xC9,W
05C04:  MOVWF  xC5
05C06:  MOVF   02,W
05C08:  IORWF  xCA,W
05C0A:  MOVWF  xC6
05C0C:  MOVF   03,W
05C0E:  IORWF  xCB,W
05C10:  MOVWF  xC7
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
05C12:  MOVLW  92
05C14:  MOVWF  FF6
05C16:  MOVLW  16
05C18:  MOVWF  FF7
05C1A:  MOVLW  00
05C1C:  MOVWF  FF8
05C1E:  MOVLW  16
05C20:  MOVLB  9
05C22:  MOVWF  xE9
05C24:  MOVLB  0
05C26:  CALL   1C2C
05C2A:  MOVFF  1C7,A48
05C2E:  MOVLW  37
05C30:  MOVLB  A
05C32:  MOVWF  x49
05C34:  MOVLB  0
05C36:  CALL   1E3C
05C3A:  MOVFF  1C6,A48
05C3E:  MOVLW  37
05C40:  MOVLB  A
05C42:  MOVWF  x49
05C44:  MOVLB  0
05C46:  CALL   1E3C
05C4A:  MOVFF  1C5,A48
05C4E:  MOVLW  37
05C50:  MOVLB  A
05C52:  MOVWF  x49
05C54:  MOVLB  0
05C56:  CALL   1E3C
05C5A:  MOVFF  1C4,A48
05C5E:  MOVLW  37
05C60:  MOVLB  A
05C62:  MOVWF  x49
05C64:  MOVLB  0
05C66:  CALL   1E3C
05C6A:  MOVLW  0D
05C6C:  BTFSS  FA6.6
05C6E:  GOTO   5C6C
05C72:  MOVLB  E
05C74:  MOVWF  xF9
05C76:  MOVLW  0A
05C78:  MOVLB  0
05C7A:  BTFSS  FA6.6
05C7C:  GOTO   5C7A
05C80:  MOVLB  E
05C82:  MOVWF  xF9
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05C84:  MOVFF  1C3,214
05C88:  MOVLB  2
05C8A:  CLRF   x15
05C8C:  MOVLB  0
05C8E:  CALL   49C2
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05C92:  MOVFF  1C3,214
05C96:  MOVLB  2
05C98:  SETF   x15
05C9A:  MOVLB  0
05C9C:  CALL   49C2
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
05CA0:  MOVLW  B0
05CA2:  MOVWF  FF6
05CA4:  MOVLW  16
05CA6:  MOVWF  FF7
05CA8:  MOVLW  00
05CAA:  MOVWF  FF8
05CAC:  CALL   1BF6
05CB0:  GOTO   A634 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
05CB4:  MOVLW  D4
05CB6:  MOVWF  FF6
05CB8:  MOVLW  16
05CBA:  MOVWF  FF7
05CBC:  MOVLW  00
05CBE:  MOVWF  FF8
05CC0:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05CC4:  MOVLB  1
05CC6:  MOVF   xC1,W
05CC8:  MOVWF  FE9
05CCA:  MOVF   xC2,W
05CCC:  MOVWF  FEA
05CCE:  MOVFF  FEF,213
05CD2:  MOVFF  213,214
05CD6:  MOVLB  2
05CD8:  CLRF   x15
05CDA:  MOVLB  0
05CDC:  CALL   49C2
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
05CE0:  MOVLB  1
05CE2:  CLRF   xC3
05CE4:  CLRF   xC4
05CE6:  CLRF   xC5
05CE8:  CLRF   xC6
05CEA:  CLRF   xC7
05CEC:  CLRF   xC8
05CEE:  CLRF   xC9
....................    
....................    flash_write_param.id = parameter[0];
05CF0:  MOVF   xC1,W
05CF2:  MOVWF  FE9
05CF4:  MOVF   xC2,W
05CF6:  MOVWF  FEA
05CF8:  MOVFF  FEF,1C3
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
05CFC:  MOVLW  01
05CFE:  ADDWF  xC1,W
05D00:  MOVWF  FE9
05D02:  MOVLW  00
05D04:  ADDWFC xC2,W
05D06:  MOVWF  FEA
05D08:  MOVF   FEF,W
05D0A:  MOVLB  2
05D0C:  CLRF   x16
05D0E:  CLRF   x15
05D10:  CLRF   x14
05D12:  MOVWF  x13
05D14:  MOVFF  213,216
05D18:  CLRF   x13
05D1A:  CLRF   x14
05D1C:  CLRF   x15
05D1E:  MOVLW  02
05D20:  MOVLB  1
05D22:  ADDWF  xC1,W
05D24:  MOVWF  FE9
05D26:  MOVLW  00
05D28:  ADDWFC xC2,W
05D2A:  MOVWF  FEA
05D2C:  MOVF   FEF,W
05D2E:  MOVLB  2
05D30:  CLRF   x1B
05D32:  CLRF   x1A
05D34:  CLRF   x19
05D36:  MOVWF  x18
05D38:  MOVFF  219,03
05D3C:  MOVFF  218,02
05D40:  CLRF   00
05D42:  CLRF   01
05D44:  MOVF   00,W
05D46:  IORWF  x13,F
05D48:  MOVF   01,W
05D4A:  IORWF  x14,F
05D4C:  MOVF   02,W
05D4E:  IORWF  x15,F
05D50:  MOVF   03,W
05D52:  IORWF  x16,F
05D54:  MOVLW  03
05D56:  MOVLB  1
05D58:  ADDWF  xC1,W
05D5A:  MOVWF  FE9
05D5C:  MOVLW  00
05D5E:  ADDWFC xC2,W
05D60:  MOVWF  FEA
05D62:  MOVF   FEF,W
05D64:  MOVLB  2
05D66:  CLRF   x1B
05D68:  CLRF   x1A
05D6A:  CLRF   x19
05D6C:  MOVWF  x18
05D6E:  MOVFF  21A,03
05D72:  MOVFF  219,02
05D76:  MOVFF  218,01
05D7A:  CLRF   00
05D7C:  MOVF   00,W
05D7E:  IORWF  x13,F
05D80:  MOVF   01,W
05D82:  IORWF  x14,F
05D84:  MOVF   02,W
05D86:  IORWF  x15,F
05D88:  MOVF   03,W
05D8A:  IORWF  x16,F
05D8C:  MOVLW  04
05D8E:  MOVLB  1
05D90:  ADDWF  xC1,W
05D92:  MOVWF  FE9
05D94:  MOVLW  00
05D96:  ADDWFC xC2,W
05D98:  MOVWF  FEA
05D9A:  MOVF   FEF,W
05D9C:  MOVWF  00
05D9E:  CLRF   01
05DA0:  CLRF   02
05DA2:  CLRF   03
05DA4:  MOVF   00,W
05DA6:  MOVLB  2
05DA8:  IORWF  x13,W
05DAA:  MOVLB  1
05DAC:  MOVWF  xC4
05DAE:  MOVF   01,W
05DB0:  MOVLB  2
05DB2:  IORWF  x14,W
05DB4:  MOVLB  1
05DB6:  MOVWF  xC5
05DB8:  MOVF   02,W
05DBA:  MOVLB  2
05DBC:  IORWF  x15,W
05DBE:  MOVLB  1
05DC0:  MOVWF  xC6
05DC2:  MOVF   03,W
05DC4:  MOVLB  2
05DC6:  IORWF  x16,W
05DC8:  MOVLB  1
05DCA:  MOVWF  xC7
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
05DCC:  MOVLW  07
05DCE:  ADDWF  xC1,W
05DD0:  MOVWF  FE9
05DD2:  MOVLW  00
05DD4:  ADDWFC xC2,W
05DD6:  MOVWF  FEA
05DD8:  MOVF   FEF,W
05DDA:  MOVLB  2
05DDC:  CLRF   x14
05DDE:  MOVWF  x13
05DE0:  MOVFF  213,214
05DE4:  CLRF   x13
05DE6:  MOVLW  08
05DE8:  MOVLB  1
05DEA:  ADDWF  xC1,W
05DEC:  MOVWF  FE9
05DEE:  MOVLW  00
05DF0:  ADDWFC xC2,W
05DF2:  MOVWF  FEA
05DF4:  MOVF   FEF,W
05DF6:  CLRF   03
05DF8:  MOVLB  2
05DFA:  IORWF  x13,W
05DFC:  MOVLB  1
05DFE:  MOVWF  xC8
05E00:  MOVF   03,W
05E02:  MOVLB  2
05E04:  IORWF  x14,W
05E06:  MOVLB  1
05E08:  MOVWF  xC9
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
05E0A:  MOVLW  EE
05E0C:  MOVWF  FF6
05E0E:  MOVLW  16
05E10:  MOVWF  FF7
05E12:  MOVLW  00
05E14:  MOVWF  FF8
05E16:  MOVLW  0C
05E18:  MOVLB  9
05E1A:  MOVWF  xE9
05E1C:  MOVLB  0
05E1E:  CALL   1C2C
05E22:  MOVFF  1C3,A48
05E26:  MOVLW  37
05E28:  MOVLB  A
05E2A:  MOVWF  x49
05E2C:  MOVLB  0
05E2E:  CALL   1E3C
05E32:  MOVLW  0D
05E34:  BTFSS  FA6.6
05E36:  GOTO   5E34
05E3A:  MOVLB  E
05E3C:  MOVWF  xF9
05E3E:  MOVLW  0A
05E40:  MOVLB  0
05E42:  BTFSS  FA6.6
05E44:  GOTO   5E42
05E48:  MOVLB  E
05E4A:  MOVWF  xF9
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
05E4C:  MOVLW  02
05E4E:  MOVWF  FF6
05E50:  MOVLW  17
05E52:  MOVWF  FF7
05E54:  MOVLW  00
05E56:  MOVWF  FF8
05E58:  MOVLW  0E
05E5A:  MOVLB  9
05E5C:  MOVWF  xE9
05E5E:  MOVLB  0
05E60:  CALL   1C2C
05E64:  MOVFF  1C7,A48
05E68:  MOVLW  37
05E6A:  MOVLB  A
05E6C:  MOVWF  x49
05E6E:  MOVLB  0
05E70:  CALL   1E3C
05E74:  MOVFF  1C6,A48
05E78:  MOVLW  37
05E7A:  MOVLB  A
05E7C:  MOVWF  x49
05E7E:  MOVLB  0
05E80:  CALL   1E3C
05E84:  MOVFF  1C5,A48
05E88:  MOVLW  37
05E8A:  MOVLB  A
05E8C:  MOVWF  x49
05E8E:  MOVLB  0
05E90:  CALL   1E3C
05E94:  MOVFF  1C4,A48
05E98:  MOVLW  37
05E9A:  MOVLB  A
05E9C:  MOVWF  x49
05E9E:  MOVLB  0
05EA0:  CALL   1E3C
05EA4:  MOVLW  0D
05EA6:  BTFSS  FA6.6
05EA8:  GOTO   5EA6
05EAC:  MOVLB  E
05EAE:  MOVWF  xF9
05EB0:  MOVLW  0A
05EB2:  MOVLB  0
05EB4:  BTFSS  FA6.6
05EB6:  GOTO   5EB4
05EBA:  MOVLB  E
05EBC:  MOVWF  xF9
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
05EBE:  MOVLW  18
05EC0:  MOVWF  FF6
05EC2:  MOVLW  17
05EC4:  MOVWF  FF7
05EC6:  MOVLW  00
05EC8:  MOVWF  FF8
05ECA:  MOVLW  0E
05ECC:  MOVLB  9
05ECE:  MOVWF  xE9
05ED0:  MOVLB  0
05ED2:  CALL   1C2C
05ED6:  MOVFF  1C9,A48
05EDA:  MOVLW  37
05EDC:  MOVLB  A
05EDE:  MOVWF  x49
05EE0:  MOVLB  0
05EE2:  CALL   1E3C
05EE6:  MOVFF  1C8,A48
05EEA:  MOVLW  37
05EEC:  MOVLB  A
05EEE:  MOVWF  x49
05EF0:  MOVLB  0
05EF2:  CALL   1E3C
05EF6:  MOVLW  0D
05EF8:  BTFSS  FA6.6
05EFA:  GOTO   5EF8
05EFE:  MOVLB  E
05F00:  MOVWF  xF9
05F02:  MOVLW  0A
05F04:  MOVLB  0
05F06:  BTFSS  FA6.6
05F08:  GOTO   5F06
05F0C:  MOVLB  E
05F0E:  MOVWF  xF9
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
05F10:  MOVFF  1C3,214
05F14:  MOVLB  2
05F16:  CLRF   x15
05F18:  MOVLB  0
05F1A:  CALL   49C2
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
05F1E:  MOVLW  2E
05F20:  MOVWF  FF6
05F22:  MOVLW  17
05F24:  MOVWF  FF7
05F26:  MOVLW  00
05F28:  MOVWF  FF8
05F2A:  CALL   1BF6
....................    for (p = 0; p < flash_write_param.packetnum; p++)
05F2E:  MOVLB  2
05F30:  CLRF   x0B
05F32:  CLRF   x0A
05F34:  MOVLB  0
05F36:  MOVLB  2
05F38:  MOVF   x0B,W
05F3A:  MOVLB  1
05F3C:  SUBWF  xC9,W
05F3E:  BTFSC  FD8.0
05F40:  BRA    5F48
05F42:  MOVLB  0
05F44:  GOTO   608A
05F48:  MOVLB  0
05F4A:  BTFSS  FD8.2
05F4C:  GOTO   5F64
05F50:  MOVLB  1
05F52:  MOVF   xC8,W
05F54:  MOVLB  2
05F56:  SUBWF  x0A,W
05F58:  BTFSS  FD8.0
05F5A:  BRA    5F62
05F5C:  MOVLB  0
05F5E:  GOTO   608A
05F62:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
05F64:  MOVLB  2
05F66:  RLCF   x0A,W
05F68:  MOVWF  x0C
05F6A:  RLCF   x0B,W
05F6C:  MOVWF  x0D
05F6E:  RLCF   x0C,F
05F70:  RLCF   x0D,F
05F72:  RLCF   x0C,F
05F74:  RLCF   x0D,F
05F76:  RLCF   x0C,F
05F78:  RLCF   x0D,F
05F7A:  RLCF   x0C,F
05F7C:  RLCF   x0D,F
05F7E:  RLCF   x0C,F
05F80:  RLCF   x0D,F
05F82:  MOVLW  C0
05F84:  ANDWF  x0C,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
05F86:  CLRF   x0E
05F88:  MOVLB  0
05F8A:  MOVLB  2
05F8C:  MOVF   x0E,W
05F8E:  SUBLW  3F
05F90:  BTFSC  FD8.0
05F92:  BRA    5F9A
05F94:  MOVLB  0
05F96:  GOTO   5FFC
05F9A:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
05F9C:  CLRF   03
05F9E:  MOVLB  2
05FA0:  MOVF   x0E,W
05FA2:  ADDLW  CA
05FA4:  MOVWF  FE9
05FA6:  MOVLW  01
05FA8:  ADDWFC 03,W
05FAA:  MOVWF  FEA
05FAC:  MOVF   x0E,W
05FAE:  ADDWF  x0C,W
05FB0:  MOVWF  x15
05FB2:  MOVLW  00
05FB4:  ADDWFC x0D,W
05FB6:  MOVWF  x16
05FB8:  MOVF   x15,W
05FBA:  MOVWF  00
05FBC:  CLRF   03
05FBE:  MOVF   00,W
05FC0:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
05FC2:  CLRF   03
05FC4:  MOVF   x0E,W
05FC6:  ADDLW  CA
05FC8:  MOVWF  FE9
05FCA:  MOVLW  01
05FCC:  ADDWFC 03,W
05FCE:  MOVWF  FEA
05FD0:  MOVFF  FEF,213
05FD4:  MOVFF  213,A48
05FD8:  MOVLW  37
05FDA:  MOVLB  A
05FDC:  MOVWF  x49
05FDE:  MOVLB  0
05FE0:  CALL   1E3C
05FE4:  MOVLW  20
05FE6:  BTFSS  FA6.6
05FE8:  GOTO   5FE6
05FEC:  MOVLB  E
05FEE:  MOVWF  xF9
05FF0:  MOVLB  0
05FF2:  MOVLB  2
05FF4:  INCF   x0E,F
05FF6:  MOVLB  0
05FF8:  GOTO   5F8A
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
05FFC:  MOVLB  2
05FFE:  RLCF   x0A,W
06000:  MOVWF  02
06002:  RLCF   x0B,W
06004:  MOVWF  03
06006:  RLCF   02,F
06008:  RLCF   03,F
0600A:  RLCF   02,F
0600C:  RLCF   03,F
0600E:  RLCF   02,F
06010:  RLCF   03,F
06012:  RLCF   02,F
06014:  RLCF   03,F
06016:  RLCF   02,F
06018:  RLCF   03,F
0601A:  MOVLW  C0
0601C:  ANDWF  02,F
0601E:  MOVF   02,W
06020:  MOVLB  1
06022:  ADDWF  xC4,W
06024:  MOVLB  2
06026:  MOVWF  x0F
06028:  MOVF   03,W
0602A:  MOVLB  1
0602C:  ADDWFC xC5,W
0602E:  MOVLB  2
06030:  MOVWF  x10
06032:  MOVLW  00
06034:  MOVLB  1
06036:  ADDWFC xC6,W
06038:  MOVLB  2
0603A:  MOVWF  x11
0603C:  MOVLW  00
0603E:  MOVLB  1
06040:  ADDWFC xC7,W
06042:  MOVLB  2
06044:  MOVWF  x12
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
06046:  MOVFF  115,A8E
0604A:  MOVFF  114,A8D
0604E:  MOVFF  113,A8C
06052:  MOVFF  112,A8B
06056:  MOVFF  212,A92
0605A:  MOVFF  211,A91
0605E:  MOVFF  210,A90
06062:  MOVFF  20F,A8F
06066:  MOVLW  01
06068:  MOVLB  A
0606A:  MOVWF  x94
0606C:  MOVLW  CA
0606E:  MOVWF  x93
06070:  CLRF   x96
06072:  MOVLW  40
06074:  MOVWF  x95
06076:  MOVLB  0
06078:  CALL   3EC0
0607C:  MOVLB  2
0607E:  INCF   x0A,F
06080:  BTFSC  FD8.2
06082:  INCF   x0B,F
06084:  MOVLB  0
06086:  GOTO   5F36
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
0608A:  MOVFF  1C3,214
0608E:  MOVLB  2
06090:  SETF   x15
06092:  MOVLB  0
06094:  CALL   49C2
....................    fprintf(PC, "\r\n");
06098:  MOVLW  0D
0609A:  BTFSS  FA6.6
0609C:  GOTO   609A
060A0:  MOVLB  E
060A2:  MOVWF  xF9
060A4:  MOVLW  0A
060A6:  MOVLB  0
060A8:  BTFSS  FA6.6
060AA:  GOTO   60A8
060AE:  MOVLB  E
060B0:  MOVWF  xF9
....................    fprintf(PC, "End Flash Write Demo\r\n");
060B2:  MOVLW  3C
060B4:  MOVWF  FF6
060B6:  MOVLW  17
060B8:  MOVWF  FF7
060BA:  MOVLW  00
060BC:  MOVWF  FF8
060BE:  MOVLB  0
060C0:  CALL   1BF6
060C4:  GOTO   A644 (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
060F8:  MOVLW  54
060FA:  MOVWF  FF6
060FC:  MOVLW  17
060FE:  MOVWF  FF7
06100:  MOVLW  00
06102:  MOVWF  FF8
06104:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
06108:  MOVLB  1
0610A:  MOVF   xC1,W
0610C:  MOVWF  FE9
0610E:  MOVF   xC2,W
06110:  MOVWF  FEA
06112:  MOVFF  FEF,1C7
06116:  MOVFF  1C7,214
0611A:  MOVLB  2
0611C:  CLRF   x15
0611E:  MOVLB  0
06120:  CALL   49C2
....................    flash_setting(mis_fm);
06124:  MOVFF  115,2CF
06128:  MOVFF  114,2CE
0612C:  MOVFF  113,2CD
06130:  MOVFF  112,2CC
06134:  CALL   60C8
....................    unsigned int32 write_address = 0x00000000;
06138:  MOVLB  1
0613A:  CLRF   xC6
0613C:  CLRF   xC5
0613E:  CLRF   xC4
06140:  CLRF   xC3
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06142:  MOVF   xC1,W
06144:  MOVWF  FE9
06146:  MOVF   xC2,W
06148:  MOVWF  FEA
0614A:  MOVFF  FEF,1C7
0614E:  MOVFF  1C7,214
06152:  MOVLB  2
06154:  SETF   x15
06156:  MOVLB  0
06158:  CALL   49C2
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
0615C:  MOVLW  7A
0615E:  MOVWF  FF6
06160:  MOVLW  17
06162:  MOVWF  FF7
06164:  MOVLW  00
06166:  MOVWF  FF8
06168:  CALL   1BF6
0616C:  GOTO   A654 (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
06170:  MOVLW  9E
06172:  MOVWF  FF6
06174:  MOVLW  17
06176:  MOVWF  FF7
06178:  MOVLW  00
0617A:  MOVWF  FF8
0617C:  CALL   1BF6
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
06180:  MOVLB  1
06182:  MOVF   xC1,W
06184:  MOVWF  FE9
06186:  MOVF   xC2,W
06188:  MOVWF  FEA
0618A:  MOVFF  FEF,213
0618E:  MOVFF  213,214
06192:  MOVLB  2
06194:  CLRF   x15
06196:  MOVLB  0
06198:  CALL   49C2
....................    FLASH_PARAM flash_param = {0};
0619C:  MOVLB  1
0619E:  CLRF   xC3
061A0:  CLRF   xC4
061A2:  CLRF   xC5
061A4:  CLRF   xC6
061A6:  CLRF   xC7
061A8:  CLRF   xC8
061AA:  CLRF   xC9
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
061AC:  MOVF   xC1,W
061AE:  MOVWF  FE9
061B0:  MOVF   xC2,W
061B2:  MOVWF  FEA
061B4:  MOVFF  FEF,1C3
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
061B8:  MOVLW  01
061BA:  ADDWF  xC1,W
061BC:  MOVWF  FE9
061BE:  MOVLW  00
061C0:  ADDWFC xC2,W
061C2:  MOVWF  FEA
061C4:  MOVF   FEF,W
061C6:  MOVLB  2
061C8:  CLRF   x16
061CA:  CLRF   x15
061CC:  CLRF   x14
061CE:  MOVWF  x13
061D0:  MOVFF  213,216
061D4:  CLRF   x13
061D6:  CLRF   x14
061D8:  CLRF   x15
061DA:  MOVLW  02
061DC:  MOVLB  1
061DE:  ADDWF  xC1,W
061E0:  MOVWF  FE9
061E2:  MOVLW  00
061E4:  ADDWFC xC2,W
061E6:  MOVWF  FEA
061E8:  MOVF   FEF,W
061EA:  MOVLB  2
061EC:  CLRF   x1B
061EE:  CLRF   x1A
061F0:  CLRF   x19
061F2:  MOVWF  x18
061F4:  MOVFF  219,03
061F8:  MOVFF  218,02
061FC:  CLRF   00
061FE:  CLRF   01
06200:  MOVF   00,W
06202:  IORWF  x13,F
06204:  MOVF   01,W
06206:  IORWF  x14,F
06208:  MOVF   02,W
0620A:  IORWF  x15,F
0620C:  MOVF   03,W
0620E:  IORWF  x16,F
06210:  MOVLW  03
06212:  MOVLB  1
06214:  ADDWF  xC1,W
06216:  MOVWF  FE9
06218:  MOVLW  00
0621A:  ADDWFC xC2,W
0621C:  MOVWF  FEA
0621E:  MOVF   FEF,W
06220:  MOVLB  2
06222:  CLRF   x1B
06224:  CLRF   x1A
06226:  CLRF   x19
06228:  MOVWF  x18
0622A:  MOVFF  21A,03
0622E:  MOVFF  219,02
06232:  MOVFF  218,01
06236:  CLRF   00
06238:  MOVF   00,W
0623A:  IORWF  x13,F
0623C:  MOVF   01,W
0623E:  IORWF  x14,F
06240:  MOVF   02,W
06242:  IORWF  x15,F
06244:  MOVF   03,W
06246:  IORWF  x16,F
06248:  MOVLW  04
0624A:  MOVLB  1
0624C:  ADDWF  xC1,W
0624E:  MOVWF  FE9
06250:  MOVLW  00
06252:  ADDWFC xC2,W
06254:  MOVWF  FEA
06256:  MOVF   FEF,W
06258:  MOVWF  00
0625A:  CLRF   01
0625C:  CLRF   02
0625E:  CLRF   03
06260:  MOVF   00,W
06262:  MOVLB  2
06264:  IORWF  x13,W
06266:  MOVLB  1
06268:  MOVWF  xC6
0626A:  MOVF   01,W
0626C:  MOVLB  2
0626E:  IORWF  x14,W
06270:  MOVLB  1
06272:  MOVWF  xC7
06274:  MOVF   02,W
06276:  MOVLB  2
06278:  IORWF  x15,W
0627A:  MOVLB  1
0627C:  MOVWF  xC8
0627E:  MOVF   03,W
06280:  MOVLB  2
06282:  IORWF  x16,W
06284:  MOVLB  1
06286:  MOVWF  xC9
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
06288:  MOVLW  07
0628A:  ADDWF  xC1,W
0628C:  MOVWF  FE9
0628E:  MOVLW  00
06290:  ADDWFC xC2,W
06292:  MOVWF  FEA
06294:  MOVF   FEF,W
06296:  MOVLB  2
06298:  CLRF   x14
0629A:  MOVWF  x13
0629C:  MOVFF  213,214
062A0:  CLRF   x13
062A2:  MOVLW  08
062A4:  MOVLB  1
062A6:  ADDWF  xC1,W
062A8:  MOVWF  FE9
062AA:  MOVLW  00
062AC:  ADDWFC xC2,W
062AE:  MOVWF  FEA
062B0:  MOVF   FEF,W
062B2:  CLRF   03
062B4:  MOVLB  2
062B6:  IORWF  x13,W
062B8:  MOVLB  1
062BA:  MOVWF  xC4
062BC:  MOVF   03,W
062BE:  MOVLB  2
062C0:  IORWF  x14,W
062C2:  MOVLB  1
062C4:  MOVWF  xC5
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
062C6:  MOVLW  B2
062C8:  MOVWF  FF6
062CA:  MOVLW  17
062CC:  MOVWF  FF7
062CE:  MOVLW  00
062D0:  MOVWF  FF8
062D2:  MOVLW  0C
062D4:  MOVLB  9
062D6:  MOVWF  xE9
062D8:  MOVLB  0
062DA:  CALL   1C2C
062DE:  MOVFF  1C3,A48
062E2:  MOVLW  37
062E4:  MOVLB  A
062E6:  MOVWF  x49
062E8:  MOVLB  0
062EA:  CALL   1E3C
062EE:  MOVLW  0D
062F0:  BTFSS  FA6.6
062F2:  GOTO   62F0
062F6:  MOVLB  E
062F8:  MOVWF  xF9
062FA:  MOVLW  0A
062FC:  MOVLB  0
062FE:  BTFSS  FA6.6
06300:  GOTO   62FE
06304:  MOVLB  E
06306:  MOVWF  xF9
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
06308:  MOVLW  C6
0630A:  MOVWF  FF6
0630C:  MOVLW  17
0630E:  MOVWF  FF7
06310:  MOVLW  00
06312:  MOVWF  FF8
06314:  MOVLW  0E
06316:  MOVLB  9
06318:  MOVWF  xE9
0631A:  MOVLB  0
0631C:  CALL   1C2C
06320:  MOVFF  1C9,A48
06324:  MOVLW  37
06326:  MOVLB  A
06328:  MOVWF  x49
0632A:  MOVLB  0
0632C:  CALL   1E3C
06330:  MOVFF  1C8,A48
06334:  MOVLW  37
06336:  MOVLB  A
06338:  MOVWF  x49
0633A:  MOVLB  0
0633C:  CALL   1E3C
06340:  MOVFF  1C7,A48
06344:  MOVLW  37
06346:  MOVLB  A
06348:  MOVWF  x49
0634A:  MOVLB  0
0634C:  CALL   1E3C
06350:  MOVFF  1C6,A48
06354:  MOVLW  37
06356:  MOVLB  A
06358:  MOVWF  x49
0635A:  MOVLB  0
0635C:  CALL   1E3C
06360:  MOVLW  0D
06362:  BTFSS  FA6.6
06364:  GOTO   6362
06368:  MOVLB  E
0636A:  MOVWF  xF9
0636C:  MOVLW  0A
0636E:  MOVLB  0
06370:  BTFSS  FA6.6
06372:  GOTO   6370
06376:  MOVLB  E
06378:  MOVWF  xF9
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
0637A:  MOVLW  DC
0637C:  MOVWF  FF6
0637E:  MOVLW  17
06380:  MOVWF  FF7
06382:  MOVLW  00
06384:  MOVWF  FF8
06386:  MOVLW  0E
06388:  MOVLB  9
0638A:  MOVWF  xE9
0638C:  MOVLB  0
0638E:  CALL   1C2C
06392:  MOVFF  1C5,A48
06396:  MOVLW  37
06398:  MOVLB  A
0639A:  MOVWF  x49
0639C:  MOVLB  0
0639E:  CALL   1E3C
063A2:  MOVFF  1C4,A48
063A6:  MOVLW  37
063A8:  MOVLB  A
063AA:  MOVWF  x49
063AC:  MOVLB  0
063AE:  CALL   1E3C
063B2:  MOVLW  0D
063B4:  BTFSS  FA6.6
063B6:  GOTO   63B4
063BA:  MOVLB  E
063BC:  MOVWF  xF9
063BE:  MOVLW  0A
063C0:  MOVLB  0
063C2:  BTFSS  FA6.6
063C4:  GOTO   63C2
063C8:  MOVLB  E
063CA:  MOVWF  xF9
....................    
....................    piclog_make(flash_param.id, 0x00);
063CC:  MOVFF  1C3,214
063D0:  MOVLB  2
063D2:  CLRF   x15
063D4:  MOVLB  0
063D6:  CALL   49C2
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
063DA:  MOVLB  1
063DC:  CLRF   xCA
063DE:  CLRF   xCB
063E0:  CLRF   xCC
063E2:  CLRF   xCD
063E4:  CLRF   xCE
063E6:  CLRF   xCF
063E8:  CLRF   xD0
063EA:  CLRF   xD1
063EC:  CLRF   xD2
063EE:  CLRF   xD3
063F0:  CLRF   xD4
063F2:  CLRF   xD5
063F4:  CLRF   xD6
063F6:  CLRF   xD7
063F8:  CLRF   xD8
063FA:  CLRF   xD9
063FC:  CLRF   xDA
063FE:  CLRF   xDB
06400:  CLRF   xDC
06402:  CLRF   xDD
06404:  CLRF   xDE
06406:  CLRF   xDF
06408:  CLRF   xE0
0640A:  CLRF   xE1
0640C:  CLRF   xE2
0640E:  CLRF   xE3
06410:  CLRF   xE4
06412:  CLRF   xE5
06414:  CLRF   xE6
06416:  CLRF   xE7
06418:  CLRF   xE8
0641A:  CLRF   xE9
0641C:  CLRF   xEA
0641E:  CLRF   xEB
06420:  CLRF   xEC
06422:  CLRF   xED
06424:  CLRF   xEE
06426:  CLRF   xEF
06428:  CLRF   xF0
0642A:  CLRF   xF1
0642C:  CLRF   xF2
0642E:  CLRF   xF3
06430:  CLRF   xF4
06432:  CLRF   xF5
06434:  CLRF   xF6
06436:  CLRF   xF7
06438:  CLRF   xF8
0643A:  CLRF   xF9
0643C:  CLRF   xFA
0643E:  CLRF   xFB
06440:  CLRF   xFC
06442:  CLRF   xFD
06444:  CLRF   xFE
06446:  CLRF   xFF
06448:  MOVLB  2
0644A:  CLRF   x00
0644C:  CLRF   x01
0644E:  CLRF   x02
06450:  CLRF   x03
06452:  CLRF   x04
06454:  CLRF   x05
06456:  CLRF   x06
06458:  CLRF   x07
0645A:  CLRF   x08
0645C:  CLRF   x09
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
0645E:  MOVLW  F2
06460:  MOVWF  FF6
06462:  MOVLW  17
06464:  MOVWF  FF7
06466:  MOVLW  00
06468:  MOVWF  FF8
0646A:  MOVLB  0
0646C:  CALL   1BF6
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
06470:  MOVFF  115,297
06474:  MOVFF  114,296
06478:  MOVFF  113,295
0647C:  MOVFF  112,294
06480:  CALL   26E4
06484:  MOVF   01,F
06486:  BTFSS  FD8.2
06488:  GOTO   649C
....................       fprintf(PC, "Mission Flash is not connected\r\n");
0648C:  MOVLW  FE
0648E:  MOVWF  FF6
06490:  MOVLW  17
06492:  MOVWF  FF7
06494:  MOVLW  00
06496:  MOVWF  FF8
06498:  CALL   1BF6
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
0649C:  MOVLB  2
0649E:  CLRF   x11
064A0:  CLRF   x10
064A2:  CLRF   x0F
064A4:  CLRF   x0E
064A6:  MOVLB  0
064A8:  MOVLB  2
064AA:  MOVF   x11,F
064AC:  BTFSC  FD8.2
064AE:  BRA    64B6
064B0:  MOVLB  0
064B2:  GOTO   661E
064B6:  MOVLB  0
064B8:  MOVLB  2
064BA:  MOVF   x10,F
064BC:  BTFSC  FD8.2
064BE:  BRA    64C6
064C0:  MOVLB  0
064C2:  GOTO   661E
064C6:  MOVLB  0
064C8:  MOVLB  2
064CA:  MOVF   x0F,W
064CC:  MOVLB  1
064CE:  SUBWF  xC5,W
064D0:  BTFSC  FD8.0
064D2:  BRA    64DA
064D4:  MOVLB  0
064D6:  GOTO   661E
064DA:  MOVLB  0
064DC:  BTFSS  FD8.2
064DE:  GOTO   64F6
064E2:  MOVLB  1
064E4:  MOVF   xC4,W
064E6:  MOVLB  2
064E8:  SUBWF  x0E,W
064EA:  BTFSS  FD8.0
064EC:  BRA    64F4
064EE:  MOVLB  0
064F0:  GOTO   661E
064F4:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
064F6:  MOVLB  2
064F8:  RLCF   x0E,W
064FA:  MOVWF  00
064FC:  RLCF   x0F,W
064FE:  MOVWF  01
06500:  RLCF   x10,W
06502:  MOVWF  02
06504:  RLCF   x11,W
06506:  MOVWF  03
06508:  RLCF   00,F
0650A:  RLCF   01,F
0650C:  RLCF   02,F
0650E:  RLCF   03,F
06510:  RLCF   00,F
06512:  RLCF   01,F
06514:  RLCF   02,F
06516:  RLCF   03,F
06518:  RLCF   00,F
0651A:  RLCF   01,F
0651C:  RLCF   02,F
0651E:  RLCF   03,F
06520:  RLCF   00,F
06522:  RLCF   01,F
06524:  RLCF   02,F
06526:  RLCF   03,F
06528:  RLCF   00,F
0652A:  RLCF   01,F
0652C:  RLCF   02,F
0652E:  RLCF   03,F
06530:  MOVLW  C0
06532:  ANDWF  00,F
06534:  MOVF   00,W
06536:  MOVLB  1
06538:  ADDWF  xC6,W
0653A:  MOVLB  2
0653C:  MOVWF  x0A
0653E:  MOVF   01,W
06540:  MOVLB  1
06542:  ADDWFC xC7,W
06544:  MOVLB  2
06546:  MOVWF  x0B
06548:  MOVF   02,W
0654A:  MOVLB  1
0654C:  ADDWFC xC8,W
0654E:  MOVLB  2
06550:  MOVWF  x0C
06552:  MOVF   03,W
06554:  MOVLB  1
06556:  ADDWFC xC9,W
06558:  MOVLB  2
0655A:  MOVWF  x0D
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
0655C:  MOVFF  115,319
06560:  MOVFF  114,318
06564:  MOVFF  113,317
06568:  MOVFF  112,316
0656C:  MOVFF  20D,31D
06570:  MOVFF  20C,31C
06574:  MOVFF  20B,31B
06578:  MOVFF  20A,31A
0657C:  MOVLW  01
0657E:  MOVLB  3
06580:  MOVWF  x1F
06582:  MOVLW  CA
06584:  MOVWF  x1E
06586:  CLRF   x23
06588:  CLRF   x22
0658A:  CLRF   x21
0658C:  MOVLW  40
0658E:  MOVWF  x20
06590:  MOVLB  0
06592:  CALL   27D0
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
06596:  MOVLB  2
06598:  CLRF   x12
0659A:  MOVLB  0
0659C:  MOVLB  2
0659E:  MOVF   x12,W
065A0:  SUBLW  3F
065A2:  BTFSC  FD8.0
065A4:  BRA    65AC
065A6:  MOVLB  0
065A8:  GOTO   65EA
065AC:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
065AE:  CLRF   03
065B0:  MOVLB  2
065B2:  MOVF   x12,W
065B4:  ADDLW  CA
065B6:  MOVWF  FE9
065B8:  MOVLW  01
065BA:  ADDWFC 03,W
065BC:  MOVWF  FEA
065BE:  MOVFF  FEF,213
065C2:  MOVFF  213,A48
065C6:  MOVLW  37
065C8:  MOVLB  A
065CA:  MOVWF  x49
065CC:  MOVLB  0
065CE:  CALL   1E3C
065D2:  MOVLW  20
065D4:  BTFSS  FA6.6
065D6:  GOTO   65D4
065DA:  MOVLB  E
065DC:  MOVWF  xF9
065DE:  MOVLB  0
065E0:  MOVLB  2
065E2:  INCF   x12,F
065E4:  MOVLB  0
065E6:  GOTO   659C
....................       }
....................       fprintf(PC,"\r\n");
065EA:  MOVLW  0D
065EC:  BTFSS  FA6.6
065EE:  GOTO   65EC
065F2:  MOVLB  E
065F4:  MOVWF  xF9
065F6:  MOVLW  0A
065F8:  MOVLB  0
065FA:  BTFSS  FA6.6
065FC:  GOTO   65FA
06600:  MOVLB  E
06602:  MOVWF  xF9
06604:  MOVLB  0
06606:  MOVLW  01
06608:  MOVLB  2
0660A:  ADDWF  x0E,F
0660C:  BTFSC  FD8.0
0660E:  INCF   x0F,F
06610:  BTFSC  FD8.2
06612:  INCF   x10,F
06614:  BTFSC  FD8.2
06616:  INCF   x11,F
06618:  MOVLB  0
0661A:  GOTO   64A8
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
0661E:  MOVFF  1C3,214
06622:  MOVLB  2
06624:  SETF   x15
06626:  MOVLB  0
06628:  CALL   49C2
....................    fprintf(PC, "End Flash Read\r\n");
0662C:  MOVLW  20
0662E:  MOVWF  FF6
06630:  MOVLW  18
06632:  MOVWF  FF7
06634:  MOVLW  00
06636:  MOVWF  FF8
06638:  CALL   1BF6
0663C:  GOTO   A664 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
06640:  MOVLW  32
06642:  MOVWF  FF6
06644:  MOVLW  18
06646:  MOVWF  FF7
06648:  MOVLW  00
0664A:  MOVWF  FF8
0664C:  CALL   1BF6
....................    flash_setting(mis_fm);
06650:  MOVFF  115,2CF
06654:  MOVFF  114,2CE
06658:  MOVFF  113,2CD
0665C:  MOVFF  112,2CC
06660:  CALL   60C8
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
06664:  MOVLB  1
06666:  CLRF   xC6
06668:  CLRF   xC5
0666A:  CLRF   xC4
0666C:  CLRF   xC3
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
0666E:  MOVFF  115,319
06672:  MOVFF  114,318
06676:  MOVFF  113,317
0667A:  MOVFF  112,316
0667E:  MOVFF  1C6,31D
06682:  MOVFF  1C5,31C
06686:  MOVFF  1C4,31B
0668A:  MOVFF  1C3,31A
0668E:  MOVLW  01
06690:  MOVLB  3
06692:  MOVWF  x1F
06694:  MOVLW  C7
06696:  MOVWF  x1E
06698:  CLRF   x23
0669A:  CLRF   x22
0669C:  CLRF   x21
0669E:  MOVLW  04
066A0:  MOVWF  x20
066A2:  MOVLB  0
066A4:  CALL   27D0
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
066A8:  MOVLW  4E
066AA:  MOVWF  FF6
066AC:  MOVLW  18
066AE:  MOVWF  FF7
066B0:  MOVLW  00
066B2:  MOVWF  FF8
066B4:  MOVLW  0B
066B6:  MOVLB  9
066B8:  MOVWF  xE9
066BA:  MOVLB  0
066BC:  CALL   1C2C
066C0:  MOVFF  1C7,A48
066C4:  MOVLW  37
066C6:  MOVLB  A
066C8:  MOVWF  x49
066CA:  MOVLB  0
066CC:  CALL   1E3C
066D0:  MOVLW  20
066D2:  BTFSS  FA6.6
066D4:  GOTO   66D2
066D8:  MOVLB  E
066DA:  MOVWF  xF9
066DC:  MOVFF  1C8,A48
066E0:  MOVLW  37
066E2:  MOVLB  A
066E4:  MOVWF  x49
066E6:  MOVLB  0
066E8:  CALL   1E3C
066EC:  MOVLW  20
066EE:  BTFSS  FA6.6
066F0:  GOTO   66EE
066F4:  MOVLB  E
066F6:  MOVWF  xF9
066F8:  MOVFF  1C9,A48
066FC:  MOVLW  37
066FE:  MOVLB  A
06700:  MOVWF  x49
06702:  MOVLB  0
06704:  CALL   1E3C
06708:  MOVLW  20
0670A:  BTFSS  FA6.6
0670C:  GOTO   670A
06710:  MOVLB  E
06712:  MOVWF  xF9
06714:  MOVFF  1CA,A48
06718:  MOVLW  37
0671A:  MOVLB  A
0671C:  MOVWF  x49
0671E:  MOVLB  0
06720:  CALL   1E3C
06724:  MOVLW  0D
06726:  BTFSS  FA6.6
06728:  GOTO   6726
0672C:  MOVLB  E
0672E:  MOVWF  xF9
06730:  MOVLW  0A
06732:  MOVLB  0
06734:  BTFSS  FA6.6
06736:  GOTO   6734
0673A:  MOVLB  E
0673C:  MOVWF  xF9
....................    fprintf(PC, "End Flash Read Address\r\n");
0673E:  MOVLW  70
06740:  MOVWF  FF6
06742:  MOVLW  18
06744:  MOVWF  FF7
06746:  MOVLW  00
06748:  MOVWF  FF8
0674A:  MOVLB  0
0674C:  CALL   1BF6
06750:  GOTO   A674 (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
06948:  MOVLW  8A
0694A:  MOVWF  FF6
0694C:  MOVLW  18
0694E:  MOVWF  FF7
06950:  MOVLW  00
06952:  MOVWF  FF8
06954:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
06958:  MOVLB  1
0695A:  MOVF   xC1,W
0695C:  MOVWF  FE9
0695E:  MOVF   xC2,W
06960:  MOVWF  FEA
06962:  MOVFF  FEF,1C3
06966:  MOVFF  1C3,214
0696A:  MOVLB  2
0696C:  CLRF   x15
0696E:  MOVLB  0
06970:  CALL   49C2
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
06974:  MOVFF  1C2,1C4
06978:  MOVFF  1C1,1C3
0697C:  CALL   53DA
....................    mode_misf_address_reset(parameter); // Reset the address area
06980:  MOVFF  1C2,1C4
06984:  MOVFF  1C1,1C3
06988:  GOTO   6754
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
0698C:  MOVLW  A8
0698E:  MOVWF  FF6
06990:  MOVLW  18
06992:  MOVWF  FF7
06994:  MOVLW  00
06996:  MOVWF  FF8
06998:  CALL   1BF6
0699C:  GOTO   A684 (RETURN)
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
069A0:  MOVLW  C4
069A2:  MOVWF  FF6
069A4:  MOVLW  18
069A6:  MOVWF  FF7
069A8:  MOVLW  00
069AA:  MOVWF  FF8
069AC:  CALL   1BF6
....................    flash_setting(mis_fm);
069B0:  MOVFF  115,2CF
069B4:  MOVFF  114,2CE
069B8:  MOVFF  113,2CD
069BC:  MOVFF  112,2CC
069C0:  CALL   60C8
....................    flash_setting(smf);
069C4:  MOVFF  119,2CF
069C8:  MOVFF  118,2CE
069CC:  MOVFF  117,2CD
069D0:  MOVFF  116,2CC
069D4:  CALL   60C8
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
069D8:  MOVLB  1
069DA:  MOVF   xC1,W
069DC:  MOVWF  FE9
069DE:  MOVF   xC2,W
069E0:  MOVWF  FEA
069E2:  MOVFF  FEF,1C3
069E6:  CLRF   xC7
069E8:  CLRF   xC6
069EA:  CLRF   xC5
069EC:  CLRF   xC4
069EE:  CLRF   xCB
069F0:  CLRF   xCA
069F2:  MOVLW  10
069F4:  MOVWF  xC9
069F6:  CLRF   xC8
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
069F8:  MOVFF  115,319
069FC:  MOVFF  114,318
06A00:  MOVFF  113,317
06A04:  MOVFF  112,316
06A08:  MOVFF  1C7,31D
06A0C:  MOVFF  1C6,31C
06A10:  MOVFF  1C5,31B
06A14:  MOVFF  1C4,31A
06A18:  MOVLW  01
06A1A:  MOVLB  3
06A1C:  MOVWF  x1F
06A1E:  MOVLW  CC
06A20:  MOVWF  x1E
06A22:  CLRF   x23
06A24:  CLRF   x22
06A26:  MOVLW  01
06A28:  MOVWF  x21
06A2A:  CLRF   x20
06A2C:  MOVLB  0
06A2E:  CALL   27D0
....................    write_data_bytes(smf, dest_address, read_data, 256);
06A32:  MOVFF  119,A8E
06A36:  MOVFF  118,A8D
06A3A:  MOVFF  117,A8C
06A3E:  MOVFF  116,A8B
06A42:  MOVFF  1CB,A92
06A46:  MOVFF  1CA,A91
06A4A:  MOVFF  1C9,A90
06A4E:  MOVFF  1C8,A8F
06A52:  MOVLW  01
06A54:  MOVLB  A
06A56:  MOVWF  x94
06A58:  MOVLW  CC
06A5A:  MOVWF  x93
06A5C:  MOVLW  01
06A5E:  MOVWF  x96
06A60:  CLRF   x95
06A62:  MOVLB  0
06A64:  CALL   3EC0
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
06A68:  MOVLW  DC
06A6A:  MOVWF  FF6
06A6C:  MOVLW  18
06A6E:  MOVWF  FF7
06A70:  MOVLW  00
06A72:  MOVWF  FF8
06A74:  CALL   1BF6
06A78:  GOTO   A694 (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
06A7C:  MOVLW  F2
06A7E:  MOVWF  FF6
06A80:  MOVLW  18
06A82:  MOVWF  FF7
06A84:  MOVLW  00
06A86:  MOVWF  FF8
06A88:  CALL   1BF6
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
06A8C:  MOVFF  119,319
06A90:  MOVFF  118,318
06A94:  MOVFF  117,317
06A98:  MOVFF  116,316
06A9C:  MOVLB  3
06A9E:  CLRF   x1D
06AA0:  CLRF   x1C
06AA2:  MOVLW  01
06AA4:  MOVWF  x1B
06AA6:  MOVLW  C3
06AA8:  MOVWF  x1A
06AAA:  MOVLW  01
06AAC:  MOVWF  x1F
06AAE:  MOVLW  C3
06AB0:  MOVWF  x1E
06AB2:  CLRF   x23
06AB4:  CLRF   x22
06AB6:  CLRF   x21
06AB8:  MOVLW  40
06ABA:  MOVWF  x20
06ABC:  MOVLB  0
06ABE:  CALL   27D0
....................    fprintf(PC, "Read Data: ");
06AC2:  MOVLW  0A
06AC4:  MOVWF  FF6
06AC6:  MOVLW  19
06AC8:  MOVWF  FF7
06ACA:  MOVLW  00
06ACC:  MOVWF  FF8
06ACE:  CALL   1BF6
....................    for (int i = 0; i < PACKET_SIZE; i++)
06AD2:  MOVLB  2
06AD4:  CLRF   x03
06AD6:  MOVLB  0
06AD8:  MOVLB  2
06ADA:  MOVF   x03,W
06ADC:  SUBLW  3F
06ADE:  BTFSC  FD8.0
06AE0:  BRA    6AE8
06AE2:  MOVLB  0
06AE4:  GOTO   6B26
06AE8:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
06AEA:  CLRF   03
06AEC:  MOVLB  2
06AEE:  MOVF   x03,W
06AF0:  ADDLW  C3
06AF2:  MOVWF  FE9
06AF4:  MOVLW  01
06AF6:  ADDWFC 03,W
06AF8:  MOVWF  FEA
06AFA:  MOVFF  FEF,204
06AFE:  MOVFF  204,A48
06B02:  MOVLW  37
06B04:  MOVLB  A
06B06:  MOVWF  x49
06B08:  MOVLB  0
06B0A:  CALL   1E3C
06B0E:  MOVLW  20
06B10:  BTFSS  FA6.6
06B12:  GOTO   6B10
06B16:  MOVLB  E
06B18:  MOVWF  xF9
06B1A:  MOVLB  0
06B1C:  MOVLB  2
06B1E:  INCF   x03,F
06B20:  MOVLB  0
06B22:  GOTO   6AD8
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
06B26:  MOVLW  16
06B28:  MOVWF  FF6
06B2A:  MOVLW  19
06B2C:  MOVWF  FF7
06B2E:  MOVLW  00
06B30:  MOVWF  FF8
06B32:  CALL   1BF6
06B36:  GOTO   A6A4 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
06B3A:  MOVLW  2E
06B3C:  MOVWF  FF6
06B3E:  MOVLW  19
06B40:  MOVWF  FF7
06B42:  MOVLW  00
06B44:  MOVWF  FF8
06B46:  CALL   1BF6
....................    flash_setting(smf);
06B4A:  MOVFF  119,2CF
06B4E:  MOVFF  118,2CE
06B52:  MOVFF  117,2CD
06B56:  MOVFF  116,2CC
06B5A:  CALL   60C8
....................    unsigned int32 erase_address = 0x00000000; // Example address
06B5E:  MOVLB  1
06B60:  CLRF   xC6
06B62:  CLRF   xC5
06B64:  CLRF   xC4
06B66:  CLRF   xC3
....................    sector_erase(smf, erase_address); // Erase the sector
06B68:  MOVFF  119,A8C
06B6C:  MOVFF  118,A8B
06B70:  MOVFF  117,A8A
06B74:  MOVFF  116,A89
06B78:  MOVFF  1C6,A90
06B7C:  MOVFF  1C5,A8F
06B80:  MOVFF  1C4,A8E
06B84:  MOVFF  1C3,A8D
06B88:  MOVLB  0
06B8A:  CALL   45DC
....................    fprintf(PC, "End Flash SMF Erase\r\n");
06B8E:  MOVLW  46
06B90:  MOVWF  FF6
06B92:  MOVLW  19
06B94:  MOVWF  FF7
06B96:  MOVLW  00
06B98:  MOVWF  FF8
06B9A:  CALL   1BF6
06B9E:  GOTO   A6B4 (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
06754:  MOVLW  5C
06756:  MOVWF  FF6
06758:  MOVLW  19
0675A:  MOVWF  FF7
0675C:  MOVLW  00
0675E:  MOVWF  FF8
06760:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_START); 
06764:  MOVLB  1
06766:  MOVF   xC3,W
06768:  MOVWF  FE9
0676A:  MOVF   xC4,W
0676C:  MOVWF  FEA
0676E:  MOVFF  FEF,207
06772:  MOVFF  207,214
06776:  MOVLB  2
06778:  CLRF   x15
0677A:  MOVLB  0
0677C:  CALL   49C2
....................    FlashData_t flash_data;
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
06780:  MOVLW  01
06782:  MOVWF  FEA
06784:  MOVLW  C5
06786:  MOVWF  FE9
06788:  CLRF   00
0678A:  CLRF   02
0678C:  MOVLW  40
0678E:  MOVWF  01
06790:  CALL   27AC
....................    /*
....................    for (int i = 0; i < PACKET_SIZE; i++) {
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
....................    }
....................    */
....................    fprintf(PC, "\r\n");
06794:  MOVLW  0D
06796:  BTFSS  FA6.6
06798:  GOTO   6796
0679C:  MOVLB  E
0679E:  MOVWF  xF9
067A0:  MOVLW  0A
067A2:  MOVLB  0
067A4:  BTFSS  FA6.6
067A6:  GOTO   67A4
067AA:  MOVLB  E
067AC:  MOVWF  xF9
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
067AE:  MOVLW  01
067B0:  MOVLB  A
067B2:  MOVWF  xEB
067B4:  MOVLW  C5
067B6:  MOVWF  xEA
067B8:  MOVLW  3F
067BA:  MOVWF  xEC
067BC:  MOVLB  0
067BE:  CALL   29E8
067C2:  MOVFF  01,204
....................    for (int i = 0; i < PACKET_SIZE; i++) {
067C6:  MOVLB  2
067C8:  CLRF   x05
067CA:  MOVLB  0
067CC:  MOVLB  2
067CE:  MOVF   x05,W
067D0:  SUBLW  3F
067D2:  BTFSC  FD8.0
067D4:  BRA    67DC
067D6:  MOVLB  0
067D8:  GOTO   681A
067DC:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
067DE:  CLRF   03
067E0:  MOVLB  2
067E2:  MOVF   x05,W
067E4:  ADDLW  C5
067E6:  MOVWF  FE9
067E8:  MOVLW  01
067EA:  ADDWFC 03,W
067EC:  MOVWF  FEA
067EE:  MOVFF  FEF,207
067F2:  MOVFF  207,A48
067F6:  MOVLW  37
067F8:  MOVLB  A
067FA:  MOVWF  x49
067FC:  MOVLB  0
067FE:  CALL   1E3C
06802:  MOVLW  20
06804:  BTFSS  FA6.6
06806:  GOTO   6804
0680A:  MOVLB  E
0680C:  MOVWF  xF9
0680E:  MOVLB  0
06810:  MOVLB  2
06812:  INCF   x05,F
06814:  MOVLB  0
06816:  GOTO   67CC
....................    }
....................    fprintf(PC, "\r\n");
0681A:  MOVLW  0D
0681C:  BTFSS  FA6.6
0681E:  GOTO   681C
06822:  MOVLB  E
06824:  MOVWF  xF9
06826:  MOVLW  0A
06828:  MOVLB  0
0682A:  BTFSS  FA6.6
0682C:  GOTO   682A
06830:  MOVLB  E
06832:  MOVWF  xF9
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
06834:  MOVFF  115,A8E
06838:  MOVFF  114,A8D
0683C:  MOVFF  113,A8C
06840:  MOVFF  112,A8B
06844:  MOVLB  A
06846:  CLRF   x92
06848:  CLRF   x91
0684A:  CLRF   x90
0684C:  CLRF   x8F
0684E:  MOVLW  01
06850:  MOVWF  x94
06852:  MOVLW  C5
06854:  MOVWF  x93
06856:  CLRF   x96
06858:  MOVLW  40
0685A:  MOVWF  x95
0685C:  MOVLB  0
0685E:  CALL   3EC0
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
06862:  MOVLW  01
06864:  MOVWF  FEA
06866:  MOVLW  C5
06868:  MOVWF  FE9
0686A:  CLRF   00
0686C:  CLRF   02
0686E:  MOVLW  40
06870:  MOVWF  01
06872:  CALL   27AC
....................    read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
06876:  MOVFF  115,319
0687A:  MOVFF  114,318
0687E:  MOVFF  113,317
06882:  MOVFF  112,316
06886:  MOVLB  3
06888:  CLRF   x1D
0688A:  CLRF   x1C
0688C:  CLRF   x1B
0688E:  CLRF   x1A
06890:  MOVLW  01
06892:  MOVWF  x1F
06894:  MOVLW  C5
06896:  MOVWF  x1E
06898:  CLRF   x23
0689A:  CLRF   x22
0689C:  CLRF   x21
0689E:  MOVLW  40
068A0:  MOVWF  x20
068A2:  MOVLB  0
068A4:  CALL   27D0
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
068A8:  MOVLW  01
068AA:  MOVLB  A
068AC:  MOVWF  xEB
068AE:  MOVLW  C5
068B0:  MOVWF  xEA
068B2:  MOVLW  3F
068B4:  MOVWF  xEC
068B6:  MOVLB  0
068B8:  CALL   29E8
068BC:  MOVFF  01,204
....................    for (int i = 0; i < PACKET_SIZE; i++) {
068C0:  MOVLB  2
068C2:  CLRF   x06
068C4:  MOVLB  0
068C6:  MOVLB  2
068C8:  MOVF   x06,W
068CA:  SUBLW  3F
068CC:  BTFSC  FD8.0
068CE:  BRA    68D6
068D0:  MOVLB  0
068D2:  GOTO   6914
068D6:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
068D8:  CLRF   03
068DA:  MOVLB  2
068DC:  MOVF   x06,W
068DE:  ADDLW  C5
068E0:  MOVWF  FE9
068E2:  MOVLW  01
068E4:  ADDWFC 03,W
068E6:  MOVWF  FEA
068E8:  MOVFF  FEF,207
068EC:  MOVFF  207,A48
068F0:  MOVLW  37
068F2:  MOVLB  A
068F4:  MOVWF  x49
068F6:  MOVLB  0
068F8:  CALL   1E3C
068FC:  MOVLW  20
068FE:  BTFSS  FA6.6
06900:  GOTO   68FE
06904:  MOVLB  E
06906:  MOVWF  xF9
06908:  MOVLB  0
0690A:  MOVLB  2
0690C:  INCF   x06,F
0690E:  MOVLB  0
06910:  GOTO   68C6
....................    }
....................    misf_init(); // Update the address area after writing
06914:  CALL   32FC
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06918:  MOVLB  1
0691A:  MOVF   xC3,W
0691C:  MOVWF  FE9
0691E:  MOVF   xC4,W
06920:  MOVWF  FEA
06922:  MOVFF  FEF,207
06926:  MOVFF  207,214
0692A:  MOVLB  2
0692C:  SETF   x15
0692E:  MOVLB  0
06930:  CALL   49C2
....................    fprintf(PC, "End Flash Address Reset\r\n");
06934:  MOVLW  78
06936:  MOVWF  FF6
06938:  MOVLW  19
0693A:  MOVWF  FF7
0693C:  MOVLW  00
0693E:  MOVWF  FF8
06940:  CALL   1BF6
06944:  GOTO   698C (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
06DEC:  MOVLW  01
06DEE:  MOVLB  1
06DF0:  ADDWF  xC1,W
06DF2:  MOVWF  FE9
06DF4:  MOVLW  00
06DF6:  ADDWFC xC2,W
06DF8:  MOVWF  FEA
06DFA:  MOVF   FEF,W
06DFC:  MOVLB  2
06DFE:  CLRF   x13
06E00:  CLRF   x12
06E02:  CLRF   x11
06E04:  MOVWF  x10
06E06:  MOVFF  210,213
06E0A:  CLRF   x10
06E0C:  CLRF   x11
06E0E:  CLRF   x12
06E10:  MOVLW  02
06E12:  MOVLB  1
06E14:  ADDWF  xC1,W
06E16:  MOVWF  FE9
06E18:  MOVLW  00
06E1A:  ADDWFC xC2,W
06E1C:  MOVWF  FEA
06E1E:  MOVF   FEF,W
06E20:  MOVLB  2
06E22:  CLRF   x18
06E24:  CLRF   x17
06E26:  CLRF   x16
06E28:  MOVWF  x15
06E2A:  MOVFF  216,03
06E2E:  MOVFF  215,02
06E32:  CLRF   00
06E34:  CLRF   01
06E36:  MOVF   00,W
06E38:  IORWF  x10,F
06E3A:  MOVF   01,W
06E3C:  IORWF  x11,F
06E3E:  MOVF   02,W
06E40:  IORWF  x12,F
06E42:  MOVF   03,W
06E44:  IORWF  x13,F
06E46:  MOVLW  03
06E48:  MOVLB  1
06E4A:  ADDWF  xC1,W
06E4C:  MOVWF  FE9
06E4E:  MOVLW  00
06E50:  ADDWFC xC2,W
06E52:  MOVWF  FEA
06E54:  MOVF   FEF,W
06E56:  MOVLB  2
06E58:  CLRF   x18
06E5A:  CLRF   x17
06E5C:  CLRF   x16
06E5E:  MOVWF  x15
06E60:  MOVFF  217,03
06E64:  MOVFF  216,02
06E68:  MOVFF  215,01
06E6C:  CLRF   00
06E6E:  MOVF   00,W
06E70:  IORWF  x10,F
06E72:  MOVF   01,W
06E74:  IORWF  x11,F
06E76:  MOVF   02,W
06E78:  IORWF  x12,F
06E7A:  MOVF   03,W
06E7C:  IORWF  x13,F
06E7E:  MOVLW  04
06E80:  MOVLB  1
06E82:  ADDWF  xC1,W
06E84:  MOVWF  FE9
06E86:  MOVLW  00
06E88:  ADDWFC xC2,W
06E8A:  MOVWF  FEA
06E8C:  MOVF   FEF,W
06E8E:  MOVWF  00
06E90:  CLRF   01
06E92:  CLRF   02
06E94:  CLRF   03
06E96:  MOVF   00,W
06E98:  MOVLB  2
06E9A:  IORWF  x10,W
06E9C:  MOVLB  1
06E9E:  MOVWF  xC3
06EA0:  MOVF   01,W
06EA2:  MOVLB  2
06EA4:  IORWF  x11,W
06EA6:  MOVLB  1
06EA8:  MOVWF  xC4
06EAA:  MOVF   02,W
06EAC:  MOVLB  2
06EAE:  IORWF  x12,W
06EB0:  MOVLB  1
06EB2:  MOVWF  xC5
06EB4:  MOVF   03,W
06EB6:  MOVLB  2
06EB8:  IORWF  x13,W
06EBA:  MOVLB  1
06EBC:  MOVWF  xC6
06EBE:  MOVLW  07
06EC0:  ADDWF  xC1,W
06EC2:  MOVWF  FE9
06EC4:  MOVLW  00
06EC6:  ADDWFC xC2,W
06EC8:  MOVWF  FEA
06ECA:  MOVF   FEF,W
06ECC:  MOVLB  2
06ECE:  CLRF   x11
06ED0:  MOVWF  x10
06ED2:  MOVFF  210,211
06ED6:  CLRF   x10
06ED8:  MOVLW  08
06EDA:  MOVLB  1
06EDC:  ADDWF  xC1,W
06EDE:  MOVWF  FE9
06EE0:  MOVLW  00
06EE2:  ADDWFC xC2,W
06EE4:  MOVWF  FEA
06EE6:  MOVF   FEF,W
06EE8:  CLRF   03
06EEA:  MOVLB  2
06EEC:  IORWF  x10,W
06EEE:  MOVLB  1
06EF0:  MOVWF  xC7
06EF2:  MOVF   03,W
06EF4:  MOVLB  2
06EF6:  IORWF  x11,W
06EF8:  MOVLB  1
06EFA:  MOVWF  xC8
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
06EFC:  CLRF   xC9
06EFE:  CLRF   xCA
06F00:  CLRF   xCB
06F02:  CLRF   xCC
06F04:  CLRF   xCD
06F06:  CLRF   xCE
06F08:  CLRF   xCF
06F0A:  CLRF   xD0
06F0C:  CLRF   xD1
06F0E:  CLRF   xD2
06F10:  CLRF   xD3
06F12:  CLRF   xD4
06F14:  CLRF   xD5
06F16:  CLRF   xD6
06F18:  CLRF   xD7
06F1A:  CLRF   xD8
06F1C:  CLRF   xD9
06F1E:  CLRF   xDA
06F20:  CLRF   xDB
06F22:  CLRF   xDC
06F24:  CLRF   xDD
06F26:  CLRF   xDE
06F28:  CLRF   xDF
06F2A:  CLRF   xE0
06F2C:  CLRF   xE1
06F2E:  CLRF   xE2
06F30:  CLRF   xE3
06F32:  CLRF   xE4
06F34:  CLRF   xE5
06F36:  CLRF   xE6
06F38:  CLRF   xE7
06F3A:  CLRF   xE8
06F3C:  CLRF   xE9
06F3E:  CLRF   xEA
06F40:  CLRF   xEB
06F42:  CLRF   xEC
06F44:  CLRF   xED
06F46:  CLRF   xEE
06F48:  CLRF   xEF
06F4A:  CLRF   xF0
06F4C:  CLRF   xF1
06F4E:  CLRF   xF2
06F50:  CLRF   xF3
06F52:  CLRF   xF4
06F54:  CLRF   xF5
06F56:  CLRF   xF6
06F58:  CLRF   xF7
06F5A:  CLRF   xF8
06F5C:  CLRF   xF9
06F5E:  CLRF   xFA
06F60:  CLRF   xFB
06F62:  CLRF   xFC
06F64:  CLRF   xFD
06F66:  CLRF   xFE
06F68:  CLRF   xFF
06F6A:  MOVLB  2
06F6C:  CLRF   x00
06F6E:  CLRF   x01
06F70:  CLRF   x02
06F72:  CLRF   x03
06F74:  CLRF   x04
06F76:  CLRF   x05
06F78:  CLRF   x06
06F7A:  CLRF   x07
06F7C:  CLRF   x08
....................    if(!is_connect(smf)) {
06F7E:  MOVFF  119,297
06F82:  MOVFF  118,296
06F86:  MOVFF  117,295
06F8A:  MOVFF  116,294
06F8E:  MOVLB  0
06F90:  CALL   26E4
06F94:  MOVF   01,F
06F96:  BTFSS  FD8.2
06F98:  GOTO   6FB0
....................       printf("SMF is not connected\r\n");
06F9C:  MOVLW  92
06F9E:  MOVWF  FF6
06FA0:  MOVLW  19
06FA2:  MOVWF  FF7
06FA4:  MOVLW  00
06FA6:  MOVWF  FF8
06FA8:  CALL   1BF6
....................       return;
06FAC:  GOTO   7218
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
06FB0:  MOVLW  AA
06FB2:  MOVWF  FF6
06FB4:  MOVLW  19
06FB6:  MOVWF  FF7
06FB8:  MOVLW  00
06FBA:  MOVWF  FF8
06FBC:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
06FC0:  MOVLB  1
06FC2:  MOVF   xC1,W
06FC4:  MOVWF  FE9
06FC6:  MOVF   xC2,W
06FC8:  MOVWF  FEA
06FCA:  MOVFF  FEF,210
06FCE:  MOVFF  210,214
06FD2:  MOVLB  2
06FD4:  CLRF   x15
06FD6:  MOVLB  0
06FD8:  CALL   49C2
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
06FDC:  MOVLW  C8
06FDE:  MOVWF  FF6
06FE0:  MOVLW  19
06FE2:  MOVWF  FF7
06FE4:  MOVLW  00
06FE6:  MOVWF  FF8
06FE8:  MOVLW  0E
06FEA:  MOVLB  9
06FEC:  MOVWF  xE9
06FEE:  MOVLB  0
06FF0:  CALL   1C2C
06FF4:  MOVFF  1C6,A48
06FF8:  MOVLW  37
06FFA:  MOVLB  A
06FFC:  MOVWF  x49
06FFE:  MOVLB  0
07000:  CALL   1E3C
07004:  MOVFF  1C5,A48
07008:  MOVLW  37
0700A:  MOVLB  A
0700C:  MOVWF  x49
0700E:  MOVLB  0
07010:  CALL   1E3C
07014:  MOVFF  1C4,A48
07018:  MOVLW  37
0701A:  MOVLB  A
0701C:  MOVWF  x49
0701E:  MOVLB  0
07020:  CALL   1E3C
07024:  MOVFF  1C3,A48
07028:  MOVLW  37
0702A:  MOVLB  A
0702C:  MOVWF  x49
0702E:  MOVLB  0
07030:  CALL   1E3C
07034:  MOVLW  0D
07036:  BTFSS  FA6.6
07038:  GOTO   7036
0703C:  MOVLB  E
0703E:  MOVWF  xF9
07040:  MOVLW  0A
07042:  MOVLB  0
07044:  BTFSS  FA6.6
07046:  GOTO   7044
0704A:  MOVLB  E
0704C:  MOVWF  xF9
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
0704E:  MOVLW  DE
07050:  MOVWF  FF6
07052:  MOVLW  19
07054:  MOVWF  FF7
07056:  MOVLW  00
07058:  MOVWF  FF8
0705A:  MOVLW  0E
0705C:  MOVLB  9
0705E:  MOVWF  xE9
07060:  MOVLB  0
07062:  CALL   1C2C
07066:  MOVFF  1C8,A48
0706A:  MOVLW  37
0706C:  MOVLB  A
0706E:  MOVWF  x49
07070:  MOVLB  0
07072:  CALL   1E3C
07076:  MOVFF  1C7,A48
0707A:  MOVLW  37
0707C:  MOVLB  A
0707E:  MOVWF  x49
07080:  MOVLB  0
07082:  CALL   1E3C
07086:  MOVLW  0D
07088:  BTFSS  FA6.6
0708A:  GOTO   7088
0708E:  MOVLB  E
07090:  MOVWF  xF9
07092:  MOVLW  0A
07094:  MOVLB  0
07096:  BTFSS  FA6.6
07098:  GOTO   7096
0709C:  MOVLB  E
0709E:  MOVWF  xF9
....................    printf("read data\r\n");
070A0:  MOVLW  F4
070A2:  MOVWF  FF6
070A4:  MOVLW  19
070A6:  MOVWF  FF7
070A8:  MOVLW  00
070AA:  MOVWF  FF8
070AC:  MOVLB  0
070AE:  CALL   1BF6
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
070B2:  MOVLB  2
070B4:  CLRF   x0A
070B6:  CLRF   x09
070B8:  MOVLB  0
070BA:  MOVLB  2
070BC:  MOVF   x0A,W
070BE:  MOVLB  1
070C0:  SUBWF  xC8,W
070C2:  BTFSC  FD8.0
070C4:  BRA    70CC
070C6:  MOVLB  0
070C8:  GOTO   71EC
070CC:  MOVLB  0
070CE:  BTFSS  FD8.2
070D0:  GOTO   70E8
070D4:  MOVLB  1
070D6:  MOVF   xC7,W
070D8:  MOVLB  2
070DA:  SUBWF  x09,W
070DC:  BTFSS  FD8.0
070DE:  BRA    70E6
070E0:  MOVLB  0
070E2:  GOTO   71EC
070E6:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
070E8:  MOVLB  2
070EA:  RLCF   x09,W
070EC:  MOVWF  02
070EE:  RLCF   x0A,W
070F0:  MOVWF  03
070F2:  RLCF   02,F
070F4:  RLCF   03,F
070F6:  RLCF   02,F
070F8:  RLCF   03,F
070FA:  RLCF   02,F
070FC:  RLCF   03,F
070FE:  RLCF   02,F
07100:  RLCF   03,F
07102:  RLCF   02,F
07104:  RLCF   03,F
07106:  MOVLW  C0
07108:  ANDWF  02,F
0710A:  MOVF   02,W
0710C:  MOVLB  1
0710E:  ADDWF  xC3,W
07110:  MOVLB  2
07112:  MOVWF  x0B
07114:  MOVF   03,W
07116:  MOVLB  1
07118:  ADDWFC xC4,W
0711A:  MOVLB  2
0711C:  MOVWF  x0C
0711E:  MOVLW  00
07120:  MOVLB  1
07122:  ADDWFC xC5,W
07124:  MOVLB  2
07126:  MOVWF  x0D
07128:  MOVLW  00
0712A:  MOVLB  1
0712C:  ADDWFC xC6,W
0712E:  MOVLB  2
07130:  MOVWF  x0E
07132:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
07134:  MOVFF  119,319
07138:  MOVFF  118,318
0713C:  MOVFF  117,317
07140:  MOVFF  116,316
07144:  MOVFF  20E,31D
07148:  MOVFF  20D,31C
0714C:  MOVFF  20C,31B
07150:  MOVFF  20B,31A
07154:  MOVLW  01
07156:  MOVLB  3
07158:  MOVWF  x1F
0715A:  MOVLW  C9
0715C:  MOVWF  x1E
0715E:  CLRF   x23
07160:  CLRF   x22
07162:  CLRF   x21
07164:  MOVLW  40
07166:  MOVWF  x20
07168:  MOVLB  0
0716A:  CALL   27D0
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
0716E:  MOVLB  2
07170:  CLRF   x0F
07172:  MOVLB  0
07174:  MOVLB  2
07176:  MOVF   x0F,W
07178:  SUBLW  3F
0717A:  BTFSC  FD8.0
0717C:  BRA    7184
0717E:  MOVLB  0
07180:  GOTO   71C2
07184:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
07186:  CLRF   03
07188:  MOVLB  2
0718A:  MOVF   x0F,W
0718C:  ADDLW  C9
0718E:  MOVWF  FE9
07190:  MOVLW  01
07192:  ADDWFC 03,W
07194:  MOVWF  FEA
07196:  MOVFF  FEF,210
0719A:  MOVFF  210,A48
0719E:  MOVLW  37
071A0:  MOVLB  A
071A2:  MOVWF  x49
071A4:  MOVLB  0
071A6:  CALL   1E3C
071AA:  MOVLW  20
071AC:  BTFSS  FA6.6
071AE:  GOTO   71AC
071B2:  MOVLB  E
071B4:  MOVWF  xF9
071B6:  MOVLB  0
071B8:  MOVLB  2
071BA:  INCF   x0F,F
071BC:  MOVLB  0
071BE:  GOTO   7174
....................       }
....................       printf("\r\n");
071C2:  MOVLW  0D
071C4:  BTFSS  FA6.6
071C6:  GOTO   71C4
071CA:  MOVLB  E
071CC:  MOVWF  xF9
071CE:  MOVLW  0A
071D0:  MOVLB  0
071D2:  BTFSS  FA6.6
071D4:  GOTO   71D2
071D8:  MOVLB  E
071DA:  MOVWF  xF9
071DC:  MOVLB  0
071DE:  MOVLB  2
071E0:  INCF   x09,F
071E2:  BTFSC  FD8.2
071E4:  INCF   x0A,F
071E6:  MOVLB  0
071E8:  GOTO   70BA
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
071EC:  MOVLW  00
071EE:  MOVWF  FF6
071F0:  MOVLW  1A
071F2:  MOVWF  FF7
071F4:  MOVLW  00
071F6:  MOVWF  FF8
071F8:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
071FC:  MOVLB  1
071FE:  MOVF   xC1,W
07200:  MOVWF  FE9
07202:  MOVF   xC2,W
07204:  MOVWF  FEA
07206:  MOVFF  FEF,210
0720A:  MOVFF  210,214
0720E:  MOVLB  2
07210:  SETF   x15
07212:  MOVLB  0
07214:  CALL   49C2
07218:  GOTO   A6D4 (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
0721C:  MOVLW  1E
0721E:  MOVWF  FF6
07220:  MOVLW  1A
07222:  MOVWF  FF7
07224:  MOVLW  00
07226:  MOVWF  FF8
07228:  CALL   1BF6
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
0722C:  MOVLB  1
0722E:  MOVF   xC1,W
07230:  MOVWF  FE9
07232:  MOVF   xC2,W
07234:  MOVWF  FEA
07236:  MOVFF  FEF,1C3
....................    piclog_make(cmd, 0x00); // Log the command execution
0723A:  MOVFF  1C3,214
0723E:  MOVLB  2
07240:  CLRF   x15
07242:  MOVLB  0
07244:  CALL   49C2
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
07248:  MOVLW  06
0724A:  MOVLB  1
0724C:  MOVWF  xC7
0724E:  MOVLW  AA
07250:  MOVWF  xC6
07252:  CLRF   xC5
07254:  CLRF   xC4
07256:  MOVLB  0
07258:  MOVLB  1
0725A:  MOVF   xC7,W
0725C:  SUBLW  06
0725E:  BTFSC  FD8.0
07260:  BRA    7268
07262:  MOVLB  0
07264:  GOTO   72E6
07268:  MOVLB  0
0726A:  BTFSS  FD8.2
0726C:  GOTO   72B2
07270:  MOVLB  1
07272:  MOVF   xC6,W
07274:  SUBLW  AA
07276:  BTFSC  FD8.0
07278:  BRA    7280
0727A:  MOVLB  0
0727C:  GOTO   72E6
07280:  MOVLB  0
07282:  BTFSS  FD8.2
07284:  GOTO   72B2
07288:  MOVLB  1
0728A:  MOVF   xC5,W
0728C:  SUBLW  1F
0728E:  BTFSC  FD8.0
07290:  BRA    7298
07292:  MOVLB  0
07294:  GOTO   72E6
07298:  MOVLB  0
0729A:  BTFSS  FD8.2
0729C:  GOTO   72B2
072A0:  MOVLB  1
072A2:  MOVF   xC4,W
072A4:  SUBLW  FE
072A6:  BTFSC  FD8.0
072A8:  BRA    72B0
072AA:  MOVLB  0
072AC:  GOTO   72E6
072B0:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
072B2:  MOVFF  119,A8C
072B6:  MOVFF  118,A8B
072BA:  MOVFF  117,A8A
072BE:  MOVFF  116,A89
072C2:  MOVFF  1C7,A90
072C6:  MOVFF  1C6,A8F
072CA:  MOVFF  1C5,A8E
072CE:  MOVFF  1C4,A8D
072D2:  CALL   45DC
072D6:  MOVLW  01
072D8:  MOVLB  1
072DA:  ADDWF  xC6,F
072DC:  MOVLW  00
072DE:  ADDWFC xC7,F
072E0:  MOVLB  0
072E2:  GOTO   7258
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
072E6:  MOVFF  1C3,214
072EA:  MOVLB  2
072EC:  SETF   x15
072EE:  MOVLB  0
072F0:  CALL   49C2
....................    printf("End SMF Erase All\r\n");
072F4:  MOVLW  34
072F6:  MOVWF  FF6
072F8:  MOVLW  1A
072FA:  MOVWF  FF7
072FC:  MOVLW  00
072FE:  MOVWF  FF8
07300:  CALL   1BF6
07304:  GOTO   A6E4 (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
06C6E:  MOVLW  48
06C70:  MOVWF  FF6
06C72:  MOVLW  1A
06C74:  MOVWF  FF7
06C76:  MOVLW  00
06C78:  MOVWF  FF8
06C7A:  CALL   1BF6
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
06C7E:  MOVLB  1
06C80:  MOVF   xC1,W
06C82:  MOVWF  FE9
06C84:  MOVF   xC2,W
06C86:  MOVWF  FEA
06C88:  MOVFF  FEF,207
06C8C:  MOVFF  207,214
06C90:  MOVLB  2
06C92:  CLRF   x15
06C94:  MOVLB  0
06C96:  CALL   49C2
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
06C9A:  MOVLB  1
06C9C:  CLRF   xC3
06C9E:  CLRF   xC4
06CA0:  CLRF   xC5
06CA2:  CLRF   xC6
06CA4:  CLRF   xC7
06CA6:  CLRF   xC8
06CA8:  CLRF   xC9
06CAA:  CLRF   xCA
06CAC:  CLRF   xCB
06CAE:  CLRF   xCC
06CB0:  CLRF   xCD
06CB2:  CLRF   xCE
06CB4:  CLRF   xCF
06CB6:  CLRF   xD0
06CB8:  CLRF   xD1
06CBA:  CLRF   xD2
06CBC:  CLRF   xD3
06CBE:  CLRF   xD4
06CC0:  CLRF   xD5
06CC2:  CLRF   xD6
06CC4:  CLRF   xD7
06CC6:  CLRF   xD8
06CC8:  CLRF   xD9
06CCA:  CLRF   xDA
06CCC:  CLRF   xDB
06CCE:  CLRF   xDC
06CD0:  CLRF   xDD
06CD2:  CLRF   xDE
06CD4:  CLRF   xDF
06CD6:  CLRF   xE0
06CD8:  CLRF   xE1
06CDA:  CLRF   xE2
06CDC:  CLRF   xE3
06CDE:  CLRF   xE4
06CE0:  CLRF   xE5
06CE2:  CLRF   xE6
06CE4:  CLRF   xE7
06CE6:  CLRF   xE8
06CE8:  CLRF   xE9
06CEA:  CLRF   xEA
06CEC:  CLRF   xEB
06CEE:  CLRF   xEC
06CF0:  CLRF   xED
06CF2:  CLRF   xEE
06CF4:  CLRF   xEF
06CF6:  CLRF   xF0
06CF8:  CLRF   xF1
06CFA:  CLRF   xF2
06CFC:  CLRF   xF3
06CFE:  CLRF   xF4
06D00:  CLRF   xF5
06D02:  CLRF   xF6
06D04:  CLRF   xF7
06D06:  CLRF   xF8
06D08:  CLRF   xF9
06D0A:  CLRF   xFA
06D0C:  CLRF   xFB
06D0E:  CLRF   xFC
06D10:  CLRF   xFD
06D12:  CLRF   xFE
06D14:  CLRF   xFF
06D16:  MOVLB  2
06D18:  CLRF   x00
06D1A:  CLRF   x01
06D1C:  CLRF   x02
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_IV2_DATA_END_ADDRESS; address += SECTOR_64K_BYTE) {
06D1E:  MOVLW  06
06D20:  MOVWF  x06
06D22:  MOVLW  AA
06D24:  MOVWF  x05
06D26:  CLRF   x04
06D28:  CLRF   x03
06D2A:  MOVLB  0
06D2C:  MOVLB  2
06D2E:  MOVF   x06,W
06D30:  SUBLW  07
06D32:  BTFSC  FD8.0
06D34:  BRA    6D3C
06D36:  MOVLB  0
06D38:  GOTO   6DBA
06D3C:  MOVLB  0
06D3E:  BTFSS  FD8.2
06D40:  GOTO   6D86
06D44:  MOVLB  2
06D46:  MOVF   x05,W
06D48:  SUBLW  48
06D4A:  BTFSC  FD8.0
06D4C:  BRA    6D54
06D4E:  MOVLB  0
06D50:  GOTO   6DBA
06D54:  MOVLB  0
06D56:  BTFSS  FD8.2
06D58:  GOTO   6D86
06D5C:  MOVLB  2
06D5E:  MOVF   x04,W
06D60:  SUBLW  3F
06D62:  BTFSC  FD8.0
06D64:  BRA    6D6C
06D66:  MOVLB  0
06D68:  GOTO   6DBA
06D6C:  MOVLB  0
06D6E:  BTFSS  FD8.2
06D70:  GOTO   6D86
06D74:  MOVLB  2
06D76:  MOVF   x03,W
06D78:  SUBLW  FE
06D7A:  BTFSC  FD8.0
06D7C:  BRA    6D84
06D7E:  MOVLB  0
06D80:  GOTO   6DBA
06D84:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
06D86:  MOVFF  119,A8C
06D8A:  MOVFF  118,A8B
06D8E:  MOVFF  117,A8A
06D92:  MOVFF  116,A89
06D96:  MOVFF  206,A90
06D9A:  MOVFF  205,A8F
06D9E:  MOVFF  204,A8E
06DA2:  MOVFF  203,A8D
06DA6:  CALL   45DC
06DAA:  MOVLW  01
06DAC:  MOVLB  2
06DAE:  ADDWF  x05,F
06DB0:  MOVLW  00
06DB2:  ADDWFC x06,F
06DB4:  MOVLB  0
06DB6:  GOTO   6D2C
....................    }
....................    smf_data_table_init(); // Update the address area after writing
06DBA:  GOTO   6BA2
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06DBE:  MOVLB  1
06DC0:  MOVF   xC1,W
06DC2:  MOVWF  FE9
06DC4:  MOVF   xC2,W
06DC6:  MOVWF  FEA
06DC8:  MOVFF  FEF,207
06DCC:  MOVFF  207,214
06DD0:  MOVLB  2
06DD2:  SETF   x15
06DD4:  MOVLB  0
06DD6:  CALL   49C2
....................    printf("End SMF Reset\r\n");
06DDA:  MOVLW  5A
06DDC:  MOVWF  FF6
06DDE:  MOVLW  1A
06DE0:  MOVWF  FF7
06DE2:  MOVLW  00
06DE4:  MOVWF  FF8
06DE6:  CALL   1BF6
06DEA:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0CA56:  CLRF   FF8
0CA58:  BCF    FD0.7
0CA5A:  BSF    07.7
0CA5C:  MOVLB  E
0CA5E:  MOVLW  55
0CA60:  MOVWF  F7E
0CA62:  MOVLW  AA
0CA64:  MOVWF  F7E
0CA66:  BCF    F66.6
0CA68:  MOVLW  F9
0CA6A:  MOVWF  x2C
0CA6C:  MOVLW  F6
0CA6E:  MOVWF  x2D
0CA70:  MOVLW  0F
0CA72:  MOVWF  x2E
0CA74:  MOVLW  40
0CA76:  MOVWF  x12
0CA78:  MOVLW  30
0CA7A:  MOVWF  x13
0CA7C:  MOVLW  20
0CA7E:  MOVWF  x22
0CA80:  MOVLW  30
0CA82:  MOVWF  x24
0CA84:  MOVLW  55
0CA86:  MOVWF  F7E
0CA88:  MOVLW  AA
0CA8A:  MOVWF  F7E
0CA8C:  BSF    F66.6
0CA8E:  CLRF   F9B
0CA90:  CLRF   F64
0CA92:  CLRF   F65
0CA94:  CLRF   F66
0CA96:  MOVLW  02
0CA98:  MOVWF  FD3
0CA9A:  CLRF   1B
0CA9C:  MOVLB  F
0CA9E:  BSF    x2D.3
0CAA0:  MOVLW  A0
0CAA2:  MOVWF  x2B
0CAA4:  MOVLW  01
0CAA6:  MOVWF  x2C
0CAA8:  MOVLW  A6
0CAAA:  MOVWF  x2E
0CAAC:  MOVLW  90
0CAAE:  MOVWF  x2F
0CAB0:  MOVLB  E
0CAB2:  BSF    xFD.3
0CAB4:  MOVLW  A0
0CAB6:  MOVWF  xFB
0CAB8:  MOVLW  01
0CABA:  MOVWF  xFC
0CABC:  MOVLW  A6
0CABE:  MOVWF  xFE
0CAC0:  MOVLW  90
0CAC2:  MOVWF  xFF
0CAC4:  BSF    F92.1
0CAC6:  BCF    F92.0
0CAC8:  BCF    F92.3
0CACA:  BCF    F89.3
0CACC:  BSF    F96.0
0CACE:  BCF    F96.6
0CAD0:  BCF    F96.1
0CAD2:  BCF    F8D.1
0CAD4:  BSF    F93.4
0CAD6:  BCF    F93.5
0CAD8:  BCF    F93.2
0CADA:  BSF    F8A.2
0CADC:  CLRF   1F
0CADE:  CLRF   1E
0CAE0:  CLRF   1D
0CAE2:  CLRF   1C
0CAE4:  CLRF   23
0CAE6:  CLRF   22
0CAE8:  CLRF   21
0CAEA:  CLRF   20
0CAEC:  CLRF   27
0CAEE:  CLRF   26
0CAF0:  CLRF   25
0CAF2:  CLRF   24
0CAF4:  CLRF   29
0CAF6:  CLRF   28
0CAF8:  CLRF   4A
0CAFA:  BCF    4B.0
0CAFC:  MOVLW  1E
0CAFE:  MOVLB  1
0CB00:  MOVWF  x34
0CB02:  CLRF   x37
0CB04:  CLRF   x36
0CB06:  MOVLW  01
0CB08:  MOVWF  x23
0CB0A:  MOVLW  5E
0CB0C:  MOVWF  x22
0CB0E:  MOVLW  01
0CB10:  MOVWF  x25
0CB12:  MOVLW  69
0CB14:  MOVWF  x24
0CB16:  MOVLW  01
0CB18:  MOVWF  x27
0CB1A:  MOVLW  74
0CB1C:  MOVWF  x26
0CB1E:  MOVLW  01
0CB20:  MOVWF  x29
0CB22:  MOVLW  7F
0CB24:  MOVWF  x28
0CB26:  MOVLW  01
0CB28:  MOVWF  x2B
0CB2A:  MOVLW  8A
0CB2C:  MOVWF  x2A
0CB2E:  MOVLW  01
0CB30:  MOVWF  x2D
0CB32:  MOVLW  95
0CB34:  MOVWF  x2C
0CB36:  MOVLW  01
0CB38:  MOVWF  x2F
0CB3A:  MOVLW  A0
0CB3C:  MOVWF  x2E
0CB3E:  MOVLB  E
0CB40:  CLRF   xD9
0CB42:  CLRF   xDA
0CB44:  CLRF   xCE
0CB46:  CLRF   xCF
0CB48:  CLRF   xD0
0CB4A:  CLRF   xD1
0CB4C:  CLRF   xD2
0CB4E:  CLRF   xD3
0CB50:  CLRF   xD4
0CB52:  CLRF   xD5
0CB54:  CLRF   x45
0CB56:  CLRF   x46
0CB58:  CLRF   x47
0CB5A:  BCF    x8D.7
0CB5C:  BCF    x8D.6
0CB5E:  BCF    x8D.5
0CB60:  MOVLB  F
0CB62:  CLRF   x53
0CB64:  CLRF   x38
0CB66:  CLRF   x37
0CB68:  MOVLB  0
0CB6A:  CLRF   2A
0CB6C:  CLRF   2B
0CB6E:  CLRF   2C
0CB70:  CLRF   2D
0CB72:  CLRF   2E
0CB74:  CLRF   2F
0CB76:  CLRF   30
0CB78:  CLRF   31
0CB7A:  CLRF   32
0CB7C:  CLRF   33
0CB7E:  CLRF   34
0CB80:  CLRF   35
0CB82:  CLRF   36
0CB84:  CLRF   37
0CB86:  CLRF   38
0CB88:  CLRF   39
0CB8A:  CLRF   3A
0CB8C:  CLRF   3B
0CB8E:  CLRF   3C
0CB90:  CLRF   3D
0CB92:  CLRF   3E
0CB94:  CLRF   3F
0CB96:  CLRF   40
0CB98:  CLRF   41
0CB9A:  CLRF   42
0CB9C:  CLRF   43
0CB9E:  CLRF   44
0CBA0:  CLRF   45
0CBA2:  CLRF   46
0CBA4:  CLRF   47
0CBA6:  CLRF   48
0CBA8:  CLRF   49
0CBAA:  MOVLW  03
0CBAC:  MOVWF  4C
0CBAE:  CLRF   4D
0CBB0:  CLRF   4E
0CBB2:  CLRF   4F
0CBB4:  CLRF   50
0CBB6:  CLRF   51
0CBB8:  CLRF   52
0CBBA:  CLRF   53
0CBBC:  CLRF   54
0CBBE:  CLRF   55
0CBC0:  CLRF   56
0CBC2:  CLRF   57
0CBC4:  CLRF   58
0CBC6:  CLRF   59
0CBC8:  CLRF   5A
0CBCA:  CLRF   5B
0CBCC:  CLRF   5C
0CBCE:  CLRF   5D
0CBD0:  CLRF   5E
0CBD2:  CLRF   5F
0CBD4:  CLRF   x60
0CBD6:  CLRF   x61
0CBD8:  CLRF   x62
0CBDA:  CLRF   x63
0CBDC:  CLRF   x64
0CBDE:  CLRF   x65
0CBE0:  CLRF   x66
0CBE2:  CLRF   x67
0CBE4:  CLRF   x68
0CBE6:  CLRF   x69
0CBE8:  CLRF   x6A
0CBEA:  CLRF   x6B
0CBEC:  CLRF   x6C
0CBEE:  CLRF   x6D
0CBF0:  CLRF   x6E
0CBF2:  CLRF   x6F
0CBF4:  CLRF   x70
0CBF6:  CLRF   x71
0CBF8:  CLRF   x72
0CBFA:  CLRF   x73
0CBFC:  CLRF   x74
0CBFE:  CLRF   x75
0CC00:  CLRF   x76
0CC02:  CLRF   x77
0CC04:  CLRF   x78
0CC06:  CLRF   x79
0CC08:  CLRF   x7A
0CC0A:  CLRF   x7B
0CC0C:  CLRF   x7C
0CC0E:  CLRF   x7D
0CC10:  CLRF   x7E
0CC12:  CLRF   x7F
0CC14:  CLRF   x80
0CC16:  CLRF   x81
0CC18:  CLRF   x82
0CC1A:  CLRF   x83
0CC1C:  CLRF   x84
0CC1E:  CLRF   x85
0CC20:  CLRF   x86
0CC22:  CLRF   x87
0CC24:  CLRF   x88
0CC26:  CLRF   x89
0CC28:  CLRF   x8A
0CC2A:  CLRF   x8B
0CC2C:  CLRF   x8C
0CC2E:  CLRF   x8D
0CC30:  CLRF   x8E
0CC32:  CLRF   x8F
0CC34:  CLRF   x90
0CC36:  CLRF   x91
0CC38:  CLRF   x92
0CC3A:  CLRF   x93
0CC3C:  CLRF   x94
0CC3E:  CLRF   x95
0CC40:  CLRF   x96
0CC42:  CLRF   x97
0CC44:  CLRF   x98
0CC46:  CLRF   x99
0CC48:  CLRF   x9A
0CC4A:  CLRF   x9B
0CC4C:  CLRF   x9C
0CC4E:  CLRF   x9D
0CC50:  CLRF   x9E
0CC52:  CLRF   x9F
0CC54:  CLRF   xA0
0CC56:  CLRF   xA1
0CC58:  CLRF   xA2
0CC5A:  CLRF   xA3
0CC5C:  CLRF   xA4
0CC5E:  CLRF   xA5
0CC60:  CLRF   xA6
0CC62:  CLRF   xA7
0CC64:  CLRF   xA8
0CC66:  CLRF   xA9
0CC68:  CLRF   xAA
0CC6A:  CLRF   xAB
0CC6C:  CLRF   xAC
0CC6E:  CLRF   xAD
0CC70:  CLRF   xAE
0CC72:  CLRF   xAF
0CC74:  CLRF   xB0
0CC76:  CLRF   xB1
0CC78:  CLRF   xB2
0CC7A:  CLRF   xB3
0CC7C:  CLRF   xB4
0CC7E:  CLRF   xB5
0CC80:  CLRF   xB6
0CC82:  CLRF   xB7
0CC84:  CLRF   xB8
0CC86:  CLRF   xB9
0CC88:  CLRF   xBA
0CC8A:  CLRF   xBB
0CC8C:  CLRF   xBC
0CC8E:  CLRF   xBD
0CC90:  CLRF   xBE
0CC92:  CLRF   xBF
0CC94:  CLRF   xC0
0CC96:  CLRF   xC1
0CC98:  CLRF   xC2
0CC9A:  CLRF   xC3
0CC9C:  CLRF   xC4
0CC9E:  CLRF   xC5
0CCA0:  CLRF   xC6
0CCA2:  CLRF   xC7
0CCA4:  CLRF   xC8
0CCA6:  CLRF   xC9
0CCA8:  CLRF   xCA
0CCAA:  CLRF   xCB
0CCAC:  CLRF   xCC
0CCAE:  CLRF   xCD
0CCB0:  CLRF   xCE
0CCB2:  CLRF   xCF
0CCB4:  CLRF   xD0
0CCB6:  CLRF   xD1
0CCB8:  CLRF   xD2
0CCBA:  CLRF   xD3
0CCBC:  CLRF   xD4
0CCBE:  CLRF   xD5
0CCC0:  CLRF   xD6
0CCC2:  CLRF   xD7
0CCC4:  CLRF   xD8
0CCC6:  CLRF   xD9
0CCC8:  CLRF   xDA
0CCCA:  CLRF   xDB
0CCCC:  CLRF   xDC
0CCCE:  CLRF   xDD
0CCD0:  CLRF   xDE
0CCD2:  CLRF   xDF
0CCD4:  CLRF   xE0
0CCD6:  CLRF   xE1
0CCD8:  CLRF   xE2
0CCDA:  CLRF   xE3
0CCDC:  CLRF   xE4
0CCDE:  CLRF   xE5
0CCE0:  CLRF   xE6
0CCE2:  CLRF   xE7
0CCE4:  CLRF   xE8
0CCE6:  CLRF   xE9
0CCE8:  CLRF   xEA
0CCEA:  CLRF   xEB
0CCEC:  CLRF   xEC
0CCEE:  CLRF   xED
0CCF0:  CLRF   xEE
0CCF2:  CLRF   xEF
0CCF4:  CLRF   xF0
0CCF6:  CLRF   xF1
0CCF8:  CLRF   xF2
0CCFA:  CLRF   xF3
0CCFC:  CLRF   xF4
0CCFE:  CLRF   xF5
0CD00:  CLRF   xF6
0CD02:  CLRF   xF7
0CD04:  CLRF   xF8
0CD06:  CLRF   xF9
0CD08:  CLRF   xFA
0CD0A:  CLRF   xFB
0CD0C:  CLRF   xFC
0CD0E:  CLRF   xFD
0CD10:  CLRF   xFE
0CD12:  CLRF   xFF
0CD14:  MOVLB  1
0CD16:  CLRF   x00
0CD18:  CLRF   x01
0CD1A:  CLRF   x02
0CD1C:  CLRF   x03
0CD1E:  CLRF   x04
0CD20:  CLRF   x05
0CD22:  CLRF   x06
0CD24:  CLRF   x07
0CD26:  CLRF   x08
0CD28:  CLRF   x09
0CD2A:  CLRF   x0A
0CD2C:  CLRF   x0B
0CD2E:  CLRF   x0C
0CD30:  CLRF   x0D
0CD32:  CLRF   x0E
0CD34:  CLRF   x0F
0CD36:  CLRF   x10
0CD38:  CLRF   x11
0CD3A:  CLRF   x12
0CD3C:  CLRF   x13
0CD3E:  MOVLW  05
0CD40:  MOVWF  x14
0CD42:  MOVLW  7C
0CD44:  MOVWF  x15
0CD46:  MOVLW  01
0CD48:  MOVWF  x16
0CD4A:  MOVLW  01
0CD4C:  MOVWF  x17
0CD4E:  MOVLW  02
0CD50:  MOVWF  x18
0CD52:  MOVLW  7C
0CD54:  MOVWF  x19
0CD56:  CLRF   x1A
0CD58:  MOVLW  09
0CD5A:  MOVWF  x1B
0CD5C:  MOVLW  01
0CD5E:  MOVWF  x1C
0CD60:  CLRF   x1D
0CD62:  MOVLW  02
0CD64:  MOVWF  x1E
0CD66:  MOVLW  01
0CD68:  MOVWF  x1F
0CD6A:  CLRF   x20
0CD6C:  CLRF   x21
0CD6E:  CLRF   x38
0CD70:  CLRF   x39
0CD72:  CLRF   x3A
0CD74:  CLRF   x3B
0CD76:  CLRF   x3C
0CD78:  CLRF   x3D
0CD7A:  CLRF   x3E
0CD7C:  CLRF   x3F
0CD7E:  CLRF   x40
0CD80:  CLRF   x41
0CD82:  CLRF   x42
0CD84:  CLRF   x43
0CD86:  CLRF   x44
0CD88:  CLRF   x45
0CD8A:  CLRF   x46
0CD8C:  CLRF   x47
0CD8E:  CLRF   x48
0CD90:  CLRF   x49
0CD92:  CLRF   x4A
0CD94:  CLRF   x4B
0CD96:  CLRF   x4C
0CD98:  CLRF   x4D
0CD9A:  CLRF   x4E
0CD9C:  CLRF   x4F
0CD9E:  CLRF   x50
0CDA0:  CLRF   x51
0CDA2:  CLRF   x52
0CDA4:  CLRF   x53
0CDA6:  CLRF   x54
0CDA8:  CLRF   x55
0CDAA:  CLRF   x56
0CDAC:  CLRF   x57
0CDAE:  CLRF   x58
0CDB0:  CLRF   x59
0CDB2:  CLRF   x5A
0CDB4:  CLRF   x5B
0CDB6:  CLRF   x5C
0CDB8:  CLRF   x5D
0CDBA:  CLRF   x5E
0CDBC:  CLRF   x5F
0CDBE:  CLRF   x60
0CDC0:  CLRF   x61
0CDC2:  CLRF   x62
0CDC4:  CLRF   x63
0CDC6:  CLRF   x64
0CDC8:  CLRF   x65
0CDCA:  CLRF   x66
0CDCC:  CLRF   x67
0CDCE:  CLRF   x68
0CDD0:  MOVLW  01
0CDD2:  MOVWF  x69
0CDD4:  CLRF   x6A
0CDD6:  CLRF   x6B
0CDD8:  CLRF   x6C
0CDDA:  CLRF   x6D
0CDDC:  CLRF   x6E
0CDDE:  CLRF   x6F
0CDE0:  CLRF   x70
0CDE2:  CLRF   x71
0CDE4:  CLRF   x72
0CDE6:  CLRF   x73
0CDE8:  MOVLW  02
0CDEA:  MOVWF  x74
0CDEC:  CLRF   x75
0CDEE:  CLRF   x76
0CDF0:  CLRF   x77
0CDF2:  CLRF   x78
0CDF4:  CLRF   x79
0CDF6:  CLRF   x7A
0CDF8:  CLRF   x7B
0CDFA:  CLRF   x7C
0CDFC:  CLRF   x7D
0CDFE:  CLRF   x7E
0CE00:  MOVLW  03
0CE02:  MOVWF  x7F
0CE04:  CLRF   x80
0CE06:  CLRF   x81
0CE08:  CLRF   x82
0CE0A:  CLRF   x83
0CE0C:  CLRF   x84
0CE0E:  CLRF   x85
0CE10:  CLRF   x86
0CE12:  CLRF   x87
0CE14:  CLRF   x88
0CE16:  CLRF   x89
0CE18:  MOVLW  04
0CE1A:  MOVWF  x8A
0CE1C:  CLRF   x8B
0CE1E:  CLRF   x8C
0CE20:  CLRF   x8D
0CE22:  CLRF   x8E
0CE24:  CLRF   x8F
0CE26:  CLRF   x90
0CE28:  CLRF   x91
0CE2A:  CLRF   x92
0CE2C:  CLRF   x93
0CE2E:  CLRF   x94
0CE30:  MOVLW  05
0CE32:  MOVWF  x95
0CE34:  CLRF   x96
0CE36:  CLRF   x97
0CE38:  CLRF   x98
0CE3A:  CLRF   x99
0CE3C:  CLRF   x9A
0CE3E:  CLRF   x9B
0CE40:  CLRF   x9C
0CE42:  CLRF   x9D
0CE44:  CLRF   x9E
0CE46:  CLRF   x9F
0CE48:  MOVLW  06
0CE4A:  MOVWF  xA0
0CE4C:  CLRF   xA1
0CE4E:  CLRF   xA2
0CE50:  CLRF   xA3
0CE52:  CLRF   xA4
0CE54:  CLRF   xA5
0CE56:  CLRF   xA6
0CE58:  CLRF   xA7
0CE5A:  CLRF   xA8
0CE5C:  CLRF   xA9
0CE5E:  CLRF   xAA
0CE60:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0CE62:  MOVLW  64
0CE64:  MOVLB  A
0CE66:  MOVWF  xA3
0CE68:  MOVLB  0
0CE6A:  CALL   1BC8
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0CE6E:  MOVLW  6A
0CE70:  MOVWF  FF6
0CE72:  MOVLW  1A
0CE74:  MOVWF  FF7
0CE76:  MOVLW  00
0CE78:  MOVWF  FF8
0CE7A:  CALL   1BF6
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0CE7E:  MOVLW  B0
0CE80:  MOVWF  FF6
0CE82:  MOVLW  1A
0CE84:  MOVWF  FF7
0CE86:  MOVLW  00
0CE88:  MOVWF  FF8
0CE8A:  CALL   1BF6
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0CE8E:  MOVLW  DE
0CE90:  MOVWF  FF6
0CE92:  MOVLW  1A
0CE94:  MOVWF  FF7
0CE96:  MOVLW  00
0CE98:  MOVWF  FF8
0CE9A:  MOVLW  10
0CE9C:  MOVLB  9
0CE9E:  MOVWF  xE9
0CEA0:  MOVLB  0
0CEA2:  CALL   1C2C
0CEA6:  MOVLW  04
0CEA8:  MOVWF  FF6
0CEAA:  MOVLW  1B
0CEAC:  MOVWF  FF7
0CEAE:  MOVLW  00
0CEB0:  MOVWF  FF8
0CEB2:  CALL   1BF6
0CEB6:  MOVLW  20
0CEB8:  BTFSS  FA6.6
0CEBA:  GOTO   CEB8
0CEBE:  MOVLB  E
0CEC0:  MOVWF  xF9
0CEC2:  MOVLW  0E
0CEC4:  MOVWF  FF6
0CEC6:  MOVLW  1B
0CEC8:  MOVWF  FF7
0CECA:  MOVLW  00
0CECC:  MOVWF  FF8
0CECE:  MOVLB  0
0CED0:  CALL   1BF6
0CED4:  MOVLW  F3
0CED6:  MOVWF  FF6
0CED8:  MOVLW  1A
0CEDA:  MOVWF  FF7
0CEDC:  MOVLW  00
0CEDE:  MOVWF  FF8
0CEE0:  MOVLW  0F
0CEE2:  MOVLB  9
0CEE4:  MOVWF  xE9
0CEE6:  MOVLB  0
0CEE8:  CALL   1C2C
....................    
....................    // io_init();
....................    setup_uart_to_boss();
0CEEC:  GOTO   1C66
....................    timer_init();
0CEF0:  GOTO   1C90
....................    ad7490_init();
0CEF4:  GOTO   1EB8
....................    mcp4901_init();
0CEF8:  GOTO   2198
....................    misf_init();
0CEFC:  CALL   32FC
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0CF00:  MOVLB  2
0CF02:  CLRF   x14
0CF04:  CLRF   x15
0CF06:  MOVLB  0
0CF08:  CALL   49C2
.................... 
....................    int1 is_finished = FALSE;
0CF0C:  MOVLB  1
0CF0E:  BCF    xAB.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0CF10:  MOVLW  18
0CF12:  MOVWF  FF6
0CF14:  MOVLW  1B
0CF16:  MOVWF  FF7
0CF18:  MOVLW  00
0CF1A:  MOVWF  FF8
0CF1C:  MOVLB  0
0CF1E:  CALL   1BF6
....................    
....................    enable_negative_power();
0CF22:  GOTO   4CF2
....................    connect_port1();
0CF26:  CALL   4CFC
....................    connect_port2();
0CF2A:  CALL   4D04
....................    mcp4901_1_write(0);
0CF2E:  MOVLB  9
0CF30:  CLRF   xEA
0CF32:  CLRF   xE9
0CF34:  MOVLB  0
0CF36:  CALL   2114
....................    mcp4901_2_write(0);
0CF3A:  MOVLB  9
0CF3C:  CLRF   xEA
0CF3E:  CLRF   xE9
0CF40:  MOVLB  0
0CF42:  CALL   2156
....................     
....................    
....................    fprintf(PC,"waiting for BOSS PIC command");
0CF46:  MOVLW  3E
0CF48:  MOVWF  FF6
0CF4A:  MOVLW  1B
0CF4C:  MOVWF  FF7
0CF4E:  MOVLW  00
0CF50:  MOVWF  FF8
0CF52:  CALL   1BF6
....................    
....................    //Start loop
....................    while(!is_finished)
0CF56:  MOVLB  1
0CF58:  BTFSS  xAB.0
0CF5A:  BRA    CF62
0CF5C:  MOVLB  0
0CF5E:  GOTO   D034
0CF62:  MOVLB  0
....................    {
....................       // unsigned int16 cigs1_amp = ad7490_read(ADC_CIGS2_AMP);
....................       // unsigned int16 cigs1_curr = ad7490_read(ADC_CIGS2_CURR);
....................       // unsigned int16 cigs1_volt = ad7490_read(ADC_CIGS2_VOLT);
....................       
....................       // fprintf(PC, "CIGS1 Amp: %04LX, Current: %04LX, Voltage: %04LX\r\n", cigs1_amp, cigs1_curr, cigs1_volt);
....................       
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0CF64:  MOVF   4A,F
0CF66:  BTFSC  FD8.2
0CF68:  GOTO   CFEC
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0CF6C:  MOVLB  1
0CF6E:  CLRF   xBF
0CF70:  MOVLW  2A
0CF72:  MOVWF  xBE
0CF74:  MOVFF  4A,1C0
0CF78:  MOVLB  0
0CF7A:  GOTO   5024
0CF7E:  MOVFF  02,03
0CF82:  MOVF   01,W
0CF84:  MOVWF  FE1
0CF86:  MOVFF  03,FE2
0CF8A:  MOVLW  01
0CF8C:  MOVWF  FEA
0CF8E:  MOVLW  AC
0CF90:  MOVWF  FE9
0CF92:  MOVLW  0C
0CF94:  MOVWF  01
0CF96:  MOVFF  FE6,FEE
0CF9A:  DECFSZ 01,F
0CF9C:  GOTO   CF96
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0CFA0:  MOVLB  1
0CFA2:  CLRF   xB9
0CFA4:  MOVLW  2A
0CFA6:  MOVWF  xB8
0CFA8:  CLRF   xBB
0CFAA:  MOVLW  4A
0CFAC:  MOVWF  xBA
0CFAE:  MOVLB  0
0CFB0:  GOTO   5226
....................          
....................          if(recieve_cmd.is_exist)
0CFB4:  MOVLB  1
0CFB6:  BTFSC  xAE.0
0CFB8:  BRA    CFC0
0CFBA:  MOVLB  0
0CFBC:  GOTO   CFDC
0CFC0:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0CFC2:  MOVLW  01
0CFC4:  MOVLB  1
0CFC6:  MOVWF  xB9
0CFC8:  MOVLW  AC
0CFCA:  MOVWF  xB8
0CFCC:  MOVLB  0
0CFCE:  GOTO   C9D4
0CFD2:  MOVLB  1
0CFD4:  BCF    xAB.1
0CFD6:  BTFSC  01.0
0CFD8:  BSF    xAB.1
0CFDA:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0CFDC:  MOVLW  5C
0CFDE:  MOVWF  FF6
0CFE0:  MOVLW  1B
0CFE2:  MOVWF  FF7
0CFE4:  MOVLW  00
0CFE6:  MOVWF  FF8
0CFE8:  CALL   1BF6
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0CFEC:  MOVLB  1
0CFEE:  BTFSC  xAB.0
0CFF0:  BRA    CFF8
0CFF2:  MOVLB  0
0CFF4:  GOTO   CFFE
0CFF8:  MOVLB  0
....................          break;
0CFFA:  GOTO   D034
....................          
....................       delay_ms(400);
0CFFE:  MOVLW  02
0D000:  MOVLB  1
0D002:  MOVWF  xB8
0D004:  MOVLB  0
0D006:  MOVLW  C8
0D008:  MOVLB  A
0D00A:  MOVWF  xA3
0D00C:  MOVLB  0
0D00E:  CALL   1BC8
0D012:  MOVLB  1
0D014:  DECFSZ xB8,F
0D016:  BRA    D01C
0D018:  BRA    D020
0D01A:  MOVLB  0
0D01C:  MOVLB  0
0D01E:  BRA    D006
....................       fprintf(PC, ".");
0D020:  MOVLW  2E
0D022:  MOVLB  0
0D024:  BTFSS  FA6.6
0D026:  GOTO   D024
0D02A:  MOVLB  E
0D02C:  MOVWF  xF9
0D02E:  MOVLB  0
0D030:  GOTO   CF56
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0D034:  MOVLW  7C
0D036:  MOVWF  FF6
0D038:  MOVLW  1B
0D03A:  MOVWF  FF7
0D03C:  MOVLW  00
0D03E:  MOVWF  FF8
0D040:  CALL   1BF6
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0D044:  MOVLW  2E
0D046:  BTFSS  FA6.6
0D048:  GOTO   D046
0D04C:  MOVLB  E
0D04E:  MOVWF  xF9
....................       delay_ms(1000);
0D050:  MOVLW  04
0D052:  MOVLB  1
0D054:  MOVWF  xB8
0D056:  MOVLB  0
0D058:  MOVLW  FA
0D05A:  MOVLB  A
0D05C:  MOVWF  xA3
0D05E:  MOVLB  0
0D060:  CALL   1BC8
0D064:  MOVLB  1
0D066:  DECFSZ xB8,F
0D068:  BRA    D06E
0D06A:  BRA    D072
0D06C:  MOVLB  0
0D06E:  MOVLB  0
0D070:  BRA    D058
0D072:  MOVLB  0
0D074:  GOTO   D044
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0D078:  MOVLW  BC
0D07A:  MOVWF  FF6
0D07C:  MOVLW  1B
0D07E:  MOVWF  FF7
0D080:  MOVLW  00
0D082:  MOVWF  FF8
0D084:  CALL   1BF6
....................    
.................... }
.................... // Enf of files
0D088:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
