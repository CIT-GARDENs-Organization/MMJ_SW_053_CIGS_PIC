CCS PCM C Compiler, Version 5.104, 57077               04-6-25 17:34

               Filename:   build\mmj_cigs_main.lst

               ROM used:   5632 words (34%)
                           Largest free fragment is 2048
               RAM used:   1315 (64%) at main() level
                           1394 (68%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 16

*
0000:  MOVLP  08
0001:  GOTO   53A
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  MOVLB  03
0010:  MOVF   11,W
0011:  MOVLB  00
0012:  MOVWF  24
0013:  MOVLB  03
0014:  MOVF   12,W
0015:  MOVLB  00
0016:  MOVWF  25
0017:  MOVLB  03
0018:  MOVF   13,W
0019:  MOVLB  00
001A:  MOVWF  26
001B:  MOVLB  03
001C:  MOVF   14,W
001D:  MOVLB  00
001E:  MOVWF  27
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   043
0023:  CLRF   05
0024:  MOVLW  91
0025:  MOVWF  04
0026:  BTFSS  00.5
0027:  GOTO   02A
0028:  BTFSC  11.5
0029:  GOTO   045
002A:  MOVF   20,W
002B:  MOVWF  77
002C:  MOVF   21,W
002D:  MOVWF  78
002E:  MOVF   22,W
002F:  MOVWF  79
0030:  MOVF   23,W
0031:  MOVWF  7A
0032:  MOVF   24,W
0033:  MOVLB  03
0034:  MOVWF  11
0035:  MOVLB  00
0036:  MOVF   25,W
0037:  MOVLB  03
0038:  MOVWF  12
0039:  MOVLB  00
003A:  MOVF   26,W
003B:  MOVLB  03
003C:  MOVWF  13
003D:  MOVLB  00
003E:  MOVF   27,W
003F:  MOVLB  03
0040:  MOVWF  14
0041:  RETFIE
0042:  MOVLB  00
0043:  MOVLP  00
0044:  GOTO   047
0045:  MOVLP  00
0046:  GOTO   09D
.................... #include "include/mmj_cigs_main.h"
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... 
.................... 
.................... // pin assignment etc
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... #include <16F1789.h>
.................... //////////// Standard Header file for the PIC16F1789 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1789
*
008D:  DATA D4,34
008E:  DATA ED,32
008F:  DATA 72,10
0090:  DATA 49,37
0091:  DATA 69,3A
0092:  DATA E9,30
0093:  DATA EC,34
0094:  DATA FA,32
0095:  DATA 0D,05
0096:  DATA 00,00
0097:  DATA 89,21
0098:  DATA EF,36
0099:  DATA 70,36
009A:  DATA 65,3A
009B:  DATA E5,06
009C:  DATA 0A,00
*
00BD:  DATA D5,20
00BE:  DATA 52,2A
00BF:  DATA A0,24
00C0:  DATA EE,34
00C1:  DATA F4,34
00C2:  DATA 61,36
00C3:  DATA 69,3D
00C4:  DATA E5,06
00C5:  DATA 0A,00
00C6:  DATA 89,21
00C7:  DATA EF,36
00C8:  DATA 70,36
00C9:  DATA 65,3A
00CA:  DATA E5,06
00CB:  DATA 0A,00
00CC:  DATA 0D,05
00CD:  DATA 09,1E
00CE:  DATA 2D,00
00CF:  DATA 66,36
00D0:  DATA E1,39
00D1:  DATA 68,10
00D2:  DATA E2,3A
00D3:  DATA F3,3C
00D4:  DATA 0D,05
00D5:  DATA 00,00
00D6:  DATA 09,29
00D7:  DATA E5,30
00D8:  DATA 64,10
00D9:  DATA 49,22
00DA:  DATA 3A,00
00DB:  DATA 09,33
00DC:  DATA EC,30
00DD:  DATA 73,34
00DE:  DATA A0,31
00DF:  DATA 6F,37
00E0:  DATA EE,32
00E1:  DATA 63,3A
00E2:  DATA A0,27
00E3:  DATA CB,06
00E4:  DATA 0A,00
00E5:  DATA 09,33
00E6:  DATA EC,30
00E7:  DATA 73,34
00E8:  DATA 20,37
00E9:  DATA 6F,3A
00EA:  DATA A0,31
00EB:  DATA 6F,37
00EC:  DATA EE,32
00ED:  DATA 63,3A
00EE:  DATA 0D,05
00EF:  DATA 00,00
00F0:  DATA 65,39
00F1:  DATA F2,37
00F2:  DATA 72,1D
00F3:  DATA 66,36
00F4:  DATA E1,39
00F5:  DATA 68,10
00F6:  DATA ED,37
00F7:  DATA E4,32
00F8:  DATA 6C,10
00F9:  DATA E9,39
00FA:  DATA A0,34
00FB:  DATA 6E,3B
00FC:  DATA 61,36
00FD:  DATA 69,32
00FE:  DATA 0D,05
00FF:  DATA 00,01
0100:  DATA 66,36
0101:  DATA E1,39
0102:  DATA 68,10
0103:  DATA F4,34
0104:  DATA ED,32
0105:  DATA EF,3A
0106:  DATA F4,06
0107:  DATA 0A,00
0108:  DATA 66,36
0109:  DATA E1,39
010A:  DATA 68,10
010B:  DATA F3,32
010C:  DATA 63,3A
010D:  DATA 6F,39
010E:  DATA A0,32
010F:  DATA F2,30
0110:  DATA F3,32
0111:  DATA A0,31
0112:  DATA EF,36
0113:  DATA 70,36
0114:  DATA 65,3A
0115:  DATA E5,06
0116:  DATA 0A,00
0117:  DATA 65,39
0118:  DATA F2,37
0119:  DATA 72,1D
011A:  DATA 66,36
011B:  DATA E1,39
011C:  DATA 68,10
011D:  DATA ED,37
011E:  DATA E4,32
011F:  DATA 6C,10
0120:  DATA E9,39
0121:  DATA A0,34
0122:  DATA 6E,3B
0123:  DATA 61,36
0124:  DATA 69,32
0125:  DATA 0D,05
0126:  DATA 00,01
0127:  DATA 66,36
0128:  DATA E1,39
0129:  DATA 68,10
012A:  DATA F4,34
012B:  DATA ED,32
012C:  DATA EF,3A
012D:  DATA F4,06
012E:  DATA 0A,00
012F:  DATA 66,36
0130:  DATA E1,39
0131:  DATA 68,10
0132:  DATA 33,19
0133:  DATA 6B,21
0134:  DATA 79,3A
0135:  DATA 65,10
0136:  DATA F3,3A
0137:  DATA E2,39
0138:  DATA E5,31
0139:  DATA F4,37
013A:  DATA 72,10
013B:  DATA 65,39
013C:  DATA E1,39
013D:  DATA 65,10
013E:  DATA E3,37
013F:  DATA 6D,38
0140:  DATA EC,32
0141:  DATA F4,32
0142:  DATA 0D,05
0143:  DATA 00,00
0144:  DATA 65,39
0145:  DATA F2,37
0146:  DATA 72,1D
0147:  DATA 66,36
0148:  DATA E1,39
0149:  DATA 68,10
014A:  DATA ED,37
014B:  DATA E4,32
014C:  DATA 6C,10
014D:  DATA E9,39
014E:  DATA A0,34
014F:  DATA 6E,3B
0150:  DATA 61,36
0151:  DATA 69,32
0152:  DATA 0D,05
0153:  DATA 00,01
0154:  DATA 66,36
0155:  DATA E1,39
0156:  DATA 68,10
0157:  DATA F4,34
0158:  DATA ED,32
0159:  DATA EF,3A
015A:  DATA F4,06
015B:  DATA 0A,00
015C:  DATA 66,36
015D:  DATA E1,39
015E:  DATA 68,10
015F:  DATA B4,35
0160:  DATA C2,3C
0161:  DATA F4,32
0162:  DATA A0,39
0163:  DATA 75,31
0164:  DATA F3,32
0165:  DATA 63,3A
0166:  DATA 6F,39
0167:  DATA A0,32
0168:  DATA F2,30
0169:  DATA F3,32
016A:  DATA A0,31
016B:  DATA EF,36
016C:  DATA 70,36
016D:  DATA 65,3A
016E:  DATA E5,06
016F:  DATA 0A,00
0170:  DATA 66,36
0171:  DATA E1,39
0172:  DATA 68,10
0173:  DATA F4,34
0174:  DATA ED,32
0175:  DATA EF,3A
0176:  DATA F4,06
0177:  DATA 0A,00
0178:  DATA 66,36
0179:  DATA E1,39
017A:  DATA 68,10
017B:  DATA 77,39
017C:  DATA 69,3A
017D:  DATA 65,10
017E:  DATA E3,37
017F:  DATA 6D,38
0180:  DATA EC,32
0181:  DATA F4,32
0182:  DATA 0D,05
0183:  DATA 00,00
0184:  DATA 66,36
0185:  DATA E1,39
0186:  DATA 68,10
0187:  DATA F4,34
0188:  DATA ED,32
0189:  DATA EF,3A
018A:  DATA F4,06
018B:  DATA 0A,00
018C:  DATA 66,36
018D:  DATA E1,39
018E:  DATA 68,10
018F:  DATA 77,39
0190:  DATA 69,3A
0191:  DATA 65,10
0192:  DATA E3,37
0193:  DATA 6D,38
0194:  DATA EC,32
0195:  DATA F4,32
0196:  DATA 0D,05
0197:  DATA 00,00
0198:  DATA 46,36
0199:  DATA E1,39
019A:  DATA 68,10
019B:  DATA 49,37
019C:  DATA 69,3A
019D:  DATA E9,30
019E:  DATA EC,34
019F:  DATA FA,32
01A0:  DATA 0D,05
01A1:  DATA 00,01
01A2:  DATA 0D,05
01A3:  DATA 89,21
01A4:  DATA EF,36
01A5:  DATA 70,36
01A6:  DATA 65,3A
01A7:  DATA E5,06
01A8:  DATA 0A,00
01A9:  DATA 89,2D
01AA:  DATA CD,24
01AB:  DATA 53,23
01AC:  DATA 5D,10
01AD:  DATA C3,37
01AE:  DATA 6E,37
01AF:  DATA E5,31
01B0:  DATA 74,10
01B1:  DATA F3,3A
01B2:  DATA E3,31
01B3:  DATA E5,39
01B4:  DATA 73,17
01B5:  DATA 0D,05
01B6:  DATA 00,01
01B7:  DATA 89,2D
01B8:  DATA CD,24
01B9:  DATA 53,23
01BA:  DATA 5D,10
01BB:  DATA BC,16
01BC:  DATA A0,1C
01BD:  DATA C6,06
01BE:  DATA 0A,00
01BF:  DATA 89,2D
01C0:  DATA CD,24
01C1:  DATA 53,23
01C2:  DATA 5D,10
01C3:  DATA 2D,1F
01C4:  DATA 20,00
01C5:  DATA 89,2D
01C6:  DATA CD,24
01C7:  DATA 53,23
01C8:  DATA 5D,10
01C9:  DATA CD,22
01CA:  DATA CD,27
01CB:  DATA D2,2C
01CC:  DATA DF,21
01CD:  DATA 41,28
01CE:  DATA C1,21
01CF:  DATA 49,2A
01D0:  DATA 59,10
01D1:  DATA 65,39
01D2:  DATA F2,37
01D3:  DATA F2,10
01D4:  DATA 20,2A
01D5:  DATA E8,34
01D6:  DATA 73,10
01D7:  DATA E9,39
01D8:  DATA A0,29
01D9:  DATA 4D,23
01DA:  DATA 0D,05
01DB:  DATA 00,01
01DC:  DATA 89,2D
01DD:  DATA CD,24
01DE:  DATA 53,23
01DF:  DATA 5D,10
01E0:  DATA BC,16
01E1:  DATA A0,1C
01E2:  DATA C6,06
01E3:  DATA 0A,00
01E4:  DATA 89,2D
01E5:  DATA CD,24
01E6:  DATA 53,23
01E7:  DATA 5D,10
01E8:  DATA 2D,1F
01E9:  DATA 20,00
01EA:  DATA 0D,05
01EB:  DATA 89,2D
01EC:  DATA CD,24
01ED:  DATA 53,23
01EE:  DATA 5D,10
01EF:  DATA CD,22
01F0:  DATA CD,27
01F1:  DATA D2,2C
01F2:  DATA DF,21
01F3:  DATA 41,28
01F4:  DATA C1,21
01F5:  DATA 49,2A
01F6:  DATA 59,10
01F7:  DATA 65,39
01F8:  DATA F2,37
01F9:  DATA F2,10
01FA:  DATA A0,21
01FB:  DATA E8,34
01FC:  DATA 70,10
01FD:  DATA 49,22
01FE:  DATA A0,34
01FF:  DATA 73,10
0200:  DATA 69,37
0201:  DATA F6,30
0202:  DATA EC,34
0203:  DATA E4,06
0204:  DATA 0A,00
0205:  DATA 89,2D
0206:  DATA CD,24
0207:  DATA 53,23
0208:  DATA 5D,10
0209:  DATA BC,16
020A:  DATA A0,1C
020B:  DATA C6,06
020C:  DATA 0A,00
020D:  DATA 89,2D
020E:  DATA CD,24
020F:  DATA 53,23
0210:  DATA 5D,10
0211:  DATA 2D,1F
0212:  DATA 20,00
0213:  DATA 0D,05
0214:  DATA 89,2D
0215:  DATA CD,24
0216:  DATA 53,23
0217:  DATA 5D,10
0218:  DATA 43,34
0219:  DATA 69,38
021A:  DATA A0,24
021B:  DATA 44,10
021C:  DATA E9,39
021D:  DATA A0,34
021E:  DATA 6E,3B
021F:  DATA 61,36
0220:  DATA 69,32
0221:  DATA 0D,05
0222:  DATA 00,00
0223:  DATA D0,24
0224:  DATA 43,26
0225:  DATA CF,23
0226:  DATA 20,32
0227:  DATA 61,3A
0228:  DATA 61,10
0229:  DATA 77,39
022A:  DATA 69,3A
022B:  DATA F4,32
022C:  DATA 6E,1D
022D:  DATA 20,23
022E:  DATA 75,37
022F:  DATA 63,3A
0230:  DATA E9,37
0231:  DATA 6E,10
0232:  DATA 25,32
0233:  DATA 2C,10
0234:  DATA D0,30
0235:  DATA F2,30
0236:  DATA ED,32
0237:  DATA F4,32
0238:  DATA 72,10
0239:  DATA 25,32
023A:  DATA 0D,05
023B:  DATA 00,00
023C:  DATA D0,24
023D:  DATA 43,26
023E:  DATA CF,23
023F:  DATA 20,32
0240:  DATA 61,3A
0241:  DATA 61,10
0242:  DATA 77,39
0243:  DATA 69,3A
0244:  DATA F4,32
0245:  DATA 6E,10
0246:  DATA F3,3A
0247:  DATA E3,31
0248:  DATA E5,39
0249:  DATA 73,33
024A:  DATA 75,36
024B:  DATA EC,3C
024C:  DATA 0D,05
024D:  DATA 00,00
024E:  DATA C9,27
024F:  DATA A0,24
0250:  DATA EE,34
0251:  DATA F4,34
0252:  DATA 61,36
0253:  DATA 69,3D
0254:  DATA E5,06
0255:  DATA 0A,00
0256:  DATA 89,21
0257:  DATA EF,36
0258:  DATA 70,36
0259:  DATA 65,3A
025A:  DATA E5,06
025B:  DATA 0A,00
025C:  DATA 41,22
025D:  DATA 43,10
025E:  DATA 49,37
025F:  DATA 69,3A
0260:  DATA E9,30
0261:  DATA EC,34
0262:  DATA FA,32
0263:  DATA 0D,05
0264:  DATA 00,01
0265:  DATA 89,21
0266:  DATA EF,36
0267:  DATA 70,36
0268:  DATA 65,3A
0269:  DATA E5,06
026A:  DATA 0A,00
026B:  DATA 53,3A
026C:  DATA 61,39
026D:  DATA 74,10
026E:  DATA D3,2B
026F:  DATA C5,22
0270:  DATA D0,06
0271:  DATA 0A,00
0272:  DATA 89,29
0273:  DATA F7,32
0274:  DATA 65,38
0275:  DATA A0,39
0276:  DATA F4,32
0277:  DATA 70,10
0278:  DATA 3A,10
0279:  DATA A5,3A
027A:  DATA 0D,05
027B:  DATA 00,01
027C:  DATA 45,27
027D:  DATA 44,10
027E:  DATA D3,2B
027F:  DATA C5,22
0280:  DATA D0,06
0281:  DATA 0A,00
0282:  DATA CC,37
0283:  DATA E7,33
0284:  DATA 65,32
0285:  DATA A0,21
0286:  DATA C9,23
0287:  DATA 53,10
0288:  DATA E4,30
0289:  DATA F4,30
028A:  DATA 0D,05
028B:  DATA 80,00
028C:  DATA D3,26
028D:  DATA 46,10
028E:  DATA E4,30
028F:  DATA F4,30
0290:  DATA 20,36
0291:  DATA E9,39
0292:  DATA 74,10
0293:  DATA E9,39
0294:  DATA 20,33
0295:  DATA 75,36
0296:  DATA EC,10
0297:  DATA A1,10
0298:  DATA 0D,05
0299:  DATA 00,00
029A:  DATA D3,26
029B:  DATA 46,10
029C:  DATA E4,30
029D:  DATA F4,30
029E:  DATA 20,36
029F:  DATA E9,39
02A0:  DATA 74,10
02A1:  DATA E9,39
02A2:  DATA A0,32
02A3:  DATA 6D,38
02A4:  DATA F4,3C
02A5:  DATA 0D,05
02A6:  DATA 00,00
02A7:  DATA 53,3A
02A8:  DATA 61,39
02A9:  DATA 74,10
02AA:  DATA ED,30
02AB:  DATA EB,32
02AC:  DATA 5F,39
02AD:  DATA E5,31
02AE:  DATA E5,34
02AF:  DATA F6,32
02B0:  DATA DF,31
02B1:  DATA EF,36
02B2:  DATA ED,30
02B3:  DATA 6E,32
02B4:  DATA 0D,05
02B5:  DATA 89,16
02B6:  DATA 3E,10
02B7:  DATA 00,01
02B8:  DATA 45,37
02B9:  DATA 64,10
02BA:  DATA ED,30
02BB:  DATA EB,32
02BC:  DATA 5F,39
02BD:  DATA E5,31
02BE:  DATA 69,3B
02BF:  DATA E5,2F
02C0:  DATA E3,37
02C1:  DATA ED,36
02C2:  DATA 61,37
02C3:  DATA E4,06
02C4:  DATA 8A,06
02C5:  DATA 0A,00
02C6:  DATA F3,34
02C7:  DATA 67,37
02C8:  DATA 61,36
02C9:  DATA A0,32
02CA:  DATA 6E,32
02CB:  DATA A0,3B
02CC:  DATA 69,3A
02CD:  DATA 68,10
02CE:  DATA 53,23
02CF:  DATA C4,06
02D0:  DATA 0A,00
02D1:  DATA E4,37
02D2:  DATA EE,13
02D3:  DATA 74,10
02D4:  DATA E6,34
02D5:  DATA 6E,32
02D6:  DATA A0,29
02D7:  DATA 46,22
02D8:  DATA 0D,05
02D9:  DATA 00,00
02DA:  DATA 89,16
02DB:  DATA 3E,10
02DC:  DATA 49,37
02DD:  DATA F6,30
02DE:  DATA EC,34
02DF:  DATA 64,10
02E0:  DATA 46,39
02E1:  DATA E1,36
02E2:  DATA 65,10
02E3:  DATA 49,22
02E4:  DATA 20,39
02E5:  DATA E5,31
02E6:  DATA E5,34
02E7:  DATA F6,32
02E8:  DATA 64,1D
02E9:  DATA A0,12
02EA:  DATA D8,06
02EB:  DATA 0A,00
02EC:  DATA 89,16
02ED:  DATA 3E,10
02EE:  DATA 43,29
02EF:  DATA 43,10
02F0:  DATA 65,39
02F1:  DATA F2,37
02F2:  DATA F2,10
02F3:  DATA 0D,05
02F4:  DATA 00,01
02F5:  DATA 89,04
02F6:  DATA 2D,1F
02F7:  DATA 20,39
02F8:  DATA E5,31
02F9:  DATA E5,34
02FA:  DATA F6,32
02FB:  DATA 64,10
02FC:  DATA 43,29
02FD:  DATA 43,1D
02FE:  DATA A0,12
02FF:  DATA D8,06
0300:  DATA 0A,00
0301:  DATA 89,04
0302:  DATA 20,10
0303:  DATA A0,31
0304:  DATA 6F,36
0305:  DATA EC,32
0306:  DATA 63,3A
0307:  DATA A0,21
0308:  DATA D2,21
0309:  DATA 20,1D
030A:  DATA A0,12
030B:  DATA D8,06
030C:  DATA 0A,00
030D:  DATA 89,16
030E:  DATA 3E,10
030F:  DATA 49,37
0310:  DATA F6,30
0311:  DATA EC,34
0312:  DATA 64,10
0313:  DATA E4,32
0314:  DATA F6,34
0315:  DATA E3,32
0316:  DATA A0,24
0317:  DATA 44,10
0318:  DATA F2,32
0319:  DATA E3,32
031A:  DATA 69,3B
031B:  DATA 65,32
031C:  DATA 0D,05
031D:  DATA 00,01
031E:  DATA 89,04
031F:  DATA 2D,1F
0320:  DATA 20,39
0321:  DATA E5,31
0322:  DATA E5,34
0323:  DATA F6,32
0324:  DATA 64,1D
0325:  DATA 20,10
0326:  DATA 20,10
0327:  DATA A0,12
0328:  DATA D8,06
0329:  DATA 0A,00
032A:  DATA 89,04
032B:  DATA 20,10
032C:  DATA A0,26
032D:  DATA 79,10
032E:  DATA E4,32
032F:  DATA F6,34
0330:  DATA E3,32
0331:  DATA A0,24
0332:  DATA 44,1D
0333:  DATA A0,12
0334:  DATA D8,06
0335:  DATA 0A,00
0336:  DATA 54,39
0337:  DATA 61,37
0338:  DATA F3,34
0339:  DATA 74,10
033A:  DATA E3,37
033B:  DATA ED,36
033C:  DATA 61,37
033D:  DATA E4,06
033E:  DATA 8A,04
033F:  DATA 2D,1F
0340:  DATA 20,00
0341:  DATA A1,10
0342:  DATA A1,37
0343:  DATA F6,32
0344:  DATA 72,33
0345:  DATA EC,37
0346:  DATA 77,10
0347:  DATA 65,3C
0348:  DATA E5,31
0349:  DATA 75,3A
034A:  DATA 65,32
034B:  DATA DF,36
034C:  DATA E9,39
034D:  DATA F3,34
034E:  DATA 6F,37
034F:  DATA 20,36
0350:  DATA E9,39
0351:  DATA F4,06
0352:  DATA 0A,00
0353:  DATA 53,3A
0354:  DATA 61,39
0355:  DATA 74,10
0356:  DATA D3,26
0357:  DATA 46,10
0358:  DATA F5,39
0359:  DATA 69,37
035A:  DATA 67,10
035B:  DATA F2,32
035C:  DATA F1,32
035D:  DATA 73,3A
035E:  DATA A0,39
035F:  DATA E5,30
0360:  DATA F1,3A
0361:  DATA 65,37
0362:  DATA E3,32
0363:  DATA 0D,05
0364:  DATA 00,01
0365:  DATA 45,39
0366:  DATA F2,37
0367:  DATA F2,10
0368:  DATA 20,29
0369:  DATA E5,31
036A:  DATA E5,34
036B:  DATA F6,34
036C:  DATA EE,33
036D:  DATA A0,31
036E:  DATA EF,36
036F:  DATA ED,30
0370:  DATA 6E,32
0371:  DATA A0,34
0372:  DATA EE,31
0373:  DATA 6F,37
0374:  DATA F3,34
0375:  DATA 73,3A
0376:  DATA 65,37
0377:  DATA 74,10
0378:  DATA F7,34
0379:  DATA 74,34
037A:  DATA 20,3A
037B:  DATA E8,32
037C:  DATA 20,32
037D:  DATA E5,39
037E:  DATA E9,33
037F:  DATA EE,06
0380:  DATA 0A,00
0381:  DATA D3,26
0382:  DATA 46,10
0383:  DATA F5,39
0384:  DATA 65,10
0385:  DATA F2,32
0386:  DATA F1,3A
0387:  DATA E5,39
0388:  DATA 74,10
0389:  DATA 61,36
038A:  DATA EC,37
038B:  DATA F7,32
038C:  DATA E4,06
038D:  DATA 0A,00
038E:  DATA D3,26
038F:  DATA 46,10
0390:  DATA F5,39
0391:  DATA 65,10
0392:  DATA F2,32
0393:  DATA F1,3A
0394:  DATA E5,39
0395:  DATA 74,10
0396:  DATA E4,32
0397:  DATA EE,3C
0398:  DATA 65,32
0399:  DATA 0D,05
039A:  DATA 00,01
039B:  DATA D2,32
039C:  DATA 74,39
039D:  DATA 79,10
039E:  DATA F2,32
039F:  DATA F1,3A
03A0:  DATA E5,39
03A1:  DATA 74,10
03A2:  DATA F4,37
03A3:  DATA 20,21
03A4:  DATA CF,29
03A5:  DATA 53,10
03A6:  DATA D0,24
03A7:  DATA C3,06
03A8:  DATA 0A,00
03A9:  DATA 45,39
03AA:  DATA F2,37
03AB:  DATA F2,10
03AC:  DATA 20,29
03AD:  DATA E5,31
03AE:  DATA E5,34
03AF:  DATA F6,34
03B0:  DATA EE,33
03B1:  DATA A0,31
03B2:  DATA EF,36
03B3:  DATA ED,30
03B4:  DATA 6E,32
03B5:  DATA A0,34
03B6:  DATA EE,31
03B7:  DATA 6F,37
03B8:  DATA F3,34
03B9:  DATA 73,3A
03BA:  DATA 65,37
03BB:  DATA 74,10
03BC:  DATA F7,34
03BD:  DATA 74,34
03BE:  DATA 20,3A
03BF:  DATA E8,32
03C0:  DATA 20,32
03C1:  DATA E5,39
03C2:  DATA E9,33
03C3:  DATA EE,06
03C4:  DATA 0A,00
03C5:  DATA 45,37
03C6:  DATA 64,10
03C7:  DATA D3,26
03C8:  DATA 46,10
03C9:  DATA F5,39
03CA:  DATA 69,37
03CB:  DATA 67,10
03CC:  DATA F2,32
03CD:  DATA F1,32
03CE:  DATA 73,3A
03CF:  DATA A0,39
03D0:  DATA E5,30
03D1:  DATA F1,3A
03D2:  DATA 65,37
03D3:  DATA E3,32
03D4:  DATA 0D,05
03D5:  DATA 00,00
03D6:  DATA 53,3A
03D7:  DATA 61,39
03D8:  DATA 74,10
03D9:  DATA CD,27
03DA:  DATA C4,22
03DB:  DATA A0,26
03DC:  DATA C5,20
03DD:  DATA D3,2A
03DE:  DATA D2,22
03DF:  DATA 0D,05
03E0:  DATA 00,00
03E1:  DATA 53,3A
03E2:  DATA 61,39
03E3:  DATA 74,10
03E4:  DATA CD,27
03E5:  DATA C4,22
03E6:  DATA A0,26
03E7:  DATA C5,20
03E8:  DATA D3,2A
03E9:  DATA D2,22
03EA:  DATA 20,2B
03EB:  DATA 6F,36
03EC:  DATA F4,30
03ED:  DATA E7,32
03EE:  DATA 0D,05
03EF:  DATA 00,00
03F0:  DATA F4,32
03F1:  DATA 6D,38
03F2:  DATA 5F,3A
03F3:  DATA 6F,38
03F4:  DATA 3A,10
03F5:  DATA 25,2C
03F6:  DATA 0D,05
03F7:  DATA 00,01
03F8:  DATA F4,32
03F9:  DATA 6D,38
03FA:  DATA 5F,31
03FB:  DATA 6F,3A
03FC:  DATA 3A,10
03FD:  DATA 25,2C
03FE:  DATA 0D,05
03FF:  DATA 00,00
0400:  DATA 70,32
0401:  DATA 5F,3B
0402:  DATA 61,36
0403:  DATA F5,32
0404:  DATA 3A,10
0405:  DATA 25,2C
0406:  DATA 0D,05
0407:  DATA 00,00
0408:  DATA E3,34
0409:  DATA E7,39
040A:  DATA 5F,3B
040B:  DATA 61,36
040C:  DATA F5,32
040D:  DATA 3A,10
040E:  DATA 25,2C
040F:  DATA 0D,05
0410:  DATA 00,00
0411:  DATA E3,3A
0412:  DATA 72,39
0413:  DATA 65,37
0414:  DATA F4,2F
0415:  DATA F6,30
0416:  DATA EC,3A
0417:  DATA 65,1D
0418:  DATA A0,12
0419:  DATA D8,06
041A:  DATA 0A,00
041B:  DATA F6,37
041C:  DATA 6C,3A
041D:  DATA E1,33
041E:  DATA E5,2F
041F:  DATA F6,30
0420:  DATA EC,3A
0421:  DATA 65,1D
0422:  DATA A0,12
0423:  DATA D8,06
0424:  DATA 0A,00
0425:  DATA 53,3A
0426:  DATA 61,39
0427:  DATA 74,10
0428:  DATA 46,36
0429:  DATA E1,39
042A:  DATA 68,10
042B:  DATA 45,39
042C:  DATA E1,39
042D:  DATA 65,10
042E:  DATA 41,36
042F:  DATA EC,06
0430:  DATA 0A,00
0431:  DATA 45,37
0432:  DATA 64,10
0433:  DATA 46,36
0434:  DATA E1,39
0435:  DATA 68,10
0436:  DATA 45,39
0437:  DATA E1,39
0438:  DATA 65,10
0439:  DATA 41,36
043A:  DATA EC,06
043B:  DATA 0A,00
043C:  DATA 53,3A
043D:  DATA 61,39
043E:  DATA 74,10
043F:  DATA 46,36
0440:  DATA E1,39
0441:  DATA 68,10
0442:  DATA 45,39
0443:  DATA E1,39
0444:  DATA 65,10
0445:  DATA 31,10
0446:  DATA D3,32
0447:  DATA 63,3A
0448:  DATA 6F,39
0449:  DATA 0D,05
044A:  DATA 00,01
044B:  DATA 45,37
044C:  DATA 64,10
044D:  DATA 46,36
044E:  DATA E1,39
044F:  DATA 68,10
0450:  DATA 45,39
0451:  DATA E1,39
0452:  DATA 65,10
0453:  DATA 31,10
0454:  DATA D3,32
0455:  DATA 63,3A
0456:  DATA 6F,39
0457:  DATA 0D,05
0458:  DATA 00,00
0459:  DATA 53,3A
045A:  DATA 61,39
045B:  DATA 74,10
045C:  DATA 46,36
045D:  DATA E1,39
045E:  DATA 68,10
045F:  DATA C3,37
0460:  DATA F0,3C
0461:  DATA A0,18
0462:  DATA A0,29
0463:  DATA E5,31
0464:  DATA F4,37
0465:  DATA F2,06
0466:  DATA 0A,00
0467:  DATA 45,37
0468:  DATA 64,10
0469:  DATA 46,36
046A:  DATA E1,39
046B:  DATA 68,10
046C:  DATA C3,37
046D:  DATA F0,3C
046E:  DATA A0,18
046F:  DATA A0,29
0470:  DATA E5,31
0471:  DATA F4,37
0472:  DATA F2,06
0473:  DATA 0A,00
0474:  DATA C4,32
0475:  DATA 73,3A
0476:  DATA 69,37
0477:  DATA 61,3A
0478:  DATA E9,37
0479:  DATA 6E,10
047A:  DATA 61,32
047B:  DATA 64,39
047C:  DATA E5,39
047D:  DATA 73,1D
047E:  DATA A0,04
047F:  DATA 30,3C
0480:  DATA 25,18
0481:  DATA 38,26
0482:  DATA D8,06
0483:  DATA 0A,00
0484:  DATA D3,37
0485:  DATA 75,39
0486:  DATA E3,32
0487:  DATA A0,30
0488:  DATA 64,32
0489:  DATA F2,32
048A:  DATA F3,39
048B:  DATA 3A,10
048C:  DATA 09,18
048D:  DATA F8,12
048E:  DATA 30,1C
048F:  DATA 4C,2C
0490:  DATA 0D,05
0491:  DATA 00,01
0492:  DATA C4,30
0493:  DATA F4,30
0494:  DATA A0,39
0495:  DATA 69,3D
0496:  DATA 65,1D
0497:  DATA A0,04
0498:  DATA 09,10
0499:  DATA A0,12
049A:  DATA 30,1C
049B:  DATA 4C,2C
049C:  DATA 0D,05
049D:  DATA 00,01
049E:  DATA C3,37
049F:  DATA F0,3C
04A0:  DATA 69,37
04A1:  DATA 67,17
04A2:  DATA 00,01
04A3:  DATA DF,2F
04A4:  DATA DF,2F
04A5:  DATA DF,2F
04A6:  DATA DF,2F
04A7:  DATA DF,22
04A8:  DATA 6E,32
04A9:  DATA A0,31
04AA:  DATA 6F,38
04AB:  DATA F9,2F
04AC:  DATA E4,30
04AD:  DATA F4,30
04AE:  DATA DF,2F
04AF:  DATA DF,2F
04B0:  DATA DF,2F
04B1:  DATA DF,2F
04B2:  DATA DF,06
04B3:  DATA 8A,2F
04B4:  DATA DF,2F
04B5:  DATA DF,2F
04B6:  DATA DF,2F
04B7:  DATA DF,2F
04B8:  DATA DF,2F
04B9:  DATA DF,2F
04BA:  DATA DF,2F
04BB:  DATA DF,2F
04BC:  DATA DF,2F
04BD:  DATA DF,2F
04BE:  DATA DF,2F
04BF:  DATA DF,2F
04C0:  DATA DF,2F
04C1:  DATA DF,2F
04C2:  DATA DF,06
04C3:  DATA 8A,06
04C4:  DATA 0A,00
04C5:  DATA 53,3A
04C6:  DATA 61,39
04C7:  DATA 74,10
04C8:  DATA 65,3C
04C9:  DATA E5,31
04CA:  DATA 75,3A
04CB:  DATA E5,2F
04CC:  DATA E3,37
04CD:  DATA ED,36
04CE:  DATA 61,37
04CF:  DATA E4,06
04D0:  DATA 0A,00
04D1:  DATA 89,16
04D2:  DATA 3E,10
04D3:  DATA 55,38
04D4:  DATA EC,34
04D5:  DATA EE,35
04D6:  DATA A0,31
04D7:  DATA EF,36
04D8:  DATA ED,30
04D9:  DATA 6E,32
04DA:  DATA 0D,05
04DB:  DATA 00,01
04DC:  DATA 09,10
04DD:  DATA 20,10
04DE:  DATA 54,39
04DF:  DATA 61,37
04E0:  DATA F3,36
04E1:  DATA 69,3A
04E2:  DATA A0,20
04E3:  DATA E3,35
04E4:  DATA EE,37
04E5:  DATA 77,36
04E6:  DATA 65,32
04E7:  DATA E7,32
04E8:  DATA 0D,05
04E9:  DATA 00,00
04EA:  DATA 89,16
04EB:  DATA 3E,10
04EC:  DATA 53,3A
04ED:  DATA 61,3A
04EE:  DATA F5,39
04EF:  DATA A0,31
04F0:  DATA E8,32
04F1:  DATA E3,35
04F2:  DATA 0D,05
04F3:  DATA 00,01
04F4:  DATA 89,04
04F5:  DATA 2D,1F
04F6:  DATA A0,26
04F7:  DATA 79,10
04F8:  DATA 73,3A
04F9:  DATA 61,3A
04FA:  DATA F5,39
04FB:  DATA A0,34
04FC:  DATA 73,10
04FD:  DATA 25,32
04FE:  DATA 0D,05
04FF:  DATA 00,01
0500:  DATA 09,10
0501:  DATA 20,10
0502:  DATA 54,39
0503:  DATA 61,37
0504:  DATA F3,36
0505:  DATA 69,3A
0506:  DATA A0,26
0507:  DATA C9,29
0508:  DATA A0,26
0509:  DATA C3,2A
050A:  DATA A0,29
050B:  DATA F4,30
050C:  DATA F4,3A
050D:  DATA F3,06
050E:  DATA 0A,00
050F:  DATA E6,34
0510:  DATA EE,34
0511:  DATA 73,34
0512:  DATA 65,32
0513:  DATA A0,34
0514:  DATA 6E,10
0515:  DATA 73,3A
0516:  DATA 61,3A
0517:  DATA F5,39
0518:  DATA DF,31
0519:  DATA E8,32
051A:  DATA E3,35
051B:  DATA 0D,05
051C:  DATA 00,00
051D:  DATA 89,16
051E:  DATA 3E,10
051F:  DATA E9,39
0520:  DATA A0,29
0521:  DATA 4D,23
0522:  DATA A0,30
0523:  DATA F6,30
0524:  DATA 69,36
0525:  DATA 61,31
0526:  DATA EC,32
0527:  DATA 0D,05
0528:  DATA 00,01
0529:  DATA 09,10
052A:  DATA 20,10
052B:  DATA 54,39
052C:  DATA 61,37
052D:  DATA F3,36
052E:  DATA 69,3A
052F:  DATA A0,20
0530:  DATA E3,35
0531:  DATA EE,37
0532:  DATA 77,36
0533:  DATA 65,32
0534:  DATA E7,32
0535:  DATA 0D,05
0536:  DATA 00,01
0537:  DATA 89,04
0538:  DATA 2D,1F
0539:  DATA A0,30
053A:  DATA 6C,36
053B:  DATA EF,3B
053C:  DATA 65,32
053D:  DATA 0D,05
053E:  DATA 00,01
053F:  DATA 89,04
0540:  DATA 2D,1F
0541:  DATA 20,32
0542:  DATA 65,37
0543:  DATA E9,32
0544:  DATA E4,06
0545:  DATA 0A,00
0546:  DATA 0D,05
0547:  DATA 54,34
0548:  DATA E9,39
0549:  DATA 20,10
054A:  DATA ED,34
054B:  DATA F3,39
054C:  DATA E9,37
054D:  DATA 6E,10
054E:  DATA E9,39
054F:  DATA A0,32
0550:  DATA F8,32
0551:  DATA E3,3A
0552:  DATA F4,32
0553:  DATA E4,06
0554:  DATA 8A,04
0555:  DATA 2D,1F
0556:  DATA 20,18
0557:  DATA F8,12
0558:  DATA E4,06
0559:  DATA 0A,00
055A:  DATA 0D,05
055B:  DATA DF,2F
055C:  DATA DF,2F
055D:  DATA DF,2F
055E:  DATA DF,2F
055F:  DATA DF,2F
0560:  DATA DF,2F
0561:  DATA DF,2F
0562:  DATA DF,2F
0563:  DATA DF,2F
0564:  DATA DF,2F
0565:  DATA DF,2F
0566:  DATA DF,2F
0567:  DATA DF,2F
0568:  DATA DF,2F
0569:  DATA DF,2F
056A:  DATA DF,2F
056B:  DATA DF,2F
056C:  DATA DF,2F
056D:  DATA 0D,05
056E:  DATA DF,2F
056F:  DATA DF,2F
0570:  DATA DF,2F
0571:  DATA DF,2F
0572:  DATA 53,3A
0573:  DATA 61,39
0574:  DATA 74,10
0575:  DATA 65,3C
0576:  DATA E5,31
0577:  DATA 75,3A
0578:  DATA E5,2F
0579:  DATA ED,34
057A:  DATA F3,39
057B:  DATA E9,37
057C:  DATA EE,2F
057D:  DATA DF,2F
057E:  DATA DF,2F
057F:  DATA DF,2F
0580:  DATA DF,06
0581:  DATA 8A,06
0582:  DATA 0A,00
0583:  DATA C3,37
0584:  DATA ED,36
0585:  DATA 61,37
0586:  DATA 64,10
0587:  DATA 49,22
0588:  DATA 3A,10
0589:  DATA 25,2C
058A:  DATA 0D,05
058B:  DATA 0D,05
058C:  DATA 00,01
058D:  DATA 89,04
058E:  DATA 2D,1F
058F:  DATA A0,24
0590:  DATA 6E,3B
0591:  DATA 61,36
0592:  DATA 69,32
0593:  DATA A0,21
0594:  DATA 4D,22
0595:  DATA A0,24
0596:  DATA C4,10
0597:  DATA 0D,05
0598:  DATA 00,01
0599:  DATA 0D,05
059A:  DATA DF,2F
059B:  DATA DF,2F
059C:  DATA DF,2F
059D:  DATA DF,2F
059E:  DATA DF,22
059F:  DATA 6E,32
05A0:  DATA A0,32
05A1:  DATA F8,32
05A2:  DATA E3,3A
05A3:  DATA F4,32
05A4:  DATA DF,36
05A5:  DATA E9,39
05A6:  DATA F3,34
05A7:  DATA 6F,37
05A8:  DATA DF,2F
05A9:  DATA DF,2F
05AA:  DATA DF,2F
05AB:  DATA DF,2F
05AC:  DATA DF,06
05AD:  DATA 8A,2F
05AE:  DATA DF,2F
05AF:  DATA DF,2F
05B0:  DATA DF,2F
05B1:  DATA DF,2F
05B2:  DATA DF,2F
05B3:  DATA DF,2F
05B4:  DATA DF,2F
05B5:  DATA DF,2F
05B6:  DATA DF,2F
05B7:  DATA DF,2F
05B8:  DATA DF,2F
05B9:  DATA DF,2F
05BA:  DATA DF,2F
05BB:  DATA DF,2F
05BC:  DATA DF,2F
05BD:  DATA DF,2F
05BE:  DATA DF,2F
05BF:  DATA DF,06
05C0:  DATA 0A,00
05C1:  DATA 0D,05
05C2:  DATA 0D,05
05C3:  DATA BD,1E
05C4:  DATA BD,1E
05C5:  DATA BD,1E
05C6:  DATA BD,1E
05C7:  DATA BD,1E
05C8:  DATA BD,1E
05C9:  DATA BD,1E
05CA:  DATA BD,1E
05CB:  DATA BD,1E
05CC:  DATA BD,1E
05CD:  DATA BD,1E
05CE:  DATA BD,1E
05CF:  DATA BD,1E
05D0:  DATA BD,1E
05D1:  DATA BD,1E
05D2:  DATA BD,1E
05D3:  DATA BD,1E
05D4:  DATA BD,1E
05D5:  DATA BD,1E
05D6:  DATA BD,1E
05D7:  DATA BD,1E
05D8:  DATA BD,1E
05D9:  DATA BD,1E
05DA:  DATA BD,1E
05DB:  DATA BD,1E
05DC:  DATA BD,1E
05DD:  DATA BD,1E
05DE:  DATA BD,1E
05DF:  DATA BD,1E
05E0:  DATA BD,1E
05E1:  DATA 0D,05
05E2:  DATA 00,01
05E3:  DATA 54,34
05E4:  DATA E9,39
05E5:  DATA A0,34
05E6:  DATA 73,10
05E7:  DATA CD,27
05E8:  DATA CD,24
05E9:  DATA CA,24
05EA:  DATA A0,21
05EB:  DATA C9,23
05EC:  DATA 53,10
05ED:  DATA D0,24
05EE:  DATA 43,10
05EF:  DATA 42,21
05F0:  DATA 4D,10
05F1:  DATA E6,37
05F2:  DATA 72,10
05F3:  DATA CD,24
05F4:  DATA D3,1B
05F5:  DATA 5F,21
05F6:  DATA C2,26
05F7:  DATA 31,17
05F8:  DATA 0D,05
05F9:  DATA 00,01
05FA:  DATA CC,30
05FB:  DATA 73,3A
05FC:  DATA A0,3A
05FD:  DATA 70,32
05FE:  DATA 61,3A
05FF:  DATA 65,32
0600:  DATA A0,37
0601:  DATA 6E,10
0602:  DATA 32,18
0603:  DATA B2,1A
0604:  DATA 2F,18
0605:  DATA B4,17
0606:  DATA B2,1A
0607:  DATA 2C,10
0608:  DATA E2,3C
0609:  DATA A0,24
060A:  DATA EE,37
060B:  DATA F5,32
060C:  DATA AE,06
060D:  DATA 8A,06
060E:  DATA 0A,00
060F:  DATA DF,2F
0610:  DATA DF,2F
0611:  DATA C3,24
0612:  DATA C7,29
0613:  DATA 20,28
0614:  DATA C9,21
0615:  DATA A0,29
0616:  DATA F4,30
0617:  DATA 72,3A
0618:  DATA A0,27
0619:  DATA F0,32
061A:  DATA F2,30
061B:  DATA F4,34
061C:  DATA 6F,37
061D:  DATA DF,2F
061E:  DATA DF,2F
061F:  DATA DF,06
0620:  DATA 8A,06
0621:  DATA 0A,00
0622:  DATA F7,30
0623:  DATA 69,3A
0624:  DATA 69,37
0625:  DATA 67,10
0626:  DATA E6,37
0627:  DATA 72,10
0628:  DATA C2,27
0629:  DATA D3,29
062A:  DATA 20,28
062B:  DATA C9,21
062C:  DATA A0,31
062D:  DATA EF,36
062E:  DATA ED,30
062F:  DATA 6E,32
0630:  DATA 00,01
0631:  DATA 46,39
0632:  DATA E1,36
0633:  DATA E5,24
0634:  DATA 44,1D
0635:  DATA A0,12
0636:  DATA 31,2C
0637:  DATA 0D,05
0638:  DATA 00,01
0639:  DATA F0,30
063A:  DATA 79,36
063B:  DATA EF,30
063C:  DATA 64,10
063D:  DATA F3,34
063E:  DATA FA,32
063F:  DATA 3A,10
0640:  DATA 25,32
0641:  DATA 0D,05
0642:  DATA 00,01
0643:  DATA F0,30
0644:  DATA 79,36
0645:  DATA EF,30
0646:  DATA 64,1D
0647:  DATA 20,00
0648:  DATA 0D,05
0649:  DATA 0D,05
064A:  DATA 00,01
064B:  DATA 89,16
064C:  DATA 3E,10
064D:  DATA 49,37
064E:  DATA F6,30
064F:  DATA EC,34
0650:  DATA 64,10
0651:  DATA E3,37
0652:  DATA ED,36
0653:  DATA 61,37
0654:  DATA E4,06
0655:  DATA 0A,00
0656:  DATA 0D,05
0657:  DATA 0D,05
0658:  DATA BD,1E
0659:  DATA BD,1E
065A:  DATA BD,1E
065B:  DATA 0D,05
065C:  DATA 0D,05
065D:  DATA C6,34
065E:  DATA EE,34
065F:  DATA 73,34
0660:  DATA 65,32
0661:  DATA 20,38
0662:  DATA F2,37
0663:  DATA E3,32
0664:  DATA F3,39
0665:  DATA AE,06
0666:  DATA 8A,2B
0667:  DATA E1,34
0668:  DATA 74,10
0669:  DATA E6,37
066A:  DATA 72,10
066B:  DATA C2,27
066C:  DATA D3,29
066D:  DATA 20,28
066E:  DATA C9,21
066F:  DATA 20,3A
0670:  DATA 75,39
0671:  DATA 6E,10
0672:  DATA 6F,33
0673:  DATA 66,10
0674:  DATA ED,32
0675:  DATA 00,01
0676:  DATA 45,37
0677:  DATA 64,10
0678:  DATA ED,30
0679:  DATA 69,37
067A:  DATA 0D,05
067B:  DATA 00,00
*
06A1:  MOVF   0B,W
06A2:  BCF    0B.7
06A3:  MOVLB  03
06A4:  BSF    15.7
06A5:  BSF    15.0
06A6:  NOP
06A7:  NOP
06A8:  BTFSC  09.7
06A9:  BSF    0B.7
06AA:  MOVF   13,W
06AB:  ANDLW  7F
06AC:  BTFSC  03.2
06AD:  GOTO   6ED
06AE:  MOVLB  11
06AF:  MOVWF  28
06B0:  MOVLB  03
06B1:  MOVF   11,W
06B2:  MOVLB  11
06B3:  MOVWF  29
06B4:  MOVLB  03
06B5:  MOVF   12,W
06B6:  MOVLB  11
06B7:  MOVWF  2A
06B8:  MOVF   28,W
06B9:  MOVWF  2B
06BA:  MOVLB  00
06BB:  CALL   67C
06BC:  MOVLB  11
06BD:  MOVF   29,W
06BE:  MOVLB  03
06BF:  MOVWF  11
06C0:  MOVLB  11
06C1:  MOVF   2A,W
06C2:  MOVLB  03
06C3:  MOVWF  12
06C4:  MOVF   0B,W
06C5:  BCF    0B.7
06C6:  BSF    15.7
06C7:  BSF    15.0
06C8:  NOP
06C9:  NOP
06CA:  BTFSC  09.7
06CB:  BSF    0B.7
06CC:  RLF    13,W
06CD:  RLF    14,W
06CE:  ANDLW  7F
06CF:  BTFSC  03.2
06D0:  GOTO   6ED
06D1:  MOVLB  11
06D2:  MOVWF  28
06D3:  MOVLB  03
06D4:  MOVF   11,W
06D5:  MOVLB  11
06D6:  MOVWF  29
06D7:  MOVLB  03
06D8:  MOVF   12,W
06D9:  MOVLB  11
06DA:  MOVWF  2A
06DB:  MOVF   28,W
06DC:  MOVWF  2B
06DD:  MOVLB  00
06DE:  CALL   67C
06DF:  MOVLB  11
06E0:  MOVF   29,W
06E1:  MOVLB  03
06E2:  MOVWF  11
06E3:  MOVLB  11
06E4:  MOVF   2A,W
06E5:  MOVLB  03
06E6:  MOVWF  12
06E7:  INCF   11,F
06E8:  BTFSC  03.2
06E9:  INCF   12,F
06EA:  MOVLB  00
06EB:  GOTO   6A1
06EC:  MOVLB  03
06ED:  MOVLB  00
06EE:  RETURN
*
0783:  MOVLB  11
0784:  BTFSC  28.7
0785:  GOTO   798
0786:  MOVLW  0F
0787:  MOVWF  77
0788:  SWAPF  27,W
0789:  ANDWF  77,F
078A:  MOVLW  0A
078B:  SUBWF  77,W
078C:  BTFSC  03.0
078D:  GOTO   791
078E:  MOVLW  30
078F:  ADDWF  77,F
0790:  GOTO   793
0791:  MOVF   28,W
0792:  ADDWF  77,F
0793:  MOVF   77,W
0794:  MOVWF  2B
0795:  MOVLB  00
0796:  CALL   67C
0797:  MOVLB  11
0798:  MOVLW  0F
0799:  ANDWF  27,F
079A:  MOVLW  0A
079B:  SUBWF  27,W
079C:  BTFSC  03.0
079D:  GOTO   7A0
079E:  MOVLW  30
079F:  GOTO   7A2
07A0:  BCF    28.7
07A1:  MOVF   28,W
07A2:  ADDWF  27,F
07A3:  MOVF   27,W
07A4:  MOVWF  2B
07A5:  MOVLB  00
07A6:  CALL   67C
07A7:  RETURN
*
07C3:  MOVLB  10
07C4:  MOVF   55,W
07C5:  CLRF   78
07C6:  SUBWF  54,W
07C7:  BTFSC  03.0
07C8:  GOTO   7CC
07C9:  MOVF   54,W
07CA:  MOVWF  77
07CB:  GOTO   7D8
07CC:  CLRF   77
07CD:  MOVLW  08
07CE:  MOVWF  56
07CF:  RLF    54,F
07D0:  RLF    77,F
07D1:  MOVF   55,W
07D2:  SUBWF  77,W
07D3:  BTFSC  03.0
07D4:  MOVWF  77
07D5:  RLF    78,F
07D6:  DECFSZ 56,F
07D7:  GOTO   7CF
07D8:  MOVLB  00
07D9:  RETURN
*
07EA:  MOVF   78,W
07EB:  BTFSC  03.2
07EC:  GOTO   7F1
07ED:  MOVF   77,W
07EE:  MOVWI  W,[FSR0++]
07EF:  DECFSZ 78,F
07F0:  GOTO   7ED
*
0949:  MOVF   0B,W
094A:  BCF    0B.7
094B:  MOVLB  03
094C:  BSF    15.7
094D:  BSF    15.0
094E:  NOP
094F:  NOP
0950:  BTFSC  09.7
0951:  BSF    0B.7
0952:  BTFSC  03.0
0953:  GOTO   17E
0954:  MOVF   13,W
0955:  ANDLW  7F
0956:  MOVLB  11
0957:  MOVWF  28
0958:  MOVLB  03
0959:  MOVF   11,W
095A:  MOVLB  11
095B:  MOVWF  29
095C:  MOVLB  03
095D:  MOVF   12,W
095E:  MOVLB  11
095F:  MOVWF  2A
0960:  MOVF   28,W
0961:  MOVWF  2B
0962:  MOVLP  00
0963:  MOVLB  00
0964:  CALL   67C
0965:  MOVLP  08
0966:  MOVLB  11
0967:  MOVF   29,W
0968:  MOVLB  03
0969:  MOVWF  11
096A:  MOVLB  11
096B:  MOVF   2A,W
096C:  MOVLB  03
096D:  MOVWF  12
096E:  MOVF   0B,W
096F:  BCF    0B.7
0970:  BSF    15.7
0971:  BSF    15.0
0972:  NOP
0973:  NOP
0974:  BTFSC  09.7
0975:  BSF    0B.7
0976:  MOVLB  11
0977:  DECFSZ 27,F
0978:  GOTO   17A
0979:  GOTO   17C
097A:  MOVLB  03
097B:  GOTO   17E
097C:  GOTO   1A3
097D:  MOVLB  03
097E:  RLF    13,W
097F:  RLF    14,W
0980:  ANDLW  7F
0981:  MOVLB  11
0982:  MOVWF  28
0983:  MOVLB  03
0984:  MOVF   11,W
0985:  MOVLB  11
0986:  MOVWF  29
0987:  MOVLB  03
0988:  MOVF   12,W
0989:  MOVLB  11
098A:  MOVWF  2A
098B:  MOVF   28,W
098C:  MOVWF  2B
098D:  MOVLP  00
098E:  MOVLB  00
098F:  CALL   67C
0990:  MOVLP  08
0991:  MOVLB  11
0992:  MOVF   29,W
0993:  MOVLB  03
0994:  MOVWF  11
0995:  MOVLB  11
0996:  MOVF   2A,W
0997:  MOVLB  03
0998:  MOVWF  12
0999:  INCF   11,F
099A:  BTFSC  03.2
099B:  INCF   12,F
099C:  BCF    03.0
099D:  MOVLB  11
099E:  DECFSZ 27,F
099F:  GOTO   1A1
09A0:  GOTO   1A3
09A1:  MOVLB  00
09A2:  GOTO   149
09A3:  MOVLB  00
09A4:  RETURN
*
0BE6:  MOVLW  20
0BE7:  MOVLB  10
0BE8:  BTFSS  4A.4
0BE9:  MOVLW  30
0BEA:  MOVWF  4C
0BEB:  MOVF   49,W
0BEC:  MOVWF  77
0BED:  BTFSS  49.7
0BEE:  GOTO   3F7
0BEF:  COMF   77,F
0BF0:  INCF   77,F
0BF1:  MOVF   77,W
0BF2:  MOVWF  49
0BF3:  MOVLW  2D
0BF4:  MOVWF  4C
0BF5:  BSF    4A.7
0BF6:  BSF    4A.0
0BF7:  MOVF   49,W
0BF8:  MOVWF  54
0BF9:  MOVLW  64
0BFA:  MOVWF  55
0BFB:  MOVLP  00
0BFC:  MOVLB  00
0BFD:  CALL   7C3
0BFE:  MOVLP  08
0BFF:  MOVF   77,W
0C00:  MOVLB  10
0C01:  MOVWF  49
0C02:  MOVLW  30
0C03:  ADDWF  78,W
0C04:  MOVWF  4D
0C05:  MOVF   49,W
0C06:  MOVWF  54
0C07:  MOVLW  0A
0C08:  MOVWF  55
0C09:  MOVLP  00
0C0A:  MOVLB  00
0C0B:  CALL   7C3
0C0C:  MOVLP  08
0C0D:  MOVLW  30
0C0E:  ADDWF  77,W
0C0F:  MOVLB  10
0C10:  MOVWF  4F
0C11:  MOVLW  30
0C12:  ADDWF  78,W
0C13:  MOVWF  4E
0C14:  MOVF   4C,W
0C15:  MOVWF  77
0C16:  MOVLW  30
0C17:  SUBWF  4D,W
0C18:  BTFSC  03.2
0C19:  GOTO   41E
0C1A:  BSF    4A.1
0C1B:  BTFSC  4A.7
0C1C:  BSF    4A.2
0C1D:  GOTO   432
0C1E:  MOVF   4C,W
0C1F:  MOVWF  4D
0C20:  MOVLW  20
0C21:  MOVWF  4C
0C22:  MOVLW  30
0C23:  SUBWF  4E,W
0C24:  BTFSC  03.2
0C25:  GOTO   42A
0C26:  BSF    4A.0
0C27:  BTFSC  4A.7
0C28:  BSF    4A.1
0C29:  GOTO   432
0C2A:  BTFSS  03.2
0C2B:  BSF    4A.0
0C2C:  BTFSS  03.2
0C2D:  GOTO   432
0C2E:  MOVF   4D,W
0C2F:  MOVWF  4E
0C30:  MOVLW  20
0C31:  MOVWF  4D
0C32:  BTFSC  4A.2
0C33:  GOTO   439
0C34:  BTFSC  4A.1
0C35:  GOTO   441
0C36:  BTFSC  4A.0
0C37:  GOTO   449
0C38:  GOTO   451
0C39:  MOVF   4C,W
0C3A:  MOVLB  11
0C3B:  MOVWF  2B
0C3C:  MOVLP  00
0C3D:  MOVLB  00
0C3E:  CALL   67C
0C3F:  MOVLP  08
0C40:  MOVLB  10
0C41:  MOVF   4D,W
0C42:  MOVLB  11
0C43:  MOVWF  2B
0C44:  MOVLP  00
0C45:  MOVLB  00
0C46:  CALL   67C
0C47:  MOVLP  08
0C48:  MOVLB  10
0C49:  MOVF   4E,W
0C4A:  MOVLB  11
0C4B:  MOVWF  2B
0C4C:  MOVLP  00
0C4D:  MOVLB  00
0C4E:  CALL   67C
0C4F:  MOVLP  08
0C50:  MOVLB  10
0C51:  MOVF   4F,W
0C52:  MOVLB  11
0C53:  MOVWF  2B
0C54:  MOVLP  00
0C55:  MOVLB  00
0C56:  CALL   67C
0C57:  MOVLP  08
0C58:  RETURN
*
0CF0:  CLRF   77
0CF1:  CLRF   78
0CF2:  MOVLB  10
0CF3:  MOVF   58,W
0CF4:  BCF    03.0
0CF5:  BTFSC  59.0
0CF6:  ADDWF  77,F
0CF7:  RRF    77,F
0CF8:  RRF    78,F
0CF9:  BTFSC  59.1
0CFA:  ADDWF  77,F
0CFB:  RRF    77,F
0CFC:  RRF    78,F
0CFD:  BTFSC  59.2
0CFE:  ADDWF  77,F
0CFF:  RRF    77,F
0D00:  RRF    78,F
0D01:  BTFSC  59.3
0D02:  ADDWF  77,F
0D03:  RRF    77,F
0D04:  RRF    78,F
0D05:  BTFSC  59.4
0D06:  ADDWF  77,F
0D07:  RRF    77,F
0D08:  RRF    78,F
0D09:  BTFSC  59.5
0D0A:  ADDWF  77,F
0D0B:  RRF    77,F
0D0C:  RRF    78,F
0D0D:  BTFSC  59.6
0D0E:  ADDWF  77,F
0D0F:  RRF    77,F
0D10:  RRF    78,F
0D11:  BTFSC  59.7
0D12:  ADDWF  77,F
0D13:  RRF    77,F
0D14:  RRF    78,F
0D15:  MOVLB  00
0D16:  RETURN
*
101E:  MOVF   52,W
101F:  MOVWF  54
1020:  MOVLW  64
1021:  MOVWF  55
1022:  MOVLP  00
1023:  MOVLB  00
1024:  CALL   7C3
1025:  MOVLP  10
1026:  MOVF   77,W
1027:  MOVLB  10
1028:  MOVWF  52
1029:  MOVF   78,W
102A:  MOVLW  30
102B:  BTFSS  03.2
102C:  GOTO   034
102D:  BTFSS  53.1
102E:  GOTO   040
102F:  BTFSC  53.3
1030:  GOTO   040
1031:  BTFSC  53.4
1032:  MOVLW  20
1033:  GOTO   037
1034:  BCF    53.3
1035:  BCF    53.4
1036:  BSF    53.0
1037:  ADDWF  78,F
1038:  MOVF   78,W
1039:  MOVLB  11
103A:  MOVWF  2B
103B:  MOVLP  00
103C:  MOVLB  00
103D:  CALL   67C
103E:  MOVLP  10
103F:  MOVLB  10
1040:  MOVF   52,W
1041:  MOVWF  54
1042:  MOVLW  0A
1043:  MOVWF  55
1044:  MOVLP  00
1045:  MOVLB  00
1046:  CALL   7C3
1047:  MOVLP  10
1048:  MOVF   77,W
1049:  MOVLB  10
104A:  MOVWF  52
104B:  MOVF   78,W
104C:  MOVLW  30
104D:  BTFSS  03.2
104E:  GOTO   055
104F:  BTFSC  53.3
1050:  GOTO   05E
1051:  BTFSS  53.0
1052:  GOTO   05E
1053:  BTFSC  53.4
1054:  MOVLW  20
1055:  ADDWF  78,F
1056:  MOVF   78,W
1057:  MOVLB  11
1058:  MOVWF  2B
1059:  MOVLP  00
105A:  MOVLB  00
105B:  CALL   67C
105C:  MOVLP  10
105D:  MOVLB  10
105E:  MOVLW  30
105F:  ADDWF  52,F
1060:  MOVF   52,W
1061:  MOVLB  11
1062:  MOVWF  2B
1063:  MOVLP  00
1064:  MOVLB  00
1065:  CALL   67C
1066:  MOVLP  10
*
1147:  BTFSC  03.1
1148:  GOTO   14D
1149:  MOVLW  25
114A:  MOVWF  05
114B:  MOVLW  3C
114C:  MOVWF  04
114D:  CLRF   77
114E:  CLRF   78
114F:  CLRF   79
1150:  CLRF   7A
1151:  CLRF   5C
1152:  CLRF   5D
1153:  CLRF   5E
1154:  CLRF   5F
1155:  MOVF   59,W
1156:  IORWF  58,W
1157:  IORWF  57,W
1158:  IORWF  56,W
1159:  BTFSC  03.2
115A:  GOTO   18B
115B:  MOVLW  20
115C:  MOVWF  60
115D:  BCF    03.0
115E:  RLF    52,F
115F:  RLF    53,F
1160:  RLF    54,F
1161:  RLF    55,F
1162:  RLF    5C,F
1163:  RLF    5D,F
1164:  RLF    5E,F
1165:  RLF    5F,F
1166:  MOVF   59,W
1167:  SUBWF  5F,W
1168:  BTFSS  03.2
1169:  GOTO   174
116A:  MOVF   58,W
116B:  SUBWF  5E,W
116C:  BTFSS  03.2
116D:  GOTO   174
116E:  MOVF   57,W
116F:  SUBWF  5D,W
1170:  BTFSS  03.2
1171:  GOTO   174
1172:  MOVF   56,W
1173:  SUBWF  5C,W
1174:  BTFSS  03.0
1175:  GOTO   185
1176:  MOVF   56,W
1177:  SUBWF  5C,F
1178:  MOVF   57,W
1179:  BTFSS  03.0
117A:  INCFSZ 57,W
117B:  SUBWF  5D,F
117C:  MOVF   58,W
117D:  BTFSS  03.0
117E:  INCFSZ 58,W
117F:  SUBWF  5E,F
1180:  MOVF   59,W
1181:  BTFSS  03.0
1182:  INCFSZ 59,W
1183:  SUBWF  5F,F
1184:  BSF    03.0
1185:  RLF    77,F
1186:  RLF    78,F
1187:  RLF    79,F
1188:  RLF    7A,F
1189:  DECFSZ 60,F
118A:  GOTO   15D
118B:  MOVF   5C,W
118C:  MOVWF  00
118D:  MOVF   5D,W
118E:  MOVWI  W,[FSR0+01]
118F:  MOVF   5E,W
1190:  MOVWI  W,[FSR0+02]
1191:  MOVF   5F,W
1192:  MOVWI  W,[FSR0+03]
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz, clock=16MHz)
*
0760:  MOVLW  25
0761:  MOVWF  05
0762:  MOVLW  36
0763:  MOVWF  04
0764:  MOVF   00,W
0765:  BTFSC  03.2
0766:  GOTO   775
0767:  MOVLW  05
0768:  MOVWF  78
0769:  CLRF   77
076A:  DECFSZ 77,F
076B:  GOTO   76A
076C:  DECFSZ 78,F
076D:  GOTO   769
076E:  MOVLW  2E
076F:  MOVWF  77
0770:  DECFSZ 77,F
0771:  GOTO   770
0772:  GOTO   773
0773:  DECFSZ 00,F
0774:  GOTO   767
0775:  RETURN
.................... #fuses NOMCLR
.................... 
.................... 
.................... 
.................... //#define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... 
.................... //-------------Serial--------------------
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
*
0CA7:  MOVLB  00
0CA8:  BTFSS  11.4
0CA9:  GOTO   4A8
0CAA:  MOVLB  03
0CAB:  MOVWF  1A
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
*
067C:  MOVLB  01
067D:  BCF    0D.4
067E:  MOVLB  02
067F:  BCF    0D.4
0680:  MOVLW  08
0681:  MOVWF  78
0682:  GOTO   683
0683:  NOP
0684:  BSF    78.7
0685:  GOTO   696
0686:  BCF    78.7
0687:  MOVLB  11
0688:  RRF    2B,F
0689:  MOVLB  02
068A:  BTFSC  03.0
068B:  BSF    0D.4
068C:  BTFSS  03.0
068D:  BCF    0D.4
068E:  BSF    78.6
068F:  GOTO   696
0690:  BCF    78.6
0691:  DECFSZ 78,F
0692:  GOTO   687
0693:  GOTO   694
0694:  NOP
0695:  BSF    0D.4
0696:  MOVLW  84
0697:  MOVWF  04
0698:  DECFSZ 04,F
0699:  GOTO   698
069A:  NOP
069B:  BTFSC  78.7
069C:  GOTO   686
069D:  BTFSC  78.6
069E:  GOTO   690
069F:  MOVLB  00
06A0:  RETURN
.................... 
.................... 
.................... #define SPI0_CS  PIN_D1
.................... #use spi(MASTER, CLK=PIN_C3, DI=PIN_C4, DO=PIN_C5, BAUD=400000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
0776:  MOVLB  04
0777:  MOVF   11,W
0778:  MOVLB  10
0779:  MOVF   58,W
077A:  MOVLB  04
077B:  MOVWF  11
077C:  RRF    14,W
077D:  BTFSS  03.0
077E:  GOTO   77C
077F:  MOVF   11,W
0780:  MOVWF  77
0781:  MOVLB  00
0782:  RETURN
.................... // MISO PIN_C5, MOSI PIN_C4, SCK PIN_C3
.................... 
.................... 
.................... #define SPI1_CS PIN_C2
.................... #use spi(MASTER, SPI1, BAUD=400000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
.................... //-------------I/O port--------------------
.................... // AI/O___ADC
.................... #define TEMP_TOP PIN_A5
.................... #define TEMP_BOT PIN_A3
.................... #define CIGS_VOLT PIN_A0 //PIN_A0
.................... #define CIGS_CURR PIN_A1
.................... #define PD PIN_E0
.................... 
.................... // AI/O___DAC
.................... #define LOAD PIN_A2
.................... 
.................... // DI/O___
.................... #define CIGS_CONNECT PIN_C0
.................... #define EN_NPWR PIN_C3  //Negative Power
.................... 
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... #include "./lib/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x00,
....................     DENY  = 0x01
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... // EOF
.................... 
.................... 
.................... #include "./lib/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile unsigned int16 duration_sec = 0;
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status = IDLE;
.................... 
.................... 
.................... #endif
.................... 
.................... // EOF
.................... 
.................... 
.................... #include "./lib/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... volatile unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #include "./src/timer.c"
.................... #INT_TIMER0
.................... static void TIMER0_isr(void)
.................... {
....................    // every 0.01 sec interrupts
....................    set_timer0(100);
*
0047:  MOVLW  64
0048:  MOVWF  15
.................... 
....................    if (++subsec >= 100)
0049:  MOVLW  01
004A:  ADDWF  2C,F
004B:  BTFSC  03.0
004C:  INCF   2D,F
004D:  BTFSC  03.2
004E:  INCF   2E,F
004F:  BTFSC  03.2
0050:  INCF   2F,F
0051:  MOVF   2F,F
0052:  BTFSS  03.2
0053:  GOTO   05E
0054:  MOVF   2E,F
0055:  BTFSS  03.2
0056:  GOTO   05E
0057:  MOVF   2D,F
0058:  BTFSS  03.2
0059:  GOTO   05E
005A:  MOVF   2C,W
005B:  SUBLW  63
005C:  BTFSC  03.0
005D:  GOTO   08A
....................    {
....................       subsec = 0;
005E:  CLRF   2F
005F:  CLRF   2E
0060:  CLRF   2D
0061:  CLRF   2C
....................       sec++;
0062:  MOVLW  01
0063:  ADDWF  30,F
0064:  BTFSC  03.0
0065:  INCF   31,F
0066:  BTFSC  03.2
0067:  INCF   32,F
0068:  BTFSC  03.2
0069:  INCF   33,F
.................... 
....................       if (sec >= SEC_IN_A_DAY)
006A:  MOVF   33,F
006B:  BTFSS  03.2
006C:  GOTO   07F
006D:  MOVF   32,W
006E:  SUBLW  00
006F:  BTFSC  03.0
0070:  GOTO   08A
0071:  XORLW  FF
0072:  BTFSS  03.2
0073:  GOTO   07F
0074:  MOVF   31,W
0075:  SUBLW  50
0076:  BTFSC  03.0
0077:  GOTO   08A
0078:  XORLW  FF
0079:  BTFSS  03.2
007A:  GOTO   07F
007B:  MOVF   30,W
007C:  SUBLW  7F
007D:  BTFSC  03.0
007E:  GOTO   08A
....................       {
....................          sec -= SEC_IN_A_DAY;
007F:  MOVLW  80
0080:  SUBWF  30,F
0081:  MOVLW  51
0082:  SUBWFC 31,F
0083:  MOVLW  01
0084:  SUBWFC 32,F
0085:  MOVLW  00
0086:  SUBWFC 33,F
....................          day++;
0087:  INCF   34,F
0088:  BTFSC  03.2
0089:  INCF   35,F
....................       }
....................    }
008A:  BCF    0B.2
008B:  MOVLP  00
008C:  GOTO   02A
.................... }
.................... 
.................... void timer_init()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
0743:  MOVLW  8D
0744:  MOVLB  03
0745:  MOVWF  11
0746:  MOVLW  00
0747:  MOVWF  12
0748:  MOVLB  00
0749:  CALL   6A1
....................    clear_interrupt(INT_TIMER1);
074A:  BCF    11.0
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1); //Config TMR1, external clock, prescaler=1
074B:  MOVLW  87
074C:  MOVWF  18
074D:  CLRF   19
....................    set_timer1(0x8000); //timer1 for 1 second interruption
074E:  CLRF   16
074F:  MOVLW  80
0750:  MOVWF  17
0751:  CLRF   16
0752:  NOP
....................    //T1OSCEN = 1; //Enable TMR1 Oscillator
....................    enable_interrupts(INT_TIMER1);
0753:  MOVLB  01
0754:  BSF    11.0
....................    enable_interrupts(GLOBAL);
0755:  MOVLW  C0
0756:  IORWF  0B,F
....................    fprintf(PC, "\tComplete\r\n");
0757:  MOVLW  97
0758:  MOVLB  03
0759:  MOVWF  11
075A:  MOVLW  00
075B:  MOVWF  12
075C:  MOVLB  00
075D:  CALL   6A1
075E:  MOVLP  08
075F:  GOTO   5EE (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "./lib/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void initialize_uart();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... #include "./src/uart.c"
.................... #INT_RDA
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
009D:  MOVF   2B,W
009E:  SUBLW  02
009F:  BTFSC  03.2
00A0:  GOTO   0A5
00A1:  MOVF   2B,W
00A2:  SUBLW  05
00A3:  BTFSS  03.2
00A4:  GOTO   0A7
00A5:  BTFSS  2A.0
00A6:  GOTO   0BA
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00A7:  MOVF   58,W
00A8:  SUBLW  1F
00A9:  BTFSS  03.0
00AA:  GOTO   0BA
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
00AB:  MOVF   58,W
00AC:  INCF   58,F
00AD:  ANDLW  1F
00AE:  ADDLW  18
00AF:  MOVWF  04
00B0:  MOVLW  20
00B1:  MOVWF  05
00B2:  BTFSC  03.0
00B3:  INCF   05,F
00B4:  BTFSS  11.5
00B5:  GOTO   0B4
00B6:  MOVLB  03
00B7:  MOVF   19,W
00B8:  MOVWF  00
00B9:  MOVLB  00
00BA:  BCF    11.5
00BB:  MOVLP  00
00BC:  GOTO   02A
.................... }
.................... 
.................... void uart_init()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
072F:  MOVLW  BD
0730:  MOVLB  03
0731:  MOVWF  11
0732:  MOVLW  00
0733:  MOVWF  12
0734:  MOVLB  00
0735:  CALL   6A1
....................    enable_interrupts(INT_RDA);
0736:  MOVLB  01
0737:  BSF    11.5
....................    enable_interrupts(global);
0738:  MOVLW  C0
0739:  IORWF  0B,F
....................    fprintf(PC, "\tComplete\r\n");
073A:  MOVLW  C6
073B:  MOVLB  03
073C:  MOVWF  11
073D:  MOVLW  00
073E:  MOVWF  12
073F:  MOVLB  00
0740:  CALL   6A1
0741:  MOVLP  08
0742:  GOTO   5EB (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
07DA:  MOVLB  10
07DB:  MOVF   40,W
07DC:  MOVWF  7A
07DD:  MOVF   3F,W
07DE:  MOVWF  04
07DF:  MOVF   7A,W
07E0:  MOVWF  05
07E1:  MOVF   00,W
07E2:  MOVWF  42
07E3:  MOVF   3E,W
07E4:  MOVWF  05
07E5:  MOVF   3D,W
07E6:  MOVWF  04
07E7:  CLRF   77
07E8:  MOVF   42,W
07E9:  MOVWF  78
....................    *receive_signal_size = 0;
*
07F1:  MOVF   3F,W
07F2:  MOVWF  04
07F3:  MOVF   40,W
07F4:  MOVWF  05
07F5:  CLRF   00
07F6:  MOVLP  08
07F7:  MOVLB  00
07F8:  GOTO   6A8 (RETURN)
.................... }
.................... 
.................... // EOF
.................... 
.................... 
.................... #endif
.................... 
.................... // EOF
.................... 
.................... 
.................... // Missions
.................... #include "mmj_cigs_mode.h"
.................... #ifndef MMJ_CIGS_MODE_H
.................... #define MMJ_CIGS_MODE_H
.................... 
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... #Separate
.................... void mode_measure(unsigned int8 parameter[]);
.................... 
.................... // Flash command 
.................... #Separate
.................... void mode_flash_erase_all();
.................... #Separate
.................... void mode_flash_erase_1sector();
.................... #Separate
.................... void mode_flash_copy_1sector();
.................... #Separate
.................... void mode_flash_write_1sector();
.................... #Separate
.................... void mode_flash_func2();
.................... #Separate
.................... void mode_flash_read();
.................... #Separate
.................... void mode_flash_read_address();
.................... 
.................... // IV command
.................... #Separate
.................... void mode_iv_measure();
.................... #Separate
.................... void mode_iv_measure_voltage();
.................... 
.................... 
.................... 
.................... // Development command
.................... #Separate
.................... void mode_dev_vol();
.................... #Separate
.................... void mode_dev_cur();
.................... #Separate
.................... void mode_dev_temp();   
.................... #Separate
.................... void mode_dev_pd();
.................... #Separate
.................... void mode_dev_cigs();
.................... #Separate
.................... void mode_dev_time();
.................... #Separate
.................... void mode_dev_sweep();
.................... 
.................... // ______________CMD ID________________
.................... #define ID_SWEEP 0x01
.................... 
.................... // Flash command 
.................... #define ID_FLASH_ERASE_ALL 0xA0
.................... #define ID_FLASH_ERASE_1SECTOR 0xA1
.................... #define ID_FLASH_COPY_1SECTOR 0xA2
.................... #define ID_FLASH_WRITE_1SECTOR 0xA3
.................... #define ID_FLASH_FUNC2 0xA4
.................... #define ID_FLASH_READ 0xA5
.................... #define ID_FLASH_READ_ADDRESS 0xA6
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_DEV_VOL 0xC0
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... #include "../mmj_cigs_mode.c"
.................... #include "include/mmj_cigs_func.h"
.................... #ifndef MMJ_CIGS_FUNC_H
.................... #define MMJ_CIGS_FUNC_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... /*
.................... 
.................... // Packet format
.................... #define PACKET_SIZE 64
.................... #define CHECKSUM
.................... //volatile unsigned int8 PACKET_DATA[MISSION_DATA_SIZE] = {0x00};
.................... */
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer[DATA_BUFFER_SIZE*2] = {0x00};
.................... volatile unsigned int8 cigs_data[DATA_BUFFER_SIZE*2] = {0x00};
.................... volatile unsigned int8 cigs_data_header[HEADER_SIZE] = {0x00};
.................... volatile unsigned int32 measured_time = 0;
.................... volatile unsigned int16 measured_pd_start = 0;
.................... volatile unsigned int16 measured_pd_end = 0;
.................... volatile unsigned int16 measured_temp_top = 0;
.................... volatile unsigned int16 measured_temp_bot = 0;
.................... 
.................... unsigned int32 current;
.................... 
.................... 
.................... volatile unsigned int8 packet_data[64] = {0x00};
.................... 
.................... #separate
.................... void sweep(unsigned int8 parameter[]);
.................... 
.................... void convert_cigs_data(unsigned int8 measurement_step);
.................... void convert_header_data(void); 
.................... 
.................... 
.................... #include "../mmj_cigs_func.c"
.................... #include "include/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... #include <16F1789.h>
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz, clock=16MHz)
.................... #fuses NOMCLR
.................... 
.................... 
.................... 
.................... //#define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... 
.................... //-------------Serial--------------------
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
.................... #define SPI0_CS  PIN_D1
.................... #use spi(MASTER, CLK=PIN_C3, DI=PIN_C4, DO=PIN_C5, BAUD=400000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
.................... // MISO PIN_C5, MOSI PIN_C4, SCK PIN_C3
.................... 
.................... 
.................... #define SPI1_CS PIN_C2
.................... #use spi(MASTER, SPI1, BAUD=400000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
.................... //-------------I/O port--------------------
.................... // AI/O___ADC
.................... #define TEMP_TOP PIN_A5
.................... #define TEMP_BOT PIN_A3
.................... #define CIGS_VOLT PIN_A0 //PIN_A0
.................... #define CIGS_CURR PIN_A1
.................... #define PD PIN_E0
.................... 
.................... // AI/O___DAC
.................... #define LOAD PIN_A2
.................... 
.................... // DI/O___
.................... #define CIGS_CONNECT PIN_C0
.................... #define EN_NPWR PIN_C3  //Negative Power
.................... 
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... //#include "include/mmj_cigs_func.h"
.................... #include "include/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... #define PICLOG_TIME_SIZE 4
.................... #define PICLOG_TOTAL_SIZE 6 // Time + Function + Parameter
.................... 
.................... // PICLOG
.................... typedef struct {
....................     unsigned int8 time[PICLOG_TIME_SIZE];
....................     unsigned int8 function;
....................     unsigned int8 parameter;
.................... } PICLOG;
.................... 
.................... 
.................... 
.................... void piclog_init(void);
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_read(unsigned int8 *data, unsigned int8 size);
.................... void piclog_write(unsigned int8 *data, unsigned int8 size);
.................... 
.................... 
.................... 
.................... #include "../mmj_cigs_piclog.c"
.................... #include "include/mmj_cigs_flash.h"
.................... #ifndef     MMJ_CIGS_FLASH_H
.................... #define     MMJ_CIGS_FLASH_H
.................... 
.................... void misf_init(void);
.................... void misf_read_id(void);
.................... 
.................... 
.................... 
.................... 
.................... // Flash Area
.................... 
.................... // PICLOG
.................... #define ADDRESS_PICLOG_START 0x000000
.................... #define ADDRESS_PICLOG_END   0x000FFF
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include "../mmj_cigs_flash.c"
.................... #include "../lib/flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "src/flash.c"
.................... #include "../flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "src/flash.c"
.................... 
.................... 
.................... // ADD 
.................... #define READ_ID_DATA_SIZE 20
.................... 
.................... #define MANUFACTURER_ID 0x20
.................... #define MEMORY_TYPE 0xBA
.................... #define MEMORY_CAPACITY_128M 0x18
.................... #define MEMORY_CAPACITY_1G   0x21
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////GDNS_226_FlashOperation.c////////////////////////////
.................... //////////////////////////////////ver 2.2//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////redefinition of spi communication///////////////////////
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2,write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3,write_data[spi_xfer_num]);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................          fprintf(PC, "\t->");
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................          {
....................             spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
....................             fprintf(PC, "%X ", write_data[spi_xfer_num]);
....................          }   
....................          fprintf(PC, "\r\n\t<-");
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................          {
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
....................             fprintf(PC, "%X ", read_data[spi_rcv_num]);
....................          }
....................          fprintf(PC, "\r\n");
....................          break;
....................             
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM2);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM3);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, write_data[spi_xfer_num]);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
.................... }
.................... 
.................... int8 status_register(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
....................    #ifdef DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(DEBUG_PORT,"flash busy\r\n");
....................    #endif
....................    return status_reg;  
.................... }
.................... 
.................... //
.................... //->success:True,fail:false
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 20);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"\tRead ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(DEBUG_PORT,"%x ",chip_id[print_counter]);
....................       fprintf(DEBUG_PORT,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == 0x20){  
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"\tflash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"\tflash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef DEBUG
.................... //!      fprintf(DEBUG_PORT,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
.................... //!      #ifdef DEBUG
.................... //!         fprintf(DEBUG_PORT,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
.................... //!      #ifdef DEBUG
.................... //!         fprintf(DEBUG_PORT,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash sector erase complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................    
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................    
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return;
.................... }
....................    
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... 
.................... 
.................... // ADD 
.................... #define READ_ID_DATA_SIZE 20
.................... 
.................... #define MANUFACTURER_ID 0x20
.................... #define MEMORY_TYPE 0xBA
.................... #define MEMORY_CAPACITY_128M 0x18
.................... #define MEMORY_CAPACITY_1G   0x21
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "include/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... #include <16F1789.h>
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz, clock=16MHz)
.................... #fuses NOMCLR
.................... 
.................... 
.................... 
.................... //#define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... 
.................... //-------------Serial--------------------
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
.................... #define SPI0_CS  PIN_D1
.................... #use spi(MASTER, CLK=PIN_C3, DI=PIN_C4, DO=PIN_C5, BAUD=400000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
.................... // MISO PIN_C5, MOSI PIN_C4, SCK PIN_C3
.................... 
.................... 
.................... #define SPI1_CS PIN_C2
.................... #use spi(MASTER, SPI1, BAUD=400000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
.................... //-------------I/O port--------------------
.................... // AI/O___ADC
.................... #define TEMP_TOP PIN_A5
.................... #define TEMP_BOT PIN_A3
.................... #define CIGS_VOLT PIN_A0 //PIN_A0
.................... #define CIGS_CURR PIN_A1
.................... #define PD PIN_E0
.................... 
.................... // AI/O___DAC
.................... #define LOAD PIN_A2
.................... 
.................... // DI/O___
.................... #define CIGS_CONNECT PIN_C0
.................... #define EN_NPWR PIN_C3  //Negative Power
.................... 
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... 
.................... void misf_init()
.................... {
....................     //Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
....................     fprintf(PC, "Flash Initialize\r\n");
*
0800:  MOVLW  98
0801:  MOVLB  03
0802:  MOVWF  11
0803:  MOVLW  01
0804:  MOVWF  12
0805:  MOVLP  00
0806:  MOVLB  00
0807:  CALL   6A1
0808:  MOVLP  08
....................     misf_read_id(); // Read the chip ID
....................     
....................     fprintf(PC, "\r\n\tComplete\r\n");
*
093E:  MOVLW  A2
093F:  MOVLB  03
0940:  MOVWF  11
0941:  MOVLW  01
0942:  MOVWF  12
0943:  MOVLP  00
0944:  MOVLB  00
0945:  CALL   6A1
0946:  MOVLP  08
0947:  MOVLP  08
0948:  GOTO   5F0 (RETURN)
.................... }
.................... 
.................... void misf_read_id()
.................... {
....................     unsigned int8 ans[READ_ID_DATA_SIZE] = {0}; // Array to store chip ID
*
0809:  MOVLB  10
080A:  CLRF   3D
080B:  CLRF   3E
080C:  CLRF   3F
080D:  CLRF   40
080E:  CLRF   41
080F:  CLRF   42
0810:  CLRF   43
0811:  CLRF   44
0812:  CLRF   45
0813:  CLRF   46
0814:  CLRF   47
0815:  CLRF   48
0816:  CLRF   49
0817:  CLRF   4A
0818:  CLRF   4B
0819:  CLRF   4C
081A:  CLRF   4D
081B:  CLRF   4E
081C:  CLRF   4F
081D:  CLRF   50
....................     output_low(SPI0_CS);                                                  //lower the CS PIN
081E:  MOVLB  01
081F:  BCF    0F.1
0820:  MOVLB  02
0821:  BCF    0F.1
....................     delay_ms(10);                                                   //wait for flash to be ready
0822:  MOVLW  0A
0823:  MOVLB  10
0824:  MOVWF  56
0825:  MOVLP  00
0826:  MOVLB  00
0827:  CALL   760
0828:  MOVLP  08
....................     spi_xfer(MIS_FM_STREAM,0x9E);                                           //READ ID COMAND   (0x9F)                                           //print Chip ID
0829:  MOVLB  04
082A:  BCF    15.5
082B:  MOVLW  40
082C:  MOVWF  14
082D:  MOVLW  09
082E:  MOVWF  12
082F:  MOVLW  2A
0830:  MOVWF  15
0831:  MOVLW  9E
0832:  MOVLB  10
0833:  MOVWF  58
0834:  MOVLP  00
0835:  MOVLB  00
0836:  CALL   776
0837:  MOVLP  08
....................     for (unsigned int8 i = 0; i < READ_ID_DATA_SIZE; i++) {
0838:  MOVLB  10
0839:  CLRF   51
083A:  MOVF   51,W
083B:  SUBLW  13
083C:  BTFSS  03.0
083D:  GOTO   058
....................         ans[i] = spi_xfer(MIS_FM_STREAM,0x00);                                  //read chip ID
083E:  MOVLW  1D
083F:  ADDWF  51,W
0840:  MOVWF  04
0841:  MOVLW  25
0842:  MOVWF  05
0843:  BTFSC  03.0
0844:  INCF   05,F
0845:  MOVLB  04
0846:  BCF    15.5
0847:  MOVLW  40
0848:  MOVWF  14
0849:  MOVLW  09
084A:  MOVWF  12
084B:  MOVLW  2A
084C:  MOVWF  15
084D:  MOVLB  10
084E:  CLRF   58
084F:  MOVLP  00
0850:  MOVLB  00
0851:  CALL   776
0852:  MOVLP  08
0853:  MOVF   77,W
0854:  MOVWF  00
0855:  MOVLB  10
0856:  INCF   51,F
0857:  GOTO   03A
....................         
....................     }
....................     output_high(SPI0_CS); 
0858:  MOVLB  01
0859:  BCF    0F.1
085A:  MOVLB  02
085B:  BSF    0F.1
.................... 
....................     if ( ans[0] == MANUFACTURER_ID && ans[1] == MEMORY_TYPE ){
085C:  MOVLB  10
085D:  MOVF   3D,W
085E:  SUBLW  20
085F:  BTFSS  03.2
0860:  GOTO   102
0861:  MOVF   3E,W
0862:  SUBLW  BA
0863:  BTFSS  03.2
0864:  GOTO   102
....................         if (ans[2] == MEMORY_CAPACITY_128M ) {
0865:  MOVF   3F,W
0866:  SUBLW  18
0867:  BTFSS  03.2
0868:  GOTO   074
....................             fprintf(PC, "\t[MISF] Connect success.\r\n");
0869:  MOVLW  A9
086A:  MOVLB  03
086B:  MOVWF  11
086C:  MOVLW  01
086D:  MOVWF  12
086E:  MOVLP  00
086F:  MOVLB  00
0870:  CALL   6A1
0871:  MOVLP  08
....................         } else if (ans[2] == MEMORY_CAPACITY_1G) {
0872:  GOTO   100
0873:  MOVLB  10
0874:  MOVF   3F,W
0875:  SUBLW  21
0876:  BTFSS  03.2
0877:  GOTO   0C4
....................                 fprintf(PC, "\t[MISF] <- 9F\r\n"); 
0878:  MOVLW  B7
0879:  MOVLB  03
087A:  MOVWF  11
087B:  MOVLW  01
087C:  MOVWF  12
087D:  MOVLP  00
087E:  MOVLB  00
087F:  CALL   6A1
0880:  MOVLP  08
....................             fprintf(PC, "\t[MISF] -> ");
0881:  MOVLW  BF
0882:  MOVLB  03
0883:  MOVWF  11
0884:  MOVLW  01
0885:  MOVWF  12
0886:  MOVLP  00
0887:  MOVLB  00
0888:  CALL   6A1
0889:  MOVLP  08
....................             for (unsigned int8 i = 0; i < READ_ID_DATA_SIZE; i++) {
088A:  MOVLB  10
088B:  CLRF   52
088C:  MOVF   52,W
088D:  SUBLW  13
088E:  BTFSS  03.0
088F:  GOTO   0AB
....................                 fprintf(PC, "%02X ", ans[i]);                                         //print chip ID
0890:  MOVLW  1D
0891:  ADDWF  52,W
0892:  MOVWF  04
0893:  MOVLW  25
0894:  MOVWF  05
0895:  BTFSC  03.0
0896:  INCF   05,F
0897:  MOVF   00,W
0898:  MOVWF  56
0899:  MOVLB  11
089A:  MOVWF  27
089B:  MOVLW  37
089C:  MOVWF  28
089D:  MOVLP  00
089E:  MOVLB  00
089F:  CALL   783
08A0:  MOVLP  08
08A1:  MOVLW  20
08A2:  MOVLB  11
08A3:  MOVWF  2B
08A4:  MOVLP  00
08A5:  MOVLB  00
08A6:  CALL   67C
08A7:  MOVLP  08
08A8:  MOVLB  10
08A9:  INCF   52,F
08AA:  GOTO   08C
....................             }
....................             fprintf(PC, "\r\n");
08AB:  MOVLW  0D
08AC:  MOVLB  11
08AD:  MOVWF  2B
08AE:  MOVLP  00
08AF:  MOVLB  00
08B0:  CALL   67C
08B1:  MOVLP  08
08B2:  MOVLW  0A
08B3:  MOVLB  11
08B4:  MOVWF  2B
08B5:  MOVLP  00
08B6:  MOVLB  00
08B7:  CALL   67C
08B8:  MOVLP  08
....................             fprintf(PC, "\t[MISF] MEMORY_CAPACITY error! This is SMF\r\n");
08B9:  MOVLW  C5
08BA:  MOVLB  03
08BB:  MOVWF  11
08BC:  MOVLW  01
08BD:  MOVWF  12
08BE:  MOVLP  00
08BF:  MOVLB  00
08C0:  CALL   6A1
08C1:  MOVLP  08
.................... 
....................         } else{
08C2:  GOTO   100
08C3:  MOVLB  10
....................             fprintf(PC, "\t[MISF] <- 9F\r\n"); 
08C4:  MOVLW  DC
08C5:  MOVLB  03
08C6:  MOVWF  11
08C7:  MOVLW  01
08C8:  MOVWF  12
08C9:  MOVLP  00
08CA:  MOVLB  00
08CB:  CALL   6A1
08CC:  MOVLP  08
....................             fprintf(PC, "\t[MISF] -> ");
08CD:  MOVLW  E4
08CE:  MOVLB  03
08CF:  MOVWF  11
08D0:  MOVLW  01
08D1:  MOVWF  12
08D2:  MOVLP  00
08D3:  MOVLB  00
08D4:  CALL   6A1
08D5:  MOVLP  08
....................             for (unsigned int8 i = 0; i < READ_ID_DATA_SIZE; i++) {
08D6:  MOVLB  10
08D7:  CLRF   53
08D8:  MOVF   53,W
08D9:  SUBLW  13
08DA:  BTFSS  03.0
08DB:  GOTO   0F7
....................                 fprintf(PC, "%02X ", ans[i]);                                         //print chip ID
08DC:  MOVLW  1D
08DD:  ADDWF  53,W
08DE:  MOVWF  04
08DF:  MOVLW  25
08E0:  MOVWF  05
08E1:  BTFSC  03.0
08E2:  INCF   05,F
08E3:  MOVF   00,W
08E4:  MOVWF  56
08E5:  MOVLB  11
08E6:  MOVWF  27
08E7:  MOVLW  37
08E8:  MOVWF  28
08E9:  MOVLP  00
08EA:  MOVLB  00
08EB:  CALL   783
08EC:  MOVLP  08
08ED:  MOVLW  20
08EE:  MOVLB  11
08EF:  MOVWF  2B
08F0:  MOVLP  00
08F1:  MOVLB  00
08F2:  CALL   67C
08F3:  MOVLP  08
08F4:  MOVLB  10
08F5:  INCF   53,F
08F6:  GOTO   0D8
....................             }
....................             fprintf(PC, "\r\n\t[MISF] MEMORY_CAPACITY error! Chip ID is invalid\r\n");
08F7:  MOVLW  EA
08F8:  MOVLB  03
08F9:  MOVWF  11
08FA:  MOVLW  01
08FB:  MOVWF  12
08FC:  MOVLP  00
08FD:  MOVLB  00
08FE:  CALL   6A1
08FF:  MOVLP  08
....................         }
....................     } else {
0900:  GOTO   13E
0901:  MOVLB  10
....................             fprintf(PC, "\t[MISF] <- 9F\r\n"); 
0902:  MOVLW  05
0903:  MOVLB  03
0904:  MOVWF  11
0905:  MOVLW  02
0906:  MOVWF  12
0907:  MOVLP  00
0908:  MOVLB  00
0909:  CALL   6A1
090A:  MOVLP  08
....................             fprintf(PC, "\t[MISF] -> ");
090B:  MOVLW  0D
090C:  MOVLB  03
090D:  MOVWF  11
090E:  MOVLW  02
090F:  MOVWF  12
0910:  MOVLP  00
0911:  MOVLB  00
0912:  CALL   6A1
0913:  MOVLP  08
....................             for (unsigned int8 i = 0; i < READ_ID_DATA_SIZE; i++) {
0914:  MOVLB  10
0915:  CLRF   54
0916:  MOVF   54,W
0917:  SUBLW  13
0918:  BTFSS  03.0
0919:  GOTO   135
....................                 fprintf(PC, "%02X ", ans[i]);                                         //print chip ID
091A:  MOVLW  1D
091B:  ADDWF  54,W
091C:  MOVWF  04
091D:  MOVLW  25
091E:  MOVWF  05
091F:  BTFSC  03.0
0920:  INCF   05,F
0921:  MOVF   00,W
0922:  MOVWF  56
0923:  MOVLB  11
0924:  MOVWF  27
0925:  MOVLW  37
0926:  MOVWF  28
0927:  MOVLP  00
0928:  MOVLB  00
0929:  CALL   783
092A:  MOVLP  08
092B:  MOVLW  20
092C:  MOVLB  11
092D:  MOVWF  2B
092E:  MOVLP  00
092F:  MOVLB  00
0930:  CALL   67C
0931:  MOVLP  08
0932:  MOVLB  10
0933:  INCF   54,F
0934:  GOTO   116
....................             }
....................             fprintf(PC, "\r\n\t[MISF] Chip ID is invalid\r\n");
0935:  MOVLW  13
0936:  MOVLB  03
0937:  MOVWF  11
0938:  MOVLW  02
0939:  MOVWF  12
093A:  MOVLP  00
093B:  MOVLB  00
093C:  CALL   6A1
093D:  MOVLP  08
....................     } 
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... #include "include/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... #define PICLOG_TIME_SIZE 4
.................... #define PICLOG_TOTAL_SIZE 6 // Time + Function + Parameter
.................... 
.................... // PICLOG
.................... typedef struct {
....................     unsigned int8 time[PICLOG_TIME_SIZE];
....................     unsigned int8 function;
....................     unsigned int8 parameter;
.................... } PICLOG;
.................... 
.................... 
.................... 
.................... void piclog_init(void);
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... void piclog_read(unsigned int8 *data, unsigned int8 size);
.................... void piclog_write(unsigned int8 *data, unsigned int8 size);
.................... 
.................... 
.................... 
.................... #include "../mmj_cigs_piclog.c"
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... PICLOG piclog_data;
.................... 
.................... void piclog_init()
.................... {
....................     //PICLOG piclog_data = {0}; // Initialize PICLOG structure
.................... 
.................... }
.................... 
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter)
.................... {
....................     piclog_init(); // 
.................... 
....................     // 
....................     // : get_current_time_array(piclog_data.time);
....................     for (int i = 0; i < PICLOG_TIME_SIZE; i++) {
....................         piclog_data.time[i] = 0; // 
....................     }
....................     piclog_data.function = function;
....................     piclog_data.parameter = parameter;
.................... 
....................     // 
....................     piclog_write((unsigned int8 *)&piclog_data, PICLOG_TOTAL_SIZE);
....................     fprintf(PC, "PICLOG data written: Function %d, Parameter %d\r\n", function, parameter);
.................... }
.................... 
.................... void piclog_write()
.................... {
....................     // Assuming a function to write data to flash
....................     //write_data_bytes(MIS_FM_STREAM, ADDRESS_PICLOG_START, data, size);
....................     
....................     fprintf(PC, "PICLOG data written successfully\r\n");
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void io_init()
.................... {
....................     fprintf(PC, "IO Initialize\r\n");
*
06EF:  MOVLW  4E
06F0:  MOVLB  03
06F1:  MOVWF  11
06F2:  MOVLW  02
06F3:  MOVWF  12
06F4:  MOVLB  00
06F5:  CALL   6A1
....................     output_low(CIGS_CONNECT);
06F6:  MOVLB  01
06F7:  BCF    0E.0
06F8:  MOVLB  02
06F9:  BCF    0E.0
....................     output_low(EN_NPWR);
06FA:  MOVLB  01
06FB:  BCF    0E.3
06FC:  MOVLB  02
06FD:  BCF    0E.3
....................     fprintf(PC, "\tComplete\r\n");
06FE:  MOVLW  56
06FF:  MOVLB  03
0700:  MOVWF  11
0701:  MOVLW  02
0702:  MOVWF  12
0703:  MOVLB  00
0704:  CALL   6A1
0705:  MOVLP  08
0706:  GOTO   5E5 (RETURN)
.................... }
.................... 
.................... void adc_init()
.................... {
....................    fprintf(PC, "ADC Initialize\r\n");
0707:  MOVLW  5C
0708:  MOVLB  03
0709:  MOVWF  11
070A:  MOVLW  02
070B:  MOVWF  12
070C:  MOVLB  00
070D:  CALL   6A1
....................     //setup ADC
....................    setup_oscillator(OSC_16MHZ);   //oscillator speed (crystal)
070E:  MOVLW  78
070F:  MOVLB  01
0710:  MOVWF  19
....................    setup_adc_ports(CIGS_VOLT | CIGS_CURR | TEMP_BOT | TEMP_TOP | PD , VSS_VDD);
0711:  BCF    1E.0
0712:  BCF    1E.1
0713:  BCF    1E.2
0714:  MOVLW  00
0715:  MOVLB  03
0716:  MOVWF  0C
0717:  MOVWF  10
0718:  MOVWF  0D
0719:  MOVLW  E7
071A:  MOVWF  0F
....................    setup_adc(ADC_CLOCK_DIV_64);
071B:  MOVLB  01
071C:  BCF    1E.4
071D:  BSF    1E.5
071E:  BSF    1E.6
071F:  BSF    1E.7
0720:  BSF    1D.0
.................... 
....................    //setup DAC
....................    setup_dac(DAC_OUTPUT1 | DAC_VSS_VDD);                                        //DAC output at pin DAC output1 from 0-VDD volts  
0721:  MOVLW  A0
0722:  MOVLB  02
0723:  MOVWF  18
....................    dac_write(50);                                                               
0724:  MOVLW  32
0725:  MOVWF  19
....................    fprintf(PC, "\tComplete\r\n");
0726:  MOVLW  65
0727:  MOVLB  03
0728:  MOVWF  11
0729:  MOVLW  02
072A:  MOVWF  12
072B:  MOVLB  00
072C:  CALL   6A1
072D:  MOVLP  08
072E:  GOTO   5E8 (RETURN)
.................... }
.................... 
.................... #Separate
.................... void sweep(unsigned int8 parameter)
.................... {
.................... 
....................     fprintf(PC, "Start SWEEP\r\n");
*
1000:  MOVLW  6B
1001:  MOVLB  03
1002:  MOVWF  11
1003:  MOVLW  02
1004:  MOVWF  12
1005:  MOVLP  00
1006:  MOVLB  00
1007:  CALL   6A1
1008:  MOVLP  10
....................     unsigned int8 measurement_step = parameter; // Get the measurement step from the parameter array
1009:  MOVLB  10
100A:  MOVF   4C,W
100B:  MOVWF  4D
....................     fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
100C:  MOVLW  72
100D:  MOVLB  03
100E:  MOVWF  11
100F:  MOVLW  02
1010:  MOVWF  12
1011:  BCF    03.0
1012:  MOVLW  0E
1013:  MOVLB  11
1014:  MOVWF  27
1015:  MOVLP  08
1016:  MOVLB  00
1017:  CALL   149
1018:  MOVLP  10
1019:  MOVLB  10
101A:  MOVF   4D,W
101B:  MOVWF  52
101C:  MOVLW  1B
101D:  MOVWF  53
*
1067:  MOVLW  0D
1068:  MOVLB  11
1069:  MOVWF  2B
106A:  MOVLP  00
106B:  MOVLB  00
106C:  CALL   67C
106D:  MOVLP  10
106E:  MOVLW  0A
106F:  MOVLB  11
1070:  MOVWF  2B
1071:  MOVLP  00
1072:  MOVLB  00
1073:  CALL   67C
1074:  MOVLP  10
....................     output_high(CIGS_CONNECT);
1075:  MOVLB  01
1076:  BCF    0E.0
1077:  MOVLB  02
1078:  BSF    0E.0
.................... 
....................     // read temperature
....................     set_adc_channel(TEMP_TOP);
1079:  MOVLW  14
107A:  MOVWF  78
107B:  MOVLB  01
107C:  MOVF   1D,W
107D:  ANDLW  83
107E:  IORWF  78,W
107F:  MOVWF  1D
1080:  MOVLW  0F
1081:  MOVWF  78
1082:  MOVF   1F,W
1083:  ANDLW  F0
1084:  IORWF  78,W
1085:  MOVWF  1F
....................     delay_us(10); // wait for the ADC to stabilize
1086:  MOVLW  0D
1087:  MOVWF  77
1088:  DECFSZ 77,F
1089:  GOTO   088
....................     measured_temp_top = read_adc(ADC_START_AND_READ); // read voltage at adc pin
108A:  BSF    1D.1
108B:  BTFSC  1D.1
108C:  GOTO   08B
108D:  MOVF   1B,W
108E:  MOVWF  78
108F:  MOVF   1C,W
1090:  MOVLB  0C
1091:  MOVWF  32
1092:  MOVF   78,W
1093:  MOVWF  31
....................     set_adc_channel(TEMP_BOT);
1094:  MOVLW  0C
1095:  MOVWF  78
1096:  MOVLB  01
1097:  MOVF   1D,W
1098:  ANDLW  83
1099:  IORWF  78,W
109A:  MOVWF  1D
109B:  MOVLW  0F
109C:  MOVWF  78
109D:  MOVF   1F,W
109E:  ANDLW  F0
109F:  IORWF  78,W
10A0:  MOVWF  1F
....................     delay_us(10); // wait for the ADC to stabilize
10A1:  MOVLW  0D
10A2:  MOVWF  77
10A3:  DECFSZ 77,F
10A4:  GOTO   0A3
....................     measured_temp_bot = read_adc(ADC_START_AND_READ); // read voltage at adc pin
10A5:  BSF    1D.1
10A6:  BTFSC  1D.1
10A7:  GOTO   0A6
10A8:  MOVF   1B,W
10A9:  MOVWF  78
10AA:  MOVF   1C,W
10AB:  MOVLB  0C
10AC:  MOVWF  34
10AD:  MOVF   78,W
10AE:  MOVWF  33
.................... 
....................     // read PD value
....................     set_adc_channel(PD);
10AF:  MOVLW  00
10B0:  MOVWF  78
10B1:  MOVLB  01
10B2:  MOVF   1D,W
10B3:  ANDLW  83
10B4:  IORWF  78,W
10B5:  MOVWF  1D
10B6:  MOVLW  0F
10B7:  MOVWF  78
10B8:  MOVF   1F,W
10B9:  ANDLW  F0
10BA:  IORWF  78,W
10BB:  MOVWF  1F
....................     delay_us(10); // wait for the ADC to stabilize
10BC:  MOVLW  0D
10BD:  MOVWF  77
10BE:  DECFSZ 77,F
10BF:  GOTO   0BE
....................     measured_pd_start = read_adc(ADC_START_AND_READ); // read voltage at adc pin
10C0:  BSF    1D.1
10C1:  BTFSC  1D.1
10C2:  GOTO   0C1
10C3:  MOVF   1B,W
10C4:  MOVWF  78
10C5:  MOVF   1C,W
10C6:  MOVLB  0C
10C7:  MOVWF  2E
10C8:  MOVF   78,W
10C9:  MOVWF  2D
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................     // CIGS value
....................     for (unsigned int16 count = 0; count < measurement_step; count++)
10CA:  MOVLB  10
10CB:  CLRF   4F
10CC:  CLRF   4E
10CD:  MOVF   4F,F
10CE:  BTFSS  03.2
10CF:  GOTO   1BF
10D0:  MOVF   4D,W
10D1:  SUBWF  4E,W
10D2:  BTFSC  03.0
10D3:  GOTO   1BF
....................     {    
....................         // set DAC value
....................         dac_write(count);
10D4:  MOVF   4E,W
10D5:  MOVLB  02
10D6:  MOVWF  19
....................         delay_us(100); // wait for the DAC to stabilize
10D7:  MOVLW  85
10D8:  MOVWF  77
10D9:  DECFSZ 77,F
10DA:  GOTO   0D9
.................... 
....................         // read CIGS voltage and current
....................         set_adc_channel(CIGS_VOLT);       
10DB:  MOVLW  00
10DC:  MOVWF  78
10DD:  MOVLB  01
10DE:  MOVF   1D,W
10DF:  ANDLW  83
10E0:  IORWF  78,W
10E1:  MOVWF  1D
10E2:  MOVLW  0F
10E3:  MOVWF  78
10E4:  MOVF   1F,W
10E5:  ANDLW  F0
10E6:  IORWF  78,W
10E7:  MOVWF  1F
....................         delay_us(10); // wait for the ADC to stabilize
10E8:  MOVLW  0D
10E9:  MOVWF  77
10EA:  DECFSZ 77,F
10EB:  GOTO   0EA
....................         data_buffer[count*2] = read_adc(ADC_START_AND_READ);  // read voltage at adc pin
10EC:  BCF    03.0
10ED:  MOVLB  10
10EE:  RLF    4E,W
10EF:  MOVWF  52
10F0:  RLF    4F,W
10F1:  MOVWF  53
10F2:  BCF    03.0
10F3:  RLF    52,W
10F4:  MOVWF  79
10F5:  RLF    53,W
10F6:  MOVWF  7A
10F7:  MOVF   79,W
10F8:  ADDLW  39
10F9:  MOVWF  04
10FA:  MOVLW  20
10FB:  ADDWFC 7A,W
10FC:  MOVWF  05
10FD:  MOVLB  01
10FE:  BSF    1D.1
10FF:  BTFSC  1D.1
1100:  GOTO   0FF
1101:  MOVF   1B,W
1102:  MOVWF  00
1103:  MOVF   1C,W
1104:  MOVWI  W,[FSR0+01]
....................         
....................         set_adc_channel(CIGS_CURR);
1105:  MOVLW  04
1106:  MOVWF  78
1107:  MOVF   1D,W
1108:  ANDLW  83
1109:  IORWF  78,W
110A:  MOVWF  1D
110B:  MOVLW  0F
110C:  MOVWF  78
110D:  MOVF   1F,W
110E:  ANDLW  F0
110F:  IORWF  78,W
1110:  MOVWF  1F
....................         current = 0; // reset current value
1111:  MOVLB  0C
1112:  CLRF   38
1113:  CLRF   37
1114:  CLRF   36
1115:  CLRF   35
....................         for(int k=0; k<10; k++)
1116:  MOVLB  10
1117:  CLRF   50
1118:  MOVF   50,W
1119:  SUBLW  09
111A:  BTFSS  03.0
111B:  GOTO   131
....................         {
....................                                             //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
111C:  MOVLW  0D
111D:  MOVWF  77
111E:  DECFSZ 77,F
111F:  GOTO   11E
....................             current = current + read_adc(ADC_START_AND_READ);
1120:  MOVLB  01
1121:  BSF    1D.1
1122:  BTFSC  1D.1
1123:  GOTO   122
1124:  MOVF   1C,W
1125:  MOVWF  7A
1126:  MOVF   1B,W
1127:  MOVLB  0C
1128:  ADDWF  35,F
1129:  MOVF   7A,W
112A:  ADDWFC 36,F
112B:  MOVLW  00
112C:  ADDWFC 37,F
112D:  ADDWFC 38,F
112E:  MOVLB  10
112F:  INCF   50,F
1130:  GOTO   118
....................         }    
....................         
....................         current = current / 10; // average the current value
1131:  BCF    03.1
1132:  MOVLB  0C
1133:  MOVF   38,W
1134:  MOVLB  10
1135:  MOVWF  55
1136:  MOVLB  0C
1137:  MOVF   37,W
1138:  MOVLB  10
1139:  MOVWF  54
113A:  MOVLB  0C
113B:  MOVF   36,W
113C:  MOVLB  10
113D:  MOVWF  53
113E:  MOVLB  0C
113F:  MOVF   35,W
1140:  MOVLB  10
1141:  MOVWF  52
1142:  CLRF   59
1143:  CLRF   58
1144:  CLRF   57
1145:  MOVLW  0A
1146:  MOVWF  56
*
1193:  MOVF   7A,W
1194:  MOVLB  0C
1195:  MOVWF  38
1196:  MOVF   79,W
1197:  MOVWF  37
1198:  MOVF   78,W
1199:  MOVWF  36
119A:  MOVF   77,W
119B:  MOVWF  35
.................... 
....................         delay_us(10); // wait for the ADC to stabilize
119C:  MOVLW  0D
119D:  MOVWF  77
119E:  DECFSZ 77,F
119F:  GOTO   19E
....................         data_buffer[count*2+1] = current; // store the current value in the buffer
11A0:  BCF    03.0
11A1:  MOVLB  10
11A2:  RLF    4E,W
11A3:  MOVWF  52
11A4:  RLF    4F,W
11A5:  MOVWF  53
11A6:  MOVLW  01
11A7:  ADDWF  52,F
11A8:  MOVLW  00
11A9:  ADDWFC 53,F
11AA:  BCF    03.0
11AB:  RLF    52,W
11AC:  MOVWF  79
11AD:  RLF    53,W
11AE:  MOVWF  7A
11AF:  MOVF   79,W
11B0:  ADDLW  39
11B1:  MOVWF  04
11B2:  MOVLW  20
11B3:  ADDWFC 7A,W
11B4:  MOVWF  05
11B5:  MOVLB  0C
11B6:  MOVF   35,W
11B7:  MOVWF  00
11B8:  MOVF   36,W
11B9:  MOVWI  W,[FSR0+01]
11BA:  MOVLB  10
11BB:  INCF   4E,F
11BC:  BTFSC  03.2
11BD:  INCF   4F,F
11BE:  GOTO   0CD
....................         //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................     }
.................... 
....................     fprintf(PC, "END SWEEP\r\n");
11BF:  MOVLW  7C
11C0:  MOVLB  03
11C1:  MOVWF  11
11C2:  MOVLW  02
11C3:  MOVWF  12
11C4:  MOVLP  00
11C5:  MOVLB  00
11C6:  CALL   6A1
11C7:  MOVLP  10
....................     // read PD value
....................     set_adc_channel(PD);
11C8:  MOVLW  00
11C9:  MOVWF  78
11CA:  MOVLB  01
11CB:  MOVF   1D,W
11CC:  ANDLW  83
11CD:  IORWF  78,W
11CE:  MOVWF  1D
11CF:  MOVLW  0F
11D0:  MOVWF  78
11D1:  MOVF   1F,W
11D2:  ANDLW  F0
11D3:  IORWF  78,W
11D4:  MOVWF  1F
....................     measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
11D5:  BSF    1D.1
11D6:  BTFSC  1D.1
11D7:  GOTO   1D6
11D8:  MOVF   1B,W
11D9:  MOVWF  78
11DA:  MOVF   1C,W
11DB:  MOVLB  0C
11DC:  MOVWF  30
11DD:  MOVF   78,W
11DE:  MOVWF  2F
.................... 
....................     convert_cigs_data(measurement_step);
11DF:  MOVLB  10
11E0:  MOVF   4D,W
11E1:  MOVWF  52
....................     //convert_header_data();    
....................     output_low(CIGS_CONNECT);
*
1339:  MOVLB  01
133A:  BCF    0E.0
133B:  MOVLB  02
133C:  BCF    0E.0
133D:  MOVLP  08
133E:  MOVLB  00
133F:  GOTO   52C (RETURN)
.................... }
.................... 
.................... 
.................... void convert_cigs_data(unsigned int8 measurement_step)
.................... {
....................     fprintf(PC, "Logged CIGS data\r\n");
*
11E2:  MOVLW  82
11E3:  MOVLB  03
11E4:  MOVWF  11
11E5:  MOVLW  02
11E6:  MOVWF  12
11E7:  MOVLP  00
11E8:  MOVLB  00
11E9:  CALL   6A1
11EA:  MOVLP  10
....................     // unsigned int8 measurement_step = 100;
....................     // Save CIGS data to memory
....................     for (unsigned int8 i = 0; i < measurement_step; i++)
11EB:  MOVLB  10
11EC:  CLRF   53
11ED:  MOVF   52,W
11EE:  SUBWF  53,W
11EF:  BTFSC  03.0
11F0:  GOTO   32B
....................     {
....................         cigs_data[i*3]      = (data_buffer[i*2] >> 4) & 0xFF;
11F1:  MOVF   53,W
11F2:  MOVWF  58
11F3:  MOVLW  03
11F4:  MOVWF  59
11F5:  MOVLP  08
11F6:  MOVLB  00
11F7:  CALL   4F0
11F8:  MOVLP  10
11F9:  MOVLW  91
11FA:  ADDWF  78,W
11FB:  MOVWF  78
11FC:  MOVLW  22
11FD:  MOVWF  7A
11FE:  BTFSC  03.0
11FF:  INCF   7A,F
1200:  MOVF   78,W
1201:  MOVLB  10
1202:  MOVWF  58
1203:  MOVF   7A,W
1204:  MOVWF  59
1205:  BCF    03.0
1206:  RLF    53,W
1207:  CLRF   7A
1208:  MOVWF  79
1209:  BCF    03.0
120A:  RLF    79,F
120B:  RLF    7A,F
120C:  MOVF   79,W
120D:  ADDLW  39
120E:  MOVWF  04
120F:  MOVLW  20
1210:  ADDWFC 7A,W
1211:  MOVWF  05
1212:  MOVF   00,W
1213:  MOVWF  5A
1214:  ADDFSR 01,FSR0
1215:  MOVF   00,W
1216:  MOVWF  5B
1217:  ADDFSR 3F,FSR0
1218:  RRF    5B,F
1219:  RRF    5A,F
121A:  RRF    5B,F
121B:  RRF    5A,F
121C:  RRF    5B,F
121D:  RRF    5A,F
121E:  RRF    5B,F
121F:  RRF    5A,F
1220:  MOVLW  0F
1221:  ANDWF  5B,F
1222:  MOVF   5A,W
1223:  MOVWF  77
1224:  CLRF   7A
1225:  MOVF   7A,W
1226:  MOVWF  5B
1227:  MOVF   59,W
1228:  MOVWF  05
1229:  MOVF   58,W
122A:  MOVWF  04
122B:  MOVF   5A,W
122C:  MOVWF  00
....................         fprintf(PC, "%X ", cigs_data[i*3]);
122D:  MOVF   53,W
122E:  MOVWF  58
122F:  MOVLW  03
1230:  MOVWF  59
1231:  MOVLP  08
1232:  MOVLB  00
1233:  CALL   4F0
1234:  MOVLP  10
1235:  MOVLW  91
1236:  ADDWF  78,W
1237:  MOVWF  04
1238:  MOVLW  22
1239:  MOVWF  05
123A:  BTFSC  03.0
123B:  INCF   05,F
123C:  MOVF   00,W
123D:  MOVLB  10
123E:  MOVWF  58
123F:  MOVLB  11
1240:  MOVWF  27
1241:  MOVLW  37
1242:  MOVWF  28
1243:  MOVLP  00
1244:  MOVLB  00
1245:  CALL   783
1246:  MOVLP  10
1247:  MOVLW  20
1248:  MOVLB  11
1249:  MOVWF  2B
124A:  MOVLP  00
124B:  MOVLB  00
124C:  CALL   67C
124D:  MOVLP  10
....................         cigs_data[i*3+1]    = (data_buffer[i*2] & 0x0F) << 4 | (data_buffer[i*2+1] >>8 )& 0x0F;
124E:  MOVLB  10
124F:  MOVF   53,W
1250:  MOVWF  58
1251:  MOVLW  03
1252:  MOVWF  59
1253:  MOVLP  08
1254:  MOVLB  00
1255:  CALL   4F0
1256:  MOVLP  10
1257:  MOVLW  01
1258:  ADDWF  78,W
1259:  ADDLW  91
125A:  MOVWF  78
125B:  MOVLW  22
125C:  MOVWF  7A
125D:  BTFSC  03.0
125E:  INCF   7A,F
125F:  MOVF   78,W
1260:  MOVLB  10
1261:  MOVWF  58
1262:  MOVF   7A,W
1263:  MOVWF  59
1264:  BCF    03.0
1265:  RLF    53,W
1266:  CLRF   7A
1267:  MOVWF  79
1268:  BCF    03.0
1269:  RLF    79,F
126A:  RLF    7A,F
126B:  MOVF   79,W
126C:  ADDLW  39
126D:  MOVWF  04
126E:  MOVLW  20
126F:  ADDWFC 7A,W
1270:  MOVWF  05
1271:  MOVF   00,W
1272:  MOVWF  5A
1273:  ADDFSR 01,FSR0
1274:  MOVF   00,W
1275:  MOVWF  5B
1276:  ADDFSR 3F,FSR0
1277:  MOVLW  0F
1278:  ANDWF  5A,F
1279:  CLRF   5B
127A:  RLF    5A,F
127B:  RLF    5B,F
127C:  RLF    5A,F
127D:  RLF    5B,F
127E:  RLF    5A,F
127F:  RLF    5B,F
1280:  RLF    5A,F
1281:  RLF    5B,F
1282:  MOVLW  F0
1283:  ANDWF  5A,F
1284:  BCF    03.0
1285:  RLF    53,W
1286:  ADDLW  01
1287:  CLRF   7A
1288:  MOVWF  79
1289:  BCF    03.0
128A:  RLF    79,F
128B:  RLF    7A,F
128C:  MOVF   79,W
128D:  ADDLW  39
128E:  MOVWF  04
128F:  MOVLW  20
1290:  ADDWFC 7A,W
1291:  MOVWF  05
1292:  MOVF   00,W
1293:  MOVWF  5C
1294:  ADDFSR 01,FSR0
1295:  MOVF   00,W
1296:  MOVWF  5D
1297:  ADDFSR 3F,FSR0
1298:  MOVF   5D,W
1299:  MOVWF  5C
129A:  CLRF   5D
129B:  MOVF   5C,W
129C:  ANDLW  0F
129D:  MOVWF  77
129E:  CLRF   7A
129F:  MOVF   77,W
12A0:  IORWF  5A,W
12A1:  MOVWF  77
12A2:  MOVF   7A,W
12A3:  IORWF  5B,W
12A4:  MOVWF  7A
12A5:  MOVF   77,W
12A6:  MOVWF  5A
12A7:  MOVF   7A,W
12A8:  MOVWF  5B
12A9:  MOVF   59,W
12AA:  MOVWF  05
12AB:  MOVF   58,W
12AC:  MOVWF  04
12AD:  MOVF   5A,W
12AE:  MOVWF  00
....................         fprintf(PC, "%X ", cigs_data[i*3+1]);
12AF:  MOVF   53,W
12B0:  MOVWF  58
12B1:  MOVLW  03
12B2:  MOVWF  59
12B3:  MOVLP  08
12B4:  MOVLB  00
12B5:  CALL   4F0
12B6:  MOVLP  10
12B7:  MOVLW  01
12B8:  ADDWF  78,W
12B9:  ADDLW  91
12BA:  MOVWF  04
12BB:  MOVLW  22
12BC:  MOVWF  05
12BD:  BTFSC  03.0
12BE:  INCF   05,F
12BF:  MOVF   00,W
12C0:  MOVLB  10
12C1:  MOVWF  58
12C2:  MOVLB  11
12C3:  MOVWF  27
12C4:  MOVLW  37
12C5:  MOVWF  28
12C6:  MOVLP  00
12C7:  MOVLB  00
12C8:  CALL   783
12C9:  MOVLP  10
12CA:  MOVLW  20
12CB:  MOVLB  11
12CC:  MOVWF  2B
12CD:  MOVLP  00
12CE:  MOVLB  00
12CF:  CALL   67C
12D0:  MOVLP  10
....................         cigs_data[i*3+2]    = data_buffer[i*2+1] & 0xFF;
12D1:  MOVLB  10
12D2:  MOVF   53,W
12D3:  MOVWF  58
12D4:  MOVLW  03
12D5:  MOVWF  59
12D6:  MOVLP  08
12D7:  MOVLB  00
12D8:  CALL   4F0
12D9:  MOVLP  10
12DA:  MOVLW  02
12DB:  ADDWF  78,W
12DC:  ADDLW  91
12DD:  MOVWF  78
12DE:  MOVLW  22
12DF:  MOVWF  7A
12E0:  BTFSC  03.0
12E1:  INCF   7A,F
12E2:  MOVF   78,W
12E3:  MOVLB  10
12E4:  MOVWF  58
12E5:  MOVF   7A,W
12E6:  MOVWF  59
12E7:  BCF    03.0
12E8:  RLF    53,W
12E9:  ADDLW  01
12EA:  CLRF   7A
12EB:  MOVWF  79
12EC:  BCF    03.0
12ED:  RLF    79,F
12EE:  RLF    7A,F
12EF:  MOVF   79,W
12F0:  ADDLW  39
12F1:  MOVWF  04
12F2:  MOVLW  20
12F3:  ADDWFC 7A,W
12F4:  MOVWF  05
12F5:  MOVF   00,W
12F6:  MOVWF  5A
12F7:  ADDFSR 01,FSR0
12F8:  MOVF   00,W
12F9:  MOVWF  5B
12FA:  ADDFSR 3F,FSR0
12FB:  MOVF   5A,W
12FC:  MOVWF  77
12FD:  CLRF   7A
12FE:  MOVF   7A,W
12FF:  MOVWF  5B
1300:  MOVF   59,W
1301:  MOVWF  05
1302:  MOVF   58,W
1303:  MOVWF  04
1304:  MOVF   5A,W
1305:  MOVWF  00
....................         fprintf(PC, "%X ", cigs_data[i*3+2]);
1306:  MOVF   53,W
1307:  MOVWF  58
1308:  MOVLW  03
1309:  MOVWF  59
130A:  MOVLP  08
130B:  MOVLB  00
130C:  CALL   4F0
130D:  MOVLP  10
130E:  MOVLW  02
130F:  ADDWF  78,W
1310:  ADDLW  91
1311:  MOVWF  04
1312:  MOVLW  22
1313:  MOVWF  05
1314:  BTFSC  03.0
1315:  INCF   05,F
1316:  MOVF   00,W
1317:  MOVLB  10
1318:  MOVWF  58
1319:  MOVLB  11
131A:  MOVWF  27
131B:  MOVLW  37
131C:  MOVWF  28
131D:  MOVLP  00
131E:  MOVLB  00
131F:  CALL   783
1320:  MOVLP  10
1321:  MOVLW  20
1322:  MOVLB  11
1323:  MOVWF  2B
1324:  MOVLP  00
1325:  MOVLB  00
1326:  CALL   67C
1327:  MOVLP  10
1328:  MOVLB  10
1329:  INCF   53,F
132A:  GOTO   1ED
....................     }
....................     /*
....................     fprintf(PC, "Logging CIGS data\r\n");
....................     for (unsigned int16 j = 0; j < measurement_step*3; j++)
....................     {
....................         fprintf(PC, "%X ", cigs_data[j]);
....................     }
....................     */
....................    fprintf(PC, "\r\n");
132B:  MOVLW  0D
132C:  MOVLB  11
132D:  MOVWF  2B
132E:  MOVLP  00
132F:  MOVLB  00
1330:  CALL   67C
1331:  MOVLP  10
1332:  MOVLW  0A
1333:  MOVLB  11
1334:  MOVWF  2B
1335:  MOVLP  00
1336:  MOVLB  00
1337:  CALL   67C
1338:  MOVLP  10
.................... }
.................... 
.................... 
.................... void convert_header_data()
.................... {    
....................     // Save CIGS data header
....................     cigs_data_header[0] = 0xFF; // Header start
....................     cigs_data_header[1] = 0x0F; // Header start
.................... 
....................     // Save measurement start time
....................     cigs_data_header[2] = measured_time & 0xFF;         // Extract the lower 8 bits
....................     cigs_data_header[3] = (measured_time >> 8) & 0xFF;  //
....................     cigs_data_header[4] = (measured_time >> 16) & 0xFF;
.................... 
.................... 
....................     // Save measurement PD value & Mode Data 
....................     cigs_data_header[5] = measured_pd_start & 0xFF;
....................     cigs_data_header[6] = ((measured_pd_start & 0x0F) << 4) | ((measured_pd_end >> 8) & 0x0F);
....................     cigs_data_header[7] = measured_pd_end >> 4 & 0xFF;
....................     
....................     // Save measurement Temp value
....................     cigs_data_header[8] = measured_pd_start & 0xFF;
....................     cigs_data_header[9] = ((measured_pd_start & 0x0F) << 4) | ((measured_pd_end >> 8) & 0x0F);
....................     cigs_data_header[10] = measured_pd_end >> 4 & 0xFF;
.................... 
....................     cigs_data_header[11] = 0x00; // Header end
.................... }
.................... 
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "./lib/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "src/smf_queue.c"
.................... void enqueue_smf_data(SmfDataStruct *data)
.................... {   
....................    int8 next_tail = (smf_queue.smf_data_tail + 1) % SMF_DATA_SIZE;
.................... 
....................    if(next_tail == smf_queue.smf_data_head)
....................       fprintf(PC, "SMF data list is full!!!\r\n");
....................       
....................    else
....................    {
....................       smf_queue.smf_data[smf_queue.smf_data_tail].dest = data->dest;
....................       smf_queue.smf_data[smf_queue.smf_data_tail].src = data->src;
....................       smf_queue.smf_data[smf_queue.smf_data_tail].size = data->size;
.................... 
....................       smf_queue.smf_data_tail = next_tail;
....................    }
.................... }
.................... 
.................... SmfDataStruct *dequeue_smf_data()
.................... {
....................    if (smf_queue.smf_data_head == smf_queue.smf_data_tail)
*
1523:  MOVLB  0F
1524:  MOVF   58,W
1525:  SUBWF  57,W
1526:  BTFSS  03.2
1527:  GOTO   537
....................    {
....................       fprintf(PC, "SMF data list is empty\r\n");
1528:  MOVLW  9A
1529:  MOVLB  03
152A:  MOVWF  11
152B:  MOVLW  02
152C:  MOVWF  12
152D:  MOVLP  00
152E:  MOVLB  00
152F:  CALL   6A1
1530:  MOVLP  10
....................       return 0x00;
1531:  MOVLW  00
1532:  MOVWF  78
1533:  MOVWF  79
1534:  GOTO   551
....................    }
1535:  GOTO   551
1536:  MOVLB  0F
....................    else
....................    {
....................       int8 current_head = smf_queue.smf_data_head;
1537:  MOVF   57,W
1538:  MOVLB  10
1539:  MOVWF  44
....................       smf_queue.smf_data_head = (smf_queue.smf_data_head + 1) % SMF_DATA_SIZE;
153A:  MOVLW  01
153B:  MOVLB  0F
153C:  ADDWF  57,W
153D:  ANDLW  0F
153E:  MOVWF  57
....................       return &smf_queue.smf_data[current_head];
153F:  MOVLB  10
1540:  MOVF   44,W
1541:  MOVWF  58
1542:  MOVLW  0C
1543:  MOVWF  59
1544:  MOVLP  08
1545:  MOVLB  00
1546:  CALL   4F0
1547:  MOVLP  10
1548:  MOVF   78,W
1549:  ADDLW  27
154A:  MOVWF  78
154B:  MOVLW  24
154C:  MOVWF  7A
154D:  BTFSC  03.0
154E:  INCF   7A,F
154F:  MOVF   7A,W
1550:  MOVWF  79
....................    }
.................... }
.................... 
.................... int1 is_empty_smf_data(void)
.................... {
....................    return smf_queue.smf_data_head == smf_queue.smf_data_tail;
*
0D2F:  MOVLB  0F
0D30:  MOVF   58,W
0D31:  SUBWF  57,W
0D32:  BTFSC  03.2
0D33:  GOTO   536
0D34:  MOVLW  00
0D35:  GOTO   537
0D36:  MOVLW  01
0D37:  MOVWF  78
0D38:  MOVLB  00
0D39:  RETURN
.................... }
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "./lib/flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "src/flash.c"
.................... 
.................... 
.................... // ADD 
.................... #define READ_ID_DATA_SIZE 20
.................... 
.................... #define MANUFACTURER_ID 0x20
.................... #define MEMORY_TYPE 0xBA
.................... #define MEMORY_CAPACITY_128M 0x18
.................... #define MEMORY_CAPACITY_1G   0x21
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "./lib/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define MAIN_PIC  0x00
.................... #define COM_PIC   0x01
.................... #define RESET_PIC 0x02
.................... #define FAB_PIC   0x03
.................... #define BOSS_PIC  0x04
.................... #define APRS_PIC  0x05
.................... #define CAM_MCU   0x06
.................... #define CHO_MCU   0x07
.................... #define NAKA_PIC  0x08
.................... #define SATO_PIC  0x09
.................... #define BHU_MCU   0x0A
.................... #define CIGS_PIC  0x0B
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC // <- change to your device name
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 32
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 content[CONTENT_MAX];
....................     int8 size;
....................     int1 is_exist;
.................... } Command;
.................... 
.................... #include "./frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x01,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... static unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... #include "./src/communication.c"
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, {0x00}, 0, FALSE};
*
09A5:  MOVLB  10
09A6:  CLRF   46
09A7:  CLRF   47
09A8:  CLRF   48
09A9:  CLRF   49
09AA:  CLRF   4A
09AB:  CLRF   4B
09AC:  CLRF   4C
09AD:  CLRF   4D
09AE:  CLRF   4E
09AF:  CLRF   4F
09B0:  CLRF   50
09B1:  CLRF   51
09B2:  CLRF   52
09B3:  CLRF   53
09B4:  CLRF   54
09B5:  CLRF   55
09B6:  CLRF   56
09B7:  CLRF   57
09B8:  CLRF   58
09B9:  CLRF   59
09BA:  CLRF   5A
09BB:  CLRF   5B
09BC:  CLRF   5C
09BD:  CLRF   5D
09BE:  CLRF   5E
09BF:  CLRF   5F
09C0:  CLRF   60
09C1:  CLRF   61
09C2:  CLRF   62
09C3:  CLRF   63
09C4:  CLRF   64
09C5:  CLRF   65
09C6:  CLRF   66
09C7:  CLRF   67
09C8:  CLRF   68
....................    fprintf(PC, "Start make_receive_command\r\n\t-> ");
09C9:  MOVLW  A7
09CA:  MOVLB  03
09CB:  MOVWF  11
09CC:  MOVLW  02
09CD:  MOVWF  12
09CE:  MOVLP  00
09CF:  MOVLB  00
09D0:  CALL   6A1
09D1:  MOVLP  08
....................    for (int8 i = 0; i < receive_signal_size; i++)
09D2:  MOVLB  10
09D3:  CLRF   69
09D4:  MOVF   45,W
09D5:  SUBWF  69,W
09D6:  BTFSC  03.0
09D7:  GOTO   1F2
....................       fprintf(PC, "%X ", receive_signal[i]);
09D8:  MOVF   69,W
09D9:  ADDWF  43,W
09DA:  MOVWF  04
09DB:  MOVLW  00
09DC:  ADDWFC 44,W
09DD:  MOVWF  05
09DE:  MOVF   00,W
09DF:  MOVLB  11
09E0:  MOVWF  22
09E1:  MOVWF  27
09E2:  MOVLW  37
09E3:  MOVWF  28
09E4:  MOVLP  00
09E5:  MOVLB  00
09E6:  CALL   783
09E7:  MOVLP  08
09E8:  MOVLW  20
09E9:  MOVLB  11
09EA:  MOVWF  2B
09EB:  MOVLP  00
09EC:  MOVLB  00
09ED:  CALL   67C
09EE:  MOVLP  08
09EF:  MOVLB  10
09F0:  INCF   69,F
09F1:  GOTO   1D4
....................    fprintf(PC, "\r\n");
09F2:  MOVLW  0D
09F3:  MOVLB  11
09F4:  MOVWF  2B
09F5:  MOVLP  00
09F6:  MOVLB  00
09F7:  CALL   67C
09F8:  MOVLP  08
09F9:  MOVLW  0A
09FA:  MOVLB  11
09FB:  MOVWF  2B
09FC:  MOVLP  00
09FD:  MOVLB  00
09FE:  CALL   67C
09FF:  MOVLP  08
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
0A00:  MOVLB  10
0A01:  MOVF   44,W
0A02:  MOVLB  11
0A03:  MOVWF  23
0A04:  MOVLB  10
0A05:  MOVF   43,W
0A06:  MOVLB  11
0A07:  MOVWF  22
0A08:  MOVLB  10
0A09:  MOVF   45,W
0A0A:  MOVLB  11
0A0B:  MOVWF  24
*
0A47:  MOVF   78,W
0A48:  MOVLB  10
0A49:  MOVWF  6A
....................    if (frame_start_position == -1)
0A4A:  MOVF   6A,W
0A4B:  SUBLW  FF
0A4C:  BTFSS  03.2
0A4D:  GOTO   253
....................       return command;
0A4E:  MOVLW  46
0A4F:  MOVWF  78
0A50:  MOVLW  08
0A51:  MOVWF  79
0A52:  GOTO   3E3
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
0A53:  MOVF   6A,W
0A54:  ADDWF  43,W
0A55:  MOVWF  6B
0A56:  MOVLW  00
0A57:  ADDWFC 44,W
0A58:  MOVWF  6C
0A59:  MOVF   6B,W
0A5A:  MOVWF  04
0A5B:  MOVF   6C,W
0A5C:  MOVWF  05
0A5D:  ADDFSR 00,FSR0
0A5E:  MOVF   00,W
0A5F:  ANDLW  0F
0A60:  MOVWF  6D
0A61:  MOVF   6D,W
0A62:  MOVLB  11
0A63:  MOVWF  22
*
0AA8:  MOVF   78,W
0AA9:  MOVLB  10
0AAA:  MOVWF  6E
....................    if (content_size == -1)
0AAB:  MOVF   6E,W
0AAC:  SUBLW  FF
0AAD:  BTFSS  03.2
0AAE:  GOTO   2B4
....................       return command;
0AAF:  MOVLW  46
0AB0:  MOVWF  78
0AB1:  MOVLW  08
0AB2:  MOVWF  79
0AB3:  GOTO   3E3
....................       
....................    int8 receive_frame_size = receive_signal_size - frame_start_position;
0AB4:  MOVF   6A,W
0AB5:  SUBWF  45,W
0AB6:  MOVWF  6F
....................    
....................    if (!check_crc(frame, receive_frame_size))
0AB7:  MOVF   6C,W
0AB8:  MOVLB  11
0AB9:  MOVWF  23
0ABA:  MOVLB  10
0ABB:  MOVF   6B,W
0ABC:  MOVLB  11
0ABD:  MOVWF  22
0ABE:  MOVLB  10
0ABF:  MOVF   6F,W
0AC0:  MOVLB  11
0AC1:  MOVWF  24
*
0B33:  MOVF   78,F
0B34:  BTFSS  03.2
0B35:  GOTO   33D
....................       return command;
0B36:  MOVLW  46
0B37:  MOVWF  78
0B38:  MOVLW  08
0B39:  MOVWF  79
0B3A:  MOVLB  10
0B3B:  GOTO   3E3
0B3C:  MOVLB  11
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
0B3D:  MOVLB  10
0B3E:  MOVF   6B,W
0B3F:  MOVWF  04
0B40:  MOVF   6C,W
0B41:  MOVWF  05
0B42:  ADDFSR 00,FSR0
0B43:  MOVF   00,W
0B44:  ANDLW  F0
0B45:  MOVWF  77
0B46:  SWAPF  77,W
0B47:  MOVLB  11
0B48:  MOVWF  22
0B49:  MOVLW  0F
0B4A:  ANDWF  22,F
0B4B:  MOVF   22,W
0B4C:  MOVWF  23
*
0BA5:  MOVF   78,F
0BA6:  BTFSS  03.2
0BA7:  GOTO   3AF
....................       return command;
0BA8:  MOVLW  46
0BA9:  MOVWF  78
0BAA:  MOVLW  08
0BAB:  MOVWF  79
0BAC:  MOVLB  10
0BAD:  GOTO   3E3
0BAE:  MOVLB  11
.................... 
....................    command.frame_id = frame_id;
0BAF:  MOVLB  10
0BB0:  MOVF   6D,W
0BB1:  MOVWF  46
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
0BB2:  MOVLW  01
0BB3:  ADDWF  6B,W
0BB4:  MOVLB  11
0BB5:  MOVWF  22
0BB6:  MOVLW  00
0BB7:  MOVLB  10
0BB8:  ADDWFC 6C,W
0BB9:  MOVLB  11
0BBA:  MOVWF  23
0BBB:  MOVLW  02
0BBC:  MOVLB  10
0BBD:  SUBWF  6F,W
0BBE:  MOVLB  11
0BBF:  MOVWF  24
0BC0:  MOVF   23,W
0BC1:  MOVWF  05
0BC2:  MOVF   22,W
0BC3:  MOVWF  04
0BC4:  MOVF   24,W
0BC5:  MOVWF  78
0BC6:  BTFSC  03.2
0BC7:  GOTO   3D0
0BC8:  MOVLW  25
0BC9:  MOVWF  07
0BCA:  MOVLW  27
0BCB:  MOVWF  06
0BCC:  MOVIW  [FSR0++],W
0BCD:  MOVWI  W,[FSR1++]
0BCE:  DECFSZ 78,F
0BCF:  GOTO   3CC
....................    command.size = receive_frame_size-2;
0BD0:  MOVLW  02
0BD1:  MOVLB  10
0BD2:  SUBWF  6F,W
0BD3:  MOVWF  67
....................    //fprintf(PC, "\tcommand.size: %d\r\n", command.size);
....................    command.is_exist = TRUE;
0BD4:  BSF    68.0
....................    //fprintf(PC, "\tcommand.is_exist: %X\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
0BD5:  MOVLW  B8
0BD6:  MOVLB  03
0BD7:  MOVWF  11
0BD8:  MOVLW  02
0BD9:  MOVWF  12
0BDA:  MOVLP  00
0BDB:  MOVLB  00
0BDC:  CALL   6A1
0BDD:  MOVLP  08
....................    return command;
0BDE:  MOVLW  46
0BDF:  MOVWF  78
0BE0:  MOVLW  08
0BE1:  MOVWF  79
0BE2:  MOVLB  10
0BE3:  MOVLP  08
0BE4:  MOVLB  00
0BE5:  GOTO   616 (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
0A0C:  CLRF   25
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
0A0D:  CLRF   25
0A0E:  MOVLW  01
0A0F:  SUBWF  24,W
0A10:  SUBWF  25,W
0A11:  BTFSC  03.0
0A12:  GOTO   223
....................       if(receive_signal[i] == SFD)
0A13:  MOVF   25,W
0A14:  ADDWF  22,W
0A15:  MOVWF  04
0A16:  MOVLW  00
0A17:  ADDWFC 23,W
0A18:  MOVWF  05
0A19:  MOVF   00,W
0A1A:  SUBLW  AA
0A1B:  BTFSS  03.2
0A1C:  GOTO   221
....................          return i+1;
0A1D:  MOVLW  01
0A1E:  ADDWF  25,W
0A1F:  MOVWF  78
0A20:  GOTO   247
0A21:  INCF   25,F
0A22:  GOTO   20E
....................    if (receive_signal[i] == SFD)
0A23:  MOVF   25,W
0A24:  ADDWF  22,W
0A25:  MOVWF  04
0A26:  MOVLW  00
0A27:  ADDWFC 23,W
0A28:  MOVWF  05
0A29:  MOVF   00,W
0A2A:  SUBLW  AA
0A2B:  BTFSS  03.2
0A2C:  GOTO   23B
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
0A2D:  MOVLW  C6
0A2E:  MOVLB  03
0A2F:  MOVWF  11
0A30:  MOVLW  02
0A31:  MOVWF  12
0A32:  MOVLP  00
0A33:  MOVLB  00
0A34:  CALL   6A1
0A35:  MOVLP  08
....................       return -1;
0A36:  MOVLW  FF
0A37:  MOVWF  78
0A38:  MOVLB  11
0A39:  GOTO   247
....................    }
0A3A:  GOTO   247
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
0A3B:  MOVLW  D1
0A3C:  MOVLB  03
0A3D:  MOVWF  11
0A3E:  MOVLW  02
0A3F:  MOVWF  12
0A40:  MOVLP  00
0A41:  MOVLB  00
0A42:  CALL   6A1
0A43:  MOVLP  08
....................       return -1;
0A44:  MOVLW  FF
0A45:  MOVWF  78
0A46:  MOVLB  11
....................    }
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
*
0A64:  CLRF   23
0A65:  MOVF   23,W
0A66:  SUBLW  02
0A67:  BTFSS  03.0
0A68:  GOTO   283
....................       if (frame_id == frame_ids[i].id)
0A69:  BCF    03.0
0A6A:  RLF    23,W
0A6B:  ADDLW  E9
0A6C:  MOVWF  04
0A6D:  MOVLW  24
0A6E:  MOVWF  05
0A6F:  BTFSC  03.0
0A70:  INCF   05,F
0A71:  MOVF   00,W
0A72:  SUBWF  22,W
0A73:  BTFSS  03.2
0A74:  GOTO   281
....................          return frame_ids[i].length;
0A75:  BCF    03.0
0A76:  RLF    23,W
0A77:  ADDLW  01
0A78:  ADDLW  E9
0A79:  MOVWF  04
0A7A:  MOVLW  24
0A7B:  MOVWF  05
0A7C:  BTFSC  03.0
0A7D:  INCF   05,F
0A7E:  MOVF   00,W
0A7F:  MOVWF  78
0A80:  GOTO   2A8
0A81:  INCF   23,F
0A82:  GOTO   265
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
0A83:  MOVLW  DA
0A84:  MOVLB  03
0A85:  MOVWF  11
0A86:  MOVLW  02
0A87:  MOVWF  12
0A88:  BCF    03.0
0A89:  MOVLW  1F
0A8A:  MOVLB  11
0A8B:  MOVWF  27
0A8C:  MOVLB  00
0A8D:  CALL   149
0A8E:  MOVLB  11
0A8F:  MOVF   22,W
0A90:  MOVWF  27
0A91:  MOVLW  37
0A92:  MOVWF  28
0A93:  MOVLP  00
0A94:  MOVLB  00
0A95:  CALL   783
0A96:  MOVLP  08
0A97:  MOVLW  0D
0A98:  MOVLB  11
0A99:  MOVWF  2B
0A9A:  MOVLP  00
0A9B:  MOVLB  00
0A9C:  CALL   67C
0A9D:  MOVLP  08
0A9E:  MOVLW  0A
0A9F:  MOVLB  11
0AA0:  MOVWF  2B
0AA1:  MOVLP  00
0AA2:  MOVLB  00
0AA3:  CALL   67C
0AA4:  MOVLP  08
....................    return -1;
0AA5:  MOVLW  FF
0AA6:  MOVWF  78
0AA7:  MOVLB  11
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
*
0AC2:  MOVLW  01
0AC3:  SUBWF  24,W
0AC4:  ADDWF  22,W
0AC5:  MOVWF  04
0AC6:  MOVLW  00
0AC7:  ADDWFC 23,W
0AC8:  MOVWF  05
0AC9:  MOVF   00,W
0ACA:  MOVWF  25
0ACB:  MOVLW  01
0ACC:  SUBWF  24,W
0ACD:  MOVWF  27
0ACE:  MOVF   23,W
0ACF:  MOVWF  29
0AD0:  MOVF   22,W
0AD1:  MOVWF  28
0AD2:  MOVF   27,W
0AD3:  MOVWF  2A
0AD4:  MOVLP  00
0AD5:  MOVLB  00
0AD6:  CALL   7A8
0AD7:  MOVLP  08
0AD8:  MOVF   78,W
0AD9:  MOVLB  11
0ADA:  MOVWF  26
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
0ADB:  MOVF   26,W
0ADC:  SUBWF  25,W
0ADD:  BTFSS  03.2
0ADE:  GOTO   2E3
....................       return TRUE;
0ADF:  MOVLW  01
0AE0:  MOVWF  78
0AE1:  GOTO   333
0AE2:  GOTO   333
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
0AE3:  MOVLW  EC
0AE4:  MOVLB  03
0AE5:  MOVWF  11
0AE6:  MOVLW  02
0AE7:  MOVWF  12
0AE8:  MOVLP  00
0AE9:  MOVLB  00
0AEA:  CALL   6A1
0AEB:  MOVLP  08
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
0AEC:  MOVLW  F5
0AED:  MOVLB  03
0AEE:  MOVWF  11
0AEF:  MOVLW  02
0AF0:  MOVWF  12
0AF1:  BCF    03.0
0AF2:  MOVLW  13
0AF3:  MOVLB  11
0AF4:  MOVWF  27
0AF5:  MOVLB  00
0AF6:  CALL   149
0AF7:  MOVLB  11
0AF8:  MOVF   25,W
0AF9:  MOVWF  27
0AFA:  MOVLW  37
0AFB:  MOVWF  28
0AFC:  MOVLP  00
0AFD:  MOVLB  00
0AFE:  CALL   783
0AFF:  MOVLP  08
0B00:  MOVLW  0D
0B01:  MOVLB  11
0B02:  MOVWF  2B
0B03:  MOVLP  00
0B04:  MOVLB  00
0B05:  CALL   67C
0B06:  MOVLP  08
0B07:  MOVLW  0A
0B08:  MOVLB  11
0B09:  MOVWF  2B
0B0A:  MOVLP  00
0B0B:  MOVLB  00
0B0C:  CALL   67C
0B0D:  MOVLP  08
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
0B0E:  MOVLW  01
0B0F:  MOVLB  03
0B10:  MOVWF  11
0B11:  MOVLW  03
0B12:  MOVWF  12
0B13:  BCF    03.0
0B14:  MOVLW  13
0B15:  MOVLB  11
0B16:  MOVWF  27
0B17:  MOVLB  00
0B18:  CALL   149
0B19:  MOVLB  11
0B1A:  MOVF   26,W
0B1B:  MOVWF  27
0B1C:  MOVLW  37
0B1D:  MOVWF  28
0B1E:  MOVLP  00
0B1F:  MOVLB  00
0B20:  CALL   783
0B21:  MOVLP  08
0B22:  MOVLW  0D
0B23:  MOVLB  11
0B24:  MOVWF  2B
0B25:  MOVLP  00
0B26:  MOVLB  00
0B27:  CALL   67C
0B28:  MOVLP  08
0B29:  MOVLW  0A
0B2A:  MOVLB  11
0B2B:  MOVWF  2B
0B2C:  MOVLP  00
0B2D:  MOVLB  00
0B2E:  CALL   67C
0B2F:  MOVLP  08
....................       return FALSE;
0B30:  MOVLW  00
0B31:  MOVWF  78
0B32:  MOVLB  11
....................    }
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
*
0B4D:  MOVF   23,W
0B4E:  SUBLW  0B
0B4F:  BTFSS  03.2
0B50:  GOTO   355
....................       return TRUE;
0B51:  MOVLW  01
0B52:  MOVWF  78
0B53:  GOTO   3A5
0B54:  GOTO   3A5
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
0B55:  MOVLW  0D
0B56:  MOVLB  03
0B57:  MOVWF  11
0B58:  MOVLW  03
0B59:  MOVWF  12
0B5A:  MOVLP  00
0B5B:  MOVLB  00
0B5C:  CALL   6A1
0B5D:  MOVLP  08
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
0B5E:  MOVLW  1E
0B5F:  MOVLB  03
0B60:  MOVWF  11
0B61:  MOVLW  03
0B62:  MOVWF  12
0B63:  BCF    03.0
0B64:  MOVLW  13
0B65:  MOVLB  11
0B66:  MOVWF  27
0B67:  MOVLB  00
0B68:  CALL   149
0B69:  MOVLB  11
0B6A:  MOVF   23,W
0B6B:  MOVWF  27
0B6C:  MOVLW  37
0B6D:  MOVWF  28
0B6E:  MOVLP  00
0B6F:  MOVLB  00
0B70:  CALL   783
0B71:  MOVLP  08
0B72:  MOVLW  0D
0B73:  MOVLB  11
0B74:  MOVWF  2B
0B75:  MOVLP  00
0B76:  MOVLB  00
0B77:  CALL   67C
0B78:  MOVLP  08
0B79:  MOVLW  0A
0B7A:  MOVLB  11
0B7B:  MOVWF  2B
0B7C:  MOVLP  00
0B7D:  MOVLB  00
0B7E:  CALL   67C
0B7F:  MOVLP  08
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
0B80:  MOVLW  2A
0B81:  MOVLB  03
0B82:  MOVWF  11
0B83:  MOVLW  03
0B84:  MOVWF  12
0B85:  BCF    03.0
0B86:  MOVLW  13
0B87:  MOVLB  11
0B88:  MOVWF  27
0B89:  MOVLB  00
0B8A:  CALL   149
0B8B:  MOVLW  0B
0B8C:  MOVLB  11
0B8D:  MOVWF  27
0B8E:  MOVLW  37
0B8F:  MOVWF  28
0B90:  MOVLP  00
0B91:  MOVLB  00
0B92:  CALL   783
0B93:  MOVLP  08
0B94:  MOVLW  0D
0B95:  MOVLB  11
0B96:  MOVWF  2B
0B97:  MOVLP  00
0B98:  MOVLB  00
0B99:  CALL   67C
0B9A:  MOVLP  08
0B9B:  MOVLW  0A
0B9C:  MOVLB  11
0B9D:  MOVWF  2B
0B9E:  MOVLP  00
0B9F:  MOVLB  00
0BA0:  CALL   67C
0BA1:  MOVLP  08
....................       return FALSE;  
0BA2:  MOVLW  00
0BA3:  MOVWF  78
0BA4:  MOVLB  11
....................    }
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
0C59:  MOVLW  AA
0C5A:  MOVLB  10
0C5B:  MOVWF  46
....................    data[1] = (BOSS_PIC << 4) | frame_id;
0C5C:  MOVF   42,W
0C5D:  IORLW  40
0C5E:  MOVWF  47
....................    memcpy(&data[2], content, size);
0C5F:  MOVF   44,W
0C60:  MOVWF  05
0C61:  MOVF   43,W
0C62:  MOVWF  04
0C63:  MOVF   45,W
0C64:  MOVWF  78
0C65:  BTFSC  03.2
0C66:  GOTO   46F
0C67:  MOVLW  25
0C68:  MOVWF  07
0C69:  MOVLW  28
0C6A:  MOVWF  06
0C6B:  MOVIW  [FSR0++],W
0C6C:  MOVWI  W,[FSR1++]
0C6D:  DECFSZ 78,F
0C6E:  GOTO   46B
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
0C6F:  MOVLW  02
0C70:  ADDWF  45,W
0C71:  MOVWF  56
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
0C72:  MOVLW  26
0C73:  ADDWF  56,W
0C74:  MOVWF  58
0C75:  MOVLW  25
0C76:  MOVWF  59
0C77:  BTFSC  03.0
0C78:  INCF   59,F
0C79:  MOVLW  01
0C7A:  SUBWF  56,W
0C7B:  MOVWF  5A
0C7C:  MOVLW  25
0C7D:  MOVLB  11
0C7E:  MOVWF  29
0C7F:  MOVLW  27
0C80:  MOVWF  28
0C81:  MOVLB  10
0C82:  MOVF   5A,W
0C83:  MOVLB  11
0C84:  MOVWF  2A
0C85:  MOVLP  00
0C86:  MOVLB  00
0C87:  CALL   7A8
0C88:  MOVLP  08
0C89:  MOVLB  10
0C8A:  MOVF   59,W
0C8B:  MOVWF  05
0C8C:  MOVF   58,W
0C8D:  MOVWF  04
0C8E:  MOVF   78,W
0C8F:  MOVWF  00
....................    int8 data_size = payload_size + 1; // '1' is for CRC
0C90:  MOVLW  01
0C91:  ADDWF  56,W
0C92:  MOVWF  57
....................    
....................    transmit(data, data_size);
0C93:  MOVLW  25
0C94:  MOVWF  59
0C95:  MOVLW  26
0C96:  MOVWF  58
0C97:  MOVF   57,W
0C98:  MOVWF  5A
*
0CE6:  RETURN
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
0C99:  CLRF   5B
0C9A:  MOVF   5A,W
0C9B:  SUBWF  5B,W
0C9C:  BTFSC  03.0
0C9D:  GOTO   4AF
....................       fputc(data[i], BOSS);
0C9E:  MOVF   5B,W
0C9F:  ADDWF  58,W
0CA0:  MOVWF  04
0CA1:  MOVLW  00
0CA2:  ADDWFC 59,W
0CA3:  MOVWF  05
0CA4:  MOVF   00,W
0CA5:  MOVWF  5D
0CA6:  MOVF   5D,W
*
0CAC:  MOVLB  10
0CAD:  INCF   5B,F
0CAE:  GOTO   49A
....................       
....................    fprintf(PC, "Transit command\r\n\t-> ");
0CAF:  MOVLW  36
0CB0:  MOVLB  03
0CB1:  MOVWF  11
0CB2:  MOVLW  03
0CB3:  MOVWF  12
0CB4:  MOVLP  00
0CB5:  MOVLB  00
0CB6:  CALL   6A1
0CB7:  MOVLP  08
....................    for(int i = 0; i < data_size; i++)
0CB8:  MOVLB  10
0CB9:  CLRF   5C
0CBA:  MOVF   5A,W
0CBB:  SUBWF  5C,W
0CBC:  BTFSC  03.0
0CBD:  GOTO   4D8
....................       fprintf(PC, "%X ", data[i]);
0CBE:  MOVF   5C,W
0CBF:  ADDWF  58,W
0CC0:  MOVWF  04
0CC1:  MOVLW  00
0CC2:  ADDWFC 59,W
0CC3:  MOVWF  05
0CC4:  MOVF   00,W
0CC5:  MOVWF  5D
0CC6:  MOVLB  11
0CC7:  MOVWF  27
0CC8:  MOVLW  37
0CC9:  MOVWF  28
0CCA:  MOVLP  00
0CCB:  MOVLB  00
0CCC:  CALL   783
0CCD:  MOVLP  08
0CCE:  MOVLW  20
0CCF:  MOVLB  11
0CD0:  MOVWF  2B
0CD1:  MOVLP  00
0CD2:  MOVLB  00
0CD3:  CALL   67C
0CD4:  MOVLP  08
0CD5:  MOVLB  10
0CD6:  INCF   5C,F
0CD7:  GOTO   4BA
....................    fprintf(PC, "\r\n");
0CD8:  MOVLW  0D
0CD9:  MOVLB  11
0CDA:  MOVWF  2B
0CDB:  MOVLP  00
0CDC:  MOVLB  00
0CDD:  CALL   67C
0CDE:  MOVLP  08
0CDF:  MOVLW  0A
0CE0:  MOVLB  11
0CE1:  MOVWF  2B
0CE2:  MOVLP  00
0CE3:  MOVLB  00
0CE4:  CALL   67C
0CE5:  MOVLP  08
.................... }
.................... 
.................... 
.................... // ______ Common _______
.................... 
.................... static unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size)
*
07A8:  MOVLB  11
07A9:  MOVF   28,W
07AA:  MOVWF  04
07AB:  MOVF   29,W
07AC:  MOVWF  05
07AD:  MOVIW  [FSR0+00],W
07AE:  MOVWF  2B
07AF:  MOVLW  01
07B0:  MOVWF  2C
.................... {
....................    unsigned int8 crc = frame[0], i = 1;
....................    while(i < payload_size)
07B1:  MOVF   2A,W
07B2:  SUBWF  2C,W
07B3:  BTFSC  03.0
07B4:  GOTO   7BF
....................       crc ^= frame[i++];
07B5:  MOVF   2C,W
07B6:  INCF   2C,F
07B7:  ADDWF  28,W
07B8:  MOVWF  04
07B9:  MOVLW  00
07BA:  ADDWFC 29,W
07BB:  MOVWF  05
07BC:  MOVF   00,W
07BD:  XORWF  2B,F
07BE:  GOTO   7B1
....................    return crc;
07BF:  MOVF   2B,W
07C0:  MOVWF  78
07C1:  MOVLB  00
07C2:  RETURN
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... // EOF
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack();
.................... 
.................... void transmit_status();
.................... 
.................... int1 req_use_smf();
.................... 
.................... 
.................... #include "./src/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    volatile Command command = make_receive_command(receive_signal, receive_signal_size);
....................    //fprintf(PC, "--Communication drier--\r\n");
....................    //fprintf(PC, "command.size: %d\r\n", command.size);
....................    //fprintf(PC, "command.frame_id: %X\r\n", command.frame_id);
....................    //fprintf(PC, "command.content: ");
....................    for (int8 i = 0; i < command.size; i++)
....................       //fprintf(PC, "%X ", command.content[i]);
....................    //fprintf(PC, "\r\n");
....................    //fprintf(PC, "command.is_exist: %X\r\n", command.is_exist);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
0CE7:  MOVLW  0F
0CE8:  MOVLB  10
0CE9:  MOVWF  42
0CEA:  CLRF   44
0CEB:  CLRF   43
0CEC:  CLRF   45
0CED:  MOVLB  00
0CEE:  CALL   459
0CEF:  RETURN
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 1);
*
14CE:  MOVLW  01
14CF:  MOVLB  10
14D0:  MOVWF  42
14D1:  MOVLW  20
14D2:  MOVWF  44
14D3:  MOVLW  0B
14D4:  MOVWF  43
14D5:  MOVLW  01
14D6:  MOVWF  45
14D7:  MOVLP  08
14D8:  MOVLB  00
14D9:  CALL   459
14DA:  MOVLP  10
.................... }
.................... 
.................... // EOF
.................... 
.................... 
.................... #endif
.................... 
.................... // EOF
.................... 
.................... 
.................... 
.................... // _____________ define _______________
.................... 
.................... #define EXECUTED_MISSION_SIZE 8
.................... 
.................... 
.................... // _____________ typedef ________________
.................... 
.................... typedef struct {
....................    unsigned int8 executed_mission[EXECUTED_MISSION_SIZE];
....................    int8 executed_mission_count;
.................... } ExecutedMission;
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Value management using the Singleton pattern
.................... ExecutedMission get_executed_mission();
.................... 
.................... int1 is_executed_mission(unsigned int8 command_id);
.................... 
.................... void add_executed_mission(unsigned int8 command_id);
.................... 
.................... // Use in missions you want to execute consecutively
.................... void executed_mission_pop(void);
.................... 
.................... 
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // MIS MCU will be up and running duration_second seconds after mission completion
.................... void continue_mis_mcu(int16 duration_second);
.................... 
.................... 
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... 
.................... 
.................... #include "./src/mission_tools.c"
.................... ExecutedMission get_executed_mission()
.................... {
....................    static ExecutedMission executed_mission = {0};
....................    return executed_mission;
*
07F9:  MOVLW  DF
07FA:  MOVWF  78
07FB:  MOVLW  07
07FC:  MOVWF  79
07FD:  RETURN
.................... }
.................... 
.................... int1 is_executed_mission(unsigned int8 command_id)
*
1398:  MOVLP  00
1399:  MOVLB  00
139A:  CALL   7F9
139B:  MOVLP  10
139C:  MOVF   79,W
139D:  MOVWF  7A
139E:  MOVF   78,W
139F:  MOVWF  04
13A0:  MOVF   7A,W
13A1:  MOVWF  05
13A2:  MOVLW  09
13A3:  MOVWF  78
13A4:  MOVLW  25
13A5:  MOVWF  07
13A6:  MOVLW  2A
13A7:  MOVWF  06
13A8:  MOVIW  [FSR0++],W
13A9:  MOVWI  W,[FSR1++]
13AA:  DECFSZ 78,F
13AB:  GOTO   3A8
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    
....................    for (int i = 0; i < executed_mission.executed_mission_count; i++)
13AC:  MOVLB  10
13AD:  CLRF   53
13AE:  MOVF   52,W
13AF:  SUBWF  53,W
13B0:  BTFSC  03.0
13B1:  GOTO   3C2
....................       if (command_id == executed_mission.executed_mission[i])
13B2:  MOVLW  2A
13B3:  ADDWF  53,W
13B4:  MOVWF  04
13B5:  MOVLW  25
13B6:  MOVWF  05
13B7:  BTFSC  03.0
13B8:  INCF   05,F
13B9:  MOVF   00,W
13BA:  SUBWF  49,W
13BB:  BTFSS  03.2
13BC:  GOTO   3C0
....................          return TRUE;
13BD:  MOVLW  01
13BE:  MOVWF  78
13BF:  GOTO   3C4
13C0:  INCF   53,F
13C1:  GOTO   3AE
....................       
....................    return FALSE;
13C2:  MOVLW  00
13C3:  MOVWF  78
.................... }
.................... 
.................... void add_executed_mission(unsigned int8 command_id)
*
13EF:  MOVLP  00
13F0:  MOVLB  00
13F1:  CALL   7F9
13F2:  MOVLP  10
13F3:  MOVF   79,W
13F4:  MOVWF  7A
13F5:  MOVF   78,W
13F6:  MOVWF  04
13F7:  MOVF   7A,W
13F8:  MOVWF  05
13F9:  MOVLW  09
13FA:  MOVWF  78
13FB:  MOVLW  25
13FC:  MOVWF  07
13FD:  MOVLW  2A
13FE:  MOVWF  06
13FF:  MOVIW  [FSR0++],W
1400:  MOVWI  W,[FSR1++]
1401:  DECFSZ 78,F
1402:  GOTO   3FF
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    
....................    if (executed_mission.executed_mission_count != EXECUTED_MISSION_SIZE)
1403:  MOVLB  10
1404:  MOVF   52,W
1405:  SUBLW  08
1406:  BTFSC  03.2
1407:  GOTO   413
....................       executed_mission.executed_mission[executed_mission.executed_mission_count++] = command_id;
1408:  MOVF   52,W
1409:  INCF   52,F
140A:  ADDLW  2A
140B:  MOVWF  04
140C:  MOVLW  25
140D:  MOVWF  05
140E:  BTFSC  03.0
140F:  INCF   05,F
1410:  MOVF   49,W
1411:  MOVWF  00
1412:  GOTO   41D
....................    else
....................       fprintf(PC, "!!!overflow executed_mission list\r\n");
1413:  MOVLW  41
1414:  MOVLB  03
1415:  MOVWF  11
1416:  MOVLW  03
1417:  MOVWF  12
1418:  MOVLP  00
1419:  MOVLB  00
141A:  CALL   6A1
141B:  MOVLP  10
141C:  MOVLB  10
.................... }
.................... 
.................... 
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status = EXECUTING_MISSION;
.................... }
.................... 
.................... void executed_mission_pop(void)
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    executed_mission.executed_mission[executed_mission.executed_mission_count--] = 0x00;
.................... }
.................... 
.................... void continue_mis_mcu(int16 duration_second)
.................... {  
....................    duration_sec = duration_second + sec;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... // _________________ Oparation Mode ______________________
.................... #Separate
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
*
0D17:  MOVLW  D6
0D18:  MOVLB  03
0D19:  MOVWF  11
0D1A:  MOVLW  03
0D1B:  MOVWF  12
0D1C:  MOVLP  00
0D1D:  MOVLB  00
0D1E:  CALL   6A1
0D1F:  MOVLP  08
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
0D20:  MOVLB  10
0D21:  MOVF   49,W
0D22:  MOVWF  04
0D23:  MOVF   4A,W
0D24:  MOVWF  05
0D25:  MOVIW  [FSR0+00],W
0D26:  MOVWF  4B
....................    
....................    //adc_init();
....................    sweep(sweep_step);
0D27:  MOVF   4B,W
0D28:  MOVWF  4C
0D29:  MOVLP  10
0D2A:  MOVLB  00
0D2B:  GOTO   000
0D2C:  MOVLP  08
0D2D:  MOVLP  10
0D2E:  GOTO   468 (RETURN)
....................    //copy_data();
.................... 
.................... }
.................... 
.................... #Separate
.................... void mode_measure_voltage()
.................... {
....................    fprintf(PC, "Start MODE MEASURE Voltage\r\n");
....................    while(TRUE)
....................    {
....................       unsigned int16 cigs_value;
....................       set_adc_channel(CIGS_VOLT);
....................       cigs_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................       //fprintf(PC, "cigs_value: %04X\r\n", cigs_value);
....................       delay_ms(1000); // wait for the ADC to stabilize
....................    }
.................... }
.................... 
.................... #Separate
.................... void mode_copy_SMF()
.................... {
....................    /*
....................    unsigned int8 smf_data[SMF_DATA_SIZE] = {0x00};
....................    unsigned int32 src = 0x00000000;
....................    unsigned int32 dest = 0x00000000;
....................    unsigned int32 size = 0x00000000;
....................    for (int i = 0; i < SMF_DATA_SIZE; i++)
....................    {
....................       smf_data[i] = read_data_byte_spi_id(src + i);
....................       fprintf(PC, "smf_data[%d]: %X\r\n", i, smf_data[i]);
....................    }
....................    enqueue_smf_data(src, dest, size);
....................    fprintf(PC, "enqueue_smf_data\r\n");
....................    */
.................... }
.................... 
.................... 
.................... //___________________ Debug Mode _______________
.................... #Separate
.................... void mode_test_temp()
.................... {
....................    while (TRUE)
....................    {   
....................       set_adc_channel(TEMP_TOP);
....................       unsigned int16 temp_top_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................       set_adc_channel(TEMP_BOT);
....................       unsigned int16 temp_bot_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................       fprintf(PC, "temp_top: %X\r\n", temp_top_value);
....................       fprintf(PC, "temp_bot: %X\r\n", temp_bot_value);
....................       delay_ms(1000);
....................    }
.................... }
.................... 
.................... #Separate
.................... void mode_test_PD()
.................... {
....................    while (TRUE)
....................    {
....................       unsigned int16 pd_value;
....................       set_adc_channel(PD);
....................       pd_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................       fprintf(PC, "pd_value: %X\r\n", pd_value);
....................       delay_ms(1000);
....................    }
.................... }
.................... 
.................... #Separate
.................... void mode_test_CIGS()
.................... {
....................    unsigned int16 cigs_value = 0;
....................    set_adc_channel(3);
....................    cigs_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    fprintf(PC, "cigs_value: %X\r\n", cigs_value);
.................... }
.................... 
.................... #Separate
.................... void mode_test_current()
.................... {
....................    unsigned int16 current_value = 0;
....................    set_adc_channel(3);
....................    current_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    fprintf(PC, "current_value: %X\r\n", current_value);
.................... }
.................... 
.................... #Separate
.................... void mode_test_voltage()
.................... {
....................    unsigned int16 voltage_value = 0;
....................    set_adc_channel(3);
....................    voltage_value = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    fprintf(PC, "voltage_value: %X\r\n", voltage_value);
.................... }
.................... 
.................... // Flash command 
.................... #Separate
.................... void mode_flash_erase_all()
.................... {
....................    fprintf(PC, "Start Flash Erase All\r\n");
....................    flash_setting(mis_fm);
....................    sector_erase(mis_fm, 0x00000000);
....................    fprintf(PC, "End Flash Erase All\r\n");
.................... }
.................... 
.................... #Separate
.................... void mode_flash_erase_1sector()
.................... {
....................    fprintf(PC, "Start Flash Erase 1 Sector\r\n");
....................    flash_setting(mis_fm);
....................    sector_erase(mis_fm, 0x00000000);
....................    fprintf(PC, "End Flash Erase 1 Sector\r\n");
.................... }
.................... 
.................... #Separate
.................... void mode_flash_copy_1sector()
.................... {
....................    fprintf(PC, "Start Flash Copy 1 Sector\r\n");
....................    flash_setting(mis_fm);
....................    sector_erase(mis_fm, 0x00000000);
....................    fprintf(PC, "End Flash Copy 1 Sector\r\n");
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // SerialCommunication
.................... #include "./lib/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack();
.................... 
.................... void transmit_status();
.................... 
.................... int1 req_use_smf();
.................... 
.................... 
.................... #include "./src/communication_driver.c"
.................... 
.................... #endif
.................... 
.................... // EOF
.................... 
.................... 
.................... // Copy to SMF
.................... #include "./lib/data_copy.h"
.................... #ifndef DATA_COPY_H
.................... #define DATA_COPY_H
.................... 
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "src/smf_queue.c"
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "src/flash.c"
.................... 
.................... 
.................... // ADD 
.................... #define READ_ID_DATA_SIZE 20
.................... 
.................... #define MANUFACTURER_ID 0x20
.................... #define MEMORY_TYPE 0xBA
.................... #define MEMORY_CAPACITY_128M 0x18
.................... #define MEMORY_CAPACITY_1G   0x21
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... void copy_data();
.................... 
.................... 
.................... #include "./src/data_copy.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "src/smf_queue.c"
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "src/flash.c"
.................... 
.................... 
.................... // ADD 
.................... #define READ_ID_DATA_SIZE 20
.................... 
.................... #define MANUFACTURER_ID 0x20
.................... #define MEMORY_TYPE 0xBA
.................... #define MEMORY_CAPACITY_128M 0x18
.................... #define MEMORY_CAPACITY_1G   0x21
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void copy_data()
.................... {   
....................    while (!is_empty_smf_data())
*
151D:  MOVLP  08
151E:  CALL   52F
151F:  MOVLP  10
1520:  MOVF   78,F
1521:  BTFSS  03.2
1522:  GOTO   6C5
....................    {
....................       SmfDataStruct *smf_data = dequeue_smf_data();
*
1551:  MOVF   79,W
1552:  MOVLB  10
1553:  MOVWF  42
1554:  MOVF   78,W
1555:  MOVWF  41
....................       fprintf(PC, "Destination address: \t0x%08LX\r\n", smf_data->dest);
1556:  MOVF   41,W
1557:  MOVWF  04
1558:  MOVF   42,W
1559:  MOVWF  05
155A:  ADDFSR 04,FSR0
155B:  MOVF   00,W
155C:  MOVWF  44
155D:  ADDFSR 01,FSR0
155E:  MOVF   00,W
155F:  MOVWF  45
1560:  ADDFSR 01,FSR0
1561:  MOVF   00,W
1562:  MOVWF  46
1563:  ADDFSR 01,FSR0
1564:  MOVF   00,W
1565:  MOVWF  47
1566:  ADDFSR 3D,FSR0
1567:  MOVLW  74
1568:  MOVLB  03
1569:  MOVWF  11
156A:  MOVLW  04
156B:  MOVWF  12
156C:  BCF    03.0
156D:  MOVLW  18
156E:  MOVLB  11
156F:  MOVWF  27
1570:  MOVLP  08
1571:  MOVLB  00
1572:  CALL   149
1573:  MOVLP  10
1574:  MOVLB  10
1575:  MOVF   47,W
1576:  MOVLB  11
1577:  MOVWF  27
1578:  MOVLW  37
1579:  MOVWF  28
157A:  MOVLP  00
157B:  MOVLB  00
157C:  CALL   783
157D:  MOVLP  10
157E:  MOVLB  10
157F:  MOVF   46,W
1580:  MOVLB  11
1581:  MOVWF  27
1582:  MOVLW  37
1583:  MOVWF  28
1584:  MOVLP  00
1585:  MOVLB  00
1586:  CALL   783
1587:  MOVLP  10
1588:  MOVLB  10
1589:  MOVF   45,W
158A:  MOVLB  11
158B:  MOVWF  27
158C:  MOVLW  37
158D:  MOVWF  28
158E:  MOVLP  00
158F:  MOVLB  00
1590:  CALL   783
1591:  MOVLP  10
1592:  MOVLB  10
1593:  MOVF   44,W
1594:  MOVLB  11
1595:  MOVWF  27
1596:  MOVLW  37
1597:  MOVWF  28
1598:  MOVLP  00
1599:  MOVLB  00
159A:  CALL   783
159B:  MOVLP  10
159C:  MOVLW  0D
159D:  MOVLB  11
159E:  MOVWF  2B
159F:  MOVLP  00
15A0:  MOVLB  00
15A1:  CALL   67C
15A2:  MOVLP  10
15A3:  MOVLW  0A
15A4:  MOVLB  11
15A5:  MOVWF  2B
15A6:  MOVLP  00
15A7:  MOVLB  00
15A8:  CALL   67C
15A9:  MOVLP  10
....................       fprintf(PC, "Source address: \t0x%08LX\r\n", smf_data->src);
15AA:  MOVLB  10
15AB:  MOVF   41,W
15AC:  MOVWF  04
15AD:  MOVF   42,W
15AE:  MOVWF  05
15AF:  ADDFSR 00,FSR0
15B0:  MOVF   00,W
15B1:  MOVWF  44
15B2:  ADDFSR 01,FSR0
15B3:  MOVF   00,W
15B4:  MOVWF  45
15B5:  ADDFSR 01,FSR0
15B6:  MOVF   00,W
15B7:  MOVWF  46
15B8:  ADDFSR 01,FSR0
15B9:  MOVF   00,W
15BA:  MOVWF  47
15BB:  ADDFSR 3D,FSR0
15BC:  MOVLW  84
15BD:  MOVLB  03
15BE:  MOVWF  11
15BF:  MOVLW  04
15C0:  MOVWF  12
15C1:  BCF    03.0
15C2:  MOVLW  13
15C3:  MOVLB  11
15C4:  MOVWF  27
15C5:  MOVLP  08
15C6:  MOVLB  00
15C7:  CALL   149
15C8:  MOVLP  10
15C9:  MOVLB  10
15CA:  MOVF   47,W
15CB:  MOVLB  11
15CC:  MOVWF  27
15CD:  MOVLW  37
15CE:  MOVWF  28
15CF:  MOVLP  00
15D0:  MOVLB  00
15D1:  CALL   783
15D2:  MOVLP  10
15D3:  MOVLB  10
15D4:  MOVF   46,W
15D5:  MOVLB  11
15D6:  MOVWF  27
15D7:  MOVLW  37
15D8:  MOVWF  28
15D9:  MOVLP  00
15DA:  MOVLB  00
15DB:  CALL   783
15DC:  MOVLP  10
15DD:  MOVLB  10
15DE:  MOVF   45,W
15DF:  MOVLB  11
15E0:  MOVWF  27
15E1:  MOVLW  37
15E2:  MOVWF  28
15E3:  MOVLP  00
15E4:  MOVLB  00
15E5:  CALL   783
15E6:  MOVLP  10
15E7:  MOVLB  10
15E8:  MOVF   44,W
15E9:  MOVLB  11
15EA:  MOVWF  27
15EB:  MOVLW  37
15EC:  MOVWF  28
15ED:  MOVLP  00
15EE:  MOVLB  00
15EF:  CALL   783
15F0:  MOVLP  10
15F1:  MOVLW  0D
15F2:  MOVLB  11
15F3:  MOVWF  2B
15F4:  MOVLP  00
15F5:  MOVLB  00
15F6:  CALL   67C
15F7:  MOVLP  10
15F8:  MOVLW  0A
15F9:  MOVLB  11
15FA:  MOVWF  2B
15FB:  MOVLP  00
15FC:  MOVLB  00
15FD:  CALL   67C
15FE:  MOVLP  10
....................       fprintf(PC, "Data size: \t\t  %08LX\r\n", smf_data->size);
15FF:  MOVLB  10
1600:  MOVF   41,W
1601:  MOVWF  04
1602:  MOVF   42,W
1603:  MOVWF  05
1604:  ADDFSR 08,FSR0
1605:  MOVF   00,W
1606:  MOVWF  44
1607:  ADDFSR 01,FSR0
1608:  MOVF   00,W
1609:  MOVWF  45
160A:  ADDFSR 01,FSR0
160B:  MOVF   00,W
160C:  MOVWF  46
160D:  ADDFSR 01,FSR0
160E:  MOVF   00,W
160F:  MOVWF  47
1610:  ADDFSR 3D,FSR0
1611:  MOVLW  92
1612:  MOVLB  03
1613:  MOVWF  11
1614:  MOVLW  04
1615:  MOVWF  12
1616:  BCF    03.0
1617:  MOVLW  0F
1618:  MOVLB  11
1619:  MOVWF  27
161A:  MOVLP  08
161B:  MOVLB  00
161C:  CALL   149
161D:  MOVLP  10
161E:  MOVLB  10
161F:  MOVF   47,W
1620:  MOVLB  11
1621:  MOVWF  27
1622:  MOVLW  37
1623:  MOVWF  28
1624:  MOVLP  00
1625:  MOVLB  00
1626:  CALL   783
1627:  MOVLP  10
1628:  MOVLB  10
1629:  MOVF   46,W
162A:  MOVLB  11
162B:  MOVWF  27
162C:  MOVLW  37
162D:  MOVWF  28
162E:  MOVLP  00
162F:  MOVLB  00
1630:  CALL   783
1631:  MOVLP  10
1632:  MOVLB  10
1633:  MOVF   45,W
1634:  MOVLB  11
1635:  MOVWF  27
1636:  MOVLW  37
1637:  MOVWF  28
1638:  MOVLP  00
1639:  MOVLB  00
163A:  CALL   783
163B:  MOVLP  10
163C:  MOVLB  10
163D:  MOVF   44,W
163E:  MOVLB  11
163F:  MOVWF  27
1640:  MOVLW  37
1641:  MOVWF  28
1642:  MOVLP  00
1643:  MOVLB  00
1644:  CALL   783
1645:  MOVLP  10
1646:  MOVLW  0D
1647:  MOVLB  11
1648:  MOVWF  2B
1649:  MOVLP  00
164A:  MOVLB  00
164B:  CALL   67C
164C:  MOVLP  10
164D:  MOVLW  0A
164E:  MOVLB  11
164F:  MOVWF  2B
1650:  MOVLP  00
1651:  MOVLB  00
1652:  CALL   67C
1653:  MOVLP  10
....................       fprintf(PC, "Copying.");
1654:  MOVLW  9E
1655:  MOVLB  03
1656:  MOVWF  11
1657:  MOVLW  04
1658:  MOVWF  12
1659:  MOVLP  00
165A:  MOVLB  00
165B:  CALL   6A1
165C:  MOVLP  10
....................       delay_ms(1000);
165D:  MOVLW  04
165E:  MOVLB  10
165F:  MOVWF  44
1660:  MOVLW  FA
1661:  MOVWF  56
1662:  MOVLP  00
1663:  MOVLB  00
1664:  CALL   760
1665:  MOVLP  10
1666:  MOVLB  10
1667:  DECFSZ 44,F
1668:  GOTO   660
....................       fprintf(PC, ".");
1669:  MOVLW  2E
166A:  MOVLB  11
166B:  MOVWF  2B
166C:  MOVLP  00
166D:  MOVLB  00
166E:  CALL   67C
166F:  MOVLP  10
....................       delay_ms(1000);
1670:  MOVLW  04
1671:  MOVLB  10
1672:  MOVWF  44
1673:  MOVLW  FA
1674:  MOVWF  56
1675:  MOVLP  00
1676:  MOVLB  00
1677:  CALL   760
1678:  MOVLP  10
1679:  MOVLB  10
167A:  DECFSZ 44,F
167B:  GOTO   673
....................       fprintf(PC, ".");
167C:  MOVLW  2E
167D:  MOVLB  11
167E:  MOVWF  2B
167F:  MOVLP  00
1680:  MOVLB  00
1681:  CALL   67C
1682:  MOVLP  10
....................       delay_ms(1000);
1683:  MOVLW  04
1684:  MOVLB  10
1685:  MOVWF  44
1686:  MOVLW  FA
1687:  MOVWF  56
1688:  MOVLP  00
1689:  MOVLB  00
168A:  CALL   760
168B:  MOVLP  10
168C:  MOVLB  10
168D:  DECFSZ 44,F
168E:  GOTO   686
....................       fprintf(PC, ".");   
168F:  MOVLW  2E
1690:  MOVLB  11
1691:  MOVWF  2B
1692:  MOVLP  00
1693:  MOVLB  00
1694:  CALL   67C
1695:  MOVLP  10
....................       delay_ms(1000);
1696:  MOVLW  04
1697:  MOVLB  10
1698:  MOVWF  44
1699:  MOVLW  FA
169A:  MOVWF  56
169B:  MOVLP  00
169C:  MOVLB  00
169D:  CALL   760
169E:  MOVLP  10
169F:  MOVLB  10
16A0:  DECFSZ 44,F
16A1:  GOTO   699
....................       fprintf(PC, ".\r\n");   
16A2:  MOVLW  2E
16A3:  MOVLB  11
16A4:  MOVWF  2B
16A5:  MOVLP  00
16A6:  MOVLB  00
16A7:  CALL   67C
16A8:  MOVLP  10
16A9:  MOVLW  0D
16AA:  MOVLB  11
16AB:  MOVWF  2B
16AC:  MOVLP  00
16AD:  MOVLB  00
16AE:  CALL   67C
16AF:  MOVLP  10
16B0:  MOVLW  0A
16B1:  MOVLB  11
16B2:  MOVWF  2B
16B3:  MOVLP  00
16B4:  MOVLB  00
16B5:  CALL   67C
16B6:  MOVLP  10
....................       delay_ms(1000);
16B7:  MOVLW  04
16B8:  MOVLB  10
16B9:  MOVWF  44
16BA:  MOVLW  FA
16BB:  MOVWF  56
16BC:  MOVLP  00
16BD:  MOVLB  00
16BE:  CALL   760
16BF:  MOVLP  10
16C0:  MOVLB  10
16C1:  DECFSZ 44,F
16C2:  GOTO   6BA
16C3:  MOVLB  00
16C4:  GOTO   51D
....................    }
....................    fprintf(PC, "_________End copy_data_________\r\n______________________________\r\n\r\n");
16C5:  MOVLW  A3
16C6:  MOVLB  03
16C7:  MOVWF  11
16C8:  MOVLW  04
16C9:  MOVWF  12
16CA:  MOVLP  00
16CB:  MOVLB  00
16CC:  CALL   6A1
16CD:  MOVLP  10
.................... }
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... #define PARAMETER_LENGTH 8
.................... 
.................... #Separate
.................... int1 execute_command(Command *command);
.................... int1 handle_uplink_command(Command *command);
.................... int1 handle_status_check(Command *command);
.................... int1 handle_smf_available(Command *command);
.................... void execute_mission(unsigned int8 *content);
.................... 
.................... #include "../mmj_cigs_excute_mission.c"
.................... #include "mmj_cigs_mode.h"
.................... #ifndef MMJ_CIGS_MODE_H
.................... #define MMJ_CIGS_MODE_H
.................... 
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... #Separate
.................... void mode_measure(unsigned int8 parameter[]);
.................... 
.................... // Flash command 
.................... #Separate
.................... void mode_flash_erase_all();
.................... #Separate
.................... void mode_flash_erase_1sector();
.................... #Separate
.................... void mode_flash_copy_1sector();
.................... #Separate
.................... void mode_flash_write_1sector();
.................... #Separate
.................... void mode_flash_func2();
.................... #Separate
.................... void mode_flash_read();
.................... #Separate
.................... void mode_flash_read_address();
.................... 
.................... // IV command
.................... #Separate
.................... void mode_iv_measure();
.................... #Separate
.................... void mode_iv_measure_voltage();
.................... 
.................... 
.................... 
.................... // Development command
.................... #Separate
.................... void mode_dev_vol();
.................... #Separate
.................... void mode_dev_cur();
.................... #Separate
.................... void mode_dev_temp();   
.................... #Separate
.................... void mode_dev_pd();
.................... #Separate
.................... void mode_dev_cigs();
.................... #Separate
.................... void mode_dev_time();
.................... #Separate
.................... void mode_dev_sweep();
.................... 
.................... // ______________CMD ID________________
.................... #define ID_SWEEP 0x01
.................... 
.................... // Flash command 
.................... #define ID_FLASH_ERASE_ALL 0xA0
.................... #define ID_FLASH_ERASE_1SECTOR 0xA1
.................... #define ID_FLASH_COPY_1SECTOR 0xA2
.................... #define ID_FLASH_WRITE_1SECTOR 0xA3
.................... #define ID_FLASH_FUNC2 0xA4
.................... #define ID_FLASH_READ 0xA5
.................... #define ID_FLASH_READ_ADDRESS 0xA6
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_DEV_VOL 0xC0
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... #include "../mmj_cigs_mode.c"
.................... 
.................... #endif // MMJ_CIGS_MODE_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #separate
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
1340:  MOVLW  C5
1341:  MOVLB  03
1342:  MOVWF  11
1343:  MOVLW  04
1344:  MOVWF  12
1345:  MOVLP  00
1346:  MOVLB  00
1347:  CALL   6A1
1348:  MOVLP  10
.................... 
....................    switch (command->frame_id)
1349:  MOVLB  10
134A:  MOVF   3D,W
134B:  MOVWF  04
134C:  MOVF   3E,W
134D:  MOVWF  05
134E:  ADDFSR 00,FSR0
134F:  MOVF   00,W
1350:  XORLW  00
1351:  MOVLB  00
1352:  BTFSC  03.2
1353:  GOTO   35B
1354:  XORLW  01
1355:  BTFSC  03.2
1356:  GOTO   493
1357:  XORLW  03
1358:  BTFSC  03.2
1359:  GOTO   4EF
135A:  GOTO   6DF
....................    {
....................       case UPLINK_COMMAND:
....................          return handle_uplink_command(command);
135B:  MOVLB  10
135C:  MOVF   3E,W
135D:  MOVWF  40
135E:  MOVF   3D,W
135F:  MOVWF  3F
*
1491:  MOVF   78,W
1492:  GOTO   6E1
....................       
....................       case STATUS_CHECK:
....................          return handle_status_check(command);
1493:  MOVLB  10
1494:  MOVF   3E,W
1495:  MOVWF  40
1496:  MOVF   3D,W
1497:  MOVWF  3F
*
14ED:  MOVF   78,W
14EE:  GOTO   6E1
....................       
....................       case IS_SMF_AVAILABLE:
....................          return handle_smf_available(command);
14EF:  MOVLB  10
14F0:  MOVF   3E,W
14F1:  MOVWF  40
14F2:  MOVF   3D,W
14F3:  MOVWF  3F
*
16DD:  MOVF   78,W
16DE:  GOTO   6E1
....................    }
.................... 
....................    return FALSE;
16DF:  MOVLW  00
16E0:  MOVWF  78
16E1:  MOVLP  08
16E2:  GOTO   6B3 (RETURN)
.................... }
.................... 
.................... 
.................... // ___________ command execution ___________
.................... int1 handle_uplink_command(Command *command)
.................... {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
1360:  MOVLW  D1
1361:  MOVLB  03
1362:  MOVWF  11
1363:  MOVLW  04
1364:  MOVWF  12
1365:  MOVLP  00
1366:  MOVLB  00
1367:  CALL   6A1
1368:  MOVLP  10
....................    fprintf(PC, "\t   Transmit Acknowledge\r\n");
1369:  MOVLW  DC
136A:  MOVLB  03
136B:  MOVWF  11
136C:  MOVLW  04
136D:  MOVWF  12
136E:  MOVLP  00
136F:  MOVLB  00
1370:  CALL   6A1
1371:  MOVLP  10
....................    transmit_ack();
1372:  MOVLP  08
1373:  CALL   4E7
1374:  MOVLP  10
.................... 
....................    status = EXECUTING_MISSION;
1375:  MOVLW  02
1376:  MOVWF  2B
....................    execute_mission(command->content);
1377:  MOVLW  01
1378:  MOVLB  10
1379:  ADDWF  3F,W
137A:  MOVWF  78
137B:  MOVLW  00
137C:  ADDWFC 40,W
137D:  MOVWF  7A
137E:  MOVF   78,W
137F:  MOVWF  42
1380:  MOVF   7A,W
1381:  MOVWF  43
1382:  MOVF   43,W
1383:  MOVWF  45
1384:  MOVF   42,W
1385:  MOVWF  44
.................... 
....................    if (is_empty_smf_data())
*
1471:  MOVLP  08
1472:  CALL   52F
1473:  MOVLP  10
1474:  MOVF   78,F
1475:  BTFSC  03.2
1476:  GOTO   48D
....................    {
....................       if (duration_sec < sec)
1477:  MOVF   33,F
1478:  BTFSS  03.2
1479:  GOTO   487
147A:  MOVF   32,F
147B:  BTFSS  03.2
147C:  GOTO   487
147D:  MOVF   29,W
147E:  SUBWF  31,W
147F:  BTFSS  03.0
1480:  GOTO   48A
1481:  BTFSS  03.2
1482:  GOTO   487
1483:  MOVF   30,W
1484:  SUBWF  28,W
1485:  BTFSC  03.0
1486:  GOTO   48A
....................          status = FINISHED;
1487:  MOVLW  06
1488:  MOVWF  2B
1489:  GOTO   48C
....................       else
....................          status = IDLE;
148A:  MOVLW  03
148B:  MOVWF  2B
....................    }
148C:  GOTO   48F
....................    else
....................    {
....................       status = SMF_USE_REQ;
148D:  MOVLW  04
148E:  MOVWF  2B
....................    }
.................... 
....................    return FALSE;
148F:  MOVLW  00
1490:  MOVWF  78
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command)
.................... {
....................    fprintf(PC, "\t-> Status check\r\n");
*
1498:  MOVLW  EA
1499:  MOVLB  03
149A:  MOVWF  11
149B:  MOVLW  04
149C:  MOVWF  12
149D:  MOVLP  00
149E:  MOVLB  00
149F:  CALL   6A1
14A0:  MOVLP  10
....................    fprintf(PC, "\t\t-> My status is %d\r\n", status);
14A1:  MOVLW  F4
14A2:  MOVLB  03
14A3:  MOVWF  11
14A4:  MOVLW  04
14A5:  MOVWF  12
14A6:  BCF    03.0
14A7:  MOVLW  12
14A8:  MOVLB  11
14A9:  MOVWF  27
14AA:  MOVLP  08
14AB:  MOVLB  00
14AC:  CALL   149
14AD:  MOVLP  10
14AE:  MOVF   2B,W
14AF:  MOVLB  10
14B0:  MOVWF  49
14B1:  MOVLW  18
14B2:  MOVWF  4A
14B3:  MOVLP  08
14B4:  MOVLB  00
14B5:  CALL   3E6
14B6:  MOVLP  10
14B7:  MOVLW  0D
14B8:  MOVLB  11
14B9:  MOVWF  2B
14BA:  MOVLP  00
14BB:  MOVLB  00
14BC:  CALL   67C
14BD:  MOVLP  10
14BE:  MOVLW  0A
14BF:  MOVLB  11
14C0:  MOVWF  2B
14C1:  MOVLP  00
14C2:  MOVLB  00
14C3:  CALL   67C
14C4:  MOVLP  10
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
14C5:  MOVLW  00
14C6:  MOVLB  03
14C7:  MOVWF  11
14C8:  MOVLW  05
14C9:  MOVWF  12
14CA:  MOVLP  00
14CB:  MOVLB  00
14CC:  CALL   6A1
14CD:  MOVLP  10
....................    transmit_status();
.................... 
....................    if (status == FINISHED)
*
14DB:  MOVF   2B,W
14DC:  SUBLW  06
14DD:  BTFSS  03.2
14DE:  GOTO   4EB
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
14DF:  MOVLW  0F
14E0:  MOVLB  03
14E1:  MOVWF  11
14E2:  MOVLW  05
14E3:  MOVWF  12
14E4:  MOVLP  00
14E5:  MOVLB  00
14E6:  CALL   6A1
14E7:  MOVLP  10
....................       return TRUE;
14E8:  MOVLW  01
14E9:  MOVWF  78
14EA:  GOTO   4ED
....................    }
.................... 
....................    return FALSE;
14EB:  MOVLW  00
14EC:  MOVWF  78
.................... }
.................... 
.................... int1 handle_smf_available(Command *command)
.................... {
....................    fprintf(PC, "\t-> is SMF available\r\n");
*
14F4:  MOVLW  1D
14F5:  MOVLB  03
14F6:  MOVWF  11
14F7:  MOVLW  05
14F8:  MOVWF  12
14F9:  MOVLP  00
14FA:  MOVLB  00
14FB:  CALL   6A1
14FC:  MOVLP  10
....................    fprintf(PC, "\t   Transmit Acknowledge\r\n");
14FD:  MOVLW  29
14FE:  MOVLB  03
14FF:  MOVWF  11
1500:  MOVLW  05
1501:  MOVWF  12
1502:  MOVLP  00
1503:  MOVLB  00
1504:  CALL   6A1
1505:  MOVLP  10
....................    transmit_ack();
1506:  MOVLP  08
1507:  CALL   4E7
1508:  MOVLP  10
.................... 
....................    if (command->content[0] == ALLOW)
1509:  MOVLB  10
150A:  MOVF   3F,W
150B:  MOVWF  04
150C:  MOVF   40,W
150D:  MOVWF  05
150E:  ADDFSR 01,FSR0
150F:  MOVF   00,F
1510:  BTFSS  03.2
1511:  GOTO   6D2
....................    {
....................       fprintf(PC, "\t\t-> allowed\r\n");
1512:  MOVLW  37
1513:  MOVLB  03
1514:  MOVWF  11
1515:  MOVLW  05
1516:  MOVWF  12
1517:  MOVLP  00
1518:  MOVLB  00
1519:  CALL   6A1
151A:  MOVLP  10
....................       status = COPYING;
151B:  MOVLW  05
151C:  MOVWF  2B
....................       copy_data();
....................       status = FINISHED;
*
16CE:  MOVLW  06
16CF:  MOVWF  2B
....................    }
16D0:  GOTO   6DB
16D1:  MOVLB  10
....................    else
....................    {
....................       fprintf(PC, "\t\t-> denied\r\n");
16D2:  MOVLW  3F
16D3:  MOVLB  03
16D4:  MOVWF  11
16D5:  MOVLW  05
16D6:  MOVWF  12
16D7:  MOVLP  00
16D8:  MOVLB  00
16D9:  CALL   6A1
16DA:  MOVLP  10
....................    }
.................... 
....................    return FALSE;
16DB:  MOVLW  00
16DC:  MOVWF  78
.................... }
.................... 
.................... void execute_mission(unsigned int8 *content)
*
1386:  MOVF   44,W
1387:  MOVWF  04
1388:  MOVF   45,W
1389:  MOVWF  05
138A:  MOVIW  [FSR0+00],W
138B:  MOVWF  46
138C:  MOVLW  01
138D:  ADDWF  44,W
138E:  MOVWF  78
138F:  MOVLW  00
1390:  ADDWFC 45,W
1391:  MOVWF  7A
1392:  MOVF   78,W
1393:  MOVWF  47
1394:  MOVF   7A,W
1395:  MOVWF  48
.................... {
....................    // record to executed mission list
....................    unsigned int8 command_id = content[0];
....................    unsigned int8 *parameter = &content[1];
....................    
....................    if (is_executed_mission(command_id))
1396:  MOVF   46,W
1397:  MOVWF  49
*
13C4:  MOVF   78,F
13C5:  BTFSC  03.2
13C6:  GOTO   3ED
....................    {
....................       fprintf(PC, "\r\nThis  mission is executed\r\n\t-> 0x%d\r\n", command_id);
13C7:  MOVLW  46
13C8:  MOVLB  03
13C9:  MOVWF  11
13CA:  MOVLW  05
13CB:  MOVWF  12
13CC:  BCF    03.0
13CD:  MOVLW  23
13CE:  MOVLB  11
13CF:  MOVWF  27
13D0:  MOVLP  08
13D1:  MOVLB  00
13D2:  CALL   149
13D3:  MOVLP  10
13D4:  MOVLB  10
13D5:  MOVF   46,W
13D6:  MOVWF  49
13D7:  MOVLW  18
13D8:  MOVWF  4A
13D9:  MOVLP  08
13DA:  MOVLB  00
13DB:  CALL   3E6
13DC:  MOVLP  10
13DD:  MOVLW  0D
13DE:  MOVLB  11
13DF:  MOVWF  2B
13E0:  MOVLP  00
13E1:  MOVLB  00
13E2:  CALL   67C
13E3:  MOVLP  10
13E4:  MOVLW  0A
13E5:  MOVLB  11
13E6:  MOVWF  2B
13E7:  MOVLP  00
13E8:  MOVLB  00
13E9:  CALL   67C
13EA:  MOVLP  10
....................       return;
13EB:  GOTO   471
13EC:  MOVLB  10
....................    }
....................    
....................    add_executed_mission(command_id);
13ED:  MOVF   46,W
13EE:  MOVWF  49
....................    
....................    // execution mission
....................    fprintf(PC, "\r\n____________________________________\r\n________Start execute_mission________\r\n\r\n");
*
141D:  MOVLW  5A
141E:  MOVLB  03
141F:  MOVWF  11
1420:  MOVLW  05
1421:  MOVWF  12
1422:  MOVLP  00
1423:  MOVLB  00
1424:  CALL   6A1
1425:  MOVLP  10
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
1426:  MOVLW  83
1427:  MOVLB  03
1428:  MOVWF  11
1429:  MOVLW  05
142A:  MOVWF  12
142B:  BCF    03.0
142C:  MOVLW  0C
142D:  MOVLB  11
142E:  MOVWF  27
142F:  MOVLP  08
1430:  MOVLB  00
1431:  CALL   149
1432:  MOVLP  10
1433:  MOVLB  10
1434:  MOVF   46,W
1435:  MOVLB  11
1436:  MOVWF  27
1437:  MOVLW  37
1438:  MOVWF  28
1439:  MOVLP  00
143A:  MOVLB  00
143B:  CALL   783
143C:  MOVLP  10
143D:  MOVLW  8A
143E:  MOVLB  03
143F:  MOVWF  11
1440:  MOVLW  05
1441:  MOVWF  12
1442:  BCF    03.0
1443:  MOVLW  04
1444:  MOVLB  11
1445:  MOVWF  27
1446:  MOVLP  08
1447:  MOVLB  00
1448:  CALL   149
1449:  MOVLP  10
....................    switch(command_id)
144A:  MOVLB  10
144B:  MOVF   46,W
144C:  XORLW  01
144D:  MOVLB  00
144E:  BTFSC  03.2
144F:  GOTO   454
1450:  XORLW  A1
1451:  BTFSC  03.2
1452:  GOTO   45E
1453:  GOTO   45F
....................    {
....................       case ID_SWEEP:
....................          mode_measure(parameter);
1454:  MOVLB  10
1455:  MOVF   48,W
1456:  MOVWF  4A
1457:  MOVF   47,W
1458:  MOVWF  49
1459:  MOVLP  08
145A:  MOVLB  00
145B:  GOTO   517
145C:  MOVLP  10
....................          break;
145D:  GOTO   468
....................       case ID_FLASH_ERASE_ALL:
....................          break;
145E:  GOTO   468
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
145F:  MOVLW  8D
1460:  MOVLB  03
1461:  MOVWF  11
1462:  MOVLW  05
1463:  MOVWF  12
1464:  MOVLP  00
1465:  MOVLB  00
1466:  CALL   6A1
1467:  MOVLP  10
....................    }
....................    fprintf(PC, "\r\n_________End execute_mission_________\r\n____________________________________\r\n");
1468:  MOVLW  99
1469:  MOVLB  03
146A:  MOVWF  11
146B:  MOVLW  05
146C:  MOVWF  12
146D:  MOVLP  00
146E:  MOVLB  00
146F:  CALL   6A1
1470:  MOVLP  10
.................... }
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef     MMJ_CIGS_FLASH_H
.................... #define     MMJ_CIGS_FLASH_H
.................... 
.................... void misf_init(void);
.................... void misf_read_id(void);
.................... 
.................... 
.................... 
.................... 
.................... // Flash Area
.................... 
.................... // PICLOG
.................... #define ADDRESS_PICLOG_START 0x000000
.................... #define ADDRESS_PICLOG_END   0x000FFF
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include "../mmj_cigs_flash.c"
.................... 
.................... #endif // MMJ_CIGS_FLASH_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0D3A:  MOVLB  03
0D3B:  BSF    1F.3
0D3C:  MOVLW  A0
0D3D:  MOVWF  1B
0D3E:  MOVLW  01
0D3F:  MOVWF  1C
0D40:  MOVLW  A6
0D41:  MOVWF  1E
0D42:  MOVLW  90
0D43:  MOVWF  1D
0D44:  MOVLB  01
0D45:  BCF    0D.4
0D46:  MOVLB  02
0D47:  BSF    0D.4
0D48:  MOVLB  04
0D49:  BCF    15.5
0D4A:  MOVLW  40
0D4B:  MOVWF  14
0D4C:  MOVLW  09
0D4D:  MOVWF  12
0D4E:  MOVLW  2A
0D4F:  MOVWF  15
0D50:  MOVLB  02
0D51:  BCF    1D.5
0D52:  BCF    1D.3
0D53:  BCF    1D.4
0D54:  MOVLB  01
0D55:  BCF    0E.5
0D56:  BSF    0E.4
0D57:  BCF    0E.3
0D58:  MOVLB  00
0D59:  CLRF   29
0D5A:  CLRF   28
0D5B:  BCF    2A.0
0D5C:  MOVLW  03
0D5D:  MOVWF  2B
0D5E:  CLRF   2F
0D5F:  CLRF   2E
0D60:  CLRF   2D
0D61:  CLRF   2C
0D62:  CLRF   33
0D63:  CLRF   32
0D64:  CLRF   31
0D65:  CLRF   30
0D66:  CLRF   35
0D67:  CLRF   34
0D68:  CLRF   37
0D69:  CLRF   36
0D6A:  CLRF   58
0D6B:  MOVLB  0C
0D6C:  CLRF   2C
0D6D:  CLRF   2B
0D6E:  CLRF   2A
0D6F:  CLRF   29
0D70:  CLRF   2E
0D71:  CLRF   2D
0D72:  CLRF   30
0D73:  CLRF   2F
0D74:  CLRF   32
0D75:  CLRF   31
0D76:  CLRF   34
0D77:  CLRF   33
0D78:  MOVLB  03
0D79:  CLRF   0C
0D7A:  CLRF   0D
0D7B:  CLRF   0E
0D7C:  CLRF   0F
0D7D:  CLRF   10
0D7E:  MOVLB  02
0D7F:  CLRF   12
0D80:  CLRF   11
0D81:  GOTO   5AE
0D82:  DATA 20,34
0D83:  DATA 60,34
0D84:  DATA 18,34
0D85:  DATA 00,34
0D86:  DATA FF,34
0D87:  DATA 60,34
0D88:  DATA 39,34
0D89:  DATA 00,34
0D8A:  DATA FF,34
0D8B:  DATA C0,34
0D8C:  DATA 00,34
0D8D:  DATA FF,34
0D8E:  DATA C0,34
0D8F:  DATA 00,34
0D90:  DATA 93,34
0D91:  DATA C0,34
0D92:  DATA 00,34
0D93:  DATA 42,34
0D94:  DATA 63,34
0D95:  DATA D9,34
0D96:  DATA 00,34
0D97:  DATA 06,34
0D98:  DATA 80,34
0D99:  DATA 79,34
0D9A:  DATA 00,34
0D9B:  DATA 01,34
0D9C:  DATA 01,34
0D9D:  DATA 72,34
0D9E:  DATA 00,34
0D9F:  DATA C3,34
0DA0:  DATA 64,34
0DA1:  DATA 27,34
0DA2:  DATA 00,34
0DA3:  DATA 05,34
0DA4:  DATA 80,34
0DA5:  DATA 09,34
0DA6:  DATA 01,34
0DA7:  DATA 00,34
0DA8:  DATA 02,34
0DA9:  DATA 01,34
0DAA:  DATA 09,34
0DAB:  DATA C0,34
0DAC:  DATA 00,34
0DAD:  DATA 00,34
0DAE:  MOVLW  0D
0DAF:  MOVWF  05
0DB0:  MOVLW  82
0DB1:  MOVWF  04
0DB2:  BSF    05.7
0DB3:  MOVIW  [FSR0++],W
0DB4:  MOVWF  77
0DB5:  XORLW  00
0DB6:  BTFSC  03.2
0DB7:  GOTO   5C8
0DB8:  MOVIW  [FSR0++],W
0DB9:  MOVWF  78
0DBA:  BTFSC  78.7
0DBB:  GOTO   5C0
0DBC:  ANDLW  3F
0DBD:  MOVWF  07
0DBE:  MOVIW  [FSR0++],W
0DBF:  MOVWF  06
0DC0:  BTFSC  78.6
0DC1:  MOVIW  [FSR0++],W
0DC2:  BTFSS  78.6
0DC3:  MOVIW  [FSR0++],W
0DC4:  MOVWI  W,[FSR1++]
0DC5:  DECFSZ 77,F
0DC6:  GOTO   5C2
0DC7:  GOTO   5B3
.................... { 
....................    fprintf(PC,"\r\n\r\n============================================================\r\n");
0DC8:  MOVLW  C1
0DC9:  MOVLB  03
0DCA:  MOVWF  11
0DCB:  MOVLW  05
0DCC:  MOVWF  12
0DCD:  MOVLP  00
0DCE:  MOVLB  00
0DCF:  CALL   6A1
0DD0:  MOVLP  08
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM1.\r\n");
0DD1:  MOVLW  E3
0DD2:  MOVLB  03
0DD3:  MOVWF  11
0DD4:  MOVLW  05
0DD5:  MOVWF  12
0DD6:  MOVLP  00
0DD7:  MOVLB  00
0DD8:  CALL   6A1
0DD9:  MOVLP  08
....................    fprintf(PC,"Last updated on 2025/04/25, by Inoue.\r\n\r\n");  
0DDA:  MOVLW  FA
0DDB:  MOVLB  03
0DDC:  MOVWF  11
0DDD:  MOVLW  05
0DDE:  MOVWF  12
0DDF:  MOVLP  00
0DE0:  MOVLB  00
0DE1:  CALL   6A1
0DE2:  MOVLP  08
.................... 
....................    
....................    io_init();
0DE3:  MOVLP  00
0DE4:  GOTO   6EF
0DE5:  MOVLP  08
....................    adc_init();
0DE6:  MOVLP  00
0DE7:  GOTO   707
0DE8:  MOVLP  08
....................    uart_init();
0DE9:  MOVLP  00
0DEA:  GOTO   72F
0DEB:  MOVLP  08
....................    timer_init();
0DEC:  MOVLP  00
0DED:  GOTO   743
0DEE:  MOVLP  08
....................    misf_init();
0DEF:  GOTO   000
.................... 
.................... 
....................    int1 is_finished = FALSE;
0DF0:  MOVLB  0F
0DF1:  BCF    68.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0DF2:  MOVLW  0F
0DF3:  MOVLB  03
0DF4:  MOVWF  11
0DF5:  MOVLW  06
0DF6:  MOVWF  12
0DF7:  MOVLP  00
0DF8:  MOVLB  00
0DF9:  CALL   6A1
0DFA:  MOVLP  08
....................    fprintf(PC,"waiting for BOSS PIC command");
0DFB:  MOVLW  22
0DFC:  MOVLB  03
0DFD:  MOVWF  11
0DFE:  MOVLW  06
0DFF:  MOVWF  12
0E00:  MOVLP  00
0E01:  MOVLB  00
0E02:  CALL   6A1
0E03:  MOVLP  08
....................    
....................    //Start loop
....................    while(!is_finished)
0E04:  MOVLB  0F
0E05:  BTFSC  68.0
0E06:  GOTO   6F8
....................    {
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0E07:  MOVLB  00
0E08:  MOVF   58,F
0E09:  BTFSC  03.2
0E0A:  GOTO   6C4
....................       {
....................          volatile Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0E0B:  MOVLW  20
0E0C:  MOVLB  10
0E0D:  MOVWF  44
0E0E:  MOVLW  18
0E0F:  MOVWF  43
0E10:  MOVLB  00
0E11:  MOVF   58,W
0E12:  MOVLB  10
0E13:  MOVWF  45
0E14:  MOVLB  00
0E15:  GOTO   1A5
0E16:  MOVF   79,W
0E17:  MOVWF  7A
0E18:  MOVF   78,W
0E19:  MOVWF  04
0E1A:  MOVF   7A,W
0E1B:  MOVWF  05
0E1C:  MOVLW  23
0E1D:  MOVWF  78
0E1E:  MOVLW  24
0E1F:  MOVWF  07
0E20:  MOVLW  F9
0E21:  MOVWF  06
0E22:  MOVIW  [FSR0++],W
0E23:  MOVWI  W,[FSR1++]
0E24:  DECFSZ 78,F
0E25:  GOTO   622
....................          
....................          fprintf(PC, "FrameID: %1X\r\n", command.frame_id);
0E26:  MOVLW  31
0E27:  MOVLB  03
0E28:  MOVWF  11
0E29:  MOVLW  06
0E2A:  MOVWF  12
0E2B:  BCF    03.0
0E2C:  MOVLW  09
0E2D:  MOVLB  11
0E2E:  MOVWF  27
0E2F:  MOVLB  00
0E30:  CALL   149
0E31:  MOVLB  0F
0E32:  MOVF   69,W
0E33:  MOVLB  11
0E34:  MOVWF  27
0E35:  MOVLW  B7
0E36:  MOVWF  28
0E37:  MOVLP  00
0E38:  MOVLB  00
0E39:  CALL   783
0E3A:  MOVLP  08
0E3B:  MOVLW  0D
0E3C:  MOVLB  11
0E3D:  MOVWF  2B
0E3E:  MOVLP  00
0E3F:  MOVLB  00
0E40:  CALL   67C
0E41:  MOVLP  08
0E42:  MOVLW  0A
0E43:  MOVLB  11
0E44:  MOVWF  2B
0E45:  MOVLP  00
0E46:  MOVLB  00
0E47:  CALL   67C
0E48:  MOVLP  08
....................          fprintf(PC, "payload size: %d\r\n", command.size);
0E49:  MOVLW  39
0E4A:  MOVLB  03
0E4B:  MOVWF  11
0E4C:  MOVLW  06
0E4D:  MOVWF  12
0E4E:  BCF    03.0
0E4F:  MOVLW  0E
0E50:  MOVLB  11
0E51:  MOVWF  27
0E52:  MOVLB  00
0E53:  CALL   149
0E54:  MOVLB  10
0E55:  MOVF   3A,W
0E56:  MOVWF  49
0E57:  MOVLW  18
0E58:  MOVWF  4A
0E59:  MOVLB  00
0E5A:  CALL   3E6
0E5B:  MOVLW  0D
0E5C:  MOVLB  11
0E5D:  MOVWF  2B
0E5E:  MOVLP  00
0E5F:  MOVLB  00
0E60:  CALL   67C
0E61:  MOVLP  08
0E62:  MOVLW  0A
0E63:  MOVLB  11
0E64:  MOVWF  2B
0E65:  MOVLP  00
0E66:  MOVLB  00
0E67:  CALL   67C
0E68:  MOVLP  08
....................          fprintf(PC, "payload: ");
0E69:  MOVLW  43
0E6A:  MOVLB  03
0E6B:  MOVWF  11
0E6C:  MOVLW  06
0E6D:  MOVWF  12
0E6E:  MOVLP  00
0E6F:  MOVLB  00
0E70:  CALL   6A1
0E71:  MOVLP  08
....................          for(int8 i = 0; i < command.size; i++)
0E72:  MOVLB  10
0E73:  CLRF   3C
0E74:  MOVF   3A,W
0E75:  SUBWF  3C,W
0E76:  BTFSC  03.0
0E77:  GOTO   693
....................             fprintf(PC, "%X ", command.content[i]);
0E78:  MOVLW  FA
0E79:  ADDWF  3C,W
0E7A:  MOVWF  04
0E7B:  MOVLW  24
0E7C:  MOVWF  05
0E7D:  BTFSC  03.0
0E7E:  INCF   05,F
0E7F:  MOVF   00,W
0E80:  MOVWF  3D
0E81:  MOVLB  11
0E82:  MOVWF  27
0E83:  MOVLW  37
0E84:  MOVWF  28
0E85:  MOVLP  00
0E86:  MOVLB  00
0E87:  CALL   783
0E88:  MOVLP  08
0E89:  MOVLW  20
0E8A:  MOVLB  11
0E8B:  MOVWF  2B
0E8C:  MOVLP  00
0E8D:  MOVLB  00
0E8E:  CALL   67C
0E8F:  MOVLP  08
0E90:  MOVLB  10
0E91:  INCF   3C,F
0E92:  GOTO   674
....................          fprintf(PC, "\r\n\r\n");
0E93:  MOVLW  48
0E94:  MOVLB  03
0E95:  MOVWF  11
0E96:  MOVLW  06
0E97:  MOVWF  12
0E98:  MOVLP  00
0E99:  MOVLB  00
0E9A:  CALL   6A1
0E9B:  MOVLP  08
....................          
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0E9C:  MOVLW  20
0E9D:  MOVLB  10
0E9E:  MOVWF  3E
0E9F:  MOVLW  18
0EA0:  MOVWF  3D
0EA1:  MOVLW  20
0EA2:  MOVWF  40
0EA3:  MOVLW  38
0EA4:  MOVWF  3F
0EA5:  MOVLP  00
0EA6:  MOVLB  00
0EA7:  GOTO   7DA
0EA8:  MOVLP  08
....................             
....................          if(command.is_exist)
0EA9:  MOVLB  10
0EAA:  BTFSS  3B.0
0EAB:  GOTO   6BA
....................             is_finished = execute_command(&command);
0EAC:  MOVLW  24
0EAD:  MOVWF  3E
0EAE:  MOVLW  F9
0EAF:  MOVWF  3D
0EB0:  MOVLP  10
0EB1:  MOVLB  00
0EB2:  GOTO   340
0EB3:  MOVLP  08
0EB4:  MOVLB  0F
0EB5:  BCF    68.0
0EB6:  BTFSC  78.0
0EB7:  BSF    68.0
0EB8:  GOTO   6C5
0EB9:  MOVLB  10
....................          else
....................          {
....................             fprintf(PC, "\t-> Invalid command\r\n");
0EBA:  MOVLW  4B
0EBB:  MOVLB  03
0EBC:  MOVWF  11
0EBD:  MOVLW  06
0EBE:  MOVWF  12
0EBF:  MOVLP  00
0EC0:  MOVLB  00
0EC1:  CALL   6A1
0EC2:  MOVLP  08
....................             continue;
0EC3:  GOTO   604
0EC4:  MOVLB  0F
....................          }
....................       }   // check if the command is valid
....................       
....................       // check mis mcu duration seconds (used in mission.c \ void continue_mis_mcu(int16 duration_sec))
....................       if (status == IDLE)
0EC5:  MOVLB  00
0EC6:  MOVF   2B,W
0EC7:  SUBLW  03
0EC8:  BTFSS  03.2
0EC9:  GOTO   6E0
....................          if (duration_sec < sec && is_empty_smf_data())
0ECA:  MOVF   33,F
0ECB:  BTFSS  03.2
0ECC:  GOTO   6DA
0ECD:  MOVF   32,F
0ECE:  BTFSS  03.2
0ECF:  GOTO   6DA
0ED0:  MOVF   29,W
0ED1:  SUBWF  31,W
0ED2:  BTFSS  03.0
0ED3:  GOTO   6E0
0ED4:  BTFSS  03.2
0ED5:  GOTO   6DA
0ED6:  MOVF   30,W
0ED7:  SUBWF  28,W
0ED8:  BTFSC  03.0
0ED9:  GOTO   6E0
0EDA:  CALL   52F
0EDB:  MOVF   78,F
0EDC:  BTFSC  03.2
0EDD:  GOTO   6E0
....................             status = FINISHED;
0EDE:  MOVLW  06
0EDF:  MOVWF  2B
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0EE0:  MOVLB  0F
0EE1:  BTFSC  68.0
....................          break;
0EE2:  GOTO   6F8
....................          
....................       delay_ms(400);
0EE3:  MOVLW  02
0EE4:  MOVLB  10
0EE5:  MOVWF  3D
0EE6:  MOVLW  C8
0EE7:  MOVWF  56
0EE8:  MOVLP  00
0EE9:  MOVLB  00
0EEA:  CALL   760
0EEB:  MOVLP  08
0EEC:  MOVLB  10
0EED:  DECFSZ 3D,F
0EEE:  GOTO   6E6
....................       fprintf(PC,".");
0EEF:  MOVLW  2E
0EF0:  MOVLB  11
0EF1:  MOVWF  2B
0EF2:  MOVLP  00
0EF3:  MOVLB  00
0EF4:  CALL   67C
0EF5:  MOVLP  08
0EF6:  GOTO   604
0EF7:  MOVLB  0F
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0EF8:  MOVLW  56
0EF9:  MOVLB  03
0EFA:  MOVWF  11
0EFB:  MOVLW  06
0EFC:  MOVWF  12
0EFD:  MOVLP  00
0EFE:  MOVLB  00
0EFF:  CALL   6A1
0F00:  MOVLP  08
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0F01:  MOVLW  2E
0F02:  MOVLB  11
0F03:  MOVWF  2B
0F04:  MOVLP  00
0F05:  MOVLB  00
0F06:  CALL   67C
0F07:  MOVLP  08
....................       delay_ms(1000);
0F08:  MOVLW  04
0F09:  MOVLB  10
0F0A:  MOVWF  3D
0F0B:  MOVLW  FA
0F0C:  MOVWF  56
0F0D:  MOVLP  00
0F0E:  MOVLB  00
0F0F:  CALL   760
0F10:  MOVLP  08
0F11:  MOVLB  10
0F12:  DECFSZ 3D,F
0F13:  GOTO   70B
0F14:  MOVLB  00
0F15:  GOTO   701
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0F16:  MOVLW  76
0F17:  MOVLB  03
0F18:  MOVWF  11
0F19:  MOVLW  06
0F1A:  MOVWF  12
0F1B:  MOVLP  00
0F1C:  MOVLB  00
0F1D:  CALL   6A1
0F1E:  MOVLP  08
....................    
.................... }
.................... 
0F1F:  SLEEP
.................... //

Configuration Fuses:
   Word  1: 3F82   HS NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT NOVCAP PLL_SW STVREN BORV19 NOLPBOR NODEBUG NOLVP
