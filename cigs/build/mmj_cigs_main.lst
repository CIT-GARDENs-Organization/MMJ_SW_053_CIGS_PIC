CCS PCH C Compiler, Version 5.104, 57077               29-8-25 16:07

               Filename:   build\mmj_cigs_main.lst

               ROM used:   51342 bytes (39%)
                           Largest free fragment is 65520
               RAM used:   436 (12%) at main() level
                           2811 (79%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   C2A0
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  F9D.0
0005E:  GOTO   0068
00062:  BTFSC  F9E.0
00064:  GOTO   0174
00068:  BTFSS  F61.5
0006A:  GOTO   0074
0006E:  BTFSC  FA6.5
00070:  GOTO   01DE
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "mmj_cigs_main.h"  // ルート直下のヘッダー
.................... #ifndef MMJ_CIGS_MAIN_H
.................... #define MMJ_CIGS_MAIN_H
.................... 
.................... #opt 0 // 0 = no optimization
.................... 
.................... //==============================================================================
.................... // CCS C 最適化構造: ヘッダー分散 + .cファイル統合
.................... //==============================================================================
.................... 
.................... // レベル1: システム設定
.................... #include "hal/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
000CA:  MOVLB  A
000CC:  CLRF   xF5
000CE:  CLRF   xF6
000D0:  MOVLW  01
000D2:  MOVWF  xF7
000D4:  CLRF   FDA
000D6:  CLRF   FD9
000D8:  MOVLW  0A
000DA:  MOVWF  xFA
000DC:  MOVLW  ED
000DE:  MOVWF  xF9
000E0:  MOVLB  0
000E2:  MOVLW  0A
000E4:  MOVWF  FEA
000E6:  MOVLW  F1
000E8:  MOVWF  FE9
000EA:  MOVFF  AFA,FE2
000EE:  MOVFF  AF9,FE1
000F2:  MOVFF  AF7,AF8
000F6:  BCF    FD8.0
000F8:  MOVF   FE5,W
000FA:  MULWF  FEE
000FC:  MOVF   FF3,W
000FE:  MOVLB  A
00100:  ADDWFC xF5,F
00102:  MOVF   FF4,W
00104:  ADDWFC xF6,F
00106:  DECFSZ xF8,F
00108:  BRA    010E
0010A:  BRA    0114
0010C:  MOVLB  0
0010E:  MOVLB  0
00110:  GOTO   00F6
00114:  MOVFF  AF5,FDE
00118:  MOVFF  AF6,AF5
0011C:  CLRF   xF6
0011E:  BTFSC  FD8.0
00120:  INCF   xF6,F
00122:  INCF   xF9,F
00124:  BTFSC  FD8.2
00126:  INCF   xFA,F
00128:  INCF   xF7,F
0012A:  MOVF   xF7,W
0012C:  SUBLW  05
0012E:  BTFSC  FD8.2
00130:  BRA    0138
00132:  MOVLB  0
00134:  GOTO   00E2
00138:  MOVLB  0
0013A:  GOTO   0160 (RETURN)
*
00196:  DATA 54,69
00198:  DATA 6D,65
0019A:  DATA 72,20
0019C:  DATA 49,6E
0019E:  DATA 69,74
001A0:  DATA 69,61
001A2:  DATA 6C,69
001A4:  DATA 7A,65
001A6:  DATA 0D,0A
001A8:  DATA 00,00
001AA:  DATA 09,43
001AC:  DATA 6F,6D
001AE:  DATA 70,6C
001B0:  DATA 65,74
001B2:  DATA 65,0D
001B4:  DATA 0A,00
*
00226:  DATA 55,41
00228:  DATA 52,54
0022A:  DATA 20,49
0022C:  DATA 6E,69
0022E:  DATA 74,69
00230:  DATA 61,6C
00232:  DATA 69,7A
00234:  DATA 65,0D
00236:  DATA 0A,00
00238:  DATA 09,43
0023A:  DATA 6F,6D
0023C:  DATA 70,6C
0023E:  DATA 65,74
00240:  DATA 65,0D
00242:  DATA 0A,00
00244:  DATA 41,44
00246:  DATA 37,34
00248:  DATA 39,30
0024A:  DATA 20,49
0024C:  DATA 6E,69
0024E:  DATA 74,69
00250:  DATA 61,6C
00252:  DATA 69,7A
00254:  DATA 65,0D
00256:  DATA 0A,00
00258:  DATA 09,43
0025A:  DATA 6F,6E
0025C:  DATA 6E,65
0025E:  DATA 63,74
00260:  DATA 20,65
00262:  DATA 72,72
00264:  DATA 6F,72
00266:  DATA 21,0D
00268:  DATA 0A,00
0026A:  DATA 09,43
0026C:  DATA 6F,6E
0026E:  DATA 6E,65
00270:  DATA 63,74
00272:  DATA 20,73
00274:  DATA 75,63
00276:  DATA 63,65
00278:  DATA 73,73
0027A:  DATA 66,75
0027C:  DATA 6C,0D
0027E:  DATA 0A,00
00280:  DATA 09,43
00282:  DATA 6F,6D
00284:  DATA 70,6C
00286:  DATA 65,74
00288:  DATA 65,0D
0028A:  DATA 0A,00
0028C:  DATA 4D,43
0028E:  DATA 50,34
00290:  DATA 39,30
00292:  DATA 31,20
00294:  DATA 49,6E
00296:  DATA 69,74
00298:  DATA 69,61
0029A:  DATA 6C,69
0029C:  DATA 7A,65
0029E:  DATA 0D,0A
002A0:  DATA 00,00
002A2:  DATA 09,5B
002A4:  DATA 44,41
002A6:  DATA 43,20
002A8:  DATA 50,6F
002AA:  DATA 72,74
002AC:  DATA 20,31
002AE:  DATA 5D,20
002B0:  DATA 43,6F
002B2:  DATA 6E,6E
002B4:  DATA 65,63
002B6:  DATA 74,20
002B8:  DATA 65,72
002BA:  DATA 72,6F
002BC:  DATA 72,21
002BE:  DATA 0D,0A
002C0:  DATA 00,00
002C2:  DATA 09,5B
002C4:  DATA 44,41
002C6:  DATA 43,20
002C8:  DATA 50,6F
002CA:  DATA 72,74
002CC:  DATA 20,31
002CE:  DATA 5D,20
002D0:  DATA 43,6F
002D2:  DATA 6E,6E
002D4:  DATA 65,63
002D6:  DATA 74,20
002D8:  DATA 73,75
002DA:  DATA 63,63
002DC:  DATA 65,73
002DE:  DATA 73,66
002E0:  DATA 75,6C
002E2:  DATA 0D,0A
002E4:  DATA 00,00
002E6:  DATA 09,5B
002E8:  DATA 44,41
002EA:  DATA 43,20
002EC:  DATA 50,6F
002EE:  DATA 72,74
002F0:  DATA 20,32
002F2:  DATA 5D,20
002F4:  DATA 43,6F
002F6:  DATA 6E,6E
002F8:  DATA 65,63
002FA:  DATA 74,20
002FC:  DATA 65,72
002FE:  DATA 72,6F
00300:  DATA 72,21
00302:  DATA 0D,0A
00304:  DATA 00,00
00306:  DATA 09,5B
00308:  DATA 44,41
0030A:  DATA 43,20
0030C:  DATA 50,6F
0030E:  DATA 72,74
00310:  DATA 20,32
00312:  DATA 5D,20
00314:  DATA 43,6F
00316:  DATA 6E,6E
00318:  DATA 65,63
0031A:  DATA 74,20
0031C:  DATA 73,75
0031E:  DATA 63,63
00320:  DATA 65,73
00322:  DATA 73,66
00324:  DATA 75,6C
00326:  DATA 0D,0A
00328:  DATA 00,00
0032A:  DATA 09,43
0032C:  DATA 6F,6D
0032E:  DATA 70,6C
00330:  DATA 65,74
00332:  DATA 65,0D
00334:  DATA 0A,00
00336:  DATA 45,6E
00338:  DATA 71,75
0033A:  DATA 65,75
0033C:  DATA 65,20
0033E:  DATA 46,6C
00340:  DATA 61,73
00342:  DATA 68,20
00344:  DATA 4F,70
00346:  DATA 65,72
00348:  DATA 61,74
0034A:  DATA 69,6F
0034C:  DATA 6E,0D
0034E:  DATA 0A,00
00350:  DATA 46,6C
00352:  DATA 61,73
00354:  DATA 68,20
00356:  DATA 71,75
00358:  DATA 65,75
0035A:  DATA 65,20
0035C:  DATA 69,73
0035E:  DATA 20,66
00360:  DATA 75,6C
00362:  DATA 6C,21
00364:  DATA 21,21
00366:  DATA 0D,0A
00368:  DATA 00,00
0036A:  DATA 46,6C
0036C:  DATA 61,73
0036E:  DATA 68,20
00370:  DATA 71,75
00372:  DATA 65,75
00374:  DATA 65,20
00376:  DATA 69,73
00378:  DATA 20,65
0037A:  DATA 6D,70
0037C:  DATA 74,79
0037E:  DATA 0D,0A
00380:  DATA 00,00
00382:  DATA 0D,0A
00384:  DATA 53,74
00386:  DATA 61,72
00388:  DATA 74,20
0038A:  DATA 6D,61
0038C:  DATA 6B,65
0038E:  DATA 5F,72
00390:  DATA 65,63
00392:  DATA 65,69
00394:  DATA 76,65
00396:  DATA 5F,63
00398:  DATA 6F,6D
0039A:  DATA 6D,61
0039C:  DATA 6E,64
0039E:  DATA 0D,0A
003A0:  DATA 00,00
003A2:  DATA 09,5B
003A4:  DATA 42,4F
003A6:  DATA 53,53
003A8:  DATA 5D,20
003AA:  DATA 3E,3E
003AC:  DATA 3E,20
003AE:  DATA 00,00
003B0:  DATA 45,6E
003B2:  DATA 64,20
003B4:  DATA 6D,61
003B6:  DATA 6B,65
003B8:  DATA 5F,72
003BA:  DATA 65,63
003BC:  DATA 69,76
003BE:  DATA 65,5F
003C0:  DATA 63,6F
003C2:  DATA 6D,6D
003C4:  DATA 61,6E
003C6:  DATA 64,0D
003C8:  DATA 0A,0D
003CA:  DATA 0A,00
003CC:  DATA 73,69
003CE:  DATA 67,6E
003D0:  DATA 61,6C
003D2:  DATA 20,65
003D4:  DATA 6E,64
003D6:  DATA 20,77
003D8:  DATA 69,74
003DA:  DATA 68,20
003DC:  DATA 53,46
003DE:  DATA 44,0D
003E0:  DATA 0A,00
003E2:  DATA 64,6F
003E4:  DATA 6E,27
003E6:  DATA 74,20
003E8:  DATA 66,69
003EA:  DATA 6E,64
003EC:  DATA 20,53
003EE:  DATA 46,44
003F0:  DATA 0D,0A
003F2:  DATA 00,00
003F4:  DATA 09,2D
003F6:  DATA 3E,20
003F8:  DATA 49,6E
003FA:  DATA 76,61
003FC:  DATA 6C,69
003FE:  DATA 64,20
00400:  DATA 46,72
00402:  DATA 61,6D
00404:  DATA 65,20
00406:  DATA 49,44
00408:  DATA 20,72
0040A:  DATA 65,63
0040C:  DATA 65,69
0040E:  DATA 76,65
00410:  DATA 64,3A
00412:  DATA 20,25
00414:  DATA 58,0D
00416:  DATA 0A,00
00418:  DATA 09,2D
0041A:  DATA 3E,20
0041C:  DATA 43,52
0041E:  DATA 43,20
00420:  DATA 65,72
00422:  DATA 72,6F
00424:  DATA 72,21
00426:  DATA 0D,0A
00428:  DATA 00,00
0042A:  DATA 09,09
0042C:  DATA 2D,3E
0042E:  DATA 20,72
00430:  DATA 65,63
00432:  DATA 65,69
00434:  DATA 76,65
00436:  DATA 64,20
00438:  DATA 43,52
0043A:  DATA 43,3A
0043C:  DATA 20,25
0043E:  DATA 58,0D
00440:  DATA 0A,00
00442:  DATA 09,09
00444:  DATA 20,20
00446:  DATA 20,63
00448:  DATA 6F,6C
0044A:  DATA 6C,65
0044C:  DATA 63,74
0044E:  DATA 20,43
00450:  DATA 52,43
00452:  DATA 20,3A
00454:  DATA 20,25
00456:  DATA 58,0D
00458:  DATA 0A,00
0045A:  DATA 09,2D
0045C:  DATA 3E,20
0045E:  DATA 49,6E
00460:  DATA 76,61
00462:  DATA 6C,69
00464:  DATA 64,20
00466:  DATA 64,65
00468:  DATA 76,69
0046A:  DATA 63,65
0046C:  DATA 20,49
0046E:  DATA 44,20
00470:  DATA 72,65
00472:  DATA 63,65
00474:  DATA 69,76
00476:  DATA 65,64
00478:  DATA 0D,0A
0047A:  DATA 00,00
0047C:  DATA 09,09
0047E:  DATA 2D,3E
00480:  DATA 20,72
00482:  DATA 65,63
00484:  DATA 65,69
00486:  DATA 76,65
00488:  DATA 64,3A
0048A:  DATA 20,20
0048C:  DATA 20,20
0048E:  DATA 20,25
00490:  DATA 58,0D
00492:  DATA 0A,00
00494:  DATA 09,09
00496:  DATA 20,20
00498:  DATA 20,4D
0049A:  DATA 79,20
0049C:  DATA 64,65
0049E:  DATA 76,69
004A0:  DATA 63,65
004A2:  DATA 20,49
004A4:  DATA 44,3A
004A6:  DATA 20,25
004A8:  DATA 58,0D
004AA:  DATA 0A,00
004AC:  DATA 09,5B
004AE:  DATA 42,4F
004B0:  DATA 53,53
004B2:  DATA 5D,20
004B4:  DATA 3C,3C
004B6:  DATA 3C,20
004B8:  DATA 00,00
004BA:  DATA 53,74
004BC:  DATA 61,72
004BE:  DATA 74,20
004C0:  DATA 53,4D
004C2:  DATA 46,20
004C4:  DATA 75,73
004C6:  DATA 69,6E
004C8:  DATA 67,20
004CA:  DATA 72,65
004CC:  DATA 71,65
004CE:  DATA 73,74
004D0:  DATA 20,73
004D2:  DATA 65,61
004D4:  DATA 71,75
004D6:  DATA 65,6E
004D8:  DATA 63,65
004DA:  DATA 0D,0A
004DC:  DATA 00,00
004DE:  DATA 45,72
004E0:  DATA 72,6F
004E2:  DATA 72,21
004E4:  DATA 20,52
004E6:  DATA 65,63
004E8:  DATA 65,69
004EA:  DATA 76,69
004EC:  DATA 6E,67
004EE:  DATA 20,63
004F0:  DATA 6F,6D
004F2:  DATA 6D,61
004F4:  DATA 6E,64
004F6:  DATA 20,69
004F8:  DATA 6E,63
004FA:  DATA 6F,6E
004FC:  DATA 73,69
004FE:  DATA 73,74
00500:  DATA 65,6E
00502:  DATA 74,20
00504:  DATA 77,69
00506:  DATA 74,68
00508:  DATA 20,74
0050A:  DATA 68,65
0050C:  DATA 20,64
0050E:  DATA 65,73
00510:  DATA 69,67
00512:  DATA 6E,0D
00514:  DATA 0A,00
00516:  DATA 53,4D
00518:  DATA 46,20
0051A:  DATA 75,73
0051C:  DATA 65,20
0051E:  DATA 72,65
00520:  DATA 71,75
00522:  DATA 65,73
00524:  DATA 74,20
00526:  DATA 61,6C
00528:  DATA 6C,6F
0052A:  DATA 77,65
0052C:  DATA 64,0D
0052E:  DATA 0A,00
00530:  DATA 53,4D
00532:  DATA 46,20
00534:  DATA 75,73
00536:  DATA 65,20
00538:  DATA 72,65
0053A:  DATA 71,75
0053C:  DATA 65,73
0053E:  DATA 74,20
00540:  DATA 64,65
00542:  DATA 6E,79
00544:  DATA 65,64
00546:  DATA 0D,0A
00548:  DATA 00,00
0054A:  DATA 52,65
0054C:  DATA 74,72
0054E:  DATA 79,20
00550:  DATA 72,65
00552:  DATA 71,75
00554:  DATA 65,73
00556:  DATA 74,20
00558:  DATA 74,6F
0055A:  DATA 20,42
0055C:  DATA 4F,53
0055E:  DATA 53,20
00560:  DATA 50,49
00562:  DATA 43,0D
00564:  DATA 0A,00
00566:  DATA 45,72
00568:  DATA 72,6F
0056A:  DATA 72,21
0056C:  DATA 20,52
0056E:  DATA 65,63
00570:  DATA 65,69
00572:  DATA 76,69
00574:  DATA 6E,67
00576:  DATA 20,63
00578:  DATA 6F,6D
0057A:  DATA 6D,61
0057C:  DATA 6E,64
0057E:  DATA 20,69
00580:  DATA 6E,63
00582:  DATA 6F,6E
00584:  DATA 73,69
00586:  DATA 73,74
00588:  DATA 65,6E
0058A:  DATA 74,20
0058C:  DATA 77,69
0058E:  DATA 74,68
00590:  DATA 20,74
00592:  DATA 68,65
00594:  DATA 20,64
00596:  DATA 65,73
00598:  DATA 69,67
0059A:  DATA 6E,0D
0059C:  DATA 0A,00
0059E:  DATA 45,6E
005A0:  DATA 64,20
005A2:  DATA 53,4D
005A4:  DATA 46,20
005A6:  DATA 75,73
005A8:  DATA 69,6E
005AA:  DATA 67,20
005AC:  DATA 72,65
005AE:  DATA 71,65
005B0:  DATA 73,74
005B2:  DATA 20,73
005B4:  DATA 65,61
005B6:  DATA 71,75
005B8:  DATA 65,6E
005BA:  DATA 63,65
005BC:  DATA 0D,0A
005BE:  DATA 00,00
005C0:  DATA 5B,50
005C2:  DATA 49,43
005C4:  DATA 4C,4F
005C6:  DATA 47,5D
005C8:  DATA 20,3A
005CA:  DATA 20,00
005CC:  DATA 43,52
005CE:  DATA 43,20
005D0:  DATA 76,65
005D2:  DATA 72,69
005D4:  DATA 66,69
005D6:  DATA 63,61
005D8:  DATA 74,69
005DA:  DATA 6F,6E
005DC:  DATA 20,70
005DE:  DATA 61,73
005E0:  DATA 73,65
005E2:  DATA 64,20
005E4:  DATA 6F,6E
005E6:  DATA 20,61
005E8:  DATA 74,74
005EA:  DATA 65,6D
005EC:  DATA 70,74
005EE:  DATA 20,25
005F0:  DATA 75,0D
005F2:  DATA 0A,00
005F4:  DATA 43,52
005F6:  DATA 43,20
005F8:  DATA 76,65
005FA:  DATA 72,69
005FC:  DATA 66,69
005FE:  DATA 63,61
00600:  DATA 74,69
00602:  DATA 6F,6E
00604:  DATA 20,70
00606:  DATA 61,73
00608:  DATA 73,65
0060A:  DATA 64,20
0060C:  DATA 6F,6E
0060E:  DATA 20,61
00610:  DATA 74,74
00612:  DATA 65,6D
00614:  DATA 70,74
00616:  DATA 20,25
00618:  DATA 64,0D
0061A:  DATA 0A,00
0061C:  DATA 45,72
0061E:  DATA 72,6F
00620:  DATA 72,3A
00622:  DATA 20,43
00624:  DATA 52,43
00626:  DATA 20,76
00628:  DATA 65,72
0062A:  DATA 69,66
0062C:  DATA 69,63
0062E:  DATA 61,74
00630:  DATA 69,6F
00632:  DATA 6E,20
00634:  DATA 66,61
00636:  DATA 69,6C
00638:  DATA 65,64
0063A:  DATA 20,61
0063C:  DATA 66,74
0063E:  DATA 65,72
00640:  DATA 20,25
00642:  DATA 64,20
00644:  DATA 61,74
00646:  DATA 74,65
00648:  DATA 6D,70
0064A:  DATA 74,73
0064C:  DATA 0D,0A
0064E:  DATA 00,00
00650:  DATA 0D,0A
00652:  DATA 5F,5F
00654:  DATA 5F,5F
00656:  DATA 5F,5F
00658:  DATA 5F,5F
0065A:  DATA 5F,5F
0065C:  DATA 5F,5F
0065E:  DATA 5F,5F
00660:  DATA 5F,5F
00662:  DATA 5F,5F
00664:  DATA 5F,5F
00666:  DATA 0D,0A
00668:  DATA 00,00
0066A:  DATA 5F,5F
0066C:  DATA 5F,5F
0066E:  DATA 5F,53
00670:  DATA 74,61
00672:  DATA 72,74
00674:  DATA 20,63
00676:  DATA 6F,70
00678:  DATA 79,5F
0067A:  DATA 64,61
0067C:  DATA 74,61
0067E:  DATA 5F,5F
00680:  DATA 5F,5F
00682:  DATA 0D,0A
00684:  DATA 00,00
00686:  DATA 45,72
00688:  DATA 72,6F
0068A:  DATA 72,3A
0068C:  DATA 20,4D
0068E:  DATA 49,53
00690:  DATA 20,46
00692:  DATA 4D,20
00694:  DATA 69,73
00696:  DATA 20,6E
00698:  DATA 6F,74
0069A:  DATA 20,63
0069C:  DATA 6F,6E
0069E:  DATA 6E,65
006A0:  DATA 63,74
006A2:  DATA 65,64
006A4:  DATA 0D,0A
006A6:  DATA 00,00
006A8:  DATA 45,72
006AA:  DATA 72,6F
006AC:  DATA 72,3A
006AE:  DATA 20,53
006B0:  DATA 4D,46
006B2:  DATA 20,69
006B4:  DATA 73,20
006B6:  DATA 6E,6F
006B8:  DATA 74,20
006BA:  DATA 63,6F
006BC:  DATA 6E,6E
006BE:  DATA 65,63
006C0:  DATA 74,65
006C2:  DATA 64,0D
006C4:  DATA 0A,00
006C6:  DATA 53,69
006C8:  DATA 7A,65
006CA:  DATA 20,61
006CC:  DATA 72,65
006CE:  DATA 61,20
006D0:  DATA 72,65
006D2:  DATA 61,64
006D4:  DATA 0D,0A
006D6:  DATA 00,00
006D8:  DATA 73,6D
006DA:  DATA 66,5F
006DC:  DATA 75,73
006DE:  DATA 65,64
006E0:  DATA 5F,73
006E2:  DATA 69,7A
006E4:  DATA 65,20
006E6:  DATA 3D,20
006E8:  DATA 25,6C
006EA:  DATA 64,20
006EC:  DATA 28,73
006EE:  DATA 72,63
006F0:  DATA 20,30
006F2:  DATA 78,25
006F4:  DATA 30,38
006F6:  DATA 4C,58
006F8:  DATA 29,0D
006FA:  DATA 0A,00
006FC:  DATA 73,6D
006FE:  DATA 66,5F
00700:  DATA 6C,6F
00702:  DATA 6F,70
00704:  DATA 20,63
00706:  DATA 6F,75
00708:  DATA 6E,74
0070A:  DATA 3D,20
0070C:  DATA 25,64
0070E:  DATA 20,20
00710:  DATA 28,73
00712:  DATA 72,63
00714:  DATA 20,30
00716:  DATA 78,25
00718:  DATA 30,38
0071A:  DATA 4C,58
0071C:  DATA 29,0D
0071E:  DATA 0A,00
00720:  DATA 6D,69
00722:  DATA 73,66
00724:  DATA 5F,77
00726:  DATA 72,69
00728:  DATA 74,65
0072A:  DATA 5F,73
0072C:  DATA 6F,75
0072E:  DATA 72,63
00730:  DATA 65,20
00732:  DATA 3D,20
00734:  DATA 30,78
00736:  DATA 25,30
00738:  DATA 38,4C
0073A:  DATA 58,0D
0073C:  DATA 0A,00
0073E:  DATA 6D,69
00740:  DATA 73,66
00742:  DATA 5F,77
00744:  DATA 72,69
00746:  DATA 74,65
00748:  DATA 5F,73
0074A:  DATA 69,7A
0074C:  DATA 65,20
0074E:  DATA 3D,20
00750:  DATA 30,78
00752:  DATA 25,30
00754:  DATA 38,4C
00756:  DATA 58,0D
00758:  DATA 0A,00
0075A:  DATA 57,72
0075C:  DATA 61,70
0075E:  DATA 20,74
00760:  DATA 72,69
00762:  DATA 67,67
00764:  DATA 65,72
00766:  DATA 65,64
00768:  DATA 3A,20
0076A:  DATA 52,65
0076C:  DATA 73,65
0076E:  DATA 74,74
00770:  DATA 69,6E
00772:  DATA 67,20
00774:  DATA 64,61
00776:  DATA 74,61
00778:  DATA 5F,77
0077A:  DATA 72,69
0077C:  DATA 74,65
0077E:  DATA 5F,61
00780:  DATA 64,64
00782:  DATA 72,20
00784:  DATA 74,6F
00786:  DATA 20,73
00788:  DATA 74,61
0078A:  DATA 72,74
0078C:  DATA 0D,0A
0078E:  DATA 00,00
00790:  DATA 75,73
00792:  DATA 65,64
00794:  DATA 5F,73
00796:  DATA 69,7A
00798:  DATA 65,20
0079A:  DATA 3D,20
0079C:  DATA 25,6C
0079E:  DATA 64,0D
007A0:  DATA 0A,00
007A2:  DATA 6C,6F
007A4:  DATA 6F,70
007A6:  DATA 5F,63
007A8:  DATA 6F,75
007AA:  DATA 6E,74
007AC:  DATA 20,3D
007AE:  DATA 20,25
007B0:  DATA 75,0D
007B2:  DATA 0A,0D
007B4:  DATA 0A,00
007B6:  DATA 0D,0A
007B8:  DATA 5F,5F
007BA:  DATA 5F,45
007BC:  DATA 6E,64
007BE:  DATA 20,63
007C0:  DATA 6F,70
007C2:  DATA 79,5F
007C4:  DATA 64,61
007C6:  DATA 74,61
007C8:  DATA 5F,5F
007CA:  DATA 5F,5F
007CC:  DATA 0D,0A
007CE:  DATA 00,00
007D0:  DATA 5F,5F
007D2:  DATA 5F,5F
007D4:  DATA 5F,5F
007D6:  DATA 5F,5F
007D8:  DATA 5F,5F
007DA:  DATA 5F,5F
007DC:  DATA 5F,5F
007DE:  DATA 5F,5F
007E0:  DATA 5F,5F
007E2:  DATA 5F,5F
007E4:  DATA 0D,0A
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 0D,0A
007EC:  DATA 5F,5F
007EE:  DATA 5F,5F
007F0:  DATA 5F,5F
007F2:  DATA 5F,5F
007F4:  DATA 5F,5F
007F6:  DATA 5F,5F
007F8:  DATA 5F,5F
007FA:  DATA 5F,5F
007FC:  DATA 5F,5F
007FE:  DATA 5F,5F
00800:  DATA 0D,0A
00802:  DATA 00,00
00804:  DATA 5F,5F
00806:  DATA 5F,53
00808:  DATA 74,61
0080A:  DATA 72,74
0080C:  DATA 20,53
0080E:  DATA 4D,46
00810:  DATA 20,52
00812:  DATA 65,61
00814:  DATA 64,5F
00816:  DATA 5F,5F
00818:  DATA 5F,0D
0081A:  DATA 0A,00
0081C:  DATA 49,6E
0081E:  DATA 20,53
00820:  DATA 4D,46
00822:  DATA 20,52
00824:  DATA 65,61
00826:  DATA 64,20
00828:  DATA 73,6F
0082A:  DATA 75,72
0082C:  DATA 63,65
0082E:  DATA 20,64
00830:  DATA 61,74
00832:  DATA 61,20
00834:  DATA 61,64
00836:  DATA 64,72
00838:  DATA 65,73
0083A:  DATA 73,3A
0083C:  DATA 20,25
0083E:  DATA 4C,58
00840:  DATA 0D,0A
00842:  DATA 00,00
00844:  DATA 49,6E
00846:  DATA 20,53
00848:  DATA 4D,46
0084A:  DATA 20,52
0084C:  DATA 65,61
0084E:  DATA 64,20
00850:  DATA 64,61
00852:  DATA 74,61
00854:  DATA 20,73
00856:  DATA 69,7A
00858:  DATA 65,20
0085A:  DATA 20,20
0085C:  DATA 20,20
0085E:  DATA 20,20
00860:  DATA 20,20
00862:  DATA 20,3A
00864:  DATA 20,25
00866:  DATA 6C,75
00868:  DATA 20,28
0086A:  DATA 30,78
0086C:  DATA 25,6C
0086E:  DATA 78,29
00870:  DATA 0D,0A
00872:  DATA 0D,0A
00874:  DATA 00,00
00876:  DATA 45,72
00878:  DATA 72,6F
0087A:  DATA 72,3A
0087C:  DATA 20,53
0087E:  DATA 4D,46
00880:  DATA 20,69
00882:  DATA 73,20
00884:  DATA 6E,6F
00886:  DATA 74,20
00888:  DATA 63,6F
0088A:  DATA 6E,6E
0088C:  DATA 65,63
0088E:  DATA 74,65
00890:  DATA 64,0D
00892:  DATA 0A,00
00894:  DATA 52,45
00896:  DATA 41,44
00898:  DATA 20,44
0089A:  DATA 41,54
0089C:  DATA 41,20
0089E:  DATA 46,52
008A0:  DATA 4F,4D
008A2:  DATA 20,53
008A4:  DATA 4D,46
008A6:  DATA 2E,2E
008A8:  DATA 2E,0D
008AA:  DATA 0A,00
008AC:  DATA 0D,0A
008AE:  DATA 5F,5F
008B0:  DATA 5F,45
008B2:  DATA 6E,64
008B4:  DATA 20,53
008B6:  DATA 4D,46
008B8:  DATA 20,52
008BA:  DATA 65,61
008BC:  DATA 64,5F
008BE:  DATA 5F,5F
008C0:  DATA 5F,0D
008C2:  DATA 0A,00
008C4:  DATA 5F,5F
008C6:  DATA 5F,5F
008C8:  DATA 5F,5F
008CA:  DATA 5F,5F
008CC:  DATA 5F,5F
008CE:  DATA 5F,5F
008D0:  DATA 5F,5F
008D2:  DATA 5F,5F
008D4:  DATA 5F,5F
008D6:  DATA 5F,5F
008D8:  DATA 0D,0A
008DA:  DATA 0D,0A
008DC:  DATA 00,00
008DE:  DATA 0D,0A
008E0:  DATA 5F,5F
008E2:  DATA 5F,5F
008E4:  DATA 5F,5F
008E6:  DATA 5F,5F
008E8:  DATA 5F,5F
008EA:  DATA 5F,5F
008EC:  DATA 5F,5F
008EE:  DATA 5F,5F
008F0:  DATA 5F,5F
008F2:  DATA 5F,5F
008F4:  DATA 0D,0A
008F6:  DATA 00,00
008F8:  DATA 5F,5F
008FA:  DATA 5F,53
008FC:  DATA 74,61
008FE:  DATA 72,74
00900:  DATA 20,73
00902:  DATA 6D,66
00904:  DATA 5F,65
00906:  DATA 72,61
00908:  DATA 73,65
0090A:  DATA 5F,5F
0090C:  DATA 5F,5F
0090E:  DATA 0D,0A
00910:  DATA 00,00
00912:  DATA 49,6E
00914:  DATA 20,53
00916:  DATA 4D,46
00918:  DATA 20,45
0091A:  DATA 72,61
0091C:  DATA 73,65
0091E:  DATA 20,73
00920:  DATA 6F,75
00922:  DATA 72,63
00924:  DATA 65,20
00926:  DATA 64,61
00928:  DATA 74,61
0092A:  DATA 20,61
0092C:  DATA 64,64
0092E:  DATA 72,65
00930:  DATA 73,73
00932:  DATA 3A,20
00934:  DATA 25,4C
00936:  DATA 58,0D
00938:  DATA 0A,00
0093A:  DATA 49,6E
0093C:  DATA 20,53
0093E:  DATA 4D,46
00940:  DATA 20,45
00942:  DATA 72,61
00944:  DATA 73,65
00946:  DATA 20,64
00948:  DATA 61,74
0094A:  DATA 61,20
0094C:  DATA 73,69
0094E:  DATA 7A,65
00950:  DATA 20,20
00952:  DATA 20,20
00954:  DATA 20,20
00956:  DATA 20,20
00958:  DATA 20,20
0095A:  DATA 3A,20
0095C:  DATA 25,6C
0095E:  DATA 75,20
00960:  DATA 28,30
00962:  DATA 78,25
00964:  DATA 6C,78
00966:  DATA 29,0D
00968:  DATA 0A,0D
0096A:  DATA 0A,00
0096C:  DATA 45,72
0096E:  DATA 72,6F
00970:  DATA 72,3A
00972:  DATA 20,53
00974:  DATA 4D,46
00976:  DATA 20,69
00978:  DATA 73,20
0097A:  DATA 6E,6F
0097C:  DATA 74,20
0097E:  DATA 63,6F
00980:  DATA 6E,6E
00982:  DATA 65,63
00984:  DATA 74,65
00986:  DATA 64,0D
00988:  DATA 0A,00
0098A:  DATA 45,72
0098C:  DATA 72,6F
0098E:  DATA 72,3A
00990:  DATA 20,45
00992:  DATA 72,61
00994:  DATA 73,65
00996:  DATA 20,73
00998:  DATA 6F,75
0099A:  DATA 72,63
0099C:  DATA 65,20
0099E:  DATA 61,64
009A0:  DATA 64,72
009A2:  DATA 65,73
009A4:  DATA 73,20
009A6:  DATA 30,78
009A8:  DATA 25,4C
009AA:  DATA 58,20
009AC:  DATA 69,73
009AE:  DATA 20,6F
009B0:  DATA 75,74
009B2:  DATA 73,69
009B4:  DATA 64,65
009B6:  DATA 20,6D
009B8:  DATA 69,73
009BA:  DATA 73,69
009BC:  DATA 6F,6E
009BE:  DATA 20,72
009C0:  DATA 61,6E
009C2:  DATA 67,65
009C4:  DATA 20,5B
009C6:  DATA 30,78
009C8:  DATA 25,4C
009CA:  DATA 58,20
009CC:  DATA 2D,20
009CE:  DATA 30,78
009D0:  DATA 25,4C
009D2:  DATA 58,5D
009D4:  DATA 0D,0A
009D6:  DATA 00,00
009D8:  DATA 45,72
009DA:  DATA 72,6F
009DC:  DATA 72,3A
009DE:  DATA 20,45
009E0:  DATA 72,61
009E2:  DATA 73,65
009E4:  DATA 20,6F
009E6:  DATA 70,65
009E8:  DATA 72,61
009EA:  DATA 74,69
009EC:  DATA 6F,6E
009EE:  DATA 20,77
009F0:  DATA 6F,75
009F2:  DATA 6C,64
009F4:  DATA 20,65
009F6:  DATA 78,63
009F8:  DATA 65,65
009FA:  DATA 64,20
009FC:  DATA 6D,69
009FE:  DATA 73,73
00A00:  DATA 69,6F
00A02:  DATA 6E,20
00A04:  DATA 65,6E
00A06:  DATA 64,20
00A08:  DATA 61,64
00A0A:  DATA 64,72
00A0C:  DATA 65,73
00A0E:  DATA 73,20
00A10:  DATA 30,78
00A12:  DATA 25,4C
00A14:  DATA 58,0D
00A16:  DATA 0A,00
00A18:  DATA 4C,69
00A1A:  DATA 6D,69
00A1C:  DATA 74,69
00A1E:  DATA 6E,67
00A20:  DATA 20,65
00A22:  DATA 72,61
00A24:  DATA 73,65
00A26:  DATA 20,73
00A28:  DATA 69,7A
00A2A:  DATA 65,20
00A2C:  DATA 74,6F
00A2E:  DATA 20,73
00A30:  DATA 74,61
00A32:  DATA 79,20
00A34:  DATA 77,69
00A36:  DATA 74,68
00A38:  DATA 69,6E
00A3A:  DATA 20,6D
00A3C:  DATA 69,73
00A3E:  DATA 73,69
00A40:  DATA 6F,6E
00A42:  DATA 20,62
00A44:  DATA 6F,75
00A46:  DATA 6E,64
00A48:  DATA 73,0D
00A4A:  DATA 0A,00
00A4C:  DATA 45,72
00A4E:  DATA 61,73
00A50:  DATA 65,20
00A52:  DATA 6F,70
00A54:  DATA 65,72
00A56:  DATA 61,74
00A58:  DATA 69,6F
00A5A:  DATA 6E,20
00A5C:  DATA 76,61
00A5E:  DATA 6C,69
00A60:  DATA 64,61
00A62:  DATA 74,65
00A64:  DATA 64,20
00A66:  DATA 77,69
00A68:  DATA 74,68
00A6A:  DATA 69,6E
00A6C:  DATA 20,6D
00A6E:  DATA 69,73
00A70:  DATA 73,69
00A72:  DATA 6F,6E
00A74:  DATA 20,72
00A76:  DATA 61,6E
00A78:  DATA 67,65
00A7A:  DATA 0D,0A
00A7C:  DATA 00,00
00A7E:  DATA 0D,0A
00A80:  DATA 5F,5F
00A82:  DATA 5F,45
00A84:  DATA 6E,64
00A86:  DATA 20,73
00A88:  DATA 6D,66
00A8A:  DATA 5F,65
00A8C:  DATA 72,61
00A8E:  DATA 73,65
00A90:  DATA 5F,5F
00A92:  DATA 5F,5F
00A94:  DATA 0D,0A
00A96:  DATA 00,00
00A98:  DATA 5F,5F
00A9A:  DATA 5F,5F
00A9C:  DATA 5F,5F
00A9E:  DATA 5F,5F
00AA0:  DATA 5F,5F
00AA2:  DATA 5F,5F
00AA4:  DATA 5F,5F
00AA6:  DATA 5F,5F
00AA8:  DATA 5F,5F
00AAA:  DATA 5F,5F
00AAC:  DATA 0D,0A
00AAE:  DATA 0D,0A
00AB0:  DATA 00,00
00AB2:  DATA 45,72
00AB4:  DATA 72,6F
00AB6:  DATA 72,3A
00AB8:  DATA 20,55
00ABA:  DATA 6E,6B
00ABC:  DATA 6E,6F
00ABE:  DATA 77,6E
00AC0:  DATA 20,6D
00AC2:  DATA 69,73
00AC4:  DATA 73,69
00AC6:  DATA 6F,6E
00AC8:  DATA 5F,69
00ACA:  DATA 64,3A
00ACC:  DATA 20,25
00ACE:  DATA 30,32
00AD0:  DATA 58,0D
00AD2:  DATA 0A,00
00AD4:  DATA 55,70
00AD6:  DATA 64,61
00AD8:  DATA 74,65
00ADA:  DATA 64,20
00ADC:  DATA 70,61
00ADE:  DATA 72,74
00AE0:  DATA 69,74
00AE2:  DATA 69,6F
00AE4:  DATA 6E,20
00AE6:  DATA 66,6F
00AE8:  DATA 72,20
00AEA:  DATA 6D,69
00AEC:  DATA 73,73
00AEE:  DATA 69,6F
00AF0:  DATA 6E,5F
00AF2:  DATA 69,64
00AF4:  DATA 20,25
00AF6:  DATA 30,32
00AF8:  DATA 58,3A
00AFA:  DATA 20,75
00AFC:  DATA 73,65
00AFE:  DATA 64,5F
00B00:  DATA 73,69
00B02:  DATA 7A,65
00B04:  DATA 3D,25
00B06:  DATA 6C,64
00B08:  DATA 2C,20
00B0A:  DATA 6C,6F
00B0C:  DATA 6F,70
00B0E:  DATA 5F,63
00B10:  DATA 6F,75
00B12:  DATA 6E,74
00B14:  DATA 65,72
00B16:  DATA 3D,25
00B18:  DATA 6C,64
00B1A:  DATA 0D,0A
00B1C:  DATA 00,00
00B1E:  DATA 4D,49
00B20:  DATA 53,53
00B22:  DATA 49,4F
00B24:  DATA 4E,20
00B26:  DATA 46,4C
00B28:  DATA 41,53
00B2A:  DATA 48,20
00B2C:  DATA 49,6E
00B2E:  DATA 69,74
00B30:  DATA 69,61
00B32:  DATA 6C,69
00B34:  DATA 7A,65
00B36:  DATA 0D,0A
00B38:  DATA 00,00
00B3A:  DATA 09,5B
00B3C:  DATA 4D,49
00B3E:  DATA 53,20
00B40:  DATA 46,4D
00B42:  DATA 5D,20
00B44:  DATA 43,6F
00B46:  DATA 6E,6E
00B48:  DATA 65,63
00B4A:  DATA 74,65
00B4C:  DATA 64,0D
00B4E:  DATA 0A,00
00B50:  DATA 09,5B
00B52:  DATA 4D,49
00B54:  DATA 53,20
00B56:  DATA 46,4D
00B58:  DATA 5D,20
00B5A:  DATA 4E,6F
00B5C:  DATA 74,20
00B5E:  DATA 43,6F
00B60:  DATA 6E,6E
00B62:  DATA 65,63
00B64:  DATA 74,65
00B66:  DATA 64,0D
00B68:  DATA 0A,00
00B6A:  DATA 09,5B
00B6C:  DATA 53,4D
00B6E:  DATA 46,5D
00B70:  DATA 20,43
00B72:  DATA 6F,6E
00B74:  DATA 6E,65
00B76:  DATA 63,74
00B78:  DATA 65,64
00B7A:  DATA 0D,0A
00B7C:  DATA 00,00
00B7E:  DATA 09,5B
00B80:  DATA 53,4D
00B82:  DATA 46,5D
00B84:  DATA 20,4E
00B86:  DATA 6F,74
00B88:  DATA 20,43
00B8A:  DATA 6F,6E
00B8C:  DATA 6E,65
00B8E:  DATA 63,74
00B90:  DATA 65,64
00B92:  DATA 0D,0A
00B94:  DATA 00,00
00B96:  DATA 09,5B
00B98:  DATA 4D,49
00B9A:  DATA 53,20
00B9C:  DATA 46,4D
00B9E:  DATA 5D,20
00BA0:  DATA 43,52
00BA2:  DATA 43,20
00BA4:  DATA 65,72
00BA6:  DATA 72,6F
00BA8:  DATA 72,20
00BAA:  DATA 2D,3E
00BAC:  DATA 20,69
00BAE:  DATA 6E,69
00BB0:  DATA 74,69
00BB2:  DATA 61,6C
00BB4:  DATA 69,7A
00BB6:  DATA 65,20
00BB8:  DATA 63,6F
00BBA:  DATA 75,6E
00BBC:  DATA 74,65
00BBE:  DATA 72,73
00BC0:  DATA 0D,0A
00BC2:  DATA 00,00
00BC4:  DATA 09,7C
00BC6:  DATA 20,4D
00BC8:  DATA 49,53
00BCA:  DATA 46,20
00BCC:  DATA 7C,20
00BCE:  DATA 50,49
00BD0:  DATA 43,4C
00BD2:  DATA 4F,47
00BD4:  DATA 20,20
00BD6:  DATA 20,20
00BD8:  DATA 20,7C
00BDA:  DATA 20,55
00BDC:  DATA 73,65
00BDE:  DATA 20,43
00BE0:  DATA 6F,75
00BE2:  DATA 6E,74
00BE4:  DATA 65,72
00BE6:  DATA 20,20
00BE8:  DATA 20,20
00BEA:  DATA 20,20
00BEC:  DATA 3A,20
00BEE:  DATA 30,78
00BF0:  DATA 25,30
00BF2:  DATA 38,4C
00BF4:  DATA 58,0D
00BF6:  DATA 0A,00
00BF8:  DATA 09,7C
00BFA:  DATA 20,4D
00BFC:  DATA 49,53
00BFE:  DATA 46,20
00C00:  DATA 7C,20
00C02:  DATA 50,49
00C04:  DATA 43,4C
00C06:  DATA 4F,47
00C08:  DATA 20,20
00C0A:  DATA 20,20
00C0C:  DATA 20,7C
00C0E:  DATA 20,55
00C10:  DATA 6E,63
00C12:  DATA 6F,70
00C14:  DATA 79,65
00C16:  DATA 64,20
00C18:  DATA 43,6F
00C1A:  DATA 75,6E
00C1C:  DATA 74,65
00C1E:  DATA 72,20
00C20:  DATA 3A,20
00C22:  DATA 30,78
00C24:  DATA 25,30
00C26:  DATA 38,4C
00C28:  DATA 58,0D
00C2A:  DATA 0A,00
00C2C:  DATA 09,7C
00C2E:  DATA 20,4D
00C30:  DATA 49,53
00C32:  DATA 46,20
00C34:  DATA 7C,20
00C36:  DATA 50,49
00C38:  DATA 43,4C
00C3A:  DATA 4F,47
00C3C:  DATA 20,20
00C3E:  DATA 20,20
00C40:  DATA 20,7C
00C42:  DATA 20,52
00C44:  DATA 65,73
00C46:  DATA 65,72
00C48:  DATA 76,65
00C4A:  DATA 20,43
00C4C:  DATA 6F,75
00C4E:  DATA 6E,74
00C50:  DATA 65,72
00C52:  DATA 31,20
00C54:  DATA 3A,20
00C56:  DATA 30,78
00C58:  DATA 25,30
00C5A:  DATA 32,58
00C5C:  DATA 0D,0A
00C5E:  DATA 00,00
00C60:  DATA 09,7C
00C62:  DATA 20,4D
00C64:  DATA 49,53
00C66:  DATA 46,20
00C68:  DATA 7C,20
00C6A:  DATA 50,49
00C6C:  DATA 43,4C
00C6E:  DATA 4F,47
00C70:  DATA 20,20
00C72:  DATA 20,20
00C74:  DATA 20,7C
00C76:  DATA 20,52
00C78:  DATA 65,73
00C7A:  DATA 65,72
00C7C:  DATA 76,65
00C7E:  DATA 20,43
00C80:  DATA 6F,75
00C82:  DATA 6E,74
00C84:  DATA 65,72
00C86:  DATA 32,20
00C88:  DATA 3A,20
00C8A:  DATA 30,78
00C8C:  DATA 25,30
00C8E:  DATA 32,58
00C90:  DATA 0D,0A
00C92:  DATA 00,00
00C94:  DATA 09,7C
00C96:  DATA 20,4D
00C98:  DATA 49,53
00C9A:  DATA 46,20
00C9C:  DATA 7C,20
00C9E:  DATA 45,4E
00CA0:  DATA 56,49
00CA2:  DATA 52,4F
00CA4:  DATA 20,20
00CA6:  DATA 20,20
00CA8:  DATA 20,7C
00CAA:  DATA 20,55
00CAC:  DATA 73,65
00CAE:  DATA 20,43
00CB0:  DATA 6F,75
00CB2:  DATA 6E,74
00CB4:  DATA 65,72
00CB6:  DATA 20,20
00CB8:  DATA 20,20
00CBA:  DATA 20,20
00CBC:  DATA 3A,20
00CBE:  DATA 30,78
00CC0:  DATA 25,30
00CC2:  DATA 38,4C
00CC4:  DATA 58,0D
00CC6:  DATA 0A,00
00CC8:  DATA 09,7C
00CCA:  DATA 20,4D
00CCC:  DATA 49,53
00CCE:  DATA 46,20
00CD0:  DATA 7C,20
00CD2:  DATA 45,4E
00CD4:  DATA 56,49
00CD6:  DATA 52,4F
00CD8:  DATA 20,20
00CDA:  DATA 20,20
00CDC:  DATA 20,7C
00CDE:  DATA 20,55
00CE0:  DATA 6E,63
00CE2:  DATA 6F,70
00CE4:  DATA 79,65
00CE6:  DATA 64,20
00CE8:  DATA 43,6F
00CEA:  DATA 75,6E
00CEC:  DATA 74,65
00CEE:  DATA 72,20
00CF0:  DATA 3A,20
00CF2:  DATA 30,78
00CF4:  DATA 25,30
00CF6:  DATA 38,4C
00CF8:  DATA 58,0D
00CFA:  DATA 0A,00
00CFC:  DATA 09,7C
00CFE:  DATA 20,4D
00D00:  DATA 49,53
00D02:  DATA 46,20
00D04:  DATA 7C,20
00D06:  DATA 45,4E
00D08:  DATA 56,49
00D0A:  DATA 52,4F
00D0C:  DATA 20,20
00D0E:  DATA 20,20
00D10:  DATA 20,7C
00D12:  DATA 20,52
00D14:  DATA 65,73
00D16:  DATA 65,72
00D18:  DATA 76,65
00D1A:  DATA 20,43
00D1C:  DATA 6F,75
00D1E:  DATA 6E,74
00D20:  DATA 65,72
00D22:  DATA 31,20
00D24:  DATA 3A,20
00D26:  DATA 30,78
00D28:  DATA 25,30
00D2A:  DATA 32,58
00D2C:  DATA 0D,0A
00D2E:  DATA 00,00
00D30:  DATA 09,7C
00D32:  DATA 20,4D
00D34:  DATA 49,53
00D36:  DATA 46,20
00D38:  DATA 7C,20
00D3A:  DATA 45,4E
00D3C:  DATA 56,49
00D3E:  DATA 52,4F
00D40:  DATA 20,20
00D42:  DATA 20,20
00D44:  DATA 20,7C
00D46:  DATA 20,52
00D48:  DATA 65,73
00D4A:  DATA 65,72
00D4C:  DATA 76,65
00D4E:  DATA 20,43
00D50:  DATA 6F,75
00D52:  DATA 6E,74
00D54:  DATA 65,72
00D56:  DATA 32,20
00D58:  DATA 3A,20
00D5A:  DATA 30,78
00D5C:  DATA 25,30
00D5E:  DATA 32,58
00D60:  DATA 0D,0A
00D62:  DATA 00,00
00D64:  DATA 09,7C
00D66:  DATA 20,4D
00D68:  DATA 49,53
00D6A:  DATA 46,20
00D6C:  DATA 7C,20
00D6E:  DATA 49,56
00D70:  DATA 31,20
00D72:  DATA 48,45
00D74:  DATA 41,44
00D76:  DATA 45,52
00D78:  DATA 20,7C
00D7A:  DATA 20,55
00D7C:  DATA 73,65
00D7E:  DATA 20,43
00D80:  DATA 6F,75
00D82:  DATA 6E,74
00D84:  DATA 65,72
00D86:  DATA 20,20
00D88:  DATA 20,20
00D8A:  DATA 20,20
00D8C:  DATA 3A,20
00D8E:  DATA 30,78
00D90:  DATA 25,30
00D92:  DATA 38,4C
00D94:  DATA 58,0D
00D96:  DATA 0A,00
00D98:  DATA 09,7C
00D9A:  DATA 20,4D
00D9C:  DATA 49,53
00D9E:  DATA 46,20
00DA0:  DATA 7C,20
00DA2:  DATA 49,56
00DA4:  DATA 31,20
00DA6:  DATA 48,45
00DA8:  DATA 41,44
00DAA:  DATA 45,52
00DAC:  DATA 20,7C
00DAE:  DATA 20,55
00DB0:  DATA 6E,63
00DB2:  DATA 6F,70
00DB4:  DATA 79,65
00DB6:  DATA 64,20
00DB8:  DATA 43,6F
00DBA:  DATA 75,6E
00DBC:  DATA 74,65
00DBE:  DATA 72,20
00DC0:  DATA 3A,20
00DC2:  DATA 30,78
00DC4:  DATA 25,30
00DC6:  DATA 38,4C
00DC8:  DATA 58,0D
00DCA:  DATA 0A,00
00DCC:  DATA 09,7C
00DCE:  DATA 20,4D
00DD0:  DATA 49,53
00DD2:  DATA 46,20
00DD4:  DATA 7C,20
00DD6:  DATA 49,56
00DD8:  DATA 31,20
00DDA:  DATA 48,45
00DDC:  DATA 41,44
00DDE:  DATA 45,52
00DE0:  DATA 20,7C
00DE2:  DATA 20,52
00DE4:  DATA 65,73
00DE6:  DATA 65,72
00DE8:  DATA 76,65
00DEA:  DATA 20,43
00DEC:  DATA 6F,75
00DEE:  DATA 6E,74
00DF0:  DATA 65,72
00DF2:  DATA 31,20
00DF4:  DATA 3A,20
00DF6:  DATA 30,78
00DF8:  DATA 25,30
00DFA:  DATA 32,58
00DFC:  DATA 0D,0A
00DFE:  DATA 00,00
00E00:  DATA 09,7C
00E02:  DATA 20,4D
00E04:  DATA 49,53
00E06:  DATA 46,20
00E08:  DATA 7C,20
00E0A:  DATA 49,56
00E0C:  DATA 31,20
00E0E:  DATA 48,45
00E10:  DATA 41,44
00E12:  DATA 45,52
00E14:  DATA 20,7C
00E16:  DATA 20,52
00E18:  DATA 65,73
00E1A:  DATA 65,72
00E1C:  DATA 76,65
00E1E:  DATA 20,43
00E20:  DATA 6F,75
00E22:  DATA 6E,74
00E24:  DATA 65,72
00E26:  DATA 32,20
00E28:  DATA 3A,20
00E2A:  DATA 30,78
00E2C:  DATA 25,30
00E2E:  DATA 32,58
00E30:  DATA 0D,0A
00E32:  DATA 00,00
00E34:  DATA 09,7C
00E36:  DATA 20,4D
00E38:  DATA 49,53
00E3A:  DATA 46,20
00E3C:  DATA 7C,20
00E3E:  DATA 49,56
00E40:  DATA 31,20
00E42:  DATA 44,41
00E44:  DATA 54,41
00E46:  DATA 20,20
00E48:  DATA 20,7C
00E4A:  DATA 20,55
00E4C:  DATA 73,65
00E4E:  DATA 20,43
00E50:  DATA 6F,75
00E52:  DATA 6E,74
00E54:  DATA 65,72
00E56:  DATA 20,20
00E58:  DATA 20,20
00E5A:  DATA 20,20
00E5C:  DATA 3A,20
00E5E:  DATA 30,78
00E60:  DATA 25,30
00E62:  DATA 38,4C
00E64:  DATA 58,0D
00E66:  DATA 0A,00
00E68:  DATA 09,7C
00E6A:  DATA 20,4D
00E6C:  DATA 49,53
00E6E:  DATA 46,20
00E70:  DATA 7C,20
00E72:  DATA 49,56
00E74:  DATA 31,20
00E76:  DATA 44,41
00E78:  DATA 54,41
00E7A:  DATA 20,20
00E7C:  DATA 20,7C
00E7E:  DATA 20,55
00E80:  DATA 6E,63
00E82:  DATA 6F,70
00E84:  DATA 79,65
00E86:  DATA 64,20
00E88:  DATA 43,6F
00E8A:  DATA 75,6E
00E8C:  DATA 74,65
00E8E:  DATA 72,20
00E90:  DATA 3A,20
00E92:  DATA 30,78
00E94:  DATA 25,30
00E96:  DATA 38,4C
00E98:  DATA 58,0D
00E9A:  DATA 0A,00
00E9C:  DATA 09,7C
00E9E:  DATA 20,4D
00EA0:  DATA 49,53
00EA2:  DATA 46,20
00EA4:  DATA 7C,20
00EA6:  DATA 49,56
00EA8:  DATA 31,20
00EAA:  DATA 44,41
00EAC:  DATA 54,41
00EAE:  DATA 20,20
00EB0:  DATA 20,7C
00EB2:  DATA 20,52
00EB4:  DATA 65,73
00EB6:  DATA 65,72
00EB8:  DATA 76,65
00EBA:  DATA 20,43
00EBC:  DATA 6F,75
00EBE:  DATA 6E,74
00EC0:  DATA 65,72
00EC2:  DATA 31,20
00EC4:  DATA 3A,20
00EC6:  DATA 30,78
00EC8:  DATA 25,30
00ECA:  DATA 32,58
00ECC:  DATA 0D,0A
00ECE:  DATA 00,00
00ED0:  DATA 09,7C
00ED2:  DATA 20,4D
00ED4:  DATA 49,53
00ED6:  DATA 46,20
00ED8:  DATA 7C,20
00EDA:  DATA 49,56
00EDC:  DATA 31,20
00EDE:  DATA 44,41
00EE0:  DATA 54,41
00EE2:  DATA 20,20
00EE4:  DATA 20,7C
00EE6:  DATA 20,52
00EE8:  DATA 65,73
00EEA:  DATA 65,72
00EEC:  DATA 76,65
00EEE:  DATA 20,43
00EF0:  DATA 6F,75
00EF2:  DATA 6E,74
00EF4:  DATA 65,72
00EF6:  DATA 32,20
00EF8:  DATA 3A,20
00EFA:  DATA 30,78
00EFC:  DATA 25,30
00EFE:  DATA 32,58
00F00:  DATA 0D,0A
00F02:  DATA 00,00
00F04:  DATA 09,7C
00F06:  DATA 20,4D
00F08:  DATA 49,53
00F0A:  DATA 46,20
00F0C:  DATA 7C,20
00F0E:  DATA 49,56
00F10:  DATA 32,20
00F12:  DATA 48,45
00F14:  DATA 41,44
00F16:  DATA 45,52
00F18:  DATA 20,7C
00F1A:  DATA 20,55
00F1C:  DATA 73,65
00F1E:  DATA 20,43
00F20:  DATA 6F,75
00F22:  DATA 6E,74
00F24:  DATA 65,72
00F26:  DATA 20,20
00F28:  DATA 20,20
00F2A:  DATA 20,20
00F2C:  DATA 3A,20
00F2E:  DATA 30,78
00F30:  DATA 25,30
00F32:  DATA 38,4C
00F34:  DATA 58,0D
00F36:  DATA 0A,00
00F38:  DATA 09,7C
00F3A:  DATA 20,4D
00F3C:  DATA 49,53
00F3E:  DATA 46,20
00F40:  DATA 7C,20
00F42:  DATA 49,56
00F44:  DATA 32,20
00F46:  DATA 48,45
00F48:  DATA 41,44
00F4A:  DATA 45,52
00F4C:  DATA 20,7C
00F4E:  DATA 20,55
00F50:  DATA 6E,63
00F52:  DATA 6F,70
00F54:  DATA 79,65
00F56:  DATA 64,20
00F58:  DATA 43,6F
00F5A:  DATA 75,6E
00F5C:  DATA 74,65
00F5E:  DATA 72,20
00F60:  DATA 3A,20
00F62:  DATA 30,78
00F64:  DATA 25,30
00F66:  DATA 38,4C
00F68:  DATA 58,0D
00F6A:  DATA 0A,00
00F6C:  DATA 09,7C
00F6E:  DATA 20,4D
00F70:  DATA 49,53
00F72:  DATA 46,20
00F74:  DATA 7C,20
00F76:  DATA 49,56
00F78:  DATA 32,20
00F7A:  DATA 48,45
00F7C:  DATA 41,44
00F7E:  DATA 45,52
00F80:  DATA 20,7C
00F82:  DATA 20,52
00F84:  DATA 65,73
00F86:  DATA 65,72
00F88:  DATA 76,65
00F8A:  DATA 20,43
00F8C:  DATA 6F,75
00F8E:  DATA 6E,74
00F90:  DATA 65,72
00F92:  DATA 31,20
00F94:  DATA 3A,20
00F96:  DATA 30,78
00F98:  DATA 25,30
00F9A:  DATA 32,58
00F9C:  DATA 0D,0A
00F9E:  DATA 00,00
00FA0:  DATA 09,7C
00FA2:  DATA 20,4D
00FA4:  DATA 49,53
00FA6:  DATA 46,20
00FA8:  DATA 7C,20
00FAA:  DATA 49,56
00FAC:  DATA 32,20
00FAE:  DATA 48,45
00FB0:  DATA 41,44
00FB2:  DATA 45,52
00FB4:  DATA 20,7C
00FB6:  DATA 20,52
00FB8:  DATA 65,73
00FBA:  DATA 65,72
00FBC:  DATA 76,65
00FBE:  DATA 20,43
00FC0:  DATA 6F,75
00FC2:  DATA 6E,74
00FC4:  DATA 65,72
00FC6:  DATA 32,20
00FC8:  DATA 3A,20
00FCA:  DATA 30,78
00FCC:  DATA 25,30
00FCE:  DATA 32,58
00FD0:  DATA 0D,0A
00FD2:  DATA 00,00
00FD4:  DATA 09,7C
00FD6:  DATA 20,4D
00FD8:  DATA 49,53
00FDA:  DATA 46,20
00FDC:  DATA 7C,20
00FDE:  DATA 49,56
00FE0:  DATA 32,20
00FE2:  DATA 44,41
00FE4:  DATA 54,41
00FE6:  DATA 20,20
00FE8:  DATA 20,7C
00FEA:  DATA 20,55
00FEC:  DATA 73,65
00FEE:  DATA 20,43
00FF0:  DATA 6F,75
00FF2:  DATA 6E,74
00FF4:  DATA 65,72
00FF6:  DATA 20,20
00FF8:  DATA 20,20
00FFA:  DATA 20,20
00FFC:  DATA 3A,20
00FFE:  DATA 30,78
01000:  DATA 25,30
01002:  DATA 38,4C
01004:  DATA 58,0D
01006:  DATA 0A,00
01008:  DATA 09,7C
0100A:  DATA 20,4D
0100C:  DATA 49,53
0100E:  DATA 46,20
01010:  DATA 7C,20
01012:  DATA 49,56
01014:  DATA 32,20
01016:  DATA 44,41
01018:  DATA 54,41
0101A:  DATA 20,20
0101C:  DATA 20,7C
0101E:  DATA 20,55
01020:  DATA 6E,63
01022:  DATA 6F,70
01024:  DATA 79,65
01026:  DATA 64,20
01028:  DATA 43,6F
0102A:  DATA 75,6E
0102C:  DATA 74,65
0102E:  DATA 72,20
01030:  DATA 3A,20
01032:  DATA 30,78
01034:  DATA 25,30
01036:  DATA 38,4C
01038:  DATA 58,0D
0103A:  DATA 0A,00
0103C:  DATA 09,7C
0103E:  DATA 20,4D
01040:  DATA 49,53
01042:  DATA 46,20
01044:  DATA 7C,20
01046:  DATA 49,56
01048:  DATA 32,20
0104A:  DATA 44,41
0104C:  DATA 54,41
0104E:  DATA 20,20
01050:  DATA 20,7C
01052:  DATA 20,52
01054:  DATA 65,73
01056:  DATA 65,72
01058:  DATA 76,65
0105A:  DATA 20,43
0105C:  DATA 6F,75
0105E:  DATA 6E,74
01060:  DATA 65,72
01062:  DATA 31,20
01064:  DATA 3A,20
01066:  DATA 30,78
01068:  DATA 25,30
0106A:  DATA 32,58
0106C:  DATA 0D,0A
0106E:  DATA 00,00
01070:  DATA 09,7C
01072:  DATA 20,4D
01074:  DATA 49,53
01076:  DATA 46,20
01078:  DATA 7C,20
0107A:  DATA 49,56
0107C:  DATA 32,20
0107E:  DATA 44,41
01080:  DATA 54,41
01082:  DATA 20,20
01084:  DATA 20,7C
01086:  DATA 20,52
01088:  DATA 65,73
0108A:  DATA 65,72
0108C:  DATA 76,65
0108E:  DATA 20,43
01090:  DATA 6F,75
01092:  DATA 6E,74
01094:  DATA 65,72
01096:  DATA 32,20
01098:  DATA 3A,20
0109A:  DATA 30,78
0109C:  DATA 25,30
0109E:  DATA 32,58
010A0:  DATA 0D,0A
010A2:  DATA 00,00
010A4:  DATA 09,43
010A6:  DATA 6F,6D
010A8:  DATA 70,6C
010AA:  DATA 65,74
010AC:  DATA 65,0D
010AE:  DATA 0A,00
010B0:  DATA 43,52
010B2:  DATA 43,20
010B4:  DATA 76,65
010B6:  DATA 72,69
010B8:  DATA 66,69
010BA:  DATA 63,61
010BC:  DATA 74,69
010BE:  DATA 6F,6E
010C0:  DATA 20,70
010C2:  DATA 61,73
010C4:  DATA 73,65
010C6:  DATA 64,20
010C8:  DATA 6F,6E
010CA:  DATA 20,61
010CC:  DATA 74,74
010CE:  DATA 65,6D
010D0:  DATA 70,74
010D2:  DATA 20,25
010D4:  DATA 64,0D
010D6:  DATA 0A,00
010D8:  DATA 45,72
010DA:  DATA 72,6F
010DC:  DATA 72,3A
010DE:  DATA 20,43
010E0:  DATA 52,43
010E2:  DATA 20,76
010E4:  DATA 65,72
010E6:  DATA 69,66
010E8:  DATA 69,63
010EA:  DATA 61,74
010EC:  DATA 69,6F
010EE:  DATA 6E,20
010F0:  DATA 66,61
010F2:  DATA 69,6C
010F4:  DATA 65,64
010F6:  DATA 20,61
010F8:  DATA 66,74
010FA:  DATA 65,72
010FC:  DATA 20,25
010FE:  DATA 64,20
01100:  DATA 61,74
01102:  DATA 74,65
01104:  DATA 6D,70
01106:  DATA 74,73
01108:  DATA 0D,0A
0110A:  DATA 00,00
0110C:  DATA 0D,0A
0110E:  DATA 5F,5F
01110:  DATA 5F,5F
01112:  DATA 5F,5F
01114:  DATA 5F,5F
01116:  DATA 5F,5F
01118:  DATA 5F,5F
0111A:  DATA 5F,5F
0111C:  DATA 5F,5F
0111E:  DATA 5F,5F
01120:  DATA 5F,5F
01122:  DATA 5F,5F
01124:  DATA 5F,5F
01126:  DATA 5F,5F
01128:  DATA 5F,5F
0112A:  DATA 5F,5F
0112C:  DATA 0D,0A
0112E:  DATA 5F,5F
01130:  DATA 5F,5F
01132:  DATA 5F,53
01134:  DATA 74,61
01136:  DATA 72,74
01138:  DATA 20,65
0113A:  DATA 78,65
0113C:  DATA 63,75
0113E:  DATA 74,65
01140:  DATA 5F,6D
01142:  DATA 69,73
01144:  DATA 73,69
01146:  DATA 6F,6E
01148:  DATA 5F,5F
0114A:  DATA 5F,5F
0114C:  DATA 5F,0D
0114E:  DATA 0A,0D
01150:  DATA 0A,00
01152:  DATA 43,6F
01154:  DATA 6D,6D
01156:  DATA 61,6E
01158:  DATA 64,20
0115A:  DATA 49,44
0115C:  DATA 3A,20
0115E:  DATA 25,58
01160:  DATA 0D,0A
01162:  DATA 0D,0A
01164:  DATA 00,00
01166:  DATA 09,09
01168:  DATA 2D,3E
0116A:  DATA 20,49
0116C:  DATA 6E,76
0116E:  DATA 61,6C
01170:  DATA 69,64
01172:  DATA 20,43
01174:  DATA 4D,44
01176:  DATA 20,49
01178:  DATA 44,21
0117A:  DATA 0D,0A
0117C:  DATA 00,00
0117E:  DATA 0D,0A
01180:  DATA 5F,5F
01182:  DATA 5F,5F
01184:  DATA 5F,5F
01186:  DATA 45,6E
01188:  DATA 64,20
0118A:  DATA 65,78
0118C:  DATA 65,63
0118E:  DATA 75,74
01190:  DATA 65,5F
01192:  DATA 6D,69
01194:  DATA 73,73
01196:  DATA 69,6F
01198:  DATA 6E,5F
0119A:  DATA 5F,5F
0119C:  DATA 5F,5F
0119E:  DATA 5F,0D
011A0:  DATA 0A,5F
011A2:  DATA 5F,5F
011A4:  DATA 5F,5F
011A6:  DATA 5F,5F
011A8:  DATA 5F,5F
011AA:  DATA 5F,5F
011AC:  DATA 5F,5F
011AE:  DATA 5F,5F
011B0:  DATA 5F,5F
011B2:  DATA 5F,5F
011B4:  DATA 5F,5F
011B6:  DATA 5F,5F
011B8:  DATA 5F,5F
011BA:  DATA 5F,5F
011BC:  DATA 5F,5F
011BE:  DATA 5F,5F
011C0:  DATA 0D,0A
011C2:  DATA 00,00
011C4:  DATA 53,74
011C6:  DATA 61,72
011C8:  DATA 74,20
011CA:  DATA 65,78
011CC:  DATA 65,63
011CE:  DATA 75,74
011D0:  DATA 65,5F
011D2:  DATA 63,6F
011D4:  DATA 6D,6D
011D6:  DATA 61,6E
011D8:  DATA 64,0D
011DA:  DATA 0A,00
011DC:  DATA 09,2D
011DE:  DATA 3E,20
011E0:  DATA 55,70
011E2:  DATA 6C,69
011E4:  DATA 6E,6B
011E6:  DATA 20,63
011E8:  DATA 6F,6D
011EA:  DATA 6D,61
011EC:  DATA 6E,64
011EE:  DATA 0D,0A
011F0:  DATA 00,00
011F2:  DATA 09,20
011F4:  DATA 20,20
011F6:  DATA 54,72
011F8:  DATA 61,6E
011FA:  DATA 73,6D
011FC:  DATA 69,74
011FE:  DATA 20,41
01200:  DATA 63,6B
01202:  DATA 6E,6F
01204:  DATA 6C,65
01206:  DATA 67,64
01208:  DATA 65,0D
0120A:  DATA 0A,00
0120C:  DATA 09,2D
0120E:  DATA 3E,20
01210:  DATA 53,74
01212:  DATA 61,74
01214:  DATA 75,73
01216:  DATA 20,63
01218:  DATA 68,65
0121A:  DATA 63,6B
0121C:  DATA 0D,0A
0121E:  DATA 00,00
01220:  DATA 09,20
01222:  DATA 20,20
01224:  DATA 54,72
01226:  DATA 61,6E
01228:  DATA 73,6D
0122A:  DATA 69,74
0122C:  DATA 20,4D
0122E:  DATA 49,53
01230:  DATA 20,4D
01232:  DATA 43,55
01234:  DATA 20,53
01236:  DATA 74,61
01238:  DATA 74,75
0123A:  DATA 73,0D
0123C:  DATA 0A,00
0123E:  DATA 66,69
01240:  DATA 6E,69
01242:  DATA 73,68
01244:  DATA 65,64
01246:  DATA 20,69
01248:  DATA 6E,20
0124A:  DATA 73,74
0124C:  DATA 61,74
0124E:  DATA 75,73
01250:  DATA 5F,63
01252:  DATA 68,65
01254:  DATA 63,6B
01256:  DATA 0D,0A
01258:  DATA 00,00
0125A:  DATA 09,2D
0125C:  DATA 3E,20
0125E:  DATA 53,4D
01260:  DATA 46,20
01262:  DATA 61,76
01264:  DATA 61,69
01266:  DATA 6C,61
01268:  DATA 62,6C
0126A:  DATA 65,20
0126C:  DATA 63,68
0126E:  DATA 65,63
01270:  DATA 6B,0D
01272:  DATA 0A,00
01274:  DATA 09,20
01276:  DATA 20,20
01278:  DATA 54,72
0127A:  DATA 61,6E
0127C:  DATA 73,6D
0127E:  DATA 69,74
01280:  DATA 20,41
01282:  DATA 63,6B
01284:  DATA 6E,6F
01286:  DATA 77,6C
01288:  DATA 65,64
0128A:  DATA 67,65
0128C:  DATA 6D,65
0128E:  DATA 6E,74
01290:  DATA 0D,0A
01292:  DATA 00,00
01294:  DATA 09,09
01296:  DATA 2D,3E
01298:  DATA 20,64
0129A:  DATA 65,6E
0129C:  DATA 69,65
0129E:  DATA 64,0D
012A0:  DATA 0A,00
012A2:  DATA 09,09
012A4:  DATA 2D,3E
012A6:  DATA 20,61
012A8:  DATA 6C,6C
012AA:  DATA 6F,77
012AC:  DATA 65,64
012AE:  DATA 0D,0A
012B0:  DATA 00,00
012B2:  DATA 09,09
012B4:  DATA 2D,3E
012B6:  DATA 20,64
012B8:  DATA 65,71
012BA:  DATA 75,65
012BC:  DATA 75,65
012BE:  DATA 20,4E
012C0:  DATA 55,4C
012C2:  DATA 4C,20
012C4:  DATA 28,62
012C6:  DATA 72,65
012C8:  DATA 61,6B
012CA:  DATA 29,0D
012CC:  DATA 0A,00
012CE:  DATA 09,09
012D0:  DATA 2D,3E
012D2:  DATA 20,44
012D4:  DATA 65,71
012D6:  DATA 75,65
012D8:  DATA 75,65
012DA:  DATA 64,3A
012DC:  DATA 20,66
012DE:  DATA 75,6E
012E0:  DATA 63,3D
012E2:  DATA 25,75
012E4:  DATA 20,6D
012E6:  DATA 69,73
012E8:  DATA 73,69
012EA:  DATA 6F,6E
012EC:  DATA 3D,25
012EE:  DATA 75,20
012F0:  DATA 73,69
012F2:  DATA 7A,65
012F4:  DATA 3D,25
012F6:  DATA 6C,64
012F8:  DATA 20,61
012FA:  DATA 64,64
012FC:  DATA 72,3D
012FE:  DATA 25,6C
01300:  DATA 64,0D
01302:  DATA 0A,00
01304:  DATA 09,09
01306:  DATA 20,20
01308:  DATA 20,55
0130A:  DATA 6E,6B
0130C:  DATA 6E,6F
0130E:  DATA 77,6E
01310:  DATA 20,66
01312:  DATA 75,6E
01314:  DATA 63,5F
01316:  DATA 74,79
01318:  DATA 70,65
0131A:  DATA 3D,25
0131C:  DATA 75,0D
0131E:  DATA 0A,00
01320:  DATA 09,09
01322:  DATA 2D,3E
01324:  DATA 20,43
01326:  DATA 6F,6D
01328:  DATA 70,6C
0132A:  DATA 65,74
0132C:  DATA 65,64
0132E:  DATA 20,25
01330:  DATA 75,20
01332:  DATA 6F,70
01334:  DATA 65,72
01336:  DATA 61,74
01338:  DATA 69,6F
0133A:  DATA 6E,73
0133C:  DATA 0D,0A
0133E:  DATA 00,00
01340:  DATA 53,74
01342:  DATA 61,72
01344:  DATA 74,20
01346:  DATA 4D,4F
01348:  DATA 44,45
0134A:  DATA 20,44
0134C:  DATA 55,4D
0134E:  DATA 4D,59
01350:  DATA 0D,0A
01352:  DATA 00,00
01354:  DATA 09,4D
01356:  DATA 4F,44
01358:  DATA 45,20
0135A:  DATA 20,20
0135C:  DATA 20,20
0135E:  DATA 3A,20
01360:  DATA 25,30
01362:  DATA 32,58
01364:  DATA 0D,0A
01366:  DATA 00,00
01368:  DATA 09,50
0136A:  DATA 61,72
0136C:  DATA 61,6D
0136E:  DATA 31,20
01370:  DATA 20,20
01372:  DATA 3A,20
01374:  DATA 30,78
01376:  DATA 25,30
01378:  DATA 38,4C
0137A:  DATA 58,0D
0137C:  DATA 0A,00
0137E:  DATA 09,50
01380:  DATA 61,72
01382:  DATA 61,6D
01384:  DATA 32,20
01386:  DATA 20,20
01388:  DATA 3A,20
0138A:  DATA 30,78
0138C:  DATA 25,30
0138E:  DATA 34,4C
01390:  DATA 58,0D
01392:  DATA 0A,00
01394:  DATA 45,6E
01396:  DATA 64,20
01398:  DATA 4D,4F
0139A:  DATA 44,45
0139C:  DATA 20,44
0139E:  DATA 55,4D
013A0:  DATA 4D,59
013A2:  DATA 0D,0A
013A4:  DATA 00,00
013A6:  DATA 53,74
013A8:  DATA 61,72
013AA:  DATA 74,20
013AC:  DATA 4D,4F
013AE:  DATA 44,45
013B0:  DATA 20,4D
013B2:  DATA 45,41
013B4:  DATA 53,20
013B6:  DATA 49,56
013B8:  DATA 0D,0A
013BA:  DATA 00,00
013BC:  DATA 09,49
013BE:  DATA 44,3A
013C0:  DATA 20,25
013C2:  DATA 30,32
013C4:  DATA 58,0D
013C6:  DATA 0A,00
013C8:  DATA 09,53
013CA:  DATA 6C,65
013CC:  DATA 65,70
013CE:  DATA 20,54
013D0:  DATA 69,6D
013D2:  DATA 65,3A
013D4:  DATA 20,25
013D6:  DATA 30,34
013D8:  DATA 4C,58
013DA:  DATA 20,6D
013DC:  DATA 73,0D
013DE:  DATA 0A,00
013E0:  DATA 09,43
013E2:  DATA 75,72
013E4:  DATA 72,65
013E6:  DATA 6E,74
013E8:  DATA 20,54
013EA:  DATA 68,72
013EC:  DATA 65,73
013EE:  DATA 68,6F
013F0:  DATA 6C,64
013F2:  DATA 3A,20
013F4:  DATA 25,30
013F6:  DATA 34,4C
013F8:  DATA 58,20
013FA:  DATA 6D,41
013FC:  DATA 0D,0A
013FE:  DATA 00,00
01400:  DATA 09,50
01402:  DATA 44,20
01404:  DATA 54,68
01406:  DATA 72,65
01408:  DATA 73,68
0140A:  DATA 6F,6C
0140C:  DATA 64,3A
0140E:  DATA 20,25
01410:  DATA 30,34
01412:  DATA 4C,58
01414:  DATA 20,6D
01416:  DATA 41,0D
01418:  DATA 0A,00
0141A:  DATA 09,43
0141C:  DATA 75,72
0141E:  DATA 72,65
01420:  DATA 6E,74
01422:  DATA 20,4C
01424:  DATA 69,6D
01426:  DATA 69,74
01428:  DATA 3A,20
0142A:  DATA 25,30
0142C:  DATA 34,4C
0142E:  DATA 58,20
01430:  DATA 6D,41
01432:  DATA 0D,0A
01434:  DATA 00,00
01436:  DATA 09,4D
01438:  DATA 65,61
0143A:  DATA 73,75
0143C:  DATA 72,65
0143E:  DATA 6D,65
01440:  DATA 6E,74
01442:  DATA 20,54
01444:  DATA 69,6D
01446:  DATA 65,3A
01448:  DATA 20,25
0144A:  DATA 30,34
0144C:  DATA 4C,58
0144E:  DATA 20,73
01450:  DATA 0D,0A
01452:  DATA 00,00
01454:  DATA 45,6E
01456:  DATA 64,20
01458:  DATA 4D,4F
0145A:  DATA 44,45
0145C:  DATA 20,54
0145E:  DATA 45,53
01460:  DATA 54,20
01462:  DATA 49,56
01464:  DATA 0D,0A
01466:  DATA 00,00
01468:  DATA 53,74
0146A:  DATA 61,72
0146C:  DATA 74,20
0146E:  DATA 4D,4F
01470:  DATA 44,45
01472:  DATA 20,4D
01474:  DATA 45,41
01476:  DATA 53,20
01478:  DATA 49,56
0147A:  DATA 0D,0A
0147C:  DATA 00,00
0147E:  DATA 09,49
01480:  DATA 44,3A
01482:  DATA 20,25
01484:  DATA 30,32
01486:  DATA 58,0D
01488:  DATA 0A,00
0148A:  DATA 09,53
0148C:  DATA 6C,65
0148E:  DATA 65,70
01490:  DATA 20,54
01492:  DATA 69,6D
01494:  DATA 65,3A
01496:  DATA 20,25
01498:  DATA 30,34
0149A:  DATA 4C,58
0149C:  DATA 20,6D
0149E:  DATA 73,0D
014A0:  DATA 0A,00
014A2:  DATA 09,43
014A4:  DATA 75,72
014A6:  DATA 72,65
014A8:  DATA 6E,74
014AA:  DATA 20,54
014AC:  DATA 68,72
014AE:  DATA 65,73
014B0:  DATA 68,6F
014B2:  DATA 6C,64
014B4:  DATA 3A,20
014B6:  DATA 25,30
014B8:  DATA 34,4C
014BA:  DATA 58,20
014BC:  DATA 6D,41
014BE:  DATA 0D,0A
014C0:  DATA 00,00
014C2:  DATA 09,50
014C4:  DATA 44,20
014C6:  DATA 54,68
014C8:  DATA 72,65
014CA:  DATA 73,68
014CC:  DATA 6F,6C
014CE:  DATA 64,3A
014D0:  DATA 20,25
014D2:  DATA 30,34
014D4:  DATA 4C,58
014D6:  DATA 20,6D
014D8:  DATA 41,0D
014DA:  DATA 0A,00
014DC:  DATA 09,43
014DE:  DATA 75,72
014E0:  DATA 72,65
014E2:  DATA 6E,74
014E4:  DATA 20,4C
014E6:  DATA 69,6D
014E8:  DATA 69,74
014EA:  DATA 3A,20
014EC:  DATA 25,30
014EE:  DATA 34,4C
014F0:  DATA 58,20
014F2:  DATA 6D,41
014F4:  DATA 0D,0A
014F6:  DATA 00,00
014F8:  DATA 09,4D
014FA:  DATA 65,61
014FC:  DATA 73,75
014FE:  DATA 72,65
01500:  DATA 6D,65
01502:  DATA 6E,74
01504:  DATA 20,54
01506:  DATA 69,6D
01508:  DATA 65,3A
0150A:  DATA 20,25
0150C:  DATA 30,34
0150E:  DATA 4C,58
01510:  DATA 20,73
01512:  DATA 0D,0A
01514:  DATA 00,00
01516:  DATA 45,6E
01518:  DATA 71,75
0151A:  DATA 65,75
0151C:  DATA 65,20
0151E:  DATA 46,6C
01520:  DATA 61,73
01522:  DATA 68,20
01524:  DATA 4F,70
01526:  DATA 65,72
01528:  DATA 61,74
0152A:  DATA 69,6F
0152C:  DATA 6E,0D
0152E:  DATA 0A,00
01530:  DATA 4D,69
01532:  DATA 73,73
01534:  DATA 69,6F
01536:  DATA 6E,20
01538:  DATA 49,44
0153A:  DATA 3A,20
0153C:  DATA 20,20
0153E:  DATA 25,30
01540:  DATA 32,58
01542:  DATA 0D,0A
01544:  DATA 00,00
01546:  DATA 46,75
01548:  DATA 6E,63
0154A:  DATA 74,69
0154C:  DATA 6F,6E
0154E:  DATA 20,54
01550:  DATA 79,70
01552:  DATA 65,3A
01554:  DATA 25,30
01556:  DATA 32,58
01558:  DATA 0D,0A
0155A:  DATA 00,00
0155C:  DATA 57,72
0155E:  DATA 69,74
01560:  DATA 65,20
01562:  DATA 4D,6F
01564:  DATA 64,65
01566:  DATA 3A,20
01568:  DATA 20,20
0156A:  DATA 25,30
0156C:  DATA 32,58
0156E:  DATA 0D,0A
01570:  DATA 00,00
01572:  DATA 53,6F
01574:  DATA 75,72
01576:  DATA 63,65
01578:  DATA 20,54
0157A:  DATA 79,70
0157C:  DATA 65,3A
0157E:  DATA 20,20
01580:  DATA 25,30
01582:  DATA 32,58
01584:  DATA 0D,0A
01586:  DATA 00,00
01588:  DATA 53,74
0158A:  DATA 61,72
0158C:  DATA 74,20
0158E:  DATA 41,64
01590:  DATA 64,72
01592:  DATA 65,73
01594:  DATA 73,3A
01596:  DATA 25,30
01598:  DATA 34,58
0159A:  DATA 0D,0A
0159C:  DATA 00,00
0159E:  DATA 53,69
015A0:  DATA 7A,65
015A2:  DATA 3A,20
015A4:  DATA 20,20
015A6:  DATA 20,20
015A8:  DATA 20,20
015AA:  DATA 20,20
015AC:  DATA 25,30
015AE:  DATA 34,58
015B0:  DATA 0D,0A
015B2:  DATA 00,00
015B4:  DATA 45,6E
015B6:  DATA 64,20
015B8:  DATA 4D,4F
015BA:  DATA 44,45
015BC:  DATA 20,4D
015BE:  DATA 45,41
015C0:  DATA 53,20
015C2:  DATA 49,56
015C4:  DATA 20,6D
015C6:  DATA 69,73
015C8:  DATA 73,69
015CA:  DATA 6F,6E
015CC:  DATA 0D,0A
015CE:  DATA 00,00
015D0:  DATA 53,74
015D2:  DATA 61,72
015D4:  DATA 74,20
015D6:  DATA 4D,4F
015D8:  DATA 44,45
015DA:  DATA 20,49
015DC:  DATA 56,20
015DE:  DATA 54,45
015E0:  DATA 53,54
015E2:  DATA 20,0D
015E4:  DATA 0A,00
015E6:  DATA 09,49
015E8:  DATA 44,3A
015EA:  DATA 20,25
015EC:  DATA 30,32
015EE:  DATA 58,0D
015F0:  DATA 0A,00
015F2:  DATA 09,53
015F4:  DATA 6C,65
015F6:  DATA 65,70
015F8:  DATA 20,54
015FA:  DATA 69,6D
015FC:  DATA 65,3A
015FE:  DATA 20,25
01600:  DATA 30,34
01602:  DATA 4C,58
01604:  DATA 20,6D
01606:  DATA 73,0D
01608:  DATA 0A,00
0160A:  DATA 09,43
0160C:  DATA 75,72
0160E:  DATA 72,65
01610:  DATA 6E,74
01612:  DATA 20,54
01614:  DATA 68,72
01616:  DATA 65,73
01618:  DATA 68,6F
0161A:  DATA 6C,64
0161C:  DATA 3A,20
0161E:  DATA 25,30
01620:  DATA 34,4C
01622:  DATA 58,20
01624:  DATA 6D,41
01626:  DATA 0D,0A
01628:  DATA 00,00
0162A:  DATA 09,50
0162C:  DATA 44,20
0162E:  DATA 54,68
01630:  DATA 72,65
01632:  DATA 73,68
01634:  DATA 6F,6C
01636:  DATA 64,3A
01638:  DATA 20,25
0163A:  DATA 30,34
0163C:  DATA 4C,58
0163E:  DATA 20,6D
01640:  DATA 41,0D
01642:  DATA 0A,00
01644:  DATA 09,43
01646:  DATA 75,72
01648:  DATA 72,65
0164A:  DATA 6E,74
0164C:  DATA 20,4C
0164E:  DATA 69,6D
01650:  DATA 69,74
01652:  DATA 3A,20
01654:  DATA 25,30
01656:  DATA 34,4C
01658:  DATA 58,20
0165A:  DATA 6D,41
0165C:  DATA 0D,0A
0165E:  DATA 00,00
01660:  DATA 09,4D
01662:  DATA 65,61
01664:  DATA 73,75
01666:  DATA 72,65
01668:  DATA 6D,65
0166A:  DATA 6E,74
0166C:  DATA 20,54
0166E:  DATA 69,6D
01670:  DATA 65,3A
01672:  DATA 20,25
01674:  DATA 30,34
01676:  DATA 4C,58
01678:  DATA 20,73
0167A:  DATA 0D,0A
0167C:  DATA 00,00
0167E:  DATA 53,74
01680:  DATA 61,72
01682:  DATA 74,20
01684:  DATA 46,6C
01686:  DATA 61,73
01688:  DATA 68,20
0168A:  DATA 45,72
0168C:  DATA 61,73
0168E:  DATA 65,20
01690:  DATA 41,6C
01692:  DATA 6C,0D
01694:  DATA 0A,00
01696:  DATA 45,6E
01698:  DATA 64,20
0169A:  DATA 46,6C
0169C:  DATA 61,73
0169E:  DATA 68,20
016A0:  DATA 45,72
016A2:  DATA 61,73
016A4:  DATA 65,20
016A6:  DATA 41,6C
016A8:  DATA 6C,0D
016AA:  DATA 0A,00
016AC:  DATA 53,74
016AE:  DATA 61,72
016B0:  DATA 74,20
016B2:  DATA 46,6C
016B4:  DATA 61,73
016B6:  DATA 68,20
016B8:  DATA 45,72
016BA:  DATA 61,73
016BC:  DATA 65,20
016BE:  DATA 31,20
016C0:  DATA 53,65
016C2:  DATA 63,74
016C4:  DATA 6F,72
016C6:  DATA 0D,0A
016C8:  DATA 00,00
016CA:  DATA 09,53
016CC:  DATA 65,63
016CE:  DATA 74,6F
016D0:  DATA 72,20
016D2:  DATA 41,64
016D4:  DATA 64,72
016D6:  DATA 65,73
016D8:  DATA 73,3A
016DA:  DATA 20,30
016DC:  DATA 78,25
016DE:  DATA 30,38
016E0:  DATA 4C,58
016E2:  DATA 0D,0A
016E4:  DATA 00,00
016E6:  DATA 45,6E
016E8:  DATA 64,20
016EA:  DATA 46,6C
016EC:  DATA 61,73
016EE:  DATA 68,20
016F0:  DATA 45,72
016F2:  DATA 61,73
016F4:  DATA 65,20
016F6:  DATA 31,20
016F8:  DATA 53,65
016FA:  DATA 63,74
016FC:  DATA 6F,72
016FE:  DATA 0D,0A
01700:  DATA 00,00
01702:  DATA 53,74
01704:  DATA 61,72
01706:  DATA 74,20
01708:  DATA 46,6C
0170A:  DATA 61,73
0170C:  DATA 68,20
0170E:  DATA 43,6F
01710:  DATA 70,79
01712:  DATA 20,31
01714:  DATA 20,53
01716:  DATA 65,63
01718:  DATA 74,6F
0171A:  DATA 72,0D
0171C:  DATA 0A,00
0171E:  DATA 09,53
01720:  DATA 75,62
01722:  DATA 73,65
01724:  DATA 63,74
01726:  DATA 6F,72
01728:  DATA 20,41
0172A:  DATA 64,64
0172C:  DATA 72,65
0172E:  DATA 73,73
01730:  DATA 3A,20
01732:  DATA 30,78
01734:  DATA 25,30
01736:  DATA 38,4C
01738:  DATA 58,0D
0173A:  DATA 0A,00
0173C:  DATA 45,6E
0173E:  DATA 64,20
01740:  DATA 46,6C
01742:  DATA 61,73
01744:  DATA 68,20
01746:  DATA 43,6F
01748:  DATA 70,79
0174A:  DATA 20,31
0174C:  DATA 20,53
0174E:  DATA 65,63
01750:  DATA 74,6F
01752:  DATA 72,0D
01754:  DATA 0A,00
01756:  DATA 53,74
01758:  DATA 61,72
0175A:  DATA 74,20
0175C:  DATA 46,6C
0175E:  DATA 61,73
01760:  DATA 68,20
01762:  DATA 45,72
01764:  DATA 61,73
01766:  DATA 65,20
01768:  DATA 36,34
0176A:  DATA 6B,42
0176C:  DATA 79,74
0176E:  DATA 65,20
01770:  DATA 53,75
01772:  DATA 62,73
01774:  DATA 65,63
01776:  DATA 74,6F
01778:  DATA 72,0D
0177A:  DATA 0A,00
0177C:  DATA 09,53
0177E:  DATA 75,62
01780:  DATA 73,65
01782:  DATA 63,74
01784:  DATA 6F,72
01786:  DATA 20,41
01788:  DATA 64,64
0178A:  DATA 72,65
0178C:  DATA 73,73
0178E:  DATA 3A,20
01790:  DATA 30,78
01792:  DATA 25,30
01794:  DATA 38,4C
01796:  DATA 58,0D
01798:  DATA 0A,00
0179A:  DATA 45,6E
0179C:  DATA 64,20
0179E:  DATA 46,6C
017A0:  DATA 61,73
017A2:  DATA 68,20
017A4:  DATA 45,72
017A6:  DATA 61,73
017A8:  DATA 65,20
017AA:  DATA 36,34
017AC:  DATA 6B,42
017AE:  DATA 79,74
017B0:  DATA 65,20
017B2:  DATA 53,75
017B4:  DATA 62,73
017B6:  DATA 65,63
017B8:  DATA 74,6F
017BA:  DATA 72,0D
017BC:  DATA 0A,00
017BE:  DATA 53,74
017C0:  DATA 61,72
017C2:  DATA 74,20
017C4:  DATA 46,6C
017C6:  DATA 61,73
017C8:  DATA 68,20
017CA:  DATA 57,72
017CC:  DATA 69,74
017CE:  DATA 65,20
017D0:  DATA 44,65
017D2:  DATA 6D,6F
017D4:  DATA 0D,0A
017D6:  DATA 00,00
017D8:  DATA 09,4D
017DA:  DATA 4F,44
017DC:  DATA 45,20
017DE:  DATA 20,20
017E0:  DATA 20,20
017E2:  DATA 3A,20
017E4:  DATA 25,30
017E6:  DATA 32,58
017E8:  DATA 0D,0A
017EA:  DATA 00,00
017EC:  DATA 09,41
017EE:  DATA 64,64
017F0:  DATA 72,65
017F2:  DATA 73,73
017F4:  DATA 20,20
017F6:  DATA 3A,20
017F8:  DATA 30,78
017FA:  DATA 25,30
017FC:  DATA 38,4C
017FE:  DATA 58,0D
01800:  DATA 0A,00
01802:  DATA 09,50
01804:  DATA 61,63
01806:  DATA 6B,65
01808:  DATA 74,4E
0180A:  DATA 75,6D
0180C:  DATA 3A,20
0180E:  DATA 30,78
01810:  DATA 25,30
01812:  DATA 34,4C
01814:  DATA 58,0D
01816:  DATA 0A,00
01818:  DATA 57,72
0181A:  DATA 69,74
0181C:  DATA 65,20
0181E:  DATA 44,61
01820:  DATA 74,61
01822:  DATA 0D,0A
01824:  DATA 00,00
01826:  DATA 45,6E
01828:  DATA 64,20
0182A:  DATA 46,6C
0182C:  DATA 61,73
0182E:  DATA 68,20
01830:  DATA 57,72
01832:  DATA 69,74
01834:  DATA 65,20
01836:  DATA 44,65
01838:  DATA 6D,6F
0183A:  DATA 0D,0A
0183C:  DATA 00,00
0183E:  DATA 53,74
01840:  DATA 61,72
01842:  DATA 74,20
01844:  DATA 46,6C
01846:  DATA 61,73
01848:  DATA 68,20
0184A:  DATA 57,72
0184C:  DATA 69,74
0184E:  DATA 65,20
01850:  DATA 34,6B
01852:  DATA 42,79
01854:  DATA 74,65
01856:  DATA 20,53
01858:  DATA 75,62
0185A:  DATA 73,65
0185C:  DATA 63,74
0185E:  DATA 6F,72
01860:  DATA 0D,0A
01862:  DATA 00,00
01864:  DATA 45,6E
01866:  DATA 64,20
01868:  DATA 46,6C
0186A:  DATA 61,73
0186C:  DATA 68,20
0186E:  DATA 57,72
01870:  DATA 69,74
01872:  DATA 65,20
01874:  DATA 34,6B
01876:  DATA 42,79
01878:  DATA 74,65
0187A:  DATA 20,53
0187C:  DATA 75,62
0187E:  DATA 73,65
01880:  DATA 63,74
01882:  DATA 6F,72
01884:  DATA 0D,0A
01886:  DATA 00,00
01888:  DATA 53,74
0188A:  DATA 61,72
0188C:  DATA 74,20
0188E:  DATA 46,6C
01890:  DATA 61,73
01892:  DATA 68,20
01894:  DATA 52,65
01896:  DATA 61,64
01898:  DATA 0D,0A
0189A:  DATA 00,00
0189C:  DATA 09,4D
0189E:  DATA 4F,44
018A0:  DATA 45,20
018A2:  DATA 20,20
018A4:  DATA 20,20
018A6:  DATA 3A,20
018A8:  DATA 25,30
018AA:  DATA 32,58
018AC:  DATA 0D,0A
018AE:  DATA 00,00
018B0:  DATA 09,41
018B2:  DATA 64,64
018B4:  DATA 72,65
018B6:  DATA 73,73
018B8:  DATA 20,20
018BA:  DATA 3A,20
018BC:  DATA 30,78
018BE:  DATA 25,30
018C0:  DATA 38,4C
018C2:  DATA 58,0D
018C4:  DATA 0A,00
018C6:  DATA 09,50
018C8:  DATA 61,63
018CA:  DATA 6B,65
018CC:  DATA 74,4E
018CE:  DATA 75,6D
018D0:  DATA 3A,20
018D2:  DATA 30,78
018D4:  DATA 25,30
018D6:  DATA 34,4C
018D8:  DATA 58,0D
018DA:  DATA 0A,00
018DC:  DATA 52,45
018DE:  DATA 41,44
018E0:  DATA 20,44
018E2:  DATA 41,54
018E4:  DATA 41,0D
018E6:  DATA 0A,00
018E8:  DATA 4D,69
018EA:  DATA 73,73
018EC:  DATA 69,6F
018EE:  DATA 6E,20
018F0:  DATA 46,6C
018F2:  DATA 61,73
018F4:  DATA 68,20
018F6:  DATA 69,73
018F8:  DATA 20,6E
018FA:  DATA 6F,74
018FC:  DATA 20,63
018FE:  DATA 6F,6E
01900:  DATA 6E,65
01902:  DATA 63,74
01904:  DATA 65,64
01906:  DATA 0D,0A
01908:  DATA 00,00
0190A:  DATA 45,6E
0190C:  DATA 64,20
0190E:  DATA 46,6C
01910:  DATA 61,73
01912:  DATA 68,20
01914:  DATA 52,65
01916:  DATA 61,64
01918:  DATA 0D,0A
0191A:  DATA 00,00
0191C:  DATA 53,74
0191E:  DATA 61,72
01920:  DATA 74,20
01922:  DATA 46,6C
01924:  DATA 61,73
01926:  DATA 68,20
01928:  DATA 52,65
0192A:  DATA 61,64
0192C:  DATA 20,41
0192E:  DATA 64,64
01930:  DATA 72,65
01932:  DATA 73,73
01934:  DATA 0D,0A
01936:  DATA 00,00
01938:  DATA 52,65
0193A:  DATA 61,64
0193C:  DATA 20,44
0193E:  DATA 61,74
01940:  DATA 61,3A
01942:  DATA 20,25
01944:  DATA 30,32
01946:  DATA 58,20
01948:  DATA 25,30
0194A:  DATA 32,58
0194C:  DATA 20,25
0194E:  DATA 30,32
01950:  DATA 58,20
01952:  DATA 25,30
01954:  DATA 32,58
01956:  DATA 0D,0A
01958:  DATA 00,00
0195A:  DATA 45,6E
0195C:  DATA 64,20
0195E:  DATA 46,6C
01960:  DATA 61,73
01962:  DATA 68,20
01964:  DATA 52,65
01966:  DATA 61,64
01968:  DATA 20,41
0196A:  DATA 64,64
0196C:  DATA 72,65
0196E:  DATA 73,73
01970:  DATA 0D,0A
01972:  DATA 00,00
01974:  DATA 53,74
01976:  DATA 61,72
01978:  DATA 74,20
0197A:  DATA 46,6C
0197C:  DATA 61,73
0197E:  DATA 68,20
01980:  DATA 45,72
01982:  DATA 61,73
01984:  DATA 65,20
01986:  DATA 61,6E
01988:  DATA 64,20
0198A:  DATA 52,65
0198C:  DATA 73,65
0198E:  DATA 74,0D
01990:  DATA 0A,00
01992:  DATA 45,6E
01994:  DATA 64,20
01996:  DATA 46,6C
01998:  DATA 61,73
0199A:  DATA 68,20
0199C:  DATA 45,72
0199E:  DATA 61,73
019A0:  DATA 65,20
019A2:  DATA 61,6E
019A4:  DATA 64,20
019A6:  DATA 52,65
019A8:  DATA 73,65
019AA:  DATA 74,0D
019AC:  DATA 0A,00
019AE:  DATA 53,74
019B0:  DATA 61,72
019B2:  DATA 74,20
019B4:  DATA 46,6C
019B6:  DATA 61,73
019B8:  DATA 68,20
019BA:  DATA 53,4D
019BC:  DATA 46,20
019BE:  DATA 43,6F
019C0:  DATA 70,79
019C2:  DATA 0D,0A
019C4:  DATA 00,00
019C6:  DATA 45,6E
019C8:  DATA 64,20
019CA:  DATA 46,6C
019CC:  DATA 61,73
019CE:  DATA 68,20
019D0:  DATA 53,4D
019D2:  DATA 46,20
019D4:  DATA 43,6F
019D6:  DATA 70,79
019D8:  DATA 0D,0A
019DA:  DATA 00,00
019DC:  DATA 53,74
019DE:  DATA 61,72
019E0:  DATA 74,20
019E2:  DATA 46,6C
019E4:  DATA 61,73
019E6:  DATA 68,20
019E8:  DATA 53,4D
019EA:  DATA 46,20
019EC:  DATA 52,65
019EE:  DATA 61,64
019F0:  DATA 0D,0A
019F2:  DATA 00,00
019F4:  DATA 52,65
019F6:  DATA 61,64
019F8:  DATA 20,44
019FA:  DATA 61,74
019FC:  DATA 61,3A
019FE:  DATA 20,00
01A00:  DATA 0D,0A
01A02:  DATA 45,6E
01A04:  DATA 64,20
01A06:  DATA 46,6C
01A08:  DATA 61,73
01A0A:  DATA 68,20
01A0C:  DATA 53,4D
01A0E:  DATA 46,20
01A10:  DATA 52,65
01A12:  DATA 61,64
01A14:  DATA 0D,0A
01A16:  DATA 00,00
01A18:  DATA 53,74
01A1A:  DATA 61,72
01A1C:  DATA 74,20
01A1E:  DATA 46,6C
01A20:  DATA 61,73
01A22:  DATA 68,20
01A24:  DATA 53,4D
01A26:  DATA 46,20
01A28:  DATA 45,72
01A2A:  DATA 61,73
01A2C:  DATA 65,0D
01A2E:  DATA 0A,00
01A30:  DATA 45,6E
01A32:  DATA 64,20
01A34:  DATA 46,6C
01A36:  DATA 61,73
01A38:  DATA 68,20
01A3A:  DATA 53,4D
01A3C:  DATA 46,20
01A3E:  DATA 45,72
01A40:  DATA 61,73
01A42:  DATA 65,0D
01A44:  DATA 0A,00
01A46:  DATA 53,74
01A48:  DATA 61,72
01A4A:  DATA 74,20
01A4C:  DATA 46,6C
01A4E:  DATA 61,73
01A50:  DATA 68,20
01A52:  DATA 41,64
01A54:  DATA 64,72
01A56:  DATA 65,73
01A58:  DATA 73,20
01A5A:  DATA 52,65
01A5C:  DATA 73,65
01A5E:  DATA 74,0D
01A60:  DATA 0A,00
01A62:  DATA 45,6E
01A64:  DATA 64,20
01A66:  DATA 46,6C
01A68:  DATA 61,73
01A6A:  DATA 68,20
01A6C:  DATA 41,64
01A6E:  DATA 64,72
01A70:  DATA 65,73
01A72:  DATA 73,20
01A74:  DATA 52,65
01A76:  DATA 73,65
01A78:  DATA 74,0D
01A7A:  DATA 0A,00
01A7C:  DATA 53,4D
01A7E:  DATA 46,20
01A80:  DATA 69,73
01A82:  DATA 20,6E
01A84:  DATA 6F,74
01A86:  DATA 20,63
01A88:  DATA 6F,6E
01A8A:  DATA 6E,65
01A8C:  DATA 63,74
01A8E:  DATA 65,64
01A90:  DATA 0D,0A
01A92:  DATA 00,00
01A94:  DATA 53,74
01A96:  DATA 61,72
01A98:  DATA 74,20
01A9A:  DATA 46,6C
01A9C:  DATA 61,73
01A9E:  DATA 68,20
01AA0:  DATA 53,4D
01AA2:  DATA 46,20
01AA4:  DATA 52,65
01AA6:  DATA 61,64
01AA8:  DATA 20,46
01AAA:  DATA 6F,72
01AAC:  DATA 63,65
01AAE:  DATA 0D,0A
01AB0:  DATA 00,00
01AB2:  DATA 09,41
01AB4:  DATA 64,64
01AB6:  DATA 72,65
01AB8:  DATA 73,73
01ABA:  DATA 20,20
01ABC:  DATA 3A,20
01ABE:  DATA 30,78
01AC0:  DATA 25,30
01AC2:  DATA 38,4C
01AC4:  DATA 58,0D
01AC6:  DATA 0A,00
01AC8:  DATA 09,50
01ACA:  DATA 61,63
01ACC:  DATA 6B,65
01ACE:  DATA 74,4E
01AD0:  DATA 75,6D
01AD2:  DATA 3A,20
01AD4:  DATA 30,78
01AD6:  DATA 25,30
01AD8:  DATA 34,4C
01ADA:  DATA 58,0D
01ADC:  DATA 0A,00
01ADE:  DATA 72,65
01AE0:  DATA 61,64
01AE2:  DATA 20,64
01AE4:  DATA 61,74
01AE6:  DATA 61,0D
01AE8:  DATA 0A,00
01AEA:  DATA 0D,0A
01AEC:  DATA 45,6E
01AEE:  DATA 64,20
01AF0:  DATA 46,6C
01AF2:  DATA 61,73
01AF4:  DATA 68,20
01AF6:  DATA 53,4D
01AF8:  DATA 46,20
01AFA:  DATA 52,65
01AFC:  DATA 61,64
01AFE:  DATA 20,46
01B00:  DATA 6F,72
01B02:  DATA 63,65
01B04:  DATA 0D,0A
01B06:  DATA 00,00
01B08:  DATA 53,74
01B0A:  DATA 61,72
01B0C:  DATA 74,20
01B0E:  DATA 53,4D
01B10:  DATA 46,20
01B12:  DATA 45,72
01B14:  DATA 61,73
01B16:  DATA 65,20
01B18:  DATA 41,6C
01B1A:  DATA 6C,0D
01B1C:  DATA 0A,00
01B1E:  DATA 45,6E
01B20:  DATA 64,20
01B22:  DATA 53,4D
01B24:  DATA 46,20
01B26:  DATA 45,72
01B28:  DATA 61,73
01B2A:  DATA 65,20
01B2C:  DATA 41,6C
01B2E:  DATA 6C,0D
01B30:  DATA 0A,00
01B32:  DATA 53,74
01B34:  DATA 61,72
01B36:  DATA 74,20
01B38:  DATA 53,4D
01B3A:  DATA 46,20
01B3C:  DATA 52,65
01B3E:  DATA 73,65
01B40:  DATA 74,0D
01B42:  DATA 0A,00
01B44:  DATA 45,6E
01B46:  DATA 64,20
01B48:  DATA 53,4D
01B4A:  DATA 46,20
01B4C:  DATA 52,65
01B4E:  DATA 73,65
01B50:  DATA 74,0D
01B52:  DATA 0A,00
01B54:  DATA 0D,0A
01B56:  DATA 0D,0A
01B58:  DATA 0D,0A
01B5A:  DATA 3D,3D
01B5C:  DATA 3D,3D
01B5E:  DATA 3D,3D
01B60:  DATA 3D,3D
01B62:  DATA 3D,3D
01B64:  DATA 3D,3D
01B66:  DATA 3D,3D
01B68:  DATA 3D,3D
01B6A:  DATA 3D,3D
01B6C:  DATA 3D,3D
01B6E:  DATA 3D,3D
01B70:  DATA 3D,3D
01B72:  DATA 3D,3D
01B74:  DATA 3D,3D
01B76:  DATA 3D,3D
01B78:  DATA 3D,3D
01B7A:  DATA 3D,3D
01B7C:  DATA 3D,3D
01B7E:  DATA 3D,3D
01B80:  DATA 3D,3D
01B82:  DATA 3D,3D
01B84:  DATA 3D,3D
01B86:  DATA 3D,3D
01B88:  DATA 3D,3D
01B8A:  DATA 3D,3D
01B8C:  DATA 3D,3D
01B8E:  DATA 3D,3D
01B90:  DATA 3D,3D
01B92:  DATA 3D,3D
01B94:  DATA 3D,3D
01B96:  DATA 0D,0A
01B98:  DATA 00,00
01B9A:  DATA 54,68
01B9C:  DATA 69,73
01B9E:  DATA 20,69
01BA0:  DATA 73,20
01BA2:  DATA 4D,4F
01BA4:  DATA 4D,49
01BA6:  DATA 4A,49
01BA8:  DATA 20,43
01BAA:  DATA 49,47
01BAC:  DATA 53,20
01BAE:  DATA 50,49
01BB0:  DATA 43,20
01BB2:  DATA 42,42
01BB4:  DATA 4D,20
01BB6:  DATA 66,6F
01BB8:  DATA 72,20
01BBA:  DATA 4D,49
01BBC:  DATA 53,37
01BBE:  DATA 5F,42
01BC0:  DATA 42,4D
01BC2:  DATA 34,2E
01BC4:  DATA 0D,0A
01BC6:  DATA 00,00
01BC8:  DATA 4C,61
01BCA:  DATA 73,74
01BCC:  DATA 20,75
01BCE:  DATA 70,64
01BD0:  DATA 61,74
01BD2:  DATA 65,64
01BD4:  DATA 20,6F
01BD6:  DATA 6E,20
01BD8:  DATA 25,73
01BDA:  DATA 20,25
01BDC:  DATA 73,2C
01BDE:  DATA 20,62
01BE0:  DATA 79,20
01BE2:  DATA 49,6E
01BE4:  DATA 6F,75
01BE6:  DATA 65,2E
01BE8:  DATA 0D,0A
01BEA:  DATA 0D,0A
01BEC:  DATA 00,00
01BEE:  DATA 32,39
01BF0:  DATA 2D,41
01BF2:  DATA 75,67
01BF4:  DATA 2D,32
01BF6:  DATA 35,00
01BF8:  DATA 31,36
01BFA:  DATA 3A,30
01BFC:  DATA 37,3A
01BFE:  DATA 35,33
01C00:  DATA 00,00
01C02:  DATA 5F,5F
01C04:  DATA 5F,5F
01C06:  DATA 43,49
01C08:  DATA 47,53
01C0A:  DATA 20,50
01C0C:  DATA 49,43
01C0E:  DATA 20,53
01C10:  DATA 74,61
01C12:  DATA 72,74
01C14:  DATA 20,4F
01C16:  DATA 70,65
01C18:  DATA 72,61
01C1A:  DATA 74,69
01C1C:  DATA 6F,6E
01C1E:  DATA 5F,5F
01C20:  DATA 5F,5F
01C22:  DATA 5F,0D
01C24:  DATA 0A,0D
01C26:  DATA 0A,00
01C28:  DATA 77,61
01C2A:  DATA 69,74
01C2C:  DATA 69,6E
01C2E:  DATA 67,20
01C30:  DATA 66,6F
01C32:  DATA 72,20
01C34:  DATA 42,4F
01C36:  DATA 53,53
01C38:  DATA 20,50
01C3A:  DATA 49,43
01C3C:  DATA 20,63
01C3E:  DATA 6F,6D
01C40:  DATA 6D,61
01C42:  DATA 6E,64
01C44:  DATA 00,00
01C46:  DATA 0D,0A
01C48:  DATA 77,61
01C4A:  DATA 69,74
01C4C:  DATA 69,6E
01C4E:  DATA 67,20
01C50:  DATA 66,6F
01C52:  DATA 72,20
01C54:  DATA 42,4F
01C56:  DATA 53,53
01C58:  DATA 20,50
01C5A:  DATA 49,43
01C5C:  DATA 20,63
01C5E:  DATA 6F,6D
01C60:  DATA 6D,61
01C62:  DATA 6E,64
01C64:  DATA 00,00
01C66:  DATA 0D,0A
01C68:  DATA 0D,0A
01C6A:  DATA 3D,3D
01C6C:  DATA 3D,3D
01C6E:  DATA 3D,3D
01C70:  DATA 0D,0A
01C72:  DATA 0D,0A
01C74:  DATA 46,69
01C76:  DATA 6E,69
01C78:  DATA 73,68
01C7A:  DATA 65,64
01C7C:  DATA 20,70
01C7E:  DATA 72,6F
01C80:  DATA 63,65
01C82:  DATA 73,73
01C84:  DATA 2E,0D
01C86:  DATA 0A,57
01C88:  DATA 61,69
01C8A:  DATA 74,20
01C8C:  DATA 66,6F
01C8E:  DATA 72,20
01C90:  DATA 42,4F
01C92:  DATA 53,53
01C94:  DATA 20,50
01C96:  DATA 49,43
01C98:  DATA 20,74
01C9A:  DATA 75,72
01C9C:  DATA 6E,20
01C9E:  DATA 6F,66
01CA0:  DATA 66,20
01CA2:  DATA 6D,65
01CA4:  DATA 00,00
01CA6:  DATA 45,6E
01CA8:  DATA 64,20
01CAA:  DATA 6D,61
01CAC:  DATA 69,6E
01CAE:  DATA 0D,0A
01CB0:  DATA 00,00
*
01D32:  TBLRD*+
01D34:  MOVF   FF5,F
01D36:  BTFSC  FD8.2
01D38:  GOTO   1D60
01D3C:  MOVFF  FF6,2C7
01D40:  MOVFF  FF7,2C8
01D44:  MOVFF  FF8,2C9
01D48:  MOVFF  FF5,ADB
01D4C:  CALL   1CE0
01D50:  MOVFF  2C7,FF6
01D54:  MOVFF  2C8,FF7
01D58:  MOVFF  2C9,FF8
01D5C:  GOTO   1D32
01D60:  RETURN 0
01D62:  TBLRD*+
01D64:  MOVFF  FF6,313
01D68:  MOVFF  FF7,314
01D6C:  MOVFF  FF8,315
01D70:  MOVFF  FF5,ADB
01D74:  CALL   1CE0
01D78:  MOVFF  313,FF6
01D7C:  MOVFF  314,FF7
01D80:  MOVFF  315,FF8
01D84:  MOVLB  3
01D86:  DECFSZ x12,F
01D88:  BRA    1D8E
01D8A:  BRA    1D94
01D8C:  MOVLB  0
01D8E:  MOVLB  0
01D90:  GOTO   1D62
01D94:  MOVLB  0
01D96:  RETURN 0
*
01F60:  MOVLB  A
01F62:  BTFSS  x3A.7
01F64:  BRA    1F6C
01F66:  MOVLB  0
01F68:  GOTO   1F9C
01F6C:  MOVLW  0F
01F6E:  MOVWF  00
01F70:  SWAPF  x39,W
01F72:  ANDWF  00,F
01F74:  MOVLW  0A
01F76:  SUBWF  00,W
01F78:  BTFSS  FD8.0
01F7A:  BRA    1F82
01F7C:  MOVLB  0
01F7E:  GOTO   1F8C
01F82:  MOVLW  30
01F84:  ADDWF  00,F
01F86:  MOVLB  0
01F88:  GOTO   1F94
01F8C:  MOVLB  A
01F8E:  MOVF   x3A,W
01F90:  ADDWF  00,F
01F92:  MOVLB  0
01F94:  MOVFF  00,ADB
01F98:  CALL   1CE0
01F9C:  MOVLW  0F
01F9E:  MOVLB  A
01FA0:  ANDWF  x39,F
01FA2:  MOVLW  0A
01FA4:  SUBWF  x39,W
01FA6:  BTFSS  FD8.0
01FA8:  BRA    1FB0
01FAA:  MOVLB  0
01FAC:  GOTO   1FB8
01FB0:  MOVLW  30
01FB2:  MOVLB  0
01FB4:  GOTO   1FC0
01FB8:  MOVLB  A
01FBA:  BCF    x3A.7
01FBC:  MOVF   x3A,W
01FBE:  MOVLB  0
01FC0:  MOVLB  A
01FC2:  ADDWF  x39,F
01FC4:  MOVFF  A39,ADB
01FC8:  MOVLB  0
01FCA:  CALL   1CE0
01FCE:  RETURN 0
*
02476:  MOVLB  A
02478:  MOVF   x9A,W
0247A:  ANDLW  07
0247C:  MOVWF  00
0247E:  RRCF   x9A,W
02480:  MOVWF  01
02482:  RRCF   01,F
02484:  RRCF   01,F
02486:  MOVLW  1F
02488:  ANDWF  01,F
0248A:  MOVF   01,W
0248C:  ADDWF  x9C,W
0248E:  MOVWF  FE9
02490:  MOVLW  00
02492:  ADDWFC x9D,W
02494:  MOVWF  FEA
02496:  CLRF   01
02498:  INCF   01,F
0249A:  INCF   00,F
0249C:  MOVLB  0
0249E:  GOTO   24A4
024A2:  RLCF   01,F
024A4:  DECFSZ 00,F
024A6:  GOTO   24A2
024AA:  MOVLB  A
024AC:  MOVF   x9B,F
024AE:  BTFSS  FD8.2
024B0:  BRA    24B8
024B2:  MOVLB  0
024B4:  GOTO   24C2
024B8:  MOVF   01,W
024BA:  IORWF  FEF,F
024BC:  MOVLB  0
024BE:  GOTO   24C8
024C2:  COMF   01,F
024C4:  MOVF   01,W
024C6:  ANDWF  FEF,F
024C8:  RETURN 0
*
028BE:  TSTFSZ 01
028C0:  GOTO   28CE
028C4:  TSTFSZ 02
028C6:  GOTO   28D0
028CA:  GOTO   28E0
028CE:  INCF   02,F
028D0:  MOVFF  00,FEE
028D4:  DECFSZ 01,F
028D6:  GOTO   28D0
028DA:  DECFSZ 02,F
028DC:  GOTO   28D0
028E0:  RETURN 0
*
0A16E:  MOVLB  3
0A170:  MOVF   x19,W
0A172:  CLRF   01
0A174:  SUBWF  x18,W
0A176:  BTFSS  FD8.0
0A178:  BRA    A180
0A17A:  MOVLB  0
0A17C:  GOTO   A18A
0A180:  MOVF   x18,W
0A182:  MOVWF  00
0A184:  MOVLB  0
0A186:  GOTO   A1B4
0A18A:  CLRF   00
0A18C:  MOVLW  08
0A18E:  MOVLB  3
0A190:  MOVWF  x1A
0A192:  MOVLB  0
0A194:  MOVLB  3
0A196:  RLCF   x18,F
0A198:  RLCF   00,F
0A19A:  MOVF   x19,W
0A19C:  SUBWF  00,W
0A19E:  BTFSC  FD8.0
0A1A0:  MOVWF  00
0A1A2:  RLCF   01,F
0A1A4:  DECFSZ x1A,F
0A1A6:  BRA    A1AC
0A1A8:  BRA    A1B2
0A1AA:  MOVLB  0
0A1AC:  MOVLB  0
0A1AE:  GOTO   A194
0A1B2:  MOVLB  0
0A1B4:  RETURN 0
0A1B6:  MOVF   01,W
0A1B8:  MOVFF  293,318
0A1BC:  MOVLW  64
0A1BE:  MOVLB  3
0A1C0:  MOVWF  x19
0A1C2:  MOVLB  0
0A1C4:  CALL   A16E
0A1C8:  MOVFF  00,293
0A1CC:  MOVF   01,W
0A1CE:  MOVLW  30
0A1D0:  BTFSS  FD8.2
0A1D2:  GOTO   A1F6
0A1D6:  MOVLB  2
0A1D8:  BTFSC  x94.1
0A1DA:  BRA    A1E2
0A1DC:  MOVLB  0
0A1DE:  GOTO   A20A
0A1E2:  BTFSS  x94.3
0A1E4:  BRA    A1EC
0A1E6:  MOVLB  0
0A1E8:  GOTO   A20A
0A1EC:  BTFSC  x94.4
0A1EE:  MOVLW  20
0A1F0:  MOVLB  0
0A1F2:  GOTO   A200
0A1F6:  MOVLB  2
0A1F8:  BCF    x94.3
0A1FA:  BCF    x94.4
0A1FC:  BSF    x94.0
0A1FE:  MOVLB  0
0A200:  ADDWF  01,F
0A202:  MOVFF  01,ADB
0A206:  CALL   1CE0
0A20A:  MOVFF  293,318
0A20E:  MOVLW  0A
0A210:  MOVLB  3
0A212:  MOVWF  x19
0A214:  MOVLB  0
0A216:  CALL   A16E
0A21A:  MOVFF  00,293
0A21E:  MOVF   01,W
0A220:  MOVLW  30
0A222:  BTFSS  FD8.2
0A224:  GOTO   A244
0A228:  MOVLB  2
0A22A:  BTFSS  x94.3
0A22C:  BRA    A234
0A22E:  MOVLB  0
0A230:  GOTO   A24E
0A234:  BTFSC  x94.0
0A236:  BRA    A23E
0A238:  MOVLB  0
0A23A:  GOTO   A24E
0A23E:  BTFSC  x94.4
0A240:  MOVLW  20
0A242:  MOVLB  0
0A244:  ADDWF  01,F
0A246:  MOVFF  01,ADB
0A24A:  CALL   1CE0
0A24E:  MOVLW  30
0A250:  MOVLB  2
0A252:  ADDWF  x93,F
0A254:  MOVFF  293,ADB
0A258:  MOVLB  0
0A25A:  CALL   1CE0
0A25E:  RETURN 0
0A260:  BTFSC  FD8.1
0A262:  GOTO   A26E
0A266:  MOVLW  02
0A268:  MOVWF  FEA
0A26A:  MOVLW  A3
0A26C:  MOVWF  FE9
0A26E:  CLRF   00
0A270:  CLRF   01
0A272:  CLRF   02
0A274:  CLRF   03
0A276:  MOVLB  2
0A278:  CLRF   xA3
0A27A:  CLRF   xA4
0A27C:  CLRF   xA5
0A27E:  CLRF   xA6
0A280:  MOVF   xA2,W
0A282:  IORWF  xA1,W
0A284:  IORWF  xA0,W
0A286:  IORWF  x9F,W
0A288:  BTFSS  FD8.2
0A28A:  BRA    A292
0A28C:  MOVLB  0
0A28E:  GOTO   A322
0A292:  MOVLB  0
0A294:  MOVLW  20
0A296:  MOVLB  2
0A298:  MOVWF  xA7
0A29A:  MOVLB  0
0A29C:  BCF    FD8.0
0A29E:  MOVLB  2
0A2A0:  RLCF   x9B,F
0A2A2:  RLCF   x9C,F
0A2A4:  RLCF   x9D,F
0A2A6:  RLCF   x9E,F
0A2A8:  RLCF   xA3,F
0A2AA:  RLCF   xA4,F
0A2AC:  RLCF   xA5,F
0A2AE:  RLCF   xA6,F
0A2B0:  MOVF   xA2,W
0A2B2:  SUBWF  xA6,W
0A2B4:  BTFSC  FD8.2
0A2B6:  BRA    A2BE
0A2B8:  MOVLB  0
0A2BA:  GOTO   A2E0
0A2BE:  MOVF   xA1,W
0A2C0:  SUBWF  xA5,W
0A2C2:  BTFSC  FD8.2
0A2C4:  BRA    A2CC
0A2C6:  MOVLB  0
0A2C8:  GOTO   A2E0
0A2CC:  MOVF   xA0,W
0A2CE:  SUBWF  xA4,W
0A2D0:  BTFSC  FD8.2
0A2D2:  BRA    A2DA
0A2D4:  MOVLB  0
0A2D6:  GOTO   A2E0
0A2DA:  MOVF   x9F,W
0A2DC:  SUBWF  xA3,W
0A2DE:  MOVLB  0
0A2E0:  BTFSS  FD8.0
0A2E2:  GOTO   A308
0A2E6:  MOVLB  2
0A2E8:  MOVF   x9F,W
0A2EA:  SUBWF  xA3,F
0A2EC:  MOVF   xA0,W
0A2EE:  BTFSS  FD8.0
0A2F0:  INCFSZ xA0,W
0A2F2:  SUBWF  xA4,F
0A2F4:  MOVF   xA1,W
0A2F6:  BTFSS  FD8.0
0A2F8:  INCFSZ xA1,W
0A2FA:  SUBWF  xA5,F
0A2FC:  MOVF   xA2,W
0A2FE:  BTFSS  FD8.0
0A300:  INCFSZ xA2,W
0A302:  SUBWF  xA6,F
0A304:  BSF    FD8.0
0A306:  MOVLB  0
0A308:  RLCF   00,F
0A30A:  RLCF   01,F
0A30C:  RLCF   02,F
0A30E:  RLCF   03,F
0A310:  MOVLB  2
0A312:  DECFSZ xA7,F
0A314:  BRA    A31A
0A316:  BRA    A320
0A318:  MOVLB  0
0A31A:  MOVLB  0
0A31C:  GOTO   A29C
0A320:  MOVLB  0
0A322:  MOVFF  2A3,FEF
0A326:  MOVFF  2A4,FEC
0A32A:  MOVFF  2A5,FEC
0A32E:  MOVFF  2A6,FEC
0A332:  MOVF   FED,F
0A334:  MOVF   FED,F
0A336:  MOVF   FED,F
0A338:  RETURN 0
0A33A:  MOVF   FE9,W
0A33C:  MOVLB  2
0A33E:  MOVWF  x93
0A340:  BTFSC  x92.7
0A342:  BRA    A34A
0A344:  MOVLB  0
0A346:  GOTO   A366
0A34A:  DECF   x93,F
0A34C:  BSF    x93.5
0A34E:  COMF   x8F,F
0A350:  COMF   x90,F
0A352:  COMF   x91,F
0A354:  COMF   x92,F
0A356:  INCF   x8F,F
0A358:  BTFSC  FD8.2
0A35A:  INCF   x90,F
0A35C:  BTFSC  FD8.2
0A35E:  INCF   x91,F
0A360:  BTFSC  FD8.2
0A362:  INCF   x92,F
0A364:  MOVLB  0
0A366:  MOVLW  3B
0A368:  MOVLB  2
0A36A:  MOVWF  x9A
0A36C:  MOVLW  9A
0A36E:  MOVWF  x99
0A370:  MOVLW  CA
0A372:  MOVWF  x98
0A374:  CLRF   x97
0A376:  MOVLW  0A
0A378:  MOVWF  x95
0A37A:  MOVLB  0
0A37C:  BSF    FD8.1
0A37E:  MOVLW  02
0A380:  MOVWF  FEA
0A382:  MOVLW  8F
0A384:  MOVWF  FE9
0A386:  MOVFF  292,29E
0A38A:  MOVFF  291,29D
0A38E:  MOVFF  290,29C
0A392:  MOVFF  28F,29B
0A396:  MOVFF  29A,2A2
0A39A:  MOVFF  299,2A1
0A39E:  MOVFF  298,2A0
0A3A2:  MOVFF  297,29F
0A3A6:  CALL   A260
0A3AA:  MOVF   01,W
0A3AC:  MOVF   00,F
0A3AE:  BTFSS  FD8.2
0A3B0:  GOTO   A408
0A3B4:  MOVLB  2
0A3B6:  MOVF   x95,W
0A3B8:  XORLW  01
0A3BA:  BTFSS  FD8.2
0A3BC:  BRA    A3C4
0A3BE:  MOVLB  0
0A3C0:  GOTO   A408
0A3C4:  MOVF   x93,W
0A3C6:  BTFSS  FD8.2
0A3C8:  BRA    A3D0
0A3CA:  MOVLB  0
0A3CC:  GOTO   A410
0A3D0:  ANDLW  0F
0A3D2:  SUBWF  x95,W
0A3D4:  BTFSS  FD8.2
0A3D6:  BRA    A3DE
0A3D8:  MOVLB  0
0A3DA:  GOTO   A3EA
0A3DE:  BTFSS  FD8.0
0A3E0:  BRA    A3E8
0A3E2:  MOVLB  0
0A3E4:  GOTO   A46E
0A3E8:  MOVLB  0
0A3EA:  MOVLB  2
0A3EC:  BTFSS  x93.7
0A3EE:  BRA    A3F6
0A3F0:  MOVLB  0
0A3F2:  GOTO   A46E
0A3F6:  BTFSS  x93.6
0A3F8:  BRA    A400
0A3FA:  MOVLB  0
0A3FC:  GOTO   A410
0A400:  MOVLW  20
0A402:  MOVLB  0
0A404:  GOTO   A464
0A408:  MOVLW  20
0A40A:  MOVLB  2
0A40C:  ANDWF  x93,F
0A40E:  MOVLB  0
0A410:  MOVLB  2
0A412:  BTFSC  x93.5
0A414:  BRA    A41C
0A416:  MOVLB  0
0A418:  GOTO   A438
0A41C:  BCF    x93.5
0A41E:  MOVF   00,W
0A420:  MOVWF  x93
0A422:  MOVLW  2D
0A424:  MOVLB  A
0A426:  MOVWF  xDB
0A428:  MOVLB  0
0A42A:  CALL   1CE0
0A42E:  MOVLB  2
0A430:  MOVF   x93,W
0A432:  MOVWF  00
0A434:  CLRF   x93
0A436:  MOVLB  0
0A438:  MOVLW  30
0A43A:  MOVLB  2
0A43C:  BTFSC  x93.5
0A43E:  BRA    A446
0A440:  MOVLB  0
0A442:  GOTO   A464
0A446:  BCF    x93.5
0A448:  MOVF   00,W
0A44A:  MOVWF  x93
0A44C:  MOVLW  2D
0A44E:  MOVLB  A
0A450:  MOVWF  xDB
0A452:  MOVLB  0
0A454:  CALL   1CE0
0A458:  MOVLB  2
0A45A:  MOVF   x93,W
0A45C:  MOVWF  00
0A45E:  CLRF   x93
0A460:  MOVLW  30
0A462:  MOVLB  0
0A464:  ADDWF  00,F
0A466:  MOVFF  00,ADB
0A46A:  CALL   1CE0
0A46E:  BCF    FD8.1
0A470:  MOVFF  29A,29E
0A474:  MOVFF  299,29D
0A478:  MOVFF  298,29C
0A47C:  MOVFF  297,29B
0A480:  MOVLB  2
0A482:  CLRF   xA2
0A484:  CLRF   xA1
0A486:  CLRF   xA0
0A488:  MOVLW  0A
0A48A:  MOVWF  x9F
0A48C:  MOVLB  0
0A48E:  CALL   A260
0A492:  MOVFF  03,29A
0A496:  MOVFF  02,299
0A49A:  MOVFF  01,298
0A49E:  MOVFF  00,297
0A4A2:  MOVLB  2
0A4A4:  DECFSZ x95,F
0A4A6:  BRA    A4AC
0A4A8:  BRA    A4B2
0A4AA:  MOVLB  0
0A4AC:  MOVLB  0
0A4AE:  GOTO   A37C
0A4B2:  MOVLB  0
0A4B4:  RETURN 0
*
0A8C8:  MOVLW  20
0A8CA:  MOVLB  3
0A8CC:  BTFSS  x13.4
0A8CE:  MOVLW  30
0A8D0:  MOVWF  x14
0A8D2:  MOVFF  312,00
0A8D6:  BTFSC  00.7
0A8D8:  BRA    A8E0
0A8DA:  MOVLB  0
0A8DC:  GOTO   A8F2
0A8E0:  COMF   00,F
0A8E2:  INCF   00,F
0A8E4:  MOVFF  00,312
0A8E8:  MOVLW  2D
0A8EA:  MOVWF  x14
0A8EC:  BSF    x13.7
0A8EE:  BSF    x13.0
0A8F0:  MOVLB  0
0A8F2:  MOVF   01,W
0A8F4:  MOVFF  312,318
0A8F8:  MOVLW  64
0A8FA:  MOVLB  3
0A8FC:  MOVWF  x19
0A8FE:  MOVLB  0
0A900:  CALL   A16E
0A904:  MOVFF  00,312
0A908:  MOVLW  30
0A90A:  ADDWF  01,W
0A90C:  MOVLB  3
0A90E:  MOVWF  x15
0A910:  MOVFF  312,318
0A914:  MOVLW  0A
0A916:  MOVWF  x19
0A918:  MOVLB  0
0A91A:  CALL   A16E
0A91E:  MOVLW  30
0A920:  ADDWF  00,W
0A922:  MOVLB  3
0A924:  MOVWF  x17
0A926:  MOVLW  30
0A928:  ADDWF  01,W
0A92A:  MOVWF  x16
0A92C:  MOVFF  314,00
0A930:  MOVLB  0
0A932:  MOVLW  30
0A934:  MOVLB  3
0A936:  SUBWF  x15,W
0A938:  BTFSS  FD8.2
0A93A:  BRA    A942
0A93C:  MOVLB  0
0A93E:  GOTO   A94E
0A942:  BSF    x13.1
0A944:  BTFSC  x13.7
0A946:  BSF    x13.2
0A948:  MOVLB  0
0A94A:  GOTO   A98E
0A94E:  MOVFF  314,315
0A952:  MOVLW  20
0A954:  MOVLB  3
0A956:  MOVWF  x14
0A958:  MOVLW  30
0A95A:  SUBWF  x16,W
0A95C:  BTFSS  FD8.2
0A95E:  BRA    A966
0A960:  MOVLB  0
0A962:  GOTO   A972
0A966:  BSF    x13.0
0A968:  BTFSC  x13.7
0A96A:  BSF    x13.1
0A96C:  MOVLB  0
0A96E:  GOTO   A98E
0A972:  BTFSC  FD8.2
0A974:  BRA    A97C
0A976:  MOVLB  3
0A978:  BSF    x13.0
0A97A:  MOVLB  0
0A97C:  BTFSS  FD8.2
0A97E:  GOTO   A98E
0A982:  MOVFF  315,316
0A986:  MOVLW  20
0A988:  MOVLB  3
0A98A:  MOVWF  x15
0A98C:  MOVLB  0
0A98E:  MOVLB  3
0A990:  BTFSS  x13.2
0A992:  BRA    A99A
0A994:  MOVLB  0
0A996:  GOTO   A9B4
0A99A:  BTFSS  x13.1
0A99C:  BRA    A9A4
0A99E:  MOVLB  0
0A9A0:  GOTO   A9BC
0A9A4:  BTFSS  x13.0
0A9A6:  BRA    A9AE
0A9A8:  MOVLB  0
0A9AA:  GOTO   A9C4
0A9AE:  MOVLB  0
0A9B0:  GOTO   A9CC
0A9B4:  MOVFF  314,ADB
0A9B8:  CALL   1CE0
0A9BC:  MOVFF  315,ADB
0A9C0:  CALL   1CE0
0A9C4:  MOVFF  316,ADB
0A9C8:  CALL   1CE0
0A9CC:  MOVFF  317,ADB
0A9D0:  CALL   1CE0
0A9D4:  RETURN 0
*
0B580:  MOVF   FE9,W
0B582:  MOVLB  2
0B584:  MOVWF  x18
0B586:  MOVLW  3B
0B588:  MOVWF  x1F
0B58A:  MOVLW  9A
0B58C:  MOVWF  x1E
0B58E:  MOVLW  CA
0B590:  MOVWF  x1D
0B592:  CLRF   x1C
0B594:  MOVLW  0A
0B596:  MOVWF  x1A
0B598:  MOVLB  0
0B59A:  BSF    FD8.1
0B59C:  MOVLW  02
0B59E:  MOVWF  FEA
0B5A0:  MOVLW  14
0B5A2:  MOVWF  FE9
0B5A4:  MOVFF  217,29E
0B5A8:  MOVFF  216,29D
0B5AC:  MOVFF  215,29C
0B5B0:  MOVFF  214,29B
0B5B4:  MOVFF  21F,2A2
0B5B8:  MOVFF  21E,2A1
0B5BC:  MOVFF  21D,2A0
0B5C0:  MOVFF  21C,29F
0B5C4:  CALL   A260
0B5C8:  MOVF   01,W
0B5CA:  MOVF   00,F
0B5CC:  BTFSS  FD8.2
0B5CE:  GOTO   B626
0B5D2:  MOVLB  2
0B5D4:  MOVF   x1A,W
0B5D6:  XORLW  01
0B5D8:  BTFSS  FD8.2
0B5DA:  BRA    B5E2
0B5DC:  MOVLB  0
0B5DE:  GOTO   B626
0B5E2:  MOVF   x18,W
0B5E4:  BTFSS  FD8.2
0B5E6:  BRA    B5EE
0B5E8:  MOVLB  0
0B5EA:  GOTO   B62C
0B5EE:  ANDLW  0F
0B5F0:  SUBWF  x1A,W
0B5F2:  BTFSS  FD8.2
0B5F4:  BRA    B5FC
0B5F6:  MOVLB  0
0B5F8:  GOTO   B608
0B5FC:  BTFSS  FD8.0
0B5FE:  BRA    B606
0B600:  MOVLB  0
0B602:  GOTO   B638
0B606:  MOVLB  0
0B608:  MOVLB  2
0B60A:  BTFSS  x18.7
0B60C:  BRA    B614
0B60E:  MOVLB  0
0B610:  GOTO   B638
0B614:  BTFSS  x18.6
0B616:  BRA    B61E
0B618:  MOVLB  0
0B61A:  GOTO   B62C
0B61E:  MOVLW  20
0B620:  MOVLB  0
0B622:  GOTO   B62E
0B626:  MOVLB  2
0B628:  CLRF   x18
0B62A:  MOVLB  0
0B62C:  MOVLW  30
0B62E:  ADDWF  00,F
0B630:  MOVFF  00,ADB
0B634:  CALL   1CE0
0B638:  BCF    FD8.1
0B63A:  MOVFF  21F,29E
0B63E:  MOVFF  21E,29D
0B642:  MOVFF  21D,29C
0B646:  MOVFF  21C,29B
0B64A:  MOVLB  2
0B64C:  CLRF   xA2
0B64E:  CLRF   xA1
0B650:  CLRF   xA0
0B652:  MOVLW  0A
0B654:  MOVWF  x9F
0B656:  MOVLB  0
0B658:  CALL   A260
0B65C:  MOVFF  03,21F
0B660:  MOVFF  02,21E
0B664:  MOVFF  01,21D
0B668:  MOVFF  00,21C
0B66C:  MOVLB  2
0B66E:  DECFSZ x1A,F
0B670:  BRA    B676
0B672:  BRA    B67C
0B674:  MOVLB  0
0B676:  MOVLB  0
0B678:  GOTO   B59A
0B67C:  MOVLB  0
0B67E:  RETURN 0
.................... 
.................... #list
.................... 
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
*
01CB2:  MOVLW  0A
01CB4:  MOVWF  FEA
01CB6:  MOVLW  94
01CB8:  MOVWF  FE9
01CBA:  MOVF   FEF,W
01CBC:  BTFSC  FD8.2
01CBE:  GOTO   1CDE
01CC2:  MOVLW  05
01CC4:  MOVWF  01
01CC6:  CLRF   00
01CC8:  DECFSZ 00,F
01CCA:  BRA    1CC8
01CCC:  DECFSZ 01,F
01CCE:  BRA    1CC6
01CD0:  MOVLW  2E
01CD2:  MOVWF  00
01CD4:  DECFSZ 00,F
01CD6:  BRA    1CD4
01CD8:  BRA    1CDA
01CDA:  DECFSZ FEF,F
01CDC:  BRA    1CC2
01CDE:  RETURN 0
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
*
001B6:  BTFSS  FA6.5
001B8:  GOTO   01B6
001BC:  MOVLB  F
001BE:  MOVF   x2F,W
001C0:  MOVWF  1B
001C2:  MOVLB  0
001C4:  MOVLB  F
001C6:  MOVF   x2A,W
001C8:  MOVWF  01
001CA:  BTFSC  1B.1
001CC:  BRA    01D4
001CE:  MOVLB  0
001D0:  GOTO   01D8
001D4:  BCF    x2F.4
001D6:  BSF    x2F.4
001D8:  MOVLB  0
001DA:  GOTO   0214 (RETURN)
*
052F0:  BTFSS  FA6.4
052F2:  GOTO   52F0
052F6:  MOVLB  F
052F8:  MOVWF  x29
052FA:  MOVLB  0
052FC:  GOTO   5332 (RETURN)
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
*
01CE0:  BCF    F93.6
01CE2:  BCF    F8A.6
01CE4:  MOVLW  08
01CE6:  MOVWF  01
01CE8:  BRA    1CEA
01CEA:  NOP   
01CEC:  BSF    01.7
01CEE:  GOTO   1D16
01CF2:  BCF    01.7
01CF4:  MOVLB  A
01CF6:  RRCF   xDB,F
01CF8:  MOVLB  0
01CFA:  BTFSC  FD8.0
01CFC:  BSF    F8A.6
01CFE:  BTFSS  FD8.0
01D00:  BCF    F8A.6
01D02:  BSF    01.6
01D04:  GOTO   1D16
01D08:  BCF    01.6
01D0A:  DECFSZ 01,F
01D0C:  GOTO   1CF4
01D10:  BRA    1D12
01D12:  NOP   
01D14:  BSF    F8A.6
01D16:  MOVLW  84
01D18:  MOVWF  FE9
01D1A:  DECFSZ FE9,F
01D1C:  GOTO   1D1A
01D20:  BRA    1D22
01D22:  NOP   
01D24:  BTFSC  01.7
01D26:  GOTO   1CF2
01D2A:  BTFSC  01.6
01D2C:  GOTO   1D08
01D30:  RETURN 0
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
*
02546:  MOVLB  A
02548:  MOVF   xB7,W
0254A:  SUBLW  08
0254C:  BTFSS  FD8.2
0254E:  BRA    2556
02550:  MOVLB  0
02552:  GOTO   256E
02556:  MOVWF  xB9
02558:  MOVLB  0
0255A:  MOVLB  A
0255C:  RLCF   xB6,F
0255E:  DECFSZ xB9,F
02560:  BRA    2566
02562:  BRA    256C
02564:  MOVLB  0
02566:  MOVLB  0
02568:  GOTO   255A
0256C:  MOVLB  0
0256E:  BSF    F92.1
02570:  BCF    F92.0
02572:  BCF    F92.3
02574:  BCF    F89.3
02576:  MOVFF  AB7,AB9
0257A:  MOVLB  A
0257C:  BTFSS  xB6.7
0257E:  BCF    F89.0
02580:  BTFSC  xB6.7
02582:  BSF    F89.0
02584:  RLCF   xB6,F
02586:  BSF    F89.3
02588:  MOVLW  02
0258A:  MOVWF  xBA
0258C:  MOVLB  0
0258E:  MOVLB  A
02590:  DECFSZ xBA,F
02592:  BRA    2598
02594:  BRA    259E
02596:  MOVLB  0
02598:  MOVLB  0
0259A:  GOTO   258E
0259E:  RLCF   01,F
025A0:  BTFSS  F80.1
025A2:  BCF    01.0
025A4:  BTFSC  F80.1
025A6:  BSF    01.0
025A8:  BCF    F89.3
025AA:  MOVLB  0
025AC:  BRA    25AE
025AE:  MOVLB  A
025B0:  DECFSZ xB9,F
025B2:  BRA    25B8
025B4:  BRA    25BE
025B6:  MOVLB  0
025B8:  MOVLB  0
025BA:  GOTO   257A
025BE:  MOVLB  0
025C0:  RETURN 0
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
*
024CA:  MOVLB  A
024CC:  MOVF   xB7,W
024CE:  SUBLW  08
024D0:  BTFSS  FD8.2
024D2:  BRA    24DA
024D4:  MOVLB  0
024D6:  GOTO   24F2
024DA:  MOVWF  xB9
024DC:  MOVLB  0
024DE:  MOVLB  A
024E0:  RLCF   xB6,F
024E2:  DECFSZ xB9,F
024E4:  BRA    24EA
024E6:  BRA    24F0
024E8:  MOVLB  0
024EA:  MOVLB  0
024EC:  GOTO   24DE
024F0:  MOVLB  0
024F2:  BSF    F96.0
024F4:  BCF    F96.6
024F6:  BCF    F96.1
024F8:  BCF    F8D.1
024FA:  MOVFF  AB7,AB9
024FE:  MOVLB  A
02500:  BTFSS  xB6.7
02502:  BCF    F8D.6
02504:  BTFSC  xB6.7
02506:  BSF    F8D.6
02508:  RLCF   xB6,F
0250A:  BSF    F8D.1
0250C:  MOVLW  02
0250E:  MOVWF  xBA
02510:  MOVLB  0
02512:  MOVLB  A
02514:  DECFSZ xBA,F
02516:  BRA    251C
02518:  BRA    2522
0251A:  MOVLB  0
0251C:  MOVLB  0
0251E:  GOTO   2512
02522:  RLCF   01,F
02524:  BTFSS  F84.0
02526:  BCF    01.0
02528:  BTFSC  F84.0
0252A:  BSF    01.0
0252C:  BCF    F8D.1
0252E:  MOVLB  0
02530:  BRA    2532
02532:  MOVLB  A
02534:  DECFSZ xB9,F
02536:  BRA    253C
02538:  BRA    2542
0253A:  MOVLB  0
0253C:  MOVLB  0
0253E:  GOTO   24FE
02542:  MOVLB  0
02544:  RETURN 0
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
*
01E6E:  MOVLB  9
01E70:  MOVF   xFB,W
01E72:  SUBLW  10
01E74:  BTFSS  FD8.2
01E76:  BRA    1E7E
01E78:  MOVLB  0
01E7A:  GOTO   1E98
01E7E:  MOVWF  xFD
01E80:  MOVLB  0
01E82:  MOVLB  9
01E84:  RLCF   xF9,F
01E86:  RLCF   xFA,F
01E88:  DECFSZ xFD,F
01E8A:  BRA    1E90
01E8C:  BRA    1E96
01E8E:  MOVLB  0
01E90:  MOVLB  0
01E92:  GOTO   1E82
01E96:  MOVLB  0
01E98:  BSF    F93.4
01E9A:  BCF    F93.5
01E9C:  BCF    F93.2
01E9E:  BSF    F8A.2
01EA0:  MOVFF  9FB,9FD
01EA4:  MOVLB  9
01EA6:  BTFSS  xFA.7
01EA8:  BCF    F8A.5
01EAA:  BTFSC  xFA.7
01EAC:  BSF    F8A.5
01EAE:  RLCF   xF9,F
01EB0:  RLCF   xFA,F
01EB2:  BCF    F8A.2
01EB4:  RLCF   01,F
01EB6:  RLCF   02,F
01EB8:  BTFSS  F81.4
01EBA:  BCF    01.0
01EBC:  BTFSC  F81.4
01EBE:  BSF    01.0
01EC0:  BSF    F8A.2
01EC2:  DECFSZ xFD,F
01EC4:  BRA    1ECA
01EC6:  BRA    1ED0
01EC8:  MOVLB  0
01ECA:  MOVLB  0
01ECC:  GOTO   1EA4
01ED0:  MOVLB  0
01ED2:  RETURN 0
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル2: ハードウェア抽象化層  
.................... #include "hal/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "hal/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA3
.................... static void boss_receive_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "hal/gpio.h"
.................... #ifndef GPIO_H
.................... #define GPIO_H
.................... 
.................... void gpio_init();
.................... void enable_negative_power();
.................... void disable_negative_power();
.................... void connect_port1();
.................... void disconnect_port1();
.................... void connect_port2();
.................... void disconnect_port2();
.................... 
.................... #endif // GPIO_H
.................... 
.................... #include "device_driver/ad7490_driver.h"
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "device_driver/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル3: 基本ライブラリヘッダー（型定義・通信・ツール）
.................... #include "../lib/communication/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../lib/tool/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/tool/mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... // レベル4: デバイスドライバヘッダー
.................... #include "../lib/device/mt25q.h"
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/device/ad7490.h"
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mcp4901.h"
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... // レベル5: 通信ライブラリヘッダー
.................... #include "../lib/communication/communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x03,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define GS        0x00
.................... #define MAIN_PIC  0x01
.................... #define COM_PIC   0x02
.................... #define RESET_PIC 0x03
.................... #define FAB_PIC   0x04
.................... #define BOSS_PIC  0x05
.................... #define APRS_PIC  0x06
.................... #define CAM_MCU   0x07
.................... #define CHO_MCU   0x08
.................... #define NAKA_PIC  0x09
.................... #define SATO_PIC  0x0A
.................... #define BHU_MCU   0x0B
.................... #define CIGS_PIC  0x0C
.................... 
....................  // <- change to your device name
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 9
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 size;
....................     int1 is_exist;
....................     unsigned int8 content[CONTENT_MAX];
.................... } Command;
.................... 
.................... #include "frame.h"
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // レベル6: コア機能ヘッダー
.................... #include "domain/mmj_cigs_iv.h"
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "domain/mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "../hal/mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "domain/mmj_cigs_piclog.h"
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // レベル7: アプリケーションヘッダー
.................... #include "application/mmj_cigs_excute_mission.h"
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../lib/communication/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "application/mmj_cigs_mode_mission.h"
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_test(unsigned int8 *uplinkcmd);
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... #define ID_MEAS_DEBUG 0xA6
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef union {
....................     unsigned int8 raw;
....................     struct {
....................         unsigned int8 mission_continue : 1;
....................         unsigned int8 erase_and_save : 1;
....................         unsigned int8 reserved : 6;
....................     } flag;
.................... } mission_state_t;
.................... 
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     mission_state_t mission_state; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "application/mmj_cigs_mode_flash.h"
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... //==============================================================================
.................... // .cファイル統合（CCS C単一コンパイル単位）
.................... //==============================================================================
.................... 
.................... // ハードウェア層実装ファイル
.................... // 実装は各 .c からビルドするためヘッダーでの取り込みは不要。必要なら下記のように直下参照に修正。
.................... #include "hal/timer.c"
.................... #include "timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #INT_TIMER1
.................... void TIMER1_isr()
.................... {
....................    set_timer1(TIMER_ISR_10MSEC); 
*
00174:  MOVLW  FE
00176:  MOVWF  FCF
00178:  MOVLW  A8
0017A:  MOVWF  FCE
0017C:  NOP   
....................    add_current_msec(10);
0017E:  MOVLB  A
00180:  CLRF   xEC
00182:  CLRF   xEB
00184:  CLRF   xEA
00186:  MOVLW  0A
00188:  MOVWF  xE9
0018A:  MOVLB  0
0018C:  GOTO   013E
00190:  BCF    F9E.0
00192:  GOTO   0074
.................... }
.................... 
.................... void timer_init()
.................... {
....................    fprintf(PC, "Timer Initialize\r\n");
*
01DC2:  MOVLW  96
01DC4:  MOVWF  FF6
01DC6:  MOVLW  01
01DC8:  MOVWF  FF7
01DCA:  MOVLW  00
01DCC:  MOVWF  FF8
01DCE:  CALL   1D32
....................    clear_interrupt(INT_TIMER1);
01DD2:  BCF    F9E.0
....................    setup_timer_1(T1_EXTERNAL | T1_DIV_BY_1 | T1_ENABLE_SOSC);
01DD4:  MOVLW  8F
01DD6:  MOVWF  FCD
01DD8:  CLRF   FAA
....................    set_timer1((2 ^ 16) - CLOCK_FREQUENCY); 
01DDA:  MOVLW  80
01DDC:  MOVWF  FCF
01DDE:  MOVLW  12
01DE0:  MOVWF  FCE
01DE2:  NOP   
....................    enable_interrupts(INT_TIMER1);   
01DE4:  BSF    F9D.0
....................    enable_interrupts(GLOBAL);
01DE6:  MOVLW  C0
01DE8:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01DEA:  MOVLW  AA
01DEC:  MOVWF  FF6
01DEE:  MOVLW  01
01DF0:  MOVWF  FF7
01DF2:  MOVLW  00
01DF4:  MOVWF  FF8
01DF6:  CALL   1D32
01DFA:  GOTO   C71C (RETURN)
.................... }
.................... 
.................... void set_current_sec(unsigned int32 new_sec)
.................... {
....................    sec = new_sec;
.................... }
.................... 
.................... 
.................... unsigned int32 get_current_sec()
.................... {
....................    return sec;
*
03C66:  MOVFF  20,00
03C6A:  MOVFF  21,01
03C6E:  MOVFF  22,02
03C72:  MOVFF  23,03
03C76:  RETURN 0
.................... }
.................... 
.................... unsigned int16 get_current_msec()
.................... {
....................    // Assuming subsec is in deci-seconds (0.01 sec)
....................    return (subsec / 10); // Convert deci-seconds to milliseconds
.................... }
.................... 
.................... unsigned int16 get_current_day()
.................... {
....................    return day;
.................... }
.................... 
.................... 
.................... void add_current_msec(unsigned int32 msec)
.................... {
....................    subsec += (msec * 10); // Convert milliseconds to deci-seconds
*
0013E:  MOVFF  AEC,AF0
00142:  MOVFF  AEB,AEF
00146:  MOVFF  AEA,AEE
0014A:  MOVFF  AE9,AED
0014E:  MOVLB  A
00150:  CLRF   xF4
00152:  CLRF   xF3
00154:  CLRF   xF2
00156:  MOVLW  0A
00158:  MOVWF  xF1
0015A:  MOVLB  0
0015C:  GOTO   00CA
00160:  MOVF   00,W
00162:  ADDWF  1C,F
00164:  MOVF   01,W
00166:  ADDWFC 1D,F
00168:  MOVF   02,W
0016A:  ADDWFC 1E,F
0016C:  MOVF   03,W
0016E:  ADDWFC 1F,F
00170:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... #include "hal/uart.c"
.................... #include "uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA3
.................... static void boss_receive_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #INT_RDA3
.................... static void boss_receive_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
001DE:  GOTO   01E2
001E2:  GOTO   01EC
001E6:  BTFSS  47.0
001E8:  GOTO   0220
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
001EC:  MOVF   46,W
001EE:  SUBLW  1F
001F0:  BTFSS  FD8.0
001F2:  GOTO   0220
....................          boss_receive_buffer[boss_receive_buffer_size++ % RECEIVE_BUFFER_MAX] = fgetc(BOSS);
001F6:  MOVF   46,W
001F8:  INCF   46,F
001FA:  ANDLW  1F
001FC:  CLRF   03
001FE:  ADDLW  26
00200:  MOVWF  FE9
00202:  MOVLW  00
00204:  ADDWFC 03,W
00206:  MOVWF  FEA
00208:  MOVFF  FEA,AEC
0020C:  MOVFF  FE9,AEB
00210:  GOTO   01B6
00214:  MOVFF  AEC,FEA
00218:  MOVFF  AEB,FE9
0021C:  MOVF   01,W
0021E:  MOVWF  FEF
00220:  BCF    FA6.5
00222:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    fprintf(PC, "UART Initialize\r\n");
*
01D98:  MOVLW  26
01D9A:  MOVWF  FF6
01D9C:  MOVLW  02
01D9E:  MOVWF  FF7
01DA0:  MOVLW  00
01DA2:  MOVWF  FF8
01DA4:  CALL   1D32
....................    enable_interrupts(INT_RDA3);
01DA8:  BSF    F61.5
....................    enable_interrupts(GLOBAL);
01DAA:  MOVLW  C0
01DAC:  IORWF  FF2,F
....................    fprintf(PC, "\tComplete\r\n");
01DAE:  MOVLW  38
01DB0:  MOVWF  FF6
01DB2:  MOVLW  02
01DB4:  MOVWF  FF7
01DB6:  MOVLW  00
01DB8:  MOVWF  FF8
01DBA:  CALL   1D32
01DBE:  GOTO   C718 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
052B2:  MOVFF  1B6,03
052B6:  MOVLB  1
052B8:  MOVF   xB5,W
052BA:  MOVWF  FE9
052BC:  MOVFF  03,FEA
052C0:  MOVFF  FEF,1B7
052C4:  MOVFF  1B4,FEA
052C8:  MOVFF  1B3,FE9
052CC:  CLRF   00
052CE:  CLRF   02
052D0:  MOVFF  1B7,01
052D4:  MOVLB  0
052D6:  CALL   28BE
....................    *receive_signal_size = 0;
052DA:  MOVFF  1B6,03
052DE:  MOVLB  1
052E0:  MOVF   xB5,W
052E2:  MOVWF  FE9
052E4:  MOVFF  03,FEA
052E8:  CLRF   FEF
052EA:  MOVLB  0
052EC:  GOTO   C7BE (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "hal/gpio.c"
.................... #include "mmj_cigs_config.h"
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "gpio.h"
.................... #ifndef GPIO_H
.................... #define GPIO_H
.................... 
.................... void gpio_init();
.................... void enable_negative_power();
.................... void disable_negative_power();
.................... void connect_port1();
.................... void disconnect_port1();
.................... void connect_port2();
.................... void disconnect_port2();
.................... 
.................... #endif // GPIO_H
.................... 
.................... 
.................... void gpio_init() {
....................     enable_negative_power();
....................     disconnect_port1();
....................     disconnect_port2();
.................... }
.................... 
.................... void enable_negative_power() {
....................     output_high(EN_NPWR);
.................... }
.................... 
.................... void disable_negative_power() {
....................     output_low(EN_NPWR);
.................... }
.................... 
.................... void connect_port1(){
....................     output_high(CONNECT_CIGS1);
*
07454:  MOVLW  5E
07456:  MOVWF  F94
07458:  BSF    F8B.0
0745A:  GOTO   7E9C (RETURN)
.................... }
.................... 
.................... void disconnect_port1(){
....................     output_low(CONNECT_CIGS1);
.................... }
.................... 
.................... void connect_port2(){
....................     output_high(CONNECT_CIGS2);
0745E:  MOVLW  5E
07460:  MOVWF  F94
07462:  BSF    F8B.5
07464:  GOTO   7EA0 (RETURN)
.................... }
.................... 
.................... void disconnect_port2(){
....................     output_low(CONNECT_CIGS2);
.................... }
.................... 
.................... 
.................... #include "device_driver/ad7490_driver.c"
.................... #include "ad7490_driver.h"                          // 同じデバイスフォルダのヘッダー
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/ad7490.h"               // ADCデバイスライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... 
.................... void ad7490_init()
.................... {
....................     fprintf(PC, "AD7490 Initialize\r\n");
*
01FD0:  MOVLW  44
01FD2:  MOVWF  FF6
01FD4:  MOVLW  02
01FD6:  MOVWF  FF7
01FD8:  MOVLW  00
01FDA:  MOVWF  FF8
01FDC:  CALL   1D32
....................     output_high(ADC_CS); 
01FE0:  MOVLW  F4
01FE2:  MOVWF  F93
01FE4:  BSF    F8A.1
....................     delay_ms(10); 
01FE6:  MOVLW  0A
01FE8:  MOVLB  A
01FEA:  MOVWF  x94
01FEC:  MOVLB  0
01FEE:  CALL   1CB2
....................     unsigned int16 readdata = ad7490_read(ADC_CIGS2_CURR);
01FF2:  MOVLW  05
01FF4:  MOVLB  9
01FF6:  MOVWF  xF2
01FF8:  MOVLB  0
01FFA:  CALL   1ED4
01FFE:  MOVFF  02,1B4
02002:  MOVFF  01,1B3
....................     delay_ms(1);
02006:  MOVLW  01
02008:  MOVLB  A
0200A:  MOVWF  x94
0200C:  MOVLB  0
0200E:  CALL   1CB2
....................     fprintf(PC, "\t%04LX\r\n", readdata);
02012:  MOVLW  09
02014:  MOVLB  A
02016:  MOVWF  xDB
02018:  MOVLB  0
0201A:  CALL   1CE0
0201E:  MOVFF  1B4,A39
02022:  MOVLW  37
02024:  MOVLB  A
02026:  MOVWF  x3A
02028:  MOVLB  0
0202A:  CALL   1F60
0202E:  MOVFF  1B3,A39
02032:  MOVLW  37
02034:  MOVLB  A
02036:  MOVWF  x3A
02038:  MOVLB  0
0203A:  CALL   1F60
0203E:  MOVLW  0D
02040:  MOVLB  A
02042:  MOVWF  xDB
02044:  MOVLB  0
02046:  CALL   1CE0
0204A:  MOVLW  0A
0204C:  MOVLB  A
0204E:  MOVWF  xDB
02050:  MOVLB  0
02052:  CALL   1CE0
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
02056:  MOVLB  1
02058:  INCFSZ xB3,W
0205A:  BRA    2060
0205C:  BRA    2066
0205E:  MOVLB  0
02060:  MOVLB  0
02062:  GOTO   207E
02066:  MOVLB  0
02068:  MOVLB  1
0206A:  INCFSZ xB4,W
0206C:  BRA    2072
0206E:  BRA    2078
02070:  MOVLB  0
02072:  MOVLB  0
02074:  GOTO   207E
02078:  MOVLB  0
0207A:  GOTO   209E
0207E:  MOVLB  1
02080:  MOVF   xB3,F
02082:  BTFSC  FD8.2
02084:  BRA    208C
02086:  MOVLB  0
02088:  GOTO   20B2
0208C:  MOVLB  0
0208E:  MOVLB  1
02090:  MOVF   xB4,F
02092:  BTFSC  FD8.2
02094:  BRA    209C
02096:  MOVLB  0
02098:  GOTO   20B2
0209C:  MOVLB  0
....................         fprintf(PC, "\tConnect error!\r\n");
0209E:  MOVLW  58
020A0:  MOVWF  FF6
020A2:  MOVLW  02
020A4:  MOVWF  FF7
020A6:  MOVLW  00
020A8:  MOVWF  FF8
020AA:  CALL   1D32
....................     } else {
020AE:  GOTO   20C2
....................         fprintf(PC, "\tConnect successful\r\n");
020B2:  MOVLW  6A
020B4:  MOVWF  FF6
020B6:  MOVLW  02
020B8:  MOVWF  FF7
020BA:  MOVLW  00
020BC:  MOVWF  FF8
020BE:  CALL   1D32
....................     }
....................     fprintf(PC, "\tComplete\r\n");
020C2:  MOVLW  80
020C4:  MOVWF  FF6
020C6:  MOVLW  02
020C8:  MOVWF  FF7
020CA:  MOVLW  00
020CC:  MOVWF  FF8
020CE:  CALL   1D32
020D2:  GOTO   C720 (RETURN)
.................... }
.................... 
.................... unsigned int16 ad7490_read(int8 channel)
*
01ED4:  MOVFF  9F2,9F9
01ED8:  GOTO   1DFE
01EDC:  MOVFF  02,9F4
01EE0:  MOVFF  01,9F3
.................... {   
....................     unsigned int16 cmd = ad7490_make_cmd(channel);
....................     
....................     output_low(ADC_CS); 
01EE4:  MOVLW  F4
01EE6:  MOVWF  F93
01EE8:  BCF    F8A.1
....................     delay_us(10); 
01EEA:  MOVLW  0D
01EEC:  MOVWF  00
01EEE:  DECFSZ 00,F
01EF0:  BRA    1EEE
....................     spi_xfer(ADC_STREAM, cmd); 
01EF2:  MOVFF  9F4,9FA
01EF6:  MOVFF  9F3,9F9
01EFA:  MOVLW  10
01EFC:  MOVLB  9
01EFE:  MOVWF  xFB
01F00:  MOVLW  01
01F02:  MOVWF  xFC
01F04:  MOVLB  0
01F06:  CALL   1E6E
....................     #ifdef AD7490_DEBUG
....................        fprintf(PC,"\t[ADC] <<< %04LX\r\n", cmd);
....................     #endif
....................     output_high(ADC_CS); 
01F0A:  MOVLW  F4
01F0C:  MOVWF  F93
01F0E:  BSF    F8A.1
....................     delay_us(10);
01F10:  MOVLW  0D
01F12:  MOVWF  00
01F14:  DECFSZ 00,F
01F16:  BRA    1F14
.................... 
....................     // Read the ADC data
....................     output_low(ADC_CS); 
01F18:  MOVLW  F4
01F1A:  MOVWF  F93
01F1C:  BCF    F8A.1
....................     delay_us(10);
01F1E:  MOVLW  0D
01F20:  MOVWF  00
01F22:  DECFSZ 00,F
01F24:  BRA    1F22
....................     unsigned int16 ans = spi_xfer(ADC_STREAM, 0x0000);
01F26:  MOVLB  9
01F28:  CLRF   xFA
01F2A:  CLRF   xF9
01F2C:  MOVLW  10
01F2E:  MOVWF  xFB
01F30:  MOVLW  01
01F32:  MOVWF  xFC
01F34:  MOVLB  0
01F36:  CALL   1E6E
01F3A:  MOVFF  02,9F6
01F3E:  MOVFF  01,9F5
....................     output_high(ADC_CS); 
01F42:  MOVLW  F4
01F44:  MOVWF  F93
01F46:  BSF    F8A.1
....................     unsigned int16 readdata = ans & 0x0FFF; //Conver LSB <--> MSB
01F48:  MOVLB  9
01F4A:  MOVF   xF5,W
01F4C:  MOVWF  xF7
01F4E:  MOVF   xF6,W
01F50:  ANDLW  0F
01F52:  MOVWF  xF8
....................     
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC,"\t[ADC] >>> %04LX\r\n", readdata);
....................     #endif
....................     return readdata;
01F54:  MOVF   xF7,W
01F56:  MOVWF  01
01F58:  MOVF   xF8,W
01F5A:  MOVWF  02
01F5C:  MOVLB  0
01F5E:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "device_driver/mcp4901_driver.c"
.................... #include "mcp4901_driver.h"                        
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mcp4901.h"       
.................... // ===================== mcp4911.h =====================
.................... #ifndef _MCP4901_H_
.................... #define _MCP4901_H_
.................... 
.................... typedef union {
....................    unsigned int16 value; // 16-bit value to write to the DAC
....................    struct {
....................       int1 reserved4; // Reserved bit, should be 0
....................       int1 reserved3; // Reserved bit, should be 0
....................       int1 reserved2; // Reserved bit, should be 0
....................       int1 reserved; // Reserved bit, should be 0
....................       int1 data0; // LSB of the data
....................       int1 data1; // 8-bit data to write to the DAC
....................       int1 data2; // 8-bit data to write to the DAC
....................       int1 data3; // 8-bit data to write to the DAC
....................       int1 data4; // 8-bit data to write to the DAC
....................       int1 data5; // 8-bit data to write to the DAC
....................       int1 data6; // 8-bit data to write to the DAC
....................       int1 data7; // 8-bit data to write to the DAC
....................       int1 shutdown; // 1: Shutdown mode, 0: Normal operation
....................       int1 gain; // 1: Gain 2x, 0: Gain 1x
....................       int1 buffer; // Buffer not used, should be 0
....................       int1 startbit; // Start bit, should be 1
....................    } fields;
.................... } mcp4901_cmd_t;
.................... 
.................... 
.................... // ---------------------- Public API --------------------------
.................... void mcp4911_init();
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value);
.................... 
.................... #endif /* _MCP4911_H_ */
.................... // ===================== mcp4911.h =====================
.................... 
.................... 
.................... void mcp4901_init()
.................... {
....................     fprintf(PC, "MCP4901 Initialize\r\n");
*
022AE:  MOVLW  8C
022B0:  MOVWF  FF6
022B2:  MOVLW  02
022B4:  MOVWF  FF7
022B6:  MOVLW  00
022B8:  MOVWF  FF8
022BA:  CALL   1D32
....................     output_high(DAC1_CS); 
022BE:  MOVLW  F4
022C0:  MOVWF  F93
022C2:  BSF    F8A.3
....................     output_high(DAC2_CS); 
022C4:  MOVLW  F4
022C6:  MOVWF  F93
022C8:  BSF    F8A.0
....................     delay_ms(10); 
022CA:  MOVLW  0A
022CC:  MOVLB  A
022CE:  MOVWF  x94
022D0:  MOVLB  0
022D2:  CALL   1CB2
....................     mcp4901_1_write(10); 
022D6:  MOVLB  9
022D8:  CLRF   xE1
022DA:  MOVLW  0A
022DC:  MOVWF  xE0
022DE:  MOVLB  0
022E0:  CALL   222A
....................     mcp4901_2_write(10); 
022E4:  MOVLB  9
022E6:  CLRF   xE1
022E8:  MOVLW  0A
022EA:  MOVWF  xE0
022EC:  MOVLB  0
022EE:  CALL   226C
....................     unsigned int16 readdata;
....................     readdata = ad7490_read(ADC_CIGS1_DAC); 
022F2:  MOVLW  08
022F4:  MOVLB  9
022F6:  MOVWF  xF2
022F8:  MOVLB  0
022FA:  CALL   1ED4
022FE:  MOVFF  02,1B4
02302:  MOVFF  01,1B3
....................     fprintf(PC, "%04LX\r\n", readdata);
02306:  MOVFF  1B4,A39
0230A:  MOVLW  37
0230C:  MOVLB  A
0230E:  MOVWF  x3A
02310:  MOVLB  0
02312:  CALL   1F60
02316:  MOVFF  1B3,A39
0231A:  MOVLW  37
0231C:  MOVLB  A
0231E:  MOVWF  x3A
02320:  MOVLB  0
02322:  CALL   1F60
02326:  MOVLW  0D
02328:  MOVLB  A
0232A:  MOVWF  xDB
0232C:  MOVLB  0
0232E:  CALL   1CE0
02332:  MOVLW  0A
02334:  MOVLB  A
02336:  MOVWF  xDB
02338:  MOVLB  0
0233A:  CALL   1CE0
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
0233E:  MOVLB  1
02340:  INCFSZ xB3,W
02342:  BRA    2348
02344:  BRA    234E
02346:  MOVLB  0
02348:  MOVLB  0
0234A:  GOTO   2366
0234E:  MOVLB  0
02350:  MOVLB  1
02352:  INCFSZ xB4,W
02354:  BRA    235A
02356:  BRA    2360
02358:  MOVLB  0
0235A:  MOVLB  0
0235C:  GOTO   2366
02360:  MOVLB  0
02362:  GOTO   2386
02366:  MOVLB  1
02368:  MOVF   xB3,F
0236A:  BTFSC  FD8.2
0236C:  BRA    2374
0236E:  MOVLB  0
02370:  GOTO   239A
02374:  MOVLB  0
02376:  MOVLB  1
02378:  MOVF   xB4,F
0237A:  BTFSC  FD8.2
0237C:  BRA    2384
0237E:  MOVLB  0
02380:  GOTO   239A
02384:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 1] Connect error!\r\n");
02386:  MOVLW  A2
02388:  MOVWF  FF6
0238A:  MOVLW  02
0238C:  MOVWF  FF7
0238E:  MOVLW  00
02390:  MOVWF  FF8
02392:  CALL   1D32
....................     } else {
02396:  GOTO   23AA
....................         fprintf(PC, "\t[DAC Port 1] Connect successful\r\n");
0239A:  MOVLW  C2
0239C:  MOVWF  FF6
0239E:  MOVLW  02
023A0:  MOVWF  FF7
023A2:  MOVLW  00
023A4:  MOVWF  FF8
023A6:  CALL   1D32
....................     }
....................     fprintf(PC, "%04LX\r\n", readdata);
023AA:  MOVFF  1B4,A39
023AE:  MOVLW  37
023B0:  MOVLB  A
023B2:  MOVWF  x3A
023B4:  MOVLB  0
023B6:  CALL   1F60
023BA:  MOVFF  1B3,A39
023BE:  MOVLW  37
023C0:  MOVLB  A
023C2:  MOVWF  x3A
023C4:  MOVLB  0
023C6:  CALL   1F60
023CA:  MOVLW  0D
023CC:  MOVLB  A
023CE:  MOVWF  xDB
023D0:  MOVLB  0
023D2:  CALL   1CE0
023D6:  MOVLW  0A
023D8:  MOVLB  A
023DA:  MOVWF  xDB
023DC:  MOVLB  0
023DE:  CALL   1CE0
....................     readdata = ad7490_read(ADC_CIGS2_DAC); 
023E2:  MOVLW  09
023E4:  MOVLB  9
023E6:  MOVWF  xF2
023E8:  MOVLB  0
023EA:  CALL   1ED4
023EE:  MOVFF  02,1B4
023F2:  MOVFF  01,1B3
....................     if (readdata == 0xFFFF || readdata == 0x0000) {
023F6:  MOVLB  1
023F8:  INCFSZ xB3,W
023FA:  BRA    2400
023FC:  BRA    2406
023FE:  MOVLB  0
02400:  MOVLB  0
02402:  GOTO   241E
02406:  MOVLB  0
02408:  MOVLB  1
0240A:  INCFSZ xB4,W
0240C:  BRA    2412
0240E:  BRA    2418
02410:  MOVLB  0
02412:  MOVLB  0
02414:  GOTO   241E
02418:  MOVLB  0
0241A:  GOTO   243E
0241E:  MOVLB  1
02420:  MOVF   xB3,F
02422:  BTFSC  FD8.2
02424:  BRA    242C
02426:  MOVLB  0
02428:  GOTO   2452
0242C:  MOVLB  0
0242E:  MOVLB  1
02430:  MOVF   xB4,F
02432:  BTFSC  FD8.2
02434:  BRA    243C
02436:  MOVLB  0
02438:  GOTO   2452
0243C:  MOVLB  0
....................         fprintf(PC, "\t[DAC Port 2] Connect error!\r\n");
0243E:  MOVLW  E6
02440:  MOVWF  FF6
02442:  MOVLW  02
02444:  MOVWF  FF7
02446:  MOVLW  00
02448:  MOVWF  FF8
0244A:  CALL   1D32
....................     } else {
0244E:  GOTO   2462
....................         fprintf(PC, "\t[DAC Port 2] Connect successful\r\n");
02452:  MOVLW  06
02454:  MOVWF  FF6
02456:  MOVLW  03
02458:  MOVWF  FF7
0245A:  MOVLW  00
0245C:  MOVWF  FF8
0245E:  CALL   1D32
....................     }
....................     fprintf(PC, "\tComplete\r\n");
02462:  MOVLW  2A
02464:  MOVWF  FF6
02466:  MOVLW  03
02468:  MOVWF  FF7
0246A:  MOVLW  00
0246C:  MOVWF  FF8
0246E:  CALL   1D32
02472:  GOTO   C724 (RETURN)
.................... }
.................... 
.................... 
.................... void mcp4901_1_write(unsigned int16 value)
*
0222A:  MOVFF  9E1,9E5
0222E:  MOVFF  9E0,9E4
02232:  CALL   20D6
02236:  MOVFF  02,9E3
0223A:  MOVFF  01,9E2
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC1_CS); 
0223E:  MOVLW  F4
02240:  MOVWF  F93
02242:  BCF    F8A.3
....................    delay_us(10); 
02244:  MOVLW  0D
02246:  MOVWF  00
02248:  DECFSZ 00,F
0224A:  BRA    2248
....................    spi_xfer(ADCDAC_STREAM, cmd); 
0224C:  MOVFF  9E3,9FA
02250:  MOVFF  9E2,9F9
02254:  MOVLW  10
02256:  MOVLB  9
02258:  MOVWF  xFB
0225A:  MOVLW  01
0225C:  MOVWF  xFC
0225E:  MOVLB  0
02260:  CALL   1E6E
....................    output_high(DAC1_CS); 
02264:  MOVLW  F4
02266:  MOVWF  F93
02268:  BSF    F8A.3
0226A:  RETURN 0
.................... }
.................... 
.................... void mcp4901_2_write(unsigned int16 value)
0226C:  MOVFF  9E1,9E5
02270:  MOVFF  9E0,9E4
02274:  CALL   20D6
02278:  MOVFF  02,9E3
0227C:  MOVFF  01,9E2
.................... {
....................    unsigned int16 cmd = mcp4901_make_cmd(value);
....................    #ifdef MCP4901_DEBUG
....................       fprintf(PC, "\t[DAC] <<< %04LX\r\n", cmd);
....................    #endif
....................    output_low(DAC2_CS); 
02280:  MOVLW  F4
02282:  MOVWF  F93
02284:  BCF    F8A.0
....................    delay_us(10); 
02286:  MOVLW  0D
02288:  MOVWF  00
0228A:  DECFSZ 00,F
0228C:  BRA    228A
....................    spi_xfer(ADCDAC_STREAM, cmd); 
0228E:  MOVFF  9E3,9FA
02292:  MOVFF  9E2,9F9
02296:  MOVLW  10
02298:  MOVLB  9
0229A:  MOVWF  xFB
0229C:  MOVLW  01
0229E:  MOVWF  xFC
022A0:  MOVLB  0
022A2:  CALL   1E6E
....................    output_high(DAC2_CS); 
022A6:  MOVLW  F4
022A8:  MOVWF  F93
022AA:  BSF    F8A.0
022AC:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... 
.................... // ライブラリ実装ファイル
.................... #include "../lib/device/ad7490.c"
.................... // #include "ad7490.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 ad7490_readdata(unsigned int16 channel)
.................... {
....................     spi_xfer(ADC_STREAM, channel); // Dummy transfer to start communication
....................     #ifdef AD7490_DEBUG
....................         fprintf(PC, "\t[ADC] <<< %04LX\r\n", channel);
....................     #endif
....................     unsigned int16 ans = spi_xfer(ADC_STREAM);
....................     return ans & 0x0FFF; //Conver LSB <--> MSB
.................... }
.................... 
.................... unsigned int16 ad7490_make_cmd(int8 channel)
.................... {
....................     ad7490_cmd_t cmd;
....................     
....................     cmd.fields.reserved0 = 0; // Reserved bits
*
01DFE:  MOVLB  9
01E00:  BCF    xFA.0
....................     cmd.fields.reserved1 = 0; // Reserved bits
01E02:  BCF    xFA.1
....................     cmd.fields.reserved2 = 0; // Reserved bits
01E04:  BCF    xFA.2
....................     cmd.fields.reserved3 = 0;
01E06:  BCF    xFA.3
....................     cmd.fields.coding = 1; // Two's complement
01E08:  BSF    xFA.4
....................     cmd.fields.range = 0; // Normal mode
01E0A:  BCF    xFA.5
....................     cmd.fields.weak_tri = 0; // Strong trigger
01E0C:  BCF    xFA.6
....................     cmd.fields.shadow = 0; // Direct access
01E0E:  BCF    xFA.7
....................     cmd.fields.pm0 = AD7490_PM_AUTO_STANDBY & 0b00000001; // Power mode bits
01E10:  BSF    xFB.0
....................     cmd.fields.pm1 = (AD7490_PM_AUTO_STANDBY >> 1) & 0b00000001; // Power mode bits
01E12:  BSF    xFB.1
....................     cmd.fields.add0 = (channel >> 0) & 0b00000001; // Channel address bits
01E14:  MOVF   xF9,W
01E16:  ANDLW  01
01E18:  MOVWF  01
01E1A:  BCF    xFB.2
01E1C:  BTFSC  01.0
01E1E:  BSF    xFB.2
....................     cmd.fields.add1 = (channel >> 1) & 0b00000001; // Channel address bits
01E20:  BCF    FD8.0
01E22:  RRCF   xF9,W
01E24:  ANDLW  01
01E26:  MOVWF  01
01E28:  BCF    xFB.3
01E2A:  BTFSC  01.0
01E2C:  BSF    xFB.3
....................     cmd.fields.add2 = (channel >> 2) & 0b00000001; // Channel address bits
01E2E:  RRCF   xF9,W
01E30:  MOVWF  00
01E32:  RRCF   00,F
01E34:  MOVLW  3F
01E36:  ANDWF  00,F
01E38:  MOVF   00,W
01E3A:  ANDLW  01
01E3C:  MOVWF  01
01E3E:  BCF    xFB.4
01E40:  BTFSC  01.0
01E42:  BSF    xFB.4
....................     cmd.fields.add3 = (channel >> 3) & 0b00000001; // Channel address bits
01E44:  RRCF   xF9,W
01E46:  MOVWF  00
01E48:  RRCF   00,F
01E4A:  RRCF   00,F
01E4C:  MOVLW  1F
01E4E:  ANDWF  00,F
01E50:  MOVF   00,W
01E52:  ANDLW  01
01E54:  MOVWF  01
01E56:  BCF    xFB.5
01E58:  BTFSC  01.0
01E5A:  BSF    xFB.5
....................     cmd.fields.seq = 0; // Random mode
01E5C:  BCF    xFB.6
....................     cmd.fields.write = 1; // Read operation
01E5E:  BSF    xFB.7
.................... 
.................... 
....................     return cmd.value;
01E60:  MOVF   xFA,W
01E62:  MOVWF  01
01E64:  MOVF   xFB,W
01E66:  MOVWF  02
01E68:  MOVLB  0
01E6A:  GOTO   1EDC (RETURN)
.................... }
.................... 
.................... #include "../lib/device/mcp4901.c"
.................... // #include "mcp4901.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... 
.................... unsigned int16 mcp4901_make_cmd(unsigned int16 value)
.................... {
....................    mcp4901_cmd_t cmd;
....................    cmd.fields.startbit = 0; // Start bit
*
020D6:  MOVLB  9
020D8:  BCF    xE7.7
....................    cmd.fields.buffer = 1; // Buffer used
020DA:  BSF    xE7.6
....................    cmd.fields.gain = 1; // Gain 1x
020DC:  BSF    xE7.5
....................    cmd.fields.shutdown = 1; // Normal operation
020DE:  BSF    xE7.4
....................    cmd.fields.data7 = (value >> 7) & 0x01;
020E0:  RRCF   xE5,W
020E2:  MOVWF  xE9
020E4:  RRCF   xE4,W
020E6:  MOVWF  xE8
020E8:  RRCF   xE9,F
020EA:  RRCF   xE8,F
020EC:  RRCF   xE9,F
020EE:  RRCF   xE8,F
020F0:  RRCF   xE9,F
020F2:  RRCF   xE8,F
020F4:  RRCF   xE9,F
020F6:  RRCF   xE8,F
020F8:  RRCF   xE9,F
020FA:  RRCF   xE8,F
020FC:  RRCF   xE9,F
020FE:  RRCF   xE8,F
02100:  MOVLW  01
02102:  ANDWF  xE9,F
02104:  MOVF   xE8,W
02106:  ANDLW  01
02108:  MOVWF  00
0210A:  CLRF   03
0210C:  MOVF   00,W
0210E:  MOVWF  01
02110:  BCF    xE7.3
02112:  BTFSC  01.0
02114:  BSF    xE7.3
....................    cmd.fields.data6 = (value >> 6) & 0x01;
02116:  RRCF   xE5,W
02118:  MOVWF  xE9
0211A:  RRCF   xE4,W
0211C:  MOVWF  xE8
0211E:  RRCF   xE9,F
02120:  RRCF   xE8,F
02122:  RRCF   xE9,F
02124:  RRCF   xE8,F
02126:  RRCF   xE9,F
02128:  RRCF   xE8,F
0212A:  RRCF   xE9,F
0212C:  RRCF   xE8,F
0212E:  RRCF   xE9,F
02130:  RRCF   xE8,F
02132:  MOVLW  03
02134:  ANDWF  xE9,F
02136:  MOVF   xE8,W
02138:  ANDLW  01
0213A:  MOVWF  00
0213C:  CLRF   03
0213E:  MOVF   00,W
02140:  MOVWF  01
02142:  BCF    xE7.2
02144:  BTFSC  01.0
02146:  BSF    xE7.2
....................    cmd.fields.data5 = (value >> 5) & 0x01;
02148:  RRCF   xE5,W
0214A:  MOVWF  xE9
0214C:  RRCF   xE4,W
0214E:  MOVWF  xE8
02150:  RRCF   xE9,F
02152:  RRCF   xE8,F
02154:  RRCF   xE9,F
02156:  RRCF   xE8,F
02158:  RRCF   xE9,F
0215A:  RRCF   xE8,F
0215C:  RRCF   xE9,F
0215E:  RRCF   xE8,F
02160:  MOVLW  07
02162:  ANDWF  xE9,F
02164:  MOVF   xE8,W
02166:  ANDLW  01
02168:  MOVWF  00
0216A:  CLRF   03
0216C:  MOVF   00,W
0216E:  MOVWF  01
02170:  BCF    xE7.1
02172:  BTFSC  01.0
02174:  BSF    xE7.1
....................    cmd.fields.data4 = (value >> 4) & 0x01;
02176:  RRCF   xE5,W
02178:  MOVWF  xE9
0217A:  RRCF   xE4,W
0217C:  MOVWF  xE8
0217E:  RRCF   xE9,F
02180:  RRCF   xE8,F
02182:  RRCF   xE9,F
02184:  RRCF   xE8,F
02186:  RRCF   xE9,F
02188:  RRCF   xE8,F
0218A:  MOVLW  0F
0218C:  ANDWF  xE9,F
0218E:  MOVF   xE8,W
02190:  ANDLW  01
02192:  MOVWF  00
02194:  CLRF   03
02196:  MOVF   00,W
02198:  MOVWF  01
0219A:  BCF    xE7.0
0219C:  BTFSC  01.0
0219E:  BSF    xE7.0
....................    cmd.fields.data3 = (value >> 3) & 0x01;
021A0:  RRCF   xE5,W
021A2:  MOVWF  xE9
021A4:  RRCF   xE4,W
021A6:  MOVWF  xE8
021A8:  RRCF   xE9,F
021AA:  RRCF   xE8,F
021AC:  RRCF   xE9,F
021AE:  RRCF   xE8,F
021B0:  MOVLW  1F
021B2:  ANDWF  xE9,F
021B4:  MOVF   xE8,W
021B6:  ANDLW  01
021B8:  MOVWF  00
021BA:  CLRF   03
021BC:  MOVF   00,W
021BE:  MOVWF  01
021C0:  BCF    xE6.7
021C2:  BTFSC  01.0
021C4:  BSF    xE6.7
....................    cmd.fields.data2 = (value >> 2) & 0x01;
021C6:  RRCF   xE5,W
021C8:  MOVWF  xE9
021CA:  RRCF   xE4,W
021CC:  MOVWF  xE8
021CE:  RRCF   xE9,F
021D0:  RRCF   xE8,F
021D2:  MOVLW  3F
021D4:  ANDWF  xE9,F
021D6:  MOVF   xE8,W
021D8:  ANDLW  01
021DA:  MOVWF  00
021DC:  CLRF   03
021DE:  MOVF   00,W
021E0:  MOVWF  01
021E2:  BCF    xE6.6
021E4:  BTFSC  01.0
021E6:  BSF    xE6.6
....................    cmd.fields.data1 = (value >> 1) & 0x01;
021E8:  BCF    FD8.0
021EA:  RRCF   xE5,W
021EC:  MOVWF  xE9
021EE:  RRCF   xE4,W
021F0:  MOVWF  xE8
021F2:  MOVF   xE8,W
021F4:  ANDLW  01
021F6:  MOVWF  00
021F8:  CLRF   03
021FA:  MOVF   00,W
021FC:  MOVWF  01
021FE:  BCF    xE6.5
02200:  BTFSC  01.0
02202:  BSF    xE6.5
....................    cmd.fields.data0 = value & 0x01; // LSB of the data
02204:  MOVF   xE4,W
02206:  ANDLW  01
02208:  MOVWF  00
0220A:  CLRF   03
0220C:  MOVF   00,W
0220E:  MOVWF  01
02210:  BCF    xE6.4
02212:  BTFSC  01.0
02214:  BSF    xE6.4
....................    cmd.fields.reserved = 0; // Reserved bits
02216:  BCF    xE6.3
....................    cmd.fields.reserved2 = 0; // Reserved bits
02218:  BCF    xE6.2
....................    cmd.fields.reserved3 = 0; // Reserved bits
0221A:  BCF    xE6.1
....................    cmd.fields.reserved4 = 0; // Reserved bits
0221C:  BCF    xE6.0
.................... 
....................    return cmd.value;
0221E:  MOVF   xE6,W
02220:  MOVWF  01
02222:  MOVF   xE7,W
02224:  MOVWF  02
02226:  MOVLB  0
02228:  RETURN 0
.................... }
.................... 
.................... #include "../lib/device/mt25q.c"
.................... #include "mt25q.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
03C78:  MOVLB  A
03C7A:  MOVF   x94,W
03C7C:  XORLW  00
03C7E:  MOVLB  0
03C80:  BTFSC  FD8.2
03C82:  GOTO   3C92
03C86:  XORLW  01
03C88:  BTFSC  FD8.2
03C8A:  GOTO   3CFA
03C8E:  GOTO   3D62
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03C92:  MOVLB  A
03C94:  CLRF   x9D
03C96:  CLRF   x9C
03C98:  MOVLB  0
03C9A:  MOVLB  A
03C9C:  MOVF   x9D,W
03C9E:  SUBWF  x9B,W
03CA0:  BTFSC  FD8.0
03CA2:  BRA    3CAA
03CA4:  MOVLB  0
03CA6:  GOTO   3CF6
03CAA:  MOVLB  0
03CAC:  BTFSS  FD8.2
03CAE:  GOTO   3CC4
03CB2:  MOVLB  A
03CB4:  MOVF   x9A,W
03CB6:  SUBWF  x9C,W
03CB8:  BTFSS  FD8.0
03CBA:  BRA    3CC2
03CBC:  MOVLB  0
03CBE:  GOTO   3CF6
03CC2:  MOVLB  0
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
03CC4:  MOVLB  A
03CC6:  MOVF   x98,W
03CC8:  ADDWF  x9C,W
03CCA:  MOVWF  FE9
03CCC:  MOVF   x99,W
03CCE:  ADDWFC x9D,W
03CD0:  MOVWF  FEA
03CD2:  MOVFF  FEF,AA0
03CD6:  MOVFF  AA0,AB6
03CDA:  MOVLW  08
03CDC:  MOVWF  xB7
03CDE:  MOVLW  01
03CE0:  MOVWF  xB8
03CE2:  MOVLB  0
03CE4:  CALL   24CA
03CE8:  MOVLB  A
03CEA:  INCF   x9C,F
03CEC:  BTFSC  FD8.2
03CEE:  INCF   x9D,F
03CF0:  MOVLB  0
03CF2:  GOTO   3C9A
....................          break;
03CF6:  GOTO   3D66
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03CFA:  MOVLB  A
03CFC:  CLRF   x9F
03CFE:  CLRF   x9E
03D00:  MOVLB  0
03D02:  MOVLB  A
03D04:  MOVF   x9F,W
03D06:  SUBWF  x9B,W
03D08:  BTFSC  FD8.0
03D0A:  BRA    3D12
03D0C:  MOVLB  0
03D0E:  GOTO   3D5E
03D12:  MOVLB  0
03D14:  BTFSS  FD8.2
03D16:  GOTO   3D2C
03D1A:  MOVLB  A
03D1C:  MOVF   x9A,W
03D1E:  SUBWF  x9E,W
03D20:  BTFSS  FD8.0
03D22:  BRA    3D2A
03D24:  MOVLB  0
03D26:  GOTO   3D5E
03D2A:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
03D2C:  MOVLB  A
03D2E:  MOVF   x98,W
03D30:  ADDWF  x9E,W
03D32:  MOVWF  FE9
03D34:  MOVF   x99,W
03D36:  ADDWFC x9F,W
03D38:  MOVWF  FEA
03D3A:  MOVFF  FEF,AA0
03D3E:  MOVFF  AA0,AB6
03D42:  MOVLW  08
03D44:  MOVWF  xB7
03D46:  MOVLW  01
03D48:  MOVWF  xB8
03D4A:  MOVLB  0
03D4C:  CALL   2546
03D50:  MOVLB  A
03D52:  INCF   x9E,F
03D54:  BTFSC  FD8.2
03D56:  INCF   x9F,F
03D58:  MOVLB  0
03D5A:  GOTO   3D02
....................          break;
03D5E:  GOTO   3D66
....................          
....................       default:
....................          break;
03D62:  GOTO   3D66
....................    }
....................    return;
03D66:  RETURN 0
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
*
025C2:  MOVLB  A
025C4:  MOVF   x9A,W
025C6:  XORLW  00
025C8:  MOVLB  0
025CA:  BTFSC  FD8.2
025CC:  GOTO   25DC
025D0:  XORLW  01
025D2:  BTFSC  FD8.2
025D4:  GOTO   26E6
025D8:  GOTO   27F0
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
025DC:  MOVLB  A
025DE:  CLRF   xA9
025E0:  CLRF   xA8
025E2:  MOVLB  0
025E4:  MOVLB  A
025E6:  MOVF   xA9,W
025E8:  SUBWF  xA1,W
025EA:  BTFSC  FD8.0
025EC:  BRA    25F4
025EE:  MOVLB  0
025F0:  GOTO   2640
025F4:  MOVLB  0
025F6:  BTFSS  FD8.2
025F8:  GOTO   260E
025FC:  MOVLB  A
025FE:  MOVF   xA0,W
02600:  SUBWF  xA8,W
02602:  BTFSS  FD8.0
02604:  BRA    260C
02606:  MOVLB  0
02608:  GOTO   2640
0260C:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
0260E:  MOVLB  A
02610:  MOVF   x9E,W
02612:  ADDWF  xA8,W
02614:  MOVWF  FE9
02616:  MOVF   x9F,W
02618:  ADDWFC xA9,W
0261A:  MOVWF  FEA
0261C:  MOVFF  FEF,AB4
02620:  MOVFF  AB4,AB6
02624:  MOVLW  08
02626:  MOVWF  xB7
02628:  MOVLW  01
0262A:  MOVWF  xB8
0262C:  MOVLB  0
0262E:  CALL   24CA
02632:  MOVLB  A
02634:  INCF   xA8,F
02636:  BTFSC  FD8.2
02638:  INCF   xA9,F
0263A:  MOVLB  0
0263C:  GOTO   25E4
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
02640:  MOVLB  A
02642:  CLRF   xAD
02644:  CLRF   xAC
02646:  CLRF   xAB
02648:  CLRF   xAA
0264A:  MOVLB  0
0264C:  MOVLB  A
0264E:  MOVF   xAD,W
02650:  SUBWF  xA7,W
02652:  BTFSC  FD8.0
02654:  BRA    265C
02656:  MOVLB  0
02658:  GOTO   26E2
0265C:  MOVLB  0
0265E:  BTFSS  FD8.2
02660:  GOTO   26A6
02664:  MOVLB  A
02666:  MOVF   xAC,W
02668:  SUBWF  xA6,W
0266A:  BTFSC  FD8.0
0266C:  BRA    2674
0266E:  MOVLB  0
02670:  GOTO   26E2
02674:  MOVLB  0
02676:  BTFSS  FD8.2
02678:  GOTO   26A6
0267C:  MOVLB  A
0267E:  MOVF   xAB,W
02680:  SUBWF  xA5,W
02682:  BTFSC  FD8.0
02684:  BRA    268C
02686:  MOVLB  0
02688:  GOTO   26E2
0268C:  MOVLB  0
0268E:  BTFSS  FD8.2
02690:  GOTO   26A6
02694:  MOVLB  A
02696:  MOVF   xA4,W
02698:  SUBWF  xAA,W
0269A:  BTFSS  FD8.0
0269C:  BRA    26A4
0269E:  MOVLB  0
026A0:  GOTO   26E2
026A4:  MOVLB  0
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
026A6:  MOVLB  A
026A8:  MOVF   xA2,W
026AA:  ADDWF  xAA,W
026AC:  MOVWF  FE9
026AE:  MOVF   xA3,W
026B0:  ADDWFC xAB,W
026B2:  MOVWF  FEA
026B4:  MOVLW  02
026B6:  MOVWF  xB6
026B8:  MOVLW  08
026BA:  MOVWF  xB7
026BC:  MOVLW  01
026BE:  MOVWF  xB8
026C0:  MOVLB  0
026C2:  CALL   24CA
026C6:  MOVFF  01,FEF
026CA:  MOVLW  01
026CC:  MOVLB  A
026CE:  ADDWF  xAA,F
026D0:  BTFSC  FD8.0
026D2:  INCF   xAB,F
026D4:  BTFSC  FD8.2
026D6:  INCF   xAC,F
026D8:  BTFSC  FD8.2
026DA:  INCF   xAD,F
026DC:  MOVLB  0
026DE:  GOTO   264C
....................          break;
026E2:  GOTO   27F4
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
026E6:  MOVLB  A
026E8:  CLRF   xAF
026EA:  CLRF   xAE
026EC:  MOVLB  0
026EE:  MOVLB  A
026F0:  MOVF   xAF,W
026F2:  SUBWF  xA1,W
026F4:  BTFSC  FD8.0
026F6:  BRA    26FE
026F8:  MOVLB  0
026FA:  GOTO   274A
026FE:  MOVLB  0
02700:  BTFSS  FD8.2
02702:  GOTO   2718
02706:  MOVLB  A
02708:  MOVF   xA0,W
0270A:  SUBWF  xAE,W
0270C:  BTFSS  FD8.0
0270E:  BRA    2716
02710:  MOVLB  0
02712:  GOTO   274A
02716:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
02718:  MOVLB  A
0271A:  MOVF   x9E,W
0271C:  ADDWF  xAE,W
0271E:  MOVWF  FE9
02720:  MOVF   x9F,W
02722:  ADDWFC xAF,W
02724:  MOVWF  FEA
02726:  MOVFF  FEF,AB4
0272A:  MOVFF  AB4,AB6
0272E:  MOVLW  08
02730:  MOVWF  xB7
02732:  MOVLW  01
02734:  MOVWF  xB8
02736:  MOVLB  0
02738:  CALL   2546
0273C:  MOVLB  A
0273E:  INCF   xAE,F
02740:  BTFSC  FD8.2
02742:  INCF   xAF,F
02744:  MOVLB  0
02746:  GOTO   26EE
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
0274A:  MOVLB  A
0274C:  CLRF   xB3
0274E:  CLRF   xB2
02750:  CLRF   xB1
02752:  CLRF   xB0
02754:  MOVLB  0
02756:  MOVLB  A
02758:  MOVF   xB3,W
0275A:  SUBWF  xA7,W
0275C:  BTFSC  FD8.0
0275E:  BRA    2766
02760:  MOVLB  0
02762:  GOTO   27EC
02766:  MOVLB  0
02768:  BTFSS  FD8.2
0276A:  GOTO   27B0
0276E:  MOVLB  A
02770:  MOVF   xB2,W
02772:  SUBWF  xA6,W
02774:  BTFSC  FD8.0
02776:  BRA    277E
02778:  MOVLB  0
0277A:  GOTO   27EC
0277E:  MOVLB  0
02780:  BTFSS  FD8.2
02782:  GOTO   27B0
02786:  MOVLB  A
02788:  MOVF   xB1,W
0278A:  SUBWF  xA5,W
0278C:  BTFSC  FD8.0
0278E:  BRA    2796
02790:  MOVLB  0
02792:  GOTO   27EC
02796:  MOVLB  0
02798:  BTFSS  FD8.2
0279A:  GOTO   27B0
0279E:  MOVLB  A
027A0:  MOVF   xA4,W
027A2:  SUBWF  xB0,W
027A4:  BTFSS  FD8.0
027A6:  BRA    27AE
027A8:  MOVLB  0
027AA:  GOTO   27EC
027AE:  MOVLB  0
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
027B0:  MOVLB  A
027B2:  MOVF   xA2,W
027B4:  ADDWF  xB0,W
027B6:  MOVWF  FE9
027B8:  MOVF   xA3,W
027BA:  ADDWFC xB1,W
027BC:  MOVWF  FEA
027BE:  MOVLW  01
027C0:  MOVWF  xB6
027C2:  MOVLW  08
027C4:  MOVWF  xB7
027C6:  MOVLW  01
027C8:  MOVWF  xB8
027CA:  MOVLB  0
027CC:  CALL   2546
027D0:  MOVFF  01,FEF
027D4:  MOVLW  01
027D6:  MOVLB  A
027D8:  ADDWF  xB0,F
027DA:  BTFSC  FD8.0
027DC:  INCF   xB1,F
027DE:  BTFSC  FD8.2
027E0:  INCF   xB2,F
027E2:  BTFSC  FD8.2
027E4:  INCF   xB3,F
027E6:  MOVLB  0
027E8:  GOTO   2756
....................          break;
027EC:  GOTO   27F4
....................    
....................          
....................       default:
....................          break;
027F0:  GOTO   27F4
....................    }
....................    return;
027F4:  RETURN 0
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
*
03D68:  MOVLB  A
03D6A:  MOVF   x94,W
03D6C:  XORLW  00
03D6E:  MOVLB  0
03D70:  BTFSC  FD8.2
03D72:  GOTO   3D82
03D76:  XORLW  01
03D78:  BTFSC  FD8.2
03D7A:  GOTO   3E30
03D7E:  GOTO   3EDE
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
03D82:  MOVLB  A
03D84:  CLRF   x9F
03D86:  MOVLB  0
03D88:  MOVLB  A
03D8A:  MOVF   x9A,W
03D8C:  SUBWF  x9F,W
03D8E:  BTFSS  FD8.0
03D90:  BRA    3D98
03D92:  MOVLB  0
03D94:  GOTO   3DC8
03D98:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
03D9A:  MOVLB  A
03D9C:  MOVF   x9F,W
03D9E:  ADDWF  x98,W
03DA0:  MOVWF  FE9
03DA2:  MOVLW  00
03DA4:  ADDWFC x99,W
03DA6:  MOVWF  FEA
03DA8:  MOVFF  FEF,AA5
03DAC:  MOVFF  AA5,AB6
03DB0:  MOVLW  08
03DB2:  MOVWF  xB7
03DB4:  MOVLW  01
03DB6:  MOVWF  xB8
03DB8:  MOVLB  0
03DBA:  CALL   24CA
03DBE:  MOVLB  A
03DC0:  INCF   x9F,F
03DC2:  MOVLB  0
03DC4:  GOTO   3D88
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03DC8:  MOVLB  A
03DCA:  CLRF   xA1
03DCC:  CLRF   xA0
03DCE:  MOVLB  0
03DD0:  MOVLB  A
03DD2:  MOVF   xA1,W
03DD4:  SUBWF  x9E,W
03DD6:  BTFSC  FD8.0
03DD8:  BRA    3DE0
03DDA:  MOVLB  0
03DDC:  GOTO   3E2C
03DE0:  MOVLB  0
03DE2:  BTFSS  FD8.2
03DE4:  GOTO   3DFA
03DE8:  MOVLB  A
03DEA:  MOVF   x9D,W
03DEC:  SUBWF  xA0,W
03DEE:  BTFSS  FD8.0
03DF0:  BRA    3DF8
03DF2:  MOVLB  0
03DF4:  GOTO   3E2C
03DF8:  MOVLB  0
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
03DFA:  MOVLB  A
03DFC:  MOVF   x9B,W
03DFE:  ADDWF  xA0,W
03E00:  MOVWF  FE9
03E02:  MOVF   x9C,W
03E04:  ADDWFC xA1,W
03E06:  MOVWF  FEA
03E08:  MOVFF  FEF,AA5
03E0C:  MOVFF  AA5,AB6
03E10:  MOVLW  08
03E12:  MOVWF  xB7
03E14:  MOVLW  01
03E16:  MOVWF  xB8
03E18:  MOVLB  0
03E1A:  CALL   24CA
03E1E:  MOVLB  A
03E20:  INCF   xA0,F
03E22:  BTFSC  FD8.2
03E24:  INCF   xA1,F
03E26:  MOVLB  0
03E28:  GOTO   3DD0
....................          break;
03E2C:  GOTO   3EE2
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
03E30:  MOVLB  A
03E32:  CLRF   xA2
03E34:  MOVLB  0
03E36:  MOVLB  A
03E38:  MOVF   x9A,W
03E3A:  SUBWF  xA2,W
03E3C:  BTFSS  FD8.0
03E3E:  BRA    3E46
03E40:  MOVLB  0
03E42:  GOTO   3E76
03E46:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
03E48:  MOVLB  A
03E4A:  MOVF   xA2,W
03E4C:  ADDWF  x98,W
03E4E:  MOVWF  FE9
03E50:  MOVLW  00
03E52:  ADDWFC x99,W
03E54:  MOVWF  FEA
03E56:  MOVFF  FEF,AA5
03E5A:  MOVFF  AA5,AB6
03E5E:  MOVLW  08
03E60:  MOVWF  xB7
03E62:  MOVLW  01
03E64:  MOVWF  xB8
03E66:  MOVLB  0
03E68:  CALL   2546
03E6C:  MOVLB  A
03E6E:  INCF   xA2,F
03E70:  MOVLB  0
03E72:  GOTO   3E36
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
03E76:  MOVLB  A
03E78:  CLRF   xA4
03E7A:  CLRF   xA3
03E7C:  MOVLB  0
03E7E:  MOVLB  A
03E80:  MOVF   xA4,W
03E82:  SUBWF  x9E,W
03E84:  BTFSC  FD8.0
03E86:  BRA    3E8E
03E88:  MOVLB  0
03E8A:  GOTO   3EDA
03E8E:  MOVLB  0
03E90:  BTFSS  FD8.2
03E92:  GOTO   3EA8
03E96:  MOVLB  A
03E98:  MOVF   x9D,W
03E9A:  SUBWF  xA3,W
03E9C:  BTFSS  FD8.0
03E9E:  BRA    3EA6
03EA0:  MOVLB  0
03EA2:  GOTO   3EDA
03EA6:  MOVLB  0
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
03EA8:  MOVLB  A
03EAA:  MOVF   x9B,W
03EAC:  ADDWF  xA3,W
03EAE:  MOVWF  FE9
03EB0:  MOVF   x9C,W
03EB2:  ADDWFC xA4,W
03EB4:  MOVWF  FEA
03EB6:  MOVFF  FEF,AA5
03EBA:  MOVFF  AA5,AB6
03EBE:  MOVLW  08
03EC0:  MOVWF  xB7
03EC2:  MOVLW  01
03EC4:  MOVWF  xB8
03EC6:  MOVLB  0
03EC8:  CALL   2546
03ECC:  MOVLB  A
03ECE:  INCF   xA3,F
03ED0:  BTFSC  FD8.2
03ED2:  INCF   xA4,F
03ED4:  MOVLB  0
03ED6:  GOTO   3E7E
....................          break;
03EDA:  GOTO   3EE2
....................          
....................       default:
....................          break;
03EDE:  GOTO   3EE2
....................    }
....................    return;
03EE2:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
*
0613C:  MOVFF  2C9,A9A
06140:  MOVLW  01
06142:  MOVLB  A
06144:  MOVWF  x9B
06146:  MOVLW  0F
06148:  MOVWF  x9D
0614A:  MOVLW  89
0614C:  MOVWF  x9C
0614E:  MOVLB  0
06150:  CALL   2476
06154:  MOVFF  2C9,A9A
06158:  MOVLB  A
0615A:  CLRF   x9B
0615C:  MOVLW  0F
0615E:  MOVWF  x9D
06160:  MOVLW  92
06162:  MOVWF  x9C
06164:  MOVLB  0
06166:  CALL   2476
0616A:  RETURN 0
.................... }
....................  
.................... int8 status_register(Flash flash_stream){
*
03EE4:  MOVLW  05
03EE6:  MOVLB  A
03EE8:  MOVWF  x98
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
03EEA:  MOVFF  A96,A9A
03EEE:  CLRF   x9B
03EF0:  MOVLW  0F
03EF2:  MOVWF  x9D
03EF4:  MOVLW  89
03EF6:  MOVWF  x9C
03EF8:  MOVLB  0
03EFA:  CALL   2476
03EFE:  MOVFF  A96,A9A
03F02:  MOVLB  A
03F04:  CLRF   x9B
03F06:  MOVLW  0F
03F08:  MOVWF  x9D
03F0A:  MOVLW  92
03F0C:  MOVWF  x9C
03F0E:  MOVLB  0
03F10:  CALL   2476
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
03F14:  MOVFF  A97,A9D
03F18:  MOVFF  A96,A9C
03F1C:  MOVFF  A95,A9B
03F20:  MOVFF  A94,A9A
03F24:  MOVLW  0A
03F26:  MOVLB  A
03F28:  MOVWF  x9F
03F2A:  MOVLW  98
03F2C:  MOVWF  x9E
03F2E:  CLRF   xA1
03F30:  MOVLW  01
03F32:  MOVWF  xA0
03F34:  MOVLW  0A
03F36:  MOVWF  xA3
03F38:  MOVLW  99
03F3A:  MOVWF  xA2
03F3C:  CLRF   xA7
03F3E:  CLRF   xA6
03F40:  CLRF   xA5
03F42:  MOVLW  01
03F44:  MOVWF  xA4
03F46:  MOVLB  0
03F48:  CALL   25C2
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
03F4C:  MOVFF  A96,A9A
03F50:  MOVLW  01
03F52:  MOVLB  A
03F54:  MOVWF  x9B
03F56:  MOVLW  0F
03F58:  MOVWF  x9D
03F5A:  MOVLW  89
03F5C:  MOVWF  x9C
03F5E:  MOVLB  0
03F60:  CALL   2476
03F64:  MOVFF  A96,A9A
03F68:  MOVLB  A
03F6A:  CLRF   x9B
03F6C:  MOVLW  0F
03F6E:  MOVWF  x9D
03F70:  MOVLW  92
03F72:  MOVWF  x9C
03F74:  MOVLB  0
03F76:  CALL   2476
....................    #ifdef MT25Q_DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(PC,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
03F7A:  MOVLB  A
03F7C:  MOVF   x99,W
03F7E:  MOVWF  01
03F80:  MOVLB  0
03F82:  RETURN 0
.................... }
.................... 
.................... //
.................... //->success:True,fail:false 
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 16);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(PC,"%x ",chip_id[print_counter]);
....................       fprintf(PC,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == MANUFACTURER_ID_MICRON){  
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
....................  
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef MT25Q_DEBUG
.................... //!      fprintf(PC,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
0469C:  MOVLB  A
0469E:  MOVF   x7B,F
046A0:  BTFSC  FD8.2
046A2:  BRA    46AA
046A4:  MOVLB  0
046A6:  GOTO   4800
046AA:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
046AC:  MOVLW  06
046AE:  MOVLB  A
046B0:  MOVWF  x82
046B2:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
046B4:  MOVLW  D8
046B6:  MOVLB  A
046B8:  MOVWF  x83
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
046BA:  MOVFF  A80,A8F
046BE:  MOVFF  A81,A90
046C2:  CLRF   x91
046C4:  CLRF   x92
046C6:  MOVF   x8F,W
046C8:  MOVWF  00
046CA:  CLRF   01
046CC:  CLRF   02
046CE:  CLRF   03
046D0:  MOVFF  00,A84
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
046D4:  MOVFF  A7F,A8F
046D8:  MOVFF  A80,A90
046DC:  MOVFF  A81,A91
046E0:  CLRF   x92
046E2:  MOVF   x8F,W
046E4:  MOVWF  00
046E6:  CLRF   01
046E8:  CLRF   02
046EA:  CLRF   03
046EC:  MOVFF  00,A85
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
046F0:  MOVF   x7E,W
046F2:  MOVWF  00
046F4:  CLRF   01
046F6:  CLRF   02
046F8:  CLRF   03
046FA:  MOVFF  00,A86
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
046FE:  MOVFF  A7C,A9A
04702:  CLRF   x9B
04704:  MOVLW  0F
04706:  MOVWF  x9D
04708:  MOVLW  89
0470A:  MOVWF  x9C
0470C:  MOVLB  0
0470E:  CALL   2476
04712:  MOVFF  A7C,A9A
04716:  MOVLB  A
04718:  CLRF   x9B
0471A:  MOVLW  0F
0471C:  MOVWF  x9D
0471E:  MOVLW  92
04720:  MOVWF  x9C
04722:  MOVLB  0
04724:  CALL   2476
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04728:  MOVFF  A7D,A97
0472C:  MOVFF  A7C,A96
04730:  MOVFF  A7B,A95
04734:  MOVFF  A7A,A94
04738:  MOVLW  0A
0473A:  MOVLB  A
0473C:  MOVWF  x99
0473E:  MOVLW  82
04740:  MOVWF  x98
04742:  CLRF   x9B
04744:  MOVLW  01
04746:  MOVWF  x9A
04748:  MOVLB  0
0474A:  CALL   3C78
....................       output_high(flash_stream.cs_pin);
0474E:  MOVFF  A7C,A9A
04752:  MOVLW  01
04754:  MOVLB  A
04756:  MOVWF  x9B
04758:  MOVLW  0F
0475A:  MOVWF  x9D
0475C:  MOVLW  89
0475E:  MOVWF  x9C
04760:  MOVLB  0
04762:  CALL   2476
04766:  MOVFF  A7C,A9A
0476A:  MOVLB  A
0476C:  CLRF   x9B
0476E:  MOVLW  0F
04770:  MOVWF  x9D
04772:  MOVLW  92
04774:  MOVWF  x9C
04776:  MOVLB  0
04778:  CALL   2476
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
0477C:  MOVFF  A7C,A9A
04780:  MOVLB  A
04782:  CLRF   x9B
04784:  MOVLW  0F
04786:  MOVWF  x9D
04788:  MOVLW  89
0478A:  MOVWF  x9C
0478C:  MOVLB  0
0478E:  CALL   2476
04792:  MOVFF  A7C,A9A
04796:  MOVLB  A
04798:  CLRF   x9B
0479A:  MOVLW  0F
0479C:  MOVWF  x9D
0479E:  MOVLW  92
047A0:  MOVWF  x9C
047A2:  MOVLB  0
047A4:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
047A8:  MOVFF  A7D,A97
047AC:  MOVFF  A7C,A96
047B0:  MOVFF  A7B,A95
047B4:  MOVFF  A7A,A94
047B8:  MOVLW  0A
047BA:  MOVLB  A
047BC:  MOVWF  x99
047BE:  MOVLW  83
047C0:  MOVWF  x98
047C2:  CLRF   x9B
047C4:  MOVLW  04
047C6:  MOVWF  x9A
047C8:  MOVLB  0
047CA:  CALL   3C78
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
047CE:  MOVFF  A7C,A9A
047D2:  MOVLW  01
047D4:  MOVLB  A
047D6:  MOVWF  x9B
047D8:  MOVLW  0F
047DA:  MOVWF  x9D
047DC:  MOVLW  89
047DE:  MOVWF  x9C
047E0:  MOVLB  0
047E2:  CALL   2476
047E6:  MOVFF  A7C,A9A
047EA:  MOVLB  A
047EC:  CLRF   x9B
047EE:  MOVLW  0F
047F0:  MOVWF  x9D
047F2:  MOVLW  92
047F4:  MOVWF  x9C
047F6:  MOVLB  0
047F8:  CALL   2476
....................    }
047FC:  GOTO   497E
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04800:  MOVLB  A
04802:  DECFSZ x7B,W
04804:  BRA    480A
04806:  BRA    4810
04808:  MOVLB  0
0480A:  MOVLB  0
0480C:  GOTO   497E
04810:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04812:  MOVLW  06
04814:  MOVLB  A
04816:  MOVWF  x87
04818:  MOVLB  0
.................... //!      #ifdef MT25Q_DEBUG
.................... //!         fprintf(PC,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
0481A:  MOVLW  DC
0481C:  MOVLB  A
0481E:  MOVWF  x88
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
04820:  MOVFF  A81,A8F
04824:  CLRF   x90
04826:  CLRF   x91
04828:  CLRF   x92
0482A:  MOVF   x8F,W
0482C:  MOVWF  00
0482E:  CLRF   01
04830:  CLRF   02
04832:  CLRF   03
04834:  MOVFF  00,A89
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04838:  MOVFF  A80,A8F
0483C:  MOVFF  A81,A90
04840:  CLRF   x91
04842:  CLRF   x92
04844:  MOVF   x8F,W
04846:  MOVWF  00
04848:  CLRF   01
0484A:  CLRF   02
0484C:  CLRF   03
0484E:  MOVFF  00,A8A
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04852:  MOVFF  A7F,A8F
04856:  MOVFF  A80,A90
0485A:  MOVFF  A81,A91
0485E:  CLRF   x92
04860:  MOVF   x8F,W
04862:  MOVWF  00
04864:  CLRF   01
04866:  CLRF   02
04868:  CLRF   03
0486A:  MOVFF  00,A8B
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
0486E:  MOVF   x7E,W
04870:  MOVWF  00
04872:  CLRF   01
04874:  CLRF   02
04876:  CLRF   03
04878:  MOVFF  00,A8C
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
0487C:  MOVFF  A7C,A9A
04880:  CLRF   x9B
04882:  MOVLW  0F
04884:  MOVWF  x9D
04886:  MOVLW  89
04888:  MOVWF  x9C
0488A:  MOVLB  0
0488C:  CALL   2476
04890:  MOVFF  A7C,A9A
04894:  MOVLB  A
04896:  CLRF   x9B
04898:  MOVLW  0F
0489A:  MOVWF  x9D
0489C:  MOVLW  92
0489E:  MOVWF  x9C
048A0:  MOVLB  0
048A2:  CALL   2476
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
048A6:  MOVFF  A7D,A97
048AA:  MOVFF  A7C,A96
048AE:  MOVFF  A7B,A95
048B2:  MOVFF  A7A,A94
048B6:  MOVLW  0A
048B8:  MOVLB  A
048BA:  MOVWF  x99
048BC:  MOVLW  87
048BE:  MOVWF  x98
048C0:  CLRF   x9B
048C2:  MOVLW  01
048C4:  MOVWF  x9A
048C6:  MOVLB  0
048C8:  CALL   3C78
....................       output_high(flash_stream.cs_pin);
048CC:  MOVFF  A7C,A9A
048D0:  MOVLW  01
048D2:  MOVLB  A
048D4:  MOVWF  x9B
048D6:  MOVLW  0F
048D8:  MOVWF  x9D
048DA:  MOVLW  89
048DC:  MOVWF  x9C
048DE:  MOVLB  0
048E0:  CALL   2476
048E4:  MOVFF  A7C,A9A
048E8:  MOVLB  A
048EA:  CLRF   x9B
048EC:  MOVLW  0F
048EE:  MOVWF  x9D
048F0:  MOVLW  92
048F2:  MOVWF  x9C
048F4:  MOVLB  0
048F6:  CALL   2476
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
048FA:  MOVFF  A7C,A9A
048FE:  MOVLB  A
04900:  CLRF   x9B
04902:  MOVLW  0F
04904:  MOVWF  x9D
04906:  MOVLW  89
04908:  MOVWF  x9C
0490A:  MOVLB  0
0490C:  CALL   2476
04910:  MOVFF  A7C,A9A
04914:  MOVLB  A
04916:  CLRF   x9B
04918:  MOVLW  0F
0491A:  MOVWF  x9D
0491C:  MOVLW  92
0491E:  MOVWF  x9C
04920:  MOVLB  0
04922:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
04926:  MOVFF  A7D,A97
0492A:  MOVFF  A7C,A96
0492E:  MOVFF  A7B,A95
04932:  MOVFF  A7A,A94
04936:  MOVLW  0A
04938:  MOVLB  A
0493A:  MOVWF  x99
0493C:  MOVLW  88
0493E:  MOVWF  x98
04940:  CLRF   x9B
04942:  MOVLW  05
04944:  MOVWF  x9A
04946:  MOVLB  0
04948:  CALL   3C78
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
0494C:  MOVFF  A7C,A9A
04950:  MOVLW  01
04952:  MOVLB  A
04954:  MOVWF  x9B
04956:  MOVLW  0F
04958:  MOVWF  x9D
0495A:  MOVLW  89
0495C:  MOVWF  x9C
0495E:  MOVLB  0
04960:  CALL   2476
04964:  MOVFF  A7C,A9A
04968:  MOVLB  A
0496A:  CLRF   x9B
0496C:  MOVLW  0F
0496E:  MOVWF  x9D
04970:  MOVLW  92
04972:  MOVWF  x9C
04974:  MOVLB  0
04976:  CALL   2476
....................    }
0497A:  GOTO   497E
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
0497E:  MOVLB  A
04980:  CLRF   x8D
04982:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
04984:  MOVFF  A7D,A97
04988:  MOVFF  A7C,A96
0498C:  MOVFF  A7B,A95
04990:  MOVFF  A7A,A94
04994:  CALL   3EE4
04998:  MOVF   01,W
0499A:  ANDLW  01
0499C:  SUBLW  01
0499E:  BTFSS  FD8.2
049A0:  GOTO   49F2
....................       if(timeout_counter > 10)
049A4:  MOVLB  A
049A6:  MOVF   x8D,W
049A8:  SUBLW  0A
049AA:  BTFSS  FD8.0
049AC:  BRA    49B4
049AE:  MOVLB  0
049B0:  GOTO   49C6
049B4:  MOVLB  0
....................          delay_ms(200);
049B6:  MOVLW  C8
049B8:  MOVLB  A
049BA:  MOVWF  x94
049BC:  MOVLB  0
049BE:  CALL   1CB2
049C2:  GOTO   49D2
....................       else
....................          delay_ms(10);   
049C6:  MOVLW  0A
049C8:  MOVLB  A
049CA:  MOVWF  x94
049CC:  MOVLB  0
049CE:  CALL   1CB2
....................       
....................       if(timeout_counter > 100){
049D2:  MOVLB  A
049D4:  MOVF   x8D,W
049D6:  SUBLW  64
049D8:  BTFSS  FD8.0
049DA:  BRA    49E2
049DC:  MOVLB  0
049DE:  GOTO   49E8
049E2:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
049E4:  GOTO   49F2
....................       }  
....................       timeout_counter++;
049E8:  MOVLB  A
049EA:  INCF   x8D,F
049EC:  MOVLB  0
049EE:  GOTO   4984
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash sector erase complete\r\n");
....................    #endif
....................    return;
049F2:  RETURN 0
.................... }
....................  
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
056D4:  MOVLB  3
056D6:  MOVF   x12,F
056D8:  BTFSC  FD8.2
056DA:  BRA    56E2
056DC:  MOVLB  0
056DE:  GOTO   583A
056E2:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
056E4:  MOVLW  06
056E6:  MOVLB  3
056E8:  MOVWF  x19
056EA:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
056EC:  MOVLW  20
056EE:  MOVLB  3
056F0:  MOVWF  x1A
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
056F2:  MOVFF  317,326
056F6:  MOVFF  318,327
056FA:  CLRF   x28
056FC:  CLRF   x29
056FE:  MOVF   x26,W
05700:  MOVWF  00
05702:  CLRF   01
05704:  CLRF   02
05706:  CLRF   03
05708:  MOVFF  00,31B
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0570C:  MOVFF  316,326
05710:  MOVFF  317,327
05714:  MOVFF  318,328
05718:  CLRF   x29
0571A:  MOVF   x26,W
0571C:  MOVWF  00
0571E:  CLRF   01
05720:  CLRF   02
05722:  CLRF   03
05724:  MOVFF  00,31C
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
05728:  MOVF   x15,W
0572A:  MOVWF  00
0572C:  CLRF   01
0572E:  CLRF   02
05730:  CLRF   03
05732:  MOVFF  00,31D
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
05736:  MOVFF  313,A9A
0573A:  MOVLB  A
0573C:  CLRF   x9B
0573E:  MOVLW  0F
05740:  MOVWF  x9D
05742:  MOVLW  89
05744:  MOVWF  x9C
05746:  MOVLB  0
05748:  CALL   2476
0574C:  MOVFF  313,A9A
05750:  MOVLB  A
05752:  CLRF   x9B
05754:  MOVLW  0F
05756:  MOVWF  x9D
05758:  MOVLW  92
0575A:  MOVWF  x9C
0575C:  MOVLB  0
0575E:  CALL   2476
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
05762:  MOVFF  314,A97
05766:  MOVFF  313,A96
0576A:  MOVFF  312,A95
0576E:  MOVFF  311,A94
05772:  MOVLW  03
05774:  MOVLB  A
05776:  MOVWF  x99
05778:  MOVLW  19
0577A:  MOVWF  x98
0577C:  CLRF   x9B
0577E:  MOVLW  01
05780:  MOVWF  x9A
05782:  MOVLB  0
05784:  CALL   3C78
....................       output_high(flash_stream.cs_pin);
05788:  MOVFF  313,A9A
0578C:  MOVLW  01
0578E:  MOVLB  A
05790:  MOVWF  x9B
05792:  MOVLW  0F
05794:  MOVWF  x9D
05796:  MOVLW  89
05798:  MOVWF  x9C
0579A:  MOVLB  0
0579C:  CALL   2476
057A0:  MOVFF  313,A9A
057A4:  MOVLB  A
057A6:  CLRF   x9B
057A8:  MOVLW  0F
057AA:  MOVWF  x9D
057AC:  MOVLW  92
057AE:  MOVWF  x9C
057B0:  MOVLB  0
057B2:  CALL   2476
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
057B6:  MOVFF  313,A9A
057BA:  MOVLB  A
057BC:  CLRF   x9B
057BE:  MOVLW  0F
057C0:  MOVWF  x9D
057C2:  MOVLW  89
057C4:  MOVWF  x9C
057C6:  MOVLB  0
057C8:  CALL   2476
057CC:  MOVFF  313,A9A
057D0:  MOVLB  A
057D2:  CLRF   x9B
057D4:  MOVLW  0F
057D6:  MOVWF  x9D
057D8:  MOVLW  92
057DA:  MOVWF  x9C
057DC:  MOVLB  0
057DE:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
057E2:  MOVFF  314,A97
057E6:  MOVFF  313,A96
057EA:  MOVFF  312,A95
057EE:  MOVFF  311,A94
057F2:  MOVLW  03
057F4:  MOVLB  A
057F6:  MOVWF  x99
057F8:  MOVLW  1A
057FA:  MOVWF  x98
057FC:  CLRF   x9B
057FE:  MOVLW  04
05800:  MOVWF  x9A
05802:  MOVLB  0
05804:  CALL   3C78
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
05808:  MOVFF  313,A9A
0580C:  MOVLW  01
0580E:  MOVLB  A
05810:  MOVWF  x9B
05812:  MOVLW  0F
05814:  MOVWF  x9D
05816:  MOVLW  89
05818:  MOVWF  x9C
0581A:  MOVLB  0
0581C:  CALL   2476
05820:  MOVFF  313,A9A
05824:  MOVLB  A
05826:  CLRF   x9B
05828:  MOVLW  0F
0582A:  MOVWF  x9D
0582C:  MOVLW  92
0582E:  MOVWF  x9C
05830:  MOVLB  0
05832:  CALL   2476
....................    }
05836:  GOTO   59BA
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
0583A:  MOVLB  3
0583C:  DECFSZ x12,W
0583E:  BRA    5844
05840:  BRA    584A
05842:  MOVLB  0
05844:  MOVLB  0
05846:  GOTO   59BA
0584A:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
0584C:  MOVLW  06
0584E:  MOVLB  3
05850:  MOVWF  x1E
05852:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
05854:  MOVLW  21
05856:  MOVLB  3
05858:  MOVWF  x1F
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
0585A:  MOVFF  318,326
0585E:  CLRF   x27
05860:  CLRF   x28
05862:  CLRF   x29
05864:  MOVF   x26,W
05866:  MOVWF  00
05868:  CLRF   01
0586A:  CLRF   02
0586C:  CLRF   03
0586E:  MOVFF  00,320
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
05872:  MOVFF  317,326
05876:  MOVFF  318,327
0587A:  CLRF   x28
0587C:  CLRF   x29
0587E:  MOVF   x26,W
05880:  MOVWF  00
05882:  CLRF   01
05884:  CLRF   02
05886:  CLRF   03
05888:  MOVFF  00,321
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
0588C:  MOVFF  316,326
05890:  MOVFF  317,327
05894:  MOVFF  318,328
05898:  CLRF   x29
0589A:  MOVF   x26,W
0589C:  MOVWF  00
0589E:  CLRF   01
058A0:  CLRF   02
058A2:  CLRF   03
058A4:  MOVFF  00,322
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
058A8:  MOVF   x15,W
058AA:  MOVWF  00
058AC:  CLRF   01
058AE:  CLRF   02
058B0:  CLRF   03
058B2:  MOVFF  00,323
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
058B6:  MOVFF  313,A9A
058BA:  MOVLB  A
058BC:  CLRF   x9B
058BE:  MOVLW  0F
058C0:  MOVWF  x9D
058C2:  MOVLW  89
058C4:  MOVWF  x9C
058C6:  MOVLB  0
058C8:  CALL   2476
058CC:  MOVFF  313,A9A
058D0:  MOVLB  A
058D2:  CLRF   x9B
058D4:  MOVLW  0F
058D6:  MOVWF  x9D
058D8:  MOVLW  92
058DA:  MOVWF  x9C
058DC:  MOVLB  0
058DE:  CALL   2476
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
058E2:  MOVFF  314,A97
058E6:  MOVFF  313,A96
058EA:  MOVFF  312,A95
058EE:  MOVFF  311,A94
058F2:  MOVLW  03
058F4:  MOVLB  A
058F6:  MOVWF  x99
058F8:  MOVLW  1E
058FA:  MOVWF  x98
058FC:  CLRF   x9B
058FE:  MOVLW  01
05900:  MOVWF  x9A
05902:  MOVLB  0
05904:  CALL   3C78
....................       output_high(flash_stream.cs_pin);
05908:  MOVFF  313,A9A
0590C:  MOVLW  01
0590E:  MOVLB  A
05910:  MOVWF  x9B
05912:  MOVLW  0F
05914:  MOVWF  x9D
05916:  MOVLW  89
05918:  MOVWF  x9C
0591A:  MOVLB  0
0591C:  CALL   2476
05920:  MOVFF  313,A9A
05924:  MOVLB  A
05926:  CLRF   x9B
05928:  MOVLW  0F
0592A:  MOVWF  x9D
0592C:  MOVLW  92
0592E:  MOVWF  x9C
05930:  MOVLB  0
05932:  CALL   2476
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
05936:  MOVFF  313,A9A
0593A:  MOVLB  A
0593C:  CLRF   x9B
0593E:  MOVLW  0F
05940:  MOVWF  x9D
05942:  MOVLW  89
05944:  MOVWF  x9C
05946:  MOVLB  0
05948:  CALL   2476
0594C:  MOVFF  313,A9A
05950:  MOVLB  A
05952:  CLRF   x9B
05954:  MOVLW  0F
05956:  MOVWF  x9D
05958:  MOVLW  92
0595A:  MOVWF  x9C
0595C:  MOVLB  0
0595E:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
05962:  MOVFF  314,A97
05966:  MOVFF  313,A96
0596A:  MOVFF  312,A95
0596E:  MOVFF  311,A94
05972:  MOVLW  03
05974:  MOVLB  A
05976:  MOVWF  x99
05978:  MOVLW  1F
0597A:  MOVWF  x98
0597C:  CLRF   x9B
0597E:  MOVLW  05
05980:  MOVWF  x9A
05982:  MOVLB  0
05984:  CALL   3C78
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
05988:  MOVFF  313,A9A
0598C:  MOVLW  01
0598E:  MOVLB  A
05990:  MOVWF  x9B
05992:  MOVLW  0F
05994:  MOVWF  x9D
05996:  MOVLW  89
05998:  MOVWF  x9C
0599A:  MOVLB  0
0599C:  CALL   2476
059A0:  MOVFF  313,A9A
059A4:  MOVLB  A
059A6:  CLRF   x9B
059A8:  MOVLW  0F
059AA:  MOVWF  x9D
059AC:  MOVLW  92
059AE:  MOVWF  x9C
059B0:  MOVLB  0
059B2:  CALL   2476
....................    }
059B6:  GOTO   59BA
....................    
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
059BA:  MOVLB  3
059BC:  CLRF   x24
059BE:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
059C0:  MOVFF  314,A97
059C4:  MOVFF  313,A96
059C8:  MOVFF  312,A95
059CC:  MOVFF  311,A94
059D0:  CALL   3EE4
059D4:  MOVF   01,W
059D6:  ANDLW  01
059D8:  SUBLW  01
059DA:  BTFSS  FD8.2
059DC:  GOTO   5A2E
....................       if(timeout_counter > 10)
059E0:  MOVLB  3
059E2:  MOVF   x24,W
059E4:  SUBLW  0A
059E6:  BTFSS  FD8.0
059E8:  BRA    59F0
059EA:  MOVLB  0
059EC:  GOTO   5A02
059F0:  MOVLB  0
....................          delay_ms(200);
059F2:  MOVLW  C8
059F4:  MOVLB  A
059F6:  MOVWF  x94
059F8:  MOVLB  0
059FA:  CALL   1CB2
059FE:  GOTO   5A0E
....................       else
....................          delay_ms(10);   
05A02:  MOVLW  0A
05A04:  MOVLB  A
05A06:  MOVWF  x94
05A08:  MOVLB  0
05A0A:  CALL   1CB2
....................       
....................       if(timeout_counter > 100){
05A0E:  MOVLB  3
05A10:  MOVF   x24,W
05A12:  SUBLW  64
05A14:  BTFSS  FD8.0
05A16:  BRA    5A1E
05A18:  MOVLB  0
05A1A:  GOTO   5A24
05A1E:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
05A20:  GOTO   5A2E
....................       }  
....................       timeout_counter++;
05A24:  MOVLB  3
05A26:  INCF   x24,F
05A28:  MOVLB  0
05A2A:  GOTO   59C0
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
05A2E:  RETURN 0
.................... }
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................  
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
028E2:  MOVLB  3
028E4:  MOVF   x12,F
028E6:  BTFSC  FD8.2
028E8:  BRA    28F0
028EA:  MOVLB  0
028EC:  GOTO   29E2
028F0:  MOVLB  0
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
028F2:  MOVLW  03
028F4:  MOVLB  3
028F6:  MOVWF  x1F
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
028F8:  MOVFF  317,329
028FC:  MOVFF  318,32A
02900:  CLRF   x2B
02902:  CLRF   x2C
02904:  MOVF   x29,W
02906:  MOVWF  00
02908:  CLRF   01
0290A:  CLRF   02
0290C:  CLRF   03
0290E:  MOVFF  00,320
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
02912:  MOVFF  316,329
02916:  MOVFF  317,32A
0291A:  MOVFF  318,32B
0291E:  CLRF   x2C
02920:  MOVF   x29,W
02922:  MOVWF  00
02924:  CLRF   01
02926:  CLRF   02
02928:  CLRF   03
0292A:  MOVFF  00,321
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
0292E:  MOVF   x15,W
02930:  MOVWF  00
02932:  CLRF   01
02934:  CLRF   02
02936:  CLRF   03
02938:  MOVFF  00,322
....................             
....................       output_low(flash_stream.cs_pin);
0293C:  MOVFF  313,A9A
02940:  MOVLB  A
02942:  CLRF   x9B
02944:  MOVLW  0F
02946:  MOVWF  x9D
02948:  MOVLW  89
0294A:  MOVWF  x9C
0294C:  MOVLB  0
0294E:  CALL   2476
02952:  MOVFF  313,A9A
02956:  MOVLB  A
02958:  CLRF   x9B
0295A:  MOVLW  0F
0295C:  MOVWF  x9D
0295E:  MOVLW  92
02960:  MOVWF  x9C
02962:  MOVLB  0
02964:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
02968:  MOVFF  314,A9D
0296C:  MOVFF  313,A9C
02970:  MOVFF  312,A9B
02974:  MOVFF  311,A9A
02978:  MOVLW  03
0297A:  MOVLB  A
0297C:  MOVWF  x9F
0297E:  MOVLW  1F
02980:  MOVWF  x9E
02982:  CLRF   xA1
02984:  MOVLW  04
02986:  MOVWF  xA0
02988:  MOVFF  31A,AA3
0298C:  MOVFF  319,AA2
02990:  MOVFF  31E,AA7
02994:  MOVFF  31D,AA6
02998:  MOVFF  31C,AA5
0299C:  MOVFF  31B,AA4
029A0:  MOVLB  0
029A2:  CALL   25C2
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
029A6:  MOVLW  02
029A8:  MOVWF  00
029AA:  DECFSZ 00,F
029AC:  BRA    29AA
029AE:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
029B0:  MOVFF  313,A9A
029B4:  MOVLW  01
029B6:  MOVLB  A
029B8:  MOVWF  x9B
029BA:  MOVLW  0F
029BC:  MOVWF  x9D
029BE:  MOVLW  89
029C0:  MOVWF  x9C
029C2:  MOVLB  0
029C4:  CALL   2476
029C8:  MOVFF  313,A9A
029CC:  MOVLB  A
029CE:  CLRF   x9B
029D0:  MOVLW  0F
029D2:  MOVWF  x9D
029D4:  MOVLW  92
029D6:  MOVWF  x9C
029D8:  MOVLB  0
029DA:  CALL   2476
....................    }
029DE:  GOTO   2AF8
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
029E2:  MOVLB  3
029E4:  DECFSZ x12,W
029E6:  BRA    29EC
029E8:  BRA    29F2
029EA:  MOVLB  0
029EC:  MOVLB  0
029EE:  GOTO   2AF8
029F2:  MOVLB  0
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
029F4:  MOVLW  13
029F6:  MOVLB  3
029F8:  MOVWF  x23
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
029FA:  MOVFF  318,329
029FE:  CLRF   x2A
02A00:  CLRF   x2B
02A02:  CLRF   x2C
02A04:  MOVF   x29,W
02A06:  MOVWF  00
02A08:  CLRF   01
02A0A:  CLRF   02
02A0C:  CLRF   03
02A0E:  MOVFF  00,324
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
02A12:  MOVFF  317,329
02A16:  MOVFF  318,32A
02A1A:  CLRF   x2B
02A1C:  CLRF   x2C
02A1E:  MOVF   x29,W
02A20:  MOVWF  00
02A22:  CLRF   01
02A24:  CLRF   02
02A26:  CLRF   03
02A28:  MOVFF  00,325
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
02A2C:  MOVFF  316,329
02A30:  MOVFF  317,32A
02A34:  MOVFF  318,32B
02A38:  CLRF   x2C
02A3A:  MOVF   x29,W
02A3C:  MOVWF  00
02A3E:  CLRF   01
02A40:  CLRF   02
02A42:  CLRF   03
02A44:  MOVFF  00,326
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
02A48:  MOVF   x15,W
02A4A:  MOVWF  00
02A4C:  CLRF   01
02A4E:  CLRF   02
02A50:  CLRF   03
02A52:  MOVFF  00,327
....................    
....................       output_low(flash_stream.cs_pin);
02A56:  MOVFF  313,A9A
02A5A:  MOVLB  A
02A5C:  CLRF   x9B
02A5E:  MOVLW  0F
02A60:  MOVWF  x9D
02A62:  MOVLW  89
02A64:  MOVWF  x9C
02A66:  MOVLB  0
02A68:  CALL   2476
02A6C:  MOVFF  313,A9A
02A70:  MOVLB  A
02A72:  CLRF   x9B
02A74:  MOVLW  0F
02A76:  MOVWF  x9D
02A78:  MOVLW  92
02A7A:  MOVWF  x9C
02A7C:  MOVLB  0
02A7E:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
02A82:  MOVFF  314,A9D
02A86:  MOVFF  313,A9C
02A8A:  MOVFF  312,A9B
02A8E:  MOVFF  311,A9A
02A92:  MOVLW  03
02A94:  MOVLB  A
02A96:  MOVWF  x9F
02A98:  MOVLW  23
02A9A:  MOVWF  x9E
02A9C:  CLRF   xA1
02A9E:  MOVLW  05
02AA0:  MOVWF  xA0
02AA2:  MOVFF  31A,AA3
02AA6:  MOVFF  319,AA2
02AAA:  MOVFF  31E,AA7
02AAE:  MOVFF  31D,AA6
02AB2:  MOVFF  31C,AA5
02AB6:  MOVFF  31B,AA4
02ABA:  MOVLB  0
02ABC:  CALL   25C2
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
02AC0:  MOVLW  02
02AC2:  MOVWF  00
02AC4:  DECFSZ 00,F
02AC6:  BRA    2AC4
02AC8:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
02ACA:  MOVFF  313,A9A
02ACE:  MOVLW  01
02AD0:  MOVLB  A
02AD2:  MOVWF  x9B
02AD4:  MOVLW  0F
02AD6:  MOVWF  x9D
02AD8:  MOVLW  89
02ADA:  MOVWF  x9C
02ADC:  MOVLB  0
02ADE:  CALL   2476
02AE2:  MOVFF  313,A9A
02AE6:  MOVLB  A
02AE8:  CLRF   x9B
02AEA:  MOVLW  0F
02AEC:  MOVWF  x9D
02AEE:  MOVLW  92
02AF0:  MOVWF  x9C
02AF2:  MOVLB  0
02AF4:  CALL   2476
....................    }
....................    return;
02AF8:  RETURN 0
.................... }
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
....................  
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
*
03F84:  MOVLB  A
03F86:  MOVF   x7D,F
03F88:  BTFSC  FD8.2
03F8A:  BRA    3F92
03F8C:  MOVLB  0
03F8E:  GOTO   4100
03F92:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
03F94:  MOVLW  06
03F96:  MOVLB  A
03F98:  MOVWF  x88
03F9A:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
03F9C:  MOVLW  02
03F9E:  MOVLB  A
03FA0:  MOVWF  x89
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
03FA2:  MOVFF  A82,A95
03FA6:  MOVFF  A83,A96
03FAA:  CLRF   x97
03FAC:  CLRF   x98
03FAE:  MOVF   x95,W
03FB0:  MOVWF  00
03FB2:  CLRF   01
03FB4:  CLRF   02
03FB6:  CLRF   03
03FB8:  MOVFF  00,A8A
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
03FBC:  MOVFF  A81,A95
03FC0:  MOVFF  A82,A96
03FC4:  MOVFF  A83,A97
03FC8:  CLRF   x98
03FCA:  MOVF   x95,W
03FCC:  MOVWF  00
03FCE:  CLRF   01
03FD0:  CLRF   02
03FD2:  CLRF   03
03FD4:  MOVFF  00,A8B
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
03FD8:  MOVF   x80,W
03FDA:  MOVWF  00
03FDC:  CLRF   01
03FDE:  CLRF   02
03FE0:  CLRF   03
03FE2:  MOVFF  00,A8C
.................... 
....................       //fprintf(PC, "address:0x%08LX\r\n", write_start_address);
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
03FE6:  MOVFF  A7E,A9A
03FEA:  CLRF   x9B
03FEC:  MOVLW  0F
03FEE:  MOVWF  x9D
03FF0:  MOVLW  89
03FF2:  MOVWF  x9C
03FF4:  MOVLB  0
03FF6:  CALL   2476
03FFA:  MOVFF  A7E,A9A
03FFE:  MOVLB  A
04000:  CLRF   x9B
04002:  MOVLW  0F
04004:  MOVWF  x9D
04006:  MOVLW  92
04008:  MOVWF  x9C
0400A:  MOVLB  0
0400C:  CALL   2476
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
04010:  MOVFF  A7F,A97
04014:  MOVFF  A7E,A96
04018:  MOVFF  A7D,A95
0401C:  MOVFF  A7C,A94
04020:  MOVLW  0A
04022:  MOVLB  A
04024:  MOVWF  x99
04026:  MOVLW  88
04028:  MOVWF  x98
0402A:  CLRF   x9B
0402C:  MOVLW  01
0402E:  MOVWF  x9A
04030:  MOVLB  0
04032:  CALL   3C78
....................       output_high(flash_stream.cs_pin);
04036:  MOVFF  A7E,A9A
0403A:  MOVLW  01
0403C:  MOVLB  A
0403E:  MOVWF  x9B
04040:  MOVLW  0F
04042:  MOVWF  x9D
04044:  MOVLW  89
04046:  MOVWF  x9C
04048:  MOVLB  0
0404A:  CALL   2476
0404E:  MOVFF  A7E,A9A
04052:  MOVLB  A
04054:  CLRF   x9B
04056:  MOVLW  0F
04058:  MOVWF  x9D
0405A:  MOVLW  92
0405C:  MOVWF  x9C
0405E:  MOVLB  0
04060:  CALL   2476
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
04064:  MOVFF  A7E,A9A
04068:  MOVLB  A
0406A:  CLRF   x9B
0406C:  MOVLW  0F
0406E:  MOVWF  x9D
04070:  MOVLW  89
04072:  MOVWF  x9C
04074:  MOVLB  0
04076:  CALL   2476
0407A:  MOVFF  A7E,A9A
0407E:  MOVLB  A
04080:  CLRF   x9B
04082:  MOVLW  0F
04084:  MOVWF  x9D
04086:  MOVLW  92
04088:  MOVWF  x9C
0408A:  MOVLB  0
0408C:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
04090:  MOVFF  A7F,A97
04094:  MOVFF  A7E,A96
04098:  MOVFF  A7D,A95
0409C:  MOVFF  A7C,A94
040A0:  MOVLW  0A
040A2:  MOVLB  A
040A4:  MOVWF  x99
040A6:  MOVLW  89
040A8:  MOVWF  x98
040AA:  MOVLW  04
040AC:  MOVWF  x9A
040AE:  MOVFF  A85,A9C
040B2:  MOVFF  A84,A9B
040B6:  MOVFF  A87,A9E
040BA:  MOVFF  A86,A9D
040BE:  MOVLB  0
040C0:  CALL   3D68
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
040C4:  MOVLW  02
040C6:  MOVWF  00
040C8:  DECFSZ 00,F
040CA:  BRA    40C8
040CC:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
040CE:  MOVFF  A7E,A9A
040D2:  MOVLW  01
040D4:  MOVLB  A
040D6:  MOVWF  x9B
040D8:  MOVLW  0F
040DA:  MOVWF  x9D
040DC:  MOVLW  89
040DE:  MOVWF  x9C
040E0:  MOVLB  0
040E2:  CALL   2476
040E6:  MOVFF  A7E,A9A
040EA:  MOVLB  A
040EC:  CLRF   x9B
040EE:  MOVLW  0F
040F0:  MOVWF  x9D
040F2:  MOVLW  92
040F4:  MOVWF  x9C
040F6:  MOVLB  0
040F8:  CALL   2476
....................    }
040FC:  GOTO   4292
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
04100:  MOVLB  A
04102:  DECFSZ x7D,W
04104:  BRA    410A
04106:  BRA    4110
04108:  MOVLB  0
0410A:  MOVLB  0
0410C:  GOTO   4292
04110:  MOVLB  0
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
04112:  MOVLW  06
04114:  MOVLB  A
04116:  MOVWF  x8D
04118:  MOVLB  0
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
0411A:  MOVLW  12
0411C:  MOVLB  A
0411E:  MOVWF  x8E
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
04120:  MOVFF  A83,A95
04124:  CLRF   x96
04126:  CLRF   x97
04128:  CLRF   x98
0412A:  MOVF   x95,W
0412C:  MOVWF  00
0412E:  CLRF   01
04130:  CLRF   02
04132:  CLRF   03
04134:  MOVFF  00,A8F
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
04138:  MOVFF  A82,A95
0413C:  MOVFF  A83,A96
04140:  CLRF   x97
04142:  CLRF   x98
04144:  MOVF   x95,W
04146:  MOVWF  00
04148:  CLRF   01
0414A:  CLRF   02
0414C:  CLRF   03
0414E:  MOVFF  00,A90
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
04152:  MOVFF  A81,A95
04156:  MOVFF  A82,A96
0415A:  MOVFF  A83,A97
0415E:  CLRF   x98
04160:  MOVF   x95,W
04162:  MOVWF  00
04164:  CLRF   01
04166:  CLRF   02
04168:  CLRF   03
0416A:  MOVFF  00,A91
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
0416E:  MOVF   x80,W
04170:  MOVWF  00
04172:  CLRF   01
04174:  CLRF   02
04176:  CLRF   03
04178:  MOVFF  00,A92
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
0417C:  MOVFF  A7E,A9A
04180:  CLRF   x9B
04182:  MOVLW  0F
04184:  MOVWF  x9D
04186:  MOVLW  89
04188:  MOVWF  x9C
0418A:  MOVLB  0
0418C:  CALL   2476
04190:  MOVFF  A7E,A9A
04194:  MOVLB  A
04196:  CLRF   x9B
04198:  MOVLW  0F
0419A:  MOVWF  x9D
0419C:  MOVLW  92
0419E:  MOVWF  x9C
041A0:  MOVLB  0
041A2:  CALL   2476
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
041A6:  MOVFF  A7F,A97
041AA:  MOVFF  A7E,A96
041AE:  MOVFF  A7D,A95
041B2:  MOVFF  A7C,A94
041B6:  MOVLW  0A
041B8:  MOVLB  A
041BA:  MOVWF  x99
041BC:  MOVLW  8D
041BE:  MOVWF  x98
041C0:  CLRF   x9B
041C2:  MOVLW  01
041C4:  MOVWF  x9A
041C6:  MOVLB  0
041C8:  CALL   3C78
....................       output_high(flash_stream.cs_pin);
041CC:  MOVFF  A7E,A9A
041D0:  MOVLW  01
041D2:  MOVLB  A
041D4:  MOVWF  x9B
041D6:  MOVLW  0F
041D8:  MOVWF  x9D
041DA:  MOVLW  89
041DC:  MOVWF  x9C
041DE:  MOVLB  0
041E0:  CALL   2476
041E4:  MOVFF  A7E,A9A
041E8:  MOVLB  A
041EA:  CLRF   x9B
041EC:  MOVLW  0F
041EE:  MOVWF  x9D
041F0:  MOVLW  92
041F2:  MOVWF  x9C
041F4:  MOVLB  0
041F6:  CALL   2476
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
041FA:  MOVFF  A7E,A9A
041FE:  MOVLB  A
04200:  CLRF   x9B
04202:  MOVLW  0F
04204:  MOVWF  x9D
04206:  MOVLW  89
04208:  MOVWF  x9C
0420A:  MOVLB  0
0420C:  CALL   2476
04210:  MOVFF  A7E,A9A
04214:  MOVLB  A
04216:  CLRF   x9B
04218:  MOVLW  0F
0421A:  MOVWF  x9D
0421C:  MOVLW  92
0421E:  MOVWF  x9C
04220:  MOVLB  0
04222:  CALL   2476
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
04226:  MOVFF  A7F,A97
0422A:  MOVFF  A7E,A96
0422E:  MOVFF  A7D,A95
04232:  MOVFF  A7C,A94
04236:  MOVLW  0A
04238:  MOVLB  A
0423A:  MOVWF  x99
0423C:  MOVLW  8E
0423E:  MOVWF  x98
04240:  MOVLW  05
04242:  MOVWF  x9A
04244:  MOVFF  A85,A9C
04248:  MOVFF  A84,A9B
0424C:  MOVFF  A87,A9E
04250:  MOVFF  A86,A9D
04254:  MOVLB  0
04256:  CALL   3D68
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
0425A:  MOVLW  02
0425C:  MOVWF  00
0425E:  DECFSZ 00,F
04260:  BRA    425E
04262:  NOP   
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
04264:  MOVFF  A7E,A9A
04268:  MOVLW  01
0426A:  MOVLB  A
0426C:  MOVWF  x9B
0426E:  MOVLW  0F
04270:  MOVWF  x9D
04272:  MOVLW  89
04274:  MOVWF  x9C
04276:  MOVLB  0
04278:  CALL   2476
0427C:  MOVFF  A7E,A9A
04280:  MOVLB  A
04282:  CLRF   x9B
04284:  MOVLW  0F
04286:  MOVWF  x9D
04288:  MOVLW  92
0428A:  MOVWF  x9C
0428C:  MOVLB  0
0428E:  CALL   2476
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
04292:  MOVLB  A
04294:  CLRF   x93
04296:  MOVLB  0
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
04298:  MOVFF  A7F,A97
0429C:  MOVFF  A7E,A96
042A0:  MOVFF  A7D,A95
042A4:  MOVFF  A7C,A94
042A8:  CALL   3EE4
042AC:  MOVF   01,W
042AE:  ANDLW  01
042B0:  SUBLW  01
042B2:  BTFSS  FD8.2
042B4:  GOTO   4306
....................       if(timeout_counter > 10)
042B8:  MOVLB  A
042BA:  MOVF   x93,W
042BC:  SUBLW  0A
042BE:  BTFSS  FD8.0
042C0:  BRA    42C8
042C2:  MOVLB  0
042C4:  GOTO   42DA
042C8:  MOVLB  0
....................          delay_ms(200);
042CA:  MOVLW  C8
042CC:  MOVLB  A
042CE:  MOVWF  x94
042D0:  MOVLB  0
042D2:  CALL   1CB2
042D6:  GOTO   42E6
....................       else
....................          delay_ms(10);   
042DA:  MOVLW  0A
042DC:  MOVLB  A
042DE:  MOVWF  x94
042E0:  MOVLB  0
042E2:  CALL   1CB2
....................       
....................       if(timeout_counter > 100){
042E6:  MOVLB  A
042E8:  MOVF   x93,W
042EA:  SUBLW  64
042EC:  BTFSS  FD8.0
042EE:  BRA    42F6
042F0:  MOVLB  0
042F2:  GOTO   42FC
042F6:  MOVLB  0
....................          #ifdef MT25Q_DEBUG
....................             fprintf(PC,"flash timeout\r\n");
....................          #endif
....................          break;
042F8:  GOTO   4306
....................       }  
....................       timeout_counter++;
042FC:  MOVLB  A
042FE:  INCF   x93,F
04300:  MOVLB  0
04302:  GOTO   4298
....................    }
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"flash write complete\r\n");
....................    #endif
....................    return;
04306:  RETURN 0
.................... }
.................... 
....................  
.................... int1 is_connect(Flash flash_stream){
*
027F6:  MOVLW  9F
027F8:  MOVLB  2
027FA:  MOVWF  xA7
....................    READ_ID_DATA read_id_data;
....................    int8 flash_cmd = CMD_READ_ID;
....................    output_low(flash_stream.cs_pin);
027FC:  MOVFF  291,A9A
02800:  MOVLB  A
02802:  CLRF   x9B
02804:  MOVLW  0F
02806:  MOVWF  x9D
02808:  MOVLW  89
0280A:  MOVWF  x9C
0280C:  MOVLB  0
0280E:  CALL   2476
02812:  MOVFF  291,A9A
02816:  MOVLB  A
02818:  CLRF   x9B
0281A:  MOVLW  0F
0281C:  MOVWF  x9D
0281E:  MOVLW  92
02820:  MOVWF  x9C
02822:  MOVLB  0
02824:  CALL   2476
....................    delay_us(10);  
02828:  MOVLW  0D
0282A:  MOVWF  00
0282C:  DECFSZ 00,F
0282E:  BRA    282C
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, read_id_data.bytes, sizeof(read_id_data.bytes));
02830:  MOVFF  292,A9D
02834:  MOVFF  291,A9C
02838:  MOVFF  290,A9B
0283C:  MOVFF  28F,A9A
02840:  MOVLW  02
02842:  MOVLB  A
02844:  MOVWF  x9F
02846:  MOVLW  A7
02848:  MOVWF  x9E
0284A:  CLRF   xA1
0284C:  MOVLW  01
0284E:  MOVWF  xA0
02850:  MOVLW  02
02852:  MOVWF  xA3
02854:  MOVLW  93
02856:  MOVWF  xA2
02858:  CLRF   xA7
0285A:  CLRF   xA6
0285C:  CLRF   xA5
0285E:  MOVLW  14
02860:  MOVWF  xA4
02862:  MOVLB  0
02864:  CALL   25C2
....................    output_high(flash_stream.cs_pin);
02868:  MOVFF  291,A9A
0286C:  MOVLW  01
0286E:  MOVLB  A
02870:  MOVWF  x9B
02872:  MOVLW  0F
02874:  MOVWF  x9D
02876:  MOVLW  89
02878:  MOVWF  x9C
0287A:  MOVLB  0
0287C:  CALL   2476
02880:  MOVFF  291,A9A
02884:  MOVLB  A
02886:  CLRF   x9B
02888:  MOVLW  0F
0288A:  MOVWF  x9D
0288C:  MOVLW  92
0288E:  MOVWF  x9C
02890:  MOVLB  0
02892:  CALL   2476
....................    //fprintf(PC,"Read ID:%02X", read_id_data.fields.manufacturer_id);
....................    #ifdef MT25Q_DEBUG
....................       fprintf(PC,"Read ID:");
.................... 
....................    #endif
....................    //chip id check
....................    if(read_id_data.fields.manufacturer_id == MANUFACTURER_ID_MICRON){  
02896:  MOVLB  2
02898:  MOVF   x93,W
0289A:  SUBLW  20
0289C:  BTFSC  FD8.2
0289E:  BRA    28A6
028A0:  MOVLB  0
028A2:  GOTO   28B4
028A6:  MOVLB  0
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash connect OK\r\n");
....................       #endif
....................       return true;
028A8:  MOVLW  01
028AA:  MOVWF  01
028AC:  GOTO   28BC
....................    }
028B0:  GOTO   28BC
....................    else{
....................       #ifdef MT25Q_DEBUG
....................          fprintf(PC,"flash not connect\r\n");
....................       #endif
....................       return false;
028B4:  MOVLW  00
028B6:  MOVWF  01
028B8:  GOTO   28BC
....................    }
028BC:  RETURN 0
.................... }
.................... 
.................... #include "../lib/tool/calc_tools.c"
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size)
.................... {
....................    if (payload_size <= 0) return 0;
*
02AFA:  MOVLB  A
02AFC:  MOVF   xDD,F
02AFE:  BTFSC  FD8.2
02B00:  BRA    2B08
02B02:  MOVLB  0
02B04:  GOTO   2B12
02B08:  MOVLB  0
02B0A:  MOVLW  00
02B0C:  MOVWF  01
02B0E:  GOTO   2B64
.................... 
....................    unsigned int8 crc = *frame++;
02B12:  MOVLB  A
02B14:  MOVF   xDC,W
02B16:  MOVWF  03
02B18:  MOVF   xDB,W
02B1A:  INCF   xDB,F
02B1C:  BTFSC  FD8.2
02B1E:  INCF   xDC,F
02B20:  MOVWF  FE9
02B22:  MOVFF  03,FEA
02B26:  MOVFF  FEF,ADE
02B2A:  MOVLB  0
....................    while (--payload_size > 0)
02B2C:  MOVLB  A
02B2E:  DECF   xDD,F
02B30:  MOVF   xDD,F
02B32:  BTFSS  FD8.2
02B34:  BRA    2B3C
02B36:  MOVLB  0
02B38:  GOTO   2B5C
02B3C:  MOVLB  0
....................       crc ^= *frame++;
02B3E:  MOVLB  A
02B40:  MOVF   xDC,W
02B42:  MOVWF  03
02B44:  MOVF   xDB,W
02B46:  INCF   xDB,F
02B48:  BTFSC  FD8.2
02B4A:  INCF   xDC,F
02B4C:  MOVWF  FE9
02B4E:  MOVFF  03,FEA
02B52:  MOVF   FEF,W
02B54:  XORWF  xDE,F
02B56:  MOVLB  0
02B58:  GOTO   2B2C
.................... 
....................    return crc;
02B5C:  MOVLB  A
02B5E:  MOVF   xDE,W
02B60:  MOVWF  01
02B62:  MOVLB  0
02B64:  RETURN 0
.................... }
.................... 
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size)
*
0A74A:  MOVLW  01
0A74C:  MOVLB  3
0A74E:  SUBWF  x13,W
0A750:  ADDWF  x11,W
0A752:  MOVWF  FE9
0A754:  MOVLW  00
0A756:  ADDWFC x12,W
0A758:  MOVWF  FEA
0A75A:  MOVFF  FEF,314
0A75E:  MOVLW  01
0A760:  SUBWF  x13,W
0A762:  MOVWF  x16
0A764:  MOVFF  312,ADC
0A768:  MOVFF  311,ADB
0A76C:  MOVFF  316,ADD
0A770:  MOVLB  0
0A772:  CALL   2AFA
0A776:  MOVFF  01,315
.................... {
....................    unsigned int8 received_crc = frame[payload_size - 1]; // CRC is the last byte
....................    unsigned int8 calculated_crc = calc_crc8(frame, payload_size - 1);
....................    return (received_crc == calculated_crc);
0A77A:  MOVLB  3
0A77C:  MOVF   x15,W
0A77E:  SUBWF  x14,W
0A780:  BTFSS  FD8.2
0A782:  BRA    A78A
0A784:  MOVLB  0
0A786:  GOTO   A792
0A78A:  MOVLB  0
0A78C:  MOVLW  00
0A78E:  GOTO   A794
0A792:  MOVLW  01
0A794:  MOVWF  01
0A796:  RETURN 0
.................... }
.................... 
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index)
.................... {
....................     buf[index + 0] = (int8)(value >> 24);   // MSB
....................     buf[index + 1] = (int8)(value >> 16);
....................     buf[index + 2] = (int8)(value >>  8);
....................     buf[index + 3] = (int8)(value      );   // LSB
.................... }
.................... 
.................... int32 lsb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] <<  0) |
....................            ((int32)buf[index + 1] <<  8) |
....................            ((int32)buf[index + 2] << 16) |
....................            ((int32)buf[index + 3] << 24);
.................... }
.................... 
.................... 
.................... int32 msb_array_to_int32(int8 *buf, int8 index)
.................... {
....................     return ((int32)buf[index + 0] << 24) |
....................            ((int32)buf[index + 1] << 16) |
....................            ((int32)buf[index + 2] <<  8) |
....................            ((int32)buf[index + 3]);
.................... }
.................... 
.................... unsigned int32 int32_lsb_to_msb(unsigned int32 value)
.................... {
....................     return ((value & 0x000000FF) << 24) |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0xFF000000) >> 24);
.................... }
.................... 
.................... unsigned int32 int32_msb_to_lsb(unsigned int32 value)
.................... {
....................     return ((value & 0xFF000000) >> 24) |
....................            ((value & 0x00FF0000) >> 8)  |
....................            ((value & 0x0000FF00) << 8)  |
....................            ((value & 0x000000FF) << 24);
.................... }
.................... // End of file
.................... 
.................... #include "../lib/tool/smf_queue.c"
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "mmj_smf_memorymap.h"
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data)
.................... {   
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
*
095E2:  MOVLW  36
095E4:  MOVWF  FF6
095E6:  MOVLW  03
095E8:  MOVWF  FF7
095EA:  MOVLW  00
095EC:  MOVWF  FF8
095EE:  CALL   1D32
....................    int8 next_tail = (flash_queue.tail_index + 1) % SMF_QUEUE_SIZE;
095F2:  MOVLW  01
095F4:  MOVLB  1
095F6:  ADDWF  x0D,W
095F8:  ANDLW  0F
095FA:  MOVWF  xDC
.................... 
....................    if(next_tail == flash_queue.head_index)
095FC:  MOVF   x0C,W
095FE:  SUBWF  xDC,W
09600:  BTFSC  FD8.2
09602:  BRA    960A
09604:  MOVLB  0
09606:  GOTO   9620
0960A:  MOVLB  0
....................       printf("Flash queue is full!!!\r\n");
0960C:  MOVLW  50
0960E:  MOVWF  FF6
09610:  MOVLW  03
09612:  MOVWF  FF7
09614:  MOVLW  00
09616:  MOVWF  FF8
09618:  CALL   1D32
0961C:  GOTO   983E
....................       
....................    else
....................    {
....................       flash_queue.entries[flash_queue.tail_index].mission_id = data->mission_id;
09620:  MOVLB  1
09622:  MOVF   x0D,W
09624:  MULLW  0C
09626:  MOVF   FF3,W
09628:  CLRF   xDE
0962A:  MOVWF  xDD
0962C:  MOVLW  4C
0962E:  ADDWF  xDD,W
09630:  MOVWF  01
09632:  MOVLW  00
09634:  ADDWFC xDE,W
09636:  MOVWF  03
09638:  MOVF   01,W
0963A:  MOVWF  xDF
0963C:  MOVFF  03,1E0
09640:  MOVF   xDA,W
09642:  MOVWF  FE9
09644:  MOVF   xDB,W
09646:  MOVWF  FEA
09648:  MOVF   FEF,W
0964A:  MOVWF  xE1
0964C:  MOVFF  1E0,FEA
09650:  MOVFF  1DF,FE9
09654:  MOVFF  1E1,FEF
....................       flash_queue.entries[flash_queue.tail_index].func_type  = data->func_type;
09658:  MOVF   x0D,W
0965A:  MULLW  0C
0965C:  MOVF   FF3,W
0965E:  CLRF   xDE
09660:  MOVWF  xDD
09662:  MOVLW  01
09664:  ADDWF  xDD,W
09666:  MOVWF  01
09668:  MOVLW  00
0966A:  ADDWFC xDE,W
0966C:  MOVWF  03
0966E:  MOVF   01,W
09670:  ADDLW  4C
09672:  MOVWF  01
09674:  MOVLW  00
09676:  ADDWFC 03,F
09678:  MOVF   01,W
0967A:  MOVWF  xDD
0967C:  MOVFF  03,1DE
09680:  MOVLW  01
09682:  ADDWF  xDA,W
09684:  MOVWF  FE9
09686:  MOVLW  00
09688:  ADDWFC xDB,W
0968A:  MOVWF  FEA
0968C:  MOVF   FEF,W
0968E:  MOVWF  xDF
09690:  MOVFF  1DE,FEA
09694:  MOVFF  1DD,FE9
09698:  MOVFF  1DF,FEF
....................       flash_queue.entries[flash_queue.tail_index].write_mode = data->write_mode;
0969C:  MOVF   x0D,W
0969E:  MULLW  0C
096A0:  MOVF   FF3,W
096A2:  CLRF   xDE
096A4:  MOVWF  xDD
096A6:  MOVLW  02
096A8:  ADDWF  xDD,W
096AA:  MOVWF  01
096AC:  MOVLW  00
096AE:  ADDWFC xDE,W
096B0:  MOVWF  03
096B2:  MOVF   01,W
096B4:  ADDLW  4C
096B6:  MOVWF  01
096B8:  MOVLW  00
096BA:  ADDWFC 03,F
096BC:  MOVF   01,W
096BE:  MOVWF  xDD
096C0:  MOVFF  03,1DE
096C4:  MOVLW  02
096C6:  ADDWF  xDA,W
096C8:  MOVWF  FE9
096CA:  MOVLW  00
096CC:  ADDWFC xDB,W
096CE:  MOVWF  FEA
096D0:  MOVF   FEF,W
096D2:  MOVWF  xDF
096D4:  MOVFF  1DE,FEA
096D8:  MOVFF  1DD,FE9
096DC:  MOVFF  1DF,FEF
....................       flash_queue.entries[flash_queue.tail_index].source_type = data->source_type;
096E0:  MOVF   x0D,W
096E2:  MULLW  0C
096E4:  MOVF   FF3,W
096E6:  CLRF   xDE
096E8:  MOVWF  xDD
096EA:  MOVLW  03
096EC:  ADDWF  xDD,W
096EE:  MOVWF  01
096F0:  MOVLW  00
096F2:  ADDWFC xDE,W
096F4:  MOVWF  03
096F6:  MOVF   01,W
096F8:  ADDLW  4C
096FA:  MOVWF  01
096FC:  MOVLW  00
096FE:  ADDWFC 03,F
09700:  MOVF   01,W
09702:  MOVWF  xDD
09704:  MOVFF  03,1DE
09708:  MOVLW  03
0970A:  ADDWF  xDA,W
0970C:  MOVWF  01
0970E:  MOVLW  00
09710:  ADDWFC xDB,W
09712:  MOVWF  03
09714:  MOVF   01,W
09716:  MOVWF  FE9
09718:  MOVFF  03,FEA
0971C:  MOVLW  00
0971E:  BTFSC  FEF.0
09720:  MOVLW  01
09722:  MOVWF  01
09724:  BTFSS  01.0
09726:  BRA    972E
09728:  MOVLB  0
0972A:  GOTO   973E
0972E:  MOVLB  0
09730:  MOVFF  1DE,FEA
09734:  MOVFF  1DD,FE9
09738:  BCF    FEF.0
0973A:  GOTO   9748
0973E:  MOVFF  1DE,FEA
09742:  MOVFF  1DD,FE9
09746:  BSF    FEF.0
....................       flash_queue.entries[flash_queue.tail_index].misf_start_addr = data->misf_start_addr;
09748:  MOVLB  1
0974A:  MOVF   x0D,W
0974C:  MULLW  0C
0974E:  MOVF   FF3,W
09750:  CLRF   xDE
09752:  MOVWF  xDD
09754:  MOVLW  04
09756:  ADDWF  xDD,W
09758:  MOVWF  01
0975A:  MOVLW  00
0975C:  ADDWFC xDE,W
0975E:  MOVWF  03
09760:  MOVF   01,W
09762:  ADDLW  4C
09764:  MOVWF  01
09766:  MOVLW  00
09768:  ADDWFC 03,F
0976A:  MOVF   01,W
0976C:  MOVWF  xDD
0976E:  MOVFF  03,1DE
09772:  MOVLW  04
09774:  ADDWF  xDA,W
09776:  MOVWF  FE9
09778:  MOVLW  00
0977A:  ADDWFC xDB,W
0977C:  MOVWF  FEA
0977E:  MOVFF  FEF,00
09782:  MOVFF  FEC,01
09786:  MOVFF  FEC,02
0978A:  MOVFF  FEC,03
0978E:  MOVF   FED,F
09790:  MOVF   FED,F
09792:  MOVF   FED,F
09794:  MOVFF  03,1E2
09798:  MOVFF  02,1E1
0979C:  MOVFF  01,1E0
097A0:  MOVFF  00,1DF
097A4:  MOVFF  1DE,FEA
097A8:  MOVFF  1DD,FE9
097AC:  MOVFF  1DF,FEF
097B0:  MOVFF  1E0,FEC
097B4:  MOVFF  1E1,FEC
097B8:  MOVFF  1E2,FEC
097BC:  MOVF   FED,F
097BE:  MOVF   FED,F
097C0:  MOVF   FED,F
....................       flash_queue.entries[flash_queue.tail_index].misf_size = data->misf_size;
097C2:  MOVF   x0D,W
097C4:  MULLW  0C
097C6:  MOVF   FF3,W
097C8:  CLRF   xDE
097CA:  MOVWF  xDD
097CC:  MOVLW  08
097CE:  ADDWF  xDD,W
097D0:  MOVWF  01
097D2:  MOVLW  00
097D4:  ADDWFC xDE,W
097D6:  MOVWF  03
097D8:  MOVF   01,W
097DA:  ADDLW  4C
097DC:  MOVWF  01
097DE:  MOVLW  00
097E0:  ADDWFC 03,F
097E2:  MOVF   01,W
097E4:  MOVWF  xDD
097E6:  MOVFF  03,1DE
097EA:  MOVLW  08
097EC:  ADDWF  xDA,W
097EE:  MOVWF  FE9
097F0:  MOVLW  00
097F2:  ADDWFC xDB,W
097F4:  MOVWF  FEA
097F6:  MOVFF  FEF,00
097FA:  MOVFF  FEC,01
097FE:  MOVFF  FEC,02
09802:  MOVFF  FEC,03
09806:  MOVF   FED,F
09808:  MOVF   FED,F
0980A:  MOVF   FED,F
0980C:  MOVFF  03,1E2
09810:  MOVFF  02,1E1
09814:  MOVFF  01,1E0
09818:  MOVFF  00,1DF
0981C:  MOVFF  1DE,FEA
09820:  MOVFF  1DD,FE9
09824:  MOVFF  1DF,FEF
09828:  MOVFF  1E0,FEC
0982C:  MOVFF  1E1,FEC
09830:  MOVFF  1E2,FEC
09834:  MOVF   FED,F
09836:  MOVF   FED,F
09838:  MOVF   FED,F
....................       flash_queue.tail_index = next_tail;
0983A:  MOVFF  1DC,10D
0983E:  MOVLB  0
....................    }
09840:  GOTO   9D7C (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... FlashOperationStruct *dequeue_flash_operation()
.................... {
....................    if (flash_queue.head_index == flash_queue.tail_index)
*
0A10C:  MOVLB  1
0A10E:  MOVF   x0D,W
0A110:  SUBWF  x0C,W
0A112:  BTFSC  FD8.2
0A114:  BRA    A11C
0A116:  MOVLB  0
0A118:  GOTO   A13E
0A11C:  MOVLB  0
....................    {
....................       printf("Flash queue is empty\r\n");
0A11E:  MOVLW  6A
0A120:  MOVWF  FF6
0A122:  MOVLW  03
0A124:  MOVWF  FF7
0A126:  MOVLW  00
0A128:  MOVWF  FF8
0A12A:  CALL   1D32
....................       return 0x00;
0A12E:  MOVLW  00
0A130:  MOVWF  01
0A132:  MOVLW  00
0A134:  MOVWF  02
0A136:  GOTO   A16A
....................    }
0A13A:  GOTO   A16A
....................    else
....................    {
....................       int8 current_head = flash_queue.head_index;
0A13E:  MOVFF  10C,1BA
....................       flash_queue.head_index = (flash_queue.head_index + 1) % SMF_QUEUE_SIZE;
0A142:  MOVLW  01
0A144:  MOVLB  1
0A146:  ADDWF  x0C,W
0A148:  ANDLW  0F
0A14A:  MOVWF  x0C
.................... 
.................... 
....................       return &flash_queue.entries[current_head];
0A14C:  MOVF   xBA,W
0A14E:  MULLW  0C
0A150:  MOVF   FF3,W
0A152:  CLRF   03
0A154:  ADDLW  4C
0A156:  MOVWF  01
0A158:  MOVLW  00
0A15A:  ADDWFC 03,F
0A15C:  MOVF   01,W
0A15E:  MOVWF  01
0A160:  MOVF   03,W
0A162:  MOVWF  02
0A164:  MOVLB  0
0A166:  GOTO   A16A
....................    }
0A16A:  GOTO   BFB2 (RETURN)
.................... }
.................... 
.................... int1 is_empty_flash_queue(void)
.................... {
....................    return flash_queue.head_index == flash_queue.tail_index;
*
0A016:  MOVLB  1
0A018:  MOVF   x0D,W
0A01A:  SUBWF  x0C,W
0A01C:  BTFSS  FD8.2
0A01E:  BRA    A026
0A020:  MOVLB  0
0A022:  GOTO   A02E
0A026:  MOVLB  0
0A028:  MOVLW  00
0A02A:  GOTO   A030
0A02E:  MOVLW  01
0A030:  MOVWF  01
0A032:  RETURN 0
.................... }
.................... 
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id)
.................... {
....................    SmfAddressStruct mis_struct = {0};
*
0A4B6:  MOVLB  2
0A4B8:  CLRF   x97
0A4BA:  CLRF   x98
0A4BC:  CLRF   x99
0A4BE:  CLRF   x9A
0A4C0:  CLRF   x9B
0A4C2:  CLRF   x9C
0A4C4:  CLRF   x9D
0A4C6:  CLRF   x9E
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0A4C8:  MOVF   x96,F
0A4CA:  BTFSC  FD8.2
0A4CC:  BRA    A4D4
0A4CE:  MOVLB  0
0A4D0:  GOTO   A4F8
0A4D4:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_DATA_TABLE_START_ADDRESS;
0A4D6:  MOVLW  06
0A4D8:  MOVLB  2
0A4DA:  MOVWF  x9A
0A4DC:  MOVLW  AA
0A4DE:  MOVWF  x99
0A4E0:  CLRF   x98
0A4E2:  CLRF   x97
....................       mis_struct.end_address   = CIGS_DATA_TABLE_END_ADDRESS;
0A4E4:  MOVLW  06
0A4E6:  MOVWF  x9E
0A4E8:  MOVLW  AA
0A4EA:  MOVWF  x9D
0A4EC:  MOVLW  0F
0A4EE:  MOVWF  x9C
0A4F0:  SETF   x9B
0A4F2:  MOVLB  0
....................    }
0A4F4:  GOTO   A638
....................    else if (mission_id == CIGS_PICLOG_DATA)
0A4F8:  MOVLB  2
0A4FA:  DECFSZ x96,W
0A4FC:  BRA    A502
0A4FE:  BRA    A508
0A500:  MOVLB  0
0A502:  MOVLB  0
0A504:  GOTO   A52E
0A508:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
0A50A:  MOVLW  06
0A50C:  MOVLB  2
0A50E:  MOVWF  x9A
0A510:  MOVLW  AA
0A512:  MOVWF  x99
0A514:  MOVLW  10
0A516:  MOVWF  x98
0A518:  CLRF   x97
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
0A51A:  MOVLW  06
0A51C:  MOVWF  x9E
0A51E:  MOVLW  AA
0A520:  MOVWF  x9D
0A522:  MOVLW  1F
0A524:  MOVWF  x9C
0A526:  SETF   x9B
0A528:  MOVLB  0
....................    }
0A52A:  GOTO   A638
....................    else if (mission_id == CIGS_ENVIRO_DATA)
0A52E:  MOVLB  2
0A530:  MOVF   x96,W
0A532:  SUBLW  02
0A534:  BTFSC  FD8.2
0A536:  BRA    A53E
0A538:  MOVLB  0
0A53A:  GOTO   A564
0A53E:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_PICLOG_START_ADDRESS;
0A540:  MOVLW  06
0A542:  MOVLB  2
0A544:  MOVWF  x9A
0A546:  MOVLW  AA
0A548:  MOVWF  x99
0A54A:  MOVLW  10
0A54C:  MOVWF  x98
0A54E:  CLRF   x97
....................       mis_struct.end_address   = CIGS_PICLOG_END_ADDRESS;
0A550:  MOVLW  06
0A552:  MOVWF  x9E
0A554:  MOVLW  AA
0A556:  MOVWF  x9D
0A558:  MOVLW  1F
0A55A:  MOVWF  x9C
0A55C:  SETF   x9B
0A55E:  MOVLB  0
....................    }
0A560:  GOTO   A638
....................    else if (mission_id == CIGS_IV1_HEADER)
0A564:  MOVLB  2
0A566:  MOVF   x96,W
0A568:  SUBLW  03
0A56A:  BTFSC  FD8.2
0A56C:  BRA    A574
0A56E:  MOVLB  0
0A570:  GOTO   A59A
0A574:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_HEADER_START_ADDRESS;
0A576:  MOVLW  06
0A578:  MOVLB  2
0A57A:  MOVWF  x9A
0A57C:  MOVLW  B4
0A57E:  MOVWF  x99
0A580:  MOVLW  20
0A582:  MOVWF  x98
0A584:  CLRF   x97
....................       mis_struct.end_address   = CIGS_IV1_HEADER_END_ADDRESS;
0A586:  MOVLW  06
0A588:  MOVWF  x9E
0A58A:  MOVLW  BE
0A58C:  MOVWF  x9D
0A58E:  MOVLW  1F
0A590:  MOVWF  x9C
0A592:  SETF   x9B
0A594:  MOVLB  0
....................    }
0A596:  GOTO   A638
....................    else if (mission_id == CIGS_IV1_DATA)
0A59A:  MOVLB  2
0A59C:  MOVF   x96,W
0A59E:  SUBLW  04
0A5A0:  BTFSC  FD8.2
0A5A2:  BRA    A5AA
0A5A4:  MOVLB  0
0A5A6:  GOTO   A5D0
0A5AA:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV1_DATA_START_ADDRESS;
0A5AC:  MOVLW  06
0A5AE:  MOVLB  2
0A5B0:  MOVWF  x9A
0A5B2:  MOVLW  BE
0A5B4:  MOVWF  x99
0A5B6:  MOVLW  20
0A5B8:  MOVWF  x98
0A5BA:  CLRF   x97
....................       mis_struct.end_address   = CIGS_IV1_DATA_END_ADDRESS;
0A5BC:  MOVLW  06
0A5BE:  MOVWF  x9E
0A5C0:  MOVLW  FE
0A5C2:  MOVWF  x9D
0A5C4:  MOVLW  2F
0A5C6:  MOVWF  x9C
0A5C8:  SETF   x9B
0A5CA:  MOVLB  0
....................    }
0A5CC:  GOTO   A638
....................       else if (mission_id == CIGS_IV2_HEADER)
0A5D0:  MOVLB  2
0A5D2:  MOVF   x96,W
0A5D4:  SUBLW  05
0A5D6:  BTFSC  FD8.2
0A5D8:  BRA    A5E0
0A5DA:  MOVLB  0
0A5DC:  GOTO   A606
0A5E0:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV2_HEADER_START_ADDRESS;
0A5E2:  MOVLW  06
0A5E4:  MOVLB  2
0A5E6:  MOVWF  x9A
0A5E8:  MOVLW  FE
0A5EA:  MOVWF  x99
0A5EC:  MOVLW  30
0A5EE:  MOVWF  x98
0A5F0:  CLRF   x97
....................       mis_struct.end_address   = CIGS_IV2_HEADER_END_ADDRESS;
0A5F2:  MOVLW  07
0A5F4:  MOVWF  x9E
0A5F6:  MOVLW  08
0A5F8:  MOVWF  x9D
0A5FA:  MOVLW  2F
0A5FC:  MOVWF  x9C
0A5FE:  SETF   x9B
0A600:  MOVLB  0
....................    }
0A602:  GOTO   A638
....................    else if (mission_id == CIGS_IV2_DATA)
0A606:  MOVLB  2
0A608:  MOVF   x96,W
0A60A:  SUBLW  06
0A60C:  BTFSC  FD8.2
0A60E:  BRA    A616
0A610:  MOVLB  0
0A612:  GOTO   A638
0A616:  MOVLB  0
....................    {
....................       mis_struct.start_address = CIGS_IV2_DATA_START_ADDRESS;
0A618:  MOVLW  07
0A61A:  MOVLB  2
0A61C:  MOVWF  x9A
0A61E:  MOVLW  08
0A620:  MOVWF  x99
0A622:  MOVLW  30
0A624:  MOVWF  x98
0A626:  CLRF   x97
....................       mis_struct.end_address   = CIGS_IV2_DATA_END_ADDRESS;
0A628:  MOVLW  07
0A62A:  MOVWF  x9E
0A62C:  MOVLW  48
0A62E:  MOVWF  x9D
0A630:  MOVLW  3F
0A632:  MOVWF  x9C
0A634:  SETF   x9B
0A636:  MOVLB  0
....................    }
....................    return mis_struct;
0A638:  MOVLW  97
0A63A:  MOVWF  01
0A63C:  MOVLW  02
0A63E:  MOVWF  02
0A640:  RETURN 0
.................... }
.................... // End of file
.................... 
.................... #include "../lib/communication/communication.c"
.................... // #include "communication.h"  // ヘッダーファイルから自動的にインクルードされるため不要
.................... #include "mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, 0, FALSE,{0x00}};
*
050B6:  MOVLB  1
050B8:  CLRF   xBC
050BA:  CLRF   xBD
050BC:  CLRF   xBE
050BE:  CLRF   xBF
050C0:  CLRF   xC0
050C2:  CLRF   xC1
050C4:  CLRF   xC2
050C6:  CLRF   xC3
050C8:  CLRF   xC4
050CA:  CLRF   xC5
050CC:  CLRF   xC6
050CE:  CLRF   xC7
....................    fprintf(PC, "\r\nStart make_receive_command\r\n");
050D0:  MOVLW  82
050D2:  MOVWF  FF6
050D4:  MOVLW  03
050D6:  MOVWF  FF7
050D8:  MOVLW  00
050DA:  MOVWF  FF8
050DC:  MOVLB  0
050DE:  CALL   1D32
....................    fprintf(PC, "\t[BOSS] >>> ");
050E2:  MOVLW  A2
050E4:  MOVWF  FF6
050E6:  MOVLW  03
050E8:  MOVWF  FF7
050EA:  MOVLW  00
050EC:  MOVWF  FF8
050EE:  CALL   1D32
....................    for (int8 i = 0; i < receive_signal_size; i++)
050F2:  MOVLB  1
050F4:  CLRF   xC8
050F6:  MOVLB  0
050F8:  MOVLB  1
050FA:  MOVF   xBB,W
050FC:  SUBWF  xC8,W
050FE:  BTFSS  FD8.0
05100:  BRA    5108
05102:  MOVLB  0
05104:  GOTO   5142
05108:  MOVLB  0
....................       fprintf(PC, "%X ", receive_signal[i]);
0510A:  MOVLB  1
0510C:  MOVF   xC8,W
0510E:  ADDWF  xB9,W
05110:  MOVWF  FE9
05112:  MOVLW  00
05114:  ADDWFC xBA,W
05116:  MOVWF  FEA
05118:  MOVFF  FEF,1CF
0511C:  MOVFF  1CF,A39
05120:  MOVLW  37
05122:  MOVLB  A
05124:  MOVWF  x3A
05126:  MOVLB  0
05128:  CALL   1F60
0512C:  MOVLW  20
0512E:  MOVLB  A
05130:  MOVWF  xDB
05132:  MOVLB  0
05134:  CALL   1CE0
05138:  MOVLB  1
0513A:  INCF   xC8,F
0513C:  MOVLB  0
0513E:  GOTO   50F8
....................    fprintf(PC, "\r\n");
05142:  MOVLW  0D
05144:  MOVLB  A
05146:  MOVWF  xDB
05148:  MOVLB  0
0514A:  CALL   1CE0
0514E:  MOVLW  0A
05150:  MOVLB  A
05152:  MOVWF  xDB
05154:  MOVLB  0
05156:  CALL   1CE0
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
0515A:  MOVFF  1BA,1D0
0515E:  MOVFF  1B9,1CF
05162:  MOVFF  1BB,1D1
05166:  GOTO   4DAE
0516A:  MOVFF  01,1C9
....................    if (frame_start_position == -1)
0516E:  MOVLB  1
05170:  MOVF   xC9,W
05172:  SUBLW  FF
05174:  BTFSC  FD8.2
05176:  BRA    517E
05178:  MOVLB  0
0517A:  GOTO   518C
0517E:  MOVLB  0
....................       return command;
05180:  MOVLW  BC
05182:  MOVWF  01
05184:  MOVLW  01
05186:  MOVWF  02
05188:  GOTO   52AE
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
0518C:  MOVLB  1
0518E:  MOVF   xC9,W
05190:  ADDWF  xB9,W
05192:  MOVWF  01
05194:  MOVLW  00
05196:  ADDWFC xBA,W
05198:  MOVWF  03
0519A:  MOVF   01,W
0519C:  MOVWF  xCA
0519E:  MOVFF  03,1CB
051A2:  MOVF   xCA,W
051A4:  MOVWF  FE9
051A6:  MOVF   xCB,W
051A8:  MOVWF  FEA
051AA:  MOVF   FEF,W
051AC:  ANDLW  0F
051AE:  MOVWF  xCC
051B0:  MOVFF  1CC,1CF
051B4:  MOVLB  0
051B6:  GOTO   4E56
051BA:  MOVFF  01,1CD
....................    if (content_size == -1)
051BE:  MOVLB  1
051C0:  MOVF   xCD,W
051C2:  SUBLW  FF
051C4:  BTFSC  FD8.2
051C6:  BRA    51CE
051C8:  MOVLB  0
051CA:  GOTO   51DC
051CE:  MOVLB  0
....................       return command;
051D0:  MOVLW  BC
051D2:  MOVWF  01
051D4:  MOVLW  01
051D6:  MOVWF  02
051D8:  GOTO   52AE
....................       
....................    unsigned int8 receive_frame_size = receive_signal_size - frame_start_position;
051DC:  MOVLB  1
051DE:  MOVF   xC9,W
051E0:  SUBWF  xBB,W
051E2:  MOVWF  xCE
....................    
....................    if (!check_crc(frame, receive_frame_size))
051E4:  MOVFF  1CB,1D0
051E8:  MOVFF  1CA,1CF
051EC:  MOVFF  1CE,1D1
051F0:  MOVLB  0
051F2:  GOTO   4F12
051F6:  MOVF   01,F
051F8:  BTFSS  FD8.2
051FA:  GOTO   520A
....................       return command;
051FE:  MOVLW  BC
05200:  MOVWF  01
05202:  MOVLW  01
05204:  MOVWF  02
05206:  GOTO   52AE
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
0520A:  MOVLB  1
0520C:  MOVF   xCA,W
0520E:  MOVWF  FE9
05210:  MOVF   xCB,W
05212:  MOVWF  FEA
05214:  MOVF   FEF,W
05216:  ANDLW  F0
05218:  MOVWF  00
0521A:  SWAPF  00,W
0521C:  MOVWF  xCF
0521E:  MOVLW  0F
05220:  ANDWF  xCF,F
05222:  MOVFF  1CF,1D0
05226:  MOVLB  0
05228:  GOTO   4FFC
0522C:  MOVF   01,F
0522E:  BTFSS  FD8.2
05230:  GOTO   5240
....................       return command;
05234:  MOVLW  BC
05236:  MOVWF  01
05238:  MOVLW  01
0523A:  MOVWF  02
0523C:  GOTO   52AE
.................... 
....................    command.frame_id = frame_id;
05240:  MOVFF  1CC,1BC
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
05244:  MOVLW  01
05246:  MOVLB  1
05248:  ADDWF  xCA,W
0524A:  MOVWF  01
0524C:  MOVLW  00
0524E:  ADDWFC xCB,W
05250:  MOVWF  03
05252:  MOVF   01,W
05254:  MOVWF  xCF
05256:  MOVFF  03,1D0
0525A:  MOVLW  02
0525C:  SUBWF  xCE,W
0525E:  MOVWF  xD1
05260:  MOVLW  01
05262:  MOVWF  FEA
05264:  MOVLW  BF
05266:  MOVWF  FE9
05268:  MOVFF  1D0,FE2
0526C:  MOVFF  1CF,FE1
05270:  MOVF   xD1,W
05272:  MOVWF  01
05274:  BTFSS  FD8.2
05276:  BRA    527E
05278:  MOVLB  0
0527A:  GOTO   528A
0527E:  MOVLB  0
05280:  MOVFF  FE6,FEE
05284:  DECFSZ 01,F
05286:  GOTO   5280
....................    command.size = receive_frame_size-2;
0528A:  MOVLW  02
0528C:  MOVLB  1
0528E:  SUBWF  xCE,W
05290:  MOVWF  xBD
....................    command.is_exist = TRUE;
05292:  BSF    xBE.0
....................    //fprintf(PC, "\t-> Frame ID: %X\r\n", command.frame_id);
....................    //fprintf(PC, "\t-> Content size: %d\r\n", command.size);
....................    //fprintf(PC, "\t-> is_exist: %d\r\n", command.is_exist);
....................    fprintf(PC, "End make_recive_command\r\n\r\n");
05294:  MOVLW  B0
05296:  MOVWF  FF6
05298:  MOVLW  03
0529A:  MOVWF  FF7
0529C:  MOVLW  00
0529E:  MOVWF  FF8
052A0:  MOVLB  0
052A2:  CALL   1D32
....................    return command;
052A6:  MOVLW  BC
052A8:  MOVWF  01
052AA:  MOVLW  01
052AC:  MOVWF  02
052AE:  GOTO   C788 (RETURN)
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
04DAE:  MOVLB  1
04DB0:  CLRF   xD2
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
04DB2:  CLRF   xD2
04DB4:  MOVLB  0
04DB6:  MOVLW  01
04DB8:  MOVLB  1
04DBA:  SUBWF  xD1,W
04DBC:  SUBWF  xD2,W
04DBE:  BTFSS  FD8.0
04DC0:  BRA    4DC8
04DC2:  MOVLB  0
04DC4:  GOTO   4E00
04DC8:  MOVLB  0
....................       if(receive_signal[i] == SFD)
04DCA:  MOVLB  1
04DCC:  MOVF   xD2,W
04DCE:  ADDWF  xCF,W
04DD0:  MOVWF  FE9
04DD2:  MOVLW  00
04DD4:  ADDWFC xD0,W
04DD6:  MOVWF  FEA
04DD8:  MOVF   FEF,W
04DDA:  SUBLW  AA
04DDC:  BTFSC  FD8.2
04DDE:  BRA    4DE6
04DE0:  MOVLB  0
04DE2:  GOTO   4DF6
04DE6:  MOVLB  0
....................          return i+1;
04DE8:  MOVLW  01
04DEA:  MOVLB  1
04DEC:  ADDWF  xD2,W
04DEE:  MOVWF  01
04DF0:  MOVLB  0
04DF2:  GOTO   4E52
04DF6:  MOVLB  1
04DF8:  INCF   xD2,F
04DFA:  MOVLB  0
04DFC:  GOTO   4DB6
....................    if (receive_signal[i] == SFD)
04E00:  MOVLB  1
04E02:  MOVF   xD2,W
04E04:  ADDWF  xCF,W
04E06:  MOVWF  FE9
04E08:  MOVLW  00
04E0A:  ADDWFC xD0,W
04E0C:  MOVWF  FEA
04E0E:  MOVF   FEF,W
04E10:  SUBLW  AA
04E12:  BTFSC  FD8.2
04E14:  BRA    4E1C
04E16:  MOVLB  0
04E18:  GOTO   4E3A
04E1C:  MOVLB  0
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
04E1E:  MOVLW  CC
04E20:  MOVWF  FF6
04E22:  MOVLW  03
04E24:  MOVWF  FF7
04E26:  MOVLW  00
04E28:  MOVWF  FF8
04E2A:  CALL   1D32
....................       return -1;
04E2E:  MOVLW  FF
04E30:  MOVWF  01
04E32:  GOTO   4E52
....................    }
04E36:  GOTO   4E52
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
04E3A:  MOVLW  E2
04E3C:  MOVWF  FF6
04E3E:  MOVLW  03
04E40:  MOVWF  FF7
04E42:  MOVLW  00
04E44:  MOVWF  FF8
04E46:  CALL   1D32
....................       return -1;
04E4A:  MOVLW  FF
04E4C:  MOVWF  01
04E4E:  GOTO   4E52
....................    }
04E52:  GOTO   516A (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
04E56:  MOVLB  1
04E58:  CLRF   xD0
04E5A:  MOVLB  0
04E5C:  MOVLB  1
04E5E:  MOVF   xD0,W
04E60:  SUBLW  02
04E62:  BTFSC  FD8.0
04E64:  BRA    4E6C
04E66:  MOVLB  0
04E68:  GOTO   4ECA
04E6C:  MOVLB  0
....................       if (frame_id == frame_ids[i].id)
04E6E:  BCF    FD8.0
04E70:  MOVLB  1
04E72:  RLCF   xD0,W
04E74:  CLRF   xD2
04E76:  MOVWF  xD1
04E78:  MOVLW  16
04E7A:  ADDWF  xD1,W
04E7C:  MOVWF  FE9
04E7E:  MOVLW  01
04E80:  ADDWFC xD2,W
04E82:  MOVWF  FEA
04E84:  MOVF   FEF,W
04E86:  SUBWF  xCF,W
04E88:  BTFSC  FD8.2
04E8A:  BRA    4E92
04E8C:  MOVLB  0
04E8E:  GOTO   4EC0
04E92:  MOVLB  0
....................          return frame_ids[i].length;
04E94:  BCF    FD8.0
04E96:  MOVLB  1
04E98:  RLCF   xD0,W
04E9A:  CLRF   xD2
04E9C:  MOVWF  xD1
04E9E:  MOVLW  01
04EA0:  ADDWF  xD1,W
04EA2:  MOVWF  01
04EA4:  MOVLW  00
04EA6:  ADDWFC xD2,W
04EA8:  MOVWF  03
04EAA:  MOVF   01,W
04EAC:  ADDLW  16
04EAE:  MOVWF  FE9
04EB0:  MOVLW  01
04EB2:  ADDWFC 03,W
04EB4:  MOVWF  FEA
04EB6:  MOVF   FEF,W
04EB8:  MOVWF  01
04EBA:  MOVLB  0
04EBC:  GOTO   4F0E
04EC0:  MOVLB  1
04EC2:  INCF   xD0,F
04EC4:  MOVLB  0
04EC6:  GOTO   4E5C
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
04ECA:  MOVLW  F4
04ECC:  MOVWF  FF6
04ECE:  MOVLW  03
04ED0:  MOVWF  FF7
04ED2:  MOVLW  00
04ED4:  MOVWF  FF8
04ED6:  MOVLW  1F
04ED8:  MOVLB  3
04EDA:  MOVWF  x12
04EDC:  MOVLB  0
04EDE:  CALL   1D62
04EE2:  MOVFF  1CF,A39
04EE6:  MOVLW  37
04EE8:  MOVLB  A
04EEA:  MOVWF  x3A
04EEC:  MOVLB  0
04EEE:  CALL   1F60
04EF2:  MOVLW  0D
04EF4:  MOVLB  A
04EF6:  MOVWF  xDB
04EF8:  MOVLB  0
04EFA:  CALL   1CE0
04EFE:  MOVLW  0A
04F00:  MOVLB  A
04F02:  MOVWF  xDB
04F04:  MOVLB  0
04F06:  CALL   1CE0
....................    return -1;
04F0A:  MOVLW  FF
04F0C:  MOVWF  01
04F0E:  GOTO   51BA (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
04F12:  MOVLW  01
04F14:  MOVLB  1
04F16:  SUBWF  xD1,W
04F18:  ADDWF  xCF,W
04F1A:  MOVWF  FE9
04F1C:  MOVLW  00
04F1E:  ADDWFC xD0,W
04F20:  MOVWF  FEA
04F22:  MOVFF  FEF,1D2
04F26:  MOVLW  01
04F28:  SUBWF  xD1,W
04F2A:  MOVWF  xD4
04F2C:  MOVFF  1D0,ADC
04F30:  MOVFF  1CF,ADB
04F34:  MOVFF  1D4,ADD
04F38:  MOVLB  0
04F3A:  CALL   2AFA
04F3E:  MOVFF  01,1D3
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
04F42:  MOVLB  1
04F44:  MOVF   xD3,W
04F46:  SUBWF  xD2,W
04F48:  BTFSC  FD8.2
04F4A:  BRA    4F52
04F4C:  MOVLB  0
04F4E:  GOTO   4F60
04F52:  MOVLB  0
....................       return TRUE;
04F54:  MOVLW  01
04F56:  MOVWF  01
04F58:  GOTO   4FF8
04F5C:  GOTO   4FF8
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
04F60:  MOVLW  18
04F62:  MOVWF  FF6
04F64:  MOVLW  04
04F66:  MOVWF  FF7
04F68:  MOVLW  00
04F6A:  MOVWF  FF8
04F6C:  CALL   1D32
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
04F70:  MOVLW  2A
04F72:  MOVWF  FF6
04F74:  MOVLW  04
04F76:  MOVWF  FF7
04F78:  MOVLW  00
04F7A:  MOVWF  FF8
04F7C:  MOVLW  13
04F7E:  MOVLB  3
04F80:  MOVWF  x12
04F82:  MOVLB  0
04F84:  CALL   1D62
04F88:  MOVFF  1D2,A39
04F8C:  MOVLW  37
04F8E:  MOVLB  A
04F90:  MOVWF  x3A
04F92:  MOVLB  0
04F94:  CALL   1F60
04F98:  MOVLW  0D
04F9A:  MOVLB  A
04F9C:  MOVWF  xDB
04F9E:  MOVLB  0
04FA0:  CALL   1CE0
04FA4:  MOVLW  0A
04FA6:  MOVLB  A
04FA8:  MOVWF  xDB
04FAA:  MOVLB  0
04FAC:  CALL   1CE0
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
04FB0:  MOVLW  42
04FB2:  MOVWF  FF6
04FB4:  MOVLW  04
04FB6:  MOVWF  FF7
04FB8:  MOVLW  00
04FBA:  MOVWF  FF8
04FBC:  MOVLW  13
04FBE:  MOVLB  3
04FC0:  MOVWF  x12
04FC2:  MOVLB  0
04FC4:  CALL   1D62
04FC8:  MOVFF  1D3,A39
04FCC:  MOVLW  37
04FCE:  MOVLB  A
04FD0:  MOVWF  x3A
04FD2:  MOVLB  0
04FD4:  CALL   1F60
04FD8:  MOVLW  0D
04FDA:  MOVLB  A
04FDC:  MOVWF  xDB
04FDE:  MOVLB  0
04FE0:  CALL   1CE0
04FE4:  MOVLW  0A
04FE6:  MOVLB  A
04FE8:  MOVWF  xDB
04FEA:  MOVLB  0
04FEC:  CALL   1CE0
....................       return FALSE;
04FF0:  MOVLW  00
04FF2:  MOVWF  01
04FF4:  GOTO   4FF8
....................    }
04FF8:  GOTO   51F6 (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
04FFC:  MOVLB  1
04FFE:  MOVF   xD0,W
05000:  SUBLW  0C
05002:  BTFSC  FD8.2
05004:  BRA    500C
05006:  MOVLB  0
05008:  GOTO   501A
0500C:  MOVLB  0
....................       return TRUE;
0500E:  MOVLW  01
05010:  MOVWF  01
05012:  GOTO   50B2
05016:  GOTO   50B2
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
0501A:  MOVLW  5A
0501C:  MOVWF  FF6
0501E:  MOVLW  04
05020:  MOVWF  FF7
05022:  MOVLW  00
05024:  MOVWF  FF8
05026:  CALL   1D32
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
0502A:  MOVLW  7C
0502C:  MOVWF  FF6
0502E:  MOVLW  04
05030:  MOVWF  FF7
05032:  MOVLW  00
05034:  MOVWF  FF8
05036:  MOVLW  13
05038:  MOVLB  3
0503A:  MOVWF  x12
0503C:  MOVLB  0
0503E:  CALL   1D62
05042:  MOVFF  1D0,A39
05046:  MOVLW  37
05048:  MOVLB  A
0504A:  MOVWF  x3A
0504C:  MOVLB  0
0504E:  CALL   1F60
05052:  MOVLW  0D
05054:  MOVLB  A
05056:  MOVWF  xDB
05058:  MOVLB  0
0505A:  CALL   1CE0
0505E:  MOVLW  0A
05060:  MOVLB  A
05062:  MOVWF  xDB
05064:  MOVLB  0
05066:  CALL   1CE0
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
0506A:  MOVLW  94
0506C:  MOVWF  FF6
0506E:  MOVLW  04
05070:  MOVWF  FF7
05072:  MOVLW  00
05074:  MOVWF  FF8
05076:  MOVLW  13
05078:  MOVLB  3
0507A:  MOVWF  x12
0507C:  MOVLB  0
0507E:  CALL   1D62
05082:  MOVLW  0C
05084:  MOVLB  A
05086:  MOVWF  x39
05088:  MOVLW  37
0508A:  MOVWF  x3A
0508C:  MOVLB  0
0508E:  CALL   1F60
05092:  MOVLW  0D
05094:  MOVLB  A
05096:  MOVWF  xDB
05098:  MOVLB  0
0509A:  CALL   1CE0
0509E:  MOVLW  0A
050A0:  MOVLB  A
050A2:  MOVWF  xDB
050A4:  MOVLB  0
050A6:  CALL   1CE0
....................       return FALSE;  
050AA:  MOVLW  00
050AC:  MOVWF  01
050AE:  GOTO   50B2
....................    }
050B2:  GOTO   522C (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
053B8:  MOVLW  AA
053BA:  MOVLB  1
053BC:  MOVWF  xBE
....................    data[1] = (BOSS_PIC << 4) | frame_id;
053BE:  MOVF   xBA,W
053C0:  IORLW  50
053C2:  MOVWF  xBF
....................    memcpy(&data[2], content, size);
053C4:  MOVLW  01
053C6:  MOVWF  FEA
053C8:  MOVLW  C0
053CA:  MOVWF  FE9
053CC:  MOVFF  1BC,FE2
053D0:  MOVFF  1BB,FE1
053D4:  MOVF   xBD,W
053D6:  MOVWF  01
053D8:  BTFSS  FD8.2
053DA:  BRA    53E2
053DC:  MOVLB  0
053DE:  GOTO   53EE
053E2:  MOVLB  0
053E4:  MOVFF  FE6,FEE
053E8:  DECFSZ 01,F
053EA:  GOTO   53E4
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
053EE:  MOVLW  02
053F0:  MOVLB  1
053F2:  ADDWF  xBD,W
053F4:  MOVWF  xCE
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
053F6:  CLRF   03
053F8:  MOVF   xCE,W
053FA:  ADDLW  BE
053FC:  MOVWF  01
053FE:  MOVLW  01
05400:  ADDWFC 03,F
05402:  MOVF   01,W
05404:  MOVWF  xD0
05406:  MOVFF  03,1D1
0540A:  MOVLW  01
0540C:  SUBWF  xCE,W
0540E:  MOVWF  xD2
05410:  MOVLW  01
05412:  MOVLB  A
05414:  MOVWF  xDC
05416:  MOVLW  BF
05418:  MOVWF  xDB
0541A:  MOVFF  1D2,ADD
0541E:  MOVLB  0
05420:  CALL   2AFA
05424:  MOVFF  1D1,FEA
05428:  MOVFF  1D0,FE9
0542C:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
05430:  MOVLW  01
05432:  MOVLB  1
05434:  ADDWF  xCE,W
05436:  MOVWF  xCF
....................    
....................    transmit(data, data_size);
05438:  MOVLW  01
0543A:  MOVWF  xD1
0543C:  MOVLW  BE
0543E:  MOVWF  xD0
05440:  MOVFF  1CF,1D2
05444:  MOVLB  0
05446:  GOTO   5300
0544A:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
05300:  MOVLB  1
05302:  CLRF   xD3
05304:  MOVLB  0
05306:  MOVLB  1
05308:  MOVF   xD2,W
0530A:  SUBWF  xD3,W
0530C:  BTFSS  FD8.0
0530E:  BRA    5316
05310:  MOVLB  0
05312:  GOTO   533C
05316:  MOVLB  0
....................       fputc(data[i], BOSS);
05318:  MOVLB  1
0531A:  MOVF   xD3,W
0531C:  ADDWF  xD0,W
0531E:  MOVWF  FE9
05320:  MOVLW  00
05322:  ADDWFC xD1,W
05324:  MOVWF  FEA
05326:  MOVFF  FEF,1D5
0532A:  MOVF   xD5,W
0532C:  MOVLB  0
0532E:  GOTO   52F0
05332:  MOVLB  1
05334:  INCF   xD3,F
05336:  MOVLB  0
05338:  GOTO   5306
....................       
....................    fprintf(PC, "\t[BOSS] <<< ");
0533C:  MOVLW  AC
0533E:  MOVWF  FF6
05340:  MOVLW  04
05342:  MOVWF  FF7
05344:  MOVLW  00
05346:  MOVWF  FF8
05348:  CALL   1D32
....................    for(int i = 0; i < data_size; i++)
0534C:  MOVLB  1
0534E:  CLRF   xD4
05350:  MOVLB  0
05352:  MOVLB  1
05354:  MOVF   xD2,W
05356:  SUBWF  xD4,W
05358:  BTFSS  FD8.0
0535A:  BRA    5362
0535C:  MOVLB  0
0535E:  GOTO   539C
05362:  MOVLB  0
....................       fprintf(PC, "%X ", data[i]);
05364:  MOVLB  1
05366:  MOVF   xD4,W
05368:  ADDWF  xD0,W
0536A:  MOVWF  FE9
0536C:  MOVLW  00
0536E:  ADDWFC xD1,W
05370:  MOVWF  FEA
05372:  MOVFF  FEF,1D5
05376:  MOVFF  1D5,A39
0537A:  MOVLW  37
0537C:  MOVLB  A
0537E:  MOVWF  x3A
05380:  MOVLB  0
05382:  CALL   1F60
05386:  MOVLW  20
05388:  MOVLB  A
0538A:  MOVWF  xDB
0538C:  MOVLB  0
0538E:  CALL   1CE0
05392:  MOVLB  1
05394:  INCF   xD4,F
05396:  MOVLB  0
05398:  GOTO   5352
....................    fprintf(PC, "\r\n");
0539C:  MOVLW  0D
0539E:  MOVLB  A
053A0:  MOVWF  xDB
053A2:  MOVLB  0
053A4:  CALL   1CE0
053A8:  MOVLW  0A
053AA:  MOVLB  A
053AC:  MOVWF  xDB
053AE:  MOVLB  0
053B0:  CALL   1CE0
053B4:  GOTO   544A (RETURN)
.................... }
.................... 
.................... #include "../lib/communication/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
0544C:  MOVLW  0F
0544E:  MOVLB  1
05450:  MOVWF  xBA
05452:  CLRF   xBC
05454:  CLRF   xBB
05456:  CLRF   xBD
05458:  MOVLB  0
0545A:  CALL   53B8
0545E:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 4);
*
0A09C:  MOVLW  03
0A09E:  MOVLB  1
0A0A0:  MOVWF  xBA
0A0A2:  CLRF   xBC
0A0A4:  MOVLW  48
0A0A6:  MOVWF  xBB
0A0A8:  MOVLW  04
0A0AA:  MOVWF  xBD
0A0AC:  MOVLB  0
0A0AE:  CALL   53B8
0A0B2:  GOTO   A0DA (RETURN)
.................... }
.................... 
.................... 
.................... #include "../lib/communication/mission_tools.c"
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
....................    status[0] = SMF_USE_REQ;
....................    is_use_smf_req_in_mission = TRUE;
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == STATUS_CHECK)
....................             {
....................                transmit_status();
....................                break;
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
....................       {
....................          if (boss_receive_buffer_size > 0)
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
....................             if (command.frame_id == IS_SMF_AVAILABLE)
....................             {
....................                if (command.content[0] == ALLOW)
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
....................                   transmit_ack();
....................                   goto NEXT;
....................                }
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
....................                   transmit_ack();
....................                   break;
....................                }
....................             }
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
....................             }
....................          }
....................          delay_ms(500);
....................       }
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
....................    status[0] = COPYING;
....................    return TRUE;
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status[0] = EXECUTING_MISSION;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
....................    {
....................       fgetc(BOSS);
....................       transmit_status();
....................    }
.................... }
.................... 
.................... 
.................... 
.................... // コア機能実装ファイル
.................... #include "domain/mmj_cigs_iv.c"
.................... #include "mmj_cigs_iv.h"               // 同じフォルダのヘッダー
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"      // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../device_driver/ad7490_driver.h"   // デバイス定義  
.................... #ifndef AD7490_DRIVER_H
.................... #define AD7490_DRIVER_H
.................... 
.................... 
.................... // AD7490 Functions
.................... void ad7490_init(void);
.................... unsigned int16 ad7490_read(int8 channel);
.................... 
.................... 
.................... #endif // MMJ_CIGS_DEVCE_H
.................... //------------------End of File------------------
.................... 
.................... #include "../device_driver/mcp4901_driver.h"
.................... #ifndef MCP4901_DRIVER_H
.................... #define MCP4901_DRIVER_H
.................... 
.................... // MCP4901 Functions
.................... void mcp4901_init();
.................... void mcp4901_1_write(unsigned int16 val);
.................... void mcp4901_2_write(unsigned int16 val);
.................... 
.................... #endif // MCP4901_DRIVER_H
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_flash.h"               // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/communication/mission_tools.h"   // 通信ツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../hal/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void test_sweep(unsigned int16 curr_threshold,unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, ".");
*
07E8C:  MOVLW  2E
07E8E:  MOVLB  A
07E90:  MOVWF  xDB
07E92:  MOVLB  0
07E94:  CALL   1CE0
....................    
....................     // Enable both CIGS ports
....................     connect_port1();
07E98:  GOTO   7454
....................     connect_port2();
07E9C:  GOTO   745E
.................... 
....................     // Init Port1
....................     sweep_config_t port1 = {0};
07EA0:  MOVLB  1
07EA2:  CLRF   xD2
07EA4:  CLRF   xD3
07EA6:  CLRF   xD4
07EA8:  CLRF   xD5
07EAA:  CLRF   xD6
07EAC:  CLRF   xD7
07EAE:  CLRF   xD8
07EB0:  CLRF   xD9
07EB2:  CLRF   xDA
07EB4:  CLRF   xDB
07EB6:  CLRF   xDC
07EB8:  CLRF   xDD
07EBA:  CLRF   xDE
07EBC:  CLRF   xDF
07EBE:  CLRF   xE0
07EC0:  CLRF   xE1
07EC2:  CLRF   xE2
07EC4:  CLRF   xE3
07EC6:  CLRF   xE4
07EC8:  CLRF   xE5
07ECA:  CLRF   xE6
07ECC:  CLRF   xE7
07ECE:  CLRF   xE8
07ED0:  CLRF   xE9
07ED2:  CLRF   xEA
07ED4:  CLRF   xEB
07ED6:  CLRF   xEC
07ED8:  CLRF   xED
07EDA:  CLRF   xEE
07EDC:  CLRF   xEF
07EDE:  CLRF   xF0
07EE0:  CLRF   xF1
07EE2:  CLRF   xF2
07EE4:  CLRF   xF3
07EE6:  CLRF   xF4
07EE8:  CLRF   xF5
07EEA:  CLRF   xF6
07EEC:  CLRF   xF7
07EEE:  CLRF   xF8
07EF0:  CLRF   xF9
07EF2:  CLRF   xFA
07EF4:  CLRF   xFB
07EF6:  CLRF   xFC
07EF8:  CLRF   xFD
07EFA:  CLRF   xFE
07EFC:  CLRF   xFF
07EFE:  MOVLB  2
07F00:  CLRF   x00
07F02:  CLRF   x01
07F04:  CLRF   x02
07F06:  CLRF   x03
07F08:  CLRF   x04
07F0A:  CLRF   x05
07F0C:  CLRF   x06
07F0E:  CLRF   x07
07F10:  CLRF   x08
07F12:  CLRF   x09
07F14:  CLRF   x0A
07F16:  CLRF   x0B
07F18:  CLRF   x0C
07F1A:  CLRF   x0D
07F1C:  CLRF   x0E
07F1E:  CLRF   x0F
07F20:  CLRF   x10
07F22:  CLRF   x11
07F24:  CLRF   x12
07F26:  CLRF   x13
07F28:  CLRF   x14
07F2A:  CLRF   x15
07F2C:  CLRF   x16
07F2E:  CLRF   x17
07F30:  CLRF   x18
07F32:  CLRF   x19
07F34:  CLRF   x1A
07F36:  CLRF   x1B
07F38:  CLRF   x1C
07F3A:  CLRF   x1D
07F3C:  CLRF   x1E
07F3E:  CLRF   x1F
07F40:  CLRF   x20
07F42:  CLRF   x21
07F44:  CLRF   x22
07F46:  CLRF   x23
07F48:  CLRF   x24
07F4A:  CLRF   x25
07F4C:  CLRF   x26
07F4E:  CLRF   x27
07F50:  CLRF   x28
07F52:  CLRF   x29
07F54:  CLRF   x2A
07F56:  CLRF   x2B
07F58:  CLRF   x2C
07F5A:  CLRF   x2D
07F5C:  CLRF   x2E
07F5E:  CLRF   x2F
07F60:  CLRF   x30
07F62:  CLRF   x31
07F64:  CLRF   x32
07F66:  CLRF   x33
07F68:  CLRF   x34
07F6A:  CLRF   x35
07F6C:  CLRF   x36
07F6E:  CLRF   x37
07F70:  CLRF   x38
07F72:  CLRF   x39
07F74:  CLRF   x3A
07F76:  CLRF   x3B
07F78:  CLRF   x3C
07F7A:  CLRF   x3D
07F7C:  CLRF   x3E
07F7E:  CLRF   x3F
07F80:  CLRF   x40
07F82:  CLRF   x41
07F84:  CLRF   x42
07F86:  CLRF   x43
07F88:  CLRF   x44
07F8A:  CLRF   x45
07F8C:  CLRF   x46
07F8E:  CLRF   x47
07F90:  CLRF   x48
07F92:  CLRF   x49
07F94:  CLRF   x4A
07F96:  CLRF   x4B
07F98:  CLRF   x4C
07F9A:  CLRF   x4D
07F9C:  CLRF   x4E
07F9E:  CLRF   x4F
07FA0:  CLRF   x50
07FA2:  CLRF   x51
07FA4:  CLRF   x52
07FA6:  CLRF   x53
07FA8:  CLRF   x54
07FAA:  CLRF   x55
07FAC:  CLRF   x56
07FAE:  CLRF   x57
07FB0:  CLRF   x58
07FB2:  CLRF   x59
07FB4:  CLRF   x5A
07FB6:  CLRF   x5B
07FB8:  CLRF   x5C
07FBA:  CLRF   x5D
07FBC:  CLRF   x5E
07FBE:  CLRF   x5F
07FC0:  CLRF   x60
07FC2:  CLRF   x61
07FC4:  CLRF   x62
07FC6:  CLRF   x63
07FC8:  CLRF   x64
07FCA:  CLRF   x65
07FCC:  CLRF   x66
07FCE:  CLRF   x67
07FD0:  CLRF   x68
07FD2:  CLRF   x69
07FD4:  CLRF   x6A
07FD6:  CLRF   x6B
07FD8:  CLRF   x6C
07FDA:  CLRF   x6D
07FDC:  CLRF   x6E
07FDE:  CLRF   x6F
07FE0:  CLRF   x70
07FE2:  CLRF   x71
07FE4:  CLRF   x72
07FE6:  CLRF   x73
07FE8:  CLRF   x74
07FEA:  CLRF   x75
07FEC:  CLRF   x76
07FEE:  CLRF   x77
07FF0:  CLRF   x78
07FF2:  CLRF   x79
07FF4:  CLRF   x7A
07FF6:  CLRF   x7B
07FF8:  CLRF   x7C
07FFA:  CLRF   x7D
07FFC:  CLRF   x7E
07FFE:  CLRF   x7F
08000:  CLRF   x80
08002:  CLRF   x81
08004:  CLRF   x82
08006:  CLRF   x83
08008:  CLRF   x84
0800A:  CLRF   x85
0800C:  CLRF   x86
0800E:  CLRF   x87
08010:  CLRF   x88
08012:  CLRF   x89
08014:  CLRF   x8A
08016:  CLRF   x8B
08018:  CLRF   x8C
0801A:  CLRF   x8D
0801C:  CLRF   x8E
0801E:  CLRF   x8F
08020:  CLRF   x90
08022:  CLRF   x91
08024:  CLRF   x92
08026:  CLRF   x93
08028:  CLRF   x94
0802A:  CLRF   x95
0802C:  CLRF   x96
0802E:  CLRF   x97
08030:  CLRF   x98
08032:  CLRF   x99
08034:  CLRF   x9A
08036:  CLRF   x9B
08038:  CLRF   x9C
0803A:  CLRF   x9D
0803C:  CLRF   x9E
0803E:  CLRF   x9F
08040:  CLRF   xA0
08042:  CLRF   xA1
08044:  CLRF   xA2
08046:  CLRF   xA3
08048:  CLRF   xA4
0804A:  CLRF   xA5
0804C:  CLRF   xA6
0804E:  CLRF   xA7
08050:  CLRF   xA8
08052:  CLRF   xA9
08054:  CLRF   xAA
08056:  CLRF   xAB
08058:  CLRF   xAC
0805A:  CLRF   xAD
0805C:  CLRF   xAE
0805E:  CLRF   xAF
08060:  CLRF   xB0
08062:  CLRF   xB1
08064:  CLRF   xB2
08066:  CLRF   xB3
08068:  CLRF   xB4
0806A:  CLRF   xB5
0806C:  CLRF   xB6
0806E:  CLRF   xB7
08070:  CLRF   xB8
08072:  CLRF   xB9
08074:  CLRF   xBA
08076:  CLRF   xBB
08078:  CLRF   xBC
0807A:  CLRF   xBD
0807C:  CLRF   xBE
0807E:  CLRF   xBF
08080:  CLRF   xC0
08082:  CLRF   xC1
08084:  CLRF   xC2
08086:  CLRF   xC3
08088:  CLRF   xC4
0808A:  CLRF   xC5
0808C:  CLRF   xC6
0808E:  CLRF   xC7
08090:  CLRF   xC8
08092:  CLRF   xC9
08094:  CLRF   xCA
08096:  CLRF   xCB
08098:  CLRF   xCC
0809A:  CLRF   xCD
0809C:  CLRF   xCE
0809E:  CLRF   xCF
080A0:  CLRF   xD0
080A2:  CLRF   xD1
080A4:  CLRF   xD2
080A6:  CLRF   xD3
080A8:  CLRF   xD4
080AA:  CLRF   xD5
080AC:  CLRF   xD6
080AE:  CLRF   xD7
080B0:  CLRF   xD8
080B2:  CLRF   xD9
080B4:  CLRF   xDA
080B6:  CLRF   xDB
080B8:  CLRF   xDC
080BA:  CLRF   xDD
080BC:  CLRF   xDE
080BE:  CLRF   xDF
080C0:  CLRF   xE0
080C2:  CLRF   xE1
080C4:  CLRF   xE2
080C6:  CLRF   xE3
080C8:  CLRF   xE4
080CA:  CLRF   xE5
080CC:  CLRF   xE6
080CE:  CLRF   xE7
080D0:  CLRF   xE8
080D2:  CLRF   xE9
080D4:  CLRF   xEA
080D6:  CLRF   xEB
080D8:  CLRF   xEC
080DA:  CLRF   xED
080DC:  CLRF   xEE
080DE:  CLRF   xEF
080E0:  CLRF   xF0
080E2:  CLRF   xF1
080E4:  CLRF   xF2
080E6:  CLRF   xF3
080E8:  CLRF   xF4
080EA:  CLRF   xF5
080EC:  CLRF   xF6
080EE:  CLRF   xF7
080F0:  CLRF   xF8
080F2:  CLRF   xF9
080F4:  CLRF   xFA
080F6:  CLRF   xFB
080F8:  CLRF   xFC
080FA:  CLRF   xFD
080FC:  CLRF   xFE
080FE:  CLRF   xFF
08100:  MOVLB  3
08102:  CLRF   x00
08104:  CLRF   x01
08106:  CLRF   x02
08108:  CLRF   x03
0810A:  CLRF   x04
0810C:  CLRF   x05
0810E:  CLRF   x06
08110:  CLRF   x07
08112:  CLRF   x08
08114:  CLRF   x09
08116:  CLRF   x0A
08118:  CLRF   x0B
0811A:  CLRF   x0C
0811C:  CLRF   x0D
0811E:  CLRF   x0E
08120:  CLRF   x0F
08122:  CLRF   x10
08124:  CLRF   x11
08126:  CLRF   x12
08128:  CLRF   x13
0812A:  CLRF   x14
0812C:  CLRF   x15
0812E:  CLRF   x16
08130:  CLRF   x17
08132:  CLRF   x18
08134:  CLRF   x19
08136:  CLRF   x1A
08138:  CLRF   x1B
0813A:  CLRF   x1C
0813C:  CLRF   x1D
0813E:  CLRF   x1E
08140:  CLRF   x1F
08142:  CLRF   x20
08144:  CLRF   x21
08146:  CLRF   x22
08148:  CLRF   x23
0814A:  CLRF   x24
0814C:  CLRF   x25
0814E:  CLRF   x26
08150:  CLRF   x27
08152:  CLRF   x28
08154:  CLRF   x29
08156:  CLRF   x2A
08158:  CLRF   x2B
0815A:  CLRF   x2C
0815C:  CLRF   x2D
0815E:  CLRF   x2E
08160:  CLRF   x2F
08162:  CLRF   x30
08164:  CLRF   x31
08166:  CLRF   x32
08168:  CLRF   x33
0816A:  CLRF   x34
0816C:  CLRF   x35
0816E:  CLRF   x36
08170:  CLRF   x37
08172:  CLRF   x38
08174:  CLRF   x39
08176:  CLRF   x3A
08178:  CLRF   x3B
0817A:  CLRF   x3C
0817C:  CLRF   x3D
0817E:  CLRF   x3E
08180:  CLRF   x3F
08182:  CLRF   x40
08184:  CLRF   x41
08186:  CLRF   x42
08188:  CLRF   x43
0818A:  CLRF   x44
0818C:  CLRF   x45
0818E:  CLRF   x46
08190:  CLRF   x47
08192:  CLRF   x48
08194:  CLRF   x49
08196:  CLRF   x4A
08198:  CLRF   x4B
0819A:  CLRF   x4C
0819C:  CLRF   x4D
0819E:  CLRF   x4E
081A0:  CLRF   x4F
081A2:  CLRF   x50
081A4:  CLRF   x51
081A6:  CLRF   x52
081A8:  CLRF   x53
081AA:  CLRF   x54
081AC:  CLRF   x55
081AE:  CLRF   x56
081B0:  CLRF   x57
081B2:  CLRF   x58
081B4:  CLRF   x59
081B6:  CLRF   x5A
081B8:  CLRF   x5B
081BA:  CLRF   x5C
081BC:  CLRF   x5D
081BE:  CLRF   x5E
081C0:  CLRF   x5F
081C2:  CLRF   x60
081C4:  CLRF   x61
081C6:  CLRF   x62
081C8:  CLRF   x63
081CA:  CLRF   x64
081CC:  CLRF   x65
081CE:  CLRF   x66
081D0:  CLRF   x67
081D2:  CLRF   x68
081D4:  CLRF   x69
081D6:  CLRF   x6A
081D8:  CLRF   x6B
081DA:  CLRF   x6C
081DC:  CLRF   x6D
081DE:  CLRF   x6E
081E0:  CLRF   x6F
081E2:  CLRF   x70
081E4:  CLRF   x71
081E6:  CLRF   x72
081E8:  CLRF   x73
081EA:  CLRF   x74
081EC:  CLRF   x75
081EE:  CLRF   x76
081F0:  CLRF   x77
081F2:  CLRF   x78
081F4:  CLRF   x79
081F6:  CLRF   x7A
081F8:  CLRF   x7B
081FA:  CLRF   x7C
081FC:  CLRF   x7D
081FE:  CLRF   x7E
08200:  CLRF   x7F
08202:  CLRF   x80
08204:  CLRF   x81
08206:  CLRF   x82
08208:  CLRF   x83
0820A:  CLRF   x84
0820C:  CLRF   x85
0820E:  CLRF   x86
08210:  CLRF   x87
08212:  CLRF   x88
08214:  CLRF   x89
08216:  CLRF   x8A
08218:  CLRF   x8B
0821A:  CLRF   x8C
0821C:  CLRF   x8D
0821E:  CLRF   x8E
08220:  CLRF   x8F
08222:  CLRF   x90
08224:  CLRF   x91
08226:  CLRF   x92
08228:  CLRF   x93
0822A:  CLRF   x94
0822C:  CLRF   x95
0822E:  CLRF   x96
08230:  CLRF   x97
08232:  CLRF   x98
08234:  CLRF   x99
08236:  CLRF   x9A
08238:  CLRF   x9B
0823A:  CLRF   x9C
0823C:  CLRF   x9D
0823E:  CLRF   x9E
08240:  CLRF   x9F
08242:  CLRF   xA0
08244:  CLRF   xA1
08246:  CLRF   xA2
08248:  CLRF   xA3
0824A:  CLRF   xA4
0824C:  CLRF   xA5
0824E:  CLRF   xA6
08250:  CLRF   xA7
08252:  CLRF   xA8
08254:  CLRF   xA9
08256:  CLRF   xAA
08258:  CLRF   xAB
0825A:  CLRF   xAC
0825C:  CLRF   xAD
0825E:  CLRF   xAE
08260:  CLRF   xAF
08262:  CLRF   xB0
08264:  CLRF   xB1
08266:  CLRF   xB2
08268:  CLRF   xB3
0826A:  CLRF   xB4
0826C:  CLRF   xB5
0826E:  CLRF   xB6
08270:  CLRF   xB7
08272:  CLRF   xB8
08274:  CLRF   xB9
08276:  CLRF   xBA
08278:  CLRF   xBB
0827A:  CLRF   xBC
0827C:  CLRF   xBD
0827E:  CLRF   xBE
08280:  CLRF   xBF
08282:  CLRF   xC0
08284:  CLRF   xC1
08286:  CLRF   xC2
08288:  CLRF   xC3
0828A:  CLRF   xC4
0828C:  CLRF   xC5
0828E:  CLRF   xC6
08290:  CLRF   xC7
08292:  CLRF   xC8
08294:  CLRF   xC9
08296:  CLRF   xCA
08298:  CLRF   xCB
0829A:  CLRF   xCC
0829C:  CLRF   xCD
0829E:  CLRF   xCE
082A0:  CLRF   xCF
082A2:  CLRF   xD0
082A4:  CLRF   xD1
082A6:  CLRF   xD2
082A8:  CLRF   xD3
082AA:  CLRF   xD4
082AC:  CLRF   xD5
082AE:  CLRF   xD6
082B0:  CLRF   xD7
082B2:  CLRF   xD8
082B4:  CLRF   xD9
082B6:  CLRF   xDA
082B8:  CLRF   xDB
082BA:  CLRF   xDC
082BC:  CLRF   xDD
082BE:  CLRF   xDE
082C0:  CLRF   xDF
082C2:  CLRF   xE0
082C4:  CLRF   xE1
082C6:  CLRF   xE2
082C8:  CLRF   xE3
082CA:  CLRF   xE4
082CC:  CLRF   xE5
082CE:  CLRF   xE6
082D0:  CLRF   xE7
082D2:  CLRF   xE8
082D4:  CLRF   xE9
082D6:  CLRF   xEA
082D8:  CLRF   xEB
082DA:  CLRF   xEC
082DC:  CLRF   xED
082DE:  CLRF   xEE
082E0:  CLRF   xEF
082E2:  CLRF   xF0
082E4:  CLRF   xF1
082E6:  CLRF   xF2
082E8:  CLRF   xF3
082EA:  CLRF   xF4
082EC:  CLRF   xF5
082EE:  CLRF   xF6
082F0:  CLRF   xF7
082F2:  CLRF   xF8
082F4:  CLRF   xF9
082F6:  CLRF   xFA
082F8:  CLRF   xFB
082FA:  CLRF   xFC
082FC:  CLRF   xFD
082FE:  CLRF   xFE
08300:  CLRF   xFF
08302:  MOVLB  4
08304:  CLRF   x00
08306:  CLRF   x01
08308:  CLRF   x02
0830A:  CLRF   x03
0830C:  CLRF   x04
0830E:  CLRF   x05
08310:  CLRF   x06
08312:  CLRF   x07
08314:  CLRF   x08
08316:  CLRF   x09
08318:  CLRF   x0A
0831A:  CLRF   x0B
0831C:  CLRF   x0C
0831E:  CLRF   x0D
08320:  CLRF   x0E
08322:  CLRF   x0F
08324:  CLRF   x10
08326:  CLRF   x11
08328:  CLRF   x12
0832A:  CLRF   x13
0832C:  CLRF   x14
0832E:  CLRF   x15
08330:  CLRF   x16
08332:  CLRF   x17
08334:  CLRF   x18
08336:  CLRF   x19
08338:  CLRF   x1A
0833A:  CLRF   x1B
0833C:  CLRF   x1C
0833E:  CLRF   x1D
08340:  CLRF   x1E
08342:  CLRF   x1F
08344:  CLRF   x20
08346:  CLRF   x21
08348:  CLRF   x22
0834A:  CLRF   x23
0834C:  CLRF   x24
0834E:  CLRF   x25
08350:  CLRF   x26
08352:  CLRF   x27
08354:  CLRF   x28
08356:  CLRF   x29
08358:  CLRF   x2A
0835A:  CLRF   x2B
0835C:  CLRF   x2C
0835E:  CLRF   x2D
08360:  CLRF   x2E
08362:  CLRF   x2F
08364:  CLRF   x30
08366:  CLRF   x31
08368:  CLRF   x32
0836A:  CLRF   x33
0836C:  CLRF   x34
0836E:  CLRF   x35
08370:  CLRF   x36
08372:  CLRF   x37
08374:  CLRF   x38
08376:  CLRF   x39
08378:  CLRF   x3A
0837A:  CLRF   x3B
0837C:  CLRF   x3C
0837E:  CLRF   x3D
08380:  CLRF   x3E
08382:  CLRF   x3F
08384:  CLRF   x40
08386:  CLRF   x41
08388:  CLRF   x42
0838A:  CLRF   x43
0838C:  CLRF   x44
0838E:  CLRF   x45
08390:  CLRF   x46
08392:  CLRF   x47
08394:  CLRF   x48
08396:  CLRF   x49
08398:  CLRF   x4A
0839A:  CLRF   x4B
0839C:  CLRF   x4C
0839E:  CLRF   x4D
083A0:  CLRF   x4E
083A2:  CLRF   x4F
083A4:  CLRF   x50
083A6:  CLRF   x51
083A8:  CLRF   x52
083AA:  CLRF   x53
083AC:  CLRF   x54
083AE:  CLRF   x55
083B0:  CLRF   x56
083B2:  CLRF   x57
083B4:  CLRF   x58
083B6:  CLRF   x59
083B8:  CLRF   x5A
083BA:  CLRF   x5B
083BC:  CLRF   x5C
083BE:  CLRF   x5D
083C0:  CLRF   x5E
083C2:  CLRF   x5F
083C4:  CLRF   x60
083C6:  CLRF   x61
083C8:  CLRF   x62
083CA:  CLRF   x63
083CC:  CLRF   x64
083CE:  CLRF   x65
083D0:  CLRF   x66
083D2:  CLRF   x67
083D4:  CLRF   x68
083D6:  CLRF   x69
083D8:  CLRF   x6A
083DA:  CLRF   x6B
083DC:  CLRF   x6C
083DE:  CLRF   x6D
083E0:  CLRF   x6E
083E2:  CLRF   x6F
083E4:  CLRF   x70
083E6:  CLRF   x71
083E8:  CLRF   x72
083EA:  CLRF   x73
083EC:  CLRF   x74
083EE:  CLRF   x75
083F0:  CLRF   x76
083F2:  CLRF   x77
083F4:  CLRF   x78
083F6:  CLRF   x79
083F8:  CLRF   x7A
083FA:  CLRF   x7B
083FC:  CLRF   x7C
083FE:  CLRF   x7D
08400:  CLRF   x7E
08402:  CLRF   x7F
08404:  CLRF   x80
08406:  CLRF   x81
08408:  CLRF   x82
0840A:  CLRF   x83
0840C:  CLRF   x84
0840E:  CLRF   x85
08410:  CLRF   x86
08412:  CLRF   x87
08414:  CLRF   x88
08416:  CLRF   x89
08418:  CLRF   x8A
0841A:  CLRF   x8B
0841C:  CLRF   x8C
0841E:  CLRF   x8D
08420:  CLRF   x8E
08422:  CLRF   x8F
08424:  CLRF   x90
08426:  CLRF   x91
08428:  CLRF   x92
0842A:  CLRF   x93
0842C:  CLRF   x94
0842E:  CLRF   x95
08430:  CLRF   x96
08432:  CLRF   x97
08434:  CLRF   x98
08436:  CLRF   x99
08438:  CLRF   x9A
0843A:  CLRF   x9B
0843C:  CLRF   x9C
0843E:  CLRF   x9D
08440:  CLRF   x9E
08442:  CLRF   x9F
08444:  CLRF   xA0
08446:  CLRF   xA1
08448:  CLRF   xA2
0844A:  CLRF   xA3
0844C:  CLRF   xA4
0844E:  CLRF   xA5
08450:  CLRF   xA6
08452:  CLRF   xA7
08454:  CLRF   xA8
08456:  CLRF   xA9
08458:  CLRF   xAA
0845A:  CLRF   xAB
0845C:  CLRF   xAC
0845E:  CLRF   xAD
08460:  CLRF   xAE
08462:  CLRF   xAF
08464:  CLRF   xB0
08466:  CLRF   xB1
08468:  CLRF   xB2
0846A:  CLRF   xB3
0846C:  CLRF   xB4
0846E:  CLRF   xB5
08470:  CLRF   xB6
08472:  CLRF   xB7
08474:  CLRF   xB8
08476:  CLRF   xB9
08478:  CLRF   xBA
0847A:  CLRF   xBB
0847C:  CLRF   xBC
0847E:  CLRF   xBD
08480:  CLRF   xBE
08482:  CLRF   xBF
08484:  CLRF   xC0
08486:  CLRF   xC1
08488:  CLRF   xC2
0848A:  CLRF   xC3
0848C:  CLRF   xC4
0848E:  CLRF   xC5
08490:  CLRF   xC6
08492:  CLRF   xC7
08494:  CLRF   xC8
08496:  CLRF   xC9
08498:  CLRF   xCA
0849A:  CLRF   xCB
0849C:  CLRF   xCC
0849E:  CLRF   xCD
084A0:  CLRF   xCE
084A2:  CLRF   xCF
084A4:  CLRF   xD0
084A6:  CLRF   xD1
084A8:  CLRF   xD2
084AA:  CLRF   xD3
084AC:  CLRF   xD4
084AE:  CLRF   xD5
084B0:  CLRF   xD6
084B2:  CLRF   xD7
084B4:  CLRF   xD8
084B6:  CLRF   xD9
084B8:  CLRF   xDA
084BA:  CLRF   xDB
084BC:  CLRF   xDC
084BE:  CLRF   xDD
084C0:  CLRF   xDE
084C2:  CLRF   xDF
084C4:  CLRF   xE0
084C6:  CLRF   xE1
084C8:  CLRF   xE2
084CA:  CLRF   xE3
084CC:  CLRF   xE4
084CE:  CLRF   xE5
084D0:  CLRF   xE6
084D2:  CLRF   xE7
084D4:  CLRF   xE8
084D6:  CLRF   xE9
084D8:  CLRF   xEA
084DA:  CLRF   xEB
084DC:  CLRF   xEC
084DE:  CLRF   xED
084E0:  CLRF   xEE
084E2:  CLRF   xEF
084E4:  CLRF   xF0
084E6:  CLRF   xF1
084E8:  CLRF   xF2
084EA:  CLRF   xF3
084EC:  CLRF   xF4
084EE:  CLRF   xF5
084F0:  CLRF   xF6
084F2:  CLRF   xF7
084F4:  CLRF   xF8
084F6:  CLRF   xF9
084F8:  CLRF   xFA
084FA:  CLRF   xFB
084FC:  CLRF   xFC
084FE:  CLRF   xFD
08500:  CLRF   xFE
08502:  CLRF   xFF
08504:  MOVLB  5
08506:  CLRF   x00
08508:  CLRF   x01
0850A:  CLRF   x02
0850C:  CLRF   x03
0850E:  CLRF   x04
08510:  CLRF   x05
08512:  CLRF   x06
08514:  CLRF   x07
08516:  CLRF   x08
08518:  CLRF   x09
0851A:  CLRF   x0A
0851C:  CLRF   x0B
0851E:  CLRF   x0C
08520:  CLRF   x0D
08522:  CLRF   x0E
08524:  CLRF   x0F
08526:  CLRF   x10
08528:  CLRF   x11
0852A:  CLRF   x12
0852C:  CLRF   x13
0852E:  CLRF   x14
08530:  CLRF   x15
08532:  CLRF   x16
08534:  CLRF   x17
08536:  CLRF   x18
08538:  CLRF   x19
0853A:  CLRF   x1A
0853C:  CLRF   x1B
0853E:  CLRF   x1C
08540:  CLRF   x1D
08542:  CLRF   x1E
08544:  CLRF   x1F
08546:  CLRF   x20
08548:  CLRF   x21
0854A:  CLRF   x22
0854C:  CLRF   x23
0854E:  CLRF   x24
08550:  CLRF   x25
08552:  CLRF   x26
08554:  CLRF   x27
08556:  CLRF   x28
08558:  CLRF   x29
0855A:  CLRF   x2A
0855C:  CLRF   x2B
0855E:  CLRF   x2C
08560:  CLRF   x2D
08562:  CLRF   x2E
08564:  CLRF   x2F
08566:  CLRF   x30
08568:  CLRF   x31
0856A:  CLRF   x32
0856C:  CLRF   x33
0856E:  CLRF   x34
08570:  CLRF   x35
08572:  CLRF   x36
08574:  CLRF   x37
08576:  CLRF   x38
08578:  CLRF   x39
0857A:  CLRF   x3A
0857C:  CLRF   x3B
0857E:  CLRF   x3C
08580:  CLRF   x3D
08582:  CLRF   x3E
08584:  CLRF   x3F
08586:  CLRF   x40
08588:  CLRF   x41
0858A:  CLRF   x42
0858C:  CLRF   x43
0858E:  CLRF   x44
08590:  CLRF   x45
08592:  CLRF   x46
08594:  CLRF   x47
08596:  CLRF   x48
08598:  CLRF   x49
0859A:  CLRF   x4A
0859C:  CLRF   x4B
0859E:  CLRF   x4C
085A0:  CLRF   x4D
085A2:  CLRF   x4E
085A4:  CLRF   x4F
085A6:  CLRF   x50
085A8:  CLRF   x51
085AA:  CLRF   x52
085AC:  CLRF   x53
085AE:  CLRF   x54
085B0:  CLRF   x55
085B2:  CLRF   x56
085B4:  CLRF   x57
085B6:  CLRF   x58
085B8:  CLRF   x59
085BA:  CLRF   x5A
085BC:  CLRF   x5B
085BE:  CLRF   x5C
085C0:  CLRF   x5D
085C2:  CLRF   x5E
085C4:  CLRF   x5F
085C6:  CLRF   x60
085C8:  CLRF   x61
085CA:  CLRF   x62
085CC:  CLRF   x63
085CE:  CLRF   x64
085D0:  CLRF   x65
085D2:  CLRF   x66
085D4:  CLRF   x67
085D6:  CLRF   x68
085D8:  CLRF   x69
085DA:  CLRF   x6A
085DC:  CLRF   x6B
085DE:  CLRF   x6C
085E0:  CLRF   x6D
085E2:  CLRF   x6E
085E4:  CLRF   x6F
085E6:  CLRF   x70
085E8:  CLRF   x71
085EA:  CLRF   x72
085EC:  CLRF   x73
085EE:  CLRF   x74
085F0:  CLRF   x75
085F2:  CLRF   x76
085F4:  CLRF   x77
085F6:  CLRF   x78
085F8:  CLRF   x79
085FA:  CLRF   x7A
085FC:  CLRF   x7B
085FE:  CLRF   x7C
08600:  CLRF   x7D
08602:  CLRF   x7E
08604:  CLRF   x7F
08606:  CLRF   x80
08608:  CLRF   x81
0860A:  CLRF   x82
0860C:  CLRF   x83
0860E:  CLRF   x84
08610:  CLRF   x85
08612:  CLRF   x86
08614:  CLRF   x87
08616:  CLRF   x88
08618:  CLRF   x89
0861A:  CLRF   x8A
0861C:  CLRF   x8B
0861E:  CLRF   x8C
08620:  CLRF   x8D
08622:  CLRF   x8E
08624:  CLRF   x8F
08626:  CLRF   x90
08628:  CLRF   x91
0862A:  CLRF   x92
0862C:  CLRF   x93
0862E:  CLRF   x94
08630:  CLRF   x95
08632:  CLRF   x96
08634:  CLRF   x97
08636:  CLRF   x98
08638:  CLRF   x99
0863A:  CLRF   x9A
0863C:  CLRF   x9B
0863E:  CLRF   x9C
08640:  CLRF   x9D
08642:  CLRF   x9E
08644:  CLRF   x9F
08646:  CLRF   xA0
08648:  CLRF   xA1
0864A:  CLRF   xA2
0864C:  CLRF   xA3
0864E:  CLRF   xA4
08650:  CLRF   xA5
08652:  CLRF   xA6
08654:  CLRF   xA7
08656:  CLRF   xA8
08658:  CLRF   xA9
0865A:  CLRF   xAA
0865C:  CLRF   xAB
0865E:  CLRF   xAC
08660:  CLRF   xAD
08662:  CLRF   xAE
08664:  CLRF   xAF
08666:  CLRF   xB0
08668:  CLRF   xB1
0866A:  CLRF   xB2
0866C:  CLRF   xB3
0866E:  CLRF   xB4
08670:  CLRF   xB5
08672:  CLRF   xB6
08674:  CLRF   xB7
08676:  CLRF   xB8
08678:  CLRF   xB9
0867A:  CLRF   xBA
0867C:  CLRF   xBB
0867E:  CLRF   xBC
08680:  CLRF   xBD
08682:  CLRF   xBE
08684:  CLRF   xBF
08686:  CLRF   xC0
08688:  CLRF   xC1
0868A:  CLRF   xC2
0868C:  CLRF   xC3
0868E:  CLRF   xC4
08690:  CLRF   xC5
08692:  CLRF   xC6
08694:  CLRF   xC7
08696:  CLRF   xC8
08698:  CLRF   xC9
0869A:  CLRF   xCA
0869C:  CLRF   xCB
0869E:  CLRF   xCC
086A0:  CLRF   xCD
086A2:  CLRF   xCE
086A4:  CLRF   xCF
086A6:  CLRF   xD0
086A8:  CLRF   xD1
....................     port1.port_num = 1;
086AA:  MOVLW  01
086AC:  MOVLB  1
086AE:  MOVWF  xD2
....................     port1.sweep_step = 0;
086B0:  CLRF   xD4
086B2:  CLRF   xD3
....................     port1.active = 1;
086B4:  MOVLB  5
086B6:  BSF    xD1.0
.................... 
....................     // Init Port2
....................     sweep_config_t port2 = {0};
086B8:  CLRF   xD2
086BA:  CLRF   xD3
086BC:  CLRF   xD4
086BE:  CLRF   xD5
086C0:  CLRF   xD6
086C2:  CLRF   xD7
086C4:  CLRF   xD8
086C6:  CLRF   xD9
086C8:  CLRF   xDA
086CA:  CLRF   xDB
086CC:  CLRF   xDC
086CE:  CLRF   xDD
086D0:  CLRF   xDE
086D2:  CLRF   xDF
086D4:  CLRF   xE0
086D6:  CLRF   xE1
086D8:  CLRF   xE2
086DA:  CLRF   xE3
086DC:  CLRF   xE4
086DE:  CLRF   xE5
086E0:  CLRF   xE6
086E2:  CLRF   xE7
086E4:  CLRF   xE8
086E6:  CLRF   xE9
086E8:  CLRF   xEA
086EA:  CLRF   xEB
086EC:  CLRF   xEC
086EE:  CLRF   xED
086F0:  CLRF   xEE
086F2:  CLRF   xEF
086F4:  CLRF   xF0
086F6:  CLRF   xF1
086F8:  CLRF   xF2
086FA:  CLRF   xF3
086FC:  CLRF   xF4
086FE:  CLRF   xF5
08700:  CLRF   xF6
08702:  CLRF   xF7
08704:  CLRF   xF8
08706:  CLRF   xF9
08708:  CLRF   xFA
0870A:  CLRF   xFB
0870C:  CLRF   xFC
0870E:  CLRF   xFD
08710:  CLRF   xFE
08712:  CLRF   xFF
08714:  MOVLB  6
08716:  CLRF   x00
08718:  CLRF   x01
0871A:  CLRF   x02
0871C:  CLRF   x03
0871E:  CLRF   x04
08720:  CLRF   x05
08722:  CLRF   x06
08724:  CLRF   x07
08726:  CLRF   x08
08728:  CLRF   x09
0872A:  CLRF   x0A
0872C:  CLRF   x0B
0872E:  CLRF   x0C
08730:  CLRF   x0D
08732:  CLRF   x0E
08734:  CLRF   x0F
08736:  CLRF   x10
08738:  CLRF   x11
0873A:  CLRF   x12
0873C:  CLRF   x13
0873E:  CLRF   x14
08740:  CLRF   x15
08742:  CLRF   x16
08744:  CLRF   x17
08746:  CLRF   x18
08748:  CLRF   x19
0874A:  CLRF   x1A
0874C:  CLRF   x1B
0874E:  CLRF   x1C
08750:  CLRF   x1D
08752:  CLRF   x1E
08754:  CLRF   x1F
08756:  CLRF   x20
08758:  CLRF   x21
0875A:  CLRF   x22
0875C:  CLRF   x23
0875E:  CLRF   x24
08760:  CLRF   x25
08762:  CLRF   x26
08764:  CLRF   x27
08766:  CLRF   x28
08768:  CLRF   x29
0876A:  CLRF   x2A
0876C:  CLRF   x2B
0876E:  CLRF   x2C
08770:  CLRF   x2D
08772:  CLRF   x2E
08774:  CLRF   x2F
08776:  CLRF   x30
08778:  CLRF   x31
0877A:  CLRF   x32
0877C:  CLRF   x33
0877E:  CLRF   x34
08780:  CLRF   x35
08782:  CLRF   x36
08784:  CLRF   x37
08786:  CLRF   x38
08788:  CLRF   x39
0878A:  CLRF   x3A
0878C:  CLRF   x3B
0878E:  CLRF   x3C
08790:  CLRF   x3D
08792:  CLRF   x3E
08794:  CLRF   x3F
08796:  CLRF   x40
08798:  CLRF   x41
0879A:  CLRF   x42
0879C:  CLRF   x43
0879E:  CLRF   x44
087A0:  CLRF   x45
087A2:  CLRF   x46
087A4:  CLRF   x47
087A6:  CLRF   x48
087A8:  CLRF   x49
087AA:  CLRF   x4A
087AC:  CLRF   x4B
087AE:  CLRF   x4C
087B0:  CLRF   x4D
087B2:  CLRF   x4E
087B4:  CLRF   x4F
087B6:  CLRF   x50
087B8:  CLRF   x51
087BA:  CLRF   x52
087BC:  CLRF   x53
087BE:  CLRF   x54
087C0:  CLRF   x55
087C2:  CLRF   x56
087C4:  CLRF   x57
087C6:  CLRF   x58
087C8:  CLRF   x59
087CA:  CLRF   x5A
087CC:  CLRF   x5B
087CE:  CLRF   x5C
087D0:  CLRF   x5D
087D2:  CLRF   x5E
087D4:  CLRF   x5F
087D6:  CLRF   x60
087D8:  CLRF   x61
087DA:  CLRF   x62
087DC:  CLRF   x63
087DE:  CLRF   x64
087E0:  CLRF   x65
087E2:  CLRF   x66
087E4:  CLRF   x67
087E6:  CLRF   x68
087E8:  CLRF   x69
087EA:  CLRF   x6A
087EC:  CLRF   x6B
087EE:  CLRF   x6C
087F0:  CLRF   x6D
087F2:  CLRF   x6E
087F4:  CLRF   x6F
087F6:  CLRF   x70
087F8:  CLRF   x71
087FA:  CLRF   x72
087FC:  CLRF   x73
087FE:  CLRF   x74
08800:  CLRF   x75
08802:  CLRF   x76
08804:  CLRF   x77
08806:  CLRF   x78
08808:  CLRF   x79
0880A:  CLRF   x7A
0880C:  CLRF   x7B
0880E:  CLRF   x7C
08810:  CLRF   x7D
08812:  CLRF   x7E
08814:  CLRF   x7F
08816:  CLRF   x80
08818:  CLRF   x81
0881A:  CLRF   x82
0881C:  CLRF   x83
0881E:  CLRF   x84
08820:  CLRF   x85
08822:  CLRF   x86
08824:  CLRF   x87
08826:  CLRF   x88
08828:  CLRF   x89
0882A:  CLRF   x8A
0882C:  CLRF   x8B
0882E:  CLRF   x8C
08830:  CLRF   x8D
08832:  CLRF   x8E
08834:  CLRF   x8F
08836:  CLRF   x90
08838:  CLRF   x91
0883A:  CLRF   x92
0883C:  CLRF   x93
0883E:  CLRF   x94
08840:  CLRF   x95
08842:  CLRF   x96
08844:  CLRF   x97
08846:  CLRF   x98
08848:  CLRF   x99
0884A:  CLRF   x9A
0884C:  CLRF   x9B
0884E:  CLRF   x9C
08850:  CLRF   x9D
08852:  CLRF   x9E
08854:  CLRF   x9F
08856:  CLRF   xA0
08858:  CLRF   xA1
0885A:  CLRF   xA2
0885C:  CLRF   xA3
0885E:  CLRF   xA4
08860:  CLRF   xA5
08862:  CLRF   xA6
08864:  CLRF   xA7
08866:  CLRF   xA8
08868:  CLRF   xA9
0886A:  CLRF   xAA
0886C:  CLRF   xAB
0886E:  CLRF   xAC
08870:  CLRF   xAD
08872:  CLRF   xAE
08874:  CLRF   xAF
08876:  CLRF   xB0
08878:  CLRF   xB1
0887A:  CLRF   xB2
0887C:  CLRF   xB3
0887E:  CLRF   xB4
08880:  CLRF   xB5
08882:  CLRF   xB6
08884:  CLRF   xB7
08886:  CLRF   xB8
08888:  CLRF   xB9
0888A:  CLRF   xBA
0888C:  CLRF   xBB
0888E:  CLRF   xBC
08890:  CLRF   xBD
08892:  CLRF   xBE
08894:  CLRF   xBF
08896:  CLRF   xC0
08898:  CLRF   xC1
0889A:  CLRF   xC2
0889C:  CLRF   xC3
0889E:  CLRF   xC4
088A0:  CLRF   xC5
088A2:  CLRF   xC6
088A4:  CLRF   xC7
088A6:  CLRF   xC8
088A8:  CLRF   xC9
088AA:  CLRF   xCA
088AC:  CLRF   xCB
088AE:  CLRF   xCC
088B0:  CLRF   xCD
088B2:  CLRF   xCE
088B4:  CLRF   xCF
088B6:  CLRF   xD0
088B8:  CLRF   xD1
088BA:  CLRF   xD2
088BC:  CLRF   xD3
088BE:  CLRF   xD4
088C0:  CLRF   xD5
088C2:  CLRF   xD6
088C4:  CLRF   xD7
088C6:  CLRF   xD8
088C8:  CLRF   xD9
088CA:  CLRF   xDA
088CC:  CLRF   xDB
088CE:  CLRF   xDC
088D0:  CLRF   xDD
088D2:  CLRF   xDE
088D4:  CLRF   xDF
088D6:  CLRF   xE0
088D8:  CLRF   xE1
088DA:  CLRF   xE2
088DC:  CLRF   xE3
088DE:  CLRF   xE4
088E0:  CLRF   xE5
088E2:  CLRF   xE6
088E4:  CLRF   xE7
088E6:  CLRF   xE8
088E8:  CLRF   xE9
088EA:  CLRF   xEA
088EC:  CLRF   xEB
088EE:  CLRF   xEC
088F0:  CLRF   xED
088F2:  CLRF   xEE
088F4:  CLRF   xEF
088F6:  CLRF   xF0
088F8:  CLRF   xF1
088FA:  CLRF   xF2
088FC:  CLRF   xF3
088FE:  CLRF   xF4
08900:  CLRF   xF5
08902:  CLRF   xF6
08904:  CLRF   xF7
08906:  CLRF   xF8
08908:  CLRF   xF9
0890A:  CLRF   xFA
0890C:  CLRF   xFB
0890E:  CLRF   xFC
08910:  CLRF   xFD
08912:  CLRF   xFE
08914:  CLRF   xFF
08916:  MOVLB  7
08918:  CLRF   x00
0891A:  CLRF   x01
0891C:  CLRF   x02
0891E:  CLRF   x03
08920:  CLRF   x04
08922:  CLRF   x05
08924:  CLRF   x06
08926:  CLRF   x07
08928:  CLRF   x08
0892A:  CLRF   x09
0892C:  CLRF   x0A
0892E:  CLRF   x0B
08930:  CLRF   x0C
08932:  CLRF   x0D
08934:  CLRF   x0E
08936:  CLRF   x0F
08938:  CLRF   x10
0893A:  CLRF   x11
0893C:  CLRF   x12
0893E:  CLRF   x13
08940:  CLRF   x14
08942:  CLRF   x15
08944:  CLRF   x16
08946:  CLRF   x17
08948:  CLRF   x18
0894A:  CLRF   x19
0894C:  CLRF   x1A
0894E:  CLRF   x1B
08950:  CLRF   x1C
08952:  CLRF   x1D
08954:  CLRF   x1E
08956:  CLRF   x1F
08958:  CLRF   x20
0895A:  CLRF   x21
0895C:  CLRF   x22
0895E:  CLRF   x23
08960:  CLRF   x24
08962:  CLRF   x25
08964:  CLRF   x26
08966:  CLRF   x27
08968:  CLRF   x28
0896A:  CLRF   x29
0896C:  CLRF   x2A
0896E:  CLRF   x2B
08970:  CLRF   x2C
08972:  CLRF   x2D
08974:  CLRF   x2E
08976:  CLRF   x2F
08978:  CLRF   x30
0897A:  CLRF   x31
0897C:  CLRF   x32
0897E:  CLRF   x33
08980:  CLRF   x34
08982:  CLRF   x35
08984:  CLRF   x36
08986:  CLRF   x37
08988:  CLRF   x38
0898A:  CLRF   x39
0898C:  CLRF   x3A
0898E:  CLRF   x3B
08990:  CLRF   x3C
08992:  CLRF   x3D
08994:  CLRF   x3E
08996:  CLRF   x3F
08998:  CLRF   x40
0899A:  CLRF   x41
0899C:  CLRF   x42
0899E:  CLRF   x43
089A0:  CLRF   x44
089A2:  CLRF   x45
089A4:  CLRF   x46
089A6:  CLRF   x47
089A8:  CLRF   x48
089AA:  CLRF   x49
089AC:  CLRF   x4A
089AE:  CLRF   x4B
089B0:  CLRF   x4C
089B2:  CLRF   x4D
089B4:  CLRF   x4E
089B6:  CLRF   x4F
089B8:  CLRF   x50
089BA:  CLRF   x51
089BC:  CLRF   x52
089BE:  CLRF   x53
089C0:  CLRF   x54
089C2:  CLRF   x55
089C4:  CLRF   x56
089C6:  CLRF   x57
089C8:  CLRF   x58
089CA:  CLRF   x59
089CC:  CLRF   x5A
089CE:  CLRF   x5B
089D0:  CLRF   x5C
089D2:  CLRF   x5D
089D4:  CLRF   x5E
089D6:  CLRF   x5F
089D8:  CLRF   x60
089DA:  CLRF   x61
089DC:  CLRF   x62
089DE:  CLRF   x63
089E0:  CLRF   x64
089E2:  CLRF   x65
089E4:  CLRF   x66
089E6:  CLRF   x67
089E8:  CLRF   x68
089EA:  CLRF   x69
089EC:  CLRF   x6A
089EE:  CLRF   x6B
089F0:  CLRF   x6C
089F2:  CLRF   x6D
089F4:  CLRF   x6E
089F6:  CLRF   x6F
089F8:  CLRF   x70
089FA:  CLRF   x71
089FC:  CLRF   x72
089FE:  CLRF   x73
08A00:  CLRF   x74
08A02:  CLRF   x75
08A04:  CLRF   x76
08A06:  CLRF   x77
08A08:  CLRF   x78
08A0A:  CLRF   x79
08A0C:  CLRF   x7A
08A0E:  CLRF   x7B
08A10:  CLRF   x7C
08A12:  CLRF   x7D
08A14:  CLRF   x7E
08A16:  CLRF   x7F
08A18:  CLRF   x80
08A1A:  CLRF   x81
08A1C:  CLRF   x82
08A1E:  CLRF   x83
08A20:  CLRF   x84
08A22:  CLRF   x85
08A24:  CLRF   x86
08A26:  CLRF   x87
08A28:  CLRF   x88
08A2A:  CLRF   x89
08A2C:  CLRF   x8A
08A2E:  CLRF   x8B
08A30:  CLRF   x8C
08A32:  CLRF   x8D
08A34:  CLRF   x8E
08A36:  CLRF   x8F
08A38:  CLRF   x90
08A3A:  CLRF   x91
08A3C:  CLRF   x92
08A3E:  CLRF   x93
08A40:  CLRF   x94
08A42:  CLRF   x95
08A44:  CLRF   x96
08A46:  CLRF   x97
08A48:  CLRF   x98
08A4A:  CLRF   x99
08A4C:  CLRF   x9A
08A4E:  CLRF   x9B
08A50:  CLRF   x9C
08A52:  CLRF   x9D
08A54:  CLRF   x9E
08A56:  CLRF   x9F
08A58:  CLRF   xA0
08A5A:  CLRF   xA1
08A5C:  CLRF   xA2
08A5E:  CLRF   xA3
08A60:  CLRF   xA4
08A62:  CLRF   xA5
08A64:  CLRF   xA6
08A66:  CLRF   xA7
08A68:  CLRF   xA8
08A6A:  CLRF   xA9
08A6C:  CLRF   xAA
08A6E:  CLRF   xAB
08A70:  CLRF   xAC
08A72:  CLRF   xAD
08A74:  CLRF   xAE
08A76:  CLRF   xAF
08A78:  CLRF   xB0
08A7A:  CLRF   xB1
08A7C:  CLRF   xB2
08A7E:  CLRF   xB3
08A80:  CLRF   xB4
08A82:  CLRF   xB5
08A84:  CLRF   xB6
08A86:  CLRF   xB7
08A88:  CLRF   xB8
08A8A:  CLRF   xB9
08A8C:  CLRF   xBA
08A8E:  CLRF   xBB
08A90:  CLRF   xBC
08A92:  CLRF   xBD
08A94:  CLRF   xBE
08A96:  CLRF   xBF
08A98:  CLRF   xC0
08A9A:  CLRF   xC1
08A9C:  CLRF   xC2
08A9E:  CLRF   xC3
08AA0:  CLRF   xC4
08AA2:  CLRF   xC5
08AA4:  CLRF   xC6
08AA6:  CLRF   xC7
08AA8:  CLRF   xC8
08AAA:  CLRF   xC9
08AAC:  CLRF   xCA
08AAE:  CLRF   xCB
08AB0:  CLRF   xCC
08AB2:  CLRF   xCD
08AB4:  CLRF   xCE
08AB6:  CLRF   xCF
08AB8:  CLRF   xD0
08ABA:  CLRF   xD1
08ABC:  CLRF   xD2
08ABE:  CLRF   xD3
08AC0:  CLRF   xD4
08AC2:  CLRF   xD5
08AC4:  CLRF   xD6
08AC6:  CLRF   xD7
08AC8:  CLRF   xD8
08ACA:  CLRF   xD9
08ACC:  CLRF   xDA
08ACE:  CLRF   xDB
08AD0:  CLRF   xDC
08AD2:  CLRF   xDD
08AD4:  CLRF   xDE
08AD6:  CLRF   xDF
08AD8:  CLRF   xE0
08ADA:  CLRF   xE1
08ADC:  CLRF   xE2
08ADE:  CLRF   xE3
08AE0:  CLRF   xE4
08AE2:  CLRF   xE5
08AE4:  CLRF   xE6
08AE6:  CLRF   xE7
08AE8:  CLRF   xE8
08AEA:  CLRF   xE9
08AEC:  CLRF   xEA
08AEE:  CLRF   xEB
08AF0:  CLRF   xEC
08AF2:  CLRF   xED
08AF4:  CLRF   xEE
08AF6:  CLRF   xEF
08AF8:  CLRF   xF0
08AFA:  CLRF   xF1
08AFC:  CLRF   xF2
08AFE:  CLRF   xF3
08B00:  CLRF   xF4
08B02:  CLRF   xF5
08B04:  CLRF   xF6
08B06:  CLRF   xF7
08B08:  CLRF   xF8
08B0A:  CLRF   xF9
08B0C:  CLRF   xFA
08B0E:  CLRF   xFB
08B10:  CLRF   xFC
08B12:  CLRF   xFD
08B14:  CLRF   xFE
08B16:  CLRF   xFF
08B18:  MOVLB  8
08B1A:  CLRF   x00
08B1C:  CLRF   x01
08B1E:  CLRF   x02
08B20:  CLRF   x03
08B22:  CLRF   x04
08B24:  CLRF   x05
08B26:  CLRF   x06
08B28:  CLRF   x07
08B2A:  CLRF   x08
08B2C:  CLRF   x09
08B2E:  CLRF   x0A
08B30:  CLRF   x0B
08B32:  CLRF   x0C
08B34:  CLRF   x0D
08B36:  CLRF   x0E
08B38:  CLRF   x0F
08B3A:  CLRF   x10
08B3C:  CLRF   x11
08B3E:  CLRF   x12
08B40:  CLRF   x13
08B42:  CLRF   x14
08B44:  CLRF   x15
08B46:  CLRF   x16
08B48:  CLRF   x17
08B4A:  CLRF   x18
08B4C:  CLRF   x19
08B4E:  CLRF   x1A
08B50:  CLRF   x1B
08B52:  CLRF   x1C
08B54:  CLRF   x1D
08B56:  CLRF   x1E
08B58:  CLRF   x1F
08B5A:  CLRF   x20
08B5C:  CLRF   x21
08B5E:  CLRF   x22
08B60:  CLRF   x23
08B62:  CLRF   x24
08B64:  CLRF   x25
08B66:  CLRF   x26
08B68:  CLRF   x27
08B6A:  CLRF   x28
08B6C:  CLRF   x29
08B6E:  CLRF   x2A
08B70:  CLRF   x2B
08B72:  CLRF   x2C
08B74:  CLRF   x2D
08B76:  CLRF   x2E
08B78:  CLRF   x2F
08B7A:  CLRF   x30
08B7C:  CLRF   x31
08B7E:  CLRF   x32
08B80:  CLRF   x33
08B82:  CLRF   x34
08B84:  CLRF   x35
08B86:  CLRF   x36
08B88:  CLRF   x37
08B8A:  CLRF   x38
08B8C:  CLRF   x39
08B8E:  CLRF   x3A
08B90:  CLRF   x3B
08B92:  CLRF   x3C
08B94:  CLRF   x3D
08B96:  CLRF   x3E
08B98:  CLRF   x3F
08B9A:  CLRF   x40
08B9C:  CLRF   x41
08B9E:  CLRF   x42
08BA0:  CLRF   x43
08BA2:  CLRF   x44
08BA4:  CLRF   x45
08BA6:  CLRF   x46
08BA8:  CLRF   x47
08BAA:  CLRF   x48
08BAC:  CLRF   x49
08BAE:  CLRF   x4A
08BB0:  CLRF   x4B
08BB2:  CLRF   x4C
08BB4:  CLRF   x4D
08BB6:  CLRF   x4E
08BB8:  CLRF   x4F
08BBA:  CLRF   x50
08BBC:  CLRF   x51
08BBE:  CLRF   x52
08BC0:  CLRF   x53
08BC2:  CLRF   x54
08BC4:  CLRF   x55
08BC6:  CLRF   x56
08BC8:  CLRF   x57
08BCA:  CLRF   x58
08BCC:  CLRF   x59
08BCE:  CLRF   x5A
08BD0:  CLRF   x5B
08BD2:  CLRF   x5C
08BD4:  CLRF   x5D
08BD6:  CLRF   x5E
08BD8:  CLRF   x5F
08BDA:  CLRF   x60
08BDC:  CLRF   x61
08BDE:  CLRF   x62
08BE0:  CLRF   x63
08BE2:  CLRF   x64
08BE4:  CLRF   x65
08BE6:  CLRF   x66
08BE8:  CLRF   x67
08BEA:  CLRF   x68
08BEC:  CLRF   x69
08BEE:  CLRF   x6A
08BF0:  CLRF   x6B
08BF2:  CLRF   x6C
08BF4:  CLRF   x6D
08BF6:  CLRF   x6E
08BF8:  CLRF   x6F
08BFA:  CLRF   x70
08BFC:  CLRF   x71
08BFE:  CLRF   x72
08C00:  CLRF   x73
08C02:  CLRF   x74
08C04:  CLRF   x75
08C06:  CLRF   x76
08C08:  CLRF   x77
08C0A:  CLRF   x78
08C0C:  CLRF   x79
08C0E:  CLRF   x7A
08C10:  CLRF   x7B
08C12:  CLRF   x7C
08C14:  CLRF   x7D
08C16:  CLRF   x7E
08C18:  CLRF   x7F
08C1A:  CLRF   x80
08C1C:  CLRF   x81
08C1E:  CLRF   x82
08C20:  CLRF   x83
08C22:  CLRF   x84
08C24:  CLRF   x85
08C26:  CLRF   x86
08C28:  CLRF   x87
08C2A:  CLRF   x88
08C2C:  CLRF   x89
08C2E:  CLRF   x8A
08C30:  CLRF   x8B
08C32:  CLRF   x8C
08C34:  CLRF   x8D
08C36:  CLRF   x8E
08C38:  CLRF   x8F
08C3A:  CLRF   x90
08C3C:  CLRF   x91
08C3E:  CLRF   x92
08C40:  CLRF   x93
08C42:  CLRF   x94
08C44:  CLRF   x95
08C46:  CLRF   x96
08C48:  CLRF   x97
08C4A:  CLRF   x98
08C4C:  CLRF   x99
08C4E:  CLRF   x9A
08C50:  CLRF   x9B
08C52:  CLRF   x9C
08C54:  CLRF   x9D
08C56:  CLRF   x9E
08C58:  CLRF   x9F
08C5A:  CLRF   xA0
08C5C:  CLRF   xA1
08C5E:  CLRF   xA2
08C60:  CLRF   xA3
08C62:  CLRF   xA4
08C64:  CLRF   xA5
08C66:  CLRF   xA6
08C68:  CLRF   xA7
08C6A:  CLRF   xA8
08C6C:  CLRF   xA9
08C6E:  CLRF   xAA
08C70:  CLRF   xAB
08C72:  CLRF   xAC
08C74:  CLRF   xAD
08C76:  CLRF   xAE
08C78:  CLRF   xAF
08C7A:  CLRF   xB0
08C7C:  CLRF   xB1
08C7E:  CLRF   xB2
08C80:  CLRF   xB3
08C82:  CLRF   xB4
08C84:  CLRF   xB5
08C86:  CLRF   xB6
08C88:  CLRF   xB7
08C8A:  CLRF   xB8
08C8C:  CLRF   xB9
08C8E:  CLRF   xBA
08C90:  CLRF   xBB
08C92:  CLRF   xBC
08C94:  CLRF   xBD
08C96:  CLRF   xBE
08C98:  CLRF   xBF
08C9A:  CLRF   xC0
08C9C:  CLRF   xC1
08C9E:  CLRF   xC2
08CA0:  CLRF   xC3
08CA2:  CLRF   xC4
08CA4:  CLRF   xC5
08CA6:  CLRF   xC6
08CA8:  CLRF   xC7
08CAA:  CLRF   xC8
08CAC:  CLRF   xC9
08CAE:  CLRF   xCA
08CB0:  CLRF   xCB
08CB2:  CLRF   xCC
08CB4:  CLRF   xCD
08CB6:  CLRF   xCE
08CB8:  CLRF   xCF
08CBA:  CLRF   xD0
08CBC:  CLRF   xD1
08CBE:  CLRF   xD2
08CC0:  CLRF   xD3
08CC2:  CLRF   xD4
08CC4:  CLRF   xD5
08CC6:  CLRF   xD6
08CC8:  CLRF   xD7
08CCA:  CLRF   xD8
08CCC:  CLRF   xD9
08CCE:  CLRF   xDA
08CD0:  CLRF   xDB
08CD2:  CLRF   xDC
08CD4:  CLRF   xDD
08CD6:  CLRF   xDE
08CD8:  CLRF   xDF
08CDA:  CLRF   xE0
08CDC:  CLRF   xE1
08CDE:  CLRF   xE2
08CE0:  CLRF   xE3
08CE2:  CLRF   xE4
08CE4:  CLRF   xE5
08CE6:  CLRF   xE6
08CE8:  CLRF   xE7
08CEA:  CLRF   xE8
08CEC:  CLRF   xE9
08CEE:  CLRF   xEA
08CF0:  CLRF   xEB
08CF2:  CLRF   xEC
08CF4:  CLRF   xED
08CF6:  CLRF   xEE
08CF8:  CLRF   xEF
08CFA:  CLRF   xF0
08CFC:  CLRF   xF1
08CFE:  CLRF   xF2
08D00:  CLRF   xF3
08D02:  CLRF   xF4
08D04:  CLRF   xF5
08D06:  CLRF   xF6
08D08:  CLRF   xF7
08D0A:  CLRF   xF8
08D0C:  CLRF   xF9
08D0E:  CLRF   xFA
08D10:  CLRF   xFB
08D12:  CLRF   xFC
08D14:  CLRF   xFD
08D16:  CLRF   xFE
08D18:  CLRF   xFF
08D1A:  MOVLB  9
08D1C:  CLRF   x00
08D1E:  CLRF   x01
08D20:  CLRF   x02
08D22:  CLRF   x03
08D24:  CLRF   x04
08D26:  CLRF   x05
08D28:  CLRF   x06
08D2A:  CLRF   x07
08D2C:  CLRF   x08
08D2E:  CLRF   x09
08D30:  CLRF   x0A
08D32:  CLRF   x0B
08D34:  CLRF   x0C
08D36:  CLRF   x0D
08D38:  CLRF   x0E
08D3A:  CLRF   x0F
08D3C:  CLRF   x10
08D3E:  CLRF   x11
08D40:  CLRF   x12
08D42:  CLRF   x13
08D44:  CLRF   x14
08D46:  CLRF   x15
08D48:  CLRF   x16
08D4A:  CLRF   x17
08D4C:  CLRF   x18
08D4E:  CLRF   x19
08D50:  CLRF   x1A
08D52:  CLRF   x1B
08D54:  CLRF   x1C
08D56:  CLRF   x1D
08D58:  CLRF   x1E
08D5A:  CLRF   x1F
08D5C:  CLRF   x20
08D5E:  CLRF   x21
08D60:  CLRF   x22
08D62:  CLRF   x23
08D64:  CLRF   x24
08D66:  CLRF   x25
08D68:  CLRF   x26
08D6A:  CLRF   x27
08D6C:  CLRF   x28
08D6E:  CLRF   x29
08D70:  CLRF   x2A
08D72:  CLRF   x2B
08D74:  CLRF   x2C
08D76:  CLRF   x2D
08D78:  CLRF   x2E
08D7A:  CLRF   x2F
08D7C:  CLRF   x30
08D7E:  CLRF   x31
08D80:  CLRF   x32
08D82:  CLRF   x33
08D84:  CLRF   x34
08D86:  CLRF   x35
08D88:  CLRF   x36
08D8A:  CLRF   x37
08D8C:  CLRF   x38
08D8E:  CLRF   x39
08D90:  CLRF   x3A
08D92:  CLRF   x3B
08D94:  CLRF   x3C
08D96:  CLRF   x3D
08D98:  CLRF   x3E
08D9A:  CLRF   x3F
08D9C:  CLRF   x40
08D9E:  CLRF   x41
08DA0:  CLRF   x42
08DA2:  CLRF   x43
08DA4:  CLRF   x44
08DA6:  CLRF   x45
08DA8:  CLRF   x46
08DAA:  CLRF   x47
08DAC:  CLRF   x48
08DAE:  CLRF   x49
08DB0:  CLRF   x4A
08DB2:  CLRF   x4B
08DB4:  CLRF   x4C
08DB6:  CLRF   x4D
08DB8:  CLRF   x4E
08DBA:  CLRF   x4F
08DBC:  CLRF   x50
08DBE:  CLRF   x51
08DC0:  CLRF   x52
08DC2:  CLRF   x53
08DC4:  CLRF   x54
08DC6:  CLRF   x55
08DC8:  CLRF   x56
08DCA:  CLRF   x57
08DCC:  CLRF   x58
08DCE:  CLRF   x59
08DD0:  CLRF   x5A
08DD2:  CLRF   x5B
08DD4:  CLRF   x5C
08DD6:  CLRF   x5D
08DD8:  CLRF   x5E
08DDA:  CLRF   x5F
08DDC:  CLRF   x60
08DDE:  CLRF   x61
08DE0:  CLRF   x62
08DE2:  CLRF   x63
08DE4:  CLRF   x64
08DE6:  CLRF   x65
08DE8:  CLRF   x66
08DEA:  CLRF   x67
08DEC:  CLRF   x68
08DEE:  CLRF   x69
08DF0:  CLRF   x6A
08DF2:  CLRF   x6B
08DF4:  CLRF   x6C
08DF6:  CLRF   x6D
08DF8:  CLRF   x6E
08DFA:  CLRF   x6F
08DFC:  CLRF   x70
08DFE:  CLRF   x71
08E00:  CLRF   x72
08E02:  CLRF   x73
08E04:  CLRF   x74
08E06:  CLRF   x75
08E08:  CLRF   x76
08E0A:  CLRF   x77
08E0C:  CLRF   x78
08E0E:  CLRF   x79
08E10:  CLRF   x7A
08E12:  CLRF   x7B
08E14:  CLRF   x7C
08E16:  CLRF   x7D
08E18:  CLRF   x7E
08E1A:  CLRF   x7F
08E1C:  CLRF   x80
08E1E:  CLRF   x81
08E20:  CLRF   x82
08E22:  CLRF   x83
08E24:  CLRF   x84
08E26:  CLRF   x85
08E28:  CLRF   x86
08E2A:  CLRF   x87
08E2C:  CLRF   x88
08E2E:  CLRF   x89
08E30:  CLRF   x8A
08E32:  CLRF   x8B
08E34:  CLRF   x8C
08E36:  CLRF   x8D
08E38:  CLRF   x8E
08E3A:  CLRF   x8F
08E3C:  CLRF   x90
08E3E:  CLRF   x91
08E40:  CLRF   x92
08E42:  CLRF   x93
08E44:  CLRF   x94
08E46:  CLRF   x95
08E48:  CLRF   x96
08E4A:  CLRF   x97
08E4C:  CLRF   x98
08E4E:  CLRF   x99
08E50:  CLRF   x9A
08E52:  CLRF   x9B
08E54:  CLRF   x9C
08E56:  CLRF   x9D
08E58:  CLRF   x9E
08E5A:  CLRF   x9F
08E5C:  CLRF   xA0
08E5E:  CLRF   xA1
08E60:  CLRF   xA2
08E62:  CLRF   xA3
08E64:  CLRF   xA4
08E66:  CLRF   xA5
08E68:  CLRF   xA6
08E6A:  CLRF   xA7
08E6C:  CLRF   xA8
08E6E:  CLRF   xA9
08E70:  CLRF   xAA
08E72:  CLRF   xAB
08E74:  CLRF   xAC
08E76:  CLRF   xAD
08E78:  CLRF   xAE
08E7A:  CLRF   xAF
08E7C:  CLRF   xB0
08E7E:  CLRF   xB1
08E80:  CLRF   xB2
08E82:  CLRF   xB3
08E84:  CLRF   xB4
08E86:  CLRF   xB5
08E88:  CLRF   xB6
08E8A:  CLRF   xB7
08E8C:  CLRF   xB8
08E8E:  CLRF   xB9
08E90:  CLRF   xBA
08E92:  CLRF   xBB
08E94:  CLRF   xBC
08E96:  CLRF   xBD
08E98:  CLRF   xBE
08E9A:  CLRF   xBF
08E9C:  CLRF   xC0
08E9E:  CLRF   xC1
08EA0:  CLRF   xC2
08EA2:  CLRF   xC3
08EA4:  CLRF   xC4
08EA6:  CLRF   xC5
08EA8:  CLRF   xC6
08EAA:  CLRF   xC7
08EAC:  CLRF   xC8
08EAE:  CLRF   xC9
08EB0:  CLRF   xCA
08EB2:  CLRF   xCB
08EB4:  CLRF   xCC
08EB6:  CLRF   xCD
08EB8:  CLRF   xCE
08EBA:  CLRF   xCF
08EBC:  CLRF   xD0
08EBE:  CLRF   xD1
....................     port2.port_num = 2;
08EC0:  MOVLW  02
08EC2:  MOVLB  5
08EC4:  MOVWF  xD2
....................     port2.sweep_step = 0;
08EC6:  CLRF   xD4
08EC8:  CLRF   xD3
....................     port2.active = 1;
08ECA:  MOVLB  9
08ECC:  BSF    xD1.0
.................... 
....................     int16 count = 1;
08ECE:  CLRF   xD3
08ED0:  MOVLW  01
08ED2:  MOVWF  xD2
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
08ED4:  CLRF   xE1
08ED6:  MOVLW  01
08ED8:  MOVWF  xE0
08EDA:  MOVLB  0
08EDC:  CALL   222A
....................     mcp4901_2_write(1);
08EE0:  MOVLB  9
08EE2:  CLRF   xE1
08EE4:  MOVLW  01
08EE6:  MOVWF  xE0
08EE8:  MOVLB  0
08EEA:  CALL   226C
.................... 
....................     iv_env_t measured_data = create_meas_data();
08EEE:  GOTO   7468
08EF2:  MOVFF  02,03
08EF6:  MOVF   01,W
08EF8:  MOVWF  FE1
08EFA:  MOVFF  03,FE2
08EFE:  MOVLW  09
08F00:  MOVWF  FEA
08F02:  MOVLW  D4
08F04:  MOVWF  FE9
08F06:  MOVLW  0C
08F08:  MOVWF  01
08F0A:  MOVFF  FE6,FEE
08F0E:  DECFSZ 01,F
08F10:  GOTO   8F0A
....................     while (port1.active || port2.active)
08F14:  MOVLB  5
08F16:  BTFSS  xD1.0
08F18:  BRA    8F20
08F1A:  MOVLB  0
08F1C:  GOTO   8F30
08F20:  MOVLB  0
08F22:  MOVLB  9
08F24:  BTFSC  xD1.0
08F26:  BRA    8F2E
08F28:  MOVLB  0
08F2A:  GOTO   926C
08F2E:  MOVLB  0
....................     {
....................         mcp4901_1_write(count);
08F30:  MOVFF  9D3,9E1
08F34:  MOVFF  9D2,9E0
08F38:  CALL   222A
....................         mcp4901_2_write(count);
08F3C:  MOVFF  9D3,9E1
08F40:  MOVFF  9D2,9E0
08F44:  CALL   226C
....................         delay_us(10); // wait for DAC to stabilize
08F48:  MOVLW  0D
08F4A:  MOVWF  00
08F4C:  DECFSZ 00,F
08F4E:  BRA    8F4C
.................... 
....................         if (port1.active) {
08F50:  MOVLB  5
08F52:  BTFSC  xD1.0
08F54:  BRA    8F5C
08F56:  MOVLB  0
08F58:  GOTO   8FE8
08F5C:  MOVLB  0
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
08F5E:  BCF    FD8.0
08F60:  MOVLB  9
08F62:  RLCF   xD2,W
08F64:  MOVWF  02
08F66:  RLCF   xD3,W
08F68:  MOVWF  03
08F6A:  MOVF   02,W
08F6C:  ADDLW  D5
08F6E:  MOVWF  01
08F70:  MOVLW  01
08F72:  ADDWFC 03,F
08F74:  MOVF   01,W
08F76:  MOVWF  xE0
08F78:  MOVFF  03,9E1
08F7C:  MOVLW  02
08F7E:  MOVWF  xF2
08F80:  MOVLB  0
08F82:  CALL   1ED4
08F86:  MOVFF  9E1,FEA
08F8A:  MOVFF  9E0,FE9
08F8E:  MOVFF  02,FEC
08F92:  MOVF   FED,F
08F94:  MOVFF  01,FEF
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
08F98:  BCF    FD8.0
08F9A:  MOVLB  9
08F9C:  RLCF   xD2,W
08F9E:  MOVWF  02
08FA0:  RLCF   xD3,W
08FA2:  MOVWF  03
08FA4:  MOVF   02,W
08FA6:  ADDLW  D3
08FA8:  MOVWF  01
08FAA:  MOVLW  03
08FAC:  ADDWFC 03,F
08FAE:  MOVF   01,W
08FB0:  MOVWF  xE0
08FB2:  MOVFF  03,9E1
08FB6:  MOVLW  01
08FB8:  MOVWF  xF2
08FBA:  MOVLB  0
08FBC:  CALL   1ED4
08FC0:  MOVFF  9E1,FEA
08FC4:  MOVFF  9E0,FE9
08FC8:  MOVFF  02,FEC
08FCC:  MOVF   FED,F
08FCE:  MOVFF  01,FEF
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
08FD2:  MOVLW  01
08FD4:  MOVLB  9
08FD6:  ADDWF  xD2,W
08FD8:  MOVLB  1
08FDA:  MOVWF  xD3
08FDC:  MOVLW  00
08FDE:  MOVLB  9
08FE0:  ADDWFC xD3,W
08FE2:  MOVLB  1
08FE4:  MOVWF  xD4
08FE6:  MOVLB  0
....................         }
....................         
.................... 
....................         if (port2.active) {
08FE8:  MOVLB  9
08FEA:  BTFSC  xD1.0
08FEC:  BRA    8FF4
08FEE:  MOVLB  0
08FF0:  GOTO   9080
08FF4:  MOVLB  0
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
08FF6:  BCF    FD8.0
08FF8:  MOVLB  9
08FFA:  RLCF   xD2,W
08FFC:  MOVWF  02
08FFE:  RLCF   xD3,W
09000:  MOVWF  03
09002:  MOVF   02,W
09004:  ADDLW  D5
09006:  MOVWF  01
09008:  MOVLW  05
0900A:  ADDWFC 03,F
0900C:  MOVF   01,W
0900E:  MOVWF  xE0
09010:  MOVFF  03,9E1
09014:  MOVLW  06
09016:  MOVWF  xF2
09018:  MOVLB  0
0901A:  CALL   1ED4
0901E:  MOVFF  9E1,FEA
09022:  MOVFF  9E0,FE9
09026:  MOVFF  02,FEC
0902A:  MOVF   FED,F
0902C:  MOVFF  01,FEF
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
09030:  BCF    FD8.0
09032:  MOVLB  9
09034:  RLCF   xD2,W
09036:  MOVWF  02
09038:  RLCF   xD3,W
0903A:  MOVWF  03
0903C:  MOVF   02,W
0903E:  ADDLW  D3
09040:  MOVWF  01
09042:  MOVLW  07
09044:  ADDWFC 03,F
09046:  MOVF   01,W
09048:  MOVWF  xE0
0904A:  MOVFF  03,9E1
0904E:  MOVLW  05
09050:  MOVWF  xF2
09052:  MOVLB  0
09054:  CALL   1ED4
09058:  MOVFF  9E1,FEA
0905C:  MOVFF  9E0,FE9
09060:  MOVFF  02,FEC
09064:  MOVF   FED,F
09066:  MOVFF  01,FEF
....................             // fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
0906A:  MOVLW  01
0906C:  MOVLB  9
0906E:  ADDWF  xD2,W
09070:  MOVLB  5
09072:  MOVWF  xD3
09074:  MOVLW  00
09076:  MOVLB  9
09078:  ADDWFC xD3,W
0907A:  MOVLB  5
0907C:  MOVWF  xD4
0907E:  MOVLB  0
....................         }
.................... 
....................         count++;
09080:  MOVLB  9
09082:  INCF   xD2,F
09084:  BTFSC  FD8.2
09086:  INCF   xD3,F
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
09088:  MOVF   xD3,F
0908A:  BTFSC  FD8.2
0908C:  BRA    9094
0908E:  MOVLB  0
09090:  GOTO   90A8
09094:  MOVLB  0
09096:  MOVLB  9
09098:  MOVF   xD2,W
0909A:  SUBLW  FE
0909C:  BTFSS  FD8.0
0909E:  BRA    90A6
090A0:  MOVLB  0
090A2:  GOTO   90AC
090A6:  MOVLB  0
....................             // fprintf(PC, "Maximum step count reached: %ld\r\n", count);
....................             break;
090A8:  GOTO   926C
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
090AC:  MOVLB  5
090AE:  BTFSC  xD1.0
090B0:  BRA    90B8
090B2:  MOVLB  0
090B4:  GOTO   918A
090B8:  MOVLB  0
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
090BA:  MOVLW  01
090BC:  MOVLB  9
090BE:  SUBWF  xD2,W
090C0:  MOVWF  xE0
090C2:  MOVLW  00
090C4:  SUBWFB xD3,W
090C6:  MOVWF  xE1
090C8:  BCF    FD8.0
090CA:  RLCF   xE0,W
090CC:  MOVWF  02
090CE:  RLCF   xE1,W
090D0:  MOVWF  03
090D2:  MOVF   02,W
090D4:  ADDLW  D3
090D6:  MOVWF  FE9
090D8:  MOVLW  03
090DA:  ADDWFC 03,W
090DC:  MOVWF  FEA
090DE:  MOVFF  FEC,9E1
090E2:  MOVF   FED,F
090E4:  MOVFF  FEF,9E0
090E8:  MOVF   xE1,W
090EA:  MOVLB  1
090EC:  SUBWF  xD1,W
090EE:  BTFSC  FD8.0
090F0:  BRA    90F8
090F2:  MOVLB  0
090F4:  GOTO   9124
090F8:  MOVLB  0
090FA:  BTFSS  FD8.2
090FC:  GOTO   9114
09100:  MOVLB  1
09102:  MOVF   xD0,W
09104:  MOVLB  9
09106:  SUBWF  xE0,W
09108:  BTFSS  FD8.0
0910A:  BRA    9112
0910C:  MOVLB  0
0910E:  GOTO   9124
09112:  MOVLB  0
....................                 // fprintf(PC, "CIGS1 current limit reached:");
....................                 port1.active = 0;
09114:  MOVLB  5
09116:  BCF    xD1.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
09118:  MOVLW  5E
0911A:  MOVWF  F94
0911C:  BCF    F8B.0
0911E:  MOVLB  0
....................             }
09120:  GOTO   918A
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
09124:  MOVLW  01
09126:  MOVLB  9
09128:  SUBWF  xD2,W
0912A:  MOVWF  xE0
0912C:  MOVLW  00
0912E:  SUBWFB xD3,W
09130:  MOVWF  xE1
09132:  BCF    FD8.0
09134:  RLCF   xE0,W
09136:  MOVWF  02
09138:  RLCF   xE1,W
0913A:  MOVWF  03
0913C:  MOVF   02,W
0913E:  ADDLW  D3
09140:  MOVWF  FE9
09142:  MOVLW  03
09144:  ADDWFC 03,W
09146:  MOVWF  FEA
09148:  MOVFF  FEC,9E1
0914C:  MOVF   FED,F
0914E:  MOVFF  FEF,9E0
09152:  MOVF   xE1,W
09154:  MOVLB  1
09156:  SUBWF  xCF,W
09158:  BTFSC  FD8.0
0915A:  BRA    9162
0915C:  MOVLB  0
0915E:  GOTO   918A
09162:  MOVLB  0
09164:  BTFSS  FD8.2
09166:  GOTO   917E
0916A:  MOVLB  1
0916C:  MOVF   xCE,W
0916E:  MOVLB  9
09170:  SUBWF  xE0,W
09172:  BTFSS  FD8.0
09174:  BRA    917C
09176:  MOVLB  0
09178:  GOTO   918A
0917C:  MOVLB  0
....................                 // fprintf(PC, "CIGS1 current below threshold");
....................                 port1.active = 0;
0917E:  MOVLB  5
09180:  BCF    xD1.0
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
09182:  MOVLW  5E
09184:  MOVWF  F94
09186:  BCF    F8B.0
09188:  MOVLB  0
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
0918A:  MOVLB  9
0918C:  BTFSC  xD1.0
0918E:  BRA    9196
09190:  MOVLB  0
09192:  GOTO   9268
09196:  MOVLB  0
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
09198:  MOVLW  01
0919A:  MOVLB  9
0919C:  SUBWF  xD2,W
0919E:  MOVWF  xE0
091A0:  MOVLW  00
091A2:  SUBWFB xD3,W
091A4:  MOVWF  xE1
091A6:  BCF    FD8.0
091A8:  RLCF   xE0,W
091AA:  MOVWF  02
091AC:  RLCF   xE1,W
091AE:  MOVWF  03
091B0:  MOVF   02,W
091B2:  ADDLW  D3
091B4:  MOVWF  FE9
091B6:  MOVLW  07
091B8:  ADDWFC 03,W
091BA:  MOVWF  FEA
091BC:  MOVFF  FEC,9E1
091C0:  MOVF   FED,F
091C2:  MOVFF  FEF,9E0
091C6:  MOVF   xE1,W
091C8:  MOVLB  1
091CA:  SUBWF  xD1,W
091CC:  BTFSC  FD8.0
091CE:  BRA    91D6
091D0:  MOVLB  0
091D2:  GOTO   9202
091D6:  MOVLB  0
091D8:  BTFSS  FD8.2
091DA:  GOTO   91F2
091DE:  MOVLB  1
091E0:  MOVF   xD0,W
091E2:  MOVLB  9
091E4:  SUBWF  xE0,W
091E6:  BTFSS  FD8.0
091E8:  BRA    91F0
091EA:  MOVLB  0
091EC:  GOTO   9202
091F0:  MOVLB  0
....................                 // fprintf(PC, "CIGS2 current limit reached: ");
....................                 port2.active = 0;
091F2:  MOVLB  9
091F4:  BCF    xD1.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
091F6:  MOVLW  5E
091F8:  MOVWF  F94
091FA:  BCF    F8B.5
091FC:  MOVLB  0
....................             }
091FE:  GOTO   9268
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
09202:  MOVLW  01
09204:  MOVLB  9
09206:  SUBWF  xD2,W
09208:  MOVWF  xE0
0920A:  MOVLW  00
0920C:  SUBWFB xD3,W
0920E:  MOVWF  xE1
09210:  BCF    FD8.0
09212:  RLCF   xE0,W
09214:  MOVWF  02
09216:  RLCF   xE1,W
09218:  MOVWF  03
0921A:  MOVF   02,W
0921C:  ADDLW  D3
0921E:  MOVWF  FE9
09220:  MOVLW  07
09222:  ADDWFC 03,W
09224:  MOVWF  FEA
09226:  MOVFF  FEC,9E1
0922A:  MOVF   FED,F
0922C:  MOVFF  FEF,9E0
09230:  MOVF   xE1,W
09232:  MOVLB  1
09234:  SUBWF  xCF,W
09236:  BTFSC  FD8.0
09238:  BRA    9240
0923A:  MOVLB  0
0923C:  GOTO   9268
09240:  MOVLB  0
09242:  BTFSS  FD8.2
09244:  GOTO   925C
09248:  MOVLB  1
0924A:  MOVF   xCE,W
0924C:  MOVLB  9
0924E:  SUBWF  xE0,W
09250:  BTFSS  FD8.0
09252:  BRA    925A
09254:  MOVLB  0
09256:  GOTO   9268
0925A:  MOVLB  0
....................                 // fprintf(PC, "CIGS2 current below threshold:");
....................                 port2.active = 0;
0925C:  MOVLB  9
0925E:  BCF    xD1.0
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
09260:  MOVLW  5E
09262:  MOVWF  F94
09264:  BCF    F8B.5
09266:  MOVLB  0
....................             }
....................         }
09268:  GOTO   8F14
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
0926C:  MOVLW  5E
0926E:  MOVWF  F94
09270:  BCF    F8B.0
....................     output_low(CONNECT_CIGS2);
09272:  MOVLW  5E
09274:  MOVWF  F94
09276:  BCF    F8B.5
....................     log_meas_data_with_print(&measured_data, &port1); // Log data for CIGS1
09278:  MOVLW  09
0927A:  MOVLB  9
0927C:  MOVWF  xE1
0927E:  MOVLW  D4
09280:  MOVWF  xE0
09282:  MOVLW  01
09284:  MOVWF  xE3
09286:  MOVLW  D2
09288:  MOVWF  xE2
0928A:  MOVLB  0
0928C:  CALL   74EC
....................     log_meas_data_with_print(&measured_data, &port2); // Log data for CIGS2
09290:  MOVLW  09
09292:  MOVLB  9
09294:  MOVWF  xE1
09296:  MOVLW  D4
09298:  MOVWF  xE0
0929A:  MOVLW  05
0929C:  MOVWF  xE3
0929E:  MOVLW  D2
092A0:  MOVWF  xE2
092A2:  MOVLB  0
092A4:  CALL   74EC
092A8:  GOTO   95A4 (RETURN)
.................... }
.................... 
.................... 
.................... void sweep(  unsigned int16 curr_threshold, unsigned int16 curr_limit)
.................... {
....................     fprintf(PC, ".");
....................    
....................     // Enable both CIGS ports
....................     output_high(CONNECT_CIGS1);
....................     output_high(CONNECT_CIGS2);
.................... 
....................     // delay_us(100); // wait for the CIGS to stabilize
.................... 
....................     // Init Port1
....................     sweep_config_t port1 = {0};
....................     port1.port_num = 1;
....................     port1.sweep_step = 0;
....................     port1.active = 1;
.................... 
....................     // Init Port2
....................     sweep_config_t port2 = {0};
....................     port2.port_num = 2;
....................     port2.sweep_step = 0;
....................     port2.active = 1;
.................... 
....................     int16 count = 1;
....................     
....................     // Initialize DACs to 0
....................     mcp4901_1_write(1);
....................     mcp4901_2_write(1);
.................... 
....................     iv_env_t measured_data = create_meas_data();
....................     while (port1.active || port2.active)
....................     {
....................         mcp4901_1_write(count);
....................         mcp4901_2_write(count);
....................         delay_us(10); // wait for DAC to stabilize
.................... 
....................         if (port1.active) {
....................             port1.data_buffer[0][count] = ad7490_read(ADC_CIGS1_AMP);
....................             port1.data_buffer[1][count] = ad7490_read(ADC_CIGS1_CURR);
....................             port1.sweep_step = count + 1; // Update CIGS1 step counter
....................         }
....................         
.................... 
....................         if (port2.active) {
....................             port2.data_buffer[0][count] = ad7490_read(ADC_CIGS2_AMP);
....................             port2.data_buffer[1][count] = ad7490_read(ADC_CIGS2_CURR);
....................             // fprintf(PC, "CIGS2 data: %04LX, %04LX\r\n", port2.data_buffer[0][count], port2.data_buffer[1][count]);
....................             port2.sweep_step = count + 1; // Update CIGS2 step counter
....................         }
.................... 
....................         count++;
.................... 
....................         // Check global exit conditions
....................         if (count >= 255) {
....................             // fprintf(PC, "Maximum step count reached: %ld\r\n", count);
....................             break;
....................         }
....................         
....................         // Check CIGS1 specific conditions
....................         if (port1.active) {
....................             if (port1.data_buffer[1][count-1] < curr_limit) {
....................                 // fprintf(PC, "CIGS1 current limit reached:");
....................                 port1.active = 0;
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
....................             }
....................             else if (port1.data_buffer[1][count-1] < curr_threshold) {
....................                 // fprintf(PC, "CIGS1 current below threshold");
....................                 port1.active = 0;
....................                 output_low(CONNECT_CIGS1); // Disconnect CIGS1
....................             }
....................         }
....................         
....................         // Check CIGS2 specific conditions
....................         if (port2.active) {
....................             if (port2.data_buffer[1][count-1] < curr_limit) {
....................                 // fprintf(PC, "CIGS2 current limit reached: ");
....................                 port2.active = 0;
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
....................             }
....................             else if (port2.data_buffer[1][count-1] < curr_threshold) {
....................                 // fprintf(PC, "CIGS2 current below threshold:");
....................                 port2.active = 0;
....................                 output_low(CONNECT_CIGS2); // Disconnect CIGS2
....................             }
....................         }
....................     }
.................... 
....................     // Ensure all connections are disabled
....................     output_low(CONNECT_CIGS1);
....................     output_low(CONNECT_CIGS2);
....................     log_meas_data(&measured_data, &port1); // Log data for CIGS1
....................     log_meas_data(&measured_data, &port2); // Log data for CIGS2
.................... 
....................     //fprintf(PC, "End SWEEP with threshold\r\n");
.................... }
.................... 
.................... 
.................... void log_meas_data(iv_env_t *measured_data_ptr, sweep_config_t *port_data_ptr)
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; 
....................     unsigned int8 packetdata_index = 0;
.................... 
....................     /*
....................     // Header creation
....................     packetdata[0] = START_MAKER;
....................     packetdata[1] = (START_MAKER & 0xF0) | (port_data_ptr->port_num & 0x0F);
....................     packetdata[2] = measured_data_ptr->time >> 24 & 0xFF;
....................     packetdata[3] = measured_data_ptr->time >> 16 & 0xFF;
....................     packetdata[4] = measured_data_ptr->time >> 8 & 0xFF;
....................     packetdata[5] = measured_data_ptr->time_sec & 0xFF;
....................     packetdata[6] = (measured_data_ptr->time_msec & 0x0F) >>4 | measured_data_ptr->pd >> 8 & 0x0F;
....................     packetdata[7] = measured_data_ptr->pd & 0xFF;
....................     packetdata[8] = (measured_data_ptr->open_voltage >> 4) & 0xFF; // PD start low byte
....................     packetdata[9] = (measured_data_ptr->open_voltage & 0x0F) << 4 | (measured_data_ptr->temp_py_top >> 8) & 0x0F;
....................     packetdata[10] = measured_data_ptr->temp_py_top & 0xFF;
....................     packetdata[11] = (measured_data_ptr->temp_py_bot >> 4) & 0xFF; // PD start low byte
....................     packetdata[12] = (measured_data_ptr->temp_py_bot & 0x0F) << 4 | (measured_data_ptr->temp_mis7 >> 8) & 0x0F;
....................     packetdata[13] = measured_data_ptr->temp_mis7 & 0xFF;
....................     */
....................     packetdata_index = 14; // Start index for data
.................... 
....................     for (unsigned int16 i = 0; i < port_data_ptr->sweep_step ; i++) {
....................         unsigned int16 data0 = port_data_ptr->data_buffer[0][i];
....................         unsigned int16 data1 = port_data_ptr->data_buffer[1][i];
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
....................         packetdata[packetdata_index++] = data1 & 0xFF;
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
....................            unsigned int32 write_address;
....................             
....................             switch (port_data_ptr -> port_num) {
....................                 case 1:
....................                     write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................                     iv1_data_ptr->used_counter += PACKET_SIZE;
....................                     iv1_data_ptr->uncopied_counter += PACKET_SIZE;
....................                     break;
....................                 case 2:
....................                     write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................                     iv2_data_ptr->used_counter += PACKET_SIZE;
....................                     iv2_data_ptr->uncopied_counter += PACKET_SIZE;
....................                     break;
....................                 default:
....................                     break;
....................             }
....................             packetdata_index = 0;
....................             memset(packetdata, 0x00, PACKET_SIZE);
....................         }
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
....................             packetdata[j] = 0x00;
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
....................       unsigned int32 write_address;
....................         switch (port_data_ptr->port_num)
....................         {
....................         case 1:
....................             write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................             iv1_data_ptr->used_counter += PACKET_SIZE;
....................             iv1_data_ptr->uncopied_counter += PACKET_SIZE;
....................             break;
....................         case 2:
....................          write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
....................             iv2_data_ptr->used_counter += PACKET_SIZE;
....................             iv2_data_ptr->uncopied_counter += PACKET_SIZE;
....................             break;
....................         default:
....................             break;
....................         }
.................... 
....................     }
....................     // fprintf(PC, "End CIGS data conversion\r\n");
....................     write_misf_address_area(); // Write the mission flash address area
.................... }
.................... 
.................... void log_meas_data_with_print(iv_env_t *measured_data_ptr, sweep_config_t *port_data_ptr)
*
07570:  CLRF   x24
.................... {
....................     unsigned int8 packetdata[PACKET_SIZE] = {0x00}; 
*
074EC:  MOVLB  9
074EE:  CLRF   xE4
074F0:  CLRF   xE5
074F2:  CLRF   xE6
074F4:  CLRF   xE7
074F6:  CLRF   xE8
074F8:  CLRF   xE9
074FA:  CLRF   xEA
074FC:  CLRF   xEB
074FE:  CLRF   xEC
07500:  CLRF   xED
07502:  CLRF   xEE
07504:  CLRF   xEF
07506:  CLRF   xF0
07508:  CLRF   xF1
0750A:  CLRF   xF2
0750C:  CLRF   xF3
0750E:  CLRF   xF4
07510:  CLRF   xF5
07512:  CLRF   xF6
07514:  CLRF   xF7
07516:  CLRF   xF8
07518:  CLRF   xF9
0751A:  CLRF   xFA
0751C:  CLRF   xFB
0751E:  CLRF   xFC
07520:  CLRF   xFD
07522:  CLRF   xFE
07524:  CLRF   xFF
07526:  MOVLB  A
07528:  CLRF   x00
0752A:  CLRF   x01
0752C:  CLRF   x02
0752E:  CLRF   x03
07530:  CLRF   x04
07532:  CLRF   x05
07534:  CLRF   x06
07536:  CLRF   x07
07538:  CLRF   x08
0753A:  CLRF   x09
0753C:  CLRF   x0A
0753E:  CLRF   x0B
07540:  CLRF   x0C
07542:  CLRF   x0D
07544:  CLRF   x0E
07546:  CLRF   x0F
07548:  CLRF   x10
0754A:  CLRF   x11
0754C:  CLRF   x12
0754E:  CLRF   x13
07550:  CLRF   x14
07552:  CLRF   x15
07554:  CLRF   x16
07556:  CLRF   x17
07558:  CLRF   x18
0755A:  CLRF   x19
0755C:  CLRF   x1A
0755E:  CLRF   x1B
07560:  CLRF   x1C
07562:  CLRF   x1D
07564:  CLRF   x1E
07566:  CLRF   x1F
07568:  CLRF   x20
0756A:  CLRF   x21
0756C:  CLRF   x22
0756E:  CLRF   x23
....................     unsigned int8 packetdata_index = 0;
.................... 
.................... 
....................     // Header creation
....................     packetdata[0] = START_MAKER;
*
07572:  MOVLB  9
07574:  SETF   xE4
....................     packetdata[1] = measured_data_ptr->time >> 24 & 0xFF;
07576:  MOVF   xE0,W
07578:  MOVWF  FE9
0757A:  MOVF   xE1,W
0757C:  MOVWF  FEA
0757E:  MOVFF  FEF,A38
07582:  MOVFF  FEC,A39
07586:  MOVFF  FEC,A3A
0758A:  MOVFF  FEC,A3B
0758E:  MOVF   FED,F
07590:  MOVF   FED,F
07592:  MOVF   FED,F
07594:  MOVFF  A3B,A38
07598:  MOVLB  A
0759A:  CLRF   x39
0759C:  CLRF   x3A
0759E:  CLRF   x3B
075A0:  MOVF   x38,W
075A2:  MOVLB  9
075A4:  MOVWF  xE5
....................     packetdata[2] = measured_data_ptr->time >> 16 & 0xFF;
075A6:  MOVF   xE0,W
075A8:  MOVWF  FE9
075AA:  MOVF   xE1,W
075AC:  MOVWF  FEA
075AE:  MOVFF  FEF,A38
075B2:  MOVFF  FEC,A39
075B6:  MOVFF  FEC,A3A
075BA:  MOVFF  FEC,A3B
075BE:  MOVF   FED,F
075C0:  MOVF   FED,F
075C2:  MOVF   FED,F
075C4:  MOVFF  A3A,A38
075C8:  MOVFF  A3B,A39
075CC:  MOVLB  A
075CE:  CLRF   x3A
075D0:  CLRF   x3B
075D2:  MOVF   x38,W
075D4:  MOVLB  9
075D6:  MOVWF  xE6
....................     packetdata[3] = measured_data_ptr->time >> 8 & 0xFF;
075D8:  MOVF   xE0,W
075DA:  MOVWF  FE9
075DC:  MOVF   xE1,W
075DE:  MOVWF  FEA
075E0:  MOVFF  FEF,A38
075E4:  MOVFF  FEC,A39
075E8:  MOVFF  FEC,A3A
075EC:  MOVFF  FEC,A3B
075F0:  MOVF   FED,F
075F2:  MOVF   FED,F
075F4:  MOVF   FED,F
075F6:  MOVFF  A39,A38
075FA:  MOVFF  A3A,A39
075FE:  MOVFF  A3B,A3A
07602:  MOVLB  A
07604:  CLRF   x3B
07606:  MOVF   x38,W
07608:  MOVLB  9
0760A:  MOVWF  xE7
....................     packetdata[4] = measured_data_ptr->time & 0xFF;
0760C:  MOVF   xE0,W
0760E:  MOVWF  FE9
07610:  MOVF   xE1,W
07612:  MOVWF  FEA
07614:  MOVFF  FEF,A38
07618:  MOVFF  FEC,A39
0761C:  MOVFF  FEC,A3A
07620:  MOVFF  FEC,A3B
07624:  MOVF   FED,F
07626:  MOVF   FED,F
07628:  MOVF   FED,F
0762A:  MOVLB  A
0762C:  MOVF   x38,W
0762E:  MOVLB  9
07630:  MOVWF  xE8
....................     // Enviro data
....................     packetdata[6] = (measured_data_ptr->pd >> 4) & 0xFF;
07632:  MOVLW  04
07634:  ADDWF  xE0,W
07636:  MOVWF  FE9
07638:  MOVLW  00
0763A:  ADDWFC xE1,W
0763C:  MOVWF  FEA
0763E:  MOVFF  FEC,A39
07642:  MOVF   FED,F
07644:  MOVFF  FEF,A38
07648:  MOVLB  A
0764A:  RRCF   x39,F
0764C:  RRCF   x38,F
0764E:  RRCF   x39,F
07650:  RRCF   x38,F
07652:  RRCF   x39,F
07654:  RRCF   x38,F
07656:  RRCF   x39,F
07658:  RRCF   x38,F
0765A:  MOVLW  0F
0765C:  ANDWF  x39,F
0765E:  MOVF   x38,W
07660:  MOVLB  9
07662:  MOVWF  xEA
....................     packetdata[7] = (measured_data_ptr->pd & 0x0F) << 4 | (measured_data_ptr->temp_py_top >> 8) & 0x0F;
07664:  MOVLW  04
07666:  ADDWF  xE0,W
07668:  MOVWF  FE9
0766A:  MOVLW  00
0766C:  ADDWFC xE1,W
0766E:  MOVWF  FEA
07670:  MOVFF  FEC,A39
07674:  MOVF   FED,F
07676:  MOVFF  FEF,A38
0767A:  MOVLW  0F
0767C:  MOVLB  A
0767E:  ANDWF  x38,F
07680:  CLRF   x39
07682:  RLCF   x38,F
07684:  RLCF   x39,F
07686:  RLCF   x38,F
07688:  RLCF   x39,F
0768A:  RLCF   x38,F
0768C:  RLCF   x39,F
0768E:  RLCF   x38,F
07690:  RLCF   x39,F
07692:  MOVLW  F0
07694:  ANDWF  x38,F
07696:  MOVLW  06
07698:  MOVLB  9
0769A:  ADDWF  xE0,W
0769C:  MOVWF  FE9
0769E:  MOVLW  00
076A0:  ADDWFC xE1,W
076A2:  MOVWF  FEA
076A4:  MOVFF  FEC,A3B
076A8:  MOVF   FED,F
076AA:  MOVFF  FEF,A3A
076AE:  MOVFF  A3B,A3A
076B2:  MOVLB  A
076B4:  CLRF   x3B
076B6:  MOVF   x3A,W
076B8:  ANDLW  0F
076BA:  MOVWF  00
076BC:  CLRF   03
076BE:  MOVF   00,W
076C0:  IORWF  x38,W
076C2:  MOVLB  9
076C4:  MOVWF  xEB
....................     packetdata[8] = (measured_data_ptr->temp_py_top >> 4) & 0xFF; // PD start low byte
076C6:  MOVLW  06
076C8:  ADDWF  xE0,W
076CA:  MOVWF  FE9
076CC:  MOVLW  00
076CE:  ADDWFC xE1,W
076D0:  MOVWF  FEA
076D2:  MOVFF  FEC,A39
076D6:  MOVF   FED,F
076D8:  MOVFF  FEF,A38
076DC:  MOVLB  A
076DE:  RRCF   x39,F
076E0:  RRCF   x38,F
076E2:  RRCF   x39,F
076E4:  RRCF   x38,F
076E6:  RRCF   x39,F
076E8:  RRCF   x38,F
076EA:  RRCF   x39,F
076EC:  RRCF   x38,F
076EE:  MOVLW  0F
076F0:  ANDWF  x39,F
076F2:  MOVF   x38,W
076F4:  MOVLB  9
076F6:  MOVWF  xEC
....................     packetdata[9] =(measured_data_ptr->temp_py_bot >> 4) & 0xFF;
076F8:  MOVLW  08
076FA:  ADDWF  xE0,W
076FC:  MOVWF  FE9
076FE:  MOVLW  00
07700:  ADDWFC xE1,W
07702:  MOVWF  FEA
07704:  MOVFF  FEC,A39
07708:  MOVF   FED,F
0770A:  MOVFF  FEF,A38
0770E:  MOVLB  A
07710:  RRCF   x39,F
07712:  RRCF   x38,F
07714:  RRCF   x39,F
07716:  RRCF   x38,F
07718:  RRCF   x39,F
0771A:  RRCF   x38,F
0771C:  RRCF   x39,F
0771E:  RRCF   x38,F
07720:  MOVLW  0F
07722:  ANDWF  x39,F
07724:  MOVF   x38,W
07726:  MOVLB  9
07728:  MOVWF  xED
....................     packetdata[10] = (measured_data_ptr->temp_py_bot & 0x0F) << 4 | (measured_data_ptr->temp_mis7 >> 8) & 0x0F;
0772A:  MOVLW  08
0772C:  ADDWF  xE0,W
0772E:  MOVWF  FE9
07730:  MOVLW  00
07732:  ADDWFC xE1,W
07734:  MOVWF  FEA
07736:  MOVFF  FEC,A39
0773A:  MOVF   FED,F
0773C:  MOVFF  FEF,A38
07740:  MOVLW  0F
07742:  MOVLB  A
07744:  ANDWF  x38,F
07746:  CLRF   x39
07748:  RLCF   x38,F
0774A:  RLCF   x39,F
0774C:  RLCF   x38,F
0774E:  RLCF   x39,F
07750:  RLCF   x38,F
07752:  RLCF   x39,F
07754:  RLCF   x38,F
07756:  RLCF   x39,F
07758:  MOVLW  F0
0775A:  ANDWF  x38,F
0775C:  MOVLW  0A
0775E:  MOVLB  9
07760:  ADDWF  xE0,W
07762:  MOVWF  FE9
07764:  MOVLW  00
07766:  ADDWFC xE1,W
07768:  MOVWF  FEA
0776A:  MOVFF  FEC,A3B
0776E:  MOVF   FED,F
07770:  MOVFF  FEF,A3A
07774:  MOVFF  A3B,A3A
07778:  MOVLB  A
0777A:  CLRF   x3B
0777C:  MOVF   x3A,W
0777E:  ANDLW  0F
07780:  MOVWF  00
07782:  CLRF   03
07784:  MOVF   00,W
07786:  IORWF  x38,W
07788:  MOVLB  9
0778A:  MOVWF  xEE
....................     packetdata[11] = (measured_data_ptr->temp_mis7 >> 4) & 0xFF; // PD start low byte
0778C:  MOVLW  0A
0778E:  ADDWF  xE0,W
07790:  MOVWF  FE9
07792:  MOVLW  00
07794:  ADDWFC xE1,W
07796:  MOVWF  FEA
07798:  MOVFF  FEC,A39
0779C:  MOVF   FED,F
0779E:  MOVFF  FEF,A38
077A2:  MOVLB  A
077A4:  RRCF   x39,F
077A6:  RRCF   x38,F
077A8:  RRCF   x39,F
077AA:  RRCF   x38,F
077AC:  RRCF   x39,F
077AE:  RRCF   x38,F
077B0:  RRCF   x39,F
077B2:  RRCF   x38,F
077B4:  MOVLW  0F
077B6:  ANDWF  x39,F
077B8:  MOVF   x38,W
077BA:  MOVLB  9
077BC:  MOVWF  xEF
.................... 
....................     packetdata_index = 12; // Start index for data
077BE:  MOVLW  0C
077C0:  MOVLB  A
077C2:  MOVWF  x24
.................... 
....................     for (unsigned int16 i = 0; i < port_data_ptr->sweep_step ; i++) {
077C4:  CLRF   x26
077C6:  CLRF   x25
077C8:  MOVLB  0
077CA:  MOVLW  01
077CC:  MOVLB  9
077CE:  ADDWF  xE2,W
077D0:  MOVWF  FE9
077D2:  MOVLW  00
077D4:  ADDWFC xE3,W
077D6:  MOVWF  FEA
077D8:  MOVFF  FEC,03
077DC:  MOVF   FED,F
077DE:  MOVF   FEF,W
077E0:  MOVWF  01
077E2:  MOVLB  A
077E4:  MOVF   x26,W
077E6:  SUBWF  03,W
077E8:  BTFSC  FD8.0
077EA:  BRA    77F2
077EC:  MOVLB  0
077EE:  GOTO   7C14
077F2:  MOVLB  0
077F4:  BTFSS  FD8.2
077F6:  GOTO   780C
077FA:  MOVF   01,W
077FC:  MOVLB  A
077FE:  SUBWF  x25,W
07800:  BTFSS  FD8.0
07802:  BRA    780A
07804:  MOVLB  0
07806:  GOTO   7C14
0780A:  MOVLB  0
....................         unsigned int16 data0 = port_data_ptr->data_buffer[0][i];
....................         unsigned int16 data1 = port_data_ptr->data_buffer[1][i];
0780C:  BCF    FD8.0
0780E:  MOVLB  A
07810:  RLCF   x25,W
07812:  MOVWF  02
07814:  RLCF   x26,W
07816:  MOVWF  03
07818:  MOVF   02,W
0781A:  ADDLW  03
0781C:  MOVWF  01
0781E:  MOVLW  00
07820:  ADDWFC 03,F
07822:  MOVF   01,W
07824:  MOVLB  9
07826:  ADDWF  xE2,W
07828:  MOVWF  FE9
0782A:  MOVF   xE3,W
0782C:  ADDWFC 03,W
0782E:  MOVWF  FEA
07830:  MOVFF  FEC,A28
07834:  MOVF   FED,F
07836:  MOVFF  FEF,A27
0783A:  BCF    FD8.0
0783C:  MOVLB  A
0783E:  RLCF   x25,W
07840:  MOVWF  02
07842:  RLCF   x26,W
07844:  MOVWF  03
07846:  MOVF   02,W
07848:  ADDLW  01
0784A:  MOVWF  01
0784C:  MOVLW  02
0784E:  ADDWFC 03,F
07850:  MOVF   01,W
07852:  MOVLB  9
07854:  ADDWF  xE2,W
07856:  MOVWF  FE9
07858:  MOVF   xE3,W
0785A:  ADDWFC 03,W
0785C:  MOVWF  FEA
0785E:  MOVFF  FEC,A2A
07862:  MOVF   FED,F
07864:  MOVFF  FEF,A29
07868:  MOVLB  0
.................... 
....................         packetdata[packetdata_index++] = (data0 >> 4) & 0xFF;
0786A:  MOVLB  A
0786C:  MOVF   x24,W
0786E:  INCF   x24,F
07870:  CLRF   03
07872:  ADDLW  E4
07874:  MOVWF  FE9
07876:  MOVLW  09
07878:  ADDWFC 03,W
0787A:  MOVWF  FEA
0787C:  RRCF   x28,W
0787E:  MOVWF  x3B
07880:  RRCF   x27,W
07882:  MOVWF  x3A
07884:  RRCF   x3B,F
07886:  RRCF   x3A,F
07888:  RRCF   x3B,F
0788A:  RRCF   x3A,F
0788C:  RRCF   x3B,F
0788E:  RRCF   x3A,F
07890:  MOVLW  0F
07892:  ANDWF  x3B,F
07894:  MOVF   x3A,W
07896:  MOVWF  00
07898:  CLRF   03
0789A:  MOVF   00,W
0789C:  MOVWF  FEF
....................         packetdata[packetdata_index++] = ((data0 & 0x0F) << 4) | ((data1 >> 8) & 0x0F);
0789E:  MOVF   x24,W
078A0:  INCF   x24,F
078A2:  CLRF   03
078A4:  ADDLW  E4
078A6:  MOVWF  FE9
078A8:  MOVLW  09
078AA:  ADDWFC 03,W
078AC:  MOVWF  FEA
078AE:  MOVF   x27,W
078B0:  ANDLW  0F
078B2:  MOVWF  x3A
078B4:  CLRF   x3B
078B6:  RLCF   x3A,F
078B8:  RLCF   x3B,F
078BA:  RLCF   x3A,F
078BC:  RLCF   x3B,F
078BE:  RLCF   x3A,F
078C0:  RLCF   x3B,F
078C2:  RLCF   x3A,F
078C4:  RLCF   x3B,F
078C6:  MOVLW  F0
078C8:  ANDWF  x3A,F
078CA:  MOVFF  A2A,A3C
078CE:  CLRF   x3D
078D0:  MOVF   x3C,W
078D2:  ANDLW  0F
078D4:  MOVWF  00
078D6:  CLRF   03
078D8:  MOVF   00,W
078DA:  IORWF  x3A,W
078DC:  MOVWF  00
078DE:  MOVF   03,W
078E0:  IORWF  x3B,W
078E2:  MOVWF  03
078E4:  MOVF   00,W
078E6:  MOVWF  FEF
....................         packetdata[packetdata_index++] = data1 & 0xFF;
078E8:  MOVF   x24,W
078EA:  INCF   x24,F
078EC:  CLRF   03
078EE:  ADDLW  E4
078F0:  MOVWF  FE9
078F2:  MOVLW  09
078F4:  ADDWFC 03,W
078F6:  MOVWF  FEA
078F8:  MOVF   x29,W
078FA:  MOVWF  00
078FC:  CLRF   03
078FE:  MOVF   00,W
07900:  MOVWF  FEF
.................... 
....................         if (packetdata_index + 3 >= PACKET_SIZE - 1) {
07902:  MOVLW  03
07904:  ADDWF  x24,W
07906:  SUBLW  3E
07908:  BTFSS  FD8.0
0790A:  BRA    7912
0790C:  MOVLB  0
0790E:  GOTO   7C06
07912:  MOVLB  0
....................             packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
07914:  MOVLW  09
07916:  MOVLB  A
07918:  MOVWF  xDC
0791A:  MOVLW  E4
0791C:  MOVWF  xDB
0791E:  MOVLW  3F
07920:  MOVWF  xDD
07922:  MOVLB  0
07924:  CALL   2AFA
07928:  MOVFF  01,A23
....................             unsigned int32 write_address;
.................... 
....................             switch (port_data_ptr->port_num) {
0792C:  MOVLB  9
0792E:  MOVF   xE2,W
07930:  MOVWF  FE9
07932:  MOVF   xE3,W
07934:  MOVWF  FEA
07936:  MOVF   FEF,W
07938:  XORLW  01
0793A:  MOVLB  0
0793C:  BTFSC  FD8.2
0793E:  GOTO   794E
07942:  XORLW  03
07944:  BTFSC  FD8.2
07946:  GOTO   7A46
0794A:  GOTO   7B3E
....................                 case 1:
....................                     write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
0794E:  MOVLW  01
07950:  MOVLB  1
07952:  ADDWF  x26,W
07954:  MOVWF  FE9
07956:  MOVLW  00
07958:  ADDWFC x27,W
0795A:  MOVWF  FEA
0795C:  MOVFF  FEF,00
07960:  MOVFF  FEC,01
07964:  MOVFF  FEC,02
07968:  MOVFF  FEC,03
0796C:  MOVF   FED,F
0796E:  MOVF   FED,F
07970:  MOVF   FED,F
07972:  MOVF   00,W
07974:  MOVLB  A
07976:  MOVWF  x2B
07978:  MOVLW  10
0797A:  ADDWF  01,W
0797C:  MOVWF  x2C
0797E:  MOVLW  7C
07980:  ADDWFC 02,W
07982:  MOVWF  x2D
07984:  MOVLW  00
07986:  ADDWFC 03,W
07988:  MOVWF  x2E
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
0798A:  MOVFF  111,A7F
0798E:  MOVFF  110,A7E
07992:  MOVFF  10F,A7D
07996:  MOVFF  10E,A7C
0799A:  MOVFF  A2E,A83
0799E:  MOVFF  A2D,A82
079A2:  MOVFF  A2C,A81
079A6:  MOVFF  A2B,A80
079AA:  MOVLW  09
079AC:  MOVWF  x85
079AE:  MOVLW  E4
079B0:  MOVWF  x84
079B2:  CLRF   x87
079B4:  MOVLW  40
079B6:  MOVWF  x86
079B8:  MOVLB  0
079BA:  CALL   3F84
....................                     iv1_data_ptr->used_counter += PACKET_SIZE;
079BE:  MOVLW  01
079C0:  MOVLB  1
079C2:  ADDWF  x26,W
079C4:  MOVWF  FE9
079C6:  MOVLW  00
079C8:  ADDWFC x27,W
079CA:  MOVWF  FEA
079CC:  MOVLW  40
079CE:  ADDWF  FEF,W
079D0:  MOVWF  00
079D2:  MOVLW  00
079D4:  ADDWFC FEC,W
079D6:  MOVWF  01
079D8:  MOVLW  00
079DA:  ADDWFC FEC,W
079DC:  MOVWF  02
079DE:  MOVLW  00
079E0:  ADDWFC FEC,W
079E2:  MOVWF  03
079E4:  MOVF   FED,F
079E6:  MOVF   FED,F
079E8:  MOVF   FED,F
079EA:  MOVFF  00,FEF
079EE:  MOVFF  01,FEC
079F2:  MOVFF  02,FEC
079F6:  MOVFF  03,FEC
079FA:  MOVF   FED,F
079FC:  MOVF   FED,F
079FE:  MOVF   FED,F
....................                     iv1_data_ptr->uncopied_counter += PACKET_SIZE;
07A00:  MOVLW  05
07A02:  ADDWF  x26,W
07A04:  MOVWF  FE9
07A06:  MOVLW  00
07A08:  ADDWFC x27,W
07A0A:  MOVWF  FEA
07A0C:  MOVLW  40
07A0E:  ADDWF  FEF,W
07A10:  MOVWF  00
07A12:  MOVLW  00
07A14:  ADDWFC FEC,W
07A16:  MOVWF  01
07A18:  MOVLW  00
07A1A:  ADDWFC FEC,W
07A1C:  MOVWF  02
07A1E:  MOVLW  00
07A20:  ADDWFC FEC,W
07A22:  MOVWF  03
07A24:  MOVF   FED,F
07A26:  MOVF   FED,F
07A28:  MOVF   FED,F
07A2A:  MOVFF  00,FEF
07A2E:  MOVFF  01,FEC
07A32:  MOVFF  02,FEC
07A36:  MOVFF  03,FEC
07A3A:  MOVF   FED,F
07A3C:  MOVF   FED,F
07A3E:  MOVF   FED,F
....................                     break;
07A40:  MOVLB  0
07A42:  GOTO   7B42
....................                 case 2:
....................                     write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
07A46:  MOVLW  01
07A48:  MOVLB  1
07A4A:  ADDWF  x2A,W
07A4C:  MOVWF  FE9
07A4E:  MOVLW  00
07A50:  ADDWFC x2B,W
07A52:  MOVWF  FEA
07A54:  MOVFF  FEF,00
07A58:  MOVFF  FEC,01
07A5C:  MOVFF  FEC,02
07A60:  MOVFF  FEC,03
07A64:  MOVF   FED,F
07A66:  MOVF   FED,F
07A68:  MOVF   FED,F
07A6A:  MOVF   00,W
07A6C:  MOVLB  A
07A6E:  MOVWF  x2B
07A70:  MOVLW  10
07A72:  ADDWF  01,W
07A74:  MOVWF  x2C
07A76:  MOVLW  7C
07A78:  ADDWFC 02,W
07A7A:  MOVWF  x2D
07A7C:  MOVLW  00
07A7E:  ADDWFC 03,W
07A80:  MOVWF  x2E
....................                     write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
07A82:  MOVFF  111,A7F
07A86:  MOVFF  110,A7E
07A8A:  MOVFF  10F,A7D
07A8E:  MOVFF  10E,A7C
07A92:  MOVFF  A2E,A83
07A96:  MOVFF  A2D,A82
07A9A:  MOVFF  A2C,A81
07A9E:  MOVFF  A2B,A80
07AA2:  MOVLW  09
07AA4:  MOVWF  x85
07AA6:  MOVLW  E4
07AA8:  MOVWF  x84
07AAA:  CLRF   x87
07AAC:  MOVLW  40
07AAE:  MOVWF  x86
07AB0:  MOVLB  0
07AB2:  CALL   3F84
....................                     iv2_data_ptr->used_counter += PACKET_SIZE;
07AB6:  MOVLW  01
07AB8:  MOVLB  1
07ABA:  ADDWF  x2A,W
07ABC:  MOVWF  FE9
07ABE:  MOVLW  00
07AC0:  ADDWFC x2B,W
07AC2:  MOVWF  FEA
07AC4:  MOVLW  40
07AC6:  ADDWF  FEF,W
07AC8:  MOVWF  00
07ACA:  MOVLW  00
07ACC:  ADDWFC FEC,W
07ACE:  MOVWF  01
07AD0:  MOVLW  00
07AD2:  ADDWFC FEC,W
07AD4:  MOVWF  02
07AD6:  MOVLW  00
07AD8:  ADDWFC FEC,W
07ADA:  MOVWF  03
07ADC:  MOVF   FED,F
07ADE:  MOVF   FED,F
07AE0:  MOVF   FED,F
07AE2:  MOVFF  00,FEF
07AE6:  MOVFF  01,FEC
07AEA:  MOVFF  02,FEC
07AEE:  MOVFF  03,FEC
07AF2:  MOVF   FED,F
07AF4:  MOVF   FED,F
07AF6:  MOVF   FED,F
....................                     iv2_data_ptr->uncopied_counter += PACKET_SIZE;
07AF8:  MOVLW  05
07AFA:  ADDWF  x2A,W
07AFC:  MOVWF  FE9
07AFE:  MOVLW  00
07B00:  ADDWFC x2B,W
07B02:  MOVWF  FEA
07B04:  MOVLW  40
07B06:  ADDWF  FEF,W
07B08:  MOVWF  00
07B0A:  MOVLW  00
07B0C:  ADDWFC FEC,W
07B0E:  MOVWF  01
07B10:  MOVLW  00
07B12:  ADDWFC FEC,W
07B14:  MOVWF  02
07B16:  MOVLW  00
07B18:  ADDWFC FEC,W
07B1A:  MOVWF  03
07B1C:  MOVF   FED,F
07B1E:  MOVF   FED,F
07B20:  MOVF   FED,F
07B22:  MOVFF  00,FEF
07B26:  MOVFF  01,FEC
07B2A:  MOVFF  02,FEC
07B2E:  MOVFF  03,FEC
07B32:  MOVF   FED,F
07B34:  MOVF   FED,F
07B36:  MOVF   FED,F
....................                     break;
07B38:  MOVLB  0
07B3A:  GOTO   7B42
....................                 default:
....................                     break;
07B3E:  GOTO   7B42
....................             }
....................             fprintf(PC, "\r\n");
07B42:  MOVLW  0D
07B44:  MOVLB  A
07B46:  MOVWF  xDB
07B48:  MOVLB  0
07B4A:  CALL   1CE0
07B4E:  MOVLW  0A
07B50:  MOVLB  A
07B52:  MOVWF  xDB
07B54:  MOVLB  0
07B56:  CALL   1CE0
....................             for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
07B5A:  MOVLB  A
07B5C:  CLRF   x32
07B5E:  CLRF   x31
07B60:  CLRF   x30
07B62:  CLRF   x2F
07B64:  MOVLB  0
07B66:  MOVLB  A
07B68:  MOVF   x32,F
07B6A:  BTFSC  FD8.2
07B6C:  BRA    7B74
07B6E:  MOVLB  0
07B70:  GOTO   7BEC
07B74:  MOVLB  0
07B76:  MOVLB  A
07B78:  MOVF   x31,F
07B7A:  BTFSC  FD8.2
07B7C:  BRA    7B84
07B7E:  MOVLB  0
07B80:  GOTO   7BEC
07B84:  MOVLB  0
07B86:  MOVLB  A
07B88:  MOVF   x30,F
07B8A:  BTFSC  FD8.2
07B8C:  BRA    7B94
07B8E:  MOVLB  0
07B90:  GOTO   7BEC
07B94:  MOVLB  0
07B96:  MOVLB  A
07B98:  MOVF   x2F,W
07B9A:  SUBLW  3F
07B9C:  BTFSC  FD8.0
07B9E:  BRA    7BA6
07BA0:  MOVLB  0
07BA2:  GOTO   7BEC
07BA6:  MOVLB  0
....................             {
....................                 fprintf(PC, "%02X ", packetdata[i]);
07BA8:  MOVLW  E4
07BAA:  MOVLB  A
07BAC:  ADDWF  x2F,W
07BAE:  MOVWF  FE9
07BB0:  MOVLW  09
07BB2:  ADDWFC x30,W
07BB4:  MOVWF  FEA
07BB6:  MOVFF  FEF,A38
07BBA:  MOVFF  A38,A39
07BBE:  MOVLW  37
07BC0:  MOVWF  x3A
07BC2:  MOVLB  0
07BC4:  CALL   1F60
07BC8:  MOVLW  20
07BCA:  MOVLB  A
07BCC:  MOVWF  xDB
07BCE:  MOVLB  0
07BD0:  CALL   1CE0
07BD4:  MOVLW  01
07BD6:  MOVLB  A
07BD8:  ADDWF  x2F,F
07BDA:  BTFSC  FD8.0
07BDC:  INCF   x30,F
07BDE:  BTFSC  FD8.2
07BE0:  INCF   x31,F
07BE2:  BTFSC  FD8.2
07BE4:  INCF   x32,F
07BE6:  MOVLB  0
07BE8:  GOTO   7B66
....................             }
....................             packetdata_index = 0;
07BEC:  MOVLB  A
07BEE:  CLRF   x24
....................             memset(packetdata, 0x00, PACKET_SIZE);
07BF0:  MOVLW  09
07BF2:  MOVWF  FEA
07BF4:  MOVLW  E4
07BF6:  MOVWF  FE9
07BF8:  CLRF   00
07BFA:  CLRF   02
07BFC:  MOVLW  40
07BFE:  MOVWF  01
07C00:  MOVLB  0
07C02:  CALL   28BE
....................         }
07C06:  MOVLB  A
07C08:  INCF   x25,F
07C0A:  BTFSC  FD8.2
07C0C:  INCF   x26,F
07C0E:  MOVLB  0
07C10:  GOTO   77CA
....................     }
.................... 
....................     // 最後に残ったデータの処理
....................     if (packetdata_index > 0) {
07C14:  MOVLB  A
07C16:  MOVF   x24,F
07C18:  BTFSS  FD8.2
07C1A:  BRA    7C22
07C1C:  MOVLB  0
07C1E:  GOTO   7E86
07C22:  MOVLB  0
....................         for (unsigned int8 j = packetdata_index; j < PACKET_SIZE - 1; j++) {
07C24:  MOVFF  A24,A33
07C28:  MOVLB  A
07C2A:  MOVF   x33,W
07C2C:  SUBLW  3E
07C2E:  BTFSC  FD8.0
07C30:  BRA    7C38
07C32:  MOVLB  0
07C34:  GOTO   7C58
07C38:  MOVLB  0
....................             packetdata[j] = 0x00;
07C3A:  CLRF   03
07C3C:  MOVLB  A
07C3E:  MOVF   x33,W
07C40:  ADDLW  E4
07C42:  MOVWF  FE9
07C44:  MOVLW  09
07C46:  ADDWFC 03,W
07C48:  MOVWF  FEA
07C4A:  CLRF   FEF
07C4C:  MOVLB  0
07C4E:  MOVLB  A
07C50:  INCF   x33,F
07C52:  MOVLB  0
07C54:  GOTO   7C28
....................         }
....................         packetdata[PACKET_SIZE - 1] = calc_crc8(packetdata, PACKET_SIZE - 1);
07C58:  MOVLW  09
07C5A:  MOVLB  A
07C5C:  MOVWF  xDC
07C5E:  MOVLW  E4
07C60:  MOVWF  xDB
07C62:  MOVLW  3F
07C64:  MOVWF  xDD
07C66:  MOVLB  0
07C68:  CALL   2AFA
07C6C:  MOVFF  01,A23
....................       unsigned int32 write_address;
....................         switch (port_data_ptr->port_num)
07C70:  MOVLB  9
07C72:  MOVF   xE2,W
07C74:  MOVWF  FE9
07C76:  MOVF   xE3,W
07C78:  MOVWF  FEA
07C7A:  MOVF   FEF,W
07C7C:  XORLW  01
07C7E:  MOVLB  0
07C80:  BTFSC  FD8.2
07C82:  GOTO   7C92
07C86:  XORLW  03
07C88:  BTFSC  FD8.2
07C8A:  GOTO   7D8A
07C8E:  GOTO   7E82
....................         {
....................         case 1:
....................             write_address = MISF_CIGS_IV_DATA_START + iv1_data_ptr->used_counter;
07C92:  MOVLW  01
07C94:  MOVLB  1
07C96:  ADDWF  x26,W
07C98:  MOVWF  FE9
07C9A:  MOVLW  00
07C9C:  ADDWFC x27,W
07C9E:  MOVWF  FEA
07CA0:  MOVFF  FEF,00
07CA4:  MOVFF  FEC,01
07CA8:  MOVFF  FEC,02
07CAC:  MOVFF  FEC,03
07CB0:  MOVF   FED,F
07CB2:  MOVF   FED,F
07CB4:  MOVF   FED,F
07CB6:  MOVF   00,W
07CB8:  MOVLB  A
07CBA:  MOVWF  x34
07CBC:  MOVLW  10
07CBE:  ADDWF  01,W
07CC0:  MOVWF  x35
07CC2:  MOVLW  7C
07CC4:  ADDWFC 02,W
07CC6:  MOVWF  x36
07CC8:  MOVLW  00
07CCA:  ADDWFC 03,W
07CCC:  MOVWF  x37
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
07CCE:  MOVFF  111,A7F
07CD2:  MOVFF  110,A7E
07CD6:  MOVFF  10F,A7D
07CDA:  MOVFF  10E,A7C
07CDE:  MOVFF  A37,A83
07CE2:  MOVFF  A36,A82
07CE6:  MOVFF  A35,A81
07CEA:  MOVFF  A34,A80
07CEE:  MOVLW  09
07CF0:  MOVWF  x85
07CF2:  MOVLW  E4
07CF4:  MOVWF  x84
07CF6:  CLRF   x87
07CF8:  MOVLW  40
07CFA:  MOVWF  x86
07CFC:  MOVLB  0
07CFE:  CALL   3F84
....................             iv1_data_ptr->used_counter += PACKET_SIZE;
07D02:  MOVLW  01
07D04:  MOVLB  1
07D06:  ADDWF  x26,W
07D08:  MOVWF  FE9
07D0A:  MOVLW  00
07D0C:  ADDWFC x27,W
07D0E:  MOVWF  FEA
07D10:  MOVLW  40
07D12:  ADDWF  FEF,W
07D14:  MOVWF  00
07D16:  MOVLW  00
07D18:  ADDWFC FEC,W
07D1A:  MOVWF  01
07D1C:  MOVLW  00
07D1E:  ADDWFC FEC,W
07D20:  MOVWF  02
07D22:  MOVLW  00
07D24:  ADDWFC FEC,W
07D26:  MOVWF  03
07D28:  MOVF   FED,F
07D2A:  MOVF   FED,F
07D2C:  MOVF   FED,F
07D2E:  MOVFF  00,FEF
07D32:  MOVFF  01,FEC
07D36:  MOVFF  02,FEC
07D3A:  MOVFF  03,FEC
07D3E:  MOVF   FED,F
07D40:  MOVF   FED,F
07D42:  MOVF   FED,F
....................             iv1_data_ptr->uncopied_counter += PACKET_SIZE;
07D44:  MOVLW  05
07D46:  ADDWF  x26,W
07D48:  MOVWF  FE9
07D4A:  MOVLW  00
07D4C:  ADDWFC x27,W
07D4E:  MOVWF  FEA
07D50:  MOVLW  40
07D52:  ADDWF  FEF,W
07D54:  MOVWF  00
07D56:  MOVLW  00
07D58:  ADDWFC FEC,W
07D5A:  MOVWF  01
07D5C:  MOVLW  00
07D5E:  ADDWFC FEC,W
07D60:  MOVWF  02
07D62:  MOVLW  00
07D64:  ADDWFC FEC,W
07D66:  MOVWF  03
07D68:  MOVF   FED,F
07D6A:  MOVF   FED,F
07D6C:  MOVF   FED,F
07D6E:  MOVFF  00,FEF
07D72:  MOVFF  01,FEC
07D76:  MOVFF  02,FEC
07D7A:  MOVFF  03,FEC
07D7E:  MOVF   FED,F
07D80:  MOVF   FED,F
07D82:  MOVF   FED,F
....................             break;
07D84:  MOVLB  0
07D86:  GOTO   7E86
....................         case 2:
....................          write_address = MISF_CIGS_IV_DATA_START + iv2_data_ptr->used_counter;
07D8A:  MOVLW  01
07D8C:  MOVLB  1
07D8E:  ADDWF  x2A,W
07D90:  MOVWF  FE9
07D92:  MOVLW  00
07D94:  ADDWFC x2B,W
07D96:  MOVWF  FEA
07D98:  MOVFF  FEF,00
07D9C:  MOVFF  FEC,01
07DA0:  MOVFF  FEC,02
07DA4:  MOVFF  FEC,03
07DA8:  MOVF   FED,F
07DAA:  MOVF   FED,F
07DAC:  MOVF   FED,F
07DAE:  MOVF   00,W
07DB0:  MOVLB  A
07DB2:  MOVWF  x34
07DB4:  MOVLW  10
07DB6:  ADDWF  01,W
07DB8:  MOVWF  x35
07DBA:  MOVLW  7C
07DBC:  ADDWFC 02,W
07DBE:  MOVWF  x36
07DC0:  MOVLW  00
07DC2:  ADDWFC 03,W
07DC4:  MOVWF  x37
....................             write_data_bytes(mis_fm, write_address, packetdata, PACKET_SIZE);
07DC6:  MOVFF  111,A7F
07DCA:  MOVFF  110,A7E
07DCE:  MOVFF  10F,A7D
07DD2:  MOVFF  10E,A7C
07DD6:  MOVFF  A37,A83
07DDA:  MOVFF  A36,A82
07DDE:  MOVFF  A35,A81
07DE2:  MOVFF  A34,A80
07DE6:  MOVLW  09
07DE8:  MOVWF  x85
07DEA:  MOVLW  E4
07DEC:  MOVWF  x84
07DEE:  CLRF   x87
07DF0:  MOVLW  40
07DF2:  MOVWF  x86
07DF4:  MOVLB  0
07DF6:  CALL   3F84
....................             iv2_data_ptr->used_counter += PACKET_SIZE;
07DFA:  MOVLW  01
07DFC:  MOVLB  1
07DFE:  ADDWF  x2A,W
07E00:  MOVWF  FE9
07E02:  MOVLW  00
07E04:  ADDWFC x2B,W
07E06:  MOVWF  FEA
07E08:  MOVLW  40
07E0A:  ADDWF  FEF,W
07E0C:  MOVWF  00
07E0E:  MOVLW  00
07E10:  ADDWFC FEC,W
07E12:  MOVWF  01
07E14:  MOVLW  00
07E16:  ADDWFC FEC,W
07E18:  MOVWF  02
07E1A:  MOVLW  00
07E1C:  ADDWFC FEC,W
07E1E:  MOVWF  03
07E20:  MOVF   FED,F
07E22:  MOVF   FED,F
07E24:  MOVF   FED,F
07E26:  MOVFF  00,FEF
07E2A:  MOVFF  01,FEC
07E2E:  MOVFF  02,FEC
07E32:  MOVFF  03,FEC
07E36:  MOVF   FED,F
07E38:  MOVF   FED,F
07E3A:  MOVF   FED,F
....................             iv2_data_ptr->uncopied_counter += PACKET_SIZE;
07E3C:  MOVLW  05
07E3E:  ADDWF  x2A,W
07E40:  MOVWF  FE9
07E42:  MOVLW  00
07E44:  ADDWFC x2B,W
07E46:  MOVWF  FEA
07E48:  MOVLW  40
07E4A:  ADDWF  FEF,W
07E4C:  MOVWF  00
07E4E:  MOVLW  00
07E50:  ADDWFC FEC,W
07E52:  MOVWF  01
07E54:  MOVLW  00
07E56:  ADDWFC FEC,W
07E58:  MOVWF  02
07E5A:  MOVLW  00
07E5C:  ADDWFC FEC,W
07E5E:  MOVWF  03
07E60:  MOVF   FED,F
07E62:  MOVF   FED,F
07E64:  MOVF   FED,F
07E66:  MOVFF  00,FEF
07E6A:  MOVFF  01,FEC
07E6E:  MOVFF  02,FEC
07E72:  MOVFF  03,FEC
07E76:  MOVF   FED,F
07E78:  MOVF   FED,F
07E7A:  MOVF   FED,F
....................             break;
07E7C:  MOVLB  0
07E7E:  GOTO   7E86
....................         default:
....................             break;
07E82:  GOTO   7E86
....................         }
.................... 
....................     }
....................     // fprintf(PC, "End CIGS data conversion\r\n");
....................     write_misf_address_area(); // Write the mission flash address area
07E86:  CALL   49F4
07E8A:  RETURN 0
.................... }
.................... 
.................... 
.................... iv_env_t create_meas_data()
.................... {
....................     iv_env_t data;
....................     memset(&data, 0, sizeof(data));
*
07468:  MOVLW  09
0746A:  MOVWF  FEA
0746C:  MOVLW  E6
0746E:  MOVWF  FE9
07470:  CLRF   00
07472:  CLRF   02
07474:  MOVLW  0C
07476:  MOVWF  01
07478:  CALL   28BE
....................     data.time           = get_current_sec();
0747C:  CALL   3C66
07480:  MOVFF  03,9E9
07484:  MOVFF  02,9E8
07488:  MOVFF  01,9E7
0748C:  MOVFF  00,9E6
....................     data.temp_py_top    = ad7490_read(ADC_TEMP_PY_TOP);
07490:  MOVLW  0D
07492:  MOVLB  9
07494:  MOVWF  xF2
07496:  MOVLB  0
07498:  CALL   1ED4
0749C:  MOVFF  02,9ED
074A0:  MOVFF  01,9EC
....................     data.temp_py_bot    = ad7490_read(ADC_TEMP_PY_BOT);
074A4:  MOVLW  0E
074A6:  MOVLB  9
074A8:  MOVWF  xF2
074AA:  MOVLB  0
074AC:  CALL   1ED4
074B0:  MOVFF  02,9EF
074B4:  MOVFF  01,9EE
....................     data.temp_mis7      = ad7490_read(ADC_TEMP_MIS7);
074B8:  MOVLW  0C
074BA:  MOVLB  9
074BC:  MOVWF  xF2
074BE:  MOVLB  0
074C0:  CALL   1ED4
074C4:  MOVFF  02,9F1
074C8:  MOVFF  01,9F0
....................     data.pd             = ad7490_read(ADC_PD);
074CC:  MOVLW  0F
074CE:  MOVLB  9
074D0:  MOVWF  xF2
074D2:  MOVLB  0
074D4:  CALL   1ED4
074D8:  MOVFF  02,9EB
074DC:  MOVFF  01,9EA
....................     return data;
074E0:  MOVLW  E6
074E2:  MOVWF  01
074E4:  MOVLW  09
074E6:  MOVWF  02
074E8:  GOTO   8EF2 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "domain/mmj_cigs_piclog.c"
.................... #include "mmj_cigs_piclog.h"                          // 同じフォルダのヘッダー
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/timer.h"                   // タイマーライブラリ  
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... #define CLOCK_FREQUENCY 32768 // 32.768 kHz
.................... 
.................... // __________ values _________
.................... 
.................... unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... void timer_init();
.................... // __________ functions _________
.................... unsigned int32 get_current_sec();
.................... unsigned int16 get_current_msec();
.................... unsigned int16 get_current_day();
.................... void set_current_sec(unsigned int32 new_sec);
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... // Clock Freq : 32.768kHz
.................... #define TIMER_ISR_1S 0x8000 // 1秒ごとのタイマー割り込み
.................... #define TIMER_ISR_100MSEC 0xF313 // 100ミリ秒ごとのタイマー割り込み
.................... #define TIMER_ISR_10MSEC 0xFEA8 // 10ミリ秒ごとのタイマー割り込み
.................... 
.................... unsigned int32 get_current_msec();
.................... void set_current_msec(unsigned int32 msec);
.................... void add_current_msec(unsigned int32 msec);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_flash.h"                 // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/smf_queue.h"               // フラッシュ操作キュー
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/device/mt25q.h"                 // フラッシュデバイス
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... // #define PICLOG_DEBUG
.................... #define MISSION_ID_PICLOG 0x03  // PICLOGミッションID
.................... 
.................... void piclog_make(int8 function, int8 parameter)
*
04A82:  MOVLW  02
04A84:  MOVLB  2
04A86:  MOVWF  x18
04A88:  MOVLW  11
04A8A:  MOVWF  x17
.................... {
....................     piclog_t piclog;
....................     piclog_t *piclog_ptr = &piclog;
....................     memset(piclog_ptr, 0x00, PICLOG_PACKET_SIZE);
04A8C:  MOVFF  218,FEA
04A90:  MOVFF  217,FE9
04A94:  CLRF   00
04A96:  CLRF   02
04A98:  MOVLW  06
04A9A:  MOVWF  01
04A9C:  MOVLB  0
04A9E:  CALL   28BE
....................     piclog_ptr->fields.time = get_current_sec();
04AA2:  MOVLB  2
04AA4:  MOVF   x17,W
04AA6:  MOVWF  01
04AA8:  MOVF   x18,W
04AAA:  MOVWF  03
04AAC:  MOVF   01,W
04AAE:  MOVWF  x1E
04AB0:  MOVFF  03,21F
04AB4:  MOVLB  0
04AB6:  CALL   3C66
04ABA:  MOVFF  21F,FEA
04ABE:  MOVFF  21E,FE9
04AC2:  MOVFF  00,FEF
04AC6:  MOVFF  01,FEC
04ACA:  MOVFF  02,FEC
04ACE:  MOVFF  03,FEC
04AD2:  MOVF   FED,F
04AD4:  MOVF   FED,F
04AD6:  MOVF   FED,F
....................     piclog_ptr->fields.function = function;
04AD8:  MOVLW  04
04ADA:  MOVLB  2
04ADC:  ADDWF  x17,W
04ADE:  MOVWF  FE9
04AE0:  MOVLW  00
04AE2:  ADDWFC x18,W
04AE4:  MOVWF  FEA
04AE6:  MOVFF  20F,FEF
....................     piclog_ptr->fields.parameter = parameter;
04AEA:  MOVLW  05
04AEC:  ADDWF  x17,W
04AEE:  MOVWF  FE9
04AF0:  MOVLW  00
04AF2:  ADDWFC x18,W
04AF4:  MOVWF  FEA
04AF6:  MOVFF  210,FEF
.................... 
....................     printf("[PICLOG] : ");
04AFA:  MOVLW  C0
04AFC:  MOVWF  FF6
04AFE:  MOVLW  05
04B00:  MOVWF  FF7
04B02:  MOVLW  00
04B04:  MOVWF  FF8
04B06:  MOVLB  0
04B08:  CALL   1D32
....................     for (int8 i = 0; i < PICLOG_PACKET_SIZE; i++) {
04B0C:  MOVLB  2
04B0E:  CLRF   x19
04B10:  MOVLB  0
04B12:  MOVLB  2
04B14:  MOVF   x19,W
04B16:  SUBLW  05
04B18:  BTFSC  FD8.0
04B1A:  BRA    4B22
04B1C:  MOVLB  0
04B1E:  GOTO   4B5C
04B22:  MOVLB  0
....................         printf("%02X ", piclog_ptr->bytes[i]);
04B24:  MOVLB  2
04B26:  MOVF   x19,W
04B28:  ADDWF  x17,W
04B2A:  MOVWF  FE9
04B2C:  MOVLW  00
04B2E:  ADDWFC x18,W
04B30:  MOVWF  FEA
04B32:  MOVFF  FEF,21E
04B36:  MOVFF  21E,A39
04B3A:  MOVLW  37
04B3C:  MOVLB  A
04B3E:  MOVWF  x3A
04B40:  MOVLB  0
04B42:  CALL   1F60
04B46:  MOVLW  20
04B48:  MOVLB  A
04B4A:  MOVWF  xDB
04B4C:  MOVLB  0
04B4E:  CALL   1CE0
04B52:  MOVLB  2
04B54:  INCF   x19,F
04B56:  MOVLB  0
04B58:  GOTO   4B12
....................     }
....................     printf("\r\n");
04B5C:  MOVLW  0D
04B5E:  MOVLB  A
04B60:  MOVWF  xDB
04B62:  MOVLB  0
04B64:  CALL   1CE0
04B68:  MOVLW  0A
04B6A:  MOVLB  A
04B6C:  MOVWF  xDB
04B6E:  MOVLB  0
04B70:  CALL   1CE0
.................... 
....................     int32 write_address = MISF_CIGS_PICLOG_START + piclog_data_ptr->used_counter;
04B74:  MOVLW  01
04B76:  MOVLB  1
04B78:  ADDWF  x20,W
04B7A:  MOVWF  FE9
04B7C:  MOVLW  00
04B7E:  ADDWFC x21,W
04B80:  MOVWF  FEA
04B82:  MOVFF  FEF,00
04B86:  MOVFF  FEC,01
04B8A:  MOVFF  FEC,02
04B8E:  MOVFF  FEC,03
04B92:  MOVF   FED,F
04B94:  MOVF   FED,F
04B96:  MOVF   FED,F
04B98:  MOVF   00,W
04B9A:  MOVLB  2
04B9C:  MOVWF  x1A
04B9E:  MOVF   01,W
04BA0:  MOVWF  x1B
04BA2:  MOVLW  01
04BA4:  ADDWF  02,W
04BA6:  MOVWF  x1C
04BA8:  MOVLW  00
04BAA:  ADDWFC 03,W
04BAC:  MOVWF  x1D
....................     write_data_bytes(mis_fm, write_address, piclog_ptr->bytes, PICLOG_PACKET_SIZE);
04BAE:  MOVF   x17,W
04BB0:  MOVWF  01
04BB2:  MOVF   x18,W
04BB4:  MOVWF  03
04BB6:  MOVF   01,W
04BB8:  MOVWF  x1E
04BBA:  MOVFF  03,21F
04BBE:  MOVFF  111,A7F
04BC2:  MOVFF  110,A7E
04BC6:  MOVFF  10F,A7D
04BCA:  MOVFF  10E,A7C
04BCE:  MOVFF  21D,A83
04BD2:  MOVFF  21C,A82
04BD6:  MOVFF  21B,A81
04BDA:  MOVFF  21A,A80
04BDE:  MOVFF  21F,A85
04BE2:  MOVFF  21E,A84
04BE6:  MOVLB  A
04BE8:  CLRF   x87
04BEA:  MOVLW  06
04BEC:  MOVWF  x86
04BEE:  MOVLB  0
04BF0:  CALL   3F84
.................... 
....................     piclog_data_ptr->used_counter += PICLOG_PACKET_SIZE;
04BF4:  MOVLW  01
04BF6:  MOVLB  1
04BF8:  ADDWF  x20,W
04BFA:  MOVWF  FE9
04BFC:  MOVLW  00
04BFE:  ADDWFC x21,W
04C00:  MOVWF  FEA
04C02:  MOVLW  06
04C04:  ADDWF  FEF,W
04C06:  MOVWF  00
04C08:  MOVLW  00
04C0A:  ADDWFC FEC,W
04C0C:  MOVWF  01
04C0E:  MOVLW  00
04C10:  ADDWFC FEC,W
04C12:  MOVWF  02
04C14:  MOVLW  00
04C16:  ADDWFC FEC,W
04C18:  MOVWF  03
04C1A:  MOVF   FED,F
04C1C:  MOVF   FED,F
04C1E:  MOVF   FED,F
04C20:  MOVFF  00,FEF
04C24:  MOVFF  01,FEC
04C28:  MOVFF  02,FEC
04C2C:  MOVFF  03,FEC
04C30:  MOVF   FED,F
04C32:  MOVF   FED,F
04C34:  MOVF   FED,F
....................     piclog_data_ptr->uncopied_counter += PICLOG_PACKET_SIZE;
04C36:  MOVLW  05
04C38:  ADDWF  x20,W
04C3A:  MOVWF  FE9
04C3C:  MOVLW  00
04C3E:  ADDWFC x21,W
04C40:  MOVWF  FEA
04C42:  MOVLW  06
04C44:  ADDWF  FEF,W
04C46:  MOVWF  00
04C48:  MOVLW  00
04C4A:  ADDWFC FEC,W
04C4C:  MOVWF  01
04C4E:  MOVLW  00
04C50:  ADDWFC FEC,W
04C52:  MOVWF  02
04C54:  MOVLW  00
04C56:  ADDWFC FEC,W
04C58:  MOVWF  03
04C5A:  MOVF   FED,F
04C5C:  MOVF   FED,F
04C5E:  MOVF   FED,F
04C60:  MOVFF  00,FEF
04C64:  MOVFF  01,FEC
04C68:  MOVFF  02,FEC
04C6C:  MOVFF  03,FEC
04C70:  MOVF   FED,F
04C72:  MOVF   FED,F
04C74:  MOVF   FED,F
....................     piclog_data_ptr->reserve_counter1 += PICLOG_PACKET_SIZE;
04C76:  MOVLW  09
04C78:  ADDWF  x20,W
04C7A:  MOVWF  FE9
04C7C:  MOVLW  00
04C7E:  ADDWFC x21,W
04C80:  MOVWF  FEA
04C82:  MOVLW  06
04C84:  ADDWF  FEF,W
04C86:  MOVWF  FEF
.................... 
....................     // Next Packet
....................     if (piclog_data_ptr->reserve_counter1 + PICLOG_PACKET_SIZE >=  PACKET_SIZE) {
04C88:  MOVLW  09
04C8A:  ADDWF  x20,W
04C8C:  MOVWF  FE9
04C8E:  MOVLW  00
04C90:  ADDWFC x21,W
04C92:  MOVWF  FEA
04C94:  MOVLW  06
04C96:  ADDWF  FEF,W
04C98:  SUBLW  3F
04C9A:  BTFSS  FD8.0
04C9C:  BRA    4CA4
04C9E:  MOVLB  0
04CA0:  GOTO   4DA8
04CA4:  MOVLB  0
....................         write_address = MISF_CIGS_PICLOG_START + piclog_data_ptr->used_counter;
04CA6:  MOVLW  01
04CA8:  MOVLB  1
04CAA:  ADDWF  x20,W
04CAC:  MOVWF  FE9
04CAE:  MOVLW  00
04CB0:  ADDWFC x21,W
04CB2:  MOVWF  FEA
04CB4:  MOVFF  FEF,00
04CB8:  MOVFF  FEC,01
04CBC:  MOVFF  FEC,02
04CC0:  MOVFF  FEC,03
04CC4:  MOVF   FED,F
04CC6:  MOVF   FED,F
04CC8:  MOVF   FED,F
04CCA:  MOVF   00,W
04CCC:  MOVLB  2
04CCE:  MOVWF  x1A
04CD0:  MOVF   01,W
04CD2:  MOVWF  x1B
04CD4:  MOVLW  01
04CD6:  ADDWF  02,W
04CD8:  MOVWF  x1C
04CDA:  MOVLW  00
04CDC:  ADDWFC 03,W
04CDE:  MOVWF  x1D
....................         write_data_bytes(mis_fm, write_address, PICLOG_BLANK_DATA, sizeof(PICLOG_BLANK_DATA));
04CE0:  MOVFF  111,A7F
04CE4:  MOVFF  110,A7E
04CE8:  MOVFF  10F,A7D
04CEC:  MOVFF  10E,A7C
04CF0:  MOVFF  21D,A83
04CF4:  MOVFF  21C,A82
04CF8:  MOVFF  21B,A81
04CFC:  MOVFF  21A,A80
04D00:  MOVLW  01
04D02:  MOVLB  A
04D04:  MOVWF  x85
04D06:  MOVLW  2C
04D08:  MOVWF  x84
04D0A:  CLRF   x87
04D0C:  MOVLW  04
04D0E:  MOVWF  x86
04D10:  MOVLB  0
04D12:  CALL   3F84
....................         piclog_data_ptr->used_counter += sizeof(PICLOG_BLANK_DATA);
04D16:  MOVLW  01
04D18:  MOVLB  1
04D1A:  ADDWF  x20,W
04D1C:  MOVWF  FE9
04D1E:  MOVLW  00
04D20:  ADDWFC x21,W
04D22:  MOVWF  FEA
04D24:  MOVLW  04
04D26:  ADDWF  FEF,W
04D28:  MOVWF  00
04D2A:  MOVLW  00
04D2C:  ADDWFC FEC,W
04D2E:  MOVWF  01
04D30:  MOVLW  00
04D32:  ADDWFC FEC,W
04D34:  MOVWF  02
04D36:  MOVLW  00
04D38:  ADDWFC FEC,W
04D3A:  MOVWF  03
04D3C:  MOVF   FED,F
04D3E:  MOVF   FED,F
04D40:  MOVF   FED,F
04D42:  MOVFF  00,FEF
04D46:  MOVFF  01,FEC
04D4A:  MOVFF  02,FEC
04D4E:  MOVFF  03,FEC
04D52:  MOVF   FED,F
04D54:  MOVF   FED,F
04D56:  MOVF   FED,F
....................         piclog_data_ptr->uncopied_counter += sizeof(PICLOG_BLANK_DATA);
04D58:  MOVLW  05
04D5A:  ADDWF  x20,W
04D5C:  MOVWF  FE9
04D5E:  MOVLW  00
04D60:  ADDWFC x21,W
04D62:  MOVWF  FEA
04D64:  MOVLW  04
04D66:  ADDWF  FEF,W
04D68:  MOVWF  00
04D6A:  MOVLW  00
04D6C:  ADDWFC FEC,W
04D6E:  MOVWF  01
04D70:  MOVLW  00
04D72:  ADDWFC FEC,W
04D74:  MOVWF  02
04D76:  MOVLW  00
04D78:  ADDWFC FEC,W
04D7A:  MOVWF  03
04D7C:  MOVF   FED,F
04D7E:  MOVF   FED,F
04D80:  MOVF   FED,F
04D82:  MOVFF  00,FEF
04D86:  MOVFF  01,FEC
04D8A:  MOVFF  02,FEC
04D8E:  MOVFF  03,FEC
04D92:  MOVF   FED,F
04D94:  MOVF   FED,F
04D96:  MOVF   FED,F
....................         piclog_data_ptr->reserve_counter1 = 0;
04D98:  MOVLW  09
04D9A:  ADDWF  x20,W
04D9C:  MOVWF  FE9
04D9E:  MOVLW  00
04DA0:  ADDWFC x21,W
04DA2:  MOVWF  FEA
04DA4:  CLRF   FEF
04DA6:  MOVLB  0
....................     }
.................... 
....................     write_misf_address_area(); // Update the address area after writing
04DA8:  CALL   49F4
04DAC:  RETURN 0
....................     
....................     /*
....................     // Add CRC Check
....................     if (misf_piclog_write_counter >= MISF_PICLOG_MAX_COUNT) {
....................         write_address = ADDRESS_MISF_PICLOG_DATA_START + misf_piclog_use_counter;
....................         write_data_bytes(mis_fm, write_address, *PICLOG_BLANK_DATA, PICLOG_BLANK_SIZE);
....................         unsigned int8 piclog_data_header[PICLOG_BLANK_SIZE] = {0x00, 0x00, 0x00}; // Initialize blank data
....................         misf_piclog_write_counter = 0; // Reset if max count reached
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "domain/mmj_cigs_smf.c"
.................... #include "mmj_cigs_smf.h"  
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "mmj_cigs_flash.h"
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mt25q.h"              // Flash device definitions
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/tool/smf_queue.h"            // システム設定 
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/tool/calc_tools.h"           // SMF処理関数 
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../lib/tool/mmj_smf_memorymap.h" 
.................... #ifndef SMF_MEMORY_MAP_H
.................... #define SMF_MEMORY_MAP_H
.................... 
.................... /*
....................  * Auto-generated Memory Map Header
....................  * Generated from: MMJ_ICD_021_IICD_06_Memory_map.xlsx
....................  * Generated at: 2025-07-27 20:54:05
....................  */
.................... #define PACKET_SIZE 64
.................... 
.................... typedef struct {
....................     unsigned int32 used_size;
....................     unsigned int8 loop_counter;
....................     unsigned int8 reserved[3];
.................... } partition_header_t;
.................... 
.................... // payloadに複数のpartition_headerを並べる
.................... typedef union {
....................     unsigned int8 bytes[PACKET_SIZE];  // 生データアクセス用
.................... 
....................     struct {
....................         union {
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             }cigs;
....................             
....................             struct {
....................                 partition_header_t piclog;
....................                 partition_header_t enviroment;
....................                 partition_header_t iv_head;
....................                 partition_header_t iv_data;
....................             } satolab;
....................             // フラットにアクセスしたいとき用
....................             partition_header_t headers[(PACKET_SIZE - 1) / sizeof(partition_header_t)];
....................         } payload;
.................... 
....................         unsigned int8 crc;  // 最後の1バイト
....................     };
.................... } smf_data_table_t;
.................... 
.................... // Base Memory Configuration
.................... #define SMF_SIZE 0x08000000 // 128MB
.................... #define SMF_START_ADDRESS 0x00000000
.................... #define SMF_END_ADDRESS   0x07FFFFFF
.................... 
.................... 
.................... // ===== Device IDs from メモリマップ  =====
.................... #define MAIN_DEVICE_ID 0x10
.................... #define COM_DEVICE_ID 0x20
.................... #define APRS_DEVICE_ID 0x60
.................... #define CAM_DEVICE_ID 0x70
.................... #define CHO_DEVICE_ID 0x80
.................... #define SATO_DEVICE_ID 0x90
.................... #define BHU_DEVICE_ID 0xB0
.................... #define CIGS_DEVICE_ID 0xC0
.................... 
.................... // ===== Data IDs from メモリマップ  =====
.................... #define ID_MAIN_ADDRESS_AREA 0x10
.................... #define ID_MAIN_ADDRESS 0x11
.................... #define ID_MAIN_RESERVED_COMMAND 0x12
.................... #define ID_MAIN_HK 0x14
.................... #define ID_MAIN_HSHK 0x15
.................... #define ID_MAIN_LSHK 0x16
.................... #define ID_MAIN_PIC_LOG 0x1F
.................... #define ID_COM_RSSI_TRX_T_LOG 0x20
.................... #define ID_COM_PIC_LOG 0x2F
.................... #define ID_APRS_PIC_DATA_TABLE 0x60
.................... #define ID_APRS_APRS 0x61
.................... #define ID_APRS_IN_VEHICLE_COMMUNICATION_MISSION 0x62
.................... #define ID_APRS_TLE_DATA 0x63
.................... #define ID_APRS_ECOSYSTEM 0x67
.................... #define ID_APRS_PIC_LOG 0x6F
.................... #define ID_CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE 0x70
.................... #define ID_CAM_CHIBANY_IMAGE_DATA_SIZE 0x71
.................... #define ID_CAM_CHIBANY_VIDEO_SIZE 0x72
.................... #define ID_CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE 0x73
.................... #define ID_CAM_POLEN_IMAGE_DATA_SIZE 0x74
.................... #define ID_CAM_POLLEN_VIDEO_DATA_SIZE 0x75
.................... #define ID_CAM_MCU_LOG_DATA_SIZE 0x7F
.................... #define ID_CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE 0x80
.................... #define ID_CHO_GREECE_IMAGE_DATA_SIZE 0x81
.................... #define ID_CHO_SENSOR_DATA_SIZE 0x82
.................... #define ID_CHO_MCU_LOG_DATA_SIZE 0x8F
.................... #define ID_SATO_PIC_DATA_TABLE 0x90
.................... #define ID_SATO_CYCLE_MODE_DATA 0x91
.................... #define ID_SATO_RANDOM_MODE_DATA 0x92
.................... #define ID_SATO_MULTIPLE_POINT_MODE_DATA 0x93
.................... #define ID_SATO_VOLTAGE_SWEEP_MODE_DATA 0x94
.................... #define ID_SATO_PIC_LOG 0x9F
.................... #define ID_BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE 0xB0
.................... #define ID_BHU_FOREST_IMAGE_DATA_SIZE 0xB1
.................... #define ID_BHU_SENSOR_DATA_DATA_SIZE 0xB2
.................... #define ID_BHU_MCU_LOG_DATA_SIZE 0xBF
.................... #define ID_CIGS_DATA_TABLE 0xC0
.................... #define ID_CIGS_MEASURE_DATA 0xC1
.................... #define ID_CIGS_PICLOG 0xCF
.................... 
.................... // ===== Memory Address Mappings from メモリマップ  =====
.................... #define MAIN_ADDRESS_AREA_START_ADDRESS 0x00000000
.................... #define MAIN_ADDRESS_AREA_END_ADDRESS 0x00000FFF
.................... #define MAIN_ADDRESS_START_ADDRESS 0x00001000
.................... #define MAIN_ADDRESS_END_ADDRESS 0x00001FFF
.................... #define MAIN_RESERVED_COMMAND_START_ADDRESS 0x00002000
.................... #define MAIN_RESERVED_COMMAND_END_ADDRESS 0x00003FFF
.................... #define MAIN_HK_START_ADDRESS 0x00004000
.................... #define MAIN_HK_END_ADDRESS 0x02003FFF
.................... #define MAIN_HSHK_START_ADDRESS 0x02004000
.................... #define MAIN_HSHK_END_ADDRESS 0x02103FFF
.................... #define MAIN_LSHK_START_ADDRESS 0x02104000
.................... #define MAIN_LSHK_END_ADDRESS 0x02303FFF
.................... #define MAIN_PIC_LOG_START_ADDRESS 0x02304000
.................... #define MAIN_PIC_LOG_END_ADDRESS 0x0240FFFF
.................... #define COM_RSSI_TRX_T_LOG_START_ADDRESS 0x02800000
.................... #define COM_RSSI_TRX_T_LOG_END_ADDRESS 0x028FFFFF
.................... #define COM_PIC_LOG_START_ADDRESS 0x02900000
.................... #define COM_PIC_LOG_END_ADDRESS 0x029FFFFF
.................... #define APRS_PIC_DATA_TABLE_START_ADDRESS 0x02C00000
.................... #define APRS_PIC_DATA_TABLE_END_ADDRESS 0x02C00FFF
.................... #define APRS_APRS_START_ADDRESS 0x02C01000
.................... #define APRS_APRS_END_ADDRESS 0x02D00FFF
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_START_ADDRESS 0x02D01000
.................... #define APRS_IN_VEHICLE_COMMUNICATION_MISSION_END_ADDRESS 0x02D01FFF
.................... #define APRS_TLE_DATA_START_ADDRESS 0x02D02000
.................... #define APRS_TLE_DATA_END_ADDRESS 0x02D02FFF
.................... #define APRS_ECOSYSTEM_START_ADDRESS 0x02D03000
.................... #define APRS_ECOSYSTEM_END_ADDRESS 0x02E02FFF
.................... #define APRS_PIC_LOG_START_ADDRESS 0x02E03000
.................... #define APRS_PIC_LOG_END_ADDRESS 0x02E03FFF
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x02F10000
.................... #define CAM_CHIBANY_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x02F10FFF
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_START_ADDRESS 0x03311000
.................... #define CAM_CHIBANY_IMAGE_DATA_SIZE_END_ADDRESS 0x03311FFF
.................... #define CAM_CHIBANY_VIDEO_SIZE_START_ADDRESS 0x03712000
.................... #define CAM_CHIBANY_VIDEO_SIZE_END_ADDRESS 0x03712FFF
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x03B13000
.................... #define CAM_POLLEN_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x03B13FFF
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_START_ADDRESS 0x03F14000
.................... #define CAM_POLEN_IMAGE_DATA_SIZE_END_ADDRESS 0x03F14FFF
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_START_ADDRESS 0x04315000
.................... #define CAM_POLLEN_VIDEO_DATA_SIZE_END_ADDRESS 0x04315FFF
.................... #define CAM_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04320000
.................... #define CAM_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04320FFF
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x04440000
.................... #define CHO_GREECE_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x04440FFF
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_START_ADDRESS 0x04451000
.................... #define CHO_GREECE_IMAGE_DATA_SIZE_END_ADDRESS 0x04451FFF
.................... #define CHO_SENSOR_DATA_SIZE_START_ADDRESS 0x04852000
.................... #define CHO_SENSOR_DATA_SIZE_END_ADDRESS 0x04852FFF
.................... #define CHO_MCU_LOG_DATA_SIZE_START_ADDRESS 0x04863000
.................... #define CHO_MCU_LOG_DATA_SIZE_END_ADDRESS 0x04863FFF
.................... #define SATO_PIC_DATA_TABLE_START_ADDRESS 0x04980000
.................... #define SATO_PIC_DATA_TABLE_END_ADDRESS 0x04980FFF
.................... #define SATO_CYCLE_MODE_DATA_START_ADDRESS 0x04981000
.................... #define SATO_CYCLE_MODE_DATA_END_ADDRESS 0x04A80FFF
.................... #define SATO_RANDOM_MODE_DATA_START_ADDRESS 0x04A81000
.................... #define SATO_RANDOM_MODE_DATA_END_ADDRESS 0x04E80FFF
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_START_ADDRESS 0x04E81000
.................... #define SATO_MULTIPLE_POINT_MODE_DATA_END_ADDRESS 0x04F80FFF
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_START_ADDRESS 0x04F81000
.................... #define SATO_VOLTAGE_SWEEP_MODE_DATA_END_ADDRESS 0x05080FFF
.................... #define SATO_PIC_LOG_START_ADDRESS 0x05081000
.................... #define SATO_PIC_LOG_END_ADDRESS 0x05081FFF
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_START_ADDRESS 0x05190000
.................... #define BHU_FOREST_THUMBNAIL_IMAGE_DATA_SIZE_END_ADDRESS 0x05190FFF
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_START_ADDRESS 0x05591000
.................... #define BHU_FOREST_IMAGE_DATA_SIZE_END_ADDRESS 0x05591FFF
.................... #define BHU_SENSOR_DATA_DATA_SIZE_START_ADDRESS 0x05992000
.................... #define BHU_SENSOR_DATA_DATA_SIZE_END_ADDRESS 0x05992FFF
.................... #define BHU_MCU_LOG_DATA_SIZE_START_ADDRESS 0x06993000
.................... #define BHU_MCU_LOG_DATA_SIZE_END_ADDRESS 0x06993FFF
.................... #define CIGS_DATA_TABLE_START_ADDRESS 0x06AA0000
.................... #define CIGS_DATA_TABLE_END_ADDRESS 0x06AA0FFF
.................... #define CIGS_PICLOG_START_ADDRESS 0x06AA1000
.................... #define CIGS_PICLOG_END_ADDRESS 0x06AA1FFF
.................... #define CIGS_ENVIRO_START_ADDRESS 0x06AA2000
.................... #define CIGS_ENVIRO_END_ADDRESS 0x06AA2FFF
.................... #define CIGS_IV1_HEADER_START_ADDRESS 0x06B42000
.................... #define CIGS_IV1_HEADER_END_ADDRESS 0x06BE1FFF
.................... #define CIGS_IV1_DATA_START_ADDRESS 0x06BE2000
.................... #define CIGS_IV1_DATA_END_ADDRESS 0x06FE2FFF
.................... #define CIGS_IV2_HEADER_START_ADDRESS 0x06FE3000
.................... #define CIGS_IV2_HEADER_END_ADDRESS 0x07082FFF
.................... #define CIGS_IV2_DATA_START_ADDRESS 0x07083000
.................... #define CIGS_IV2_DATA_END_ADDRESS 0x07483FFF
.................... 
.................... #endif // SMF_MEMORY_MAP_H
.................... 
.................... 
.................... #define MAX_READ_SIZE 64
.................... #define SIZE_AREA_SIZE 0x1000
.................... #define SUBSECTOR_SIZE 0x1000 // (4096bytes)
.................... #define CRC_RETRY_COUNT 5     // CRC検証のリトライ回数
.................... 
.................... // PartitionParam グローバル実体
.................... // ヘッダ(mmj_cigs_smf.h)で extern 宣言されている param をここで定義する。
.................... // 初期状態は 0 クリア。
.................... PartitionParam param = {0};
.................... 
.................... void smf_data_table_init()
.................... {
....................     FlashData_t smf_data_table = {0};
*
06BFC:  MOVLB  2
06BFE:  CLRF   x02
06C00:  CLRF   x03
06C02:  CLRF   x04
06C04:  CLRF   x05
06C06:  CLRF   x06
06C08:  CLRF   x07
06C0A:  CLRF   x08
06C0C:  CLRF   x09
06C0E:  CLRF   x0A
06C10:  CLRF   x0B
06C12:  CLRF   x0C
06C14:  CLRF   x0D
06C16:  CLRF   x0E
06C18:  CLRF   x0F
06C1A:  CLRF   x10
06C1C:  CLRF   x11
06C1E:  CLRF   x12
06C20:  CLRF   x13
06C22:  CLRF   x14
06C24:  CLRF   x15
06C26:  CLRF   x16
06C28:  CLRF   x17
06C2A:  CLRF   x18
06C2C:  CLRF   x19
06C2E:  CLRF   x1A
06C30:  CLRF   x1B
06C32:  CLRF   x1C
06C34:  CLRF   x1D
06C36:  CLRF   x1E
06C38:  CLRF   x1F
06C3A:  CLRF   x20
06C3C:  CLRF   x21
06C3E:  CLRF   x22
06C40:  CLRF   x23
06C42:  CLRF   x24
06C44:  CLRF   x25
06C46:  CLRF   x26
06C48:  CLRF   x27
06C4A:  CLRF   x28
06C4C:  CLRF   x29
06C4E:  CLRF   x2A
06C50:  CLRF   x2B
06C52:  CLRF   x2C
06C54:  CLRF   x2D
06C56:  CLRF   x2E
06C58:  CLRF   x2F
06C5A:  CLRF   x30
06C5C:  CLRF   x31
06C5E:  CLRF   x32
06C60:  CLRF   x33
06C62:  CLRF   x34
06C64:  CLRF   x35
06C66:  CLRF   x36
06C68:  CLRF   x37
06C6A:  CLRF   x38
06C6C:  CLRF   x39
06C6E:  CLRF   x3A
06C70:  CLRF   x3B
06C72:  CLRF   x3C
06C74:  CLRF   x3D
06C76:  CLRF   x3E
06C78:  CLRF   x3F
06C7A:  CLRF   x40
06C7C:  CLRF   x41
....................     calc_crc8(smf_data_table.bytes, PACKET_SIZE - 1); // CRCを計算して初期化
06C7E:  MOVLW  02
06C80:  MOVLB  A
06C82:  MOVWF  xDC
06C84:  MOVLW  02
06C86:  MOVWF  xDB
06C88:  MOVLW  3F
06C8A:  MOVWF  xDD
06C8C:  MOVLB  0
06C8E:  CALL   2AFA
.................... 
....................     write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table.bytes, PACKET_SIZE);
06C92:  MOVFF  115,A7F
06C96:  MOVFF  114,A7E
06C9A:  MOVFF  113,A7D
06C9E:  MOVFF  112,A7C
06CA2:  MOVLW  06
06CA4:  MOVLB  A
06CA6:  MOVWF  x83
06CA8:  MOVLW  AA
06CAA:  MOVWF  x82
06CAC:  CLRF   x81
06CAE:  CLRF   x80
06CB0:  MOVLW  02
06CB2:  MOVWF  x85
06CB4:  MOVLW  02
06CB6:  MOVWF  x84
06CB8:  CLRF   x87
06CBA:  MOVLW  40
06CBC:  MOVWF  x86
06CBE:  MOVLB  0
06CC0:  CALL   3F84
06CC4:  GOTO   6E1A (RETURN)
.................... 
.................... }
.................... 
.................... void read_smf_header(smf_data_table_t *smf_data_table)
.................... {
....................     int8 retry_count;
.................... 
....................     read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
*
0A798:  MOVLB  2
0A79A:  MOVF   x8F,W
0A79C:  MOVWF  01
0A79E:  MOVF   x90,W
0A7A0:  MOVWF  03
0A7A2:  MOVF   01,W
0A7A4:  MOVWF  x92
0A7A6:  MOVFF  03,293
0A7AA:  MOVFF  115,314
0A7AE:  MOVFF  114,313
0A7B2:  MOVFF  113,312
0A7B6:  MOVFF  112,311
0A7BA:  MOVLW  06
0A7BC:  MOVLB  3
0A7BE:  MOVWF  x18
0A7C0:  MOVLW  AA
0A7C2:  MOVWF  x17
0A7C4:  CLRF   x16
0A7C6:  CLRF   x15
0A7C8:  MOVFF  293,31A
0A7CC:  MOVFF  292,319
0A7D0:  CLRF   x1E
0A7D2:  CLRF   x1D
0A7D4:  CLRF   x1C
0A7D6:  MOVLW  40
0A7D8:  MOVWF  x1B
0A7DA:  MOVLB  0
0A7DC:  CALL   28E2
.................... 
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0A7E0:  MOVLB  2
0A7E2:  CLRF   x91
0A7E4:  MOVLB  0
0A7E6:  MOVLB  2
0A7E8:  MOVF   x91,W
0A7EA:  SUBLW  04
0A7EC:  BTFSC  FD8.0
0A7EE:  BRA    A7F6
0A7F0:  MOVLB  0
0A7F2:  GOTO   A8C4
0A7F6:  MOVLB  0
....................     {
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE);
0A7F8:  MOVLB  2
0A7FA:  MOVF   x8F,W
0A7FC:  MOVWF  01
0A7FE:  MOVF   x90,W
0A800:  MOVWF  03
0A802:  MOVF   01,W
0A804:  MOVWF  x92
0A806:  MOVFF  03,293
0A80A:  MOVFF  115,314
0A80E:  MOVFF  114,313
0A812:  MOVFF  113,312
0A816:  MOVFF  112,311
0A81A:  MOVLW  06
0A81C:  MOVLB  3
0A81E:  MOVWF  x18
0A820:  MOVLW  AA
0A822:  MOVWF  x17
0A824:  CLRF   x16
0A826:  CLRF   x15
0A828:  MOVFF  293,31A
0A82C:  MOVFF  292,319
0A830:  CLRF   x1E
0A832:  CLRF   x1D
0A834:  CLRF   x1C
0A836:  MOVLW  40
0A838:  MOVWF  x1B
0A83A:  MOVLB  0
0A83C:  CALL   28E2
....................         if (is_crc_valid(smf_data_table->bytes, PACKET_SIZE-1))
0A840:  MOVLB  2
0A842:  MOVF   x8F,W
0A844:  MOVWF  01
0A846:  MOVF   x90,W
0A848:  MOVWF  03
0A84A:  MOVF   01,W
0A84C:  MOVWF  x92
0A84E:  MOVFF  03,293
0A852:  MOVFF  293,312
0A856:  MOVFF  292,311
0A85A:  MOVLW  3F
0A85C:  MOVLB  3
0A85E:  MOVWF  x13
0A860:  MOVLB  0
0A862:  CALL   A74A
0A866:  MOVF   01,F
0A868:  BTFSC  FD8.2
0A86A:  GOTO   A8BA
....................         {
....................             printf("CRC verification passed on attempt %u\r\n", retry_count + 1);
0A86E:  MOVLW  01
0A870:  MOVLB  2
0A872:  ADDWF  x91,W
0A874:  MOVWF  x92
0A876:  MOVLW  CC
0A878:  MOVWF  FF6
0A87A:  MOVLW  05
0A87C:  MOVWF  FF7
0A87E:  MOVLW  00
0A880:  MOVWF  FF8
0A882:  MOVLW  23
0A884:  MOVLB  3
0A886:  MOVWF  x12
0A888:  MOVLB  0
0A88A:  CALL   1D62
0A88E:  MOVFF  292,293
0A892:  MOVLW  1B
0A894:  MOVLB  2
0A896:  MOVWF  x94
0A898:  MOVLB  0
0A89A:  CALL   A1B6
0A89E:  MOVLW  0D
0A8A0:  MOVLB  A
0A8A2:  MOVWF  xDB
0A8A4:  MOVLB  0
0A8A6:  CALL   1CE0
0A8AA:  MOVLW  0A
0A8AC:  MOVLB  A
0A8AE:  MOVWF  xDB
0A8B0:  MOVLB  0
0A8B2:  CALL   1CE0
....................             break;
0A8B6:  GOTO   A8C4
....................         }
0A8BA:  MOVLB  2
0A8BC:  INCF   x91,F
0A8BE:  MOVLB  0
0A8C0:  GOTO   A7E6
....................     }
0A8C4:  GOTO   AD4E (RETURN)
.................... }
.................... 
.................... void write_smf_header()
*
0A9DA:  CALL   4308
0A9DE:  MOVFF  02,03
0A9E2:  MOVF   01,W
0A9E4:  MOVWF  FE1
0A9E6:  MOVFF  03,FE2
0A9EA:  MOVLW  02
0A9EC:  MOVWF  FEA
0A9EE:  MOVLW  8F
0A9F0:  MOVWF  FE9
0A9F2:  MOVLW  40
0A9F4:  MOVWF  01
0A9F6:  MOVFF  FE6,FEE
0A9FA:  DECFSZ 01,F
0A9FC:  GOTO   A9F6
0AA00:  MOVLB  3
0AA02:  BCF    x0F.0
.................... {
.................... 
....................     FlashData_t flash_data = make_flash_data_table();
....................     unsigned int8 readdata[PACKET_SIZE];
....................     // int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (int8 retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
0AA04:  CLRF   x10
0AA06:  MOVLB  0
0AA08:  MOVLB  3
0AA0A:  MOVF   x10,W
0AA0C:  SUBLW  04
0AA0E:  BTFSC  FD8.0
0AA10:  BRA    AA18
0AA12:  MOVLB  0
0AA14:  GOTO   AB16
0AA18:  MOVLB  0
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
0AA1A:  MOVFF  115,314
0AA1E:  MOVFF  114,313
0AA22:  MOVFF  113,312
0AA26:  MOVFF  112,311
0AA2A:  MOVLW  06
0AA2C:  MOVLB  3
0AA2E:  MOVWF  x18
0AA30:  MOVLW  AA
0AA32:  MOVWF  x17
0AA34:  CLRF   x16
0AA36:  CLRF   x15
0AA38:  MOVLB  0
0AA3A:  CALL   56D4
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, flash_data.bytes, PACKET_SIZE); // ヘッダーを書き込み
0AA3E:  MOVFF  115,A7F
0AA42:  MOVFF  114,A7E
0AA46:  MOVFF  113,A7D
0AA4A:  MOVFF  112,A7C
0AA4E:  MOVLW  06
0AA50:  MOVLB  A
0AA52:  MOVWF  x83
0AA54:  MOVLW  AA
0AA56:  MOVWF  x82
0AA58:  CLRF   x81
0AA5A:  CLRF   x80
0AA5C:  MOVLW  02
0AA5E:  MOVWF  x85
0AA60:  MOVLW  8F
0AA62:  MOVWF  x84
0AA64:  CLRF   x87
0AA66:  MOVLW  40
0AA68:  MOVWF  x86
0AA6A:  MOVLB  0
0AA6C:  CALL   3F84
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
0AA70:  MOVFF  115,314
0AA74:  MOVFF  114,313
0AA78:  MOVFF  113,312
0AA7C:  MOVFF  112,311
0AA80:  MOVLW  06
0AA82:  MOVLB  3
0AA84:  MOVWF  x18
0AA86:  MOVLW  AA
0AA88:  MOVWF  x17
0AA8A:  CLRF   x16
0AA8C:  CLRF   x15
0AA8E:  MOVLW  02
0AA90:  MOVWF  x1A
0AA92:  MOVLW  CF
0AA94:  MOVWF  x19
0AA96:  CLRF   x1E
0AA98:  CLRF   x1D
0AA9A:  CLRF   x1C
0AA9C:  MOVLW  40
0AA9E:  MOVWF  x1B
0AAA0:  MOVLB  0
0AAA2:  CALL   28E2
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
0AAA6:  MOVLW  02
0AAA8:  MOVLB  3
0AAAA:  MOVWF  x12
0AAAC:  MOVLW  CF
0AAAE:  MOVWF  x11
0AAB0:  MOVLW  3F
0AAB2:  MOVWF  x13
0AAB4:  MOVLB  0
0AAB6:  CALL   A74A
0AABA:  MOVF   01,F
0AABC:  BTFSC  FD8.2
0AABE:  GOTO   AB0C
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
0AAC2:  MOVLW  01
0AAC4:  MOVLB  3
0AAC6:  ADDWF  x10,W
0AAC8:  MOVWF  x11
0AACA:  MOVLW  F4
0AACC:  MOVWF  FF6
0AACE:  MOVLW  05
0AAD0:  MOVWF  FF7
0AAD2:  MOVLW  00
0AAD4:  MOVWF  FF8
0AAD6:  MOVLW  23
0AAD8:  MOVWF  x12
0AADA:  MOVLB  0
0AADC:  CALL   1D62
0AAE0:  MOVFF  311,312
0AAE4:  MOVLW  18
0AAE6:  MOVLB  3
0AAE8:  MOVWF  x13
0AAEA:  MOVLB  0
0AAEC:  CALL   A8C8
0AAF0:  MOVLW  0D
0AAF2:  MOVLB  A
0AAF4:  MOVWF  xDB
0AAF6:  MOVLB  0
0AAF8:  CALL   1CE0
0AAFC:  MOVLW  0A
0AAFE:  MOVLB  A
0AB00:  MOVWF  xDB
0AB02:  MOVLB  0
0AB04:  CALL   1CE0
....................             break;
0AB08:  GOTO   AB16
....................         }
0AB0C:  MOVLB  3
0AB0E:  INCF   x10,F
0AB10:  MOVLB  0
0AB12:  GOTO   AA08
....................     }
....................     if (!crc_valid)
0AB16:  MOVLB  3
0AB18:  BTFSS  x0F.0
0AB1A:  BRA    AB22
0AB1C:  MOVLB  0
0AB1E:  GOTO   AB64
0AB22:  MOVLB  0
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
0AB24:  MOVLW  1C
0AB26:  MOVWF  FF6
0AB28:  MOVLW  06
0AB2A:  MOVWF  FF7
0AB2C:  MOVLW  00
0AB2E:  MOVWF  FF8
0AB30:  MOVLW  25
0AB32:  MOVLB  3
0AB34:  MOVWF  x12
0AB36:  MOVLB  0
0AB38:  CALL   1D62
0AB3C:  MOVLW  05
0AB3E:  MOVLB  3
0AB40:  MOVWF  x12
0AB42:  MOVLW  18
0AB44:  MOVWF  x13
0AB46:  MOVLB  0
0AB48:  CALL   A8C8
0AB4C:  MOVLW  43
0AB4E:  MOVWF  FF6
0AB50:  MOVLW  06
0AB52:  MOVWF  FF7
0AB54:  MOVLW  00
0AB56:  MOVWF  FF8
0AB58:  MOVLW  0B
0AB5A:  MOVLB  3
0AB5C:  MOVWF  x12
0AB5E:  MOVLB  0
0AB60:  CALL   1D62
....................         // return; 
....................     }
0AB64:  GOTO   B4AC (RETURN)
.................... }
.................... 
.................... 
.................... void smf_write(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0AB6C:  MOVLW  50
0AB6E:  MOVWF  FF6
0AB70:  MOVLW  06
0AB72:  MOVWF  FF7
0AB74:  MOVLW  00
0AB76:  MOVWF  FF8
0AB78:  CALL   1D32
....................     fprintf(PC, "_____Start copy_data____\r\n");
0AB7C:  MOVLW  6A
0AB7E:  MOVWF  FF6
0AB80:  MOVLW  06
0AB82:  MOVWF  FF7
0AB84:  MOVLW  00
0AB86:  MOVWF  FF8
0AB88:  CALL   1D32
....................     
....................     smf_data_table_t smf_data_table;
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
.................... 
....................     unsigned int32 mis_start_address = smf_address.start_address;
....................     unsigned int32 mis_end_address = smf_address.end_address;
....................     unsigned int32 write_src;
....................     unsigned int32 write_size;
0AB8C:  MOVLB  1
0AB8E:  MOVF   xBA,W
0AB90:  MOVWF  FE9
0AB92:  MOVF   xBB,W
0AB94:  MOVWF  FEA
0AB96:  MOVFF  FEF,28F
0AB9A:  MOVFF  28F,296
0AB9E:  MOVLB  0
0ABA0:  CALL   A4B6
0ABA4:  MOVFF  02,03
0ABA8:  MOVF   01,W
0ABAA:  MOVWF  FE1
0ABAC:  MOVFF  03,FE2
0ABB0:  MOVLW  01
0ABB2:  MOVWF  FEA
0ABB4:  MOVLW  FC
0ABB6:  MOVWF  FE9
0ABB8:  MOVLW  08
0ABBA:  MOVWF  01
0ABBC:  MOVFF  FE6,FEE
0ABC0:  DECFSZ 01,F
0ABC2:  GOTO   ABBC
0ABC6:  MOVFF  1FF,207
0ABCA:  MOVFF  1FE,206
0ABCE:  MOVFF  1FD,205
0ABD2:  MOVFF  1FC,204
0ABD6:  MOVFF  203,20B
0ABDA:  MOVFF  202,20A
0ABDE:  MOVFF  201,209
0ABE2:  MOVFF  200,208
.................... 
....................     //アドレスと自動更新
....................     if (smf_data->source_type == SOURCE_MISF_UNCOPIED )
0ABE6:  MOVLW  03
0ABE8:  MOVLB  1
0ABEA:  ADDWF  xBA,W
0ABEC:  MOVWF  01
0ABEE:  MOVLW  00
0ABF0:  ADDWFC xBB,W
0ABF2:  MOVWF  03
0ABF4:  MOVF   01,W
0ABF6:  MOVWF  FE9
0ABF8:  MOVFF  03,FEA
0ABFC:  BTFSS  FEF.0
0ABFE:  BRA    AC06
0AC00:  MOVLB  0
0AC02:  GOTO   AC7C
0AC06:  MOVLB  0
....................     {
....................         MisfAddressStruct misf_address = get_misf_address_struct(smf_data->mission_id);
0AC08:  MOVLB  1
0AC0A:  MOVF   xBA,W
0AC0C:  MOVWF  FE9
0AC0E:  MOVF   xBB,W
0AC10:  MOVWF  FEA
0AC12:  MOVFF  FEF,28F
0AC16:  MOVFF  28F,296
0AC1A:  MOVLB  0
0AC1C:  GOTO   A642
0AC20:  MOVFF  02,03
0AC24:  MOVF   01,W
0AC26:  MOVWF  FE1
0AC28:  MOVFF  03,FE2
0AC2C:  MOVLW  02
0AC2E:  MOVWF  FEA
0AC30:  MOVLW  14
0AC32:  MOVWF  FE9
0AC34:  MOVLW  08
0AC36:  MOVWF  01
0AC38:  MOVFF  FE6,FEE
0AC3C:  DECFSZ 01,F
0AC3E:  GOTO   AC38
....................         write_src = misf_address.start_address;
0AC42:  MOVFF  217,20F
0AC46:  MOVFF  216,20E
0AC4A:  MOVFF  215,20D
0AC4E:  MOVFF  214,20C
....................         write_size = iv1_data_ptr->uncopied_counter;
0AC52:  MOVLW  05
0AC54:  MOVLB  1
0AC56:  ADDWF  x26,W
0AC58:  MOVWF  FE9
0AC5A:  MOVLW  00
0AC5C:  ADDWFC x27,W
0AC5E:  MOVWF  FEA
0AC60:  MOVFF  FEF,210
0AC64:  MOVFF  FEC,211
0AC68:  MOVFF  FEC,212
0AC6C:  MOVFF  FEC,213
0AC70:  MOVF   FED,F
0AC72:  MOVF   FED,F
0AC74:  MOVF   FED,F
0AC76:  MOVLB  0
....................     }else if(smf_data->source_type == SOURCE_MISF_MANUAL)
0AC78:  GOTO   ACE6
0AC7C:  MOVLW  03
0AC7E:  MOVLB  1
0AC80:  ADDWF  xBA,W
0AC82:  MOVWF  01
0AC84:  MOVLW  00
0AC86:  ADDWFC xBB,W
0AC88:  MOVWF  03
0AC8A:  MOVF   01,W
0AC8C:  MOVWF  FE9
0AC8E:  MOVFF  03,FEA
0AC92:  BTFSC  FEF.0
0AC94:  BRA    AC9C
0AC96:  MOVLB  0
0AC98:  GOTO   ACE6
0AC9C:  MOVLB  0
....................     {
....................         // 手動指定データを転送
....................         write_src = smf_data->misf_start_addr;
0AC9E:  MOVLW  04
0ACA0:  MOVLB  1
0ACA2:  ADDWF  xBA,W
0ACA4:  MOVWF  FE9
0ACA6:  MOVLW  00
0ACA8:  ADDWFC xBB,W
0ACAA:  MOVWF  FEA
0ACAC:  MOVFF  FEF,20C
0ACB0:  MOVFF  FEC,20D
0ACB4:  MOVFF  FEC,20E
0ACB8:  MOVFF  FEC,20F
0ACBC:  MOVF   FED,F
0ACBE:  MOVF   FED,F
0ACC0:  MOVF   FED,F
....................         write_size = smf_data->misf_size;
0ACC2:  MOVLW  08
0ACC4:  ADDWF  xBA,W
0ACC6:  MOVWF  FE9
0ACC8:  MOVLW  00
0ACCA:  ADDWFC xBB,W
0ACCC:  MOVWF  FEA
0ACCE:  MOVFF  FEF,210
0ACD2:  MOVFF  FEC,211
0ACD6:  MOVFF  FEC,212
0ACDA:  MOVFF  FEC,213
0ACDE:  MOVF   FED,F
0ACE0:  MOVF   FED,F
0ACE2:  MOVF   FED,F
0ACE4:  MOVLB  0
....................     }
.................... 
....................     // 接続確認
....................     if (!is_connect(mis_fm))
0ACE6:  MOVFF  111,292
0ACEA:  MOVFF  110,291
0ACEE:  MOVFF  10F,290
0ACF2:  MOVFF  10E,28F
0ACF6:  CALL   27F6
0ACFA:  MOVF   01,F
0ACFC:  BTFSS  FD8.2
0ACFE:  GOTO   AD12
....................     {
....................         fprintf(PC, "Error: MIS FM is not connected\r\n");
0AD02:  MOVLW  86
0AD04:  MOVWF  FF6
0AD06:  MOVLW  06
0AD08:  MOVWF  FF7
0AD0A:  MOVLW  00
0AD0C:  MOVWF  FF8
0AD0E:  CALL   1D32
....................     }    
....................     if (!is_connect(smf))
0AD12:  MOVFF  115,292
0AD16:  MOVFF  114,291
0AD1A:  MOVFF  113,290
0AD1E:  MOVFF  112,28F
0AD22:  CALL   27F6
0AD26:  MOVF   01,F
0AD28:  BTFSS  FD8.2
0AD2A:  GOTO   AD3E
....................     {
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0AD2E:  MOVLW  A8
0AD30:  MOVWF  FF6
0AD32:  MOVLW  06
0AD34:  MOVWF  FF7
0AD36:  MOVLW  00
0AD38:  MOVWF  FF8
0AD3A:  CALL   1D32
....................     }    
.................... 
....................     // read size area with CRC verification retry
....................     read_smf_header(&smf_data_table);
0AD3E:  MOVLW  01
0AD40:  MOVLB  2
0AD42:  MOVWF  x90
0AD44:  MOVLW  BC
0AD46:  MOVWF  x8F
0AD48:  MOVLB  0
0AD4A:  GOTO   A798
....................     int32 used_size = param.meas.used_size;
....................     int8 loop_count = param.meas.loop_counter;
0AD4E:  MOVFF  136,21F
0AD52:  MOVFF  135,21E
0AD56:  MOVFF  134,21D
0AD5A:  MOVFF  133,21C
0AD5E:  MOVFF  137,220
....................     fprintf(PC, "Size area read\r\n");
0AD62:  MOVLW  C6
0AD64:  MOVWF  FF6
0AD66:  MOVLW  06
0AD68:  MOVWF  FF7
0AD6A:  MOVLW  00
0AD6C:  MOVWF  FF8
0AD6E:  CALL   1D32
....................     fprintf(PC, "smf_used_size = %ld (src 0x%08LX)\r\n", used_size, mis_start_address);
0AD72:  MOVLW  D8
0AD74:  MOVWF  FF6
0AD76:  MOVLW  06
0AD78:  MOVWF  FF7
0AD7A:  MOVLW  00
0AD7C:  MOVWF  FF8
0AD7E:  MOVLW  10
0AD80:  MOVLB  3
0AD82:  MOVWF  x12
0AD84:  MOVLB  0
0AD86:  CALL   1D62
0AD8A:  MOVLW  41
0AD8C:  MOVWF  FE9
0AD8E:  MOVFF  21F,292
0AD92:  MOVFF  21E,291
0AD96:  MOVFF  21D,290
0AD9A:  MOVFF  21C,28F
0AD9E:  CALL   A33A
0ADA2:  MOVLW  EB
0ADA4:  MOVWF  FF6
0ADA6:  MOVLW  06
0ADA8:  MOVWF  FF7
0ADAA:  MOVLW  00
0ADAC:  MOVWF  FF8
0ADAE:  MOVLW  08
0ADB0:  MOVLB  3
0ADB2:  MOVWF  x12
0ADB4:  MOVLB  0
0ADB6:  CALL   1D62
0ADBA:  MOVFF  207,A39
0ADBE:  MOVLW  37
0ADC0:  MOVLB  A
0ADC2:  MOVWF  x3A
0ADC4:  MOVLB  0
0ADC6:  CALL   1F60
0ADCA:  MOVFF  206,A39
0ADCE:  MOVLW  37
0ADD0:  MOVLB  A
0ADD2:  MOVWF  x3A
0ADD4:  MOVLB  0
0ADD6:  CALL   1F60
0ADDA:  MOVFF  205,A39
0ADDE:  MOVLW  37
0ADE0:  MOVLB  A
0ADE2:  MOVWF  x3A
0ADE4:  MOVLB  0
0ADE6:  CALL   1F60
0ADEA:  MOVFF  204,A39
0ADEE:  MOVLW  37
0ADF0:  MOVLB  A
0ADF2:  MOVWF  x3A
0ADF4:  MOVLB  0
0ADF6:  CALL   1F60
0ADFA:  MOVLW  F8
0ADFC:  MOVWF  FF6
0ADFE:  MOVLW  06
0AE00:  MOVWF  FF7
0AE02:  MOVLW  00
0AE04:  MOVWF  FF8
0AE06:  MOVLW  03
0AE08:  MOVLB  3
0AE0A:  MOVWF  x12
0AE0C:  MOVLB  0
0AE0E:  CALL   1D62
....................     fprintf(PC, "smf_loop count= %d  (src 0x%08LX)\r\n", loop_count, mis_start_address + 4);
0AE12:  MOVLW  04
0AE14:  MOVLB  2
0AE16:  ADDWF  x04,W
0AE18:  MOVWF  x8F
0AE1A:  MOVLW  00
0AE1C:  ADDWFC x05,W
0AE1E:  MOVWF  x90
0AE20:  MOVLW  00
0AE22:  ADDWFC x06,W
0AE24:  MOVWF  x91
0AE26:  MOVLW  00
0AE28:  ADDWFC x07,W
0AE2A:  MOVWF  x92
0AE2C:  MOVLW  FC
0AE2E:  MOVWF  FF6
0AE30:  MOVLW  06
0AE32:  MOVWF  FF7
0AE34:  MOVLW  00
0AE36:  MOVWF  FF8
0AE38:  MOVLW  10
0AE3A:  MOVLB  3
0AE3C:  MOVWF  x12
0AE3E:  MOVLB  0
0AE40:  CALL   1D62
0AE44:  MOVFF  220,312
0AE48:  MOVLW  18
0AE4A:  MOVLB  3
0AE4C:  MOVWF  x13
0AE4E:  MOVLB  0
0AE50:  CALL   A8C8
0AE54:  MOVLW  0E
0AE56:  MOVWF  FF6
0AE58:  MOVLW  07
0AE5A:  MOVWF  FF7
0AE5C:  MOVLW  00
0AE5E:  MOVWF  FF8
0AE60:  MOVLW  09
0AE62:  MOVLB  3
0AE64:  MOVWF  x12
0AE66:  MOVLB  0
0AE68:  CALL   1D62
0AE6C:  MOVFF  292,A39
0AE70:  MOVLW  37
0AE72:  MOVLB  A
0AE74:  MOVWF  x3A
0AE76:  MOVLB  0
0AE78:  CALL   1F60
0AE7C:  MOVFF  291,A39
0AE80:  MOVLW  37
0AE82:  MOVLB  A
0AE84:  MOVWF  x3A
0AE86:  MOVLB  0
0AE88:  CALL   1F60
0AE8C:  MOVFF  290,A39
0AE90:  MOVLW  37
0AE92:  MOVLB  A
0AE94:  MOVWF  x3A
0AE96:  MOVLB  0
0AE98:  CALL   1F60
0AE9C:  MOVFF  28F,A39
0AEA0:  MOVLW  37
0AEA2:  MOVLB  A
0AEA4:  MOVWF  x3A
0AEA6:  MOVLB  0
0AEA8:  CALL   1F60
0AEAC:  MOVLW  1C
0AEAE:  MOVWF  FF6
0AEB0:  MOVLW  07
0AEB2:  MOVWF  FF7
0AEB4:  MOVLW  00
0AEB6:  MOVWF  FF8
0AEB8:  MOVLW  03
0AEBA:  MOVLB  3
0AEBC:  MOVWF  x12
0AEBE:  MOVLB  0
0AEC0:  CALL   1D62
....................     fprintf(PC, "misf_write_source = 0x%08LX\r\n", write_src);
0AEC4:  MOVLW  20
0AEC6:  MOVWF  FF6
0AEC8:  MOVLW  07
0AECA:  MOVWF  FF7
0AECC:  MOVLW  00
0AECE:  MOVWF  FF8
0AED0:  MOVLW  16
0AED2:  MOVLB  3
0AED4:  MOVWF  x12
0AED6:  MOVLB  0
0AED8:  CALL   1D62
0AEDC:  MOVFF  20F,A39
0AEE0:  MOVLW  37
0AEE2:  MOVLB  A
0AEE4:  MOVWF  x3A
0AEE6:  MOVLB  0
0AEE8:  CALL   1F60
0AEEC:  MOVFF  20E,A39
0AEF0:  MOVLW  37
0AEF2:  MOVLB  A
0AEF4:  MOVWF  x3A
0AEF6:  MOVLB  0
0AEF8:  CALL   1F60
0AEFC:  MOVFF  20D,A39
0AF00:  MOVLW  37
0AF02:  MOVLB  A
0AF04:  MOVWF  x3A
0AF06:  MOVLB  0
0AF08:  CALL   1F60
0AF0C:  MOVFF  20C,A39
0AF10:  MOVLW  37
0AF12:  MOVLB  A
0AF14:  MOVWF  x3A
0AF16:  MOVLB  0
0AF18:  CALL   1F60
0AF1C:  MOVLW  0D
0AF1E:  MOVLB  A
0AF20:  MOVWF  xDB
0AF22:  MOVLB  0
0AF24:  CALL   1CE0
0AF28:  MOVLW  0A
0AF2A:  MOVLB  A
0AF2C:  MOVWF  xDB
0AF2E:  MOVLB  0
0AF30:  CALL   1CE0
....................     fprintf(PC, "misf_write_size = 0x%08LX\r\n", write_size);
0AF34:  MOVLW  3E
0AF36:  MOVWF  FF6
0AF38:  MOVLW  07
0AF3A:  MOVWF  FF7
0AF3C:  MOVLW  00
0AF3E:  MOVWF  FF8
0AF40:  MOVLW  14
0AF42:  MOVLB  3
0AF44:  MOVWF  x12
0AF46:  MOVLB  0
0AF48:  CALL   1D62
0AF4C:  MOVFF  213,A39
0AF50:  MOVLW  37
0AF52:  MOVLB  A
0AF54:  MOVWF  x3A
0AF56:  MOVLB  0
0AF58:  CALL   1F60
0AF5C:  MOVFF  212,A39
0AF60:  MOVLW  37
0AF62:  MOVLB  A
0AF64:  MOVWF  x3A
0AF66:  MOVLB  0
0AF68:  CALL   1F60
0AF6C:  MOVFF  211,A39
0AF70:  MOVLW  37
0AF72:  MOVLB  A
0AF74:  MOVWF  x3A
0AF76:  MOVLB  0
0AF78:  CALL   1F60
0AF7C:  MOVFF  210,A39
0AF80:  MOVLW  37
0AF82:  MOVLB  A
0AF84:  MOVWF  x3A
0AF86:  MOVLB  0
0AF88:  CALL   1F60
0AF8C:  MOVLW  0D
0AF8E:  MOVLB  A
0AF90:  MOVWF  xDB
0AF92:  MOVLB  0
0AF94:  CALL   1CE0
0AF98:  MOVLW  0A
0AF9A:  MOVLB  A
0AF9C:  MOVWF  xDB
0AF9E:  MOVLB  0
0AFA0:  CALL   1CE0
.................... 
....................     // Calculate data write address and check for wrap-around
....................     unsigned int32 data_region_start = mis_start_address + SUBSECTOR_SIZE;
....................     unsigned int32 data_region_end = mis_end_address;
....................     unsigned int32 data_region_size = data_region_end - data_region_start;
....................     unsigned int32 data_write_addr = data_region_start + used_size;
0AFA4:  MOVLB  2
0AFA6:  MOVF   x04,W
0AFA8:  MOVWF  x21
0AFAA:  MOVLW  10
0AFAC:  ADDWF  x05,W
0AFAE:  MOVWF  x22
0AFB0:  MOVLW  00
0AFB2:  ADDWFC x06,W
0AFB4:  MOVWF  x23
0AFB6:  MOVLW  00
0AFB8:  ADDWFC x07,W
0AFBA:  MOVWF  x24
0AFBC:  MOVFF  20B,228
0AFC0:  MOVFF  20A,227
0AFC4:  MOVFF  209,226
0AFC8:  MOVFF  208,225
0AFCC:  MOVF   x21,W
0AFCE:  SUBWF  x25,W
0AFD0:  MOVWF  x29
0AFD2:  MOVF   x22,W
0AFD4:  SUBWFB x26,W
0AFD6:  MOVWF  x2A
0AFD8:  MOVF   x23,W
0AFDA:  SUBWFB x27,W
0AFDC:  MOVWF  x2B
0AFDE:  MOVF   x24,W
0AFE0:  SUBWFB x28,W
0AFE2:  MOVWF  x2C
0AFE4:  MOVF   x1C,W
0AFE6:  ADDWF  x21,W
0AFE8:  MOVWF  x2D
0AFEA:  MOVF   x1D,W
0AFEC:  ADDWFC x22,W
0AFEE:  MOVWF  x2E
0AFF0:  MOVF   x1E,W
0AFF2:  ADDWFC x23,W
0AFF4:  MOVWF  x2F
0AFF6:  MOVF   x1F,W
0AFF8:  ADDWFC x24,W
0AFFA:  MOVWF  x30
.................... 
.................... 
....................     // Delete the first part in advance in case of looping
....................     if ((used_size + write_size) > data_region_size)
0AFFC:  MOVF   x10,W
0AFFE:  ADDWF  x1C,W
0B000:  MOVWF  x8F
0B002:  MOVF   x11,W
0B004:  ADDWFC x1D,W
0B006:  MOVWF  x90
0B008:  MOVF   x12,W
0B00A:  ADDWFC x1E,W
0B00C:  MOVWF  x91
0B00E:  MOVF   x13,W
0B010:  ADDWFC x1F,W
0B012:  MOVWF  x92
0B014:  MOVF   x2C,W
0B016:  SUBWF  x92,W
0B018:  BTFSC  FD8.0
0B01A:  BRA    B022
0B01C:  MOVLB  0
0B01E:  GOTO   B152
0B022:  MOVLB  0
0B024:  BTFSS  FD8.2
0B026:  GOTO   B06C
0B02A:  MOVLB  2
0B02C:  MOVF   x2B,W
0B02E:  SUBWF  x91,W
0B030:  BTFSC  FD8.0
0B032:  BRA    B03A
0B034:  MOVLB  0
0B036:  GOTO   B152
0B03A:  MOVLB  0
0B03C:  BTFSS  FD8.2
0B03E:  GOTO   B06C
0B042:  MOVLB  2
0B044:  MOVF   x2A,W
0B046:  SUBWF  x90,W
0B048:  BTFSC  FD8.0
0B04A:  BRA    B052
0B04C:  MOVLB  0
0B04E:  GOTO   B152
0B052:  MOVLB  0
0B054:  BTFSS  FD8.2
0B056:  GOTO   B06C
0B05A:  MOVLB  2
0B05C:  MOVF   x8F,W
0B05E:  SUBWF  x29,W
0B060:  BTFSS  FD8.0
0B062:  BRA    B06A
0B064:  MOVLB  0
0B066:  GOTO   B152
0B06A:  MOVLB  0
....................     {
....................         fprintf(PC, "Wrap triggered: Resetting data_write_addr to start\r\n");
0B06C:  MOVLW  5A
0B06E:  MOVWF  FF6
0B070:  MOVLW  07
0B072:  MOVWF  FF7
0B074:  MOVLW  00
0B076:  MOVWF  FF8
0B078:  CALL   1D32
....................         loop_count++;
0B07C:  MOVLB  2
0B07E:  INCF   x20,F
....................         used_size = 0;
0B080:  CLRF   x1F
0B082:  CLRF   x1E
0B084:  CLRF   x1D
0B086:  CLRF   x1C
....................         data_write_addr = data_region_start;
0B088:  MOVFF  224,230
0B08C:  MOVFF  223,22F
0B090:  MOVFF  222,22E
0B094:  MOVFF  221,22D
....................         
....................         // Reset counters when loop occurs
....................         reset_misf_counters(smf_data->mission_id);
0B098:  MOVLB  1
0B09A:  MOVF   xBA,W
0B09C:  MOVWF  FE9
0B09E:  MOVF   xBB,W
0B0A0:  MOVWF  FEA
0B0A2:  MOVFF  FEF,28F
0B0A6:  MOVFF  28F,290
0B0AA:  MOVLB  0
0B0AC:  GOTO   A9D6
....................         
....................         unsigned int32 erase_ptr = data_region_start;
0B0B0:  MOVFF  224,234
0B0B4:  MOVFF  223,233
0B0B8:  MOVFF  222,232
0B0BC:  MOVFF  221,231
....................         while (erase_ptr < data_region_end)
0B0C0:  MOVLB  2
0B0C2:  MOVF   x34,W
0B0C4:  SUBWF  x28,W
0B0C6:  BTFSC  FD8.0
0B0C8:  BRA    B0D0
0B0CA:  MOVLB  0
0B0CC:  GOTO   B152
0B0D0:  MOVLB  0
0B0D2:  BTFSS  FD8.2
0B0D4:  GOTO   B11A
0B0D8:  MOVLB  2
0B0DA:  MOVF   x33,W
0B0DC:  SUBWF  x27,W
0B0DE:  BTFSC  FD8.0
0B0E0:  BRA    B0E8
0B0E2:  MOVLB  0
0B0E4:  GOTO   B152
0B0E8:  MOVLB  0
0B0EA:  BTFSS  FD8.2
0B0EC:  GOTO   B11A
0B0F0:  MOVLB  2
0B0F2:  MOVF   x32,W
0B0F4:  SUBWF  x26,W
0B0F6:  BTFSC  FD8.0
0B0F8:  BRA    B100
0B0FA:  MOVLB  0
0B0FC:  GOTO   B152
0B100:  MOVLB  0
0B102:  BTFSS  FD8.2
0B104:  GOTO   B11A
0B108:  MOVLB  2
0B10A:  MOVF   x25,W
0B10C:  SUBWF  x31,W
0B10E:  BTFSS  FD8.0
0B110:  BRA    B118
0B112:  MOVLB  0
0B114:  GOTO   B152
0B118:  MOVLB  0
....................         {
....................             subsector_4kByte_erase(smf, erase_ptr);
0B11A:  MOVFF  115,314
0B11E:  MOVFF  114,313
0B122:  MOVFF  113,312
0B126:  MOVFF  112,311
0B12A:  MOVFF  234,318
0B12E:  MOVFF  233,317
0B132:  MOVFF  232,316
0B136:  MOVFF  231,315
0B13A:  CALL   56D4
....................             erase_ptr += SUBSECTOR_SIZE;     // tips: `value += 0x1000` means add up 4KB (0x1000 = 0d4096)
0B13E:  MOVLW  10
0B140:  MOVLB  2
0B142:  ADDWF  x32,F
0B144:  MOVLW  00
0B146:  ADDWFC x33,F
0B148:  MOVLW  00
0B14A:  ADDWFC x34,F
0B14C:  MOVLB  0
0B14E:  GOTO   B0C0
....................         }
....................     }
.................... 
.................... 
....................     // Erase the space you will be writing in now
....................     unsigned int32 erase_start = data_write_addr & ~0xFFF;       // tips: `value & ~0xFFF` means alignment 4KB.
....................     unsigned int32 erase_end = (data_write_addr + write_size + 0xFFF) & ~0xFFF;
0B152:  MOVLB  2
0B154:  CLRF   x35
0B156:  MOVF   x2E,W
0B158:  ANDLW  F0
0B15A:  MOVWF  x36
0B15C:  CLRF   x37
0B15E:  CLRF   x38
0B160:  MOVF   x10,W
0B162:  ADDWF  x2D,W
0B164:  MOVWF  x8F
0B166:  MOVF   x11,W
0B168:  ADDWFC x2E,W
0B16A:  MOVWF  x90
0B16C:  MOVF   x12,W
0B16E:  ADDWFC x2F,W
0B170:  MOVWF  x91
0B172:  MOVF   x13,W
0B174:  ADDWFC x30,W
0B176:  MOVWF  x92
0B178:  MOVLW  FF
0B17A:  ADDWF  x8F,F
0B17C:  MOVLW  0F
0B17E:  ADDWFC x90,F
0B180:  MOVLW  00
0B182:  ADDWFC x91,F
0B184:  MOVLW  00
0B186:  ADDWFC x92,F
0B188:  CLRF   x39
0B18A:  MOVF   x90,W
0B18C:  ANDLW  F0
0B18E:  MOVWF  x3A
0B190:  CLRF   x3B
0B192:  CLRF   x3C
....................     for (unsigned int32 addr = erase_start; addr < erase_end && addr < mis_end_address; addr += SUBSECTOR_SIZE)
0B194:  MOVFF  238,240
0B198:  MOVFF  237,23F
0B19C:  MOVFF  236,23E
0B1A0:  MOVFF  235,23D
0B1A4:  MOVLB  0
0B1A6:  MOVLB  2
0B1A8:  MOVF   x40,W
0B1AA:  SUBWF  x3C,W
0B1AC:  BTFSC  FD8.0
0B1AE:  BRA    B1B6
0B1B0:  MOVLB  0
0B1B2:  GOTO   B292
0B1B6:  MOVLB  0
0B1B8:  BTFSS  FD8.2
0B1BA:  GOTO   B200
0B1BE:  MOVLB  2
0B1C0:  MOVF   x3F,W
0B1C2:  SUBWF  x3B,W
0B1C4:  BTFSC  FD8.0
0B1C6:  BRA    B1CE
0B1C8:  MOVLB  0
0B1CA:  GOTO   B292
0B1CE:  MOVLB  0
0B1D0:  BTFSS  FD8.2
0B1D2:  GOTO   B200
0B1D6:  MOVLB  2
0B1D8:  MOVF   x3E,W
0B1DA:  SUBWF  x3A,W
0B1DC:  BTFSC  FD8.0
0B1DE:  BRA    B1E6
0B1E0:  MOVLB  0
0B1E2:  GOTO   B292
0B1E6:  MOVLB  0
0B1E8:  BTFSS  FD8.2
0B1EA:  GOTO   B200
0B1EE:  MOVLB  2
0B1F0:  MOVF   x39,W
0B1F2:  SUBWF  x3D,W
0B1F4:  BTFSS  FD8.0
0B1F6:  BRA    B1FE
0B1F8:  MOVLB  0
0B1FA:  GOTO   B292
0B1FE:  MOVLB  0
0B200:  MOVLB  2
0B202:  MOVF   x40,W
0B204:  SUBWF  x0B,W
0B206:  BTFSC  FD8.0
0B208:  BRA    B210
0B20A:  MOVLB  0
0B20C:  GOTO   B292
0B210:  MOVLB  0
0B212:  BTFSS  FD8.2
0B214:  GOTO   B25A
0B218:  MOVLB  2
0B21A:  MOVF   x3F,W
0B21C:  SUBWF  x0A,W
0B21E:  BTFSC  FD8.0
0B220:  BRA    B228
0B222:  MOVLB  0
0B224:  GOTO   B292
0B228:  MOVLB  0
0B22A:  BTFSS  FD8.2
0B22C:  GOTO   B25A
0B230:  MOVLB  2
0B232:  MOVF   x3E,W
0B234:  SUBWF  x09,W
0B236:  BTFSC  FD8.0
0B238:  BRA    B240
0B23A:  MOVLB  0
0B23C:  GOTO   B292
0B240:  MOVLB  0
0B242:  BTFSS  FD8.2
0B244:  GOTO   B25A
0B248:  MOVLB  2
0B24A:  MOVF   x08,W
0B24C:  SUBWF  x3D,W
0B24E:  BTFSS  FD8.0
0B250:  BRA    B258
0B252:  MOVLB  0
0B254:  GOTO   B292
0B258:  MOVLB  0
....................         subsector_4kByte_erase(smf, addr);
0B25A:  MOVFF  115,314
0B25E:  MOVFF  114,313
0B262:  MOVFF  113,312
0B266:  MOVFF  112,311
0B26A:  MOVFF  240,318
0B26E:  MOVFF  23F,317
0B272:  MOVFF  23E,316
0B276:  MOVFF  23D,315
0B27A:  CALL   56D4
0B27E:  MOVLW  10
0B280:  MOVLB  2
0B282:  ADDWF  x3E,F
0B284:  MOVLW  00
0B286:  ADDWFC x3F,F
0B288:  MOVLW  00
0B28A:  ADDWFC x40,F
0B28C:  MOVLB  0
0B28E:  GOTO   B1A6
.................... 
....................     unsigned int32 remaining = write_size;
....................     unsigned int32 src_addr = write_src;
....................     int8 buffer[PACKET_SIZE];
0B292:  MOVFF  213,244
0B296:  MOVFF  212,243
0B29A:  MOVFF  211,242
0B29E:  MOVFF  210,241
0B2A2:  MOVFF  20F,248
0B2A6:  MOVFF  20E,247
0B2AA:  MOVFF  20D,246
0B2AE:  MOVFF  20C,245
....................     while (remaining > 0)
0B2B2:  MOVLB  2
0B2B4:  MOVF   x41,F
0B2B6:  BTFSC  FD8.2
0B2B8:  BRA    B2C0
0B2BA:  MOVLB  0
0B2BC:  GOTO   B2F2
0B2C0:  MOVLB  0
0B2C2:  MOVLB  2
0B2C4:  MOVF   x42,F
0B2C6:  BTFSC  FD8.2
0B2C8:  BRA    B2D0
0B2CA:  MOVLB  0
0B2CC:  GOTO   B2F2
0B2D0:  MOVLB  0
0B2D2:  MOVLB  2
0B2D4:  MOVF   x43,F
0B2D6:  BTFSC  FD8.2
0B2D8:  BRA    B2E0
0B2DA:  MOVLB  0
0B2DC:  GOTO   B2F2
0B2E0:  MOVLB  0
0B2E2:  MOVLB  2
0B2E4:  MOVF   x44,F
0B2E6:  BTFSS  FD8.2
0B2E8:  BRA    B2F0
0B2EA:  MOVLB  0
0B2EC:  GOTO   B4A8
0B2F0:  MOVLB  0
....................     {
....................         unsigned int16 chunk = (remaining > MAX_READ_SIZE) ? MAX_READ_SIZE : remaining; //  = max(MAX_READ_SIZE, rest write_size)
0B2F2:  MOVLB  2
0B2F4:  MOVF   x44,F
0B2F6:  BTFSC  FD8.2
0B2F8:  BRA    B300
0B2FA:  MOVLB  0
0B2FC:  GOTO   B334
0B300:  MOVLB  0
0B302:  MOVLB  2
0B304:  MOVF   x43,F
0B306:  BTFSC  FD8.2
0B308:  BRA    B310
0B30A:  MOVLB  0
0B30C:  GOTO   B334
0B310:  MOVLB  0
0B312:  MOVLB  2
0B314:  MOVF   x42,F
0B316:  BTFSC  FD8.2
0B318:  BRA    B320
0B31A:  MOVLB  0
0B31C:  GOTO   B334
0B320:  MOVLB  0
0B322:  MOVLB  2
0B324:  MOVF   x41,W
0B326:  SUBLW  40
0B328:  BTFSS  FD8.0
0B32A:  BRA    B332
0B32C:  MOVLB  0
0B32E:  GOTO   B33C
0B332:  MOVLB  0
0B334:  CLRF   03
0B336:  MOVLW  40
0B338:  GOTO   B346
0B33C:  MOVFF  242,03
0B340:  MOVLB  2
0B342:  MOVF   x41,W
0B344:  MOVLB  0
0B346:  MOVLB  2
0B348:  MOVWF  x89
0B34A:  MOVFF  03,28A
0B34E:  MOVLB  0
.................... 
....................         read_data_bytes(mis_fm, src_addr, buffer, chunk);
0B350:  MOVFF  111,314
0B354:  MOVFF  110,313
0B358:  MOVFF  10F,312
0B35C:  MOVFF  10E,311
0B360:  MOVFF  248,318
0B364:  MOVFF  247,317
0B368:  MOVFF  246,316
0B36C:  MOVFF  245,315
0B370:  MOVLW  02
0B372:  MOVLB  3
0B374:  MOVWF  x1A
0B376:  MOVLW  49
0B378:  MOVWF  x19
0B37A:  CLRF   x1E
0B37C:  CLRF   x1D
0B37E:  MOVFF  28A,31C
0B382:  MOVFF  289,31B
0B386:  MOVLB  0
0B388:  CALL   28E2
....................         write_data_bytes(smf, data_write_addr, buffer, chunk);
0B38C:  MOVFF  115,A7F
0B390:  MOVFF  114,A7E
0B394:  MOVFF  113,A7D
0B398:  MOVFF  112,A7C
0B39C:  MOVFF  230,A83
0B3A0:  MOVFF  22F,A82
0B3A4:  MOVFF  22E,A81
0B3A8:  MOVFF  22D,A80
0B3AC:  MOVLW  02
0B3AE:  MOVLB  A
0B3B0:  MOVWF  x85
0B3B2:  MOVLW  49
0B3B4:  MOVWF  x84
0B3B6:  MOVFF  28A,A87
0B3BA:  MOVFF  289,A86
0B3BE:  MOVLB  0
0B3C0:  CALL   3F84
....................         for (unsigned int32 i = 0; i < chunk; i++)
0B3C4:  MOVLB  2
0B3C6:  CLRF   x8E
0B3C8:  CLRF   x8D
0B3CA:  CLRF   x8C
0B3CC:  CLRF   x8B
0B3CE:  MOVLB  0
0B3D0:  MOVLB  2
0B3D2:  MOVF   x8E,F
0B3D4:  BTFSC  FD8.2
0B3D6:  BRA    B3DE
0B3D8:  MOVLB  0
0B3DA:  GOTO   B460
0B3DE:  MOVLB  0
0B3E0:  MOVLB  2
0B3E2:  MOVF   x8D,F
0B3E4:  BTFSC  FD8.2
0B3E6:  BRA    B3EE
0B3E8:  MOVLB  0
0B3EA:  GOTO   B460
0B3EE:  MOVLB  0
0B3F0:  MOVLB  2
0B3F2:  MOVF   x8C,W
0B3F4:  SUBWF  x8A,W
0B3F6:  BTFSC  FD8.0
0B3F8:  BRA    B400
0B3FA:  MOVLB  0
0B3FC:  GOTO   B460
0B400:  MOVLB  0
0B402:  BTFSS  FD8.2
0B404:  GOTO   B41A
0B408:  MOVLB  2
0B40A:  MOVF   x89,W
0B40C:  SUBWF  x8B,W
0B40E:  BTFSS  FD8.0
0B410:  BRA    B418
0B412:  MOVLB  0
0B414:  GOTO   B460
0B418:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0B41A:  MOVLW  49
0B41C:  MOVLB  2
0B41E:  ADDWF  x8B,W
0B420:  MOVWF  FE9
0B422:  MOVLW  02
0B424:  ADDWFC x8C,W
0B426:  MOVWF  FEA
0B428:  MOVFF  FEF,28F
0B42C:  MOVFF  28F,A39
0B430:  MOVLW  37
0B432:  MOVLB  A
0B434:  MOVWF  x3A
0B436:  MOVLB  0
0B438:  CALL   1F60
0B43C:  MOVLW  20
0B43E:  MOVLB  A
0B440:  MOVWF  xDB
0B442:  MOVLB  0
0B444:  CALL   1CE0
0B448:  MOVLW  01
0B44A:  MOVLB  2
0B44C:  ADDWF  x8B,F
0B44E:  BTFSC  FD8.0
0B450:  INCF   x8C,F
0B452:  BTFSC  FD8.2
0B454:  INCF   x8D,F
0B456:  BTFSC  FD8.2
0B458:  INCF   x8E,F
0B45A:  MOVLB  0
0B45C:  GOTO   B3D0
....................         }
....................         src_addr += chunk;
0B460:  MOVLB  2
0B462:  MOVF   x89,W
0B464:  ADDWF  x45,F
0B466:  MOVF   x8A,W
0B468:  ADDWFC x46,F
0B46A:  MOVLW  00
0B46C:  ADDWFC x47,F
0B46E:  MOVLW  00
0B470:  ADDWFC x48,F
....................         data_write_addr += chunk;
0B472:  MOVF   x89,W
0B474:  ADDWF  x2D,F
0B476:  MOVF   x8A,W
0B478:  ADDWFC x2E,F
0B47A:  MOVLW  00
0B47C:  ADDWFC x2F,F
0B47E:  MOVLW  00
0B480:  ADDWFC x30,F
....................         used_size += chunk;
0B482:  MOVF   x89,W
0B484:  ADDWF  x1C,F
0B486:  MOVF   x8A,W
0B488:  ADDWFC x1D,F
0B48A:  MOVLW  00
0B48C:  ADDWFC x1E,F
0B48E:  MOVLW  00
0B490:  ADDWFC x1F,F
....................         remaining -= chunk;
0B492:  MOVF   x89,W
0B494:  SUBWF  x41,F
0B496:  MOVF   x8A,W
0B498:  SUBWFB x42,F
0B49A:  MOVLW  00
0B49C:  SUBWFB x43,F
0B49E:  MOVLW  00
0B4A0:  SUBWFB x44,F
0B4A2:  MOVLB  0
0B4A4:  GOTO   B2B2
....................     }
....................     // write size area
....................     write_smf_header();
0B4A8:  GOTO   A9DA
....................     
....................     // Update MISF counters for transferred data
....................     update_misf_counters(smf_data->mission_id, write_size);
0B4AC:  MOVLB  1
0B4AE:  MOVF   xBA,W
0B4B0:  MOVWF  FE9
0B4B2:  MOVF   xBB,W
0B4B4:  MOVWF  FEA
0B4B6:  MOVFF  FEF,28F
0B4BA:  MOVFF  28F,290
0B4BE:  MOVFF  213,294
0B4C2:  MOVFF  212,293
0B4C6:  MOVFF  211,292
0B4CA:  MOVFF  210,291
0B4CE:  MOVLB  0
0B4D0:  GOTO   AB68
....................     
....................     fprintf(PC, "used_size = %ld\r\n", used_size);
0B4D4:  MOVLW  90
0B4D6:  MOVWF  FF6
0B4D8:  MOVLW  07
0B4DA:  MOVWF  FF7
0B4DC:  MOVLW  00
0B4DE:  MOVWF  FF8
0B4E0:  MOVLW  0C
0B4E2:  MOVLB  3
0B4E4:  MOVWF  x12
0B4E6:  MOVLB  0
0B4E8:  CALL   1D62
0B4EC:  MOVLW  41
0B4EE:  MOVWF  FE9
0B4F0:  MOVFF  21F,292
0B4F4:  MOVFF  21E,291
0B4F8:  MOVFF  21D,290
0B4FC:  MOVFF  21C,28F
0B500:  CALL   A33A
0B504:  MOVLW  0D
0B506:  MOVLB  A
0B508:  MOVWF  xDB
0B50A:  MOVLB  0
0B50C:  CALL   1CE0
0B510:  MOVLW  0A
0B512:  MOVLB  A
0B514:  MOVWF  xDB
0B516:  MOVLB  0
0B518:  CALL   1CE0
....................     fprintf(PC, "loop_count = %u\r\n\r\n", loop_count);
0B51C:  MOVLW  A2
0B51E:  MOVWF  FF6
0B520:  MOVLW  07
0B522:  MOVWF  FF7
0B524:  MOVLW  00
0B526:  MOVWF  FF8
0B528:  MOVLW  0D
0B52A:  MOVLB  3
0B52C:  MOVWF  x12
0B52E:  MOVLB  0
0B530:  CALL   1D62
0B534:  MOVFF  220,293
0B538:  MOVLW  1B
0B53A:  MOVLB  2
0B53C:  MOVWF  x94
0B53E:  MOVLB  0
0B540:  CALL   A1B6
0B544:  MOVLW  B1
0B546:  MOVWF  FF6
0B548:  MOVLW  07
0B54A:  MOVWF  FF7
0B54C:  MOVLW  00
0B54E:  MOVWF  FF8
0B550:  MOVLW  04
0B552:  MOVLB  3
0B554:  MOVWF  x12
0B556:  MOVLB  0
0B558:  CALL   1D62
.................... 
....................     fprintf(PC, "\r\n___End copy_data____\r\n");
0B55C:  MOVLW  B6
0B55E:  MOVWF  FF6
0B560:  MOVLW  07
0B562:  MOVWF  FF7
0B564:  MOVLW  00
0B566:  MOVWF  FF8
0B568:  CALL   1D32
....................     fprintf(PC, "____________________\r\n\r\n");
0B56C:  MOVLW  D0
0B56E:  MOVWF  FF6
0B570:  MOVLW  07
0B572:  MOVWF  FF7
0B574:  MOVLW  00
0B576:  MOVWF  FF8
0B578:  CALL   1D32
0B57C:  GOTO   C152 (RETURN)
.................... }
.................... 
.................... void smf_read(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
*
0B680:  MOVLW  EA
0B682:  MOVWF  FF6
0B684:  MOVLW  07
0B686:  MOVWF  FF7
0B688:  MOVLW  00
0B68A:  MOVWF  FF8
0B68C:  CALL   1D32
....................     fprintf(PC, "___Start SMF Read____\r\n");
0B690:  MOVLW  04
0B692:  MOVWF  FF6
0B694:  MOVLW  08
0B696:  MOVWF  FF7
0B698:  MOVLW  00
0B69A:  MOVWF  FF8
0B69C:  CALL   1D32
.................... 
....................     int8 buffer[PACKET_SIZE];
.................... 
....................     SmfAddressStruct smf_address = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 read_address = smf_data->misf_start_addr;
....................     unsigned int32 read_size = smf_data->misf_size;
0B6A0:  MOVLB  1
0B6A2:  MOVF   xBA,W
0B6A4:  MOVWF  FE9
0B6A6:  MOVF   xBB,W
0B6A8:  MOVWF  FEA
0B6AA:  MOVFF  FEF,214
0B6AE:  MOVFF  214,296
0B6B2:  MOVLB  0
0B6B4:  CALL   A4B6
0B6B8:  MOVFF  02,03
0B6BC:  MOVF   01,W
0B6BE:  MOVWF  FE1
0B6C0:  MOVFF  03,FE2
0B6C4:  MOVLW  01
0B6C6:  MOVWF  FEA
0B6C8:  MOVLW  FC
0B6CA:  MOVWF  FE9
0B6CC:  MOVLW  08
0B6CE:  MOVWF  01
0B6D0:  MOVFF  FE6,FEE
0B6D4:  DECFSZ 01,F
0B6D6:  GOTO   B6D0
0B6DA:  MOVLW  04
0B6DC:  MOVLB  1
0B6DE:  ADDWF  xBA,W
0B6E0:  MOVWF  FE9
0B6E2:  MOVLW  00
0B6E4:  ADDWFC xBB,W
0B6E6:  MOVWF  FEA
0B6E8:  MOVFF  FEF,204
0B6EC:  MOVFF  FEC,205
0B6F0:  MOVFF  FEC,206
0B6F4:  MOVFF  FEC,207
0B6F8:  MOVF   FED,F
0B6FA:  MOVF   FED,F
0B6FC:  MOVF   FED,F
0B6FE:  MOVLW  08
0B700:  ADDWF  xBA,W
0B702:  MOVWF  FE9
0B704:  MOVLW  00
0B706:  ADDWFC xBB,W
0B708:  MOVWF  FEA
0B70A:  MOVFF  FEF,208
0B70E:  MOVFF  FEC,209
0B712:  MOVFF  FEC,20A
0B716:  MOVFF  FEC,20B
0B71A:  MOVF   FED,F
0B71C:  MOVF   FED,F
0B71E:  MOVF   FED,F
.................... 
....................     fprintf(PC, "In SMF Read source data address: %LX\r\n", read_address);
0B720:  MOVLW  1C
0B722:  MOVWF  FF6
0B724:  MOVLW  08
0B726:  MOVWF  FF7
0B728:  MOVLW  00
0B72A:  MOVWF  FF8
0B72C:  MOVLW  21
0B72E:  MOVLB  3
0B730:  MOVWF  x12
0B732:  MOVLB  0
0B734:  CALL   1D62
0B738:  MOVFF  207,A39
0B73C:  MOVLW  37
0B73E:  MOVLB  A
0B740:  MOVWF  x3A
0B742:  MOVLB  0
0B744:  CALL   1F60
0B748:  MOVFF  206,A39
0B74C:  MOVLW  37
0B74E:  MOVLB  A
0B750:  MOVWF  x3A
0B752:  MOVLB  0
0B754:  CALL   1F60
0B758:  MOVFF  205,A39
0B75C:  MOVLW  37
0B75E:  MOVLB  A
0B760:  MOVWF  x3A
0B762:  MOVLB  0
0B764:  CALL   1F60
0B768:  MOVFF  204,A39
0B76C:  MOVLW  37
0B76E:  MOVLB  A
0B770:  MOVWF  x3A
0B772:  MOVLB  0
0B774:  CALL   1F60
0B778:  MOVLW  0D
0B77A:  MOVLB  A
0B77C:  MOVWF  xDB
0B77E:  MOVLB  0
0B780:  CALL   1CE0
0B784:  MOVLW  0A
0B786:  MOVLB  A
0B788:  MOVWF  xDB
0B78A:  MOVLB  0
0B78C:  CALL   1CE0
....................     fprintf(PC, "In SMF Read data size          : %lu (0x%lx)\r\n\r\n", read_size, read_size);
0B790:  MOVLW  44
0B792:  MOVWF  FF6
0B794:  MOVLW  08
0B796:  MOVWF  FF7
0B798:  MOVLW  00
0B79A:  MOVWF  FF8
0B79C:  MOVLW  21
0B79E:  MOVLB  3
0B7A0:  MOVWF  x12
0B7A2:  MOVLB  0
0B7A4:  CALL   1D62
0B7A8:  MOVLW  41
0B7AA:  MOVWF  FE9
0B7AC:  MOVFF  20B,217
0B7B0:  MOVFF  20A,216
0B7B4:  MOVFF  209,215
0B7B8:  MOVFF  208,214
0B7BC:  CALL   B580
0B7C0:  MOVLW  68
0B7C2:  MOVWF  FF6
0B7C4:  MOVLW  08
0B7C6:  MOVWF  FF7
0B7C8:  MOVLW  00
0B7CA:  MOVWF  FF8
0B7CC:  MOVLW  04
0B7CE:  MOVLB  3
0B7D0:  MOVWF  x12
0B7D2:  MOVLB  0
0B7D4:  CALL   1D62
0B7D8:  MOVFF  20B,A39
0B7DC:  MOVLW  57
0B7DE:  MOVLB  A
0B7E0:  MOVWF  x3A
0B7E2:  MOVLB  0
0B7E4:  CALL   1F60
0B7E8:  MOVFF  20A,A39
0B7EC:  MOVLW  57
0B7EE:  MOVLB  A
0B7F0:  MOVWF  x3A
0B7F2:  MOVLB  0
0B7F4:  CALL   1F60
0B7F8:  MOVFF  209,A39
0B7FC:  MOVLW  57
0B7FE:  MOVLB  A
0B800:  MOVWF  x3A
0B802:  MOVLB  0
0B804:  CALL   1F60
0B808:  MOVFF  208,A39
0B80C:  MOVLW  57
0B80E:  MOVLB  A
0B810:  MOVWF  x3A
0B812:  MOVLB  0
0B814:  CALL   1F60
0B818:  MOVLW  6F
0B81A:  MOVWF  FF6
0B81C:  MOVLW  08
0B81E:  MOVWF  FF7
0B820:  MOVLW  00
0B822:  MOVWF  FF8
0B824:  MOVLW  05
0B826:  MOVLB  3
0B828:  MOVWF  x12
0B82A:  MOVLB  0
0B82C:  CALL   1D62
.................... 
....................     if (!is_connect(smf)){
0B830:  MOVFF  115,292
0B834:  MOVFF  114,291
0B838:  MOVFF  113,290
0B83C:  MOVFF  112,28F
0B840:  CALL   27F6
0B844:  MOVF   01,F
0B846:  BTFSS  FD8.2
0B848:  GOTO   B85C
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0B84C:  MOVLW  76
0B84E:  MOVWF  FF6
0B850:  MOVLW  08
0B852:  MOVWF  FF7
0B854:  MOVLW  00
0B856:  MOVWF  FF8
0B858:  CALL   1D32
....................     }
....................     fprintf(PC, "READ DATA FROM SMF...\r\n");
0B85C:  MOVLW  94
0B85E:  MOVWF  FF6
0B860:  MOVLW  08
0B862:  MOVWF  FF7
0B864:  MOVLW  00
0B866:  MOVWF  FF8
0B868:  CALL   1D32
....................     for (unsigned int32 addr = read_address; addr < read_address + read_size; addr += PACKET_SIZE)
0B86C:  MOVFF  207,20F
0B870:  MOVFF  206,20E
0B874:  MOVFF  205,20D
0B878:  MOVFF  204,20C
0B87C:  MOVLB  2
0B87E:  MOVF   x08,W
0B880:  ADDWF  x04,W
0B882:  MOVWF  00
0B884:  MOVF   x09,W
0B886:  ADDWFC x05,W
0B888:  MOVWF  01
0B88A:  MOVF   x0A,W
0B88C:  ADDWFC x06,W
0B88E:  MOVWF  02
0B890:  MOVF   x0B,W
0B892:  ADDWFC x07,W
0B894:  MOVWF  03
0B896:  MOVF   x0F,W
0B898:  SUBWF  03,W
0B89A:  BTFSC  FD8.0
0B89C:  BRA    B8A4
0B89E:  MOVLB  0
0B8A0:  GOTO   B9EC
0B8A4:  MOVLB  0
0B8A6:  BTFSS  FD8.2
0B8A8:  GOTO   B8EE
0B8AC:  MOVLB  2
0B8AE:  MOVF   x0E,W
0B8B0:  SUBWF  02,W
0B8B2:  BTFSC  FD8.0
0B8B4:  BRA    B8BC
0B8B6:  MOVLB  0
0B8B8:  GOTO   B9EC
0B8BC:  MOVLB  0
0B8BE:  BTFSS  FD8.2
0B8C0:  GOTO   B8EE
0B8C4:  MOVLB  2
0B8C6:  MOVF   x0D,W
0B8C8:  SUBWF  01,W
0B8CA:  BTFSC  FD8.0
0B8CC:  BRA    B8D4
0B8CE:  MOVLB  0
0B8D0:  GOTO   B9EC
0B8D4:  MOVLB  0
0B8D6:  BTFSS  FD8.2
0B8D8:  GOTO   B8EE
0B8DC:  MOVF   00,W
0B8DE:  MOVLB  2
0B8E0:  SUBWF  x0C,W
0B8E2:  BTFSS  FD8.0
0B8E4:  BRA    B8EC
0B8E6:  MOVLB  0
0B8E8:  GOTO   B9EC
0B8EC:  MOVLB  0
....................     {
....................         read_data_bytes(smf, addr, buffer, PACKET_SIZE);
0B8EE:  MOVFF  115,314
0B8F2:  MOVFF  114,313
0B8F6:  MOVFF  113,312
0B8FA:  MOVFF  112,311
0B8FE:  MOVFF  20F,318
0B902:  MOVFF  20E,317
0B906:  MOVFF  20D,316
0B90A:  MOVFF  20C,315
0B90E:  MOVLW  01
0B910:  MOVLB  3
0B912:  MOVWF  x1A
0B914:  MOVLW  BC
0B916:  MOVWF  x19
0B918:  CLRF   x1E
0B91A:  CLRF   x1D
0B91C:  CLRF   x1C
0B91E:  MOVLW  40
0B920:  MOVWF  x1B
0B922:  MOVLB  0
0B924:  CALL   28E2
....................         for (unsigned int32 i = 0; i < PACKET_SIZE; i++)
0B928:  MOVLB  2
0B92A:  CLRF   x13
0B92C:  CLRF   x12
0B92E:  CLRF   x11
0B930:  CLRF   x10
0B932:  MOVLB  0
0B934:  MOVLB  2
0B936:  MOVF   x13,F
0B938:  BTFSC  FD8.2
0B93A:  BRA    B942
0B93C:  MOVLB  0
0B93E:  GOTO   B9BC
0B942:  MOVLB  0
0B944:  MOVLB  2
0B946:  MOVF   x12,F
0B948:  BTFSC  FD8.2
0B94A:  BRA    B952
0B94C:  MOVLB  0
0B94E:  GOTO   B9BC
0B952:  MOVLB  0
0B954:  MOVLB  2
0B956:  MOVF   x11,F
0B958:  BTFSC  FD8.2
0B95A:  BRA    B962
0B95C:  MOVLB  0
0B95E:  GOTO   B9BC
0B962:  MOVLB  0
0B964:  MOVLB  2
0B966:  MOVF   x10,W
0B968:  SUBLW  3F
0B96A:  BTFSC  FD8.0
0B96C:  BRA    B974
0B96E:  MOVLB  0
0B970:  GOTO   B9BC
0B974:  MOVLB  0
....................         {
....................             fprintf(PC, "%02X ", buffer[i]);
0B976:  MOVLW  BC
0B978:  MOVLB  2
0B97A:  ADDWF  x10,W
0B97C:  MOVWF  FE9
0B97E:  MOVLW  01
0B980:  ADDWFC x11,W
0B982:  MOVWF  FEA
0B984:  MOVFF  FEF,214
0B988:  MOVFF  214,A39
0B98C:  MOVLW  37
0B98E:  MOVLB  A
0B990:  MOVWF  x3A
0B992:  MOVLB  0
0B994:  CALL   1F60
0B998:  MOVLW  20
0B99A:  MOVLB  A
0B99C:  MOVWF  xDB
0B99E:  MOVLB  0
0B9A0:  CALL   1CE0
0B9A4:  MOVLW  01
0B9A6:  MOVLB  2
0B9A8:  ADDWF  x10,F
0B9AA:  BTFSC  FD8.0
0B9AC:  INCF   x11,F
0B9AE:  BTFSC  FD8.2
0B9B0:  INCF   x12,F
0B9B2:  BTFSC  FD8.2
0B9B4:  INCF   x13,F
0B9B6:  MOVLB  0
0B9B8:  GOTO   B934
....................         }
....................         fprintf(PC, "\r\n");
0B9BC:  MOVLW  0D
0B9BE:  MOVLB  A
0B9C0:  MOVWF  xDB
0B9C2:  MOVLB  0
0B9C4:  CALL   1CE0
0B9C8:  MOVLW  0A
0B9CA:  MOVLB  A
0B9CC:  MOVWF  xDB
0B9CE:  MOVLB  0
0B9D0:  CALL   1CE0
0B9D4:  MOVLW  40
0B9D6:  MOVLB  2
0B9D8:  ADDWF  x0C,F
0B9DA:  MOVLW  00
0B9DC:  ADDWFC x0D,F
0B9DE:  MOVLW  00
0B9E0:  ADDWFC x0E,F
0B9E2:  MOVLW  00
0B9E4:  ADDWFC x0F,F
0B9E6:  MOVLB  0
0B9E8:  GOTO   B87C
....................     }
....................     fprintf(PC, "\r\n___End SMF Read____\r\n");
0B9EC:  MOVLW  AC
0B9EE:  MOVWF  FF6
0B9F0:  MOVLW  08
0B9F2:  MOVWF  FF7
0B9F4:  MOVLW  00
0B9F6:  MOVWF  FF8
0B9F8:  CALL   1D32
....................     fprintf(PC, "____________________\r\n\r\n");
0B9FC:  MOVLW  C4
0B9FE:  MOVWF  FF6
0BA00:  MOVLW  08
0BA02:  MOVWF  FF7
0BA04:  MOVLW  00
0BA06:  MOVWF  FF8
0BA08:  CALL   1D32
0BA0C:  GOTO   C162 (RETURN)
.................... }
.................... 
.................... void smf_erase(FlashOperationStruct *smf_data)
.................... {
....................     fprintf(PC, "\r\n____________________\r\n");
0BA10:  MOVLW  DE
0BA12:  MOVWF  FF6
0BA14:  MOVLW  08
0BA16:  MOVWF  FF7
0BA18:  MOVLW  00
0BA1A:  MOVWF  FF8
0BA1C:  CALL   1D32
....................     fprintf(PC, "___Start smf_erase____\r\n");
0BA20:  MOVLW  F8
0BA22:  MOVWF  FF6
0BA24:  MOVLW  08
0BA26:  MOVWF  FF7
0BA28:  MOVLW  00
0BA2A:  MOVWF  FF8
0BA2C:  CALL   1D32
.................... 
....................     SmfAddressStruct mission_type = get_smf_address_struct(smf_data->mission_id);
....................     unsigned int32 erase_address = smf_data->misf_start_addr;
....................     unsigned int32 erase_size = smf_data->misf_size;
0BA30:  MOVLB  1
0BA32:  MOVF   xBA,W
0BA34:  MOVWF  FE9
0BA36:  MOVF   xBB,W
0BA38:  MOVWF  FEA
0BA3A:  MOVFF  FEF,1CC
0BA3E:  MOVFF  1CC,296
0BA42:  MOVLB  0
0BA44:  CALL   A4B6
0BA48:  MOVFF  02,03
0BA4C:  MOVF   01,W
0BA4E:  MOVWF  FE1
0BA50:  MOVFF  03,FE2
0BA54:  MOVLW  01
0BA56:  MOVWF  FEA
0BA58:  MOVLW  BC
0BA5A:  MOVWF  FE9
0BA5C:  MOVLW  08
0BA5E:  MOVWF  01
0BA60:  MOVFF  FE6,FEE
0BA64:  DECFSZ 01,F
0BA66:  GOTO   BA60
0BA6A:  MOVLW  04
0BA6C:  MOVLB  1
0BA6E:  ADDWF  xBA,W
0BA70:  MOVWF  FE9
0BA72:  MOVLW  00
0BA74:  ADDWFC xBB,W
0BA76:  MOVWF  FEA
0BA78:  MOVFF  FEF,1C4
0BA7C:  MOVFF  FEC,1C5
0BA80:  MOVFF  FEC,1C6
0BA84:  MOVFF  FEC,1C7
0BA88:  MOVF   FED,F
0BA8A:  MOVF   FED,F
0BA8C:  MOVF   FED,F
0BA8E:  MOVLW  08
0BA90:  ADDWF  xBA,W
0BA92:  MOVWF  FE9
0BA94:  MOVLW  00
0BA96:  ADDWFC xBB,W
0BA98:  MOVWF  FEA
0BA9A:  MOVFF  FEF,1C8
0BA9E:  MOVFF  FEC,1C9
0BAA2:  MOVFF  FEC,1CA
0BAA6:  MOVFF  FEC,1CB
0BAAA:  MOVF   FED,F
0BAAC:  MOVF   FED,F
0BAAE:  MOVF   FED,F
....................     fprintf(PC, "In SMF Erase source data address: %LX\r\n", erase_address);
0BAB0:  MOVLW  12
0BAB2:  MOVWF  FF6
0BAB4:  MOVLW  09
0BAB6:  MOVWF  FF7
0BAB8:  MOVLW  00
0BABA:  MOVWF  FF8
0BABC:  MOVLW  22
0BABE:  MOVLB  3
0BAC0:  MOVWF  x12
0BAC2:  MOVLB  0
0BAC4:  CALL   1D62
0BAC8:  MOVFF  1C7,A39
0BACC:  MOVLW  37
0BACE:  MOVLB  A
0BAD0:  MOVWF  x3A
0BAD2:  MOVLB  0
0BAD4:  CALL   1F60
0BAD8:  MOVFF  1C6,A39
0BADC:  MOVLW  37
0BADE:  MOVLB  A
0BAE0:  MOVWF  x3A
0BAE2:  MOVLB  0
0BAE4:  CALL   1F60
0BAE8:  MOVFF  1C5,A39
0BAEC:  MOVLW  37
0BAEE:  MOVLB  A
0BAF0:  MOVWF  x3A
0BAF2:  MOVLB  0
0BAF4:  CALL   1F60
0BAF8:  MOVFF  1C4,A39
0BAFC:  MOVLW  37
0BAFE:  MOVLB  A
0BB00:  MOVWF  x3A
0BB02:  MOVLB  0
0BB04:  CALL   1F60
0BB08:  MOVLW  0D
0BB0A:  MOVLB  A
0BB0C:  MOVWF  xDB
0BB0E:  MOVLB  0
0BB10:  CALL   1CE0
0BB14:  MOVLW  0A
0BB16:  MOVLB  A
0BB18:  MOVWF  xDB
0BB1A:  MOVLB  0
0BB1C:  CALL   1CE0
....................     fprintf(PC, "In SMF Erase data size          : %lu (0x%lx)\r\n\r\n", erase_size, erase_size);
0BB20:  MOVLW  3A
0BB22:  MOVWF  FF6
0BB24:  MOVLW  09
0BB26:  MOVWF  FF7
0BB28:  MOVLW  00
0BB2A:  MOVWF  FF8
0BB2C:  MOVLW  22
0BB2E:  MOVLB  3
0BB30:  MOVWF  x12
0BB32:  MOVLB  0
0BB34:  CALL   1D62
0BB38:  MOVLW  41
0BB3A:  MOVWF  FE9
0BB3C:  MOVFF  1CB,217
0BB40:  MOVFF  1CA,216
0BB44:  MOVFF  1C9,215
0BB48:  MOVFF  1C8,214
0BB4C:  CALL   B580
0BB50:  MOVLW  5F
0BB52:  MOVWF  FF6
0BB54:  MOVLW  09
0BB56:  MOVWF  FF7
0BB58:  MOVLW  00
0BB5A:  MOVWF  FF8
0BB5C:  MOVLW  04
0BB5E:  MOVLB  3
0BB60:  MOVWF  x12
0BB62:  MOVLB  0
0BB64:  CALL   1D62
0BB68:  MOVFF  1CB,A39
0BB6C:  MOVLW  57
0BB6E:  MOVLB  A
0BB70:  MOVWF  x3A
0BB72:  MOVLB  0
0BB74:  CALL   1F60
0BB78:  MOVFF  1CA,A39
0BB7C:  MOVLW  57
0BB7E:  MOVLB  A
0BB80:  MOVWF  x3A
0BB82:  MOVLB  0
0BB84:  CALL   1F60
0BB88:  MOVFF  1C9,A39
0BB8C:  MOVLW  57
0BB8E:  MOVLB  A
0BB90:  MOVWF  x3A
0BB92:  MOVLB  0
0BB94:  CALL   1F60
0BB98:  MOVFF  1C8,A39
0BB9C:  MOVLW  57
0BB9E:  MOVLB  A
0BBA0:  MOVWF  x3A
0BBA2:  MOVLB  0
0BBA4:  CALL   1F60
0BBA8:  MOVLW  66
0BBAA:  MOVWF  FF6
0BBAC:  MOVLW  09
0BBAE:  MOVWF  FF7
0BBB0:  MOVLW  00
0BBB2:  MOVWF  FF8
0BBB4:  MOVLW  05
0BBB6:  MOVLB  3
0BBB8:  MOVWF  x12
0BBBA:  MOVLB  0
0BBBC:  CALL   1D62
.................... 
....................     if (!is_connect(smf)){
0BBC0:  MOVFF  115,292
0BBC4:  MOVFF  114,291
0BBC8:  MOVFF  113,290
0BBCC:  MOVFF  112,28F
0BBD0:  CALL   27F6
0BBD4:  MOVF   01,F
0BBD6:  BTFSS  FD8.2
0BBD8:  GOTO   BBF0
....................         fprintf(PC, "Error: SMF is not connected\r\n");
0BBDC:  MOVLW  6C
0BBDE:  MOVWF  FF6
0BBE0:  MOVLW  09
0BBE2:  MOVWF  FF7
0BBE4:  MOVLW  00
0BBE6:  MOVWF  FF8
0BBE8:  CALL   1D32
....................         return;
0BBEC:  GOTO   BF2A
....................     }
.................... 
....................     // Check if erase operation is within mission_type range
....................     if (erase_address < mission_type.start_address || erase_address >= mission_type.end_address) {
0BBF0:  MOVLB  1
0BBF2:  MOVF   xC7,W
0BBF4:  SUBWF  xBF,W
0BBF6:  BTFSC  FD8.0
0BBF8:  BRA    BC00
0BBFA:  MOVLB  0
0BBFC:  GOTO   BC4A
0BC00:  MOVLB  0
0BC02:  BTFSS  FD8.2
0BC04:  GOTO   BCA4
0BC08:  MOVLB  1
0BC0A:  MOVF   xC6,W
0BC0C:  SUBWF  xBE,W
0BC0E:  BTFSC  FD8.0
0BC10:  BRA    BC18
0BC12:  MOVLB  0
0BC14:  GOTO   BC4A
0BC18:  MOVLB  0
0BC1A:  BTFSS  FD8.2
0BC1C:  GOTO   BCA4
0BC20:  MOVLB  1
0BC22:  MOVF   xC5,W
0BC24:  SUBWF  xBD,W
0BC26:  BTFSC  FD8.0
0BC28:  BRA    BC30
0BC2A:  MOVLB  0
0BC2C:  GOTO   BC4A
0BC30:  MOVLB  0
0BC32:  BTFSS  FD8.2
0BC34:  GOTO   BCA4
0BC38:  MOVLB  1
0BC3A:  MOVF   xBC,W
0BC3C:  SUBWF  xC4,W
0BC3E:  BTFSC  FD8.0
0BC40:  BRA    BC48
0BC42:  MOVLB  0
0BC44:  GOTO   BCA4
0BC48:  MOVLB  0
0BC4A:  MOVLB  1
0BC4C:  MOVF   xC3,W
0BC4E:  SUBWF  xC7,W
0BC50:  BTFSC  FD8.0
0BC52:  BRA    BC5A
0BC54:  MOVLB  0
0BC56:  GOTO   BDC8
0BC5A:  MOVLB  0
0BC5C:  BTFSS  FD8.2
0BC5E:  GOTO   BCA4
0BC62:  MOVLB  1
0BC64:  MOVF   xC2,W
0BC66:  SUBWF  xC6,W
0BC68:  BTFSC  FD8.0
0BC6A:  BRA    BC72
0BC6C:  MOVLB  0
0BC6E:  GOTO   BDC8
0BC72:  MOVLB  0
0BC74:  BTFSS  FD8.2
0BC76:  GOTO   BCA4
0BC7A:  MOVLB  1
0BC7C:  MOVF   xC1,W
0BC7E:  SUBWF  xC5,W
0BC80:  BTFSC  FD8.0
0BC82:  BRA    BC8A
0BC84:  MOVLB  0
0BC86:  GOTO   BDC8
0BC8A:  MOVLB  0
0BC8C:  BTFSS  FD8.2
0BC8E:  GOTO   BCA4
0BC92:  MOVLB  1
0BC94:  MOVF   xC0,W
0BC96:  SUBWF  xC4,W
0BC98:  BTFSC  FD8.0
0BC9A:  BRA    BCA2
0BC9C:  MOVLB  0
0BC9E:  GOTO   BDC8
0BCA2:  MOVLB  0
....................         fprintf(PC, "Error: Erase source address 0x%LX is outside mission range [0x%LX - 0x%LX]\r\n", 
....................                 erase_address, mission_type.start_address, mission_type.end_address);
0BCA4:  MOVLW  8A
0BCA6:  MOVWF  FF6
0BCA8:  MOVLW  09
0BCAA:  MOVWF  FF7
0BCAC:  MOVLW  00
0BCAE:  MOVWF  FF8
0BCB0:  MOVLW  1E
0BCB2:  MOVLB  3
0BCB4:  MOVWF  x12
0BCB6:  MOVLB  0
0BCB8:  CALL   1D62
0BCBC:  MOVFF  1C7,A39
0BCC0:  MOVLW  37
0BCC2:  MOVLB  A
0BCC4:  MOVWF  x3A
0BCC6:  MOVLB  0
0BCC8:  CALL   1F60
0BCCC:  MOVFF  1C6,A39
0BCD0:  MOVLW  37
0BCD2:  MOVLB  A
0BCD4:  MOVWF  x3A
0BCD6:  MOVLB  0
0BCD8:  CALL   1F60
0BCDC:  MOVFF  1C5,A39
0BCE0:  MOVLW  37
0BCE2:  MOVLB  A
0BCE4:  MOVWF  x3A
0BCE6:  MOVLB  0
0BCE8:  CALL   1F60
0BCEC:  MOVFF  1C4,A39
0BCF0:  MOVLW  37
0BCF2:  MOVLB  A
0BCF4:  MOVWF  x3A
0BCF6:  MOVLB  0
0BCF8:  CALL   1F60
0BCFC:  MOVLW  AB
0BCFE:  MOVWF  FF6
0BD00:  MOVLW  09
0BD02:  MOVWF  FF7
0BD04:  MOVLW  00
0BD06:  MOVWF  FF8
0BD08:  MOVLW  1D
0BD0A:  MOVLB  3
0BD0C:  MOVWF  x12
0BD0E:  MOVLB  0
0BD10:  CALL   1D62
0BD14:  MOVFF  1BF,A39
0BD18:  MOVLW  37
0BD1A:  MOVLB  A
0BD1C:  MOVWF  x3A
0BD1E:  MOVLB  0
0BD20:  CALL   1F60
0BD24:  MOVFF  1BE,A39
0BD28:  MOVLW  37
0BD2A:  MOVLB  A
0BD2C:  MOVWF  x3A
0BD2E:  MOVLB  0
0BD30:  CALL   1F60
0BD34:  MOVFF  1BD,A39
0BD38:  MOVLW  37
0BD3A:  MOVLB  A
0BD3C:  MOVWF  x3A
0BD3E:  MOVLB  0
0BD40:  CALL   1F60
0BD44:  MOVFF  1BC,A39
0BD48:  MOVLW  37
0BD4A:  MOVLB  A
0BD4C:  MOVWF  x3A
0BD4E:  MOVLB  0
0BD50:  CALL   1F60
0BD54:  MOVLW  CB
0BD56:  MOVWF  FF6
0BD58:  MOVLW  09
0BD5A:  MOVWF  FF7
0BD5C:  MOVLW  00
0BD5E:  MOVWF  FF8
0BD60:  MOVLW  05
0BD62:  MOVLB  3
0BD64:  MOVWF  x12
0BD66:  MOVLB  0
0BD68:  CALL   1D62
0BD6C:  MOVFF  1C3,A39
0BD70:  MOVLW  37
0BD72:  MOVLB  A
0BD74:  MOVWF  x3A
0BD76:  MOVLB  0
0BD78:  CALL   1F60
0BD7C:  MOVFF  1C2,A39
0BD80:  MOVLW  37
0BD82:  MOVLB  A
0BD84:  MOVWF  x3A
0BD86:  MOVLB  0
0BD88:  CALL   1F60
0BD8C:  MOVFF  1C1,A39
0BD90:  MOVLW  37
0BD92:  MOVLB  A
0BD94:  MOVWF  x3A
0BD96:  MOVLB  0
0BD98:  CALL   1F60
0BD9C:  MOVFF  1C0,A39
0BDA0:  MOVLW  37
0BDA2:  MOVLB  A
0BDA4:  MOVWF  x3A
0BDA6:  MOVLB  0
0BDA8:  CALL   1F60
0BDAC:  MOVLW  D3
0BDAE:  MOVWF  FF6
0BDB0:  MOVLW  09
0BDB2:  MOVWF  FF7
0BDB4:  MOVLW  00
0BDB6:  MOVWF  FF8
0BDB8:  MOVLW  03
0BDBA:  MOVLB  3
0BDBC:  MOVWF  x12
0BDBE:  MOVLB  0
0BDC0:  CALL   1D62
....................         return;
0BDC4:  GOTO   BF2A
....................     }
.................... 
....................     if ((erase_address + erase_size) > mission_type.end_address) {
0BDC8:  MOVLB  1
0BDCA:  MOVF   xC8,W
0BDCC:  ADDWF  xC4,W
0BDCE:  MOVWF  xCC
0BDD0:  MOVF   xC9,W
0BDD2:  ADDWFC xC5,W
0BDD4:  MOVWF  xCD
0BDD6:  MOVF   xCA,W
0BDD8:  ADDWFC xC6,W
0BDDA:  MOVWF  xCE
0BDDC:  MOVF   xCB,W
0BDDE:  ADDWFC xC7,W
0BDE0:  MOVWF  xCF
0BDE2:  MOVF   xC3,W
0BDE4:  SUBWF  xCF,W
0BDE6:  BTFSC  FD8.0
0BDE8:  BRA    BDF0
0BDEA:  MOVLB  0
0BDEC:  GOTO   BED6
0BDF0:  MOVLB  0
0BDF2:  BTFSS  FD8.2
0BDF4:  GOTO   BE3A
0BDF8:  MOVLB  1
0BDFA:  MOVF   xC2,W
0BDFC:  SUBWF  xCE,W
0BDFE:  BTFSC  FD8.0
0BE00:  BRA    BE08
0BE02:  MOVLB  0
0BE04:  GOTO   BED6
0BE08:  MOVLB  0
0BE0A:  BTFSS  FD8.2
0BE0C:  GOTO   BE3A
0BE10:  MOVLB  1
0BE12:  MOVF   xC1,W
0BE14:  SUBWF  xCD,W
0BE16:  BTFSC  FD8.0
0BE18:  BRA    BE20
0BE1A:  MOVLB  0
0BE1C:  GOTO   BED6
0BE20:  MOVLB  0
0BE22:  BTFSS  FD8.2
0BE24:  GOTO   BE3A
0BE28:  MOVLB  1
0BE2A:  MOVF   xCC,W
0BE2C:  SUBWF  xC0,W
0BE2E:  BTFSS  FD8.0
0BE30:  BRA    BE38
0BE32:  MOVLB  0
0BE34:  GOTO   BED6
0BE38:  MOVLB  0
....................         fprintf(PC, "Error: Erase operation would exceed mission end address 0x%LX\r\n", mission_type.end_address);
0BE3A:  MOVLW  D8
0BE3C:  MOVWF  FF6
0BE3E:  MOVLW  09
0BE40:  MOVWF  FF7
0BE42:  MOVLW  00
0BE44:  MOVWF  FF8
0BE46:  MOVLW  3A
0BE48:  MOVLB  3
0BE4A:  MOVWF  x12
0BE4C:  MOVLB  0
0BE4E:  CALL   1D62
0BE52:  MOVFF  1C3,A39
0BE56:  MOVLW  37
0BE58:  MOVLB  A
0BE5A:  MOVWF  x3A
0BE5C:  MOVLB  0
0BE5E:  CALL   1F60
0BE62:  MOVFF  1C2,A39
0BE66:  MOVLW  37
0BE68:  MOVLB  A
0BE6A:  MOVWF  x3A
0BE6C:  MOVLB  0
0BE6E:  CALL   1F60
0BE72:  MOVFF  1C1,A39
0BE76:  MOVLW  37
0BE78:  MOVLB  A
0BE7A:  MOVWF  x3A
0BE7C:  MOVLB  0
0BE7E:  CALL   1F60
0BE82:  MOVFF  1C0,A39
0BE86:  MOVLW  37
0BE88:  MOVLB  A
0BE8A:  MOVWF  x3A
0BE8C:  MOVLB  0
0BE8E:  CALL   1F60
0BE92:  MOVLW  0D
0BE94:  MOVLB  A
0BE96:  MOVWF  xDB
0BE98:  MOVLB  0
0BE9A:  CALL   1CE0
0BE9E:  MOVLW  0A
0BEA0:  MOVLB  A
0BEA2:  MOVWF  xDB
0BEA4:  MOVLB  0
0BEA6:  CALL   1CE0
....................         fprintf(PC, "Limiting erase size to stay within mission bounds\r\n");
0BEAA:  MOVLW  18
0BEAC:  MOVWF  FF6
0BEAE:  MOVLW  0A
0BEB0:  MOVWF  FF7
0BEB2:  MOVLW  00
0BEB4:  MOVWF  FF8
0BEB6:  CALL   1D32
....................         erase_size = mission_type.end_address - erase_address;
0BEBA:  MOVLB  1
0BEBC:  MOVF   xC4,W
0BEBE:  SUBWF  xC0,W
0BEC0:  MOVWF  xC8
0BEC2:  MOVF   xC5,W
0BEC4:  SUBWFB xC1,W
0BEC6:  MOVWF  xC9
0BEC8:  MOVF   xC6,W
0BECA:  SUBWFB xC2,W
0BECC:  MOVWF  xCA
0BECE:  MOVF   xC7,W
0BED0:  SUBWFB xC3,W
0BED2:  MOVWF  xCB
0BED4:  MOVLB  0
....................     }
.................... 
....................     fprintf(PC, "Erase operation validated within mission range\r\n");
0BED6:  MOVLW  4C
0BED8:  MOVWF  FF6
0BEDA:  MOVLW  0A
0BEDC:  MOVWF  FF7
0BEDE:  MOVLW  00
0BEE0:  MOVWF  FF8
0BEE2:  CALL   1D32
....................     subsector_4kByte_erase(smf, erase_address);
0BEE6:  MOVFF  115,314
0BEEA:  MOVFF  114,313
0BEEE:  MOVFF  113,312
0BEF2:  MOVFF  112,311
0BEF6:  MOVFF  1C7,318
0BEFA:  MOVFF  1C6,317
0BEFE:  MOVFF  1C5,316
0BF02:  MOVFF  1C4,315
0BF06:  CALL   56D4
.................... 
....................     fprintf(PC, "\r\n___End smf_erase____\r\n");
0BF0A:  MOVLW  7E
0BF0C:  MOVWF  FF6
0BF0E:  MOVLW  0A
0BF10:  MOVWF  FF7
0BF12:  MOVLW  00
0BF14:  MOVWF  FF8
0BF16:  CALL   1D32
....................     fprintf(PC, "____________________\r\n\r\n");
0BF1A:  MOVLW  98
0BF1C:  MOVWF  FF6
0BF1E:  MOVLW  0A
0BF20:  MOVWF  FF7
0BF22:  MOVLW  00
0BF24:  MOVWF  FF8
0BF26:  CALL   1D32
0BF2A:  GOTO   C172 (RETURN)
.................... }
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id)
.................... {
....................     switch(mission_id)
....................     {
....................         case 0x01:  // CIGS_MEASURE_DATA
....................             return &param.meas;
....................         case 0x02:  // CIGS_PICLOG
....................             return &param.piclog;
....................         default:
....................             fprintf(PC, "Error: Unknown mission_id: %02X\r\n", mission_id);
....................             return 0x00;  // NULL pointer
....................     }
.................... }
.................... 
.................... // mission_idに対応するパーティション情報を更新する関数
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter)
.................... {
....................     SMF_PARTITION* partition = get_smf_partition_by_mission_id(mission_id);
....................     if (partition != 0x00)
....................     {
....................         partition->used_size = used_size;
....................         partition->loop_counter = loop_counter;
....................         fprintf(PC, "Updated partition for mission_id %02X: used_size=%ld, loop_counter=%ld\r\n", 
....................                 mission_id, used_size, loop_counter);
....................     }
.................... }
.................... 
.................... // カウンター更新関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size)
.................... {
*
0AB68:  GOTO   B4D4 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Measurement: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_meas_uncopyed_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG  
....................             misf_piclog_uncopyed_counter += transfer_size;
....................             fprintf(PC, "MISF Counter Update - Piclog: +%ld, Total: %lu\r\n", 
....................                     transfer_size, misf_piclog_uncopyed_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter update\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター初期化関数
.................... void reset_misf_counters(int8 mission_id)
.................... {
*
0A9D6:  GOTO   B0B0 (RETURN)
....................     /*
....................     switch(mission_id)
....................     {
....................         case 0x01: // CIGS_MEASURE_DATA
....................             misf_meas_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_meas_uncopyed_counter\r\n");
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             misf_piclog_uncopyed_counter = 0;
....................             fprintf(PC, "Reset misf_piclog_uncopyed_counter\r\n");
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter reset\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... 
.................... // カウンター状態表示関数
.................... void print_misf_counter_status(int8 mission_id)
.................... {
....................     /*
....................     switch(mission_id)
....................     {
....................         
....................         case 0x01: // CIGS_MEASURE_DATA
....................             fprintf(PC, "MISF Measurement Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_meas_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_meas_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_meas_loop_counter);
....................             break;
....................             
....................         case 0x02: // CIGS_PICLOG
....................             fprintf(PC, "MISF Piclog Counters:\r\n");
....................             fprintf(PC, "  Use Counter: %lu\r\n", misf_piclog_use_counter);
....................             fprintf(PC, "  Uncopied Counter: %lu\r\n", misf_piclog_uncopyed_counter);
....................             fprintf(PC, "  Loop Counter: %u\r\n", misf_piclog_loop_counter);
....................             fprintf(PC, "  Write Counter: %u\r\n", misf_piclog_write_counter);
....................             break;
....................             
....................         default:
....................             fprintf(PC, "Warning: Unknown mission_id %02X for counter status\r\n", mission_id);
....................             break;
....................     }
....................     */
.................... }
.................... // End of file
.................... 
.................... #include "domain/mmj_cigs_flash.c"
.................... #include "mmj_cigs_flash.h"                           
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../hal/mmj_cigs_config.h"             
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/device/mt25q.h"                
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/tool/calc_tools.h"             
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... #include "../lib/tool/smf_queue.h"              
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... 
.................... // 実体宣言
.................... Flash_t data_table = {FLASH_ID_DATA_TABLE, 0, 0, 0};
.................... Flash_t piclog_data = {FLASH_ID_PICLOG, 0, 0, 0};
.................... Flash_t environment_data = {FLASH_ID_ENVIRONMENT, 0, 0, 0};
.................... Flash_t iv1_header = {FLASH_ID_IV1_HEADER, 0, 0, 0};
.................... Flash_t iv1_data = {FLASH_ID_IV1_DATA, 0, 0, 0};
.................... Flash_t iv2_header = {FLASH_ID_IV2_HEADER, 0, 0, 0};
.................... Flash_t iv2_data = {FLASH_ID_IV2_DATA, 0, 0, 0};
.................... 
.................... // ポインタ設定
.................... Flash_t *data_table_ptr = &data_table;
.................... Flash_t *piclog_data_ptr = &piclog_data;
.................... Flash_t *environment_data_ptr = &environment_data;
.................... Flash_t *iv1_header_ptr = &iv1_header;
.................... Flash_t *iv1_data_ptr = &iv1_data;
.................... Flash_t *iv2_header_ptr = &iv2_header;
.................... Flash_t *iv2_data_ptr = &iv2_data;
.................... 
.................... void misf_init()
.................... {
....................     fprintf(PC, "MISSION FLASH Initialize\r\n");
*
033BA:  MOVLW  1E
033BC:  MOVWF  FF6
033BE:  MOVLW  0B
033C0:  MOVWF  FF7
033C2:  MOVLW  00
033C4:  MOVWF  FF8
033C6:  CALL   1D32
....................     output_high(MIS_FM_CS);
033CA:  MOVLW  DB
033CC:  MOVWF  F92
033CE:  BSF    F89.5
....................     output_high(SMF_CS);
033D0:  MOVLW  DB
033D2:  MOVWF  F92
033D4:  BSF    F89.2
.................... 
....................     // 接続処理
....................     if (is_connect(mis_fm)) {
033D6:  MOVFF  111,292
033DA:  MOVFF  110,291
033DE:  MOVFF  10F,290
033E2:  MOVFF  10E,28F
033E6:  CALL   27F6
033EA:  MOVF   01,F
033EC:  BTFSC  FD8.2
033EE:  GOTO   3406
....................         fprintf(PC, "\t[MIS FM] Connected\r\n");
033F2:  MOVLW  3A
033F4:  MOVWF  FF6
033F6:  MOVLW  0B
033F8:  MOVWF  FF7
033FA:  MOVLW  00
033FC:  MOVWF  FF8
033FE:  CALL   1D32
....................     } else {
03402:  GOTO   3416
....................         fprintf(PC, "\t[MIS FM] Not Connected\r\n");
03406:  MOVLW  50
03408:  MOVWF  FF6
0340A:  MOVLW  0B
0340C:  MOVWF  FF7
0340E:  MOVLW  00
03410:  MOVWF  FF8
03412:  CALL   1D32
....................     }
....................     if (is_connect(smf)) {
03416:  MOVFF  115,292
0341A:  MOVFF  114,291
0341E:  MOVFF  113,290
03422:  MOVFF  112,28F
03426:  CALL   27F6
0342A:  MOVF   01,F
0342C:  BTFSC  FD8.2
0342E:  GOTO   3446
....................         fprintf(PC, "\t[SMF] Connected\r\n");
03432:  MOVLW  6A
03434:  MOVWF  FF6
03436:  MOVLW  0B
03438:  MOVWF  FF7
0343A:  MOVLW  00
0343C:  MOVWF  FF8
0343E:  CALL   1D32
....................     } else {
03442:  GOTO   3456
....................         fprintf(PC, "\t[SMF] Not Connected\r\n");
03446:  MOVLW  7E
03448:  MOVWF  FF6
0344A:  MOVLW  0B
0344C:  MOVWF  FF7
0344E:  MOVLW  00
03450:  MOVWF  FF8
03452:  CALL   1D32
....................     }
.................... 
....................     //=== MIS_FM カウンタテーブル読出し ===//
....................     FlashData_t read_header;
....................     FlashData_t *read_header_ptr = &read_header;
03456:  MOVLW  02
03458:  MOVLB  2
0345A:  MOVWF  x43
0345C:  MOVLW  02
0345E:  MOVWF  x42
....................     memset(read_header_ptr, 0x00, sizeof(FlashData_t));
03460:  MOVFF  243,FEA
03464:  MOVFF  242,FE9
03468:  CLRF   00
0346A:  CLRF   02
0346C:  MOVLW  40
0346E:  MOVWF  01
03470:  MOVLB  0
03472:  CALL   28BE
....................     read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, read_header_ptr->bytes, PACKET_SIZE);
03476:  MOVLB  2
03478:  MOVF   x42,W
0347A:  MOVWF  01
0347C:  MOVF   x43,W
0347E:  MOVWF  03
03480:  MOVF   01,W
03482:  MOVWF  x44
03484:  MOVFF  03,245
03488:  MOVFF  111,314
0348C:  MOVFF  110,313
03490:  MOVFF  10F,312
03494:  MOVFF  10E,311
03498:  MOVLB  3
0349A:  CLRF   x18
0349C:  CLRF   x17
0349E:  CLRF   x16
034A0:  CLRF   x15
034A2:  MOVFF  245,31A
034A6:  MOVFF  244,319
034AA:  CLRF   x1E
034AC:  CLRF   x1D
034AE:  CLRF   x1C
034B0:  MOVLW  40
034B2:  MOVWF  x1B
034B4:  MOVLB  0
034B6:  CALL   28E2
.................... 
....................     // CRC 検証
....................     if (read_header_ptr->packet.crc != calc_crc8(read_header_ptr->bytes, PACKET_SIZE - 1)) {
034BA:  MOVLW  3F
034BC:  MOVLB  2
034BE:  ADDWF  x42,W
034C0:  MOVWF  FE9
034C2:  MOVLW  00
034C4:  ADDWFC x43,W
034C6:  MOVWF  FEA
034C8:  MOVFF  FEF,244
034CC:  MOVF   x42,W
034CE:  MOVWF  01
034D0:  MOVF   x43,W
034D2:  MOVWF  03
034D4:  MOVF   01,W
034D6:  MOVWF  x45
034D8:  MOVFF  03,246
034DC:  MOVFF  246,ADC
034E0:  MOVFF  245,ADB
034E4:  MOVLW  3F
034E6:  MOVLB  A
034E8:  MOVWF  xDD
034EA:  MOVLB  0
034EC:  CALL   2AFA
034F0:  MOVF   01,W
034F2:  MOVLB  2
034F4:  SUBWF  x44,W
034F6:  BTFSS  FD8.2
034F8:  BRA    3500
034FA:  MOVLB  0
034FC:  GOTO   3512
03500:  MOVLB  0
....................         fprintf(PC, "\t[MIS FM] CRC error -> initialize counters\r\n");
03502:  MOVLW  96
03504:  MOVWF  FF6
03506:  MOVLW  0B
03508:  MOVWF  FF7
0350A:  MOVLW  00
0350C:  MOVWF  FF8
0350E:  CALL   1D32
....................         // デフォルト初期化
....................         /*
....................         piclog_data.id        = FLASH_ID_PICLOG;
....................         environment_data.id   = FLASH_ID_ENVIRONMENT;
....................         iv_header.id          = FLASH_ID_IV_HEADER;
....................         iv_data.id            = FLASH_ID_IV_DATA;
....................         piclog_data.used_counter = 0;
....................         piclog_data.uncopied_counter = 0;
....................         environment_data.used_counter = 0;
....................         environment_data.uncopied_counter = 0;
....................         iv_header.used_counter = 0;
....................         iv_header.uncopied_counter = 0;
....................         iv_data.used_counter = 0;
....................         iv_data.uncopied_counter = 0;
....................         write_misf_address_area();   // 初期テーブル書込み
....................         print_flash_status();
....................         return;
....................         */
....................     }
....................     //=== 個別コピー (キャスト禁止) ===//
....................     // PICLOG
....................     piclog_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.piclog.used_counter;
03512:  MOVLW  01
03514:  MOVLB  1
03516:  ADDWF  x20,W
03518:  MOVWF  01
0351A:  MOVLW  00
0351C:  ADDWFC x21,W
0351E:  MOVWF  03
03520:  MOVF   01,W
03522:  MOVLB  2
03524:  MOVWF  x44
03526:  MOVFF  03,245
0352A:  MOVF   x42,W
0352C:  MOVWF  FE9
0352E:  MOVF   x43,W
03530:  MOVWF  FEA
03532:  MOVFF  FEF,00
03536:  MOVFF  FEC,01
0353A:  MOVFF  FEC,02
0353E:  MOVFF  FEC,03
03542:  MOVF   FED,F
03544:  MOVF   FED,F
03546:  MOVF   FED,F
03548:  MOVFF  03,249
0354C:  MOVFF  02,248
03550:  MOVFF  01,247
03554:  MOVFF  00,246
03558:  MOVFF  245,FEA
0355C:  MOVFF  244,FE9
03560:  MOVFF  246,FEF
03564:  MOVFF  247,FEC
03568:  MOVFF  248,FEC
0356C:  MOVFF  249,FEC
03570:  MOVF   FED,F
03572:  MOVF   FED,F
03574:  MOVF   FED,F
....................     piclog_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.piclog.uncopied_counter;
03576:  MOVLW  05
03578:  MOVLB  1
0357A:  ADDWF  x20,W
0357C:  MOVWF  01
0357E:  MOVLW  00
03580:  ADDWFC x21,W
03582:  MOVWF  03
03584:  MOVF   01,W
03586:  MOVLB  2
03588:  MOVWF  x44
0358A:  MOVFF  03,245
0358E:  MOVLW  04
03590:  ADDWF  x42,W
03592:  MOVWF  FE9
03594:  MOVLW  00
03596:  ADDWFC x43,W
03598:  MOVWF  FEA
0359A:  MOVFF  FEF,00
0359E:  MOVFF  FEC,01
035A2:  MOVFF  FEC,02
035A6:  MOVFF  FEC,03
035AA:  MOVF   FED,F
035AC:  MOVF   FED,F
035AE:  MOVF   FED,F
035B0:  MOVFF  03,249
035B4:  MOVFF  02,248
035B8:  MOVFF  01,247
035BC:  MOVFF  00,246
035C0:  MOVFF  245,FEA
035C4:  MOVFF  244,FE9
035C8:  MOVFF  246,FEF
035CC:  MOVFF  247,FEC
035D0:  MOVFF  248,FEC
035D4:  MOVFF  249,FEC
035D8:  MOVF   FED,F
035DA:  MOVF   FED,F
035DC:  MOVF   FED,F
....................     piclog_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.piclog.reserve_counter1;
035DE:  MOVLW  09
035E0:  MOVLB  1
035E2:  ADDWF  x20,W
035E4:  MOVWF  01
035E6:  MOVLW  00
035E8:  ADDWFC x21,W
035EA:  MOVWF  03
035EC:  MOVF   01,W
035EE:  MOVLB  2
035F0:  MOVWF  x44
035F2:  MOVFF  03,245
035F6:  MOVLW  08
035F8:  ADDWF  x42,W
035FA:  MOVWF  FE9
035FC:  MOVLW  00
035FE:  ADDWFC x43,W
03600:  MOVWF  FEA
03602:  MOVF   FEF,W
03604:  MOVWF  x46
03606:  MOVFF  245,FEA
0360A:  MOVFF  244,FE9
0360E:  MOVFF  246,FEF
....................     piclog_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.piclog.reserve_counter2;
03612:  MOVLW  0A
03614:  MOVLB  1
03616:  ADDWF  x20,W
03618:  MOVWF  01
0361A:  MOVLW  00
0361C:  ADDWFC x21,W
0361E:  MOVWF  03
03620:  MOVF   01,W
03622:  MOVLB  2
03624:  MOVWF  x44
03626:  MOVFF  03,245
0362A:  MOVLW  09
0362C:  ADDWF  x42,W
0362E:  MOVWF  FE9
03630:  MOVLW  00
03632:  ADDWFC x43,W
03634:  MOVWF  FEA
03636:  MOVF   FEF,W
03638:  MOVWF  x46
0363A:  MOVFF  245,FEA
0363E:  MOVFF  244,FE9
03642:  MOVFF  246,FEF
....................     // 環境データ
....................     environment_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.environment.used_counter;
03646:  MOVLW  01
03648:  MOVLB  1
0364A:  ADDWF  x22,W
0364C:  MOVWF  01
0364E:  MOVLW  00
03650:  ADDWFC x23,W
03652:  MOVWF  03
03654:  MOVF   01,W
03656:  MOVLB  2
03658:  MOVWF  x44
0365A:  MOVFF  03,245
0365E:  MOVLW  0A
03660:  ADDWF  x42,W
03662:  MOVWF  FE9
03664:  MOVLW  00
03666:  ADDWFC x43,W
03668:  MOVWF  FEA
0366A:  MOVFF  FEF,00
0366E:  MOVFF  FEC,01
03672:  MOVFF  FEC,02
03676:  MOVFF  FEC,03
0367A:  MOVF   FED,F
0367C:  MOVF   FED,F
0367E:  MOVF   FED,F
03680:  MOVFF  03,249
03684:  MOVFF  02,248
03688:  MOVFF  01,247
0368C:  MOVFF  00,246
03690:  MOVFF  245,FEA
03694:  MOVFF  244,FE9
03698:  MOVFF  246,FEF
0369C:  MOVFF  247,FEC
036A0:  MOVFF  248,FEC
036A4:  MOVFF  249,FEC
036A8:  MOVF   FED,F
036AA:  MOVF   FED,F
036AC:  MOVF   FED,F
....................     environment_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.environment.uncopied_counter;
036AE:  MOVLW  05
036B0:  MOVLB  1
036B2:  ADDWF  x22,W
036B4:  MOVWF  01
036B6:  MOVLW  00
036B8:  ADDWFC x23,W
036BA:  MOVWF  03
036BC:  MOVF   01,W
036BE:  MOVLB  2
036C0:  MOVWF  x44
036C2:  MOVFF  03,245
036C6:  MOVLW  0E
036C8:  ADDWF  x42,W
036CA:  MOVWF  FE9
036CC:  MOVLW  00
036CE:  ADDWFC x43,W
036D0:  MOVWF  FEA
036D2:  MOVFF  FEF,00
036D6:  MOVFF  FEC,01
036DA:  MOVFF  FEC,02
036DE:  MOVFF  FEC,03
036E2:  MOVF   FED,F
036E4:  MOVF   FED,F
036E6:  MOVF   FED,F
036E8:  MOVFF  03,249
036EC:  MOVFF  02,248
036F0:  MOVFF  01,247
036F4:  MOVFF  00,246
036F8:  MOVFF  245,FEA
036FC:  MOVFF  244,FE9
03700:  MOVFF  246,FEF
03704:  MOVFF  247,FEC
03708:  MOVFF  248,FEC
0370C:  MOVFF  249,FEC
03710:  MOVF   FED,F
03712:  MOVF   FED,F
03714:  MOVF   FED,F
....................     environment_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.environment.reserve_counter1;
03716:  MOVLW  09
03718:  MOVLB  1
0371A:  ADDWF  x22,W
0371C:  MOVWF  01
0371E:  MOVLW  00
03720:  ADDWFC x23,W
03722:  MOVWF  03
03724:  MOVF   01,W
03726:  MOVLB  2
03728:  MOVWF  x44
0372A:  MOVFF  03,245
0372E:  MOVLW  12
03730:  ADDWF  x42,W
03732:  MOVWF  FE9
03734:  MOVLW  00
03736:  ADDWFC x43,W
03738:  MOVWF  FEA
0373A:  MOVF   FEF,W
0373C:  MOVWF  x46
0373E:  MOVFF  245,FEA
03742:  MOVFF  244,FE9
03746:  MOVFF  246,FEF
....................     environment_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.environment.reserve_counter2;
0374A:  MOVLW  0A
0374C:  MOVLB  1
0374E:  ADDWF  x22,W
03750:  MOVWF  01
03752:  MOVLW  00
03754:  ADDWFC x23,W
03756:  MOVWF  03
03758:  MOVF   01,W
0375A:  MOVLB  2
0375C:  MOVWF  x44
0375E:  MOVFF  03,245
03762:  MOVLW  13
03764:  ADDWF  x42,W
03766:  MOVWF  FE9
03768:  MOVLW  00
0376A:  ADDWFC x43,W
0376C:  MOVWF  FEA
0376E:  MOVF   FEF,W
03770:  MOVWF  x46
03772:  MOVFF  245,FEA
03776:  MOVFF  244,FE9
0377A:  MOVFF  246,FEF
....................     // IV1 ヘッダ
....................     iv1_header_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv1_header.used_counter;
0377E:  MOVLW  01
03780:  MOVLB  1
03782:  ADDWF  x24,W
03784:  MOVWF  01
03786:  MOVLW  00
03788:  ADDWFC x25,W
0378A:  MOVWF  03
0378C:  MOVF   01,W
0378E:  MOVLB  2
03790:  MOVWF  x44
03792:  MOVFF  03,245
03796:  MOVLW  14
03798:  ADDWF  x42,W
0379A:  MOVWF  FE9
0379C:  MOVLW  00
0379E:  ADDWFC x43,W
037A0:  MOVWF  FEA
037A2:  MOVFF  FEF,00
037A6:  MOVFF  FEC,01
037AA:  MOVFF  FEC,02
037AE:  MOVFF  FEC,03
037B2:  MOVF   FED,F
037B4:  MOVF   FED,F
037B6:  MOVF   FED,F
037B8:  MOVFF  03,249
037BC:  MOVFF  02,248
037C0:  MOVFF  01,247
037C4:  MOVFF  00,246
037C8:  MOVFF  245,FEA
037CC:  MOVFF  244,FE9
037D0:  MOVFF  246,FEF
037D4:  MOVFF  247,FEC
037D8:  MOVFF  248,FEC
037DC:  MOVFF  249,FEC
037E0:  MOVF   FED,F
037E2:  MOVF   FED,F
037E4:  MOVF   FED,F
....................     iv1_header_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv1_header.uncopied_counter;
037E6:  MOVLW  05
037E8:  MOVLB  1
037EA:  ADDWF  x24,W
037EC:  MOVWF  01
037EE:  MOVLW  00
037F0:  ADDWFC x25,W
037F2:  MOVWF  03
037F4:  MOVF   01,W
037F6:  MOVLB  2
037F8:  MOVWF  x44
037FA:  MOVFF  03,245
037FE:  MOVLW  18
03800:  ADDWF  x42,W
03802:  MOVWF  FE9
03804:  MOVLW  00
03806:  ADDWFC x43,W
03808:  MOVWF  FEA
0380A:  MOVFF  FEF,00
0380E:  MOVFF  FEC,01
03812:  MOVFF  FEC,02
03816:  MOVFF  FEC,03
0381A:  MOVF   FED,F
0381C:  MOVF   FED,F
0381E:  MOVF   FED,F
03820:  MOVFF  03,249
03824:  MOVFF  02,248
03828:  MOVFF  01,247
0382C:  MOVFF  00,246
03830:  MOVFF  245,FEA
03834:  MOVFF  244,FE9
03838:  MOVFF  246,FEF
0383C:  MOVFF  247,FEC
03840:  MOVFF  248,FEC
03844:  MOVFF  249,FEC
03848:  MOVF   FED,F
0384A:  MOVF   FED,F
0384C:  MOVF   FED,F
....................     iv1_header_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv1_header.reserve_counter1;
0384E:  MOVLW  09
03850:  MOVLB  1
03852:  ADDWF  x24,W
03854:  MOVWF  01
03856:  MOVLW  00
03858:  ADDWFC x25,W
0385A:  MOVWF  03
0385C:  MOVF   01,W
0385E:  MOVLB  2
03860:  MOVWF  x44
03862:  MOVFF  03,245
03866:  MOVLW  1C
03868:  ADDWF  x42,W
0386A:  MOVWF  FE9
0386C:  MOVLW  00
0386E:  ADDWFC x43,W
03870:  MOVWF  FEA
03872:  MOVF   FEF,W
03874:  MOVWF  x46
03876:  MOVFF  245,FEA
0387A:  MOVFF  244,FE9
0387E:  MOVFF  246,FEF
....................     iv1_header_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv1_header.reserve_counter2;
03882:  MOVLW  0A
03884:  MOVLB  1
03886:  ADDWF  x24,W
03888:  MOVWF  01
0388A:  MOVLW  00
0388C:  ADDWFC x25,W
0388E:  MOVWF  03
03890:  MOVF   01,W
03892:  MOVLB  2
03894:  MOVWF  x44
03896:  MOVFF  03,245
0389A:  MOVLW  1D
0389C:  ADDWF  x42,W
0389E:  MOVWF  FE9
038A0:  MOVLW  00
038A2:  ADDWFC x43,W
038A4:  MOVWF  FEA
038A6:  MOVF   FEF,W
038A8:  MOVWF  x46
038AA:  MOVFF  245,FEA
038AE:  MOVFF  244,FE9
038B2:  MOVFF  246,FEF
....................     // IV1 データ
....................     iv1_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv1_data.used_counter;
038B6:  MOVLW  01
038B8:  MOVLB  1
038BA:  ADDWF  x26,W
038BC:  MOVWF  01
038BE:  MOVLW  00
038C0:  ADDWFC x27,W
038C2:  MOVWF  03
038C4:  MOVF   01,W
038C6:  MOVLB  2
038C8:  MOVWF  x44
038CA:  MOVFF  03,245
038CE:  MOVLW  1E
038D0:  ADDWF  x42,W
038D2:  MOVWF  FE9
038D4:  MOVLW  00
038D6:  ADDWFC x43,W
038D8:  MOVWF  FEA
038DA:  MOVFF  FEF,00
038DE:  MOVFF  FEC,01
038E2:  MOVFF  FEC,02
038E6:  MOVFF  FEC,03
038EA:  MOVF   FED,F
038EC:  MOVF   FED,F
038EE:  MOVF   FED,F
038F0:  MOVFF  03,249
038F4:  MOVFF  02,248
038F8:  MOVFF  01,247
038FC:  MOVFF  00,246
03900:  MOVFF  245,FEA
03904:  MOVFF  244,FE9
03908:  MOVFF  246,FEF
0390C:  MOVFF  247,FEC
03910:  MOVFF  248,FEC
03914:  MOVFF  249,FEC
03918:  MOVF   FED,F
0391A:  MOVF   FED,F
0391C:  MOVF   FED,F
....................     iv1_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv1_data.uncopied_counter;
0391E:  MOVLW  05
03920:  MOVLB  1
03922:  ADDWF  x26,W
03924:  MOVWF  01
03926:  MOVLW  00
03928:  ADDWFC x27,W
0392A:  MOVWF  03
0392C:  MOVF   01,W
0392E:  MOVLB  2
03930:  MOVWF  x44
03932:  MOVFF  03,245
03936:  MOVLW  22
03938:  ADDWF  x42,W
0393A:  MOVWF  FE9
0393C:  MOVLW  00
0393E:  ADDWFC x43,W
03940:  MOVWF  FEA
03942:  MOVFF  FEF,00
03946:  MOVFF  FEC,01
0394A:  MOVFF  FEC,02
0394E:  MOVFF  FEC,03
03952:  MOVF   FED,F
03954:  MOVF   FED,F
03956:  MOVF   FED,F
03958:  MOVFF  03,249
0395C:  MOVFF  02,248
03960:  MOVFF  01,247
03964:  MOVFF  00,246
03968:  MOVFF  245,FEA
0396C:  MOVFF  244,FE9
03970:  MOVFF  246,FEF
03974:  MOVFF  247,FEC
03978:  MOVFF  248,FEC
0397C:  MOVFF  249,FEC
03980:  MOVF   FED,F
03982:  MOVF   FED,F
03984:  MOVF   FED,F
....................     iv1_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv1_data.reserve_counter1;
03986:  MOVLW  09
03988:  MOVLB  1
0398A:  ADDWF  x26,W
0398C:  MOVWF  01
0398E:  MOVLW  00
03990:  ADDWFC x27,W
03992:  MOVWF  03
03994:  MOVF   01,W
03996:  MOVLB  2
03998:  MOVWF  x44
0399A:  MOVFF  03,245
0399E:  MOVLW  26
039A0:  ADDWF  x42,W
039A2:  MOVWF  FE9
039A4:  MOVLW  00
039A6:  ADDWFC x43,W
039A8:  MOVWF  FEA
039AA:  MOVF   FEF,W
039AC:  MOVWF  x46
039AE:  MOVFF  245,FEA
039B2:  MOVFF  244,FE9
039B6:  MOVFF  246,FEF
....................     iv1_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv1_data.reserve_counter2;
039BA:  MOVLW  0A
039BC:  MOVLB  1
039BE:  ADDWF  x26,W
039C0:  MOVWF  01
039C2:  MOVLW  00
039C4:  ADDWFC x27,W
039C6:  MOVWF  03
039C8:  MOVF   01,W
039CA:  MOVLB  2
039CC:  MOVWF  x44
039CE:  MOVFF  03,245
039D2:  MOVLW  27
039D4:  ADDWF  x42,W
039D6:  MOVWF  FE9
039D8:  MOVLW  00
039DA:  ADDWFC x43,W
039DC:  MOVWF  FEA
039DE:  MOVF   FEF,W
039E0:  MOVWF  x46
039E2:  MOVFF  245,FEA
039E6:  MOVFF  244,FE9
039EA:  MOVFF  246,FEF
....................     // IV2 ヘッダ
....................     iv2_header_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv2_header.used_counter;
039EE:  MOVLW  01
039F0:  MOVLB  1
039F2:  ADDWF  x28,W
039F4:  MOVWF  01
039F6:  MOVLW  00
039F8:  ADDWFC x29,W
039FA:  MOVWF  03
039FC:  MOVF   01,W
039FE:  MOVLB  2
03A00:  MOVWF  x44
03A02:  MOVFF  03,245
03A06:  MOVLW  28
03A08:  ADDWF  x42,W
03A0A:  MOVWF  FE9
03A0C:  MOVLW  00
03A0E:  ADDWFC x43,W
03A10:  MOVWF  FEA
03A12:  MOVFF  FEF,00
03A16:  MOVFF  FEC,01
03A1A:  MOVFF  FEC,02
03A1E:  MOVFF  FEC,03
03A22:  MOVF   FED,F
03A24:  MOVF   FED,F
03A26:  MOVF   FED,F
03A28:  MOVFF  03,249
03A2C:  MOVFF  02,248
03A30:  MOVFF  01,247
03A34:  MOVFF  00,246
03A38:  MOVFF  245,FEA
03A3C:  MOVFF  244,FE9
03A40:  MOVFF  246,FEF
03A44:  MOVFF  247,FEC
03A48:  MOVFF  248,FEC
03A4C:  MOVFF  249,FEC
03A50:  MOVF   FED,F
03A52:  MOVF   FED,F
03A54:  MOVF   FED,F
....................     iv2_header_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv2_header.uncopied_counter;
03A56:  MOVLW  05
03A58:  MOVLB  1
03A5A:  ADDWF  x28,W
03A5C:  MOVWF  01
03A5E:  MOVLW  00
03A60:  ADDWFC x29,W
03A62:  MOVWF  03
03A64:  MOVF   01,W
03A66:  MOVLB  2
03A68:  MOVWF  x44
03A6A:  MOVFF  03,245
03A6E:  MOVLW  2C
03A70:  ADDWF  x42,W
03A72:  MOVWF  FE9
03A74:  MOVLW  00
03A76:  ADDWFC x43,W
03A78:  MOVWF  FEA
03A7A:  MOVFF  FEF,00
03A7E:  MOVFF  FEC,01
03A82:  MOVFF  FEC,02
03A86:  MOVFF  FEC,03
03A8A:  MOVF   FED,F
03A8C:  MOVF   FED,F
03A8E:  MOVF   FED,F
03A90:  MOVFF  03,249
03A94:  MOVFF  02,248
03A98:  MOVFF  01,247
03A9C:  MOVFF  00,246
03AA0:  MOVFF  245,FEA
03AA4:  MOVFF  244,FE9
03AA8:  MOVFF  246,FEF
03AAC:  MOVFF  247,FEC
03AB0:  MOVFF  248,FEC
03AB4:  MOVFF  249,FEC
03AB8:  MOVF   FED,F
03ABA:  MOVF   FED,F
03ABC:  MOVF   FED,F
....................     iv2_header_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv2_header.reserve_counter1;
03ABE:  MOVLW  09
03AC0:  MOVLB  1
03AC2:  ADDWF  x28,W
03AC4:  MOVWF  01
03AC6:  MOVLW  00
03AC8:  ADDWFC x29,W
03ACA:  MOVWF  03
03ACC:  MOVF   01,W
03ACE:  MOVLB  2
03AD0:  MOVWF  x44
03AD2:  MOVFF  03,245
03AD6:  MOVLW  30
03AD8:  ADDWF  x42,W
03ADA:  MOVWF  FE9
03ADC:  MOVLW  00
03ADE:  ADDWFC x43,W
03AE0:  MOVWF  FEA
03AE2:  MOVF   FEF,W
03AE4:  MOVWF  x46
03AE6:  MOVFF  245,FEA
03AEA:  MOVFF  244,FE9
03AEE:  MOVFF  246,FEF
....................     iv2_header_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv2_header.reserve_counter2;
03AF2:  MOVLW  0A
03AF4:  MOVLB  1
03AF6:  ADDWF  x28,W
03AF8:  MOVWF  01
03AFA:  MOVLW  00
03AFC:  ADDWFC x29,W
03AFE:  MOVWF  03
03B00:  MOVF   01,W
03B02:  MOVLB  2
03B04:  MOVWF  x44
03B06:  MOVFF  03,245
03B0A:  MOVLW  31
03B0C:  ADDWF  x42,W
03B0E:  MOVWF  FE9
03B10:  MOVLW  00
03B12:  ADDWFC x43,W
03B14:  MOVWF  FEA
03B16:  MOVF   FEF,W
03B18:  MOVWF  x46
03B1A:  MOVFF  245,FEA
03B1E:  MOVFF  244,FE9
03B22:  MOVFF  246,FEF
....................     // IV2 データ
....................     iv2_data_ptr->used_counter     = read_header_ptr->packet.payload.logdata.iv2_data.used_counter;
03B26:  MOVLW  01
03B28:  MOVLB  1
03B2A:  ADDWF  x2A,W
03B2C:  MOVWF  01
03B2E:  MOVLW  00
03B30:  ADDWFC x2B,W
03B32:  MOVWF  03
03B34:  MOVF   01,W
03B36:  MOVLB  2
03B38:  MOVWF  x44
03B3A:  MOVFF  03,245
03B3E:  MOVLW  32
03B40:  ADDWF  x42,W
03B42:  MOVWF  FE9
03B44:  MOVLW  00
03B46:  ADDWFC x43,W
03B48:  MOVWF  FEA
03B4A:  MOVFF  FEF,00
03B4E:  MOVFF  FEC,01
03B52:  MOVFF  FEC,02
03B56:  MOVFF  FEC,03
03B5A:  MOVF   FED,F
03B5C:  MOVF   FED,F
03B5E:  MOVF   FED,F
03B60:  MOVFF  03,249
03B64:  MOVFF  02,248
03B68:  MOVFF  01,247
03B6C:  MOVFF  00,246
03B70:  MOVFF  245,FEA
03B74:  MOVFF  244,FE9
03B78:  MOVFF  246,FEF
03B7C:  MOVFF  247,FEC
03B80:  MOVFF  248,FEC
03B84:  MOVFF  249,FEC
03B88:  MOVF   FED,F
03B8A:  MOVF   FED,F
03B8C:  MOVF   FED,F
....................     iv2_data_ptr->uncopied_counter = read_header_ptr->packet.payload.logdata.iv2_data.uncopied_counter;
03B8E:  MOVLW  05
03B90:  MOVLB  1
03B92:  ADDWF  x2A,W
03B94:  MOVWF  01
03B96:  MOVLW  00
03B98:  ADDWFC x2B,W
03B9A:  MOVWF  03
03B9C:  MOVF   01,W
03B9E:  MOVLB  2
03BA0:  MOVWF  x44
03BA2:  MOVFF  03,245
03BA6:  MOVLW  36
03BA8:  ADDWF  x42,W
03BAA:  MOVWF  FE9
03BAC:  MOVLW  00
03BAE:  ADDWFC x43,W
03BB0:  MOVWF  FEA
03BB2:  MOVFF  FEF,00
03BB6:  MOVFF  FEC,01
03BBA:  MOVFF  FEC,02
03BBE:  MOVFF  FEC,03
03BC2:  MOVF   FED,F
03BC4:  MOVF   FED,F
03BC6:  MOVF   FED,F
03BC8:  MOVFF  03,249
03BCC:  MOVFF  02,248
03BD0:  MOVFF  01,247
03BD4:  MOVFF  00,246
03BD8:  MOVFF  245,FEA
03BDC:  MOVFF  244,FE9
03BE0:  MOVFF  246,FEF
03BE4:  MOVFF  247,FEC
03BE8:  MOVFF  248,FEC
03BEC:  MOVFF  249,FEC
03BF0:  MOVF   FED,F
03BF2:  MOVF   FED,F
03BF4:  MOVF   FED,F
....................     iv2_data_ptr->reserve_counter1 = read_header_ptr->packet.payload.logdata.iv2_data.reserve_counter1;
03BF6:  MOVLW  09
03BF8:  MOVLB  1
03BFA:  ADDWF  x2A,W
03BFC:  MOVWF  01
03BFE:  MOVLW  00
03C00:  ADDWFC x2B,W
03C02:  MOVWF  03
03C04:  MOVF   01,W
03C06:  MOVLB  2
03C08:  MOVWF  x44
03C0A:  MOVFF  03,245
03C0E:  MOVLW  3A
03C10:  ADDWF  x42,W
03C12:  MOVWF  FE9
03C14:  MOVLW  00
03C16:  ADDWFC x43,W
03C18:  MOVWF  FEA
03C1A:  MOVF   FEF,W
03C1C:  MOVWF  x46
03C1E:  MOVFF  245,FEA
03C22:  MOVFF  244,FE9
03C26:  MOVFF  246,FEF
....................     iv2_data_ptr->reserve_counter2 = read_header_ptr->packet.payload.logdata.iv2_data.reserve_counter2;
03C2A:  MOVLW  0A
03C2C:  MOVLB  1
03C2E:  ADDWF  x2A,W
03C30:  MOVWF  01
03C32:  MOVLW  00
03C34:  ADDWFC x2B,W
03C36:  MOVWF  03
03C38:  MOVF   01,W
03C3A:  MOVLB  2
03C3C:  MOVWF  x44
03C3E:  MOVFF  03,245
03C42:  MOVLW  3B
03C44:  ADDWF  x42,W
03C46:  MOVWF  FE9
03C48:  MOVLW  00
03C4A:  ADDWFC x43,W
03C4C:  MOVWF  FEA
03C4E:  MOVF   FEF,W
03C50:  MOVWF  x46
03C52:  MOVFF  245,FEA
03C56:  MOVFF  244,FE9
03C5A:  MOVFF  246,FEF
....................     
....................     print_flash_status();
03C5E:  MOVLB  0
03C60:  GOTO   2B66
03C64:  RETURN 0
.................... }
.................... 
.................... FlashData_t make_flash_data_table()
*
04308:  MOVLW  0A
0430A:  MOVLB  A
0430C:  MOVWF  xC1
0430E:  MOVLW  80
04310:  MOVWF  xC0
.................... {
....................     FlashData_t flash_data;
....................     FlashData_t *flash_data_ptr = &flash_data;
....................     memset(flash_data_ptr->bytes, 0, sizeof(flash_data_ptr->bytes));
04312:  MOVF   xC0,W
04314:  MOVWF  01
04316:  MOVF   xC1,W
04318:  MOVWF  03
0431A:  MOVF   01,W
0431C:  MOVWF  xDB
0431E:  MOVFF  03,ADC
04322:  MOVFF  ADC,FEA
04326:  MOVFF  ADB,FE9
0432A:  CLRF   00
0432C:  CLRF   02
0432E:  MOVLW  40
04330:  MOVWF  01
04332:  MOVLB  0
04334:  CALL   28BE
.................... 
....................     FlashCounter_t *dst_list[] = {
....................         &flash_data.packet.payload.logdata.piclog,
....................         &flash_data.packet.payload.logdata.environment,
....................         &flash_data.packet.payload.logdata.iv1_header,
....................         &flash_data.packet.payload.logdata.iv1_data,
....................         &flash_data.packet.payload.logdata.iv2_header,
....................         &flash_data.packet.payload.logdata.iv2_data
....................     };
04338:  MOVLW  0A
0433A:  MOVLB  A
0433C:  MOVWF  xC3
0433E:  MOVLW  80
04340:  MOVWF  xC2
04342:  MOVLW  0A
04344:  MOVWF  xC5
04346:  MOVLW  8A
04348:  MOVWF  xC4
0434A:  MOVLW  0A
0434C:  MOVWF  xC7
0434E:  MOVLW  94
04350:  MOVWF  xC6
04352:  MOVLW  0A
04354:  MOVWF  xC9
04356:  MOVLW  9E
04358:  MOVWF  xC8
0435A:  MOVLW  0A
0435C:  MOVWF  xCB
0435E:  MOVLW  A8
04360:  MOVWF  xCA
04362:  MOVLW  0A
04364:  MOVWF  xCD
04366:  MOVLW  B2
04368:  MOVWF  xCC
....................     Flash_t *src_list[] = {
....................         &piclog_data,
....................         &environment_data,
....................         &iv1_header,
....................         &iv1_data,
....................         &iv2_header,
....................         &iv2_data
....................     };
0436A:  MOVLW  01
0436C:  MOVWF  xCF
0436E:  MOVLW  64
04370:  MOVWF  xCE
04372:  MOVLW  01
04374:  MOVWF  xD1
04376:  MOVLW  6F
04378:  MOVWF  xD0
0437A:  MOVLW  01
0437C:  MOVWF  xD3
0437E:  MOVLW  7A
04380:  MOVWF  xD2
04382:  MOVLW  01
04384:  MOVWF  xD5
04386:  MOVLW  85
04388:  MOVWF  xD4
0438A:  MOVLW  01
0438C:  MOVWF  xD7
0438E:  MOVLW  90
04390:  MOVWF  xD6
04392:  MOVLW  01
04394:  MOVWF  xD9
04396:  MOVLW  9B
04398:  MOVWF  xD8
.................... 
....................     for (int i = 0; i < FLASH_ID_COUNT; i++) {
0439A:  CLRF   xDA
0439C:  MOVLB  0
0439E:  MOVLB  A
043A0:  MOVF   xDA,W
043A2:  SUBLW  06
043A4:  BTFSC  FD8.0
043A6:  BRA    43AE
043A8:  MOVLB  0
043AA:  GOTO   4662
043AE:  MOVLB  0
....................         dst_list[i]->used_counter     = src_list[i]->used_counter;
043B0:  CLRF   03
043B2:  MOVLB  A
043B4:  MOVF   xDA,W
043B6:  MOVWF  02
043B8:  BCF    FD8.0
043BA:  RLCF   02,F
043BC:  RLCF   03,F
043BE:  MOVF   02,W
043C0:  ADDLW  C2
043C2:  MOVWF  01
043C4:  MOVLW  0A
043C6:  ADDWFC 03,F
043C8:  MOVF   01,W
043CA:  MOVWF  xDB
043CC:  MOVFF  03,ADC
043D0:  MOVFF  ADC,FEA
043D4:  MOVFF  ADB,FE9
043D8:  MOVFF  FEC,ADE
043DC:  MOVF   FED,F
043DE:  MOVFF  FEF,ADD
043E2:  MOVF   xDD,W
043E4:  MOVWF  01
043E6:  MOVF   xDE,W
043E8:  MOVWF  03
043EA:  MOVF   01,W
043EC:  MOVWF  xDF
043EE:  MOVFF  03,AE0
043F2:  CLRF   03
043F4:  MOVF   xDA,W
043F6:  MOVWF  02
043F8:  BCF    FD8.0
043FA:  RLCF   02,F
043FC:  RLCF   03,F
043FE:  MOVF   02,W
04400:  ADDLW  CE
04402:  MOVWF  01
04404:  MOVLW  0A
04406:  ADDWFC 03,F
04408:  MOVF   01,W
0440A:  MOVWF  xE1
0440C:  MOVFF  03,AE2
04410:  MOVFF  AE2,FEA
04414:  MOVFF  AE1,FE9
04418:  MOVFF  FEC,AE4
0441C:  MOVF   FED,F
0441E:  MOVFF  FEF,AE3
04422:  MOVLW  01
04424:  ADDWF  xE3,W
04426:  MOVWF  FE9
04428:  MOVLW  00
0442A:  ADDWFC xE4,W
0442C:  MOVWF  FEA
0442E:  MOVFF  FEF,00
04432:  MOVFF  FEC,01
04436:  MOVFF  FEC,02
0443A:  MOVFF  FEC,03
0443E:  MOVF   FED,F
04440:  MOVF   FED,F
04442:  MOVF   FED,F
04444:  MOVFF  03,AE8
04448:  MOVFF  02,AE7
0444C:  MOVFF  01,AE6
04450:  MOVFF  00,AE5
04454:  MOVFF  AE0,FEA
04458:  MOVFF  ADF,FE9
0445C:  MOVFF  AE5,FEF
04460:  MOVFF  AE6,FEC
04464:  MOVFF  AE7,FEC
04468:  MOVFF  AE8,FEC
0446C:  MOVF   FED,F
0446E:  MOVF   FED,F
04470:  MOVF   FED,F
....................         dst_list[i]->uncopied_counter = src_list[i]->uncopied_counter;
04472:  CLRF   03
04474:  MOVF   xDA,W
04476:  MOVWF  02
04478:  BCF    FD8.0
0447A:  RLCF   02,F
0447C:  RLCF   03,F
0447E:  MOVF   02,W
04480:  ADDLW  C2
04482:  MOVWF  01
04484:  MOVLW  0A
04486:  ADDWFC 03,F
04488:  MOVF   01,W
0448A:  MOVWF  xDB
0448C:  MOVFF  03,ADC
04490:  MOVFF  ADC,FEA
04494:  MOVFF  ADB,FE9
04498:  MOVFF  FEC,ADE
0449C:  MOVF   FED,F
0449E:  MOVFF  FEF,ADD
044A2:  MOVLW  04
044A4:  ADDWF  xDD,W
044A6:  MOVWF  01
044A8:  MOVLW  00
044AA:  ADDWFC xDE,W
044AC:  MOVWF  03
044AE:  MOVF   01,W
044B0:  MOVWF  xDF
044B2:  MOVFF  03,AE0
044B6:  CLRF   03
044B8:  MOVF   xDA,W
044BA:  MOVWF  02
044BC:  BCF    FD8.0
044BE:  RLCF   02,F
044C0:  RLCF   03,F
044C2:  MOVF   02,W
044C4:  ADDLW  CE
044C6:  MOVWF  01
044C8:  MOVLW  0A
044CA:  ADDWFC 03,F
044CC:  MOVF   01,W
044CE:  MOVWF  xE1
044D0:  MOVFF  03,AE2
044D4:  MOVFF  AE2,FEA
044D8:  MOVFF  AE1,FE9
044DC:  MOVFF  FEC,AE4
044E0:  MOVF   FED,F
044E2:  MOVFF  FEF,AE3
044E6:  MOVLW  05
044E8:  ADDWF  xE3,W
044EA:  MOVWF  FE9
044EC:  MOVLW  00
044EE:  ADDWFC xE4,W
044F0:  MOVWF  FEA
044F2:  MOVFF  FEF,00
044F6:  MOVFF  FEC,01
044FA:  MOVFF  FEC,02
044FE:  MOVFF  FEC,03
04502:  MOVF   FED,F
04504:  MOVF   FED,F
04506:  MOVF   FED,F
04508:  MOVFF  03,AE8
0450C:  MOVFF  02,AE7
04510:  MOVFF  01,AE6
04514:  MOVFF  00,AE5
04518:  MOVFF  AE0,FEA
0451C:  MOVFF  ADF,FE9
04520:  MOVFF  AE5,FEF
04524:  MOVFF  AE6,FEC
04528:  MOVFF  AE7,FEC
0452C:  MOVFF  AE8,FEC
04530:  MOVF   FED,F
04532:  MOVF   FED,F
04534:  MOVF   FED,F
....................         dst_list[i]->reserve_counter1 = src_list[i]->reserve_counter1;
04536:  CLRF   03
04538:  MOVF   xDA,W
0453A:  MOVWF  02
0453C:  BCF    FD8.0
0453E:  RLCF   02,F
04540:  RLCF   03,F
04542:  MOVF   02,W
04544:  ADDLW  C2
04546:  MOVWF  01
04548:  MOVLW  0A
0454A:  ADDWFC 03,F
0454C:  MOVF   01,W
0454E:  MOVWF  xDB
04550:  MOVFF  03,ADC
04554:  MOVFF  ADC,FEA
04558:  MOVFF  ADB,FE9
0455C:  MOVFF  FEC,ADE
04560:  MOVF   FED,F
04562:  MOVFF  FEF,ADD
04566:  MOVLW  08
04568:  ADDWF  xDD,W
0456A:  MOVWF  01
0456C:  MOVLW  00
0456E:  ADDWFC xDE,W
04570:  MOVWF  03
04572:  MOVF   01,W
04574:  MOVWF  xDF
04576:  MOVFF  03,AE0
0457A:  CLRF   03
0457C:  MOVF   xDA,W
0457E:  MOVWF  02
04580:  BCF    FD8.0
04582:  RLCF   02,F
04584:  RLCF   03,F
04586:  MOVF   02,W
04588:  ADDLW  CE
0458A:  MOVWF  01
0458C:  MOVLW  0A
0458E:  ADDWFC 03,F
04590:  MOVF   01,W
04592:  MOVWF  xE1
04594:  MOVFF  03,AE2
04598:  MOVFF  AE2,FEA
0459C:  MOVFF  AE1,FE9
045A0:  MOVFF  FEC,AE4
045A4:  MOVF   FED,F
045A6:  MOVFF  FEF,AE3
045AA:  MOVLW  09
045AC:  ADDWF  xE3,W
045AE:  MOVWF  FE9
045B0:  MOVLW  00
045B2:  ADDWFC xE4,W
045B4:  MOVWF  FEA
045B6:  MOVF   FEF,W
045B8:  MOVWF  xE5
045BA:  MOVFF  AE0,FEA
045BE:  MOVFF  ADF,FE9
045C2:  MOVFF  AE5,FEF
....................         dst_list[i]->reserve_counter2 = src_list[i]->reserve_counter2;
045C6:  CLRF   03
045C8:  MOVF   xDA,W
045CA:  MOVWF  02
045CC:  BCF    FD8.0
045CE:  RLCF   02,F
045D0:  RLCF   03,F
045D2:  MOVF   02,W
045D4:  ADDLW  C2
045D6:  MOVWF  01
045D8:  MOVLW  0A
045DA:  ADDWFC 03,F
045DC:  MOVF   01,W
045DE:  MOVWF  xDB
045E0:  MOVFF  03,ADC
045E4:  MOVFF  ADC,FEA
045E8:  MOVFF  ADB,FE9
045EC:  MOVFF  FEC,ADE
045F0:  MOVF   FED,F
045F2:  MOVFF  FEF,ADD
045F6:  MOVLW  09
045F8:  ADDWF  xDD,W
045FA:  MOVWF  01
045FC:  MOVLW  00
045FE:  ADDWFC xDE,W
04600:  MOVWF  03
04602:  MOVF   01,W
04604:  MOVWF  xDF
04606:  MOVFF  03,AE0
0460A:  CLRF   03
0460C:  MOVF   xDA,W
0460E:  MOVWF  02
04610:  BCF    FD8.0
04612:  RLCF   02,F
04614:  RLCF   03,F
04616:  MOVF   02,W
04618:  ADDLW  CE
0461A:  MOVWF  01
0461C:  MOVLW  0A
0461E:  ADDWFC 03,F
04620:  MOVF   01,W
04622:  MOVWF  xE1
04624:  MOVFF  03,AE2
04628:  MOVFF  AE2,FEA
0462C:  MOVFF  AE1,FE9
04630:  MOVFF  FEC,AE4
04634:  MOVF   FED,F
04636:  MOVFF  FEF,AE3
0463A:  MOVLW  0A
0463C:  ADDWF  xE3,W
0463E:  MOVWF  FE9
04640:  MOVLW  00
04642:  ADDWFC xE4,W
04644:  MOVWF  FEA
04646:  MOVF   FEF,W
04648:  MOVWF  xE5
0464A:  MOVFF  AE0,FEA
0464E:  MOVFF  ADF,FE9
04652:  MOVFF  AE5,FEF
04656:  MOVLB  0
04658:  MOVLB  A
0465A:  INCF   xDA,F
0465C:  MOVLB  0
0465E:  GOTO   439E
....................     }
.................... 
....................     flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE - 1);
04662:  MOVLW  0A
04664:  MOVLB  A
04666:  MOVWF  xDC
04668:  MOVLW  80
0466A:  MOVWF  xDB
0466C:  MOVLW  3F
0466E:  MOVWF  xDD
04670:  MOVLB  0
04672:  CALL   2AFA
04676:  MOVFF  01,ABF
....................     fprintf(PC, "\r\n");
0467A:  MOVLW  0D
0467C:  MOVLB  A
0467E:  MOVWF  xDB
04680:  MOVLB  0
04682:  CALL   1CE0
04686:  MOVLW  0A
04688:  MOVLB  A
0468A:  MOVWF  xDB
0468C:  MOVLB  0
0468E:  CALL   1CE0
....................     return flash_data;
04692:  MOVLW  80
04694:  MOVWF  01
04696:  MOVLW  0A
04698:  MOVWF  02
0469A:  RETURN 0
.................... }
.................... 
.................... 
.................... void write_misf_address_area(void)
*
049F4:  CALL   4308
049F8:  MOVFF  02,03
049FC:  MOVF   01,W
049FE:  MOVWF  FE1
04A00:  MOVFF  03,FE2
04A04:  MOVLW  0A
04A06:  MOVWF  FEA
04A08:  MOVLW  38
04A0A:  MOVWF  FE9
04A0C:  MOVLW  40
04A0E:  MOVWF  01
04A10:  MOVFF  FE6,FEE
04A14:  DECFSZ 01,F
04A16:  GOTO   4A10
04A1A:  MOVLW  0A
04A1C:  MOVLB  A
04A1E:  MOVWF  x79
04A20:  MOVLW  38
04A22:  MOVWF  x78
.................... {
....................     FlashData_t flash_data = make_flash_data_table();
....................     FlashData_t *flash_data_ptr = &flash_data;
....................     sector_erase(mis_fm, MISF_CIGS_DATA_TABLE_START);
04A24:  MOVFF  111,A7D
04A28:  MOVFF  110,A7C
04A2C:  MOVFF  10F,A7B
04A30:  MOVFF  10E,A7A
04A34:  CLRF   x81
04A36:  CLRF   x80
04A38:  CLRF   x7F
04A3A:  CLRF   x7E
04A3C:  MOVLB  0
04A3E:  CALL   469C
....................     write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data_ptr->bytes, PACKET_SIZE);
04A42:  MOVLB  A
04A44:  MOVF   x78,W
04A46:  MOVWF  01
04A48:  MOVF   x79,W
04A4A:  MOVWF  03
04A4C:  MOVF   01,W
04A4E:  MOVWF  x7A
04A50:  MOVFF  03,A7B
04A54:  MOVFF  111,A7F
04A58:  MOVFF  110,A7E
04A5C:  MOVFF  10F,A7D
04A60:  MOVFF  10E,A7C
04A64:  CLRF   x83
04A66:  CLRF   x82
04A68:  CLRF   x81
04A6A:  CLRF   x80
04A6C:  MOVFF  A7B,A85
04A70:  MOVFF  A7A,A84
04A74:  CLRF   x87
04A76:  MOVLW  40
04A78:  MOVWF  x86
04A7A:  MOVLB  0
04A7C:  CALL   3F84
04A80:  RETURN 0
.................... }
.................... 
.................... // PICLOG 更新後に呼ばれる関数例 (piclog_write 内で既に write_misf_address_area 呼んでいる場合は不要)
.................... static void update_piclog_counters_after_write(unsigned int16 wrote_size)
.................... {
....................     piclog_data.used_counter     += wrote_size;
....................     piclog_data.uncopied_counter += wrote_size;
....................     // 必要なら wrap 処理追加
....................     write_misf_address_area();
.................... }
.................... 
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode)
.................... {
....................     FlashOperationStruct data;
....................     // 構造体の初期化
....................     data.mission_id = mission_id;
....................     data.func_type = func_type;
....................     data.write_mode = write_mode;
....................     data.source_type = SOURCE_MISF_UNCOPIED;
....................     enqueue_flash_operation(&data);
.................... }
.................... 
.................... void print_flash_status()
.................... {
....................     fprintf(PC, "\t| MISF | PICLOG     | Use Counter      : 0x%08LX\r\n", piclog_data.used_counter);
*
02B66:  MOVLW  C4
02B68:  MOVWF  FF6
02B6A:  MOVLW  0B
02B6C:  MOVWF  FF7
02B6E:  MOVLW  00
02B70:  MOVWF  FF8
02B72:  MOVLW  2C
02B74:  MOVLB  3
02B76:  MOVWF  x12
02B78:  MOVLB  0
02B7A:  CALL   1D62
02B7E:  MOVFF  168,A39
02B82:  MOVLW  37
02B84:  MOVLB  A
02B86:  MOVWF  x3A
02B88:  MOVLB  0
02B8A:  CALL   1F60
02B8E:  MOVFF  167,A39
02B92:  MOVLW  37
02B94:  MOVLB  A
02B96:  MOVWF  x3A
02B98:  MOVLB  0
02B9A:  CALL   1F60
02B9E:  MOVFF  166,A39
02BA2:  MOVLW  37
02BA4:  MOVLB  A
02BA6:  MOVWF  x3A
02BA8:  MOVLB  0
02BAA:  CALL   1F60
02BAE:  MOVFF  165,A39
02BB2:  MOVLW  37
02BB4:  MOVLB  A
02BB6:  MOVWF  x3A
02BB8:  MOVLB  0
02BBA:  CALL   1F60
02BBE:  MOVLW  0D
02BC0:  MOVLB  A
02BC2:  MOVWF  xDB
02BC4:  MOVLB  0
02BC6:  CALL   1CE0
02BCA:  MOVLW  0A
02BCC:  MOVLB  A
02BCE:  MOVWF  xDB
02BD0:  MOVLB  0
02BD2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | PICLOG     | Uncopyed Counter : 0x%08LX\r\n", piclog_data.uncopied_counter);
02BD6:  MOVLW  F8
02BD8:  MOVWF  FF6
02BDA:  MOVLW  0B
02BDC:  MOVWF  FF7
02BDE:  MOVLW  00
02BE0:  MOVWF  FF8
02BE2:  MOVLW  2C
02BE4:  MOVLB  3
02BE6:  MOVWF  x12
02BE8:  MOVLB  0
02BEA:  CALL   1D62
02BEE:  MOVFF  16C,A39
02BF2:  MOVLW  37
02BF4:  MOVLB  A
02BF6:  MOVWF  x3A
02BF8:  MOVLB  0
02BFA:  CALL   1F60
02BFE:  MOVFF  16B,A39
02C02:  MOVLW  37
02C04:  MOVLB  A
02C06:  MOVWF  x3A
02C08:  MOVLB  0
02C0A:  CALL   1F60
02C0E:  MOVFF  16A,A39
02C12:  MOVLW  37
02C14:  MOVLB  A
02C16:  MOVWF  x3A
02C18:  MOVLB  0
02C1A:  CALL   1F60
02C1E:  MOVFF  169,A39
02C22:  MOVLW  37
02C24:  MOVLB  A
02C26:  MOVWF  x3A
02C28:  MOVLB  0
02C2A:  CALL   1F60
02C2E:  MOVLW  0D
02C30:  MOVLB  A
02C32:  MOVWF  xDB
02C34:  MOVLB  0
02C36:  CALL   1CE0
02C3A:  MOVLW  0A
02C3C:  MOVLB  A
02C3E:  MOVWF  xDB
02C40:  MOVLB  0
02C42:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | PICLOG     | Reserve Counter1 : 0x%02X\r\n", piclog_data.reserve_counter1);
02C46:  MOVLW  2C
02C48:  MOVWF  FF6
02C4A:  MOVLW  0C
02C4C:  MOVWF  FF7
02C4E:  MOVLW  00
02C50:  MOVWF  FF8
02C52:  MOVLW  2C
02C54:  MOVLB  3
02C56:  MOVWF  x12
02C58:  MOVLB  0
02C5A:  CALL   1D62
02C5E:  MOVFF  16D,A39
02C62:  MOVLW  37
02C64:  MOVLB  A
02C66:  MOVWF  x3A
02C68:  MOVLB  0
02C6A:  CALL   1F60
02C6E:  MOVLW  0D
02C70:  MOVLB  A
02C72:  MOVWF  xDB
02C74:  MOVLB  0
02C76:  CALL   1CE0
02C7A:  MOVLW  0A
02C7C:  MOVLB  A
02C7E:  MOVWF  xDB
02C80:  MOVLB  0
02C82:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | PICLOG     | Reserve Counter2 : 0x%02X\r\n", piclog_data.reserve_counter2);
02C86:  MOVLW  60
02C88:  MOVWF  FF6
02C8A:  MOVLW  0C
02C8C:  MOVWF  FF7
02C8E:  MOVLW  00
02C90:  MOVWF  FF8
02C92:  MOVLW  2C
02C94:  MOVLB  3
02C96:  MOVWF  x12
02C98:  MOVLB  0
02C9A:  CALL   1D62
02C9E:  MOVFF  16E,A39
02CA2:  MOVLW  37
02CA4:  MOVLB  A
02CA6:  MOVWF  x3A
02CA8:  MOVLB  0
02CAA:  CALL   1F60
02CAE:  MOVLW  0D
02CB0:  MOVLB  A
02CB2:  MOVWF  xDB
02CB4:  MOVLB  0
02CB6:  CALL   1CE0
02CBA:  MOVLW  0A
02CBC:  MOVLB  A
02CBE:  MOVWF  xDB
02CC0:  MOVLB  0
02CC2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | ENVIRO     | Use Counter      : 0x%08LX\r\n", environment_data.used_counter);
02CC6:  MOVLW  94
02CC8:  MOVWF  FF6
02CCA:  MOVLW  0C
02CCC:  MOVWF  FF7
02CCE:  MOVLW  00
02CD0:  MOVWF  FF8
02CD2:  MOVLW  2C
02CD4:  MOVLB  3
02CD6:  MOVWF  x12
02CD8:  MOVLB  0
02CDA:  CALL   1D62
02CDE:  MOVFF  173,A39
02CE2:  MOVLW  37
02CE4:  MOVLB  A
02CE6:  MOVWF  x3A
02CE8:  MOVLB  0
02CEA:  CALL   1F60
02CEE:  MOVFF  172,A39
02CF2:  MOVLW  37
02CF4:  MOVLB  A
02CF6:  MOVWF  x3A
02CF8:  MOVLB  0
02CFA:  CALL   1F60
02CFE:  MOVFF  171,A39
02D02:  MOVLW  37
02D04:  MOVLB  A
02D06:  MOVWF  x3A
02D08:  MOVLB  0
02D0A:  CALL   1F60
02D0E:  MOVFF  170,A39
02D12:  MOVLW  37
02D14:  MOVLB  A
02D16:  MOVWF  x3A
02D18:  MOVLB  0
02D1A:  CALL   1F60
02D1E:  MOVLW  0D
02D20:  MOVLB  A
02D22:  MOVWF  xDB
02D24:  MOVLB  0
02D26:  CALL   1CE0
02D2A:  MOVLW  0A
02D2C:  MOVLB  A
02D2E:  MOVWF  xDB
02D30:  MOVLB  0
02D32:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | ENVIRO     | Uncopyed Counter : 0x%08LX\r\n", environment_data.uncopied_counter);
02D36:  MOVLW  C8
02D38:  MOVWF  FF6
02D3A:  MOVLW  0C
02D3C:  MOVWF  FF7
02D3E:  MOVLW  00
02D40:  MOVWF  FF8
02D42:  MOVLW  2C
02D44:  MOVLB  3
02D46:  MOVWF  x12
02D48:  MOVLB  0
02D4A:  CALL   1D62
02D4E:  MOVFF  177,A39
02D52:  MOVLW  37
02D54:  MOVLB  A
02D56:  MOVWF  x3A
02D58:  MOVLB  0
02D5A:  CALL   1F60
02D5E:  MOVFF  176,A39
02D62:  MOVLW  37
02D64:  MOVLB  A
02D66:  MOVWF  x3A
02D68:  MOVLB  0
02D6A:  CALL   1F60
02D6E:  MOVFF  175,A39
02D72:  MOVLW  37
02D74:  MOVLB  A
02D76:  MOVWF  x3A
02D78:  MOVLB  0
02D7A:  CALL   1F60
02D7E:  MOVFF  174,A39
02D82:  MOVLW  37
02D84:  MOVLB  A
02D86:  MOVWF  x3A
02D88:  MOVLB  0
02D8A:  CALL   1F60
02D8E:  MOVLW  0D
02D90:  MOVLB  A
02D92:  MOVWF  xDB
02D94:  MOVLB  0
02D96:  CALL   1CE0
02D9A:  MOVLW  0A
02D9C:  MOVLB  A
02D9E:  MOVWF  xDB
02DA0:  MOVLB  0
02DA2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | ENVIRO     | Reserve Counter1 : 0x%02X\r\n", environment_data.reserve_counter1);
02DA6:  MOVLW  FC
02DA8:  MOVWF  FF6
02DAA:  MOVLW  0C
02DAC:  MOVWF  FF7
02DAE:  MOVLW  00
02DB0:  MOVWF  FF8
02DB2:  MOVLW  2C
02DB4:  MOVLB  3
02DB6:  MOVWF  x12
02DB8:  MOVLB  0
02DBA:  CALL   1D62
02DBE:  MOVFF  178,A39
02DC2:  MOVLW  37
02DC4:  MOVLB  A
02DC6:  MOVWF  x3A
02DC8:  MOVLB  0
02DCA:  CALL   1F60
02DCE:  MOVLW  0D
02DD0:  MOVLB  A
02DD2:  MOVWF  xDB
02DD4:  MOVLB  0
02DD6:  CALL   1CE0
02DDA:  MOVLW  0A
02DDC:  MOVLB  A
02DDE:  MOVWF  xDB
02DE0:  MOVLB  0
02DE2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | ENVIRO     | Reserve Counter2 : 0x%02X\r\n", environment_data.reserve_counter2);
02DE6:  MOVLW  30
02DE8:  MOVWF  FF6
02DEA:  MOVLW  0D
02DEC:  MOVWF  FF7
02DEE:  MOVLW  00
02DF0:  MOVWF  FF8
02DF2:  MOVLW  2C
02DF4:  MOVLB  3
02DF6:  MOVWF  x12
02DF8:  MOVLB  0
02DFA:  CALL   1D62
02DFE:  MOVFF  179,A39
02E02:  MOVLW  37
02E04:  MOVLB  A
02E06:  MOVWF  x3A
02E08:  MOVLB  0
02E0A:  CALL   1F60
02E0E:  MOVLW  0D
02E10:  MOVLB  A
02E12:  MOVWF  xDB
02E14:  MOVLB  0
02E16:  CALL   1CE0
02E1A:  MOVLW  0A
02E1C:  MOVLB  A
02E1E:  MOVWF  xDB
02E20:  MOVLB  0
02E22:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Use Counter      : 0x%08LX\r\n", iv1_header.used_counter);
02E26:  MOVLW  64
02E28:  MOVWF  FF6
02E2A:  MOVLW  0D
02E2C:  MOVWF  FF7
02E2E:  MOVLW  00
02E30:  MOVWF  FF8
02E32:  MOVLW  2C
02E34:  MOVLB  3
02E36:  MOVWF  x12
02E38:  MOVLB  0
02E3A:  CALL   1D62
02E3E:  MOVFF  17E,A39
02E42:  MOVLW  37
02E44:  MOVLB  A
02E46:  MOVWF  x3A
02E48:  MOVLB  0
02E4A:  CALL   1F60
02E4E:  MOVFF  17D,A39
02E52:  MOVLW  37
02E54:  MOVLB  A
02E56:  MOVWF  x3A
02E58:  MOVLB  0
02E5A:  CALL   1F60
02E5E:  MOVFF  17C,A39
02E62:  MOVLW  37
02E64:  MOVLB  A
02E66:  MOVWF  x3A
02E68:  MOVLB  0
02E6A:  CALL   1F60
02E6E:  MOVFF  17B,A39
02E72:  MOVLW  37
02E74:  MOVLB  A
02E76:  MOVWF  x3A
02E78:  MOVLB  0
02E7A:  CALL   1F60
02E7E:  MOVLW  0D
02E80:  MOVLB  A
02E82:  MOVWF  xDB
02E84:  MOVLB  0
02E86:  CALL   1CE0
02E8A:  MOVLW  0A
02E8C:  MOVLB  A
02E8E:  MOVWF  xDB
02E90:  MOVLB  0
02E92:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Uncopyed Counter : 0x%08LX\r\n", iv1_header.uncopied_counter);
02E96:  MOVLW  98
02E98:  MOVWF  FF6
02E9A:  MOVLW  0D
02E9C:  MOVWF  FF7
02E9E:  MOVLW  00
02EA0:  MOVWF  FF8
02EA2:  MOVLW  2C
02EA4:  MOVLB  3
02EA6:  MOVWF  x12
02EA8:  MOVLB  0
02EAA:  CALL   1D62
02EAE:  MOVFF  182,A39
02EB2:  MOVLW  37
02EB4:  MOVLB  A
02EB6:  MOVWF  x3A
02EB8:  MOVLB  0
02EBA:  CALL   1F60
02EBE:  MOVFF  181,A39
02EC2:  MOVLW  37
02EC4:  MOVLB  A
02EC6:  MOVWF  x3A
02EC8:  MOVLB  0
02ECA:  CALL   1F60
02ECE:  MOVFF  180,A39
02ED2:  MOVLW  37
02ED4:  MOVLB  A
02ED6:  MOVWF  x3A
02ED8:  MOVLB  0
02EDA:  CALL   1F60
02EDE:  MOVFF  17F,A39
02EE2:  MOVLW  37
02EE4:  MOVLB  A
02EE6:  MOVWF  x3A
02EE8:  MOVLB  0
02EEA:  CALL   1F60
02EEE:  MOVLW  0D
02EF0:  MOVLB  A
02EF2:  MOVWF  xDB
02EF4:  MOVLB  0
02EF6:  CALL   1CE0
02EFA:  MOVLW  0A
02EFC:  MOVLB  A
02EFE:  MOVWF  xDB
02F00:  MOVLB  0
02F02:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Reserve Counter1 : 0x%02X\r\n", iv1_header.reserve_counter1);
02F06:  MOVLW  CC
02F08:  MOVWF  FF6
02F0A:  MOVLW  0D
02F0C:  MOVWF  FF7
02F0E:  MOVLW  00
02F10:  MOVWF  FF8
02F12:  MOVLW  2C
02F14:  MOVLB  3
02F16:  MOVWF  x12
02F18:  MOVLB  0
02F1A:  CALL   1D62
02F1E:  MOVFF  183,A39
02F22:  MOVLW  37
02F24:  MOVLB  A
02F26:  MOVWF  x3A
02F28:  MOVLB  0
02F2A:  CALL   1F60
02F2E:  MOVLW  0D
02F30:  MOVLB  A
02F32:  MOVWF  xDB
02F34:  MOVLB  0
02F36:  CALL   1CE0
02F3A:  MOVLW  0A
02F3C:  MOVLB  A
02F3E:  MOVWF  xDB
02F40:  MOVLB  0
02F42:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 HEADER | Reserve Counter2 : 0x%02X\r\n", iv1_header.reserve_counter2);
02F46:  MOVLW  00
02F48:  MOVWF  FF6
02F4A:  MOVLW  0E
02F4C:  MOVWF  FF7
02F4E:  MOVLW  00
02F50:  MOVWF  FF8
02F52:  MOVLW  2C
02F54:  MOVLB  3
02F56:  MOVWF  x12
02F58:  MOVLB  0
02F5A:  CALL   1D62
02F5E:  MOVFF  184,A39
02F62:  MOVLW  37
02F64:  MOVLB  A
02F66:  MOVWF  x3A
02F68:  MOVLB  0
02F6A:  CALL   1F60
02F6E:  MOVLW  0D
02F70:  MOVLB  A
02F72:  MOVWF  xDB
02F74:  MOVLB  0
02F76:  CALL   1CE0
02F7A:  MOVLW  0A
02F7C:  MOVLB  A
02F7E:  MOVWF  xDB
02F80:  MOVLB  0
02F82:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Use Counter      : 0x%08LX\r\n", iv1_data.used_counter);
02F86:  MOVLW  34
02F88:  MOVWF  FF6
02F8A:  MOVLW  0E
02F8C:  MOVWF  FF7
02F8E:  MOVLW  00
02F90:  MOVWF  FF8
02F92:  MOVLW  2C
02F94:  MOVLB  3
02F96:  MOVWF  x12
02F98:  MOVLB  0
02F9A:  CALL   1D62
02F9E:  MOVFF  189,A39
02FA2:  MOVLW  37
02FA4:  MOVLB  A
02FA6:  MOVWF  x3A
02FA8:  MOVLB  0
02FAA:  CALL   1F60
02FAE:  MOVFF  188,A39
02FB2:  MOVLW  37
02FB4:  MOVLB  A
02FB6:  MOVWF  x3A
02FB8:  MOVLB  0
02FBA:  CALL   1F60
02FBE:  MOVFF  187,A39
02FC2:  MOVLW  37
02FC4:  MOVLB  A
02FC6:  MOVWF  x3A
02FC8:  MOVLB  0
02FCA:  CALL   1F60
02FCE:  MOVFF  186,A39
02FD2:  MOVLW  37
02FD4:  MOVLB  A
02FD6:  MOVWF  x3A
02FD8:  MOVLB  0
02FDA:  CALL   1F60
02FDE:  MOVLW  0D
02FE0:  MOVLB  A
02FE2:  MOVWF  xDB
02FE4:  MOVLB  0
02FE6:  CALL   1CE0
02FEA:  MOVLW  0A
02FEC:  MOVLB  A
02FEE:  MOVWF  xDB
02FF0:  MOVLB  0
02FF2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Uncopyed Counter : 0x%08LX\r\n", iv1_data.uncopied_counter);
02FF6:  MOVLW  68
02FF8:  MOVWF  FF6
02FFA:  MOVLW  0E
02FFC:  MOVWF  FF7
02FFE:  MOVLW  00
03000:  MOVWF  FF8
03002:  MOVLW  2C
03004:  MOVLB  3
03006:  MOVWF  x12
03008:  MOVLB  0
0300A:  CALL   1D62
0300E:  MOVFF  18D,A39
03012:  MOVLW  37
03014:  MOVLB  A
03016:  MOVWF  x3A
03018:  MOVLB  0
0301A:  CALL   1F60
0301E:  MOVFF  18C,A39
03022:  MOVLW  37
03024:  MOVLB  A
03026:  MOVWF  x3A
03028:  MOVLB  0
0302A:  CALL   1F60
0302E:  MOVFF  18B,A39
03032:  MOVLW  37
03034:  MOVLB  A
03036:  MOVWF  x3A
03038:  MOVLB  0
0303A:  CALL   1F60
0303E:  MOVFF  18A,A39
03042:  MOVLW  37
03044:  MOVLB  A
03046:  MOVWF  x3A
03048:  MOVLB  0
0304A:  CALL   1F60
0304E:  MOVLW  0D
03050:  MOVLB  A
03052:  MOVWF  xDB
03054:  MOVLB  0
03056:  CALL   1CE0
0305A:  MOVLW  0A
0305C:  MOVLB  A
0305E:  MOVWF  xDB
03060:  MOVLB  0
03062:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Reserve Counter1 : 0x%02X\r\n", iv1_data.reserve_counter1);
03066:  MOVLW  9C
03068:  MOVWF  FF6
0306A:  MOVLW  0E
0306C:  MOVWF  FF7
0306E:  MOVLW  00
03070:  MOVWF  FF8
03072:  MOVLW  2C
03074:  MOVLB  3
03076:  MOVWF  x12
03078:  MOVLB  0
0307A:  CALL   1D62
0307E:  MOVFF  18E,A39
03082:  MOVLW  37
03084:  MOVLB  A
03086:  MOVWF  x3A
03088:  MOVLB  0
0308A:  CALL   1F60
0308E:  MOVLW  0D
03090:  MOVLB  A
03092:  MOVWF  xDB
03094:  MOVLB  0
03096:  CALL   1CE0
0309A:  MOVLW  0A
0309C:  MOVLB  A
0309E:  MOVWF  xDB
030A0:  MOVLB  0
030A2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV1 DATA   | Reserve Counter2 : 0x%02X\r\n", iv1_data.reserve_counter2);
030A6:  MOVLW  D0
030A8:  MOVWF  FF6
030AA:  MOVLW  0E
030AC:  MOVWF  FF7
030AE:  MOVLW  00
030B0:  MOVWF  FF8
030B2:  MOVLW  2C
030B4:  MOVLB  3
030B6:  MOVWF  x12
030B8:  MOVLB  0
030BA:  CALL   1D62
030BE:  MOVFF  18F,A39
030C2:  MOVLW  37
030C4:  MOVLB  A
030C6:  MOVWF  x3A
030C8:  MOVLB  0
030CA:  CALL   1F60
030CE:  MOVLW  0D
030D0:  MOVLB  A
030D2:  MOVWF  xDB
030D4:  MOVLB  0
030D6:  CALL   1CE0
030DA:  MOVLW  0A
030DC:  MOVLB  A
030DE:  MOVWF  xDB
030E0:  MOVLB  0
030E2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Use Counter      : 0x%08LX\r\n", iv2_header.used_counter);
030E6:  MOVLW  04
030E8:  MOVWF  FF6
030EA:  MOVLW  0F
030EC:  MOVWF  FF7
030EE:  MOVLW  00
030F0:  MOVWF  FF8
030F2:  MOVLW  2C
030F4:  MOVLB  3
030F6:  MOVWF  x12
030F8:  MOVLB  0
030FA:  CALL   1D62
030FE:  MOVFF  194,A39
03102:  MOVLW  37
03104:  MOVLB  A
03106:  MOVWF  x3A
03108:  MOVLB  0
0310A:  CALL   1F60
0310E:  MOVFF  193,A39
03112:  MOVLW  37
03114:  MOVLB  A
03116:  MOVWF  x3A
03118:  MOVLB  0
0311A:  CALL   1F60
0311E:  MOVFF  192,A39
03122:  MOVLW  37
03124:  MOVLB  A
03126:  MOVWF  x3A
03128:  MOVLB  0
0312A:  CALL   1F60
0312E:  MOVFF  191,A39
03132:  MOVLW  37
03134:  MOVLB  A
03136:  MOVWF  x3A
03138:  MOVLB  0
0313A:  CALL   1F60
0313E:  MOVLW  0D
03140:  MOVLB  A
03142:  MOVWF  xDB
03144:  MOVLB  0
03146:  CALL   1CE0
0314A:  MOVLW  0A
0314C:  MOVLB  A
0314E:  MOVWF  xDB
03150:  MOVLB  0
03152:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Uncopyed Counter : 0x%08LX\r\n", iv2_header.uncopied_counter);
03156:  MOVLW  38
03158:  MOVWF  FF6
0315A:  MOVLW  0F
0315C:  MOVWF  FF7
0315E:  MOVLW  00
03160:  MOVWF  FF8
03162:  MOVLW  2C
03164:  MOVLB  3
03166:  MOVWF  x12
03168:  MOVLB  0
0316A:  CALL   1D62
0316E:  MOVFF  198,A39
03172:  MOVLW  37
03174:  MOVLB  A
03176:  MOVWF  x3A
03178:  MOVLB  0
0317A:  CALL   1F60
0317E:  MOVFF  197,A39
03182:  MOVLW  37
03184:  MOVLB  A
03186:  MOVWF  x3A
03188:  MOVLB  0
0318A:  CALL   1F60
0318E:  MOVFF  196,A39
03192:  MOVLW  37
03194:  MOVLB  A
03196:  MOVWF  x3A
03198:  MOVLB  0
0319A:  CALL   1F60
0319E:  MOVFF  195,A39
031A2:  MOVLW  37
031A4:  MOVLB  A
031A6:  MOVWF  x3A
031A8:  MOVLB  0
031AA:  CALL   1F60
031AE:  MOVLW  0D
031B0:  MOVLB  A
031B2:  MOVWF  xDB
031B4:  MOVLB  0
031B6:  CALL   1CE0
031BA:  MOVLW  0A
031BC:  MOVLB  A
031BE:  MOVWF  xDB
031C0:  MOVLB  0
031C2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Reserve Counter1 : 0x%02X\r\n", iv2_header.reserve_counter1);
031C6:  MOVLW  6C
031C8:  MOVWF  FF6
031CA:  MOVLW  0F
031CC:  MOVWF  FF7
031CE:  MOVLW  00
031D0:  MOVWF  FF8
031D2:  MOVLW  2C
031D4:  MOVLB  3
031D6:  MOVWF  x12
031D8:  MOVLB  0
031DA:  CALL   1D62
031DE:  MOVFF  199,A39
031E2:  MOVLW  37
031E4:  MOVLB  A
031E6:  MOVWF  x3A
031E8:  MOVLB  0
031EA:  CALL   1F60
031EE:  MOVLW  0D
031F0:  MOVLB  A
031F2:  MOVWF  xDB
031F4:  MOVLB  0
031F6:  CALL   1CE0
031FA:  MOVLW  0A
031FC:  MOVLB  A
031FE:  MOVWF  xDB
03200:  MOVLB  0
03202:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 HEADER | Reserve Counter2 : 0x%02X\r\n", iv2_header.reserve_counter2);
03206:  MOVLW  A0
03208:  MOVWF  FF6
0320A:  MOVLW  0F
0320C:  MOVWF  FF7
0320E:  MOVLW  00
03210:  MOVWF  FF8
03212:  MOVLW  2C
03214:  MOVLB  3
03216:  MOVWF  x12
03218:  MOVLB  0
0321A:  CALL   1D62
0321E:  MOVFF  19A,A39
03222:  MOVLW  37
03224:  MOVLB  A
03226:  MOVWF  x3A
03228:  MOVLB  0
0322A:  CALL   1F60
0322E:  MOVLW  0D
03230:  MOVLB  A
03232:  MOVWF  xDB
03234:  MOVLB  0
03236:  CALL   1CE0
0323A:  MOVLW  0A
0323C:  MOVLB  A
0323E:  MOVWF  xDB
03240:  MOVLB  0
03242:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Use Counter      : 0x%08LX\r\n", iv2_data.used_counter);
03246:  MOVLW  D4
03248:  MOVWF  FF6
0324A:  MOVLW  0F
0324C:  MOVWF  FF7
0324E:  MOVLW  00
03250:  MOVWF  FF8
03252:  MOVLW  2C
03254:  MOVLB  3
03256:  MOVWF  x12
03258:  MOVLB  0
0325A:  CALL   1D62
0325E:  MOVFF  19F,A39
03262:  MOVLW  37
03264:  MOVLB  A
03266:  MOVWF  x3A
03268:  MOVLB  0
0326A:  CALL   1F60
0326E:  MOVFF  19E,A39
03272:  MOVLW  37
03274:  MOVLB  A
03276:  MOVWF  x3A
03278:  MOVLB  0
0327A:  CALL   1F60
0327E:  MOVFF  19D,A39
03282:  MOVLW  37
03284:  MOVLB  A
03286:  MOVWF  x3A
03288:  MOVLB  0
0328A:  CALL   1F60
0328E:  MOVFF  19C,A39
03292:  MOVLW  37
03294:  MOVLB  A
03296:  MOVWF  x3A
03298:  MOVLB  0
0329A:  CALL   1F60
0329E:  MOVLW  0D
032A0:  MOVLB  A
032A2:  MOVWF  xDB
032A4:  MOVLB  0
032A6:  CALL   1CE0
032AA:  MOVLW  0A
032AC:  MOVLB  A
032AE:  MOVWF  xDB
032B0:  MOVLB  0
032B2:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Uncopyed Counter : 0x%08LX\r\n", iv2_data.uncopied_counter);
032B6:  MOVLW  08
032B8:  MOVWF  FF6
032BA:  MOVLW  10
032BC:  MOVWF  FF7
032BE:  MOVLW  00
032C0:  MOVWF  FF8
032C2:  MOVLW  2C
032C4:  MOVLB  3
032C6:  MOVWF  x12
032C8:  MOVLB  0
032CA:  CALL   1D62
032CE:  MOVFF  1A3,A39
032D2:  MOVLW  37
032D4:  MOVLB  A
032D6:  MOVWF  x3A
032D8:  MOVLB  0
032DA:  CALL   1F60
032DE:  MOVFF  1A2,A39
032E2:  MOVLW  37
032E4:  MOVLB  A
032E6:  MOVWF  x3A
032E8:  MOVLB  0
032EA:  CALL   1F60
032EE:  MOVFF  1A1,A39
032F2:  MOVLW  37
032F4:  MOVLB  A
032F6:  MOVWF  x3A
032F8:  MOVLB  0
032FA:  CALL   1F60
032FE:  MOVFF  1A0,A39
03302:  MOVLW  37
03304:  MOVLB  A
03306:  MOVWF  x3A
03308:  MOVLB  0
0330A:  CALL   1F60
0330E:  MOVLW  0D
03310:  MOVLB  A
03312:  MOVWF  xDB
03314:  MOVLB  0
03316:  CALL   1CE0
0331A:  MOVLW  0A
0331C:  MOVLB  A
0331E:  MOVWF  xDB
03320:  MOVLB  0
03322:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Reserve Counter1 : 0x%02X\r\n", iv2_data.reserve_counter1);
03326:  MOVLW  3C
03328:  MOVWF  FF6
0332A:  MOVLW  10
0332C:  MOVWF  FF7
0332E:  MOVLW  00
03330:  MOVWF  FF8
03332:  MOVLW  2C
03334:  MOVLB  3
03336:  MOVWF  x12
03338:  MOVLB  0
0333A:  CALL   1D62
0333E:  MOVFF  1A4,A39
03342:  MOVLW  37
03344:  MOVLB  A
03346:  MOVWF  x3A
03348:  MOVLB  0
0334A:  CALL   1F60
0334E:  MOVLW  0D
03350:  MOVLB  A
03352:  MOVWF  xDB
03354:  MOVLB  0
03356:  CALL   1CE0
0335A:  MOVLW  0A
0335C:  MOVLB  A
0335E:  MOVWF  xDB
03360:  MOVLB  0
03362:  CALL   1CE0
....................     fprintf(PC, "\t| MISF | IV2 DATA   | Reserve Counter2 : 0x%02X\r\n", iv2_data.reserve_counter2);
03366:  MOVLW  70
03368:  MOVWF  FF6
0336A:  MOVLW  10
0336C:  MOVWF  FF7
0336E:  MOVLW  00
03370:  MOVWF  FF8
03372:  MOVLW  2C
03374:  MOVLB  3
03376:  MOVWF  x12
03378:  MOVLB  0
0337A:  CALL   1D62
0337E:  MOVFF  1A5,A39
03382:  MOVLW  37
03384:  MOVLB  A
03386:  MOVWF  x3A
03388:  MOVLB  0
0338A:  CALL   1F60
0338E:  MOVLW  0D
03390:  MOVLB  A
03392:  MOVWF  xDB
03394:  MOVLB  0
03396:  CALL   1CE0
0339A:  MOVLW  0A
0339C:  MOVLB  A
0339E:  MOVWF  xDB
033A0:  MOVLB  0
033A2:  CALL   1CE0
....................     fprintf(PC, "\tComplete\r\n");
033A6:  MOVLW  A4
033A8:  MOVWF  FF6
033AA:  MOVLW  10
033AC:  MOVWF  FF7
033AE:  MOVLW  00
033B0:  MOVWF  FF8
033B2:  CALL   1D32
033B6:  GOTO   3C64 (RETURN)
.................... }
.................... 
.................... void write_smf_header(smf_data_table_t *smf_data_table)
.................... {
.................... 
....................     int8 readdata[PACKET_SIZE];
....................     int8 retry_count;
....................     int1 crc_valid = 0;
....................     for (retry_count = 0; retry_count < CRC_RETRY_COUNT; retry_count++)
....................     {
....................         subsector_4kByte_erase(smf, CIGS_DATA_TABLE_START_ADDRESS);
....................         write_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, smf_data_table->bytes, PACKET_SIZE); // ヘッダーを書き込み
....................         read_data_bytes(smf, CIGS_DATA_TABLE_START_ADDRESS, readdata, PACKET_SIZE);
....................         if (is_crc_valid(readdata, PACKET_SIZE-1))
....................         {
....................             fprintf(PC, "CRC verification passed on attempt %d\r\n", retry_count + 1);
....................             break;
....................         }
....................     }
....................     if (!crc_valid)
....................     {
....................         fprintf(PC, "Error: CRC verification failed after %d attempts\r\n", CRC_RETRY_COUNT);
....................         // return; 
....................     }
.................... }
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id)
.................... {
....................    MisfAddressStruct mis_struct = {0};
*
0A642:  MOVLB  2
0A644:  CLRF   x97
0A646:  CLRF   x98
0A648:  CLRF   x99
0A64A:  CLRF   x9A
0A64C:  CLRF   x9B
0A64E:  CLRF   x9C
0A650:  CLRF   x9D
0A652:  CLRF   x9E
.................... 
....................    if (mission_id == CIGS_DATA_TABLE)
0A654:  MOVF   x96,F
0A656:  BTFSC  FD8.2
0A658:  BRA    A660
0A65A:  MOVLB  0
0A65C:  GOTO   A67C
0A660:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_DATA_TABLE_START;
0A662:  MOVLB  2
0A664:  CLRF   x9A
0A666:  CLRF   x99
0A668:  CLRF   x98
0A66A:  CLRF   x97
....................       mis_struct.end_address   = MISF_CIGS_DATA_TABLE_END;
0A66C:  CLRF   x9E
0A66E:  CLRF   x9D
0A670:  MOVLW  0F
0A672:  MOVWF  x9C
0A674:  SETF   x9B
0A676:  MOVLB  0
....................    }
0A678:  GOTO   A73E
....................    else if (mission_id == CIGS_PICLOG_DATA)
0A67C:  MOVLB  2
0A67E:  DECFSZ x96,W
0A680:  BRA    A686
0A682:  BRA    A68C
0A684:  MOVLB  0
0A686:  MOVLB  0
0A688:  GOTO   A6AC
0A68C:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_PICLOG_START;
0A68E:  MOVLB  2
0A690:  CLRF   x9A
0A692:  MOVLW  01
0A694:  MOVWF  x99
0A696:  CLRF   x98
0A698:  CLRF   x97
....................       mis_struct.end_address   = MISF_CIGS_PICLOG_END;
0A69A:  CLRF   x9E
0A69C:  MOVLW  14
0A69E:  MOVWF  x9D
0A6A0:  MOVLW  0F
0A6A2:  MOVWF  x9C
0A6A4:  SETF   x9B
0A6A6:  MOVLB  0
....................    }
0A6A8:  GOTO   A73E
....................    else if (mission_id == CIGS_ENVIRO_DATA)
0A6AC:  MOVLB  2
0A6AE:  MOVF   x96,W
0A6B0:  SUBLW  02
0A6B2:  BTFSC  FD8.2
0A6B4:  BRA    A6BC
0A6B6:  MOVLB  0
0A6B8:  GOTO   A6DE
0A6BC:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_ENVIRO_START;
0A6BE:  MOVLB  2
0A6C0:  CLRF   x9A
0A6C2:  MOVLW  28
0A6C4:  MOVWF  x99
0A6C6:  MOVLW  10
0A6C8:  MOVWF  x98
0A6CA:  CLRF   x97
....................       mis_struct.end_address   = MISF_CIGS_ENVIRO_END;
0A6CC:  CLRF   x9E
0A6CE:  MOVLW  32
0A6D0:  MOVWF  x9D
0A6D2:  MOVLW  0F
0A6D4:  MOVWF  x9C
0A6D6:  SETF   x9B
0A6D8:  MOVLB  0
....................    }
0A6DA:  GOTO   A73E
....................    else if (mission_id == CIGS_IV1_HEADER)
0A6DE:  MOVLB  2
0A6E0:  MOVF   x96,W
0A6E2:  SUBLW  03
0A6E4:  BTFSC  FD8.2
0A6E6:  BRA    A6EE
0A6E8:  MOVLB  0
0A6EA:  GOTO   A710
0A6EE:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_HEADER_START;
0A6F0:  MOVLB  2
0A6F2:  CLRF   x9A
0A6F4:  MOVLW  72
0A6F6:  MOVWF  x99
0A6F8:  MOVLW  10
0A6FA:  MOVWF  x98
0A6FC:  CLRF   x97
....................       mis_struct.end_address   = MISF_CIGS_IV_HEADER_END;
0A6FE:  CLRF   x9E
0A700:  MOVLW  7C
0A702:  MOVWF  x9D
0A704:  MOVLW  0F
0A706:  MOVWF  x9C
0A708:  SETF   x9B
0A70A:  MOVLB  0
....................    }
0A70C:  GOTO   A73E
....................    else if (mission_id == CIGS_IV1_DATA)
0A710:  MOVLB  2
0A712:  MOVF   x96,W
0A714:  SUBLW  04
0A716:  BTFSC  FD8.2
0A718:  BRA    A720
0A71A:  MOVLB  0
0A71C:  GOTO   A73E
0A720:  MOVLB  0
....................    {
....................       mis_struct.start_address = MISF_CIGS_IV_DATA_START;
0A722:  MOVLB  2
0A724:  CLRF   x9A
0A726:  MOVLW  7C
0A728:  MOVWF  x99
0A72A:  MOVLW  10
0A72C:  MOVWF  x98
0A72E:  CLRF   x97
....................       mis_struct.end_address   = MISF_CIGS_IV_DATA_END;
0A730:  CLRF   x9E
0A732:  MOVLW  BC
0A734:  MOVWF  x9D
0A736:  MOVLW  0F
0A738:  MOVWF  x9C
0A73A:  SETF   x9B
0A73C:  MOVLB  0
....................    }
....................    return mis_struct;
0A73E:  MOVLW  97
0A740:  MOVWF  01
0A742:  MOVLW  02
0A744:  MOVWF  02
0A746:  GOTO   AC20 (RETURN)
.................... }
.................... 
.................... MisfWriteStruct get_misf_write_struct(MissionID mission_id)
.................... {
....................     MisfWriteStruct mis_write_struct = {0};
.................... 
....................     if (mission_id == CIGS_DATA_TABLE)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_DATA_TABLE_START;
....................         mis_write_struct.size = MISF_CIGS_DATA_TABLE_SIZE;
....................     }
....................     else if (mission_id == CIGS_PICLOG_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_PICLOG_START + piclog_data.used_counter - piclog_data.uncopied_counter;
....................         mis_write_struct.size = piclog_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_ENVIRO_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_ENVIRO_START + environment_data.used_counter - environment_data.uncopied_counter;
....................         mis_write_struct.size = environment_data.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV1_HEADER)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_HEADER_START + iv1_header.used_counter - iv1_header.uncopied_counter;
....................         mis_write_struct.size = iv1_header.uncopied_counter;
....................     }
....................     else if (mission_id == CIGS_IV1_DATA)
....................     {
....................         mis_write_struct.start_address = MISF_CIGS_IV_DATA_START + iv1_data.used_counter - iv1_data.uncopied_counter;
....................         mis_write_struct.size = iv1_data.uncopied_counter;
....................     }
....................     return mis_write_struct;
.................... }
.................... // End of file
.................... 
.................... 
.................... // アプリケーション実装ファイル
.................... #include "application/mmj_cigs_excute_mission.c"
.................... #include "../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../hal/mmj_cigs_config.h"             // システム設定
.................... #ifndef MMJ_CIGS_CONFIG_H
.................... #define MMJ_CIGS_CONFIG_H
.................... 
.................... 
.................... #define SELF_DEVICE_ID CIGS_PIC
.................... 
.................... #include <18F67J94.h>
.................... //#include <16F1789.h>
.................... #opt 0 // 0 = no optimization, 1 = optimize for speed, 2 = optimize for size
.................... 
.................... #device ADC=12
.................... #use delay(crystal=16MHz)
.................... #fuses HS, NOWDT, NOBROWNOUT, NOPROTECT
.................... 
.................... #define PIC18
.................... //#define PIC16
.................... 
.................... 
.................... 
.................... #ifdef PIC16
....................     //#include <16F1789.h>
....................     #fuses NOMCLR
....................     //-------------Serial--------------------
....................     #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=BOSS)
....................     #use rs232(baud=9600,parity=N,xmit=PIN_B4,bits=8,stream=PC,FORCE_SW)
.................... 
.................... 
....................     // -------------SPI--------------------
....................     // MOSI:PIN_C5, MISO:PIN_C4, SCK:PIN_C3
....................     // Shared Mission Flash
....................     #define MIS_FM_CS  PIN_D3
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS= 8, STREAM = MIS_FM_STREAM)
.................... 
....................     // Mission Flash
....................     #define SMF_CS PIN_D1
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = SMF_STREAM)
....................     #use spi(MASTER, SPI1, BAUD = 100000, MODE = 0, BITS = 8, STREAM = spi_cell_write)
....................     // Analog to Digital Converter 
....................     #define ADC_CS PIN_D2
....................     //#use spi(MASTER, SPI1, BAUD = 9600, MODE=2, BITS = 16, STREAM = ADC_STREAM)
....................     #use spi(MASTER, CLK = PIN_C3, DI = PIN_C4, DO = PIN_C5, ENABLE = PIN_D2, BAUD = 57600, BITS = 16, STREAM = ADC_STREAM, MODE = 2 )
....................     
....................     
....................     // AI/O___ADC
....................     #define TEMP_TOP PIN_B0
....................     #define TEMP_BOT PIN_A3
....................     #define CIGS_VOLT PIN_A0 //PIN_A0
....................     #define CIGS_CURR PIN_A1
....................     #define PD PIN_E0
....................     #define VREF PIN_A4
....................  
....................     // AI/O___DAC
....................     #define LOAD PIN_A5
.................... 
....................     /* DEMO
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A0, MODE=0, BITS=8, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A1, MODE=0, BITS=8, ENABLE_ACTIVE=1, STREAM=MISF)
....................     #use spi (MASTER, SPI1, ENABLE=PIN_A3, BAUD=40000, MODE=2, BITS=16, ENABLE_ACTIVE=1, STREAM=ADC)
....................     #use spi (MASTER, MODE=0, BITS=8, STREAM=SPI_4)
....................     */
.................... #endif
.................... 
.................... #ifdef PIC18
....................     //#include <18F67J94.h>
....................     //-------------UART--------------------
....................     #pin_select TX3=PIN_E3                                                          
....................     #pin_select RX3=PIN_F2                                                        
....................     #use rs232(baud=9600, parity=N, UART3, bits=8, stream=BOSS, ERRORS)                      
....................     
.................... 
.................... //!    #pin_select TX1=PIN_E5
....................     // #use rs232(baud=9600,parity=N, xmit=PIN_E5, bits=8,stream=PC, ERRORS)
....................     #use rs232(baud=9600,parity=N, xmit=PIN_B6, bits=8, stream=PC)
.................... 
....................     // -------------SPI--------------------
....................     #define SMF_CS PIN_A2
....................     #define MIS_FM_CS  PIN_A5
.................... 
....................     #pin_select SCK1OUT=PIN_A3
....................     #pin_select SDI1=PIN_A0
....................     #pin_select SDO1=PIN_A1
....................     // #use spi (MASTER, SPI1, BAUD=100000, MODE=0, BITS=8, STREAM=SMF_STREAM)
....................     #use spi (MASTER, CLK=PIN_A3, DI=PIN_A1, DO=PIN_A0, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
....................     //#define MIS_FM_STREAM SMF_STREAM 
.................... 
....................     // #define MIS_FM_STREAM FLASH_STREAM PIN_E1
....................     #use spi (MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     // #use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, SPI1, BAUD=200000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
....................     //#use spi (MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1, BAUD=200000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... 
.................... 
....................     
.................... 
....................     #use spi (MASTER, CLK=PIN_B2, DI=PIN_B4, DO=PIN_B5,  BAUD=500000, MODE=2, BITS=16, STREAM=ADCDAC_STREAM)
....................     #define ADC_CS PIN_B1
....................     #define ADC_STREAM ADCDAC_STREAM
....................     #define DAC1_CS PIN_B3
....................     #define DAC1_STREAM ADCDAC_STREAM
....................     #define DAC2_CS PIN_B0
....................     #define DAC2_STREAM ADCDAC_STREAM
.................... 
....................     // DI/O___
....................     #define CONNECT_CIGS1 PIN_C0
....................     #define CONNECT_CIGS2 PIN_C5
....................     #define EN_NPWR PIN_C7
.................... 
.................... #endif
.................... 
.................... //-------------I/O port--------------------
.................... #use FIXED_IO( A_outputs=SMF_CS, MIS_FM_CS )
.................... #use FIXED_IO( B_outputs=ADC_CS, DAC1_CS, DAC2_CS )
.................... #use FIXED_IO( C_outputs=CONNECT_CIGS1, CONNECT_CIGS2, EN_NPWR )
.................... 
.................... 
.................... // ADC Settings
.................... #define ADC_CIGS1_VOLT      AD7490_VIN0
.................... #define ADC_CIGS1_CURR      AD7490_VIN1
.................... #define ADC_CIGS1_AMP       AD7490_VIN2
.................... #define ADC_CIGS1_VREF      AD7490_VIN3
.................... #define ADC_CIGS2_VOLT      AD7490_VIN4
.................... #define ADC_CIGS2_CURR      AD7490_VIN5
.................... #define ADC_CIGS2_AMP       AD7490_VIN6
.................... #define ADC_CIGS2_VREF      AD7490_VIN7
.................... #define ADC_CIGS1_DAC       AD7490_VIN8
.................... #define ADC_CIGS2_DAC       AD7490_VIN9
.................... #define EMPTY_VIN0          AD7490_VIN10
.................... #define EMPTY_VIN1          AD7490_VIN11
.................... #define ADC_TEMP_MIS7       AD7490_VIN12
.................... #define ADC_TEMP_PY_TOP     AD7490_VIN13
.................... #define ADC_TEMP_PY_BOT     AD7490_VIN14
.................... #define ADC_PD              AD7490_VIN15
.................... 
.................... #endif // MMJ_CIGS_CONFIG_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/communication/value_status.h"    // ステータス定義
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status[4] = {IDLE, 0, 0, 0};
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "mmj_cigs_excute_mission.h"                  // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_EXCUTE_MISSION_H
.................... #define MMJ_CIGS_EXCUTE_MISSION_H
.................... 
.................... // _________ values _________
.................... //#define PARAMETER_LENGTH 8
.................... #include "../lib/communication/mission_tools.h"
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command);
.................... 
.................... void handle_uplink_command(Command *command);
.................... 
.................... int1 handle_status_check(Command *command);
.................... 
.................... void handle_smf_available(Command *command);
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content);
.................... 
.................... int8 duration_sec = 30; // duration sec for mission
.................... 
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_test(unsigned int8 *uplinkcmd);
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... #define ID_MEAS_DEBUG 0xA6
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef union {
....................     unsigned int8 raw;
....................     struct {
....................         unsigned int8 mission_continue : 1;
....................         unsigned int8 erase_and_save : 1;
....................         unsigned int8 reserved : 6;
....................     } flag;
.................... } mission_state_t;
.................... 
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     mission_state_t mission_state; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... 
.................... #include "../domain/mmj_cigs_smf.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_SMF_H
.................... #define MMJ_CIGS_SMF_H
.................... 
.................... #include "../lib/tool/smf_queue.h"  // FlashOperationStruct定義
.................... 
.................... #define CRC_RETRY_COUNT 5
.................... 
.................... // SMF操作関数
.................... void smf_write(FlashOperationStruct *smf_data);
.................... void smf_read(FlashOperationStruct *smf_data);
.................... void smf_erase(FlashOperationStruct *smf_data);
.................... 
.................... // カウンター管理関数
.................... void update_misf_counters(int8 mission_id, int32 transfer_size);
.................... void reset_misf_counters(int8 mission_id);
.................... void print_misf_counter_status(int8 mission_id);
.................... 
.................... 
.................... 
.................... // SMF Partition Header
.................... typedef struct {
....................     int32 used_size;
....................     int32 loop_counter;
....................     int8 reserved[3];
.................... } SMF_PARTITION;
.................... 
.................... //
.................... typedef struct {
....................     SMF_PARTITION meas;
....................     SMF_PARTITION piclog;
....................     int32 write_bytes[4];
.................... } PartitionParam;
.................... 
.................... extern PartitionParam param;  // extern宣言に変更
.................... 
.................... 
.................... // MSB形式でpartition_headerに値を設定する関数
.................... void set_meas_used_size_msb(int32 value);
.................... void set_piclog_used_size_msb(int32 value);
.................... int32 get_meas_used_size_msb(void);
.................... int32 get_piclog_used_size_msb(void);
.................... 
.................... // mission_idから対応するSMF_PARTITIONを取得する関数
.................... SMF_PARTITION* get_smf_partition_by_mission_id(int8 mission_id);
.................... void update_smf_partition_by_mission_id(int8 mission_id, int32 used_size, int32 loop_counter);
.................... 
.................... 
.................... #endif  // MMJ_CIGS_SMF_H
.................... 
.................... #include "../lib/communication/typedef_content.h"    // 通信ライブラリ
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x01,
....................     DENY  = 0x00
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../lib/communication/mission_tools.h"      // ミッションツール
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... //unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "../domain/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/communication/communication_driver.h" // 通信ドライバー
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack(void);
.................... void transmit_status(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void execute_mission(int8 *content)
*
09D90:  MOVLB  1
09D92:  MOVF   xB9,W
09D94:  MOVWF  FE9
09D96:  MOVF   xBA,W
09D98:  MOVWF  FEA
09D9A:  MOVFF  FEF,1BB
.................... {
....................    // record to executed mission list
....................    int8 command_id = content[0];
....................    //unsigned int8 *parameter = &content[1];
....................       
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
09D9E:  MOVLW  0C
09DA0:  MOVWF  FF6
09DA2:  MOVLW  11
09DA4:  MOVWF  FF7
09DA6:  MOVLW  00
09DA8:  MOVWF  FF8
09DAA:  MOVLB  0
09DAC:  CALL   1D32
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
09DB0:  MOVLW  52
09DB2:  MOVWF  FF6
09DB4:  MOVLW  11
09DB6:  MOVWF  FF7
09DB8:  MOVLW  00
09DBA:  MOVWF  FF8
09DBC:  MOVLW  0C
09DBE:  MOVLB  3
09DC0:  MOVWF  x12
09DC2:  MOVLB  0
09DC4:  CALL   1D62
09DC8:  MOVFF  1BB,A39
09DCC:  MOVLW  37
09DCE:  MOVLB  A
09DD0:  MOVWF  x3A
09DD2:  MOVLB  0
09DD4:  CALL   1F60
09DD8:  MOVLW  60
09DDA:  MOVWF  FF6
09DDC:  MOVLW  11
09DDE:  MOVWF  FF7
09DE0:  MOVLW  00
09DE2:  MOVWF  FF8
09DE4:  MOVLW  04
09DE6:  MOVLB  3
09DE8:  MOVWF  x12
09DEA:  MOVLB  0
09DEC:  CALL   1D62
....................    switch(command_id)
09DF0:  MOVLB  1
09DF2:  MOVF   xBB,W
09DF4:  XORLW  10
09DF6:  MOVLB  0
09DF8:  BTFSC  FD8.2
09DFA:  GOTO   9EBA
09DFE:  XORLW  01
09E00:  BTFSC  FD8.2
09E02:  GOTO   9EBE
09E06:  XORLW  03
09E08:  BTFSC  FD8.2
09E0A:  GOTO   9EC2
09E0E:  XORLW  13
09E10:  BTFSC  FD8.2
09E12:  GOTO   9EC6
09E16:  XORLW  12
09E18:  BTFSC  FD8.2
09E1A:  GOTO   9ECA
09E1E:  XORLW  93
09E20:  BTFSC  FD8.2
09E22:  GOTO   9ECE
09E26:  XORLW  01
09E28:  BTFSC  FD8.2
09E2A:  GOTO   9EDE
09E2E:  XORLW  03
09E30:  BTFSC  FD8.2
09E32:  GOTO   9EEE
09E36:  XORLW  01
09E38:  BTFSC  FD8.2
09E3A:  GOTO   9EFE
09E3E:  XORLW  07
09E40:  BTFSC  FD8.2
09E42:  GOTO   9F0E
09E46:  XORLW  01
09E48:  BTFSC  FD8.2
09E4A:  GOTO   9F1E
09E4E:  XORLW  03
09E50:  BTFSC  FD8.2
09E52:  GOTO   9F2E
09E56:  XORLW  01
09E58:  BTFSC  FD8.2
09E5A:  GOTO   9F3E
09E5E:  XORLW  0F
09E60:  BTFSC  FD8.2
09E62:  GOTO   9F4E
09E66:  XORLW  18
09E68:  BTFSC  FD8.2
09E6A:  GOTO   9F5E
09E6E:  XORLW  01
09E70:  BTFSC  FD8.2
09E72:  GOTO   9F6E
09E76:  XORLW  03
09E78:  BTFSC  FD8.2
09E7A:  GOTO   9F7E
09E7E:  XORLW  01
09E80:  BTFSC  FD8.2
09E82:  GOTO   9F8E
09E86:  XORLW  07
09E88:  BTFSC  FD8.2
09E8A:  GOTO   9F9E
09E8E:  XORLW  01
09E90:  BTFSC  FD8.2
09E92:  GOTO   9FAE
09E96:  XORLW  03
09E98:  BTFSC  FD8.2
09E9A:  GOTO   9FBE
09E9E:  XORLW  30
09EA0:  BTFSC  FD8.2
09EA2:  GOTO   9FCE
09EA6:  XORLW  06
09EA8:  BTFSC  FD8.2
09EAA:  GOTO   9FDE
09EAE:  XORLW  04
09EB0:  BTFSC  FD8.2
09EB2:  GOTO   9FEE
09EB6:  GOTO   9FF2
....................    {
....................       case 0x10: // example command
....................          // mode_dummy(content);
....................          //mode_iv_meas_adc();
....................          break;
09EBA:  GOTO   A002
....................       case 0x11:
....................          // mode_test_iv(content);
....................          break;
09EBE:  GOTO   A002
....................       case 0x12:
....................          // test_adc();
....................          break;
09EC2:  GOTO   A002
....................       case 0x01:
....................          //mode_measure(content); // check if the flash is connected
....................          break;
09EC6:  GOTO   A002
....................       case 0x13:
....................          // mode_sweep_port1(content[1]); // Sweep Port 1 with the given step
....................          break;
09ECA:  GOTO   A002
.................... 
....................       // ___________________ MISF Commands ______________________
....................       case ID_MISF_ERASE_ALL:
....................          mode_misf_erase_all(content);
09ECE:  MOVFF  1BA,1BF
09ED2:  MOVFF  1B9,1BE
09ED6:  CALL   5460
....................          break;
09EDA:  GOTO   A002
....................       case ID_MISF_ERASE_1SECTOR:
....................          mode_misf_erase_1sector(content);
09EDE:  MOVFF  1BA,1BD
09EE2:  MOVFF  1B9,1BC
09EE6:  GOTO   553E
....................          break;
09EEA:  GOTO   A002
....................       case ID_MISF_ERASE_4kByte_SUBSECTOR:
....................          mode_misf_erase_4kbyte_subsector(content);
09EEE:  MOVFF  1BA,1BD
09EF2:  MOVFF  1B9,1BC
09EF6:  GOTO   5A30
....................          break;
09EFA:  GOTO   A002
....................       case ID_MISF_ERASE_64kByte_SUBSECTOR:
....................          mode_misf_erase_64kbyte_subsector(content);
09EFE:  MOVFF  1BA,1BD
09F02:  MOVFF  1B9,1BC
09F06:  GOTO   5BC2
....................          break;
09F0A:  GOTO   A002
....................       case ID_MISF_WRITE_DEMO:
....................          mode_misf_write_demo(content);
09F0E:  MOVFF  1BA,1BD
09F12:  MOVFF  1B9,1BC
09F16:  GOTO   5D34
....................          break;
09F1A:  GOTO   A002
....................       case ID_MISF_WRITE_4kByte_SUBSECTOR:
....................          mode_misf_write_4kbyte_subsector(content);
09F1E:  MOVFF  1BA,1BD
09F22:  MOVFF  1B9,1BC
09F26:  GOTO   616C
....................          break;
09F2A:  GOTO   A002
....................       case ID_MISF_READ:
....................          mode_misf_read(content);
09F2E:  MOVFF  1BA,1BD
09F32:  MOVFF  1B9,1BC
09F36:  GOTO   61E4
....................          break;
09F3A:  GOTO   A002
....................       case ID_MISF_READ_ADDRESS:
....................          mode_misf_read_address(content);
09F3E:  MOVFF  1BA,1BD
09F42:  MOVFF  1B9,1BC
09F46:  GOTO   66A8
....................          break;
09F4A:  GOTO   A002
....................       case ID_MISF_ERASE_AND_RESET:
....................          mode_misf_erase_and_reset(content);
09F4E:  MOVFF  1BA,1BD
09F52:  MOVFF  1B9,1BC
09F56:  GOTO   69A4
....................          break;
09F5A:  GOTO   A002
.................... 
....................       // ___________________ SMF Commands ______________________
....................       case ID_SMF_COPY:
....................          mode_smf_copy(content);
09F5E:  MOVFF  1BA,1BD
09F62:  MOVFF  1B9,1BC
09F66:  GOTO   69FC
....................          break;
09F6A:  GOTO   A002
....................       case ID_SMF_READ:
....................          mode_smf_read(content);
09F6E:  MOVFF  1BA,1BD
09F72:  MOVFF  1B9,1BC
09F76:  GOTO   6AD8
....................          break;
09F7A:  GOTO   A002
....................       case ID_SMF_ERASE:
....................          mode_smf_erase(content);
09F7E:  MOVFF  1BA,1BD
09F82:  MOVFF  1B9,1BC
09F86:  GOTO   6B94
....................          break;
09F8A:  GOTO   A002
....................       case ID_SMF_COPY_FORCE:
....................          mode_smf_address_reset(content);
09F8E:  MOVFF  1BA,1BD
09F92:  MOVFF  1B9,1BC
09F96:  CALL   6CC8
....................          break;
09F9A:  GOTO   A002
....................       case ID_SMF_READ_FORCE:
....................          mode_smf_read_force(content);
09F9E:  MOVFF  1BA,1BD
09FA2:  MOVFF  1B9,1BC
09FA6:  GOTO   6E48
....................          break;
09FAA:  GOTO   A002
....................       case ID_SMF_ERASE_FORCE:
....................          mode_smf_erase_force(content);
09FAE:  MOVFF  1BA,1BD
09FB2:  MOVFF  1B9,1BC
09FB6:  GOTO   726C
....................          break;
09FBA:  GOTO   A002
....................       case ID_SMF_RESET:
....................          mode_smf_address_reset(content);
09FBE:  MOVFF  1BA,1BD
09FC2:  MOVFF  1B9,1BC
09FC6:  CALL   6CC8
....................          break;
09FCA:  GOTO   A002
....................          
....................          
....................       // ________________MEAS________________________________
....................       case ID_MEAS_DEBUG:
....................          mode_iv_test(content);
09FCE:  MOVFF  1BA,1BD
09FD2:  MOVFF  1B9,1BC
09FD6:  GOTO   92AC
....................          break;
09FDA:  GOTO   A002
....................       case ID_MEAS_IV:
....................          mode_meas_iv(content);
09FDE:  MOVFF  1BA,1BD
09FE2:  MOVFF  1B9,1BC
09FE6:  GOTO   9844
....................          break;
09FEA:  GOTO   A002
....................       case ID_MEAS_ENVIRONMENT:
....................          //mode_meas_environment(content);
.................... 
....................          break;
09FEE:  GOTO   A002
....................             
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
09FF2:  MOVLW  66
09FF4:  MOVWF  FF6
09FF6:  MOVLW  11
09FF8:  MOVWF  FF7
09FFA:  MOVLW  00
09FFC:  MOVWF  FF8
09FFE:  CALL   1D32
....................          
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
0A002:  MOVLW  7E
0A004:  MOVWF  FF6
0A006:  MOVLW  11
0A008:  MOVWF  FF7
0A00A:  MOVLW  00
0A00C:  MOVWF  FF8
0A00E:  CALL   1D32
0A012:  GOTO   A080 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "Start execute_command\r\n");
*
0C21E:  MOVLW  C4
0C220:  MOVWF  FF6
0C222:  MOVLW  11
0C224:  MOVWF  FF7
0C226:  MOVLW  00
0C228:  MOVWF  FF8
0C22A:  CALL   1D32
....................    
....................    switch(command->frame_id)
0C22E:  MOVLB  1
0C230:  MOVF   xB3,W
0C232:  MOVWF  FE9
0C234:  MOVF   xB4,W
0C236:  MOVWF  FEA
0C238:  MOVF   FEF,W
0C23A:  XORLW  00
0C23C:  MOVLB  0
0C23E:  BTFSC  FD8.2
0C240:  GOTO   C258
0C244:  XORLW  01
0C246:  BTFSC  FD8.2
0C248:  GOTO   C268
0C24C:  XORLW  03
0C24E:  BTFSC  FD8.2
0C250:  GOTO   C288
0C254:  GOTO   C298
....................    {
....................       case UPLINK_COMMAND:
....................          handle_uplink_command(command);
0C258:  MOVFF  1B4,1B6
0C25C:  MOVFF  1B3,1B5
0C260:  GOTO   A034
....................          break;
0C264:  GOTO   C298
....................          
....................       case STATUS_CHECK:
....................          if (handle_status_check(command)){
0C268:  MOVFF  1B4,1B6
0C26C:  MOVFF  1B3,1B5
0C270:  GOTO   A0B6
0C274:  MOVF   01,F
0C276:  BTFSC  FD8.2
0C278:  GOTO   C284
....................             return TRUE; // if status is finished, return TRUE
0C27C:  MOVLW  01
0C27E:  MOVWF  01
0C280:  GOTO   C29C
....................          }        
....................          break;
0C284:  GOTO   C298
....................       
....................       case IS_SMF_AVAILABLE:
....................          handle_smf_available(command);
0C288:  MOVFF  1B4,1B6
0C28C:  MOVFF  1B3,1B5
0C290:  GOTO   BF2E
....................          break;
0C294:  GOTO   C298
....................    }
....................    return FALSE;
0C298:  MOVLW  00
0C29A:  MOVWF  01
0C29C:  GOTO   C7DC (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void handle_uplink_command(Command *command) {
....................    fprintf(PC, "\t-> Uplink command\r\n");
*
0A034:  MOVLW  DC
0A036:  MOVWF  FF6
0A038:  MOVLW  11
0A03A:  MOVWF  FF7
0A03C:  MOVLW  00
0A03E:  MOVWF  FF8
0A040:  CALL   1D32
....................    fprintf(PC, "\t   Transmit Acknolegde\r\n");
0A044:  MOVLW  F2
0A046:  MOVWF  FF6
0A048:  MOVLW  11
0A04A:  MOVWF  FF7
0A04C:  MOVLW  00
0A04E:  MOVWF  FF8
0A050:  CALL   1D32
....................    transmit_ack();
0A054:  CALL   544C
.................... 
....................    status[0] = EXECUTING_MISSION;
0A058:  MOVLW  02
0A05A:  MOVWF  48
....................    execute_mission(command->content);
0A05C:  MOVLW  03
0A05E:  MOVLB  1
0A060:  ADDWF  xB5,W
0A062:  MOVWF  01
0A064:  MOVLW  00
0A066:  ADDWFC xB6,W
0A068:  MOVWF  03
0A06A:  MOVF   01,W
0A06C:  MOVWF  xB7
0A06E:  MOVFF  03,1B8
0A072:  MOVFF  1B8,1BA
0A076:  MOVFF  1B7,1B9
0A07A:  MOVLB  0
0A07C:  GOTO   9D90
....................    if (is_empty_flash_queue())
0A080:  CALL   A016
0A084:  MOVF   01,F
0A086:  BTFSC  FD8.2
0A088:  GOTO   A094
....................       status[0] = FINISHED;
0A08C:  MOVLW  06
0A08E:  MOVWF  48
0A090:  GOTO   A098
....................    else
....................       status[0] = SMF_USE_REQ;
0A094:  MOVLW  04
0A096:  MOVWF  48
0A098:  GOTO   C264 (RETURN)
.................... 
....................    //return TRUE; // ここでTRUEを返すことで、実行後に何か処理をすることができる
....................    
.................... }
.................... 
.................... 
.................... int1 handle_status_check(Command *command) {
....................    fprintf(PC, "\t-> Status check\r\n");
*
0A0B6:  MOVLW  0C
0A0B8:  MOVWF  FF6
0A0BA:  MOVLW  12
0A0BC:  MOVWF  FF7
0A0BE:  MOVLW  00
0A0C0:  MOVWF  FF8
0A0C2:  CALL   1D32
....................    fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
0A0C6:  MOVLW  20
0A0C8:  MOVWF  FF6
0A0CA:  MOVLW  12
0A0CC:  MOVWF  FF7
0A0CE:  MOVLW  00
0A0D0:  MOVWF  FF8
0A0D2:  CALL   1D32
....................    transmit_status();
0A0D6:  GOTO   A09C
....................    if (status[0] == FINISHED)
0A0DA:  MOVF   48,W
0A0DC:  SUBLW  06
0A0DE:  BTFSS  FD8.2
0A0E0:  GOTO   A100
....................    {
....................       fprintf(PC, "finished in status_check\r\n");
0A0E4:  MOVLW  3E
0A0E6:  MOVWF  FF6
0A0E8:  MOVLW  12
0A0EA:  MOVWF  FF7
0A0EC:  MOVLW  00
0A0EE:  MOVWF  FF8
0A0F0:  CALL   1D32
....................       return TRUE;
0A0F4:  MOVLW  01
0A0F6:  MOVWF  01
0A0F8:  GOTO   A108
....................    }
0A0FC:  GOTO   A108
....................    else{
....................       return FALSE;
0A100:  MOVLW  00
0A102:  MOVWF  01
0A104:  GOTO   A108
....................    }
0A108:  GOTO   C274 (RETURN)
.................... }
.................... 
.................... 
.................... void handle_smf_available(Command *command)
.................... {
....................     fprintf(PC, "\t-> SMF available check\r\n");
*
0BF2E:  MOVLW  5A
0BF30:  MOVWF  FF6
0BF32:  MOVLW  12
0BF34:  MOVWF  FF7
0BF36:  MOVLW  00
0BF38:  MOVWF  FF8
0BF3A:  CALL   1D32
....................     fprintf(PC, "\t   Transmit Acknowledgement\r\n");
0BF3E:  MOVLW  74
0BF40:  MOVWF  FF6
0BF42:  MOVLW  12
0BF44:  MOVWF  FF7
0BF46:  MOVLW  00
0BF48:  MOVWF  FF8
0BF4A:  CALL   1D32
....................     transmit_ack();
0BF4E:  CALL   544C
.................... 
....................     if (command->content[0] != ALLOW) {
0BF52:  MOVLW  03
0BF54:  MOVLB  1
0BF56:  ADDWF  xB5,W
0BF58:  MOVWF  FE9
0BF5A:  MOVLW  00
0BF5C:  ADDWFC xB6,W
0BF5E:  MOVWF  FEA
0BF60:  DECFSZ FEF,W
0BF62:  BRA    BF68
0BF64:  BRA    BF6E
0BF66:  MOVLB  0
0BF68:  MOVLB  0
0BF6A:  GOTO   BF74
0BF6E:  MOVLB  0
0BF70:  GOTO   BF88
....................         fprintf(PC, "\t\t-> denied\r\n");
0BF74:  MOVLW  94
0BF76:  MOVWF  FF6
0BF78:  MOVLW  12
0BF7A:  MOVWF  FF7
0BF7C:  MOVLW  00
0BF7E:  MOVWF  FF8
0BF80:  CALL   1D32
....................         return;
0BF84:  GOTO   C21A
....................     }
.................... 
....................     fprintf(PC, "\t\t-> allowed\r\n");
0BF88:  MOVLW  A2
0BF8A:  MOVWF  FF6
0BF8C:  MOVLW  12
0BF8E:  MOVWF  FF7
0BF90:  MOVLW  00
0BF92:  MOVWF  FF8
0BF94:  CALL   1D32
....................     status[0] = COPYING;
0BF98:  MOVLW  05
0BF9A:  MOVWF  48
.................... 
....................     int8 processed_count = 0;
0BF9C:  MOVLB  1
0BF9E:  CLRF   xB7
0BFA0:  MOVLB  0
.................... 
....................     while (!is_empty_flash_queue()) {
0BFA2:  CALL   A016
0BFA6:  MOVF   01,F
0BFA8:  BTFSS  FD8.2
0BFAA:  GOTO   C1D6
....................         FlashOperationStruct *smf_data = dequeue_flash_operation();
0BFAE:  GOTO   A10C
0BFB2:  MOVFF  02,1B9
0BFB6:  MOVFF  01,1B8
....................         if (smf_data == NULL) {
0BFBA:  MOVLB  1
0BFBC:  MOVF   xB8,F
0BFBE:  BTFSC  FD8.2
0BFC0:  BRA    BFC8
0BFC2:  MOVLB  0
0BFC4:  GOTO   BFEE
0BFC8:  MOVLB  0
0BFCA:  MOVLB  1
0BFCC:  MOVF   xB9,F
0BFCE:  BTFSC  FD8.2
0BFD0:  BRA    BFD8
0BFD2:  MOVLB  0
0BFD4:  GOTO   BFEE
0BFD8:  MOVLB  0
....................             fprintf(PC, "\t\t-> dequeue NULL (break)\r\n");
0BFDA:  MOVLW  B2
0BFDC:  MOVWF  FF6
0BFDE:  MOVLW  12
0BFE0:  MOVWF  FF7
0BFE2:  MOVLW  00
0BFE4:  MOVWF  FF8
0BFE6:  CALL   1D32
....................             break;
0BFEA:  GOTO   C1D6
....................         }
.................... 
....................         fprintf(PC, "\t\t-> Dequeued: func=%u mission=%u size=%ld addr=%ld\r\n",
....................                 (unsigned int)smf_data->func_type,
....................                 (unsigned int)smf_data->mission_id,
....................                 smf_data->misf_size,
....................                 smf_data->misf_start_addr);
0BFEE:  MOVLW  01
0BFF0:  MOVLB  1
0BFF2:  ADDWF  xB8,W
0BFF4:  MOVWF  FE9
0BFF6:  MOVLW  00
0BFF8:  ADDWFC xB9,W
0BFFA:  MOVWF  FEA
0BFFC:  MOVFF  FEF,1BA
0C000:  MOVF   xB8,W
0C002:  MOVWF  FE9
0C004:  MOVF   xB9,W
0C006:  MOVWF  FEA
0C008:  MOVFF  FEF,1BB
0C00C:  MOVLW  08
0C00E:  ADDWF  xB8,W
0C010:  MOVWF  FE9
0C012:  MOVLW  00
0C014:  ADDWFC xB9,W
0C016:  MOVWF  FEA
0C018:  MOVFF  FEF,1BC
0C01C:  MOVFF  FEC,1BD
0C020:  MOVFF  FEC,1BE
0C024:  MOVFF  FEC,1BF
0C028:  MOVF   FED,F
0C02A:  MOVF   FED,F
0C02C:  MOVF   FED,F
0C02E:  MOVLW  04
0C030:  ADDWF  xB8,W
0C032:  MOVWF  FE9
0C034:  MOVLW  00
0C036:  ADDWFC xB9,W
0C038:  MOVWF  FEA
0C03A:  MOVFF  FEF,1C0
0C03E:  MOVFF  FEC,1C1
0C042:  MOVFF  FEC,1C2
0C046:  MOVFF  FEC,1C3
0C04A:  MOVF   FED,F
0C04C:  MOVF   FED,F
0C04E:  MOVF   FED,F
0C050:  MOVLW  CE
0C052:  MOVWF  FF6
0C054:  MOVLW  12
0C056:  MOVWF  FF7
0C058:  MOVLW  00
0C05A:  MOVWF  FF8
0C05C:  MOVLW  14
0C05E:  MOVLB  3
0C060:  MOVWF  x12
0C062:  MOVLB  0
0C064:  CALL   1D62
0C068:  MOVFF  1BA,293
0C06C:  MOVLW  1B
0C06E:  MOVLB  2
0C070:  MOVWF  x94
0C072:  MOVLB  0
0C074:  CALL   A1B6
0C078:  MOVLW  E4
0C07A:  MOVWF  FF6
0C07C:  MOVLW  12
0C07E:  MOVWF  FF7
0C080:  MOVLW  00
0C082:  MOVWF  FF8
0C084:  MOVLW  09
0C086:  MOVLB  3
0C088:  MOVWF  x12
0C08A:  MOVLB  0
0C08C:  CALL   1D62
0C090:  MOVFF  1BB,293
0C094:  MOVLW  1B
0C096:  MOVLB  2
0C098:  MOVWF  x94
0C09A:  MOVLB  0
0C09C:  CALL   A1B6
0C0A0:  MOVLW  EF
0C0A2:  MOVWF  FF6
0C0A4:  MOVLW  12
0C0A6:  MOVWF  FF7
0C0A8:  MOVLW  00
0C0AA:  MOVWF  FF8
0C0AC:  MOVLW  06
0C0AE:  MOVLB  3
0C0B0:  MOVWF  x12
0C0B2:  MOVLB  0
0C0B4:  CALL   1D62
0C0B8:  MOVLW  41
0C0BA:  MOVWF  FE9
0C0BC:  MOVFF  1BF,292
0C0C0:  MOVFF  1BE,291
0C0C4:  MOVFF  1BD,290
0C0C8:  MOVFF  1BC,28F
0C0CC:  CALL   A33A
0C0D0:  MOVLW  F8
0C0D2:  MOVWF  FF6
0C0D4:  MOVLW  12
0C0D6:  MOVWF  FF7
0C0D8:  MOVLW  00
0C0DA:  MOVWF  FF8
0C0DC:  MOVLW  06
0C0DE:  MOVLB  3
0C0E0:  MOVWF  x12
0C0E2:  MOVLB  0
0C0E4:  CALL   1D62
0C0E8:  MOVLW  41
0C0EA:  MOVWF  FE9
0C0EC:  MOVFF  1C3,292
0C0F0:  MOVFF  1C2,291
0C0F4:  MOVFF  1C1,290
0C0F8:  MOVFF  1C0,28F
0C0FC:  CALL   A33A
0C100:  MOVLW  0D
0C102:  MOVLB  A
0C104:  MOVWF  xDB
0C106:  MOVLB  0
0C108:  CALL   1CE0
0C10C:  MOVLW  0A
0C10E:  MOVLB  A
0C110:  MOVWF  xDB
0C112:  MOVLB  0
0C114:  CALL   1CE0
.................... 
....................         switch (smf_data->func_type) {
0C118:  MOVLW  01
0C11A:  MOVLB  1
0C11C:  ADDWF  xB8,W
0C11E:  MOVWF  FE9
0C120:  MOVLW  00
0C122:  ADDWFC xB9,W
0C124:  MOVWF  FEA
0C126:  MOVF   FEF,W
0C128:  XORLW  00
0C12A:  MOVLB  0
0C12C:  BTFSC  FD8.2
0C12E:  GOTO   C146
0C132:  XORLW  01
0C134:  BTFSC  FD8.2
0C136:  GOTO   C156
0C13A:  XORLW  03
0C13C:  BTFSC  FD8.2
0C13E:  GOTO   C166
0C142:  GOTO   C176
....................             case ENUM_SMF_WRITE:
....................                 smf_write(smf_data);
0C146:  MOVFF  1B9,1BB
0C14A:  MOVFF  1B8,1BA
0C14E:  GOTO   AB6C
....................                 break;
0C152:  GOTO   C1CC
....................             case ENUM_SMF_READ:
....................                 smf_read(smf_data);
0C156:  MOVFF  1B9,1BB
0C15A:  MOVFF  1B8,1BA
0C15E:  GOTO   B680
....................                 break;
0C162:  GOTO   C1CC
....................             case ENUM_SMF_ERASE:
....................                 smf_erase(smf_data);
0C166:  MOVFF  1B9,1BB
0C16A:  MOVFF  1B8,1BA
0C16E:  GOTO   BA10
....................                 break;
0C172:  GOTO   C1CC
....................             default:
....................                 fprintf(PC, "\t\t   Unknown func_type=%u\r\n",
....................                         (unsigned int)smf_data->func_type);
0C176:  MOVLW  01
0C178:  MOVLB  1
0C17A:  ADDWF  xB8,W
0C17C:  MOVWF  FE9
0C17E:  MOVLW  00
0C180:  ADDWFC xB9,W
0C182:  MOVWF  FEA
0C184:  MOVFF  FEF,1BA
0C188:  MOVLW  04
0C18A:  MOVWF  FF6
0C18C:  MOVLW  13
0C18E:  MOVWF  FF7
0C190:  MOVLW  00
0C192:  MOVWF  FF8
0C194:  MOVLW  17
0C196:  MOVLB  3
0C198:  MOVWF  x12
0C19A:  MOVLB  0
0C19C:  CALL   1D62
0C1A0:  MOVFF  1BA,293
0C1A4:  MOVLW  1B
0C1A6:  MOVLB  2
0C1A8:  MOVWF  x94
0C1AA:  MOVLB  0
0C1AC:  CALL   A1B6
0C1B0:  MOVLW  0D
0C1B2:  MOVLB  A
0C1B4:  MOVWF  xDB
0C1B6:  MOVLB  0
0C1B8:  CALL   1CE0
0C1BC:  MOVLW  0A
0C1BE:  MOVLB  A
0C1C0:  MOVWF  xDB
0C1C2:  MOVLB  0
0C1C4:  CALL   1CE0
....................                 break;
0C1C8:  GOTO   C1CC
....................         }
....................         processed_count++;
0C1CC:  MOVLB  1
0C1CE:  INCF   xB7,F
0C1D0:  MOVLB  0
0C1D2:  GOTO   BFA2
....................     }
.................... 
....................     fprintf(PC, "\t\t-> Completed %u operations\r\n",
....................             (unsigned int)processed_count);
0C1D6:  MOVLW  20
0C1D8:  MOVWF  FF6
0C1DA:  MOVLW  13
0C1DC:  MOVWF  FF7
0C1DE:  MOVLW  00
0C1E0:  MOVWF  FF8
0C1E2:  MOVLW  0F
0C1E4:  MOVLB  3
0C1E6:  MOVWF  x12
0C1E8:  MOVLB  0
0C1EA:  CALL   1D62
0C1EE:  MOVFF  1B7,293
0C1F2:  MOVLW  1B
0C1F4:  MOVLB  2
0C1F6:  MOVWF  x94
0C1F8:  MOVLB  0
0C1FA:  CALL   A1B6
0C1FE:  MOVLW  31
0C200:  MOVWF  FF6
0C202:  MOVLW  13
0C204:  MOVWF  FF7
0C206:  MOVLW  00
0C208:  MOVWF  FF8
0C20A:  MOVLW  0D
0C20C:  MOVLB  3
0C20E:  MOVWF  x12
0C210:  MOVLB  0
0C212:  CALL   1D62
.................... 
....................     status[0] = FINISHED;
0C216:  MOVLW  06
0C218:  MOVWF  48
0C21A:  GOTO   C294 (RETURN)
.................... }
.................... // End of file
.................... 
.................... #include "application/mmj_cigs_mode_mission.c"
.................... #include "mmj_cigs_mode_mission.h"                    // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_MISSION_H
.................... #define MMJ_CIGS_MODE_MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 9
.................... 
.................... // ___________MODE FUNCTIONS____________
.................... 
.................... 
.................... void mode_dummy(unsigned int8 uplinkcmd[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 param1;
....................     unsigned int16 param2;
.................... } DUMMY_CMD;
.................... 
.................... // IV command
.................... 
.................... void mode_iv_measure();
.................... 
.................... void mode_iv_test(unsigned int8 *uplinkcmd);
.................... 
.................... void mode_iv_measure_voltage();
.................... 
.................... void mode_iv_meas_adc();
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd);
.................... 
.................... // ______________CMD ID________________
.................... 
.................... // IV command
.................... #define ID_IV_MEASURE 0xB0
.................... #define ID_IV_MEASURE_VOLTAGE 0xB1
.................... 
.................... // Development command
.................... #define ID_MEAS_IV 0xA0
.................... #define ID_MEAS_IV_CURR_SELECT 0xA1
.................... #define ID_MEAS_IV_PD_SELECT 0xA2
.................... #define ID_MEAS_IV_CURR_AND_PD_SELECT 0xA3
.................... #define ID_MEAS_ENVIRONMENT 0xA4
.................... #define ID_MEAS_ENVIRONMENT_DEBUG 0xA5
.................... #define ID_MEAS_DEBUG 0xA6
.................... 
.................... void mode_meas_iv(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_iv_curr_and_pd_select(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment(unsigned int8 uplinkcmd[]);
.................... void mode_meas_environment_debug(unsigned int8 uplinkcmd[]);
.................... 
.................... typedef union {
....................     unsigned int8 raw;
....................     struct {
....................         unsigned int8 mission_continue : 1;
....................         unsigned int8 erase_and_save : 1;
....................         unsigned int8 reserved : 6;
....................     } flag;
.................... } mission_state_t;
.................... 
.................... 
.................... typedef struct {
....................     unsigned int8 id; // Command ID
....................     unsigned int16 sleep_time; // Sleep time in milliseconds
....................     unsigned int16 curr_threshold; // Current threshold for measurement
....................     unsigned int16 pd_threshold; // PD threshold for measurement
....................     unsigned int16 curr_limit; // Current limit for measurement
....................     unsigned int16 meas_time; // Measurement time in milliseconds
....................     mission_state_t mission_state; // Flag to indicate if the measurement is finished
.................... } MEAS_IV_CMD;
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 uplinkcmd[]);
.................... 
.................... 
.................... 
.................... 
.................... #define ID_DEV_CUR 0xC1
.................... #define ID_DEV_TEMP 0xC1
.................... #define ID_DEV_PD 0xC2
.................... #define ID_DEV_CIGS 0xC3
.................... #define ID_DEV_TIME 0xC4
.................... #define ID_DEV_SWEEP 0xC5
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif // MMJ_CIGS_MODE_MISSION_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../lib/device/ad7490.h"                    // ADCライブラリ
.................... #ifndef  AD7490_H
.................... #define  AD7490_H
.................... 
.................... 
.................... typedef union {
....................     unsigned int16 value; // 16-bit value for direct access
....................     struct {
....................         int1 reserved0; // Reserved bits
....................         int1 reserved1; // Reserved bits
....................         int1 reserved2; // Reserved bits
....................         int1 reserved3; // Reserved bits   
....................         int1 coding; // 1: Two's complement, 0: Binary
....................         int1 range; // 1: Range mode, 0: Normal mode
....................         int1 weak_tri; // 1: Weak trigger, 0: Strong trigger
....................         int1 shadow; // 1: Shadow register, 0: Direct access
....................         int1 pm0;
....................         int1 pm1; // Power mode bits
....................         int1 add0;
....................         int1 add1; // Channel address bits
....................         int1 add2;
....................         int1 add3; // Channel address bits
....................         int1 seq; // 1: Sequential mode, 0: Random mode
....................         int1 write; // 1: Write operation, 0: Read operation
.................... 
....................     } fields;
.................... } ad7490_cmd_t;
.................... 
.................... // Public Function 
.................... //void ad7490_init(void);
.................... unsigned int16 ad7490_make_cmd(int8 channel);
.................... 
.................... 
.................... // Resistor Settings
.................... #define AD7490_EN_WRITE 0b1
.................... 
.................... // Power Mode Register
.................... #define AD7490_PM_NORMAL 0b00000000
.................... #define AD7490_PM_SHUTDOWN 0b00000001
.................... #define AD7490_PM_AUTO_SHUTDOWN 0b00000010
.................... #define AD7490_PM_AUTO_STANDBY 0b00000011
.................... 
.................... 
.................... // ADC Channel Register
.................... #define AD7490_VIN0 0b0000
.................... #define AD7490_VIN1 0b0001
.................... #define AD7490_VIN2 0b0010
.................... #define AD7490_VIN3 0b0011
.................... #define AD7490_VIN4 0b0100
.................... #define AD7490_VIN5 0b0101
.................... #define AD7490_VIN6 0b0110
.................... #define AD7490_VIN7 0b0111
.................... #define AD7490_VIN8 0b1000
.................... #define AD7490_VIN9 0b1001
.................... #define AD7490_VIN10 0b1010
.................... #define AD7490_VIN11 0b1011
.................... #define AD7490_VIN12 0b1100
.................... #define AD7490_VIN13 0b1101
.................... #define AD7490_VIN14 0b1110
.................... #define AD7490_VIN15 0b1111
.................... 
.................... 
.................... 
.................... 
.................... #endif // AD7490_H
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... // ___________________ Mode Functions ______________________
.................... void mode_dummy(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start MODE DUMMY\r\n");
.................... 
....................    DUMMY_CMD dummy_cmd;
....................    dummy_cmd.id = uplinkcmd[0]; // Get the command ID from the uplink command
....................    dummy_cmd.param1 = 
....................       ((unsigned int32)uplinkcmd[1] << 24) |
....................       ((unsigned int32)uplinkcmd[2] << 16) |
....................       ((unsigned int32)uplinkcmd[3] << 8)  |
....................       ((unsigned int32)uplinkcmd[4]);
....................    dummy_cmd.param2 = 
....................       ((unsigned int16)uplinkcmd[5] << 8) |
....................       ((unsigned int16)uplinkcmd[6]);
....................    fprintf(PC, "\tMODE     : %02X\r\n", dummy_cmd.id);
....................    fprintf(PC, "\tParam1   : 0x%08LX\r\n", dummy_cmd.param1);
....................    fprintf(PC, "\tParam2   : 0x%04LX\r\n", dummy_cmd.param2);
.................... 
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_START); // Log the command execution
.................... 
....................    // This is a dummy function for testing purposes
....................    // You can add your own code here
....................    piclog_make(dummy_cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
....................    fprintf(PC, "End MODE DUMMY\r\n");
.................... }
.................... 
.................... 
.................... void mode_test_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
....................    output_high(CONNECT_CIGS1);
....................    output_low(EN_NPWR); // Enable NPWR
....................    unsigned int16 readdata;
.................... 
....................    test_sweep(cmd.curr_threshold,cmd.curr_limit); // Call the sweep function with the measurement step
.................... 
....................    fprintf(PC, "End MODE TEST IV\r\n");
....................    output_low(CONNECT_CIGS1);
....................    output_high(EN_NPWR); // Disable NPWR
.................... }
.................... 
.................... // _________________ Oparation Mode ______________________
.................... /*
.................... void mode_measure(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start MODE MEASURE\r\n");
.................... 
.................... 
....................    unsigned int8 sweep_step = parameter[0]; // Get the measurement step from the parameter array
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
....................    //adc_init();
....................    for (unsigned int8 count = 0; count < 40; count++)
....................    {
....................       // set DAC value
....................       //dac_write(count);
....................       delay_ms(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       data_buffer[count*2] = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................       data_buffer[count*2+1] = ad7490_read(AD7490_VIN1); // read current at adc pin
.................... 
....................       // monitoring
....................       fprintf(PC, "%04LX,%04LX\r\n", data_buffer[count*2], data_buffer[count*2+1]);
....................    }
....................    
....................    
.................... }
.................... */
.................... 
.................... /*
.................... void mode_iv_meas_adc()
.................... {
.................... 
....................    fprintf(PC, "Start SWEEP\r\n");
....................    unsigned int8 measurement_step = 100; // Get the measurement step from the parameter array
....................    fprintf(PC, "\tSweep step : %u\r\n", measurement_step);
....................    output_high(CONNECT_CIGS1);
.................... 
....................    // read temperature
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_top = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    delay_us(10); // wait for the ADC to stabilize
....................    measured_temp_bot = ad7490_read(AD7490_VIN0); // read voltage at adc pin
....................    unsigned int32 current;   
....................     // read PD value
.................... 
....................     delay_us(10); // wait for the ADC to stabilize
....................     // = ad7490_read(AD7490_VIN0); // voltage at adc pin
....................     
....................     // read timestamp
....................     //measured_time = timer0_get_time(); // read time from timer0
.................... 
....................    // CIGS value
....................    for (unsigned int16 count = 0; count < measurement_step; count++)
....................    {    
....................       // set DAC value
....................       //dac_write(count);
....................       delay_us(100); // wait for the DAC to stabilize
.................... 
....................       // read CIGS voltage and current
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2] =ad7490_read(AD7490_VIN0);  // read voltage at adc pin
....................       
....................       current = 0; // reset current value
....................       for(int k=0; k<10; k++)
....................       {
....................                                           //  routing nth channel to adc//verYOMOGI 20220214update,byUCHIDA
....................             delay_us(10);
....................             current = current + ad7490_read(AD7490_VIN0); 
....................       }    
....................       
....................       current = current / 10; // average the current value
.................... 
....................       delay_us(10); // wait for the ADC to stabilize
....................       data_buffer[count*2+1] = current; // store the current value in the buffer
....................       //data_buffer[count*2+1] = read_adc(ADC_START_AND_READ); // read voltage at adc pin
....................    }
.................... 
....................    fprintf(PC, "END SWEEP\r\n");
....................    // read PD value
....................    //measured_pd_end = read_adc(ADC_START_AND_READ); // read voltage at adc pin
.................... 
....................    //convert_cigs_data(measurement_step);
....................    //convert_header_data();    
....................    output_low(CONNECT_CIGS1);
.................... }
.................... */
.................... 
.................... void mode_sweep_port1(unsigned int8 uplinkcmd)
.................... {
.................... //!   sweep_port1(80);
....................    FlashOperationStruct data;
....................    data.func_type = ENUM_SMF_WRITE;
....................    data.mission_id = 0x01;
....................    data.write_mode = SMF_WRITE_CIRCULAR;
....................    data.source_type = SOURCE_MISF_UNCOPIED;
....................    //data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    //data.size = cigs_counters.counters.misf_meas_uncopyed_counter; // コピーするデータのサイズ
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
.................... }
.................... 
.................... 
.................... void mode_meas_iv(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE MEAS IV\r\n");
*
09844:  MOVLW  68
09846:  MOVWF  FF6
09848:  MOVLW  14
0984A:  MOVWF  FF7
0984C:  MOVLW  00
0984E:  MOVWF  FF8
09850:  CALL   1D32
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
09854:  MOVFF  1BD,1E1
09858:  MOVFF  1BC,1E0
0985C:  CALL   7358
09860:  MOVFF  02,03
09864:  MOVF   01,W
09866:  MOVWF  FE1
09868:  MOVFF  03,FE2
0986C:  MOVLW  01
0986E:  MOVWF  FEA
09870:  MOVLW  BE
09872:  MOVWF  FE9
09874:  MOVLW  0C
09876:  MOVWF  01
09878:  MOVFF  FE6,FEE
0987C:  DECFSZ 01,F
0987E:  GOTO   9878
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
09882:  MOVLW  7E
09884:  MOVWF  FF6
09886:  MOVLW  14
09888:  MOVWF  FF7
0988A:  MOVLW  00
0988C:  MOVWF  FF8
0988E:  MOVLW  05
09890:  MOVLB  3
09892:  MOVWF  x12
09894:  MOVLB  0
09896:  CALL   1D62
0989A:  MOVFF  1BE,A39
0989E:  MOVLW  37
098A0:  MOVLB  A
098A2:  MOVWF  x3A
098A4:  MOVLB  0
098A6:  CALL   1F60
098AA:  MOVLW  0D
098AC:  MOVLB  A
098AE:  MOVWF  xDB
098B0:  MOVLB  0
098B2:  CALL   1CE0
098B6:  MOVLW  0A
098B8:  MOVLB  A
098BA:  MOVWF  xDB
098BC:  MOVLB  0
098BE:  CALL   1CE0
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
098C2:  MOVLW  8A
098C4:  MOVWF  FF6
098C6:  MOVLW  14
098C8:  MOVWF  FF7
098CA:  MOVLW  00
098CC:  MOVWF  FF8
098CE:  MOVLW  0D
098D0:  MOVLB  3
098D2:  MOVWF  x12
098D4:  MOVLB  0
098D6:  CALL   1D62
098DA:  MOVFF  1C0,A39
098DE:  MOVLW  37
098E0:  MOVLB  A
098E2:  MOVWF  x3A
098E4:  MOVLB  0
098E6:  CALL   1F60
098EA:  MOVFF  1BF,A39
098EE:  MOVLW  37
098F0:  MOVLB  A
098F2:  MOVWF  x3A
098F4:  MOVLB  0
098F6:  CALL   1F60
098FA:  MOVLW  9C
098FC:  MOVWF  FF6
098FE:  MOVLW  14
09900:  MOVWF  FF7
09902:  MOVLW  00
09904:  MOVWF  FF8
09906:  MOVLW  05
09908:  MOVLB  3
0990A:  MOVWF  x12
0990C:  MOVLB  0
0990E:  CALL   1D62
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
09912:  MOVLW  A2
09914:  MOVWF  FF6
09916:  MOVLW  14
09918:  MOVWF  FF7
0991A:  MOVLW  00
0991C:  MOVWF  FF8
0991E:  MOVLW  14
09920:  MOVLB  3
09922:  MOVWF  x12
09924:  MOVLB  0
09926:  CALL   1D62
0992A:  MOVFF  1C2,A39
0992E:  MOVLW  37
09930:  MOVLB  A
09932:  MOVWF  x3A
09934:  MOVLB  0
09936:  CALL   1F60
0993A:  MOVFF  1C1,A39
0993E:  MOVLW  37
09940:  MOVLB  A
09942:  MOVWF  x3A
09944:  MOVLB  0
09946:  CALL   1F60
0994A:  MOVLW  BB
0994C:  MOVWF  FF6
0994E:  MOVLW  14
09950:  MOVWF  FF7
09952:  MOVLW  00
09954:  MOVWF  FF8
09956:  MOVLW  05
09958:  MOVLB  3
0995A:  MOVWF  x12
0995C:  MOVLB  0
0995E:  CALL   1D62
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
09962:  MOVLW  C2
09964:  MOVWF  FF6
09966:  MOVLW  14
09968:  MOVWF  FF7
0996A:  MOVLW  00
0996C:  MOVWF  FF8
0996E:  MOVLW  0F
09970:  MOVLB  3
09972:  MOVWF  x12
09974:  MOVLB  0
09976:  CALL   1D62
0997A:  MOVFF  1C4,A39
0997E:  MOVLW  37
09980:  MOVLB  A
09982:  MOVWF  x3A
09984:  MOVLB  0
09986:  CALL   1F60
0998A:  MOVFF  1C3,A39
0998E:  MOVLW  37
09990:  MOVLB  A
09992:  MOVWF  x3A
09994:  MOVLB  0
09996:  CALL   1F60
0999A:  MOVLW  D6
0999C:  MOVWF  FF6
0999E:  MOVLW  14
099A0:  MOVWF  FF7
099A2:  MOVLW  00
099A4:  MOVWF  FF8
099A6:  MOVLW  05
099A8:  MOVLB  3
099AA:  MOVWF  x12
099AC:  MOVLB  0
099AE:  CALL   1D62
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
099B2:  MOVLW  DC
099B4:  MOVWF  FF6
099B6:  MOVLW  14
099B8:  MOVWF  FF7
099BA:  MOVLW  00
099BC:  MOVWF  FF8
099BE:  MOVLW  10
099C0:  MOVLB  3
099C2:  MOVWF  x12
099C4:  MOVLB  0
099C6:  CALL   1D62
099CA:  MOVFF  1C6,A39
099CE:  MOVLW  37
099D0:  MOVLB  A
099D2:  MOVWF  x3A
099D4:  MOVLB  0
099D6:  CALL   1F60
099DA:  MOVFF  1C5,A39
099DE:  MOVLW  37
099E0:  MOVLB  A
099E2:  MOVWF  x3A
099E4:  MOVLB  0
099E6:  CALL   1F60
099EA:  MOVLW  F1
099EC:  MOVWF  FF6
099EE:  MOVLW  14
099F0:  MOVWF  FF7
099F2:  MOVLW  00
099F4:  MOVWF  FF8
099F6:  MOVLW  05
099F8:  MOVLB  3
099FA:  MOVWF  x12
099FC:  MOVLB  0
099FE:  CALL   1D62
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
09A02:  MOVLW  F8
09A04:  MOVWF  FF6
09A06:  MOVLW  14
09A08:  MOVWF  FF7
09A0A:  MOVLW  00
09A0C:  MOVWF  FF8
09A0E:  MOVLW  13
09A10:  MOVLB  3
09A12:  MOVWF  x12
09A14:  MOVLB  0
09A16:  CALL   1D62
09A1A:  MOVFF  1C8,A39
09A1E:  MOVLW  37
09A20:  MOVLB  A
09A22:  MOVWF  x3A
09A24:  MOVLB  0
09A26:  CALL   1F60
09A2A:  MOVFF  1C7,A39
09A2E:  MOVLW  37
09A30:  MOVLB  A
09A32:  MOVWF  x3A
09A34:  MOVLB  0
09A36:  CALL   1F60
09A3A:  MOVLW  10
09A3C:  MOVWF  FF6
09A3E:  MOVLW  15
09A40:  MOVWF  FF7
09A42:  MOVLW  00
09A44:  MOVWF  FF8
09A46:  MOVLW  04
09A48:  MOVLB  3
09A4A:  MOVWF  x12
09A4C:  MOVLB  0
09A4E:  CALL   1D62
.................... //!   fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
09A52:  MOVFF  1BE,20F
09A56:  MOVLB  2
09A58:  CLRF   x10
09A5A:  MOVLB  0
09A5C:  CALL   4A82
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
09A60:  CALL   3C66
09A64:  MOVFF  01,1CB
09A68:  MOVFF  00,1CA
09A6C:  MOVLB  1
09A6E:  CLRF   xCD
09A70:  CLRF   xCC
09A72:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
09A74:  CALL   3C66
09A78:  MOVFF  03,1DD
09A7C:  MOVFF  02,1DC
09A80:  MOVFF  01,1DB
09A84:  MOVFF  00,1DA
09A88:  MOVLB  1
09A8A:  MOVF   xCA,W
09A8C:  SUBWF  xDA,F
09A8E:  MOVF   xCB,W
09A90:  SUBWFB xDB,F
09A92:  MOVLW  00
09A94:  SUBWFB xDC,F
09A96:  MOVLW  00
09A98:  SUBWFB xDD,F
09A9A:  MOVF   xDD,F
09A9C:  BTFSC  FD8.2
09A9E:  BRA    9AA6
09AA0:  MOVLB  0
09AA2:  GOTO   9B54
09AA6:  MOVLB  0
09AA8:  MOVLB  1
09AAA:  MOVF   xDC,F
09AAC:  BTFSC  FD8.2
09AAE:  BRA    9AB6
09AB0:  MOVLB  0
09AB2:  GOTO   9B54
09AB6:  MOVLB  0
09AB8:  MOVLB  1
09ABA:  MOVF   xDB,W
09ABC:  SUBWF  xC8,W
09ABE:  BTFSC  FD8.0
09AC0:  BRA    9AC8
09AC2:  MOVLB  0
09AC4:  GOTO   9B54
09AC8:  MOVLB  0
09ACA:  BTFSS  FD8.2
09ACC:  GOTO   9AE2
09AD0:  MOVLB  1
09AD2:  MOVF   xC7,W
09AD4:  SUBWF  xDA,W
09AD6:  BTFSS  FD8.0
09AD8:  BRA    9AE0
09ADA:  MOVLB  0
09ADC:  GOTO   9B54
09AE0:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
09AE2:  CALL   3C66
09AE6:  MOVFF  01,1CD
09AEA:  MOVFF  00,1CC
....................       if (current_sec - start_time >= cmd.meas_time) {
09AEE:  MOVLB  1
09AF0:  MOVF   xCA,W
09AF2:  SUBWF  xCC,W
09AF4:  MOVWF  xDA
09AF6:  MOVF   xCB,W
09AF8:  SUBWFB xCD,W
09AFA:  MOVWF  xDB
09AFC:  MOVF   xC8,W
09AFE:  SUBWF  xDB,W
09B00:  BTFSC  FD8.0
09B02:  BRA    9B0A
09B04:  MOVLB  0
09B06:  GOTO   9B28
09B0A:  MOVLB  0
09B0C:  BTFSS  FD8.2
09B0E:  GOTO   9B24
09B12:  MOVLB  1
09B14:  MOVF   xC7,W
09B16:  SUBWF  xDA,W
09B18:  BTFSC  FD8.0
09B1A:  BRA    9B22
09B1C:  MOVLB  0
09B1E:  GOTO   9B28
09B22:  MOVLB  0
....................           break;
09B24:  GOTO   9B54
....................       }
....................       //sweep(cmd.curr_threshold, cmd.pd_threshold, cmd.curr_limit); // Perform the sweep with thresholds
....................       delay_ms(cmd.sleep_time);
09B28:  MOVFF  1C0,1DA
09B2C:  MOVLB  1
09B2E:  INCF   xDA,F
09B30:  MOVLB  0
09B32:  MOVLB  1
09B34:  DECFSZ xDA,F
09B36:  BRA    9B3C
09B38:  MOVLB  0
09B3A:  BRA    9B48
09B3C:  MOVLB  A
09B3E:  SETF   x94
09B40:  MOVLB  0
09B42:  CALL   1CB2
09B46:  BRA    9B32
09B48:  MOVFF  1BF,A94
09B4C:  CALL   1CB2
09B50:  GOTO   9A74
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
09B54:  MOVFF  1BE,20F
09B58:  MOVLB  2
09B5A:  SETF   x10
09B5C:  MOVLB  0
09B5E:  CALL   4A82
.................... 
....................    FlashOperationStruct data = {0};
09B62:  MOVLB  1
09B64:  CLRF   xCE
09B66:  CLRF   xCF
09B68:  CLRF   xD0
09B6A:  CLRF   xD1
09B6C:  CLRF   xD2
09B6E:  CLRF   xD3
09B70:  CLRF   xD4
09B72:  CLRF   xD5
09B74:  CLRF   xD6
09B76:  CLRF   xD7
09B78:  CLRF   xD8
09B7A:  CLRF   xD9
....................    data.func_type = ENUM_SMF_WRITE;
09B7C:  CLRF   xCF
....................    data.mission_id = CIGS_IV1_DATA; // ID_CIGS_MEASURE_DATA; // コピーする目的のデータ種別
09B7E:  MOVLW  04
09B80:  MOVWF  xCE
....................    data.write_mode = SMF_WRITE_CIRCULAR;
09B82:  MOVLW  02
09B84:  MOVWF  xD0
....................    data.source_type = SOURCE_MISF_UNCOPIED;
09B86:  BCF    xD1.0
....................    // data.src = ADDRESS_MISF_MEASUREMENT_START + cigs_counters.counters.misf_meas_use_counter - cigs_counters.counters.misf_meas_uncopyed_counter; // コピー元のMIS_FMのアドレス
....................    // data.size = 0; // コピーするデータのサイズ
.................... 
....................    fprintf(PC, "Enqueue Flash Operation\r\n");
09B88:  MOVLW  16
09B8A:  MOVWF  FF6
09B8C:  MOVLW  15
09B8E:  MOVWF  FF7
09B90:  MOVLW  00
09B92:  MOVWF  FF8
09B94:  MOVLB  0
09B96:  CALL   1D32
....................    fprintf(PC, "Mission ID:   %02X\r\n", data.mission_id);
09B9A:  MOVLW  30
09B9C:  MOVWF  FF6
09B9E:  MOVLW  15
09BA0:  MOVWF  FF7
09BA2:  MOVLW  00
09BA4:  MOVWF  FF8
09BA6:  MOVLW  0E
09BA8:  MOVLB  3
09BAA:  MOVWF  x12
09BAC:  MOVLB  0
09BAE:  CALL   1D62
09BB2:  MOVFF  1CE,A39
09BB6:  MOVLW  37
09BB8:  MOVLB  A
09BBA:  MOVWF  x3A
09BBC:  MOVLB  0
09BBE:  CALL   1F60
09BC2:  MOVLW  0D
09BC4:  MOVLB  A
09BC6:  MOVWF  xDB
09BC8:  MOVLB  0
09BCA:  CALL   1CE0
09BCE:  MOVLW  0A
09BD0:  MOVLB  A
09BD2:  MOVWF  xDB
09BD4:  MOVLB  0
09BD6:  CALL   1CE0
....................    fprintf(PC, "Function Type:%02X\r\n", data.func_type);
09BDA:  MOVLW  46
09BDC:  MOVWF  FF6
09BDE:  MOVLW  15
09BE0:  MOVWF  FF7
09BE2:  MOVLW  00
09BE4:  MOVWF  FF8
09BE6:  MOVLW  0E
09BE8:  MOVLB  3
09BEA:  MOVWF  x12
09BEC:  MOVLB  0
09BEE:  CALL   1D62
09BF2:  MOVFF  1CF,A39
09BF6:  MOVLW  37
09BF8:  MOVLB  A
09BFA:  MOVWF  x3A
09BFC:  MOVLB  0
09BFE:  CALL   1F60
09C02:  MOVLW  0D
09C04:  MOVLB  A
09C06:  MOVWF  xDB
09C08:  MOVLB  0
09C0A:  CALL   1CE0
09C0E:  MOVLW  0A
09C10:  MOVLB  A
09C12:  MOVWF  xDB
09C14:  MOVLB  0
09C16:  CALL   1CE0
....................    fprintf(PC, "Write Mode:   %02X\r\n", data.write_mode);
09C1A:  MOVLW  5C
09C1C:  MOVWF  FF6
09C1E:  MOVLW  15
09C20:  MOVWF  FF7
09C22:  MOVLW  00
09C24:  MOVWF  FF8
09C26:  MOVLW  0E
09C28:  MOVLB  3
09C2A:  MOVWF  x12
09C2C:  MOVLB  0
09C2E:  CALL   1D62
09C32:  MOVFF  1D0,A39
09C36:  MOVLW  37
09C38:  MOVLB  A
09C3A:  MOVWF  x3A
09C3C:  MOVLB  0
09C3E:  CALL   1F60
09C42:  MOVLW  0D
09C44:  MOVLB  A
09C46:  MOVWF  xDB
09C48:  MOVLB  0
09C4A:  CALL   1CE0
09C4E:  MOVLW  0A
09C50:  MOVLB  A
09C52:  MOVWF  xDB
09C54:  MOVLB  0
09C56:  CALL   1CE0
....................    fprintf(PC, "Source Type:  %02X\r\n", data.source_type);
09C5A:  MOVLW  00
09C5C:  MOVLB  1
09C5E:  BTFSC  xD1.0
09C60:  MOVLW  01
09C62:  MOVWF  xDA
09C64:  MOVLW  72
09C66:  MOVWF  FF6
09C68:  MOVLW  15
09C6A:  MOVWF  FF7
09C6C:  MOVLW  00
09C6E:  MOVWF  FF8
09C70:  MOVLW  0E
09C72:  MOVLB  3
09C74:  MOVWF  x12
09C76:  MOVLB  0
09C78:  CALL   1D62
09C7C:  MOVFF  1DA,A39
09C80:  MOVLW  37
09C82:  MOVLB  A
09C84:  MOVWF  x3A
09C86:  MOVLB  0
09C88:  CALL   1F60
09C8C:  MOVLW  0D
09C8E:  MOVLB  A
09C90:  MOVWF  xDB
09C92:  MOVLB  0
09C94:  CALL   1CE0
09C98:  MOVLW  0A
09C9A:  MOVLB  A
09C9C:  MOVWF  xDB
09C9E:  MOVLB  0
09CA0:  CALL   1CE0
....................    fprintf(PC, "Start Address:%04X\r\n", data.misf_start_addr);
09CA4:  MOVLW  88
09CA6:  MOVWF  FF6
09CA8:  MOVLW  15
09CAA:  MOVWF  FF7
09CAC:  MOVLW  00
09CAE:  MOVWF  FF8
09CB0:  MOVLW  0E
09CB2:  MOVLB  3
09CB4:  MOVWF  x12
09CB6:  MOVLB  0
09CB8:  CALL   1D62
09CBC:  MOVLW  02
09CBE:  MOVLB  1
09CC0:  MOVWF  xDA
09CC2:  MOVLB  0
09CC4:  MOVLW  30
09CC6:  MOVLB  A
09CC8:  MOVWF  xDB
09CCA:  MOVLB  0
09CCC:  CALL   1CE0
09CD0:  MOVLB  1
09CD2:  DECFSZ xDA,F
09CD4:  BRA    9CDA
09CD6:  BRA    9CE0
09CD8:  MOVLB  0
09CDA:  MOVLB  0
09CDC:  GOTO   9CC4
09CE0:  MOVFF  1D2,A39
09CE4:  MOVLW  37
09CE6:  MOVLB  A
09CE8:  MOVWF  x3A
09CEA:  MOVLB  0
09CEC:  CALL   1F60
09CF0:  MOVLW  0D
09CF2:  MOVLB  A
09CF4:  MOVWF  xDB
09CF6:  MOVLB  0
09CF8:  CALL   1CE0
09CFC:  MOVLW  0A
09CFE:  MOVLB  A
09D00:  MOVWF  xDB
09D02:  MOVLB  0
09D04:  CALL   1CE0
....................    fprintf(PC, "Size:         %04X\r\n", data.misf_size);
09D08:  MOVLW  9E
09D0A:  MOVWF  FF6
09D0C:  MOVLW  15
09D0E:  MOVWF  FF7
09D10:  MOVLW  00
09D12:  MOVWF  FF8
09D14:  MOVLW  0E
09D16:  MOVLB  3
09D18:  MOVWF  x12
09D1A:  MOVLB  0
09D1C:  CALL   1D62
09D20:  MOVLW  02
09D22:  MOVLB  1
09D24:  MOVWF  xDA
09D26:  MOVLB  0
09D28:  MOVLW  30
09D2A:  MOVLB  A
09D2C:  MOVWF  xDB
09D2E:  MOVLB  0
09D30:  CALL   1CE0
09D34:  MOVLB  1
09D36:  DECFSZ xDA,F
09D38:  BRA    9D3E
09D3A:  BRA    9D44
09D3C:  MOVLB  0
09D3E:  MOVLB  0
09D40:  GOTO   9D28
09D44:  MOVFF  1D6,A39
09D48:  MOVLW  37
09D4A:  MOVLB  A
09D4C:  MOVWF  x3A
09D4E:  MOVLB  0
09D50:  CALL   1F60
09D54:  MOVLW  0D
09D56:  MOVLB  A
09D58:  MOVWF  xDB
09D5A:  MOVLB  0
09D5C:  CALL   1CE0
09D60:  MOVLW  0A
09D62:  MOVLB  A
09D64:  MOVWF  xDB
09D66:  MOVLB  0
09D68:  CALL   1CE0
.................... 
....................    enqueue_flash_operation(&data); // SMFへのデータコピーを実行する
09D6C:  MOVLW  01
09D6E:  MOVLB  1
09D70:  MOVWF  xDB
09D72:  MOVLW  CE
09D74:  MOVWF  xDA
09D76:  MOVLB  0
09D78:  GOTO   95E2
.................... 
....................    fprintf(PC, "End MODE MEAS IV mission\r\n");
09D7C:  MOVLW  B4
09D7E:  MOVWF  FF6
09D80:  MOVLW  15
09D82:  MOVWF  FF7
09D84:  MOVLW  00
09D86:  MOVWF  FF8
09D88:  CALL   1D32
09D8C:  GOTO   9FEA (RETURN)
.................... }
.................... 
.................... void mode_iv_test(unsigned int8 *uplinkcmd)
.................... {
....................    fprintf(PC, "Start MODE IV TEST \r\n");
*
092AC:  MOVLW  D0
092AE:  MOVWF  FF6
092B0:  MOVLW  15
092B2:  MOVWF  FF7
092B4:  MOVLW  00
092B6:  MOVWF  FF8
092B8:  CALL   1D32
....................    MEAS_IV_CMD cmd = make_meas_iv_cmd(uplinkcmd); // Create the measurement command structure
092BC:  MOVFF  1BD,1E1
092C0:  MOVFF  1BC,1E0
092C4:  CALL   7358
092C8:  MOVFF  02,03
092CC:  MOVF   01,W
092CE:  MOVWF  FE1
092D0:  MOVFF  03,FE2
092D4:  MOVLW  01
092D6:  MOVWF  FEA
092D8:  MOVLW  BE
092DA:  MOVWF  FE9
092DC:  MOVLW  0C
092DE:  MOVWF  01
092E0:  MOVFF  FE6,FEE
092E4:  DECFSZ 01,F
092E6:  GOTO   92E0
....................    fprintf(PC, "\tID: %02X\r\n", cmd.id);
092EA:  MOVLW  E6
092EC:  MOVWF  FF6
092EE:  MOVLW  15
092F0:  MOVWF  FF7
092F2:  MOVLW  00
092F4:  MOVWF  FF8
092F6:  MOVLW  05
092F8:  MOVLB  3
092FA:  MOVWF  x12
092FC:  MOVLB  0
092FE:  CALL   1D62
09302:  MOVFF  1BE,A39
09306:  MOVLW  37
09308:  MOVLB  A
0930A:  MOVWF  x3A
0930C:  MOVLB  0
0930E:  CALL   1F60
09312:  MOVLW  0D
09314:  MOVLB  A
09316:  MOVWF  xDB
09318:  MOVLB  0
0931A:  CALL   1CE0
0931E:  MOVLW  0A
09320:  MOVLB  A
09322:  MOVWF  xDB
09324:  MOVLB  0
09326:  CALL   1CE0
....................    fprintf(PC, "\tSleep Time: %04LX ms\r\n", cmd.sleep_time);
0932A:  MOVLW  F2
0932C:  MOVWF  FF6
0932E:  MOVLW  15
09330:  MOVWF  FF7
09332:  MOVLW  00
09334:  MOVWF  FF8
09336:  MOVLW  0D
09338:  MOVLB  3
0933A:  MOVWF  x12
0933C:  MOVLB  0
0933E:  CALL   1D62
09342:  MOVFF  1C0,A39
09346:  MOVLW  37
09348:  MOVLB  A
0934A:  MOVWF  x3A
0934C:  MOVLB  0
0934E:  CALL   1F60
09352:  MOVFF  1BF,A39
09356:  MOVLW  37
09358:  MOVLB  A
0935A:  MOVWF  x3A
0935C:  MOVLB  0
0935E:  CALL   1F60
09362:  MOVLW  04
09364:  MOVWF  FF6
09366:  MOVLW  16
09368:  MOVWF  FF7
0936A:  MOVLW  00
0936C:  MOVWF  FF8
0936E:  MOVLW  05
09370:  MOVLB  3
09372:  MOVWF  x12
09374:  MOVLB  0
09376:  CALL   1D62
....................    fprintf(PC, "\tCurrent Threshold: %04LX mA\r\n", cmd.curr_threshold);
0937A:  MOVLW  0A
0937C:  MOVWF  FF6
0937E:  MOVLW  16
09380:  MOVWF  FF7
09382:  MOVLW  00
09384:  MOVWF  FF8
09386:  MOVLW  14
09388:  MOVLB  3
0938A:  MOVWF  x12
0938C:  MOVLB  0
0938E:  CALL   1D62
09392:  MOVFF  1C2,A39
09396:  MOVLW  37
09398:  MOVLB  A
0939A:  MOVWF  x3A
0939C:  MOVLB  0
0939E:  CALL   1F60
093A2:  MOVFF  1C1,A39
093A6:  MOVLW  37
093A8:  MOVLB  A
093AA:  MOVWF  x3A
093AC:  MOVLB  0
093AE:  CALL   1F60
093B2:  MOVLW  23
093B4:  MOVWF  FF6
093B6:  MOVLW  16
093B8:  MOVWF  FF7
093BA:  MOVLW  00
093BC:  MOVWF  FF8
093BE:  MOVLW  05
093C0:  MOVLB  3
093C2:  MOVWF  x12
093C4:  MOVLB  0
093C6:  CALL   1D62
....................    fprintf(PC, "\tPD Threshold: %04LX mA\r\n", cmd.pd_threshold);
093CA:  MOVLW  2A
093CC:  MOVWF  FF6
093CE:  MOVLW  16
093D0:  MOVWF  FF7
093D2:  MOVLW  00
093D4:  MOVWF  FF8
093D6:  MOVLW  0F
093D8:  MOVLB  3
093DA:  MOVWF  x12
093DC:  MOVLB  0
093DE:  CALL   1D62
093E2:  MOVFF  1C4,A39
093E6:  MOVLW  37
093E8:  MOVLB  A
093EA:  MOVWF  x3A
093EC:  MOVLB  0
093EE:  CALL   1F60
093F2:  MOVFF  1C3,A39
093F6:  MOVLW  37
093F8:  MOVLB  A
093FA:  MOVWF  x3A
093FC:  MOVLB  0
093FE:  CALL   1F60
09402:  MOVLW  3E
09404:  MOVWF  FF6
09406:  MOVLW  16
09408:  MOVWF  FF7
0940A:  MOVLW  00
0940C:  MOVWF  FF8
0940E:  MOVLW  05
09410:  MOVLB  3
09412:  MOVWF  x12
09414:  MOVLB  0
09416:  CALL   1D62
....................    fprintf(PC, "\tCurrent Limit: %04LX mA\r\n", cmd.curr_limit);
0941A:  MOVLW  44
0941C:  MOVWF  FF6
0941E:  MOVLW  16
09420:  MOVWF  FF7
09422:  MOVLW  00
09424:  MOVWF  FF8
09426:  MOVLW  10
09428:  MOVLB  3
0942A:  MOVWF  x12
0942C:  MOVLB  0
0942E:  CALL   1D62
09432:  MOVFF  1C6,A39
09436:  MOVLW  37
09438:  MOVLB  A
0943A:  MOVWF  x3A
0943C:  MOVLB  0
0943E:  CALL   1F60
09442:  MOVFF  1C5,A39
09446:  MOVLW  37
09448:  MOVLB  A
0944A:  MOVWF  x3A
0944C:  MOVLB  0
0944E:  CALL   1F60
09452:  MOVLW  59
09454:  MOVWF  FF6
09456:  MOVLW  16
09458:  MOVWF  FF7
0945A:  MOVLW  00
0945C:  MOVWF  FF8
0945E:  MOVLW  05
09460:  MOVLB  3
09462:  MOVWF  x12
09464:  MOVLB  0
09466:  CALL   1D62
....................    fprintf(PC, "\tMeasurement Time: %04LX s\r\n", cmd.meas_time);
0946A:  MOVLW  60
0946C:  MOVWF  FF6
0946E:  MOVLW  16
09470:  MOVWF  FF7
09472:  MOVLW  00
09474:  MOVWF  FF8
09476:  MOVLW  13
09478:  MOVLB  3
0947A:  MOVWF  x12
0947C:  MOVLB  0
0947E:  CALL   1D62
09482:  MOVFF  1C8,A39
09486:  MOVLW  37
09488:  MOVLB  A
0948A:  MOVWF  x3A
0948C:  MOVLB  0
0948E:  CALL   1F60
09492:  MOVFF  1C7,A39
09496:  MOVLW  37
09498:  MOVLB  A
0949A:  MOVWF  x3A
0949C:  MOVLB  0
0949E:  CALL   1F60
094A2:  MOVLW  78
094A4:  MOVWF  FF6
094A6:  MOVLW  16
094A8:  MOVWF  FF7
094AA:  MOVLW  00
094AC:  MOVWF  FF8
094AE:  MOVLW  04
094B0:  MOVLB  3
094B2:  MOVWF  x12
094B4:  MOVLB  0
094B6:  CALL   1D62
.................... //!   fprintf(PC, "\tIs Finished: %u\r\n", cmd.is_finished);
.................... 
....................    piclog_make(cmd.id, PICLOG_PARAM_START); // Log the start of the command execution
094BA:  MOVFF  1BE,20F
094BE:  MOVLB  2
094C0:  CLRF   x10
094C2:  MOVLB  0
094C4:  CALL   4A82
.................... 
....................    unsigned int16 start_time = get_current_sec();
....................    unsigned int16 current_sec = 0;
094C8:  CALL   3C66
094CC:  MOVFF  01,1CB
094D0:  MOVFF  00,1CA
094D4:  MOVLB  1
094D6:  CLRF   xCD
094D8:  CLRF   xCC
094DA:  MOVLB  0
....................    while(get_current_sec() - start_time < cmd.meas_time)
094DC:  CALL   3C66
094E0:  MOVFF  03,1D1
094E4:  MOVFF  02,1D0
094E8:  MOVFF  01,1CF
094EC:  MOVFF  00,1CE
094F0:  MOVLB  1
094F2:  MOVF   xCA,W
094F4:  SUBWF  xCE,F
094F6:  MOVF   xCB,W
094F8:  SUBWFB xCF,F
094FA:  MOVLW  00
094FC:  SUBWFB xD0,F
094FE:  MOVLW  00
09500:  SUBWFB xD1,F
09502:  MOVF   xD1,F
09504:  BTFSC  FD8.2
09506:  BRA    950E
09508:  MOVLB  0
0950A:  GOTO   95D0
0950E:  MOVLB  0
09510:  MOVLB  1
09512:  MOVF   xD0,F
09514:  BTFSC  FD8.2
09516:  BRA    951E
09518:  MOVLB  0
0951A:  GOTO   95D0
0951E:  MOVLB  0
09520:  MOVLB  1
09522:  MOVF   xCF,W
09524:  SUBWF  xC8,W
09526:  BTFSC  FD8.0
09528:  BRA    9530
0952A:  MOVLB  0
0952C:  GOTO   95D0
09530:  MOVLB  0
09532:  BTFSS  FD8.2
09534:  GOTO   954A
09538:  MOVLB  1
0953A:  MOVF   xC7,W
0953C:  SUBWF  xCE,W
0953E:  BTFSS  FD8.0
09540:  BRA    9548
09542:  MOVLB  0
09544:  GOTO   95D0
09548:  MOVLB  0
....................    {
....................       current_sec = get_current_sec();
0954A:  CALL   3C66
0954E:  MOVFF  01,1CD
09552:  MOVFF  00,1CC
....................       if (current_sec - start_time >= cmd.meas_time) {
09556:  MOVLB  1
09558:  MOVF   xCA,W
0955A:  SUBWF  xCC,W
0955C:  MOVWF  xCE
0955E:  MOVF   xCB,W
09560:  SUBWFB xCD,W
09562:  MOVWF  xCF
09564:  MOVF   xC8,W
09566:  SUBWF  xCF,W
09568:  BTFSC  FD8.0
0956A:  BRA    9572
0956C:  MOVLB  0
0956E:  GOTO   9590
09572:  MOVLB  0
09574:  BTFSS  FD8.2
09576:  GOTO   958C
0957A:  MOVLB  1
0957C:  MOVF   xC7,W
0957E:  SUBWF  xCE,W
09580:  BTFSC  FD8.0
09582:  BRA    958A
09584:  MOVLB  0
09586:  GOTO   9590
0958A:  MOVLB  0
....................           break;
0958C:  GOTO   95D0
....................       }
....................       test_sweep(cmd.curr_threshold, cmd.curr_limit); // Perform the sweep with thresholds
09590:  MOVFF  1C2,1CF
09594:  MOVFF  1C1,1CE
09598:  MOVFF  1C6,1D1
0959C:  MOVFF  1C5,1D0
095A0:  GOTO   7E8C
....................       delay_ms(cmd.sleep_time);
095A4:  MOVFF  1C0,1CE
095A8:  MOVLB  1
095AA:  INCF   xCE,F
095AC:  MOVLB  0
095AE:  MOVLB  1
095B0:  DECFSZ xCE,F
095B2:  BRA    95B8
095B4:  MOVLB  0
095B6:  BRA    95C4
095B8:  MOVLB  A
095BA:  SETF   x94
095BC:  MOVLB  0
095BE:  CALL   1CB2
095C2:  BRA    95AE
095C4:  MOVFF  1BF,A94
095C8:  CALL   1CB2
095CC:  GOTO   94DC
....................    }
....................    piclog_make(cmd.id, PICLOG_PARAM_END); // Log the end of the command execution
095D0:  MOVFF  1BE,20F
095D4:  MOVLB  2
095D6:  SETF   x10
095D8:  MOVLB  0
095DA:  CALL   4A82
095DE:  GOTO   9FDA (RETURN)
.................... 
.................... 
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... MEAS_IV_CMD make_meas_iv_cmd(unsigned int8 *uplinkcmd[])
.................... {
....................    MEAS_IV_CMD cmd;
....................    cmd.id = uplinkcmd[0];
*
07358:  MOVLB  1
0735A:  MOVF   xE0,W
0735C:  MOVWF  FE9
0735E:  MOVF   xE1,W
07360:  MOVWF  FEA
07362:  MOVFF  FEF,1E2
....................    cmd.sleep_time = ((unsigned int16)uplinkcmd[1] << 8) | ((unsigned int16)uplinkcmd[2]);
07366:  MOVLW  01
07368:  ADDWF  xE0,W
0736A:  MOVWF  FE9
0736C:  MOVLW  00
0736E:  ADDWFC xE1,W
07370:  MOVWF  FEA
07372:  MOVF   FEF,W
07374:  CLRF   xEF
07376:  MOVWF  xEE
07378:  MOVFF  1EE,1EF
0737C:  CLRF   xEE
0737E:  MOVLW  02
07380:  ADDWF  xE0,W
07382:  MOVWF  FE9
07384:  MOVLW  00
07386:  ADDWFC xE1,W
07388:  MOVWF  FEA
0738A:  MOVF   FEF,W
0738C:  CLRF   03
0738E:  IORWF  xEE,W
07390:  MOVWF  xE3
07392:  MOVF   03,W
07394:  IORWF  xEF,W
07396:  MOVWF  xE4
....................    cmd.curr_threshold = (unsigned int16)uplinkcmd[3]<< 4;
07398:  MOVLW  03
0739A:  ADDWF  xE0,W
0739C:  MOVWF  FE9
0739E:  MOVLW  00
073A0:  ADDWFC xE1,W
073A2:  MOVWF  FEA
073A4:  MOVF   FEF,W
073A6:  CLRF   xEF
073A8:  MOVWF  xEE
073AA:  RLCF   xEE,W
073AC:  MOVWF  xE5
073AE:  RLCF   xEF,W
073B0:  MOVWF  xE6
073B2:  RLCF   xE5,F
073B4:  RLCF   xE6,F
073B6:  RLCF   xE5,F
073B8:  RLCF   xE6,F
073BA:  RLCF   xE5,F
073BC:  RLCF   xE6,F
073BE:  MOVLW  F0
073C0:  ANDWF  xE5,F
....................    cmd.pd_threshold = (unsigned int16)uplinkcmd[4]<< 4;
073C2:  MOVLW  04
073C4:  ADDWF  xE0,W
073C6:  MOVWF  FE9
073C8:  MOVLW  00
073CA:  ADDWFC xE1,W
073CC:  MOVWF  FEA
073CE:  MOVF   FEF,W
073D0:  CLRF   xEF
073D2:  MOVWF  xEE
073D4:  RLCF   xEE,W
073D6:  MOVWF  xE7
073D8:  RLCF   xEF,W
073DA:  MOVWF  xE8
073DC:  RLCF   xE7,F
073DE:  RLCF   xE8,F
073E0:  RLCF   xE7,F
073E2:  RLCF   xE8,F
073E4:  RLCF   xE7,F
073E6:  RLCF   xE8,F
073E8:  MOVLW  F0
073EA:  ANDWF  xE7,F
....................    cmd.curr_limit = (unsigned int16)uplinkcmd[5]<< 4;
073EC:  MOVLW  05
073EE:  ADDWF  xE0,W
073F0:  MOVWF  FE9
073F2:  MOVLW  00
073F4:  ADDWFC xE1,W
073F6:  MOVWF  FEA
073F8:  MOVF   FEF,W
073FA:  CLRF   xEF
073FC:  MOVWF  xEE
073FE:  RLCF   xEE,W
07400:  MOVWF  xE9
07402:  RLCF   xEF,W
07404:  MOVWF  xEA
07406:  RLCF   xE9,F
07408:  RLCF   xEA,F
0740A:  RLCF   xE9,F
0740C:  RLCF   xEA,F
0740E:  RLCF   xE9,F
07410:  RLCF   xEA,F
07412:  MOVLW  F0
07414:  ANDWF  xE9,F
....................    cmd.meas_time = ((unsigned int16)uplinkcmd[6] << 8) | ((unsigned int16)uplinkcmd[7]);
07416:  MOVLW  06
07418:  ADDWF  xE0,W
0741A:  MOVWF  FE9
0741C:  MOVLW  00
0741E:  ADDWFC xE1,W
07420:  MOVWF  FEA
07422:  MOVF   FEF,W
07424:  CLRF   xEF
07426:  MOVWF  xEE
07428:  MOVFF  1EE,1EF
0742C:  CLRF   xEE
0742E:  MOVLW  07
07430:  ADDWF  xE0,W
07432:  MOVWF  FE9
07434:  MOVLW  00
07436:  ADDWFC xE1,W
07438:  MOVWF  FEA
0743A:  MOVF   FEF,W
0743C:  CLRF   03
0743E:  IORWF  xEE,W
07440:  MOVWF  xEB
07442:  MOVF   03,W
07444:  IORWF  xEF,W
07446:  MOVWF  xEC
.................... //!  cmd.is_finished = uplinkcmd[8];
....................    return cmd;
07448:  MOVLW  E2
0744A:  MOVWF  01
0744C:  MOVLW  01
0744E:  MOVWF  02
07450:  MOVLB  0
07452:  RETURN 0
.................... }
.................... 
.................... #include "application/mmj_cigs_mode_flash.c"
.................... #include "mmj_cigs_mode_flash.h"                      // 同じフォルダのヘッダー
.................... #ifndef MMJ_CIGS_MODE_FLASH_H
.................... #define MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //#define PARAMETER_LENGTH 9
.................... 
.................... // ___________MISF FUNCTIONS____________
.................... // Command ID 
.................... #define ID_MISF_ERASE_ALL 0x80
.................... #define ID_MISF_ERASE_1SECTOR 0x81
.................... #define ID_MISF_ERASE_4kByte_SUBSECTOR 0x82
.................... #define ID_MISF_ERASE_64kByte_SUBSECTOR 0x83
.................... #define ID_MISF_WRITE_DEMO 0x84
.................... #define ID_MISF_WRITE_4kByte_SUBSECTOR 0x85
.................... #define ID_MISF_READ 0x86
.................... #define ID_MISF_READ_ADDRESS 0x87
.................... #define ID_MISF_ERASE_AND_RESET 0x88
.................... #define ID_MISF_ADDRESS_RESET 0x8F
.................... 
.................... // Mode
.................... void mode_misf_erase_all(unsigned int8 parameter[]);
.................... void mode_misf_erase_1sector(unsigned int8 parameter[]);
.................... void mode_misf_erase_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_write_demo(unsigned int8 parameter[]);
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 writeaddress;
....................     unsigned int16 packetnum;
.................... } FLASH_WRITE_PARAM;
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[]);
.................... void mode_misf_read(unsigned int8 parameter[]);
.................... typedef struct{
....................     unsigned int8 id;
....................     unsigned int16 readpacketnum;
....................     unsigned int32 readaddress;
.................... }FLASH_PARAM;
.................... void mode_misf_read_address(unsigned int8 parameter[]);
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[]);
.................... void mode_misf_address_reset(unsigned int8 parameter[]);
.................... 
.................... 
.................... 
.................... 
.................... // CMD Parameter
.................... typedef struct {
....................     unsigned int8 id;
....................     unsigned int32 readaddress;
....................     unsigned int16 readpacketnum;
.................... } FLASH_READ_PARAM;
.................... 
.................... 
.................... 
.................... // ___________SMF FUNCTIONS____________
.................... // Command
.................... #define ID_SMF_COPY 0x90
.................... #define ID_SMF_READ 0x91
.................... #define ID_SMF_ERASE 0x92
.................... #define ID_SMF_COPY_FORCE 0x93
.................... #define ID_SMF_READ_FORCE 0x94
.................... #define ID_SMF_ERASE_FORCE 0x95
.................... #define ID_SMF_RESET 0x96
.................... 
.................... // Mode
.................... void mode_smf_copy(unsigned int8 parameter[]);
.................... void mode_smf_read(unsigned int8 parameter[]);
.................... void mode_smf_erase(unsigned int8 parameter[]);
.................... void mode_smf_copy_force(unsigned int8 parameter[]);
.................... void mode_smf_read_force(unsigned int8 parameter[]);
.................... void mode_smf_erase_force(unsigned int8 parameter[]);
.................... void mode_smf_address_reset(unsigned int8 parameter[]);
.................... 
.................... #endif // MMJ_CIGS_MODE_FLASH_H
.................... 
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_iv.h"          // 測定機能
.................... #ifndef mmj_cigs_iv_H
.................... #define mmj_cigs_iv_H
.................... 
.................... /*
.................... // _________ values _________
.................... #define MISSION_DATA_SIZE 64
.................... volatile unsigned int8 mission_datas[MISSION_DATA_SIZE] = {0x00};
.................... volatile int8 executed_mission_count = 0;
.................... */
.................... 
.................... #define START_MAKER 0xFF
.................... #define RESERVED_VALUE 0x00
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // _________ functions ____________
.................... /*
.................... #define DATA_BUFFER_SIZE 150
.................... #define HEADER_SIZE 12
.................... volatile unsigned int16 data_buffer [DATA_BUFFER_SIZE*2] = {0x00} ;
.................... volatile unsigned int32 measured_time = 0 ;
.................... volatile unsigned int16 measured_open_voltage = 0 ;
.................... volatile unsigned int16 measured_pd = 0 ;
.................... volatile unsigned int16 measured_temp_top = 0 ;
.................... volatile unsigned int16 measured_temp_bot = 0 ;     
.................... */
.................... 
.................... void make_meas_header(unsigned int8 *packetdata, unsigned int8 *cmd);
.................... 
.................... 
.................... // void sweep(unsigned int8 parameter[]);
.................... 
.................... void sweep(unsigned int16 curr_threshold, unsigned int16 pd_threshold, unsigned int16 curr_limit);
.................... void test_sweep(unsigned int16 curr_threshold, unsigned int16 curr_limit);
.................... 
.................... typedef struct{
....................     unsigned int32 time;
....................     unsigned int16 pd;
....................     unsigned int16 temp_py_top;
....................     unsigned int16 temp_py_bot;
....................     unsigned int16 temp_mis7;
.................... } iv_env_t;
.................... 
.................... typedef struct{
....................     unsigned int8 port_num; // Port number (1 or 2)
....................     unsigned int16 sweep_step; // Number of steps in the sweep
....................     unsigned int16 data_buffer[2][0xFF]; // Data buffer for voltage and current readings
....................     int1 active; // Indicates if the port is active (1 for active, 0 for inactive)
.................... } sweep_config_t;
.................... 
.................... 
.................... 
.................... typedef union{
....................     struct{
....................         unsigned int8 start_marker;
....................         unsigned int8 reserved;
....................         unsigned int8 command;
....................         unsigned int8 port_num;
....................         unsigned int16 data[2];
....................     }fields;
.................... 
....................     unsigned int8 raw[PACKET_SIZE];
.................... }iv_packet_t;
.................... 
.................... 
.................... iv_env_t create_meas_data();
.................... void log_meas_data(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... void log_meas_data_with_print(iv_env_t *environment_data_ptr, sweep_config_t *port_data);
.................... 
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/smf_queue.h"                   // ツールライブラリ
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... typedef enum {
....................    ENUM_SMF_WRITE,    // SMF書き込み操作
....................    ENUM_SMF_READ,     // SMF読み込み操作
....................    ENUM_SMF_ERASE     // SMF消去操作
.................... } FunctionType;
.................... 
.................... // SMF書き込みモード
.................... typedef enum {
....................    SMF_WRITE_OVERWRITE = 0x00,  // 上書きモード
....................    SMF_WRITE_APPEND = 0x01,     // 追記モード
....................    SMF_WRITE_CIRCULAR = 0x02    // 循環書き込みモード（endまで行ったらstartに戻る）
.................... } SmfWriteMode;
.................... 
.................... // データソースタイプ
.................... typedef enum {
....................    SOURCE_MISF_UNCOPIED = 0x00, // MISF未コピーデータを転送
....................    SOURCE_MISF_MANUAL = 0x01    // MISF指定アドレス・サイズを転送
.................... } DataSourceType;
.................... 
.................... 
.................... typedef enum{
....................    CIGS_DATA_TABLE,
....................    CIGS_PICLOG_DATA,
....................    CIGS_ENVIRO_DATA,
....................    CIGS_IV1_HEADER,
....................    CIGS_IV1_DATA,
....................    CIGS_IV2_HEADER,
....................    CIGS_IV2_DATA
.................... } MissionID;
.................... 
.................... 
.................... 
.................... typedef struct {
....................    int32 start_address;
....................    int32 end_address;
.................... } SmfAddressStruct;
.................... 
.................... typedef struct{
....................    int32 misf_start_address;
....................    int32 misf_size;
.................... } SmfWriteStruct;
.................... 
.................... typedef struct {
....................     MissionID mission_id;                // ミッションID
....................     FunctionType func_type;         // 操作タイプ
....................     SmfWriteMode write_mode;        // 書き込みモード（書き込み時のみ）
....................     DataSourceType source_type;     // データソースタイプ
....................     int32 misf_start_addr;          // MISF手動指定時の開始アドレス
....................     int32 misf_size;                // MISF手動指定時のサイズ
.................... } FlashOperationStruct;
.................... 
.................... #define SMF_QUEUE_SIZE 16
.................... typedef struct {
....................    FlashOperationStruct entries[SMF_QUEUE_SIZE];  // キューエントリー配列
....................    int8 head_index;                               // 取り出し位置（読み取りインデックス）
....................    int8 tail_index;                               // 追加位置（書き込みインデックス）
.................... } FlashQueueStruct;
.................... 
.................... 
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile FlashQueueStruct flash_queue = {0};
.................... 
.................... // MISF/SMF統合管理インスタンス（ミッション別）
.................... //volatile MisfSmfManagerStruct misf_smf_manager[8] = {0}; // 最大8ミッション対応
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... // MISF/SMF管理関数
.................... void init_misf_smf_manager(int8 mission_id, int32 misf_start, int32 misf_size, int32 smf_start, int32 smf_size);
.................... void update_misf_data(int8 mission_id, int32 data_size);
.................... void process_misf_to_smf_transfer(int8 mission_id);
.................... int32 get_uncopied_data_size(int8 mission_id);
.................... void mark_data_copied(int8 mission_id, int32 copied_size);
.................... int1 is_misf_full(int8 mission_id);
.................... //MisfSmfManagerStruct* get_misf_smf_manager(int8 mission_id);
.................... 
.................... void enqueue_flash_operation(FlashOperationStruct *data);
.................... 
.................... FlashOperationStruct *dequeue_flash_operation();
.................... 
.................... FlashOperationStruct *peek_flash_operation(void);
.................... 
.................... void remove_flash_operation(void);
.................... 
.................... int1 is_empty_flash_queue(void);
.................... 
.................... SmfAddressStruct get_smf_address_struct(MissionID mission_id);
.................... 
.................... // 便利な関数
.................... void enqueue_uncopied_data(int8 mission_id, SmfWriteMode write_mode);
.................... void enqueue_manual_data(int8 mission_id, int32 misf_addr, int32 size, SmfWriteMode write_mode);
.................... void enqueue_read_data(int32 smf_addr, int32 size);
.................... void enqueue_erase_data(int32 smf_addr, int32 size);
.................... 
.................... // 統合管理対応の便利な関数
.................... void enqueue_auto_transfer(int8 mission_id);  // 未コピーデータの自動転送
.................... void complete_transfer_and_update_counter(int8 mission_id, int32 transferred_size);  // 転送完了とカウンタ更新
.................... 
.................... SmfWriteStruct get_smf_write_struct(MissionID mission_id);
.................... #endif   //SMF_QUEUE_H
.................... 
.................... #include "../lib/device/mt25q.h"                     // デバイスライブラリ
.................... #ifndef MT25Q_H
.................... #define MT25Q_H
.................... 
.................... // =========
.................... //#define MT25Q_DEBUG
.................... // =========
.................... 
.................... 
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... 
.................... typedef enum spi_stream{
....................     SPI_0,
....................     SPI_1,
....................     SPI_2,
....................     SPI_3,
.................... }SpiStreamId;
.................... 
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... typedef struct select_stream_to_flash{
....................     SpiStreamId spi_stream_id;
....................     unsigned int8 flash_model;
....................     int16 cs_pin;
.................... }Flash;
.................... 
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, MIS_FM_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SMF_CS};
.................... 
.................... 
.................... 
.................... // ===================== Function List =====================
.................... // Public Functions
.................... 
.................... int1 is_connect(Flash flash_stream);
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);      
.................... 
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);  
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);  
....................                                
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);      
.................... 
.................... //Private Functions
....................  
.................... void flash_setting(Flash flash_stream);
....................  
.................... int8 status_register(Flash flash_stream);
....................  
.................... int8 read_id(Flash flash_stream);
....................  
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
....................  
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
....................         //
.................... 
.................... 
.................... // ===================== Flash Commands =====================
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... 
.................... // ====================== Value List =====================
.................... #define MANUFACTURER_ID_MICRON 0x20 // Manufacturer ID for Micron flash
.................... #define READ_ID_DATASIZE 20 // 20 bytes for read ID data
.................... 
.................... 
.................... // ====================== Data Structures =====================
.................... typedef union
.................... {
....................     unsigned int8 bytes[READ_ID_DATASIZE]; // 20 bytes for read ID
....................     struct {
....................         unsigned int8 manufacturer_id; // 1 byte
....................         unsigned int8 memory_type;     // 1 byte
....................         unsigned int8 capacity;        // 1 byte
....................         unsigned int8 reserved;       // 1 byte
....................     } fields;
.................... }READ_ID_DATA;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "../domain/mmj_cigs_flash.h"             // ストレージ機能
.................... #ifndef MMJ_CIGS_FLASH_H
.................... #define MMJ_CIGS_FLASH_H
.................... 
.................... #include <string.h>
.................... #include "../hal/mmj_cigs_config.h"
.................... 
.................... #ifndef PACKET_SIZE
....................     #define PACKET_SIZE 64
.................... #endif
.................... 
.................... 
.................... #define MISF_START 0x00000000
.................... #define MISF_END   0x000FFFFF
.................... #define SECTOR_64K_BYTE  0x10000
.................... 
.................... #define MISF_CIGS_DATA_TABLE_SIZE 64
.................... 
.................... // Flash Address
.................... #define MISF_CIGS_DATA_TABLE_START 0x00000000
.................... #define MISF_CIGS_DATA_TABLE_END   0x00000FFF
.................... #define MISF_CIGS_PICLOG_START    0x00010000
.................... #define MISF_CIGS_PICLOG_END      0x00140FFF
.................... #define MISF_CIGS_ENVIRO_START    0x00281000
.................... #define MISF_CIGS_ENVIRO_END      0x00320FFF
.................... #define MISF_CIGS_IV_HEADER_START 0x00721000
.................... #define MISF_CIGS_IV_HEADER_END   0x007C0FFF
.................... #define MISF_CIGS_IV_DATA_START   0x007C1000
.................... #define MISF_CIGS_IV_DATA_END     0x00BC0FFF
.................... 
.................... // 重複していた #define はここに一度だけ残す
.................... // 例: #define SECTOR_4K_BYTE  0x1000  // 4KByte
.................... // 他ファイルに同じ行があれば削除
.................... 
.................... // Flash カウンタだけを保持する汎用構造
.................... typedef struct {
....................     unsigned int32 used_counter;
....................     unsigned int32 uncopied_counter;
....................     unsigned int8  reserve_counter1;
....................     unsigned int8  reserve_counter2;
.................... } FlashCounter_t;
.................... 
.................... // データ種別ID
.................... typedef enum {
....................     FLASH_ID_DATA_TABLE = 0 ,
....................     FLASH_ID_PICLOG ,
....................     FLASH_ID_ENVIRONMENT,
....................     FLASH_ID_IV1_HEADER,
....................     FLASH_ID_IV1_DATA,
....................     FLASH_ID_IV2_HEADER,
....................     FLASH_ID_IV2_DATA,
....................     FLASH_ID_COUNT = 7
.................... } FlashDataId_t;
.................... 
.................... // Flash_t : 実体側で使用する拡張(必要なら id を保持)
.................... typedef struct {
....................     FlashDataId_t   id;
....................     unsigned int32  used_counter;
....................     unsigned int32  uncopied_counter;
....................     unsigned int8   reserve_counter1;
....................     unsigned int8   reserve_counter2;
.................... } Flash_t;
.................... 
.................... // FlashData_t （既存定義が別ヘッダなら重複しないよう確認）
.................... // ここでは payload 内の logdata.* が FlashCounter_t と仮定
.................... typedef union {
....................     struct {
....................         union {
....................             struct {
....................                 FlashCounter_t piclog;
....................                 FlashCounter_t environment;
....................                 FlashCounter_t iv1_header;
....................                 FlashCounter_t iv1_data;
....................                 FlashCounter_t iv2_header;
....................                 FlashCounter_t iv2_data;
....................             } logdata;  // 合計サイズは63バイト
....................             unsigned int8 reserve[63];
....................         } payload;
....................         unsigned int8 crc;  // 1バイトCRC
....................     } packet;
....................     unsigned int8 bytes[64];
.................... } FlashData_t;
.................... 
.................... // グローバルカウンタ（他 .c で定義済みなら extern に）
.................... extern Flash_t *data_table_ptr;
.................... extern Flash_t *piclog_data_ptr;
.................... extern Flash_t *environment_data_ptr;
.................... extern Flash_t *iv1_header_ptr;
.................... extern Flash_t *iv1_data_ptr;
.................... extern Flash_t *iv2_header_ptr;
.................... extern Flash_t *iv2_data_ptr;
.................... 
.................... // 取得系
.................... FlashData_t make_flash_data_table(void);
.................... void write_misf_address_area(void);
.................... void print_flash_status(void);
.................... 
.................... // MISF アドレス/書き込み構造体
.................... typedef struct {
....................     int32 start_address;
....................     int32 end_address;
.................... } MisfAddressStruct;
.................... 
.................... typedef struct {
....................     int32 start_address;
....................     int32 size;
.................... } MisfWriteStruct;
.................... 
.................... MisfAddressStruct get_misf_address_struct(MissionID mission_id);
.................... MisfWriteStruct  get_misf_write_struct(MissionID mission_id);
.................... 
.................... // キュー投入
.................... void add_smf_queue(MissionID mission_id, FunctionType func_type, SmfWriteMode write_mode);
.................... void misf_init();
.................... #endif
.................... //------------------End of File------------------
.................... 
.................... #include "../domain/mmj_cigs_piclog.h"            // ログ機能
.................... #ifndef     MMJ_CIGS_PICLOG_H
.................... #define     MMJ_CIGS_PICLOG_H
.................... 
.................... // PICLOG Param
.................... #define PICLOG_STARTUP 0x00
.................... #define PICLOG_PARAM_START 0x00
.................... #define PICLOG_PARAM_END   0xFF
.................... 
.................... 
.................... #define PICLOG_PACKET_SIZE 6
.................... 
.................... // PICLOG Union
.................... typedef union {
....................     struct {
....................         unsigned int32 time;
....................         unsigned int8  function;
....................         unsigned int8  parameter;
....................     } fields;
....................     unsigned int8 bytes[PICLOG_PACKET_SIZE];
.................... } piclog_t;
.................... 
.................... #define PICLOG_BLANK_SIZE 4
.................... unsigned int8 PICLOG_BLANK_DATA[PICLOG_BLANK_SIZE];
.................... 
.................... // PICLOG 関数（実装は .c）
.................... void piclog_make(unsigned int8 function, unsigned int8 parameter);
.................... 
.................... #endif // MMJ_CIGS_PICLOG_H
.................... //------------------End of File------------------
.................... 
.................... #include "../lib/tool/calc_tools.h"
.................... #ifndef CALC_TOOLS_H
.................... #define CALC_TOOLS_H
....................  
.................... unsigned int8 calc_crc8(unsigned int8 *frame, unsigned int8 payload_size);
.................... int1 is_crc_valid(unsigned int8 *frame, int8 payload_size);
.................... void int32_to_be_array(int32 value, int8 *buf, int8 index);
.................... int32 lsb_array_to_int32(int8 *buf, int8 index);
.................... unsigned int32 lsb_to_msb(unsigned int32 value);
.................... unsigned int32 msb_to_lsb(unsigned int32 value);
.................... 
.................... 
.................... #endif // CALC_TOOLS_H  
.................... 
.................... 
.................... // ========================== MISF Command ============================
.................... void mode_misf_erase_all(int8 parameter[])
.................... {
....................    printf("Start Flash Erase All\r\n");
*
05460:  MOVLW  7E
05462:  MOVWF  FF6
05464:  MOVLW  16
05466:  MOVWF  FF7
05468:  MOVLW  00
0546A:  MOVWF  FF8
0546C:  CALL   1D32
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
05470:  MOVLB  1
05472:  MOVF   xBE,W
05474:  MOVWF  FE9
05476:  MOVF   xBF,W
05478:  MOVWF  FEA
0547A:  MOVFF  FEF,1C0
....................    piclog_make(cmd, 0x00); // Log the command execution
0547E:  MOVFF  1C0,20F
05482:  MOVLB  2
05484:  CLRF   x10
05486:  MOVLB  0
05488:  CALL   4A82
....................    
....................    for (int32 address = MISF_START; address < MISF_END; address += SECTOR_64K_BYTE) {
0548C:  MOVLB  1
0548E:  CLRF   xC4
05490:  CLRF   xC3
05492:  CLRF   xC2
05494:  CLRF   xC1
05496:  MOVLB  0
05498:  MOVLB  1
0549A:  MOVF   xC4,F
0549C:  BTFSC  FD8.2
0549E:  BRA    54A6
054A0:  MOVLB  0
054A2:  GOTO   551E
054A6:  MOVLB  0
054A8:  MOVLB  1
054AA:  MOVF   xC3,W
054AC:  SUBLW  0F
054AE:  BTFSC  FD8.0
054B0:  BRA    54B8
054B2:  MOVLB  0
054B4:  GOTO   551E
054B8:  MOVLB  0
054BA:  BTFSS  FD8.2
054BC:  GOTO   54EA
054C0:  MOVLB  1
054C2:  MOVF   xC2,W
054C4:  SUBLW  FF
054C6:  BTFSC  FD8.0
054C8:  BRA    54D0
054CA:  MOVLB  0
054CC:  GOTO   551E
054D0:  MOVLB  0
054D2:  BTFSS  FD8.2
054D4:  GOTO   54EA
054D8:  MOVLB  1
054DA:  MOVF   xC1,W
054DC:  SUBLW  FE
054DE:  BTFSC  FD8.0
054E0:  BRA    54E8
054E2:  MOVLB  0
054E4:  GOTO   551E
054E8:  MOVLB  0
....................       sector_erase(mis_fm, address); // Erase each sector
054EA:  MOVFF  111,A7D
054EE:  MOVFF  110,A7C
054F2:  MOVFF  10F,A7B
054F6:  MOVFF  10E,A7A
054FA:  MOVFF  1C4,A81
054FE:  MOVFF  1C3,A80
05502:  MOVFF  1C2,A7F
05506:  MOVFF  1C1,A7E
0550A:  CALL   469C
0550E:  MOVLW  01
05510:  MOVLB  1
05512:  ADDWF  xC3,F
05514:  MOVLW  00
05516:  ADDWFC xC4,F
05518:  MOVLB  0
0551A:  GOTO   5498
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
0551E:  MOVFF  1C0,20F
05522:  MOVLB  2
05524:  SETF   x10
05526:  MOVLB  0
05528:  CALL   4A82
....................    printf("End Flash Erase All\r\n");
0552C:  MOVLW  96
0552E:  MOVWF  FF6
05530:  MOVLW  16
05532:  MOVWF  FF7
05534:  MOVLW  00
05536:  MOVWF  FF8
05538:  CALL   1D32
0553C:  RETURN 0
.................... }
.................... 
.................... void mode_misf_erase_1sector(int8 parameter[])
.................... {
....................    printf("Start Flash Erase 1 Sector\r\n");
0553E:  MOVLW  AC
05540:  MOVWF  FF6
05542:  MOVLW  16
05544:  MOVWF  FF7
05546:  MOVLW  00
05548:  MOVWF  FF8
0554A:  CALL   1D32
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 sector_address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
0554E:  MOVLB  1
05550:  MOVF   xBC,W
05552:  MOVWF  FE9
05554:  MOVF   xBD,W
05556:  MOVWF  FEA
05558:  MOVFF  FEF,1BE
0555C:  MOVLW  01
0555E:  ADDWF  xBC,W
05560:  MOVWF  FE9
05562:  MOVLW  00
05564:  ADDWFC xBD,W
05566:  MOVWF  FEA
05568:  MOVF   FEF,W
0556A:  CLRF   xC6
0556C:  CLRF   xC5
0556E:  CLRF   xC4
05570:  MOVWF  xC3
05572:  MOVFF  1C3,1C6
05576:  CLRF   xC3
05578:  CLRF   xC4
0557A:  CLRF   xC5
0557C:  MOVLW  02
0557E:  ADDWF  xBC,W
05580:  MOVWF  FE9
05582:  MOVLW  00
05584:  ADDWFC xBD,W
05586:  MOVWF  FEA
05588:  MOVF   FEF,W
0558A:  CLRF   xCB
0558C:  CLRF   xCA
0558E:  CLRF   xC9
05590:  MOVWF  xC8
05592:  MOVFF  1C9,03
05596:  MOVFF  1C8,02
0559A:  CLRF   00
0559C:  CLRF   01
0559E:  MOVF   00,W
055A0:  IORWF  xC3,F
055A2:  MOVF   01,W
055A4:  IORWF  xC4,F
055A6:  MOVF   02,W
055A8:  IORWF  xC5,F
055AA:  MOVF   03,W
055AC:  IORWF  xC6,F
055AE:  MOVLW  03
055B0:  ADDWF  xBC,W
055B2:  MOVWF  FE9
055B4:  MOVLW  00
055B6:  ADDWFC xBD,W
055B8:  MOVWF  FEA
055BA:  MOVF   FEF,W
055BC:  CLRF   xCB
055BE:  CLRF   xCA
055C0:  CLRF   xC9
055C2:  MOVWF  xC8
055C4:  MOVFF  1CA,03
055C8:  MOVFF  1C9,02
055CC:  MOVFF  1C8,01
055D0:  CLRF   00
055D2:  MOVF   00,W
055D4:  IORWF  xC3,F
055D6:  MOVF   01,W
055D8:  IORWF  xC4,F
055DA:  MOVF   02,W
055DC:  IORWF  xC5,F
055DE:  MOVF   03,W
055E0:  IORWF  xC6,F
055E2:  MOVLW  04
055E4:  ADDWF  xBC,W
055E6:  MOVWF  FE9
055E8:  MOVLW  00
055EA:  ADDWFC xBD,W
055EC:  MOVWF  FEA
055EE:  MOVF   FEF,W
055F0:  MOVWF  00
055F2:  CLRF   01
055F4:  CLRF   02
055F6:  CLRF   03
055F8:  MOVF   00,W
055FA:  IORWF  xC3,W
055FC:  MOVWF  xBF
055FE:  MOVF   01,W
05600:  IORWF  xC4,W
05602:  MOVWF  xC0
05604:  MOVF   02,W
05606:  IORWF  xC5,W
05608:  MOVWF  xC1
0560A:  MOVF   03,W
0560C:  IORWF  xC6,W
0560E:  MOVWF  xC2
.................... 
....................    printf("\tSector Address: 0x%08LX\r\n", sector_address);
05610:  MOVLW  CA
05612:  MOVWF  FF6
05614:  MOVLW  16
05616:  MOVWF  FF7
05618:  MOVLW  00
0561A:  MOVWF  FF8
0561C:  MOVLW  13
0561E:  MOVLB  3
05620:  MOVWF  x12
05622:  MOVLB  0
05624:  CALL   1D62
05628:  MOVFF  1C2,A39
0562C:  MOVLW  37
0562E:  MOVLB  A
05630:  MOVWF  x3A
05632:  MOVLB  0
05634:  CALL   1F60
05638:  MOVFF  1C1,A39
0563C:  MOVLW  37
0563E:  MOVLB  A
05640:  MOVWF  x3A
05642:  MOVLB  0
05644:  CALL   1F60
05648:  MOVFF  1C0,A39
0564C:  MOVLW  37
0564E:  MOVLB  A
05650:  MOVWF  x3A
05652:  MOVLB  0
05654:  CALL   1F60
05658:  MOVFF  1BF,A39
0565C:  MOVLW  37
0565E:  MOVLB  A
05660:  MOVWF  x3A
05662:  MOVLB  0
05664:  CALL   1F60
05668:  MOVLW  0D
0566A:  MOVLB  A
0566C:  MOVWF  xDB
0566E:  MOVLB  0
05670:  CALL   1CE0
05674:  MOVLW  0A
05676:  MOVLB  A
05678:  MOVWF  xDB
0567A:  MOVLB  0
0567C:  CALL   1CE0
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05680:  MOVFF  1BE,20F
05684:  MOVLB  2
05686:  CLRF   x10
05688:  MOVLB  0
0568A:  CALL   4A82
....................    
....................    sector_erase(mis_fm, sector_address);
0568E:  MOVFF  111,A7D
05692:  MOVFF  110,A7C
05696:  MOVFF  10F,A7B
0569A:  MOVFF  10E,A7A
0569E:  MOVFF  1C2,A81
056A2:  MOVFF  1C1,A80
056A6:  MOVFF  1C0,A7F
056AA:  MOVFF  1BF,A7E
056AE:  CALL   469C
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
056B2:  MOVFF  1BE,20F
056B6:  MOVLB  2
056B8:  SETF   x10
056BA:  MOVLB  0
056BC:  CALL   4A82
....................    printf("End Flash Erase 1 Sector\r\n");
056C0:  MOVLW  E6
056C2:  MOVWF  FF6
056C4:  MOVLW  16
056C6:  MOVWF  FF7
056C8:  MOVLW  00
056CA:  MOVWF  FF8
056CC:  CALL   1D32
056D0:  GOTO   9EEA (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_4kbyte_subsector(int8 parameter[])
.................... {
....................    printf("Start Flash Copy 1 Sector\r\n");
*
05A30:  MOVLW  02
05A32:  MOVWF  FF6
05A34:  MOVLW  17
05A36:  MOVWF  FF7
05A38:  MOVLW  00
05A3A:  MOVWF  FF8
05A3C:  CALL   1D32
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    int32 subsector_address =
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
05A40:  MOVLB  1
05A42:  MOVF   xBC,W
05A44:  MOVWF  FE9
05A46:  MOVF   xBD,W
05A48:  MOVWF  FEA
05A4A:  MOVFF  FEF,1BE
05A4E:  MOVLW  01
05A50:  ADDWF  xBC,W
05A52:  MOVWF  FE9
05A54:  MOVLW  00
05A56:  ADDWFC xBD,W
05A58:  MOVWF  FEA
05A5A:  MOVF   FEF,W
05A5C:  CLRF   xC6
05A5E:  CLRF   xC5
05A60:  CLRF   xC4
05A62:  MOVWF  xC3
05A64:  MOVFF  1C3,1C6
05A68:  CLRF   xC3
05A6A:  CLRF   xC4
05A6C:  CLRF   xC5
05A6E:  MOVLW  02
05A70:  ADDWF  xBC,W
05A72:  MOVWF  FE9
05A74:  MOVLW  00
05A76:  ADDWFC xBD,W
05A78:  MOVWF  FEA
05A7A:  MOVF   FEF,W
05A7C:  CLRF   xCB
05A7E:  CLRF   xCA
05A80:  CLRF   xC9
05A82:  MOVWF  xC8
05A84:  MOVFF  1C9,03
05A88:  MOVFF  1C8,02
05A8C:  CLRF   00
05A8E:  CLRF   01
05A90:  MOVF   00,W
05A92:  IORWF  xC3,F
05A94:  MOVF   01,W
05A96:  IORWF  xC4,F
05A98:  MOVF   02,W
05A9A:  IORWF  xC5,F
05A9C:  MOVF   03,W
05A9E:  IORWF  xC6,F
05AA0:  MOVLW  03
05AA2:  ADDWF  xBC,W
05AA4:  MOVWF  FE9
05AA6:  MOVLW  00
05AA8:  ADDWFC xBD,W
05AAA:  MOVWF  FEA
05AAC:  MOVF   FEF,W
05AAE:  CLRF   xCB
05AB0:  CLRF   xCA
05AB2:  CLRF   xC9
05AB4:  MOVWF  xC8
05AB6:  MOVFF  1CA,03
05ABA:  MOVFF  1C9,02
05ABE:  MOVFF  1C8,01
05AC2:  CLRF   00
05AC4:  MOVF   00,W
05AC6:  IORWF  xC3,F
05AC8:  MOVF   01,W
05ACA:  IORWF  xC4,F
05ACC:  MOVF   02,W
05ACE:  IORWF  xC5,F
05AD0:  MOVF   03,W
05AD2:  IORWF  xC6,F
05AD4:  MOVLW  04
05AD6:  ADDWF  xBC,W
05AD8:  MOVWF  FE9
05ADA:  MOVLW  00
05ADC:  ADDWFC xBD,W
05ADE:  MOVWF  FEA
05AE0:  MOVF   FEF,W
05AE2:  MOVWF  00
05AE4:  CLRF   01
05AE6:  CLRF   02
05AE8:  CLRF   03
05AEA:  MOVF   00,W
05AEC:  IORWF  xC3,W
05AEE:  MOVWF  xBF
05AF0:  MOVF   01,W
05AF2:  IORWF  xC4,W
05AF4:  MOVWF  xC0
05AF6:  MOVF   02,W
05AF8:  IORWF  xC5,W
05AFA:  MOVWF  xC1
05AFC:  MOVF   03,W
05AFE:  IORWF  xC6,W
05B00:  MOVWF  xC2
....................    
....................    printf("\tSubsector Address: 0x%08LX\r\n", subsector_address);
05B02:  MOVLW  1E
05B04:  MOVWF  FF6
05B06:  MOVLW  17
05B08:  MOVWF  FF7
05B0A:  MOVLW  00
05B0C:  MOVWF  FF8
05B0E:  MOVLW  16
05B10:  MOVLB  3
05B12:  MOVWF  x12
05B14:  MOVLB  0
05B16:  CALL   1D62
05B1A:  MOVFF  1C2,A39
05B1E:  MOVLW  37
05B20:  MOVLB  A
05B22:  MOVWF  x3A
05B24:  MOVLB  0
05B26:  CALL   1F60
05B2A:  MOVFF  1C1,A39
05B2E:  MOVLW  37
05B30:  MOVLB  A
05B32:  MOVWF  x3A
05B34:  MOVLB  0
05B36:  CALL   1F60
05B3A:  MOVFF  1C0,A39
05B3E:  MOVLW  37
05B40:  MOVLB  A
05B42:  MOVWF  x3A
05B44:  MOVLB  0
05B46:  CALL   1F60
05B4A:  MOVFF  1BF,A39
05B4E:  MOVLW  37
05B50:  MOVLB  A
05B52:  MOVWF  x3A
05B54:  MOVLB  0
05B56:  CALL   1F60
05B5A:  MOVLW  0D
05B5C:  MOVLB  A
05B5E:  MOVWF  xDB
05B60:  MOVLB  0
05B62:  CALL   1CE0
05B66:  MOVLW  0A
05B68:  MOVLB  A
05B6A:  MOVWF  xDB
05B6C:  MOVLB  0
05B6E:  CALL   1CE0
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05B72:  MOVFF  1BE,20F
05B76:  MOVLB  2
05B78:  CLRF   x10
05B7A:  MOVLB  0
05B7C:  CALL   4A82
....................    
....................    // 統合管理システムから消去操作をキューに追加
....................    //enqueue_erase_data(subsector_address, 0x1000); // 4KB消去
....................    
....................    subsector_4kByte_erase(mis_fm, 0x00000000);
05B80:  MOVFF  111,314
05B84:  MOVFF  110,313
05B88:  MOVFF  10F,312
05B8C:  MOVFF  10E,311
05B90:  MOVLB  3
05B92:  CLRF   x18
05B94:  CLRF   x17
05B96:  CLRF   x16
05B98:  CLRF   x15
05B9A:  MOVLB  0
05B9C:  CALL   56D4
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05BA0:  MOVFF  1BE,20F
05BA4:  MOVLB  2
05BA6:  SETF   x10
05BA8:  MOVLB  0
05BAA:  CALL   4A82
....................    printf("End Flash Copy 1 Sector\r\n");
05BAE:  MOVLW  3C
05BB0:  MOVWF  FF6
05BB2:  MOVLW  17
05BB4:  MOVWF  FF7
05BB6:  MOVLW  00
05BB8:  MOVWF  FF8
05BBA:  CALL   1D32
05BBE:  GOTO   9EFA (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_64kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase 64kByte Subsector\r\n");
05BC2:  MOVLW  56
05BC4:  MOVWF  FF6
05BC6:  MOVLW  17
05BC8:  MOVWF  FF7
05BCA:  MOVLW  00
05BCC:  MOVWF  FF8
05BCE:  CALL   1D32
....................    unsigned int8 cmd = parameter[0]; // Get the command ID from the parameter array
....................    unsigned int32 subsector_address =
....................       ((unsigned int32)parameter[1] << 24) |
....................       ((unsigned int32)parameter[2] << 16) |
....................       ((unsigned int32)parameter[3] << 8)  |
....................       ((unsigned int32)parameter[4]);
05BD2:  MOVLB  1
05BD4:  MOVF   xBC,W
05BD6:  MOVWF  FE9
05BD8:  MOVF   xBD,W
05BDA:  MOVWF  FEA
05BDC:  MOVFF  FEF,1BE
05BE0:  MOVLW  01
05BE2:  ADDWF  xBC,W
05BE4:  MOVWF  FE9
05BE6:  MOVLW  00
05BE8:  ADDWFC xBD,W
05BEA:  MOVWF  FEA
05BEC:  MOVF   FEF,W
05BEE:  CLRF   xC6
05BF0:  CLRF   xC5
05BF2:  CLRF   xC4
05BF4:  MOVWF  xC3
05BF6:  MOVFF  1C3,1C6
05BFA:  CLRF   xC3
05BFC:  CLRF   xC4
05BFE:  CLRF   xC5
05C00:  MOVLW  02
05C02:  ADDWF  xBC,W
05C04:  MOVWF  FE9
05C06:  MOVLW  00
05C08:  ADDWFC xBD,W
05C0A:  MOVWF  FEA
05C0C:  MOVF   FEF,W
05C0E:  CLRF   xCB
05C10:  CLRF   xCA
05C12:  CLRF   xC9
05C14:  MOVWF  xC8
05C16:  MOVFF  1C9,03
05C1A:  MOVFF  1C8,02
05C1E:  CLRF   00
05C20:  CLRF   01
05C22:  MOVF   00,W
05C24:  IORWF  xC3,F
05C26:  MOVF   01,W
05C28:  IORWF  xC4,F
05C2A:  MOVF   02,W
05C2C:  IORWF  xC5,F
05C2E:  MOVF   03,W
05C30:  IORWF  xC6,F
05C32:  MOVLW  03
05C34:  ADDWF  xBC,W
05C36:  MOVWF  FE9
05C38:  MOVLW  00
05C3A:  ADDWFC xBD,W
05C3C:  MOVWF  FEA
05C3E:  MOVF   FEF,W
05C40:  CLRF   xCB
05C42:  CLRF   xCA
05C44:  CLRF   xC9
05C46:  MOVWF  xC8
05C48:  MOVFF  1CA,03
05C4C:  MOVFF  1C9,02
05C50:  MOVFF  1C8,01
05C54:  CLRF   00
05C56:  MOVF   00,W
05C58:  IORWF  xC3,F
05C5A:  MOVF   01,W
05C5C:  IORWF  xC4,F
05C5E:  MOVF   02,W
05C60:  IORWF  xC5,F
05C62:  MOVF   03,W
05C64:  IORWF  xC6,F
05C66:  MOVLW  04
05C68:  ADDWF  xBC,W
05C6A:  MOVWF  FE9
05C6C:  MOVLW  00
05C6E:  ADDWFC xBD,W
05C70:  MOVWF  FEA
05C72:  MOVF   FEF,W
05C74:  MOVWF  00
05C76:  CLRF   01
05C78:  CLRF   02
05C7A:  CLRF   03
05C7C:  MOVF   00,W
05C7E:  IORWF  xC3,W
05C80:  MOVWF  xBF
05C82:  MOVF   01,W
05C84:  IORWF  xC4,W
05C86:  MOVWF  xC0
05C88:  MOVF   02,W
05C8A:  IORWF  xC5,W
05C8C:  MOVWF  xC1
05C8E:  MOVF   03,W
05C90:  IORWF  xC6,W
05C92:  MOVWF  xC2
....................    
....................    fprintf(PC, "\tSubsector Address: 0x%08LX\r\n", subsector_address);
05C94:  MOVLW  7C
05C96:  MOVWF  FF6
05C98:  MOVLW  17
05C9A:  MOVWF  FF7
05C9C:  MOVLW  00
05C9E:  MOVWF  FF8
05CA0:  MOVLW  16
05CA2:  MOVLB  3
05CA4:  MOVWF  x12
05CA6:  MOVLB  0
05CA8:  CALL   1D62
05CAC:  MOVFF  1C2,A39
05CB0:  MOVLW  37
05CB2:  MOVLB  A
05CB4:  MOVWF  x3A
05CB6:  MOVLB  0
05CB8:  CALL   1F60
05CBC:  MOVFF  1C1,A39
05CC0:  MOVLW  37
05CC2:  MOVLB  A
05CC4:  MOVWF  x3A
05CC6:  MOVLB  0
05CC8:  CALL   1F60
05CCC:  MOVFF  1C0,A39
05CD0:  MOVLW  37
05CD2:  MOVLB  A
05CD4:  MOVWF  x3A
05CD6:  MOVLB  0
05CD8:  CALL   1F60
05CDC:  MOVFF  1BF,A39
05CE0:  MOVLW  37
05CE2:  MOVLB  A
05CE4:  MOVWF  x3A
05CE6:  MOVLB  0
05CE8:  CALL   1F60
05CEC:  MOVLW  0D
05CEE:  MOVLB  A
05CF0:  MOVWF  xDB
05CF2:  MOVLB  0
05CF4:  CALL   1CE0
05CF8:  MOVLW  0A
05CFA:  MOVLB  A
05CFC:  MOVWF  xDB
05CFE:  MOVLB  0
05D00:  CALL   1CE0
....................    piclog_make(cmd, PICLOG_PARAM_START); // Log the command execution
05D04:  MOVFF  1BE,20F
05D08:  MOVLB  2
05D0A:  CLRF   x10
05D0C:  MOVLB  0
05D0E:  CALL   4A82
....................    
....................    //subsector_64kByte_erase(mis_fm, subsector_address);
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
05D12:  MOVFF  1BE,20F
05D16:  MOVLB  2
05D18:  SETF   x10
05D1A:  MOVLB  0
05D1C:  CALL   4A82
....................    fprintf(PC, "End Flash Erase 64kByte Subsector\r\n");
05D20:  MOVLW  9A
05D22:  MOVWF  FF6
05D24:  MOVLW  17
05D26:  MOVWF  FF7
05D28:  MOVLW  00
05D2A:  MOVWF  FF8
05D2C:  CALL   1D32
05D30:  GOTO   9F0A (RETURN)
.................... }
.................... 
.................... void mode_misf_write_demo(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write Demo\r\n");
05D34:  MOVLW  BE
05D36:  MOVWF  FF6
05D38:  MOVLW  17
05D3A:  MOVWF  FF7
05D3C:  MOVLW  00
05D3E:  MOVWF  FF8
05D40:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
05D44:  MOVLB  1
05D46:  MOVF   xBC,W
05D48:  MOVWF  FE9
05D4A:  MOVF   xBD,W
05D4C:  MOVWF  FEA
05D4E:  MOVFF  FEF,20E
05D52:  MOVFF  20E,20F
05D56:  MOVLB  2
05D58:  CLRF   x10
05D5A:  MOVLB  0
05D5C:  CALL   4A82
.................... 
....................    FLASH_WRITE_PARAM flash_write_param = {0};
05D60:  MOVLB  1
05D62:  CLRF   xBE
05D64:  CLRF   xBF
05D66:  CLRF   xC0
05D68:  CLRF   xC1
05D6A:  CLRF   xC2
05D6C:  CLRF   xC3
05D6E:  CLRF   xC4
....................    
....................    flash_write_param.id = parameter[0];
05D70:  MOVF   xBC,W
05D72:  MOVWF  FE9
05D74:  MOVF   xBD,W
05D76:  MOVWF  FEA
05D78:  MOVFF  FEF,1BE
....................    flash_write_param.writeaddress =
....................    ((unsigned int32)parameter[1] << 24) |
....................    ((unsigned int32)parameter[2] << 16) |
....................    ((unsigned int32)parameter[3] << 8)  |
....................    ((unsigned int32)parameter[4]);
05D7C:  MOVLW  01
05D7E:  ADDWF  xBC,W
05D80:  MOVWF  FE9
05D82:  MOVLW  00
05D84:  ADDWFC xBD,W
05D86:  MOVWF  FEA
05D88:  MOVF   FEF,W
05D8A:  MOVLB  2
05D8C:  CLRF   x11
05D8E:  CLRF   x10
05D90:  CLRF   x0F
05D92:  MOVWF  x0E
05D94:  MOVFF  20E,211
05D98:  CLRF   x0E
05D9A:  CLRF   x0F
05D9C:  CLRF   x10
05D9E:  MOVLW  02
05DA0:  MOVLB  1
05DA2:  ADDWF  xBC,W
05DA4:  MOVWF  FE9
05DA6:  MOVLW  00
05DA8:  ADDWFC xBD,W
05DAA:  MOVWF  FEA
05DAC:  MOVF   FEF,W
05DAE:  MOVLB  2
05DB0:  CLRF   x16
05DB2:  CLRF   x15
05DB4:  CLRF   x14
05DB6:  MOVWF  x13
05DB8:  MOVFF  214,03
05DBC:  MOVFF  213,02
05DC0:  CLRF   00
05DC2:  CLRF   01
05DC4:  MOVF   00,W
05DC6:  IORWF  x0E,F
05DC8:  MOVF   01,W
05DCA:  IORWF  x0F,F
05DCC:  MOVF   02,W
05DCE:  IORWF  x10,F
05DD0:  MOVF   03,W
05DD2:  IORWF  x11,F
05DD4:  MOVLW  03
05DD6:  MOVLB  1
05DD8:  ADDWF  xBC,W
05DDA:  MOVWF  FE9
05DDC:  MOVLW  00
05DDE:  ADDWFC xBD,W
05DE0:  MOVWF  FEA
05DE2:  MOVF   FEF,W
05DE4:  MOVLB  2
05DE6:  CLRF   x16
05DE8:  CLRF   x15
05DEA:  CLRF   x14
05DEC:  MOVWF  x13
05DEE:  MOVFF  215,03
05DF2:  MOVFF  214,02
05DF6:  MOVFF  213,01
05DFA:  CLRF   00
05DFC:  MOVF   00,W
05DFE:  IORWF  x0E,F
05E00:  MOVF   01,W
05E02:  IORWF  x0F,F
05E04:  MOVF   02,W
05E06:  IORWF  x10,F
05E08:  MOVF   03,W
05E0A:  IORWF  x11,F
05E0C:  MOVLW  04
05E0E:  MOVLB  1
05E10:  ADDWF  xBC,W
05E12:  MOVWF  FE9
05E14:  MOVLW  00
05E16:  ADDWFC xBD,W
05E18:  MOVWF  FEA
05E1A:  MOVF   FEF,W
05E1C:  MOVWF  00
05E1E:  CLRF   01
05E20:  CLRF   02
05E22:  CLRF   03
05E24:  MOVF   00,W
05E26:  MOVLB  2
05E28:  IORWF  x0E,W
05E2A:  MOVLB  1
05E2C:  MOVWF  xBF
05E2E:  MOVF   01,W
05E30:  MOVLB  2
05E32:  IORWF  x0F,W
05E34:  MOVLB  1
05E36:  MOVWF  xC0
05E38:  MOVF   02,W
05E3A:  MOVLB  2
05E3C:  IORWF  x10,W
05E3E:  MOVLB  1
05E40:  MOVWF  xC1
05E42:  MOVF   03,W
05E44:  MOVLB  2
05E46:  IORWF  x11,W
05E48:  MOVLB  1
05E4A:  MOVWF  xC2
....................    flash_write_param.packetnum =
....................    ((unsigned int16)parameter[7] << 8) |
....................    ((unsigned int16)parameter[8]);
05E4C:  MOVLW  07
05E4E:  ADDWF  xBC,W
05E50:  MOVWF  FE9
05E52:  MOVLW  00
05E54:  ADDWFC xBD,W
05E56:  MOVWF  FEA
05E58:  MOVF   FEF,W
05E5A:  MOVLB  2
05E5C:  CLRF   x0F
05E5E:  MOVWF  x0E
05E60:  MOVFF  20E,20F
05E64:  CLRF   x0E
05E66:  MOVLW  08
05E68:  MOVLB  1
05E6A:  ADDWF  xBC,W
05E6C:  MOVWF  FE9
05E6E:  MOVLW  00
05E70:  ADDWFC xBD,W
05E72:  MOVWF  FEA
05E74:  MOVF   FEF,W
05E76:  CLRF   03
05E78:  MOVLB  2
05E7A:  IORWF  x0E,W
05E7C:  MOVLB  1
05E7E:  MOVWF  xC3
05E80:  MOVF   03,W
05E82:  MOVLB  2
05E84:  IORWF  x0F,W
05E86:  MOVLB  1
05E88:  MOVWF  xC4
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_write_param.id);
05E8A:  MOVLW  D8
05E8C:  MOVWF  FF6
05E8E:  MOVLW  17
05E90:  MOVWF  FF7
05E92:  MOVLW  00
05E94:  MOVWF  FF8
05E96:  MOVLW  0C
05E98:  MOVLB  3
05E9A:  MOVWF  x12
05E9C:  MOVLB  0
05E9E:  CALL   1D62
05EA2:  MOVFF  1BE,A39
05EA6:  MOVLW  37
05EA8:  MOVLB  A
05EAA:  MOVWF  x3A
05EAC:  MOVLB  0
05EAE:  CALL   1F60
05EB2:  MOVLW  0D
05EB4:  MOVLB  A
05EB6:  MOVWF  xDB
05EB8:  MOVLB  0
05EBA:  CALL   1CE0
05EBE:  MOVLW  0A
05EC0:  MOVLB  A
05EC2:  MOVWF  xDB
05EC4:  MOVLB  0
05EC6:  CALL   1CE0
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_write_param.writeaddress);
05ECA:  MOVLW  EC
05ECC:  MOVWF  FF6
05ECE:  MOVLW  17
05ED0:  MOVWF  FF7
05ED2:  MOVLW  00
05ED4:  MOVWF  FF8
05ED6:  MOVLW  0E
05ED8:  MOVLB  3
05EDA:  MOVWF  x12
05EDC:  MOVLB  0
05EDE:  CALL   1D62
05EE2:  MOVFF  1C2,A39
05EE6:  MOVLW  37
05EE8:  MOVLB  A
05EEA:  MOVWF  x3A
05EEC:  MOVLB  0
05EEE:  CALL   1F60
05EF2:  MOVFF  1C1,A39
05EF6:  MOVLW  37
05EF8:  MOVLB  A
05EFA:  MOVWF  x3A
05EFC:  MOVLB  0
05EFE:  CALL   1F60
05F02:  MOVFF  1C0,A39
05F06:  MOVLW  37
05F08:  MOVLB  A
05F0A:  MOVWF  x3A
05F0C:  MOVLB  0
05F0E:  CALL   1F60
05F12:  MOVFF  1BF,A39
05F16:  MOVLW  37
05F18:  MOVLB  A
05F1A:  MOVWF  x3A
05F1C:  MOVLB  0
05F1E:  CALL   1F60
05F22:  MOVLW  0D
05F24:  MOVLB  A
05F26:  MOVWF  xDB
05F28:  MOVLB  0
05F2A:  CALL   1CE0
05F2E:  MOVLW  0A
05F30:  MOVLB  A
05F32:  MOVWF  xDB
05F34:  MOVLB  0
05F36:  CALL   1CE0
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_write_param.packetnum);
05F3A:  MOVLW  02
05F3C:  MOVWF  FF6
05F3E:  MOVLW  18
05F40:  MOVWF  FF7
05F42:  MOVLW  00
05F44:  MOVWF  FF8
05F46:  MOVLW  0E
05F48:  MOVLB  3
05F4A:  MOVWF  x12
05F4C:  MOVLB  0
05F4E:  CALL   1D62
05F52:  MOVFF  1C4,A39
05F56:  MOVLW  37
05F58:  MOVLB  A
05F5A:  MOVWF  x3A
05F5C:  MOVLB  0
05F5E:  CALL   1F60
05F62:  MOVFF  1C3,A39
05F66:  MOVLW  37
05F68:  MOVLB  A
05F6A:  MOVWF  x3A
05F6C:  MOVLB  0
05F6E:  CALL   1F60
05F72:  MOVLW  0D
05F74:  MOVLB  A
05F76:  MOVWF  xDB
05F78:  MOVLB  0
05F7A:  CALL   1CE0
05F7E:  MOVLW  0A
05F80:  MOVLB  A
05F82:  MOVWF  xDB
05F84:  MOVLB  0
05F86:  CALL   1CE0
.................... 
....................    piclog_make(flash_write_param.id, 0x00); // Log the command execution
05F8A:  MOVFF  1BE,20F
05F8E:  MOVLB  2
05F90:  CLRF   x10
05F92:  MOVLB  0
05F94:  CALL   4A82
....................    
....................    unsigned int8 writedata[64];
....................    unsigned int16 p; // packet index
....................    unsigned int16 base_value;
.................... 
....................    fprintf(PC, "Write Data\r\n");
05F98:  MOVLW  18
05F9A:  MOVWF  FF6
05F9C:  MOVLW  18
05F9E:  MOVWF  FF7
05FA0:  MOVLW  00
05FA2:  MOVWF  FF8
05FA4:  CALL   1D32
....................    for (p = 0; p < flash_write_param.packetnum; p++)
05FA8:  MOVLB  2
05FAA:  CLRF   x06
05FAC:  CLRF   x05
05FAE:  MOVLB  0
05FB0:  MOVLB  2
05FB2:  MOVF   x06,W
05FB4:  MOVLB  1
05FB6:  SUBWF  xC4,W
05FB8:  BTFSC  FD8.0
05FBA:  BRA    5FC2
05FBC:  MOVLB  0
05FBE:  GOTO   6102
05FC2:  MOVLB  0
05FC4:  BTFSS  FD8.2
05FC6:  GOTO   5FDE
05FCA:  MOVLB  1
05FCC:  MOVF   xC3,W
05FCE:  MOVLB  2
05FD0:  SUBWF  x05,W
05FD2:  BTFSS  FD8.0
05FD4:  BRA    5FDC
05FD6:  MOVLB  0
05FD8:  GOTO   6102
05FDC:  MOVLB  0
....................    {
....................       base_value = p * PACKET_SIZE;  // パケット毎のスタート値
05FDE:  MOVLB  2
05FE0:  RLCF   x05,W
05FE2:  MOVWF  x07
05FE4:  RLCF   x06,W
05FE6:  MOVWF  x08
05FE8:  RLCF   x07,F
05FEA:  RLCF   x08,F
05FEC:  RLCF   x07,F
05FEE:  RLCF   x08,F
05FF0:  RLCF   x07,F
05FF2:  RLCF   x08,F
05FF4:  RLCF   x07,F
05FF6:  RLCF   x08,F
05FF8:  RLCF   x07,F
05FFA:  RLCF   x08,F
05FFC:  MOVLW  C0
05FFE:  ANDWF  x07,F
.................... 
....................       for (unsigned int8 i = 0; i < PACKET_SIZE; i++)
06000:  CLRF   x09
06002:  MOVLB  0
06004:  MOVLB  2
06006:  MOVF   x09,W
06008:  SUBLW  3F
0600A:  BTFSC  FD8.0
0600C:  BRA    6014
0600E:  MOVLB  0
06010:  GOTO   6074
06014:  MOVLB  0
....................       {
....................          writedata[i] = (base_value + i) & 0xFF; // 0x00〜0xFFをループ
06016:  CLRF   03
06018:  MOVLB  2
0601A:  MOVF   x09,W
0601C:  ADDLW  C5
0601E:  MOVWF  FE9
06020:  MOVLW  01
06022:  ADDWFC 03,W
06024:  MOVWF  FEA
06026:  MOVF   x09,W
06028:  ADDWF  x07,W
0602A:  MOVWF  x10
0602C:  MOVLW  00
0602E:  ADDWFC x08,W
06030:  MOVWF  x11
06032:  MOVF   x10,W
06034:  MOVWF  00
06036:  CLRF   03
06038:  MOVF   00,W
0603A:  MOVWF  FEF
....................          fprintf(PC, "%02X ", writedata[i]); // デバッグ用に書き込みデータを表示
0603C:  CLRF   03
0603E:  MOVF   x09,W
06040:  ADDLW  C5
06042:  MOVWF  FE9
06044:  MOVLW  01
06046:  ADDWFC 03,W
06048:  MOVWF  FEA
0604A:  MOVFF  FEF,20E
0604E:  MOVFF  20E,A39
06052:  MOVLW  37
06054:  MOVLB  A
06056:  MOVWF  x3A
06058:  MOVLB  0
0605A:  CALL   1F60
0605E:  MOVLW  20
06060:  MOVLB  A
06062:  MOVWF  xDB
06064:  MOVLB  0
06066:  CALL   1CE0
0606A:  MOVLB  2
0606C:  INCF   x09,F
0606E:  MOVLB  0
06070:  GOTO   6004
....................       }
.................... 
....................       unsigned int32 current_address = flash_write_param.writeaddress + (p * PACKET_SIZE);
06074:  MOVLB  2
06076:  RLCF   x05,W
06078:  MOVWF  02
0607A:  RLCF   x06,W
0607C:  MOVWF  03
0607E:  RLCF   02,F
06080:  RLCF   03,F
06082:  RLCF   02,F
06084:  RLCF   03,F
06086:  RLCF   02,F
06088:  RLCF   03,F
0608A:  RLCF   02,F
0608C:  RLCF   03,F
0608E:  RLCF   02,F
06090:  RLCF   03,F
06092:  MOVLW  C0
06094:  ANDWF  02,F
06096:  MOVF   02,W
06098:  MOVLB  1
0609A:  ADDWF  xBF,W
0609C:  MOVLB  2
0609E:  MOVWF  x0A
060A0:  MOVF   03,W
060A2:  MOVLB  1
060A4:  ADDWFC xC0,W
060A6:  MOVLB  2
060A8:  MOVWF  x0B
060AA:  MOVLW  00
060AC:  MOVLB  1
060AE:  ADDWFC xC1,W
060B0:  MOVLB  2
060B2:  MOVWF  x0C
060B4:  MOVLW  00
060B6:  MOVLB  1
060B8:  ADDWFC xC2,W
060BA:  MOVLB  2
060BC:  MOVWF  x0D
.................... 
....................       write_data_bytes(mis_fm, current_address, writedata, PACKET_SIZE);
060BE:  MOVFF  111,A7F
060C2:  MOVFF  110,A7E
060C6:  MOVFF  10F,A7D
060CA:  MOVFF  10E,A7C
060CE:  MOVFF  20D,A83
060D2:  MOVFF  20C,A82
060D6:  MOVFF  20B,A81
060DA:  MOVFF  20A,A80
060DE:  MOVLW  01
060E0:  MOVLB  A
060E2:  MOVWF  x85
060E4:  MOVLW  C5
060E6:  MOVWF  x84
060E8:  CLRF   x87
060EA:  MOVLW  40
060EC:  MOVWF  x86
060EE:  MOVLB  0
060F0:  CALL   3F84
060F4:  MOVLB  2
060F6:  INCF   x05,F
060F8:  BTFSC  FD8.2
060FA:  INCF   x06,F
060FC:  MOVLB  0
060FE:  GOTO   5FB0
....................    }
.................... 
....................    piclog_make(flash_write_param.id, PICLOG_PARAM_END); // Log the end of the command execution
06102:  MOVFF  1BE,20F
06106:  MOVLB  2
06108:  SETF   x10
0610A:  MOVLB  0
0610C:  CALL   4A82
....................    fprintf(PC, "\r\n");
06110:  MOVLW  0D
06112:  MOVLB  A
06114:  MOVWF  xDB
06116:  MOVLB  0
06118:  CALL   1CE0
0611C:  MOVLW  0A
0611E:  MOVLB  A
06120:  MOVWF  xDB
06122:  MOVLB  0
06124:  CALL   1CE0
....................    fprintf(PC, "End Flash Write Demo\r\n");
06128:  MOVLW  26
0612A:  MOVWF  FF6
0612C:  MOVLW  18
0612E:  MOVWF  FF7
06130:  MOVLW  00
06132:  MOVWF  FF8
06134:  CALL   1D32
06138:  GOTO   9F1A (RETURN)
.................... }
.................... 
.................... void mode_misf_write_4kbyte_subsector(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Write 4kByte Subsector\r\n");
*
0616C:  MOVLW  3E
0616E:  MOVWF  FF6
06170:  MOVLW  18
06172:  MOVWF  FF7
06174:  MOVLW  00
06176:  MOVWF  FF8
06178:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
0617C:  MOVLB  1
0617E:  MOVF   xBC,W
06180:  MOVWF  FE9
06182:  MOVF   xBD,W
06184:  MOVWF  FEA
06186:  MOVFF  FEF,1C2
0618A:  MOVFF  1C2,20F
0618E:  MOVLB  2
06190:  CLRF   x10
06192:  MOVLB  0
06194:  CALL   4A82
....................    flash_setting(mis_fm);
06198:  MOVFF  111,2CA
0619C:  MOVFF  110,2C9
061A0:  MOVFF  10F,2C8
061A4:  MOVFF  10E,2C7
061A8:  CALL   613C
....................    unsigned int32 write_address = 0x00000000;
061AC:  MOVLB  1
061AE:  CLRF   xC1
061B0:  CLRF   xC0
061B2:  CLRF   xBF
061B4:  CLRF   xBE
....................    //int8 write_data[256] = {0x01, 0x02, 0x03, 0x04}; // Example data
....................    //write_data_bytes(mis_fm, write_address, write_data, 256);
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
061B6:  MOVF   xBC,W
061B8:  MOVWF  FE9
061BA:  MOVF   xBD,W
061BC:  MOVWF  FEA
061BE:  MOVFF  FEF,1C2
061C2:  MOVFF  1C2,20F
061C6:  MOVLB  2
061C8:  SETF   x10
061CA:  MOVLB  0
061CC:  CALL   4A82
....................    fprintf(PC, "End Flash Write 4kByte Subsector\r\n");
061D0:  MOVLW  64
061D2:  MOVWF  FF6
061D4:  MOVLW  18
061D6:  MOVWF  FF7
061D8:  MOVLW  00
061DA:  MOVWF  FF8
061DC:  CALL   1D32
061E0:  GOTO   9F2A (RETURN)
.................... }
.................... 
.................... void mode_misf_read(unsigned int8 uplinkcmd[])
.................... {
....................    fprintf(PC, "Start Flash Read\r\n");
061E4:  MOVLW  88
061E6:  MOVWF  FF6
061E8:  MOVLW  18
061EA:  MOVWF  FF7
061EC:  MOVLW  00
061EE:  MOVWF  FF8
061F0:  CALL   1D32
....................    piclog_make(uplinkcmd[0], PICLOG_PARAM_START); // Log the command execution
061F4:  MOVLB  1
061F6:  MOVF   xBC,W
061F8:  MOVWF  FE9
061FA:  MOVF   xBD,W
061FC:  MOVWF  FEA
061FE:  MOVFF  FEF,20E
06202:  MOVFF  20E,20F
06206:  MOVLB  2
06208:  CLRF   x10
0620A:  MOVLB  0
0620C:  CALL   4A82
....................    FLASH_PARAM flash_param = {0};
06210:  MOVLB  1
06212:  CLRF   xBE
06214:  CLRF   xBF
06216:  CLRF   xC0
06218:  CLRF   xC1
0621A:  CLRF   xC2
0621C:  CLRF   xC3
0621E:  CLRF   xC4
....................    // for(unsigned int8 i = 0; i < PARAMETER_LENGTH; i++)
....................    // {
....................    //    fprintf(PC, "Parameter[%d]: %02X\r\n", i, parameter[i]);
....................    // }
....................    flash_param.id = uplinkcmd[0];
06220:  MOVF   xBC,W
06222:  MOVWF  FE9
06224:  MOVF   xBD,W
06226:  MOVWF  FEA
06228:  MOVFF  FEF,1BE
....................    flash_param.readaddress = 
....................    ((unsigned int32)uplinkcmd[1] << 24) |
....................    ((unsigned int32)uplinkcmd[2] << 16) |
....................    ((unsigned int32)uplinkcmd[3] << 8)  |
....................    ((unsigned int32)uplinkcmd[4]);
0622C:  MOVLW  01
0622E:  ADDWF  xBC,W
06230:  MOVWF  FE9
06232:  MOVLW  00
06234:  ADDWFC xBD,W
06236:  MOVWF  FEA
06238:  MOVF   FEF,W
0623A:  MOVLB  2
0623C:  CLRF   x11
0623E:  CLRF   x10
06240:  CLRF   x0F
06242:  MOVWF  x0E
06244:  MOVFF  20E,211
06248:  CLRF   x0E
0624A:  CLRF   x0F
0624C:  CLRF   x10
0624E:  MOVLW  02
06250:  MOVLB  1
06252:  ADDWF  xBC,W
06254:  MOVWF  FE9
06256:  MOVLW  00
06258:  ADDWFC xBD,W
0625A:  MOVWF  FEA
0625C:  MOVF   FEF,W
0625E:  MOVLB  2
06260:  CLRF   x16
06262:  CLRF   x15
06264:  CLRF   x14
06266:  MOVWF  x13
06268:  MOVFF  214,03
0626C:  MOVFF  213,02
06270:  CLRF   00
06272:  CLRF   01
06274:  MOVF   00,W
06276:  IORWF  x0E,F
06278:  MOVF   01,W
0627A:  IORWF  x0F,F
0627C:  MOVF   02,W
0627E:  IORWF  x10,F
06280:  MOVF   03,W
06282:  IORWF  x11,F
06284:  MOVLW  03
06286:  MOVLB  1
06288:  ADDWF  xBC,W
0628A:  MOVWF  FE9
0628C:  MOVLW  00
0628E:  ADDWFC xBD,W
06290:  MOVWF  FEA
06292:  MOVF   FEF,W
06294:  MOVLB  2
06296:  CLRF   x16
06298:  CLRF   x15
0629A:  CLRF   x14
0629C:  MOVWF  x13
0629E:  MOVFF  215,03
062A2:  MOVFF  214,02
062A6:  MOVFF  213,01
062AA:  CLRF   00
062AC:  MOVF   00,W
062AE:  IORWF  x0E,F
062B0:  MOVF   01,W
062B2:  IORWF  x0F,F
062B4:  MOVF   02,W
062B6:  IORWF  x10,F
062B8:  MOVF   03,W
062BA:  IORWF  x11,F
062BC:  MOVLW  04
062BE:  MOVLB  1
062C0:  ADDWF  xBC,W
062C2:  MOVWF  FE9
062C4:  MOVLW  00
062C6:  ADDWFC xBD,W
062C8:  MOVWF  FEA
062CA:  MOVF   FEF,W
062CC:  MOVWF  00
062CE:  CLRF   01
062D0:  CLRF   02
062D2:  CLRF   03
062D4:  MOVF   00,W
062D6:  MOVLB  2
062D8:  IORWF  x0E,W
062DA:  MOVLB  1
062DC:  MOVWF  xC1
062DE:  MOVF   01,W
062E0:  MOVLB  2
062E2:  IORWF  x0F,W
062E4:  MOVLB  1
062E6:  MOVWF  xC2
062E8:  MOVF   02,W
062EA:  MOVLB  2
062EC:  IORWF  x10,W
062EE:  MOVLB  1
062F0:  MOVWF  xC3
062F2:  MOVF   03,W
062F4:  MOVLB  2
062F6:  IORWF  x11,W
062F8:  MOVLB  1
062FA:  MOVWF  xC4
.................... 
....................    flash_param.readpacketnum =
....................     ((unsigned int16)uplinkcmd[7] << 8) |
....................     ((unsigned int16)uplinkcmd[8]);
062FC:  MOVLW  07
062FE:  ADDWF  xBC,W
06300:  MOVWF  FE9
06302:  MOVLW  00
06304:  ADDWFC xBD,W
06306:  MOVWF  FEA
06308:  MOVF   FEF,W
0630A:  MOVLB  2
0630C:  CLRF   x0F
0630E:  MOVWF  x0E
06310:  MOVFF  20E,20F
06314:  CLRF   x0E
06316:  MOVLW  08
06318:  MOVLB  1
0631A:  ADDWF  xBC,W
0631C:  MOVWF  FE9
0631E:  MOVLW  00
06320:  ADDWFC xBD,W
06322:  MOVWF  FEA
06324:  MOVF   FEF,W
06326:  CLRF   03
06328:  MOVLB  2
0632A:  IORWF  x0E,W
0632C:  MOVLB  1
0632E:  MOVWF  xBF
06330:  MOVF   03,W
06332:  MOVLB  2
06334:  IORWF  x0F,W
06336:  MOVLB  1
06338:  MOVWF  xC0
.................... 
....................    fprintf(PC, "\tMODE     : %02X\r\n", flash_param.id);
0633A:  MOVLW  9C
0633C:  MOVWF  FF6
0633E:  MOVLW  18
06340:  MOVWF  FF7
06342:  MOVLW  00
06344:  MOVWF  FF8
06346:  MOVLW  0C
06348:  MOVLB  3
0634A:  MOVWF  x12
0634C:  MOVLB  0
0634E:  CALL   1D62
06352:  MOVFF  1BE,A39
06356:  MOVLW  37
06358:  MOVLB  A
0635A:  MOVWF  x3A
0635C:  MOVLB  0
0635E:  CALL   1F60
06362:  MOVLW  0D
06364:  MOVLB  A
06366:  MOVWF  xDB
06368:  MOVLB  0
0636A:  CALL   1CE0
0636E:  MOVLW  0A
06370:  MOVLB  A
06372:  MOVWF  xDB
06374:  MOVLB  0
06376:  CALL   1CE0
....................    fprintf(PC, "\tAddress  : 0x%08LX\r\n", flash_param.readaddress);
0637A:  MOVLW  B0
0637C:  MOVWF  FF6
0637E:  MOVLW  18
06380:  MOVWF  FF7
06382:  MOVLW  00
06384:  MOVWF  FF8
06386:  MOVLW  0E
06388:  MOVLB  3
0638A:  MOVWF  x12
0638C:  MOVLB  0
0638E:  CALL   1D62
06392:  MOVFF  1C4,A39
06396:  MOVLW  37
06398:  MOVLB  A
0639A:  MOVWF  x3A
0639C:  MOVLB  0
0639E:  CALL   1F60
063A2:  MOVFF  1C3,A39
063A6:  MOVLW  37
063A8:  MOVLB  A
063AA:  MOVWF  x3A
063AC:  MOVLB  0
063AE:  CALL   1F60
063B2:  MOVFF  1C2,A39
063B6:  MOVLW  37
063B8:  MOVLB  A
063BA:  MOVWF  x3A
063BC:  MOVLB  0
063BE:  CALL   1F60
063C2:  MOVFF  1C1,A39
063C6:  MOVLW  37
063C8:  MOVLB  A
063CA:  MOVWF  x3A
063CC:  MOVLB  0
063CE:  CALL   1F60
063D2:  MOVLW  0D
063D4:  MOVLB  A
063D6:  MOVWF  xDB
063D8:  MOVLB  0
063DA:  CALL   1CE0
063DE:  MOVLW  0A
063E0:  MOVLB  A
063E2:  MOVWF  xDB
063E4:  MOVLB  0
063E6:  CALL   1CE0
....................    fprintf(PC, "\tPacketNum: 0x%04LX\r\n", flash_param.readpacketnum);
063EA:  MOVLW  C6
063EC:  MOVWF  FF6
063EE:  MOVLW  18
063F0:  MOVWF  FF7
063F2:  MOVLW  00
063F4:  MOVWF  FF8
063F6:  MOVLW  0E
063F8:  MOVLB  3
063FA:  MOVWF  x12
063FC:  MOVLB  0
063FE:  CALL   1D62
06402:  MOVFF  1C0,A39
06406:  MOVLW  37
06408:  MOVLB  A
0640A:  MOVWF  x3A
0640C:  MOVLB  0
0640E:  CALL   1F60
06412:  MOVFF  1BF,A39
06416:  MOVLW  37
06418:  MOVLB  A
0641A:  MOVWF  x3A
0641C:  MOVLB  0
0641E:  CALL   1F60
06422:  MOVLW  0D
06424:  MOVLB  A
06426:  MOVWF  xDB
06428:  MOVLB  0
0642A:  CALL   1CE0
0642E:  MOVLW  0A
06430:  MOVLB  A
06432:  MOVWF  xDB
06434:  MOVLB  0
06436:  CALL   1CE0
....................    
....................    piclog_make(flash_param.id, 0x00);
0643A:  MOVFF  1BE,20F
0643E:  MOVLB  2
06440:  CLRF   x10
06442:  MOVLB  0
06444:  CALL   4A82
....................    
.................... 
....................    unsigned int8 readdata[PACKET_SIZE] = {0x00}; // Initialize read data buffer
06448:  MOVLB  1
0644A:  CLRF   xC5
0644C:  CLRF   xC6
0644E:  CLRF   xC7
06450:  CLRF   xC8
06452:  CLRF   xC9
06454:  CLRF   xCA
06456:  CLRF   xCB
06458:  CLRF   xCC
0645A:  CLRF   xCD
0645C:  CLRF   xCE
0645E:  CLRF   xCF
06460:  CLRF   xD0
06462:  CLRF   xD1
06464:  CLRF   xD2
06466:  CLRF   xD3
06468:  CLRF   xD4
0646A:  CLRF   xD5
0646C:  CLRF   xD6
0646E:  CLRF   xD7
06470:  CLRF   xD8
06472:  CLRF   xD9
06474:  CLRF   xDA
06476:  CLRF   xDB
06478:  CLRF   xDC
0647A:  CLRF   xDD
0647C:  CLRF   xDE
0647E:  CLRF   xDF
06480:  CLRF   xE0
06482:  CLRF   xE1
06484:  CLRF   xE2
06486:  CLRF   xE3
06488:  CLRF   xE4
0648A:  CLRF   xE5
0648C:  CLRF   xE6
0648E:  CLRF   xE7
06490:  CLRF   xE8
06492:  CLRF   xE9
06494:  CLRF   xEA
06496:  CLRF   xEB
06498:  CLRF   xEC
0649A:  CLRF   xED
0649C:  CLRF   xEE
0649E:  CLRF   xEF
064A0:  CLRF   xF0
064A2:  CLRF   xF1
064A4:  CLRF   xF2
064A6:  CLRF   xF3
064A8:  CLRF   xF4
064AA:  CLRF   xF5
064AC:  CLRF   xF6
064AE:  CLRF   xF7
064B0:  CLRF   xF8
064B2:  CLRF   xF9
064B4:  CLRF   xFA
064B6:  CLRF   xFB
064B8:  CLRF   xFC
064BA:  CLRF   xFD
064BC:  CLRF   xFE
064BE:  CLRF   xFF
064C0:  MOVLB  2
064C2:  CLRF   x00
064C4:  CLRF   x01
064C6:  CLRF   x02
064C8:  CLRF   x03
064CA:  CLRF   x04
....................    unsigned int32 read_address;
....................    fprintf(PC, "READ DATA\r\n");
064CC:  MOVLW  DC
064CE:  MOVWF  FF6
064D0:  MOVLW  18
064D2:  MOVWF  FF7
064D4:  MOVLW  00
064D6:  MOVWF  FF8
064D8:  MOVLB  0
064DA:  CALL   1D32
.................... 
....................    if(is_connect(mis_fm) == FALSE) {
064DE:  MOVFF  111,292
064E2:  MOVFF  110,291
064E6:  MOVFF  10F,290
064EA:  MOVFF  10E,28F
064EE:  CALL   27F6
064F2:  MOVF   01,F
064F4:  BTFSS  FD8.2
064F6:  GOTO   650A
....................       fprintf(PC, "Mission Flash is not connected\r\n");
064FA:  MOVLW  E8
064FC:  MOVWF  FF6
064FE:  MOVLW  18
06500:  MOVWF  FF7
06502:  MOVLW  00
06504:  MOVWF  FF8
06506:  CALL   1D32
....................       // return;
....................    }
.................... 
....................    for (unsigned int32 packetcount = 0; packetcount < flash_param.readpacketnum; packetcount++){
0650A:  MOVLB  2
0650C:  CLRF   x0C
0650E:  CLRF   x0B
06510:  CLRF   x0A
06512:  CLRF   x09
06514:  MOVLB  0
06516:  MOVLB  2
06518:  MOVF   x0C,F
0651A:  BTFSC  FD8.2
0651C:  BRA    6524
0651E:  MOVLB  0
06520:  GOTO   6686
06524:  MOVLB  0
06526:  MOVLB  2
06528:  MOVF   x0B,F
0652A:  BTFSC  FD8.2
0652C:  BRA    6534
0652E:  MOVLB  0
06530:  GOTO   6686
06534:  MOVLB  0
06536:  MOVLB  2
06538:  MOVF   x0A,W
0653A:  MOVLB  1
0653C:  SUBWF  xC0,W
0653E:  BTFSC  FD8.0
06540:  BRA    6548
06542:  MOVLB  0
06544:  GOTO   6686
06548:  MOVLB  0
0654A:  BTFSS  FD8.2
0654C:  GOTO   6564
06550:  MOVLB  1
06552:  MOVF   xBF,W
06554:  MOVLB  2
06556:  SUBWF  x09,W
06558:  BTFSS  FD8.0
0655A:  BRA    6562
0655C:  MOVLB  0
0655E:  GOTO   6686
06562:  MOVLB  0
....................       read_address = flash_param.readaddress + packetcount * PACKET_SIZE;
06564:  MOVLB  2
06566:  RLCF   x09,W
06568:  MOVWF  00
0656A:  RLCF   x0A,W
0656C:  MOVWF  01
0656E:  RLCF   x0B,W
06570:  MOVWF  02
06572:  RLCF   x0C,W
06574:  MOVWF  03
06576:  RLCF   00,F
06578:  RLCF   01,F
0657A:  RLCF   02,F
0657C:  RLCF   03,F
0657E:  RLCF   00,F
06580:  RLCF   01,F
06582:  RLCF   02,F
06584:  RLCF   03,F
06586:  RLCF   00,F
06588:  RLCF   01,F
0658A:  RLCF   02,F
0658C:  RLCF   03,F
0658E:  RLCF   00,F
06590:  RLCF   01,F
06592:  RLCF   02,F
06594:  RLCF   03,F
06596:  RLCF   00,F
06598:  RLCF   01,F
0659A:  RLCF   02,F
0659C:  RLCF   03,F
0659E:  MOVLW  C0
065A0:  ANDWF  00,F
065A2:  MOVF   00,W
065A4:  MOVLB  1
065A6:  ADDWF  xC1,W
065A8:  MOVLB  2
065AA:  MOVWF  x05
065AC:  MOVF   01,W
065AE:  MOVLB  1
065B0:  ADDWFC xC2,W
065B2:  MOVLB  2
065B4:  MOVWF  x06
065B6:  MOVF   02,W
065B8:  MOVLB  1
065BA:  ADDWFC xC3,W
065BC:  MOVLB  2
065BE:  MOVWF  x07
065C0:  MOVF   03,W
065C2:  MOVLB  1
065C4:  ADDWFC xC4,W
065C6:  MOVLB  2
065C8:  MOVWF  x08
.................... 
....................       //fprintf(PC, "Packet %lu: Address 0x%08LX\r\n", packetcount, read_address);
....................       
....................       read_data_bytes(mis_fm, read_address, readdata, PACKET_SIZE);
065CA:  MOVFF  111,314
065CE:  MOVFF  110,313
065D2:  MOVFF  10F,312
065D6:  MOVFF  10E,311
065DA:  MOVFF  208,318
065DE:  MOVFF  207,317
065E2:  MOVFF  206,316
065E6:  MOVFF  205,315
065EA:  MOVLW  01
065EC:  MOVLB  3
065EE:  MOVWF  x1A
065F0:  MOVLW  C5
065F2:  MOVWF  x19
065F4:  CLRF   x1E
065F6:  CLRF   x1D
065F8:  CLRF   x1C
065FA:  MOVLW  40
065FC:  MOVWF  x1B
065FE:  MOVLB  0
06600:  CALL   28E2
....................       for (unsigned int8 bytecount = 0; bytecount < PACKET_SIZE; bytecount++){
06604:  MOVLB  2
06606:  CLRF   x0D
06608:  MOVLB  0
0660A:  MOVLB  2
0660C:  MOVF   x0D,W
0660E:  SUBLW  3F
06610:  BTFSC  FD8.0
06612:  BRA    661A
06614:  MOVLB  0
06616:  GOTO   6656
0661A:  MOVLB  0
....................          fprintf(PC,"%02X ",readdata[bytecount]);
0661C:  CLRF   03
0661E:  MOVLB  2
06620:  MOVF   x0D,W
06622:  ADDLW  C5
06624:  MOVWF  FE9
06626:  MOVLW  01
06628:  ADDWFC 03,W
0662A:  MOVWF  FEA
0662C:  MOVFF  FEF,20E
06630:  MOVFF  20E,A39
06634:  MOVLW  37
06636:  MOVLB  A
06638:  MOVWF  x3A
0663A:  MOVLB  0
0663C:  CALL   1F60
06640:  MOVLW  20
06642:  MOVLB  A
06644:  MOVWF  xDB
06646:  MOVLB  0
06648:  CALL   1CE0
0664C:  MOVLB  2
0664E:  INCF   x0D,F
06650:  MOVLB  0
06652:  GOTO   660A
....................       }
....................       fprintf(PC,"\r\n");
06656:  MOVLW  0D
06658:  MOVLB  A
0665A:  MOVWF  xDB
0665C:  MOVLB  0
0665E:  CALL   1CE0
06662:  MOVLW  0A
06664:  MOVLB  A
06666:  MOVWF  xDB
06668:  MOVLB  0
0666A:  CALL   1CE0
0666E:  MOVLW  01
06670:  MOVLB  2
06672:  ADDWF  x09,F
06674:  BTFSC  FD8.0
06676:  INCF   x0A,F
06678:  BTFSC  FD8.2
0667A:  INCF   x0B,F
0667C:  BTFSC  FD8.2
0667E:  INCF   x0C,F
06680:  MOVLB  0
06682:  GOTO   6516
....................    }
....................    piclog_make(flash_param.id, PICLOG_PARAM_END); // Log the end of the command execution
06686:  MOVFF  1BE,20F
0668A:  MOVLB  2
0668C:  SETF   x10
0668E:  MOVLB  0
06690:  CALL   4A82
....................    fprintf(PC, "End Flash Read\r\n");
06694:  MOVLW  0A
06696:  MOVWF  FF6
06698:  MOVLW  19
0669A:  MOVWF  FF7
0669C:  MOVLW  00
0669E:  MOVWF  FF8
066A0:  CALL   1D32
066A4:  GOTO   9F3A (RETURN)
.................... }
.................... 
.................... 
.................... void mode_misf_read_address(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Read Address\r\n");
066A8:  MOVLW  1C
066AA:  MOVWF  FF6
066AC:  MOVLW  19
066AE:  MOVWF  FF7
066B0:  MOVLW  00
066B2:  MOVWF  FF8
066B4:  CALL   1D32
....................    flash_setting(mis_fm);
066B8:  MOVFF  111,2CA
066BC:  MOVFF  110,2C9
066C0:  MOVFF  10F,2C8
066C4:  MOVFF  10E,2C7
066C8:  CALL   613C
....................    unsigned int32 read_address = 0x00000000;
....................    int8 read_data[4];
066CC:  MOVLB  1
066CE:  CLRF   xC1
066D0:  CLRF   xC0
066D2:  CLRF   xBF
066D4:  CLRF   xBE
....................    read_data_bytes(mis_fm, read_address, read_data, 4);
066D6:  MOVFF  111,314
066DA:  MOVFF  110,313
066DE:  MOVFF  10F,312
066E2:  MOVFF  10E,311
066E6:  MOVFF  1C1,318
066EA:  MOVFF  1C0,317
066EE:  MOVFF  1BF,316
066F2:  MOVFF  1BE,315
066F6:  MOVLW  01
066F8:  MOVLB  3
066FA:  MOVWF  x1A
066FC:  MOVLW  C2
066FE:  MOVWF  x19
06700:  CLRF   x1E
06702:  CLRF   x1D
06704:  CLRF   x1C
06706:  MOVLW  04
06708:  MOVWF  x1B
0670A:  MOVLB  0
0670C:  CALL   28E2
....................    fprintf(PC, "Read Data: %02X %02X %02X %02X\r\n", read_data[0], read_data[1], read_data[2], read_data[3]);
06710:  MOVLW  38
06712:  MOVWF  FF6
06714:  MOVLW  19
06716:  MOVWF  FF7
06718:  MOVLW  00
0671A:  MOVWF  FF8
0671C:  MOVLW  0B
0671E:  MOVLB  3
06720:  MOVWF  x12
06722:  MOVLB  0
06724:  CALL   1D62
06728:  MOVFF  1C2,A39
0672C:  MOVLW  37
0672E:  MOVLB  A
06730:  MOVWF  x3A
06732:  MOVLB  0
06734:  CALL   1F60
06738:  MOVLW  20
0673A:  MOVLB  A
0673C:  MOVWF  xDB
0673E:  MOVLB  0
06740:  CALL   1CE0
06744:  MOVFF  1C3,A39
06748:  MOVLW  37
0674A:  MOVLB  A
0674C:  MOVWF  x3A
0674E:  MOVLB  0
06750:  CALL   1F60
06754:  MOVLW  20
06756:  MOVLB  A
06758:  MOVWF  xDB
0675A:  MOVLB  0
0675C:  CALL   1CE0
06760:  MOVFF  1C4,A39
06764:  MOVLW  37
06766:  MOVLB  A
06768:  MOVWF  x3A
0676A:  MOVLB  0
0676C:  CALL   1F60
06770:  MOVLW  20
06772:  MOVLB  A
06774:  MOVWF  xDB
06776:  MOVLB  0
06778:  CALL   1CE0
0677C:  MOVFF  1C5,A39
06780:  MOVLW  37
06782:  MOVLB  A
06784:  MOVWF  x3A
06786:  MOVLB  0
06788:  CALL   1F60
0678C:  MOVLW  0D
0678E:  MOVLB  A
06790:  MOVWF  xDB
06792:  MOVLB  0
06794:  CALL   1CE0
06798:  MOVLW  0A
0679A:  MOVLB  A
0679C:  MOVWF  xDB
0679E:  MOVLB  0
067A0:  CALL   1CE0
....................    fprintf(PC, "End Flash Read Address\r\n");
067A4:  MOVLW  5A
067A6:  MOVWF  FF6
067A8:  MOVLW  19
067AA:  MOVWF  FF7
067AC:  MOVLW  00
067AE:  MOVWF  FF8
067B0:  CALL   1D32
067B4:  GOTO   9F4A (RETURN)
.................... }
.................... 
.................... void mode_misf_erase_and_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Erase and Reset\r\n");
*
069A4:  MOVLW  74
069A6:  MOVWF  FF6
069A8:  MOVLW  19
069AA:  MOVWF  FF7
069AC:  MOVLW  00
069AE:  MOVWF  FF8
069B0:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
069B4:  MOVLB  1
069B6:  MOVF   xBC,W
069B8:  MOVWF  FE9
069BA:  MOVF   xBD,W
069BC:  MOVWF  FEA
069BE:  MOVFF  FEF,1BE
069C2:  MOVFF  1BE,20F
069C6:  MOVLB  2
069C8:  CLRF   x10
069CA:  MOVLB  0
069CC:  CALL   4A82
.................... 
....................    mode_misf_erase_all(parameter); // Erase all flash memory
069D0:  MOVFF  1BD,1BF
069D4:  MOVFF  1BC,1BE
069D8:  CALL   5460
....................    mode_misf_address_reset(parameter); // Reset the address area
069DC:  MOVFF  1BD,1BF
069E0:  MOVFF  1BC,1BE
069E4:  GOTO   67B8
.................... 
....................    fprintf(PC, "End Flash Erase and Reset\r\n");
069E8:  MOVLW  92
069EA:  MOVWF  FF6
069EC:  MOVLW  19
069EE:  MOVWF  FF7
069F0:  MOVLW  00
069F2:  MOVWF  FF8
069F4:  CALL   1D32
069F8:  GOTO   9F5A (RETURN)
.................... }
.................... // ========================== SMF Command ============================
.................... void mode_smf_copy(int8 parameter[])
.................... {
....................    printf("Start Flash SMF Copy\r\n");
069FC:  MOVLW  AE
069FE:  MOVWF  FF6
06A00:  MOVLW  19
06A02:  MOVWF  FF7
06A04:  MOVLW  00
06A06:  MOVWF  FF8
06A08:  CALL   1D32
....................    flash_setting(mis_fm);
06A0C:  MOVFF  111,2CA
06A10:  MOVFF  110,2C9
06A14:  MOVFF  10F,2C8
06A18:  MOVFF  10E,2C7
06A1C:  CALL   613C
....................    flash_setting(smf);
06A20:  MOVFF  115,2CA
06A24:  MOVFF  114,2C9
06A28:  MOVFF  113,2C8
06A2C:  MOVFF  112,2C7
06A30:  CALL   613C
....................    
....................    // 統合管理システムを使用したコピー操作
....................    int8 mission_id = parameter[0];
....................    
....................    // 未コピーデータの自動転送をキューに追加
....................    //enqueue_auto_transfer(mission_id);
....................    
....................    // Example copy operation with integration system
....................    int32 src_address = 0x00000000;
....................    int32 dest_address = 0x00001000; // Example destination address
....................    int8 read_data[256];
06A34:  MOVLB  1
06A36:  MOVF   xBC,W
06A38:  MOVWF  FE9
06A3A:  MOVF   xBD,W
06A3C:  MOVWF  FEA
06A3E:  MOVFF  FEF,1BE
06A42:  CLRF   xC2
06A44:  CLRF   xC1
06A46:  CLRF   xC0
06A48:  CLRF   xBF
06A4A:  CLRF   xC6
06A4C:  CLRF   xC5
06A4E:  MOVLW  10
06A50:  MOVWF  xC4
06A52:  CLRF   xC3
....................    read_data_bytes(mis_fm, src_address, read_data, 256);
06A54:  MOVFF  111,314
06A58:  MOVFF  110,313
06A5C:  MOVFF  10F,312
06A60:  MOVFF  10E,311
06A64:  MOVFF  1C2,318
06A68:  MOVFF  1C1,317
06A6C:  MOVFF  1C0,316
06A70:  MOVFF  1BF,315
06A74:  MOVLW  01
06A76:  MOVLB  3
06A78:  MOVWF  x1A
06A7A:  MOVLW  C7
06A7C:  MOVWF  x19
06A7E:  CLRF   x1E
06A80:  CLRF   x1D
06A82:  MOVLW  01
06A84:  MOVWF  x1C
06A86:  CLRF   x1B
06A88:  MOVLB  0
06A8A:  CALL   28E2
....................    write_data_bytes(smf, dest_address, read_data, 256);
06A8E:  MOVFF  115,A7F
06A92:  MOVFF  114,A7E
06A96:  MOVFF  113,A7D
06A9A:  MOVFF  112,A7C
06A9E:  MOVFF  1C6,A83
06AA2:  MOVFF  1C5,A82
06AA6:  MOVFF  1C4,A81
06AAA:  MOVFF  1C3,A80
06AAE:  MOVLW  01
06AB0:  MOVLB  A
06AB2:  MOVWF  x85
06AB4:  MOVLW  C7
06AB6:  MOVWF  x84
06AB8:  MOVLW  01
06ABA:  MOVWF  x87
06ABC:  CLRF   x86
06ABE:  MOVLB  0
06AC0:  CALL   3F84
....................    
....................    // 転送完了後のカウンタ更新
....................    //complete_transfer_and_update_counter(mission_id, 256);
....................    
....................    printf("End Flash SMF Copy\r\n");
06AC4:  MOVLW  C6
06AC6:  MOVWF  FF6
06AC8:  MOVLW  19
06ACA:  MOVWF  FF7
06ACC:  MOVLW  00
06ACE:  MOVWF  FF8
06AD0:  CALL   1D32
06AD4:  GOTO   9F6A (RETURN)
.................... }
.................... 
.................... 
.................... void mode_smf_read(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Read\r\n");
06AD8:  MOVLW  DC
06ADA:  MOVWF  FF6
06ADC:  MOVLW  19
06ADE:  MOVWF  FF7
06AE0:  MOVLW  00
06AE2:  MOVWF  FF8
06AE4:  CALL   1D32
....................    int8 read_data[PACKET_SIZE];
....................    read_data_bytes(smf, read_data, read_data, PACKET_SIZE);
06AE8:  MOVFF  115,314
06AEC:  MOVFF  114,313
06AF0:  MOVFF  113,312
06AF4:  MOVFF  112,311
06AF8:  MOVLB  3
06AFA:  CLRF   x18
06AFC:  CLRF   x17
06AFE:  MOVLW  01
06B00:  MOVWF  x16
06B02:  MOVLW  BE
06B04:  MOVWF  x15
06B06:  MOVLW  01
06B08:  MOVWF  x1A
06B0A:  MOVLW  BE
06B0C:  MOVWF  x19
06B0E:  CLRF   x1E
06B10:  CLRF   x1D
06B12:  CLRF   x1C
06B14:  MOVLW  40
06B16:  MOVWF  x1B
06B18:  MOVLB  0
06B1A:  CALL   28E2
....................    fprintf(PC, "Read Data: ");
06B1E:  MOVLW  F4
06B20:  MOVWF  FF6
06B22:  MOVLW  19
06B24:  MOVWF  FF7
06B26:  MOVLW  00
06B28:  MOVWF  FF8
06B2A:  CALL   1D32
....................    for (int i = 0; i < PACKET_SIZE; i++)
06B2E:  MOVLB  1
06B30:  CLRF   xFE
06B32:  MOVLB  0
06B34:  MOVLB  1
06B36:  MOVF   xFE,W
06B38:  SUBLW  3F
06B3A:  BTFSC  FD8.0
06B3C:  BRA    6B44
06B3E:  MOVLB  0
06B40:  GOTO   6B80
06B44:  MOVLB  0
....................    {
....................       fprintf(PC, "%02X ", read_data[i]);
06B46:  CLRF   03
06B48:  MOVLB  1
06B4A:  MOVF   xFE,W
06B4C:  ADDLW  BE
06B4E:  MOVWF  FE9
06B50:  MOVLW  01
06B52:  ADDWFC 03,W
06B54:  MOVWF  FEA
06B56:  MOVFF  FEF,1FF
06B5A:  MOVFF  1FF,A39
06B5E:  MOVLW  37
06B60:  MOVLB  A
06B62:  MOVWF  x3A
06B64:  MOVLB  0
06B66:  CALL   1F60
06B6A:  MOVLW  20
06B6C:  MOVLB  A
06B6E:  MOVWF  xDB
06B70:  MOVLB  0
06B72:  CALL   1CE0
06B76:  MOVLB  1
06B78:  INCF   xFE,F
06B7A:  MOVLB  0
06B7C:  GOTO   6B34
....................    }
....................    fprintf(PC, "\r\nEnd Flash SMF Read\r\n");
06B80:  MOVLW  00
06B82:  MOVWF  FF6
06B84:  MOVLW  1A
06B86:  MOVWF  FF7
06B88:  MOVLW  00
06B8A:  MOVWF  FF8
06B8C:  CALL   1D32
06B90:  GOTO   9F7A (RETURN)
.................... }
.................... 
.................... void mode_smf_erase(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash SMF Erase\r\n");
06B94:  MOVLW  18
06B96:  MOVWF  FF6
06B98:  MOVLW  1A
06B9A:  MOVWF  FF7
06B9C:  MOVLW  00
06B9E:  MOVWF  FF8
06BA0:  CALL   1D32
....................    flash_setting(smf);
06BA4:  MOVFF  115,2CA
06BA8:  MOVFF  114,2C9
06BAC:  MOVFF  113,2C8
06BB0:  MOVFF  112,2C7
06BB4:  CALL   613C
....................    unsigned int32 erase_address = 0x00000000; // Example address
06BB8:  MOVLB  1
06BBA:  CLRF   xC1
06BBC:  CLRF   xC0
06BBE:  CLRF   xBF
06BC0:  CLRF   xBE
....................    sector_erase(smf, erase_address); // Erase the sector
06BC2:  MOVFF  115,A7D
06BC6:  MOVFF  114,A7C
06BCA:  MOVFF  113,A7B
06BCE:  MOVFF  112,A7A
06BD2:  MOVFF  1C1,A81
06BD6:  MOVFF  1C0,A80
06BDA:  MOVFF  1BF,A7F
06BDE:  MOVFF  1BE,A7E
06BE2:  MOVLB  0
06BE4:  CALL   469C
....................    fprintf(PC, "End Flash SMF Erase\r\n");
06BE8:  MOVLW  30
06BEA:  MOVWF  FF6
06BEC:  MOVLW  1A
06BEE:  MOVWF  FF7
06BF0:  MOVLW  00
06BF2:  MOVWF  FF8
06BF4:  CALL   1D32
06BF8:  GOTO   9F8A (RETURN)
.................... }  
.................... 
.................... void mode_misf_address_reset(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start Flash Address Reset\r\n");
*
067B8:  MOVLW  46
067BA:  MOVWF  FF6
067BC:  MOVLW  1A
067BE:  MOVWF  FF7
067C0:  MOVLW  00
067C2:  MOVWF  FF8
067C4:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_START); 
067C8:  MOVLB  1
067CA:  MOVF   xBE,W
067CC:  MOVWF  FE9
067CE:  MOVF   xBF,W
067D0:  MOVWF  FEA
067D2:  MOVFF  FEF,202
067D6:  MOVFF  202,20F
067DA:  MOVLB  2
067DC:  CLRF   x10
067DE:  MOVLB  0
067E0:  CALL   4A82
....................    FlashData_t flash_data;
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
067E4:  MOVLW  01
067E6:  MOVWF  FEA
067E8:  MOVLW  C0
067EA:  MOVWF  FE9
067EC:  CLRF   00
067EE:  CLRF   02
067F0:  MOVLW  40
067F2:  MOVWF  01
067F4:  CALL   28BE
....................    /*
....................    for (int i = 0; i < PACKET_SIZE; i++) {
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
....................    }
....................    */
....................    fprintf(PC, "\r\n");
067F8:  MOVLW  0D
067FA:  MOVLB  A
067FC:  MOVWF  xDB
067FE:  MOVLB  0
06800:  CALL   1CE0
06804:  MOVLW  0A
06806:  MOVLB  A
06808:  MOVWF  xDB
0680A:  MOVLB  0
0680C:  CALL   1CE0
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
06810:  MOVLW  01
06812:  MOVLB  A
06814:  MOVWF  xDC
06816:  MOVLW  C0
06818:  MOVWF  xDB
0681A:  MOVLW  3F
0681C:  MOVWF  xDD
0681E:  MOVLB  0
06820:  CALL   2AFA
06824:  MOVFF  01,1FF
....................    for (int i = 0; i < PACKET_SIZE; i++) {
06828:  MOVLB  2
0682A:  CLRF   x00
0682C:  MOVLB  0
0682E:  MOVLB  2
06830:  MOVF   x00,W
06832:  SUBLW  3F
06834:  BTFSC  FD8.0
06836:  BRA    683E
06838:  MOVLB  0
0683A:  GOTO   687A
0683E:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
06840:  CLRF   03
06842:  MOVLB  2
06844:  MOVF   x00,W
06846:  ADDLW  C0
06848:  MOVWF  FE9
0684A:  MOVLW  01
0684C:  ADDWFC 03,W
0684E:  MOVWF  FEA
06850:  MOVFF  FEF,202
06854:  MOVFF  202,A39
06858:  MOVLW  37
0685A:  MOVLB  A
0685C:  MOVWF  x3A
0685E:  MOVLB  0
06860:  CALL   1F60
06864:  MOVLW  20
06866:  MOVLB  A
06868:  MOVWF  xDB
0686A:  MOVLB  0
0686C:  CALL   1CE0
06870:  MOVLB  2
06872:  INCF   x00,F
06874:  MOVLB  0
06876:  GOTO   682E
....................    }
....................    fprintf(PC, "\r\n");
0687A:  MOVLW  0D
0687C:  MOVLB  A
0687E:  MOVWF  xDB
06880:  MOVLB  0
06882:  CALL   1CE0
06886:  MOVLW  0A
06888:  MOVLB  A
0688A:  MOVWF  xDB
0688C:  MOVLB  0
0688E:  CALL   1CE0
....................    write_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
06892:  MOVFF  111,A7F
06896:  MOVFF  110,A7E
0689A:  MOVFF  10F,A7D
0689E:  MOVFF  10E,A7C
068A2:  MOVLB  A
068A4:  CLRF   x83
068A6:  CLRF   x82
068A8:  CLRF   x81
068AA:  CLRF   x80
068AC:  MOVLW  01
068AE:  MOVWF  x85
068B0:  MOVLW  C0
068B2:  MOVWF  x84
068B4:  CLRF   x87
068B6:  MOVLW  40
068B8:  MOVWF  x86
068BA:  MOVLB  0
068BC:  CALL   3F84
....................    memset(flash_data.bytes, 0, PACKET_SIZE);
068C0:  MOVLW  01
068C2:  MOVWF  FEA
068C4:  MOVLW  C0
068C6:  MOVWF  FE9
068C8:  CLRF   00
068CA:  CLRF   02
068CC:  MOVLW  40
068CE:  MOVWF  01
068D0:  CALL   28BE
....................    read_data_bytes(mis_fm, MISF_CIGS_DATA_TABLE_START, flash_data.bytes, PACKET_SIZE);
068D4:  MOVFF  111,314
068D8:  MOVFF  110,313
068DC:  MOVFF  10F,312
068E0:  MOVFF  10E,311
068E4:  MOVLB  3
068E6:  CLRF   x18
068E8:  CLRF   x17
068EA:  CLRF   x16
068EC:  CLRF   x15
068EE:  MOVLW  01
068F0:  MOVWF  x1A
068F2:  MOVLW  C0
068F4:  MOVWF  x19
068F6:  CLRF   x1E
068F8:  CLRF   x1D
068FA:  CLRF   x1C
068FC:  MOVLW  40
068FE:  MOVWF  x1B
06900:  MOVLB  0
06902:  CALL   28E2
....................    flash_data.packet.crc = calc_crc8(flash_data.bytes, PACKET_SIZE-1);
06906:  MOVLW  01
06908:  MOVLB  A
0690A:  MOVWF  xDC
0690C:  MOVLW  C0
0690E:  MOVWF  xDB
06910:  MOVLW  3F
06912:  MOVWF  xDD
06914:  MOVLB  0
06916:  CALL   2AFA
0691A:  MOVFF  01,1FF
....................    for (int i = 0; i < PACKET_SIZE; i++) {
0691E:  MOVLB  2
06920:  CLRF   x01
06922:  MOVLB  0
06924:  MOVLB  2
06926:  MOVF   x01,W
06928:  SUBLW  3F
0692A:  BTFSC  FD8.0
0692C:  BRA    6934
0692E:  MOVLB  0
06930:  GOTO   6970
06934:  MOVLB  0
....................       fprintf(PC, "%02X ", flash_data.bytes[i]);
06936:  CLRF   03
06938:  MOVLB  2
0693A:  MOVF   x01,W
0693C:  ADDLW  C0
0693E:  MOVWF  FE9
06940:  MOVLW  01
06942:  ADDWFC 03,W
06944:  MOVWF  FEA
06946:  MOVFF  FEF,202
0694A:  MOVFF  202,A39
0694E:  MOVLW  37
06950:  MOVLB  A
06952:  MOVWF  x3A
06954:  MOVLB  0
06956:  CALL   1F60
0695A:  MOVLW  20
0695C:  MOVLB  A
0695E:  MOVWF  xDB
06960:  MOVLB  0
06962:  CALL   1CE0
06966:  MOVLB  2
06968:  INCF   x01,F
0696A:  MOVLB  0
0696C:  GOTO   6924
....................    }
....................    misf_init(); // Update the address area after writing
06970:  CALL   33BA
.................... 
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06974:  MOVLB  1
06976:  MOVF   xBE,W
06978:  MOVWF  FE9
0697A:  MOVF   xBF,W
0697C:  MOVWF  FEA
0697E:  MOVFF  FEF,202
06982:  MOVFF  202,20F
06986:  MOVLB  2
06988:  SETF   x10
0698A:  MOVLB  0
0698C:  CALL   4A82
....................    fprintf(PC, "End Flash Address Reset\r\n");
06990:  MOVLW  62
06992:  MOVWF  FF6
06994:  MOVLW  1A
06996:  MOVWF  FF7
06998:  MOVLW  00
0699A:  MOVWF  FF8
0699C:  CALL   1D32
069A0:  GOTO   69E8 (RETURN)
.................... }
.................... 
.................... 
.................... // ---------- SMF Command Functions ----------
.................... void mode_smf_read_force(int8 parameter[])
*
06E48:  MOVLW  01
06E4A:  MOVLB  1
06E4C:  ADDWF  xBC,W
06E4E:  MOVWF  FE9
06E50:  MOVLW  00
06E52:  ADDWFC xBD,W
06E54:  MOVWF  FEA
06E56:  MOVF   FEF,W
06E58:  MOVLB  2
06E5A:  CLRF   x0E
06E5C:  CLRF   x0D
06E5E:  CLRF   x0C
06E60:  MOVWF  x0B
06E62:  MOVFF  20B,20E
06E66:  CLRF   x0B
06E68:  CLRF   x0C
06E6A:  CLRF   x0D
06E6C:  MOVLW  02
06E6E:  MOVLB  1
06E70:  ADDWF  xBC,W
06E72:  MOVWF  FE9
06E74:  MOVLW  00
06E76:  ADDWFC xBD,W
06E78:  MOVWF  FEA
06E7A:  MOVF   FEF,W
06E7C:  MOVLB  2
06E7E:  CLRF   x13
06E80:  CLRF   x12
06E82:  CLRF   x11
06E84:  MOVWF  x10
06E86:  MOVFF  211,03
06E8A:  MOVFF  210,02
06E8E:  CLRF   00
06E90:  CLRF   01
06E92:  MOVF   00,W
06E94:  IORWF  x0B,F
06E96:  MOVF   01,W
06E98:  IORWF  x0C,F
06E9A:  MOVF   02,W
06E9C:  IORWF  x0D,F
06E9E:  MOVF   03,W
06EA0:  IORWF  x0E,F
06EA2:  MOVLW  03
06EA4:  MOVLB  1
06EA6:  ADDWF  xBC,W
06EA8:  MOVWF  FE9
06EAA:  MOVLW  00
06EAC:  ADDWFC xBD,W
06EAE:  MOVWF  FEA
06EB0:  MOVF   FEF,W
06EB2:  MOVLB  2
06EB4:  CLRF   x13
06EB6:  CLRF   x12
06EB8:  CLRF   x11
06EBA:  MOVWF  x10
06EBC:  MOVFF  212,03
06EC0:  MOVFF  211,02
06EC4:  MOVFF  210,01
06EC8:  CLRF   00
06ECA:  MOVF   00,W
06ECC:  IORWF  x0B,F
06ECE:  MOVF   01,W
06ED0:  IORWF  x0C,F
06ED2:  MOVF   02,W
06ED4:  IORWF  x0D,F
06ED6:  MOVF   03,W
06ED8:  IORWF  x0E,F
06EDA:  MOVLW  04
06EDC:  MOVLB  1
06EDE:  ADDWF  xBC,W
06EE0:  MOVWF  FE9
06EE2:  MOVLW  00
06EE4:  ADDWFC xBD,W
06EE6:  MOVWF  FEA
06EE8:  MOVF   FEF,W
06EEA:  MOVWF  00
06EEC:  CLRF   01
06EEE:  CLRF   02
06EF0:  CLRF   03
06EF2:  MOVF   00,W
06EF4:  MOVLB  2
06EF6:  IORWF  x0B,W
06EF8:  MOVLB  1
06EFA:  MOVWF  xBE
06EFC:  MOVF   01,W
06EFE:  MOVLB  2
06F00:  IORWF  x0C,W
06F02:  MOVLB  1
06F04:  MOVWF  xBF
06F06:  MOVF   02,W
06F08:  MOVLB  2
06F0A:  IORWF  x0D,W
06F0C:  MOVLB  1
06F0E:  MOVWF  xC0
06F10:  MOVF   03,W
06F12:  MOVLB  2
06F14:  IORWF  x0E,W
06F16:  MOVLB  1
06F18:  MOVWF  xC1
06F1A:  MOVLW  07
06F1C:  ADDWF  xBC,W
06F1E:  MOVWF  FE9
06F20:  MOVLW  00
06F22:  ADDWFC xBD,W
06F24:  MOVWF  FEA
06F26:  MOVF   FEF,W
06F28:  MOVLB  2
06F2A:  CLRF   x0C
06F2C:  MOVWF  x0B
06F2E:  MOVFF  20B,20C
06F32:  CLRF   x0B
06F34:  MOVLW  08
06F36:  MOVLB  1
06F38:  ADDWF  xBC,W
06F3A:  MOVWF  FE9
06F3C:  MOVLW  00
06F3E:  ADDWFC xBD,W
06F40:  MOVWF  FEA
06F42:  MOVF   FEF,W
06F44:  CLRF   03
06F46:  MOVLB  2
06F48:  IORWF  x0B,W
06F4A:  MOVLB  1
06F4C:  MOVWF  xC2
06F4E:  MOVF   03,W
06F50:  MOVLB  2
06F52:  IORWF  x0C,W
06F54:  MOVLB  1
06F56:  MOVWF  xC3
.................... {
....................    int32 address = 
....................       ((int32)parameter[1] << 24) |
....................       ((int32)parameter[2] << 16) |
....................       ((int32)parameter[3] << 8)  |
....................       ((int32)parameter[4]);
....................    
....................    int16 packet_num = 
....................       ((int16)parameter[7] << 8) |
....................       ((int16)parameter[8]);
....................       
....................    int8 read_data[PACKET_SIZE] = {0x00}; // Initialize read data buffer
06F58:  CLRF   xC4
06F5A:  CLRF   xC5
06F5C:  CLRF   xC6
06F5E:  CLRF   xC7
06F60:  CLRF   xC8
06F62:  CLRF   xC9
06F64:  CLRF   xCA
06F66:  CLRF   xCB
06F68:  CLRF   xCC
06F6A:  CLRF   xCD
06F6C:  CLRF   xCE
06F6E:  CLRF   xCF
06F70:  CLRF   xD0
06F72:  CLRF   xD1
06F74:  CLRF   xD2
06F76:  CLRF   xD3
06F78:  CLRF   xD4
06F7A:  CLRF   xD5
06F7C:  CLRF   xD6
06F7E:  CLRF   xD7
06F80:  CLRF   xD8
06F82:  CLRF   xD9
06F84:  CLRF   xDA
06F86:  CLRF   xDB
06F88:  CLRF   xDC
06F8A:  CLRF   xDD
06F8C:  CLRF   xDE
06F8E:  CLRF   xDF
06F90:  CLRF   xE0
06F92:  CLRF   xE1
06F94:  CLRF   xE2
06F96:  CLRF   xE3
06F98:  CLRF   xE4
06F9A:  CLRF   xE5
06F9C:  CLRF   xE6
06F9E:  CLRF   xE7
06FA0:  CLRF   xE8
06FA2:  CLRF   xE9
06FA4:  CLRF   xEA
06FA6:  CLRF   xEB
06FA8:  CLRF   xEC
06FAA:  CLRF   xED
06FAC:  CLRF   xEE
06FAE:  CLRF   xEF
06FB0:  CLRF   xF0
06FB2:  CLRF   xF1
06FB4:  CLRF   xF2
06FB6:  CLRF   xF3
06FB8:  CLRF   xF4
06FBA:  CLRF   xF5
06FBC:  CLRF   xF6
06FBE:  CLRF   xF7
06FC0:  CLRF   xF8
06FC2:  CLRF   xF9
06FC4:  CLRF   xFA
06FC6:  CLRF   xFB
06FC8:  CLRF   xFC
06FCA:  CLRF   xFD
06FCC:  CLRF   xFE
06FCE:  CLRF   xFF
06FD0:  MOVLB  2
06FD2:  CLRF   x00
06FD4:  CLRF   x01
06FD6:  CLRF   x02
06FD8:  CLRF   x03
....................    if(!is_connect(smf)) {
06FDA:  MOVFF  115,292
06FDE:  MOVFF  114,291
06FE2:  MOVFF  113,290
06FE6:  MOVFF  112,28F
06FEA:  MOVLB  0
06FEC:  CALL   27F6
06FF0:  MOVF   01,F
06FF2:  BTFSS  FD8.2
06FF4:  GOTO   700C
....................       printf("SMF is not connected\r\n");
06FF8:  MOVLW  7C
06FFA:  MOVWF  FF6
06FFC:  MOVLW  1A
06FFE:  MOVWF  FF7
07000:  MOVLW  00
07002:  MOVWF  FF8
07004:  CALL   1D32
....................       return;
07008:  GOTO   7268
....................    }
....................    printf("Start Flash SMF Read Force\r\n");
0700C:  MOVLW  94
0700E:  MOVWF  FF6
07010:  MOVLW  1A
07012:  MOVWF  FF7
07014:  MOVLW  00
07016:  MOVWF  FF8
07018:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_START); // Log the command execution
0701C:  MOVLB  1
0701E:  MOVF   xBC,W
07020:  MOVWF  FE9
07022:  MOVF   xBD,W
07024:  MOVWF  FEA
07026:  MOVFF  FEF,20B
0702A:  MOVFF  20B,20F
0702E:  MOVLB  2
07030:  CLRF   x10
07032:  MOVLB  0
07034:  CALL   4A82
.................... 
....................    // 統合管理システムからキューに追加
....................    // enqueue_read_data(address, packet_num * PACKET_SIZE);
.................... 
....................    printf("\tAddress  : 0x%08LX\r\n", address);
07038:  MOVLW  B2
0703A:  MOVWF  FF6
0703C:  MOVLW  1A
0703E:  MOVWF  FF7
07040:  MOVLW  00
07042:  MOVWF  FF8
07044:  MOVLW  0E
07046:  MOVLB  3
07048:  MOVWF  x12
0704A:  MOVLB  0
0704C:  CALL   1D62
07050:  MOVFF  1C1,A39
07054:  MOVLW  37
07056:  MOVLB  A
07058:  MOVWF  x3A
0705A:  MOVLB  0
0705C:  CALL   1F60
07060:  MOVFF  1C0,A39
07064:  MOVLW  37
07066:  MOVLB  A
07068:  MOVWF  x3A
0706A:  MOVLB  0
0706C:  CALL   1F60
07070:  MOVFF  1BF,A39
07074:  MOVLW  37
07076:  MOVLB  A
07078:  MOVWF  x3A
0707A:  MOVLB  0
0707C:  CALL   1F60
07080:  MOVFF  1BE,A39
07084:  MOVLW  37
07086:  MOVLB  A
07088:  MOVWF  x3A
0708A:  MOVLB  0
0708C:  CALL   1F60
07090:  MOVLW  0D
07092:  MOVLB  A
07094:  MOVWF  xDB
07096:  MOVLB  0
07098:  CALL   1CE0
0709C:  MOVLW  0A
0709E:  MOVLB  A
070A0:  MOVWF  xDB
070A2:  MOVLB  0
070A4:  CALL   1CE0
....................    printf("\tPacketNum: 0x%04LX\r\n", packet_num);
070A8:  MOVLW  C8
070AA:  MOVWF  FF6
070AC:  MOVLW  1A
070AE:  MOVWF  FF7
070B0:  MOVLW  00
070B2:  MOVWF  FF8
070B4:  MOVLW  0E
070B6:  MOVLB  3
070B8:  MOVWF  x12
070BA:  MOVLB  0
070BC:  CALL   1D62
070C0:  MOVFF  1C3,A39
070C4:  MOVLW  37
070C6:  MOVLB  A
070C8:  MOVWF  x3A
070CA:  MOVLB  0
070CC:  CALL   1F60
070D0:  MOVFF  1C2,A39
070D4:  MOVLW  37
070D6:  MOVLB  A
070D8:  MOVWF  x3A
070DA:  MOVLB  0
070DC:  CALL   1F60
070E0:  MOVLW  0D
070E2:  MOVLB  A
070E4:  MOVWF  xDB
070E6:  MOVLB  0
070E8:  CALL   1CE0
070EC:  MOVLW  0A
070EE:  MOVLB  A
070F0:  MOVWF  xDB
070F2:  MOVLB  0
070F4:  CALL   1CE0
....................    printf("read data\r\n");
070F8:  MOVLW  DE
070FA:  MOVWF  FF6
070FC:  MOVLW  1A
070FE:  MOVWF  FF7
07100:  MOVLW  00
07102:  MOVWF  FF8
07104:  CALL   1D32
....................    for (int16 packet_count = 0; packet_count < packet_num; packet_count++)
07108:  MOVLB  2
0710A:  CLRF   x05
0710C:  CLRF   x04
0710E:  MOVLB  0
07110:  MOVLB  2
07112:  MOVF   x05,W
07114:  MOVLB  1
07116:  SUBWF  xC3,W
07118:  BTFSC  FD8.0
0711A:  BRA    7122
0711C:  MOVLB  0
0711E:  GOTO   723C
07122:  MOVLB  0
07124:  BTFSS  FD8.2
07126:  GOTO   713E
0712A:  MOVLB  1
0712C:  MOVF   xC2,W
0712E:  MOVLB  2
07130:  SUBWF  x04,W
07132:  BTFSS  FD8.0
07134:  BRA    713C
07136:  MOVLB  0
07138:  GOTO   723C
0713C:  MOVLB  0
....................    {
....................       int32 current_address = address + (packet_count * PACKET_SIZE);
0713E:  MOVLB  2
07140:  RLCF   x04,W
07142:  MOVWF  02
07144:  RLCF   x05,W
07146:  MOVWF  03
07148:  RLCF   02,F
0714A:  RLCF   03,F
0714C:  RLCF   02,F
0714E:  RLCF   03,F
07150:  RLCF   02,F
07152:  RLCF   03,F
07154:  RLCF   02,F
07156:  RLCF   03,F
07158:  RLCF   02,F
0715A:  RLCF   03,F
0715C:  MOVLW  C0
0715E:  ANDWF  02,F
07160:  MOVF   02,W
07162:  MOVLB  1
07164:  ADDWF  xBE,W
07166:  MOVLB  2
07168:  MOVWF  x06
0716A:  MOVF   03,W
0716C:  MOVLB  1
0716E:  ADDWFC xBF,W
07170:  MOVLB  2
07172:  MOVWF  x07
07174:  MOVLW  00
07176:  MOVLB  1
07178:  ADDWFC xC0,W
0717A:  MOVLB  2
0717C:  MOVWF  x08
0717E:  MOVLW  00
07180:  MOVLB  1
07182:  ADDWFC xC1,W
07184:  MOVLB  2
07186:  MOVWF  x09
07188:  MOVLB  0
....................       read_data_bytes(smf, current_address, read_data, PACKET_SIZE);
0718A:  MOVFF  115,314
0718E:  MOVFF  114,313
07192:  MOVFF  113,312
07196:  MOVFF  112,311
0719A:  MOVFF  209,318
0719E:  MOVFF  208,317
071A2:  MOVFF  207,316
071A6:  MOVFF  206,315
071AA:  MOVLW  01
071AC:  MOVLB  3
071AE:  MOVWF  x1A
071B0:  MOVLW  C4
071B2:  MOVWF  x19
071B4:  CLRF   x1E
071B6:  CLRF   x1D
071B8:  CLRF   x1C
071BA:  MOVLW  40
071BC:  MOVWF  x1B
071BE:  MOVLB  0
071C0:  CALL   28E2
....................       for (int8 byte_count = 0; byte_count < PACKET_SIZE; byte_count++)
071C4:  MOVLB  2
071C6:  CLRF   x0A
071C8:  MOVLB  0
071CA:  MOVLB  2
071CC:  MOVF   x0A,W
071CE:  SUBLW  3F
071D0:  BTFSC  FD8.0
071D2:  BRA    71DA
071D4:  MOVLB  0
071D6:  GOTO   7216
071DA:  MOVLB  0
....................       {
....................          printf("%02X ", read_data[byte_count]);
071DC:  CLRF   03
071DE:  MOVLB  2
071E0:  MOVF   x0A,W
071E2:  ADDLW  C4
071E4:  MOVWF  FE9
071E6:  MOVLW  01
071E8:  ADDWFC 03,W
071EA:  MOVWF  FEA
071EC:  MOVFF  FEF,20B
071F0:  MOVFF  20B,A39
071F4:  MOVLW  37
071F6:  MOVLB  A
071F8:  MOVWF  x3A
071FA:  MOVLB  0
071FC:  CALL   1F60
07200:  MOVLW  20
07202:  MOVLB  A
07204:  MOVWF  xDB
07206:  MOVLB  0
07208:  CALL   1CE0
0720C:  MOVLB  2
0720E:  INCF   x0A,F
07210:  MOVLB  0
07212:  GOTO   71CA
....................       }
....................       printf("\r\n");
07216:  MOVLW  0D
07218:  MOVLB  A
0721A:  MOVWF  xDB
0721C:  MOVLB  0
0721E:  CALL   1CE0
07222:  MOVLW  0A
07224:  MOVLB  A
07226:  MOVWF  xDB
07228:  MOVLB  0
0722A:  CALL   1CE0
0722E:  MOVLB  2
07230:  INCF   x04,F
07232:  BTFSC  FD8.2
07234:  INCF   x05,F
07236:  MOVLB  0
07238:  GOTO   7110
....................    }
.................... 
....................    printf("\r\nEnd Flash SMF Read Force\r\n");
0723C:  MOVLW  EA
0723E:  MOVWF  FF6
07240:  MOVLW  1A
07242:  MOVWF  FF7
07244:  MOVLW  00
07246:  MOVWF  FF8
07248:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
0724C:  MOVLB  1
0724E:  MOVF   xBC,W
07250:  MOVWF  FE9
07252:  MOVF   xBD,W
07254:  MOVWF  FEA
07256:  MOVFF  FEF,20B
0725A:  MOVFF  20B,20F
0725E:  MOVLB  2
07260:  SETF   x10
07262:  MOVLB  0
07264:  CALL   4A82
07268:  GOTO   9FAA (RETURN)
.................... }
.................... 
.................... void mode_smf_erase_force(int8 parameter[])
.................... {
....................    printf("Start SMF Erase All\r\n");
0726C:  MOVLW  08
0726E:  MOVWF  FF6
07270:  MOVLW  1B
07272:  MOVWF  FF7
07274:  MOVLW  00
07276:  MOVWF  FF8
07278:  CALL   1D32
....................    int8 cmd = parameter[0]; // Get the command ID from the parameter array
0727C:  MOVLB  1
0727E:  MOVF   xBC,W
07280:  MOVWF  FE9
07282:  MOVF   xBD,W
07284:  MOVWF  FEA
07286:  MOVFF  FEF,1BE
....................    piclog_make(cmd, 0x00); // Log the command execution
0728A:  MOVFF  1BE,20F
0728E:  MOVLB  2
07290:  CLRF   x10
07292:  MOVLB  0
07294:  CALL   4A82
....................    
.................... 
....................    
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_PICLOG_END_ADDRESS; address += SECTOR_64K_BYTE) {
07298:  MOVLW  06
0729A:  MOVLB  1
0729C:  MOVWF  xC2
0729E:  MOVLW  AA
072A0:  MOVWF  xC1
072A2:  CLRF   xC0
072A4:  CLRF   xBF
072A6:  MOVLB  0
072A8:  MOVLB  1
072AA:  MOVF   xC2,W
072AC:  SUBLW  06
072AE:  BTFSC  FD8.0
072B0:  BRA    72B8
072B2:  MOVLB  0
072B4:  GOTO   7336
072B8:  MOVLB  0
072BA:  BTFSS  FD8.2
072BC:  GOTO   7302
072C0:  MOVLB  1
072C2:  MOVF   xC1,W
072C4:  SUBLW  AA
072C6:  BTFSC  FD8.0
072C8:  BRA    72D0
072CA:  MOVLB  0
072CC:  GOTO   7336
072D0:  MOVLB  0
072D2:  BTFSS  FD8.2
072D4:  GOTO   7302
072D8:  MOVLB  1
072DA:  MOVF   xC0,W
072DC:  SUBLW  1F
072DE:  BTFSC  FD8.0
072E0:  BRA    72E8
072E2:  MOVLB  0
072E4:  GOTO   7336
072E8:  MOVLB  0
072EA:  BTFSS  FD8.2
072EC:  GOTO   7302
072F0:  MOVLB  1
072F2:  MOVF   xBF,W
072F4:  SUBLW  FE
072F6:  BTFSC  FD8.0
072F8:  BRA    7300
072FA:  MOVLB  0
072FC:  GOTO   7336
07300:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
07302:  MOVFF  115,A7D
07306:  MOVFF  114,A7C
0730A:  MOVFF  113,A7B
0730E:  MOVFF  112,A7A
07312:  MOVFF  1C2,A81
07316:  MOVFF  1C1,A80
0731A:  MOVFF  1C0,A7F
0731E:  MOVFF  1BF,A7E
07322:  CALL   469C
07326:  MOVLW  01
07328:  MOVLB  1
0732A:  ADDWF  xC1,F
0732C:  MOVLW  00
0732E:  ADDWFC xC2,F
07330:  MOVLB  0
07332:  GOTO   72A8
....................    }
....................    piclog_make(cmd, PICLOG_PARAM_END); // Log the end of the command execution
07336:  MOVFF  1BE,20F
0733A:  MOVLB  2
0733C:  SETF   x10
0733E:  MOVLB  0
07340:  CALL   4A82
....................    printf("End SMF Erase All\r\n");
07344:  MOVLW  1E
07346:  MOVWF  FF6
07348:  MOVLW  1B
0734A:  MOVWF  FF7
0734C:  MOVLW  00
0734E:  MOVWF  FF8
07350:  CALL   1D32
07354:  GOTO   9FBA (RETURN)
.................... }
.................... 
.................... void mode_smf_address_reset(int8 parameter[])
.................... {
....................    printf("Start SMF Reset\r\n");
*
06CC8:  MOVLW  32
06CCA:  MOVWF  FF6
06CCC:  MOVLW  1B
06CCE:  MOVWF  FF7
06CD0:  MOVLW  00
06CD2:  MOVWF  FF8
06CD4:  CALL   1D32
....................    piclog_make(parameter[0], PICLOG_PARAM_START);
06CD8:  MOVLB  1
06CDA:  MOVF   xBC,W
06CDC:  MOVWF  FE9
06CDE:  MOVF   xBD,W
06CE0:  MOVWF  FEA
06CE2:  MOVFF  FEF,202
06CE6:  MOVFF  202,20F
06CEA:  MOVLB  2
06CEC:  CLRF   x10
06CEE:  MOVLB  0
06CF0:  CALL   4A82
....................    int8 writedata[PACKET_SIZE] = {0x00}; 
06CF4:  MOVLB  1
06CF6:  CLRF   xBE
06CF8:  CLRF   xBF
06CFA:  CLRF   xC0
06CFC:  CLRF   xC1
06CFE:  CLRF   xC2
06D00:  CLRF   xC3
06D02:  CLRF   xC4
06D04:  CLRF   xC5
06D06:  CLRF   xC6
06D08:  CLRF   xC7
06D0A:  CLRF   xC8
06D0C:  CLRF   xC9
06D0E:  CLRF   xCA
06D10:  CLRF   xCB
06D12:  CLRF   xCC
06D14:  CLRF   xCD
06D16:  CLRF   xCE
06D18:  CLRF   xCF
06D1A:  CLRF   xD0
06D1C:  CLRF   xD1
06D1E:  CLRF   xD2
06D20:  CLRF   xD3
06D22:  CLRF   xD4
06D24:  CLRF   xD5
06D26:  CLRF   xD6
06D28:  CLRF   xD7
06D2A:  CLRF   xD8
06D2C:  CLRF   xD9
06D2E:  CLRF   xDA
06D30:  CLRF   xDB
06D32:  CLRF   xDC
06D34:  CLRF   xDD
06D36:  CLRF   xDE
06D38:  CLRF   xDF
06D3A:  CLRF   xE0
06D3C:  CLRF   xE1
06D3E:  CLRF   xE2
06D40:  CLRF   xE3
06D42:  CLRF   xE4
06D44:  CLRF   xE5
06D46:  CLRF   xE6
06D48:  CLRF   xE7
06D4A:  CLRF   xE8
06D4C:  CLRF   xE9
06D4E:  CLRF   xEA
06D50:  CLRF   xEB
06D52:  CLRF   xEC
06D54:  CLRF   xED
06D56:  CLRF   xEE
06D58:  CLRF   xEF
06D5A:  CLRF   xF0
06D5C:  CLRF   xF1
06D5E:  CLRF   xF2
06D60:  CLRF   xF3
06D62:  CLRF   xF4
06D64:  CLRF   xF5
06D66:  CLRF   xF6
06D68:  CLRF   xF7
06D6A:  CLRF   xF8
06D6C:  CLRF   xF9
06D6E:  CLRF   xFA
06D70:  CLRF   xFB
06D72:  CLRF   xFC
06D74:  CLRF   xFD
....................    for (int32 address = CIGS_DATA_TABLE_START_ADDRESS; address < CIGS_IV2_DATA_END_ADDRESS; address += SECTOR_64K_BYTE) {
06D76:  MOVLW  06
06D78:  MOVLB  2
06D7A:  MOVWF  x01
06D7C:  MOVLW  AA
06D7E:  MOVWF  x00
06D80:  MOVLB  1
06D82:  CLRF   xFF
06D84:  CLRF   xFE
06D86:  MOVLB  0
06D88:  MOVLB  2
06D8A:  MOVF   x01,W
06D8C:  SUBLW  07
06D8E:  BTFSC  FD8.0
06D90:  BRA    6D98
06D92:  MOVLB  0
06D94:  GOTO   6E16
06D98:  MOVLB  0
06D9A:  BTFSS  FD8.2
06D9C:  GOTO   6DE2
06DA0:  MOVLB  2
06DA2:  MOVF   x00,W
06DA4:  SUBLW  48
06DA6:  BTFSC  FD8.0
06DA8:  BRA    6DB0
06DAA:  MOVLB  0
06DAC:  GOTO   6E16
06DB0:  MOVLB  0
06DB2:  BTFSS  FD8.2
06DB4:  GOTO   6DE2
06DB8:  MOVLB  1
06DBA:  MOVF   xFF,W
06DBC:  SUBLW  3F
06DBE:  BTFSC  FD8.0
06DC0:  BRA    6DC8
06DC2:  MOVLB  0
06DC4:  GOTO   6E16
06DC8:  MOVLB  0
06DCA:  BTFSS  FD8.2
06DCC:  GOTO   6DE2
06DD0:  MOVLB  1
06DD2:  MOVF   xFE,W
06DD4:  SUBLW  FE
06DD6:  BTFSC  FD8.0
06DD8:  BRA    6DE0
06DDA:  MOVLB  0
06DDC:  GOTO   6E16
06DE0:  MOVLB  0
....................       sector_erase(smf, address); // Erase each sector
06DE2:  MOVFF  115,A7D
06DE6:  MOVFF  114,A7C
06DEA:  MOVFF  113,A7B
06DEE:  MOVFF  112,A7A
06DF2:  MOVFF  201,A81
06DF6:  MOVFF  200,A80
06DFA:  MOVFF  1FF,A7F
06DFE:  MOVFF  1FE,A7E
06E02:  CALL   469C
06E06:  MOVLW  01
06E08:  MOVLB  2
06E0A:  ADDWF  x00,F
06E0C:  MOVLW  00
06E0E:  ADDWFC x01,F
06E10:  MOVLB  0
06E12:  GOTO   6D88
....................    }
....................    smf_data_table_init(); // Update the address area after writing
06E16:  GOTO   6BFC
.................... 
....................    piclog_make(parameter[0], PICLOG_PARAM_END); // Log the end of the command execution
06E1A:  MOVLB  1
06E1C:  MOVF   xBC,W
06E1E:  MOVWF  FE9
06E20:  MOVF   xBD,W
06E22:  MOVWF  FEA
06E24:  MOVFF  FEF,202
06E28:  MOVFF  202,20F
06E2C:  MOVLB  2
06E2E:  SETF   x10
06E30:  MOVLB  0
06E32:  CALL   4A82
....................    printf("End SMF Reset\r\n");
06E36:  MOVLW  44
06E38:  MOVWF  FF6
06E3A:  MOVLW  1B
06E3C:  MOVWF  FF7
06E3E:  MOVLW  00
06E40:  MOVWF  FF8
06E42:  CALL   1D32
06E46:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif // MMJ_CIGS_MAIN_H
.................... //------------------End of File------------------
.................... 
.................... 
.................... void main()
*
0C2A0:  CLRF   FF8
0C2A2:  BCF    FD0.7
0C2A4:  BSF    07.7
0C2A6:  MOVLB  E
0C2A8:  MOVLW  55
0C2AA:  MOVWF  F7E
0C2AC:  MOVLW  AA
0C2AE:  MOVWF  F7E
0C2B0:  BCF    F66.6
0C2B2:  MOVLW  F9
0C2B4:  MOVWF  x2C
0C2B6:  MOVLW  0F
0C2B8:  MOVWF  x2E
0C2BA:  MOVLW  40
0C2BC:  MOVWF  x12
0C2BE:  MOVLW  30
0C2C0:  MOVWF  x13
0C2C2:  MOVLW  20
0C2C4:  MOVWF  x22
0C2C6:  MOVLW  55
0C2C8:  MOVWF  F7E
0C2CA:  MOVLW  AA
0C2CC:  MOVWF  F7E
0C2CE:  BSF    F66.6
0C2D0:  CLRF   F9B
0C2D2:  CLRF   F64
0C2D4:  CLRF   F65
0C2D6:  CLRF   F66
0C2D8:  MOVLW  02
0C2DA:  MOVWF  FD3
0C2DC:  CLRF   1B
0C2DE:  MOVLB  F
0C2E0:  BSF    x2D.3
0C2E2:  MOVLW  A0
0C2E4:  MOVWF  x2B
0C2E6:  MOVLW  01
0C2E8:  MOVWF  x2C
0C2EA:  MOVLW  A6
0C2EC:  MOVWF  x2E
0C2EE:  MOVLW  90
0C2F0:  MOVWF  x2F
0C2F2:  BCF    F93.6
0C2F4:  BSF    F8A.6
0C2F6:  BSF    F92.1
0C2F8:  BCF    F92.0
0C2FA:  BCF    F92.3
0C2FC:  BCF    F89.3
0C2FE:  BSF    F96.0
0C300:  BCF    F96.6
0C302:  BCF    F96.1
0C304:  BCF    F8D.1
0C306:  BSF    F93.4
0C308:  BCF    F93.5
0C30A:  BCF    F93.2
0C30C:  BSF    F8A.2
0C30E:  CLRF   1F
0C310:  CLRF   1E
0C312:  CLRF   1D
0C314:  CLRF   1C
0C316:  CLRF   23
0C318:  CLRF   22
0C31A:  CLRF   21
0C31C:  CLRF   20
0C31E:  CLRF   25
0C320:  CLRF   24
0C322:  CLRF   46
0C324:  BCF    47.0
0C326:  MOVLW  1E
0C328:  MOVLB  1
0C32A:  MOVWF  x30
0C32C:  CLRF   x32
0C32E:  CLRF   x31
0C330:  MOVLW  01
0C332:  MOVWF  x1F
0C334:  MOVLW  59
0C336:  MOVWF  x1E
0C338:  MOVLW  01
0C33A:  MOVWF  x21
0C33C:  MOVLW  64
0C33E:  MOVWF  x20
0C340:  MOVLW  01
0C342:  MOVWF  x23
0C344:  MOVLW  6F
0C346:  MOVWF  x22
0C348:  MOVLW  01
0C34A:  MOVWF  x25
0C34C:  MOVLW  7A
0C34E:  MOVWF  x24
0C350:  MOVLW  01
0C352:  MOVWF  x27
0C354:  MOVLW  85
0C356:  MOVWF  x26
0C358:  MOVLW  01
0C35A:  MOVWF  x29
0C35C:  MOVLW  90
0C35E:  MOVWF  x28
0C360:  MOVLW  01
0C362:  MOVWF  x2B
0C364:  MOVLW  9B
0C366:  MOVWF  x2A
0C368:  MOVLB  E
0C36A:  CLRF   xD9
0C36C:  CLRF   xDA
0C36E:  CLRF   xCE
0C370:  CLRF   xCF
0C372:  CLRF   xD0
0C374:  CLRF   xD1
0C376:  CLRF   xD2
0C378:  CLRF   xD3
0C37A:  CLRF   xD4
0C37C:  CLRF   xD5
0C37E:  CLRF   x45
0C380:  CLRF   x46
0C382:  CLRF   x47
0C384:  BCF    x8D.7
0C386:  BCF    x8D.6
0C388:  BCF    x8D.5
0C38A:  MOVLB  F
0C38C:  CLRF   x53
0C38E:  CLRF   x38
0C390:  CLRF   x37
0C392:  MOVLB  0
0C394:  CLRF   26
0C396:  CLRF   27
0C398:  CLRF   28
0C39A:  CLRF   29
0C39C:  CLRF   2A
0C39E:  CLRF   2B
0C3A0:  CLRF   2C
0C3A2:  CLRF   2D
0C3A4:  CLRF   2E
0C3A6:  CLRF   2F
0C3A8:  CLRF   30
0C3AA:  CLRF   31
0C3AC:  CLRF   32
0C3AE:  CLRF   33
0C3B0:  CLRF   34
0C3B2:  CLRF   35
0C3B4:  CLRF   36
0C3B6:  CLRF   37
0C3B8:  CLRF   38
0C3BA:  CLRF   39
0C3BC:  CLRF   3A
0C3BE:  CLRF   3B
0C3C0:  CLRF   3C
0C3C2:  CLRF   3D
0C3C4:  CLRF   3E
0C3C6:  CLRF   3F
0C3C8:  CLRF   40
0C3CA:  CLRF   41
0C3CC:  CLRF   42
0C3CE:  CLRF   43
0C3D0:  CLRF   44
0C3D2:  CLRF   45
0C3D4:  MOVLW  03
0C3D6:  MOVWF  48
0C3D8:  CLRF   49
0C3DA:  CLRF   4A
0C3DC:  CLRF   4B
0C3DE:  CLRF   4C
0C3E0:  CLRF   4D
0C3E2:  CLRF   4E
0C3E4:  CLRF   4F
0C3E6:  CLRF   50
0C3E8:  CLRF   51
0C3EA:  CLRF   52
0C3EC:  CLRF   53
0C3EE:  CLRF   54
0C3F0:  CLRF   55
0C3F2:  CLRF   56
0C3F4:  CLRF   57
0C3F6:  CLRF   58
0C3F8:  CLRF   59
0C3FA:  CLRF   5A
0C3FC:  CLRF   5B
0C3FE:  CLRF   5C
0C400:  CLRF   5D
0C402:  CLRF   5E
0C404:  CLRF   5F
0C406:  CLRF   x60
0C408:  CLRF   x61
0C40A:  CLRF   x62
0C40C:  CLRF   x63
0C40E:  CLRF   x64
0C410:  CLRF   x65
0C412:  CLRF   x66
0C414:  CLRF   x67
0C416:  CLRF   x68
0C418:  CLRF   x69
0C41A:  CLRF   x6A
0C41C:  CLRF   x6B
0C41E:  CLRF   x6C
0C420:  CLRF   x6D
0C422:  CLRF   x6E
0C424:  CLRF   x6F
0C426:  CLRF   x70
0C428:  CLRF   x71
0C42A:  CLRF   x72
0C42C:  CLRF   x73
0C42E:  CLRF   x74
0C430:  CLRF   x75
0C432:  CLRF   x76
0C434:  CLRF   x77
0C436:  CLRF   x78
0C438:  CLRF   x79
0C43A:  CLRF   x7A
0C43C:  CLRF   x7B
0C43E:  CLRF   x7C
0C440:  CLRF   x7D
0C442:  CLRF   x7E
0C444:  CLRF   x7F
0C446:  CLRF   x80
0C448:  CLRF   x81
0C44A:  CLRF   x82
0C44C:  CLRF   x83
0C44E:  CLRF   x84
0C450:  CLRF   x85
0C452:  CLRF   x86
0C454:  CLRF   x87
0C456:  CLRF   x88
0C458:  CLRF   x89
0C45A:  CLRF   x8A
0C45C:  CLRF   x8B
0C45E:  CLRF   x8C
0C460:  CLRF   x8D
0C462:  CLRF   x8E
0C464:  CLRF   x8F
0C466:  CLRF   x90
0C468:  CLRF   x91
0C46A:  CLRF   x92
0C46C:  CLRF   x93
0C46E:  CLRF   x94
0C470:  CLRF   x95
0C472:  CLRF   x96
0C474:  CLRF   x97
0C476:  CLRF   x98
0C478:  CLRF   x99
0C47A:  CLRF   x9A
0C47C:  CLRF   x9B
0C47E:  CLRF   x9C
0C480:  CLRF   x9D
0C482:  CLRF   x9E
0C484:  CLRF   x9F
0C486:  CLRF   xA0
0C488:  CLRF   xA1
0C48A:  CLRF   xA2
0C48C:  CLRF   xA3
0C48E:  CLRF   xA4
0C490:  CLRF   xA5
0C492:  CLRF   xA6
0C494:  CLRF   xA7
0C496:  CLRF   xA8
0C498:  CLRF   xA9
0C49A:  CLRF   xAA
0C49C:  CLRF   xAB
0C49E:  CLRF   xAC
0C4A0:  CLRF   xAD
0C4A2:  CLRF   xAE
0C4A4:  CLRF   xAF
0C4A6:  CLRF   xB0
0C4A8:  CLRF   xB1
0C4AA:  CLRF   xB2
0C4AC:  CLRF   xB3
0C4AE:  CLRF   xB4
0C4B0:  CLRF   xB5
0C4B2:  CLRF   xB6
0C4B4:  CLRF   xB7
0C4B6:  CLRF   xB8
0C4B8:  CLRF   xB9
0C4BA:  CLRF   xBA
0C4BC:  CLRF   xBB
0C4BE:  CLRF   xBC
0C4C0:  CLRF   xBD
0C4C2:  CLRF   xBE
0C4C4:  CLRF   xBF
0C4C6:  CLRF   xC0
0C4C8:  CLRF   xC1
0C4CA:  CLRF   xC2
0C4CC:  CLRF   xC3
0C4CE:  CLRF   xC4
0C4D0:  CLRF   xC5
0C4D2:  CLRF   xC6
0C4D4:  CLRF   xC7
0C4D6:  CLRF   xC8
0C4D8:  CLRF   xC9
0C4DA:  CLRF   xCA
0C4DC:  CLRF   xCB
0C4DE:  CLRF   xCC
0C4E0:  CLRF   xCD
0C4E2:  CLRF   xCE
0C4E4:  CLRF   xCF
0C4E6:  CLRF   xD0
0C4E8:  CLRF   xD1
0C4EA:  CLRF   xD2
0C4EC:  CLRF   xD3
0C4EE:  CLRF   xD4
0C4F0:  CLRF   xD5
0C4F2:  CLRF   xD6
0C4F4:  CLRF   xD7
0C4F6:  CLRF   xD8
0C4F8:  CLRF   xD9
0C4FA:  CLRF   xDA
0C4FC:  CLRF   xDB
0C4FE:  CLRF   xDC
0C500:  CLRF   xDD
0C502:  CLRF   xDE
0C504:  CLRF   xDF
0C506:  CLRF   xE0
0C508:  CLRF   xE1
0C50A:  CLRF   xE2
0C50C:  CLRF   xE3
0C50E:  CLRF   xE4
0C510:  CLRF   xE5
0C512:  CLRF   xE6
0C514:  CLRF   xE7
0C516:  CLRF   xE8
0C518:  CLRF   xE9
0C51A:  CLRF   xEA
0C51C:  CLRF   xEB
0C51E:  CLRF   xEC
0C520:  CLRF   xED
0C522:  CLRF   xEE
0C524:  CLRF   xEF
0C526:  CLRF   xF0
0C528:  CLRF   xF1
0C52A:  CLRF   xF2
0C52C:  CLRF   xF3
0C52E:  CLRF   xF4
0C530:  CLRF   xF5
0C532:  CLRF   xF6
0C534:  CLRF   xF7
0C536:  CLRF   xF8
0C538:  CLRF   xF9
0C53A:  CLRF   xFA
0C53C:  CLRF   xFB
0C53E:  CLRF   xFC
0C540:  CLRF   xFD
0C542:  CLRF   xFE
0C544:  CLRF   xFF
0C546:  MOVLB  1
0C548:  CLRF   x00
0C54A:  CLRF   x01
0C54C:  CLRF   x02
0C54E:  CLRF   x03
0C550:  CLRF   x04
0C552:  CLRF   x05
0C554:  CLRF   x06
0C556:  CLRF   x07
0C558:  CLRF   x08
0C55A:  CLRF   x09
0C55C:  CLRF   x0A
0C55E:  CLRF   x0B
0C560:  CLRF   x0C
0C562:  CLRF   x0D
0C564:  CLRF   x0E
0C566:  CLRF   x0F
0C568:  MOVLW  05
0C56A:  MOVWF  x10
0C56C:  MOVLW  7C
0C56E:  MOVWF  x11
0C570:  MOVLW  01
0C572:  MOVWF  x12
0C574:  MOVLW  01
0C576:  MOVWF  x13
0C578:  MOVLW  02
0C57A:  MOVWF  x14
0C57C:  MOVLW  7C
0C57E:  MOVWF  x15
0C580:  CLRF   x16
0C582:  MOVLW  09
0C584:  MOVWF  x17
0C586:  MOVLW  01
0C588:  MOVWF  x18
0C58A:  CLRF   x19
0C58C:  MOVLW  02
0C58E:  MOVWF  x1A
0C590:  MOVLW  01
0C592:  MOVWF  x1B
0C594:  CLRF   x1C
0C596:  CLRF   x1D
0C598:  CLRF   x33
0C59A:  CLRF   x34
0C59C:  CLRF   x35
0C59E:  CLRF   x36
0C5A0:  CLRF   x37
0C5A2:  CLRF   x38
0C5A4:  CLRF   x39
0C5A6:  CLRF   x3A
0C5A8:  CLRF   x3B
0C5AA:  CLRF   x3C
0C5AC:  CLRF   x3D
0C5AE:  CLRF   x3E
0C5B0:  CLRF   x3F
0C5B2:  CLRF   x40
0C5B4:  CLRF   x41
0C5B6:  CLRF   x42
0C5B8:  CLRF   x43
0C5BA:  CLRF   x44
0C5BC:  CLRF   x45
0C5BE:  CLRF   x46
0C5C0:  CLRF   x47
0C5C2:  CLRF   x48
0C5C4:  CLRF   x49
0C5C6:  CLRF   x4A
0C5C8:  CLRF   x4B
0C5CA:  CLRF   x4C
0C5CC:  CLRF   x4D
0C5CE:  CLRF   x4E
0C5D0:  CLRF   x4F
0C5D2:  CLRF   x50
0C5D4:  CLRF   x51
0C5D6:  CLRF   x52
0C5D8:  CLRF   x53
0C5DA:  CLRF   x54
0C5DC:  CLRF   x55
0C5DE:  CLRF   x56
0C5E0:  CLRF   x57
0C5E2:  CLRF   x58
0C5E4:  CLRF   x59
0C5E6:  CLRF   x5A
0C5E8:  CLRF   x5B
0C5EA:  CLRF   x5C
0C5EC:  CLRF   x5D
0C5EE:  CLRF   x5E
0C5F0:  CLRF   x5F
0C5F2:  CLRF   x60
0C5F4:  CLRF   x61
0C5F6:  CLRF   x62
0C5F8:  CLRF   x63
0C5FA:  MOVLW  01
0C5FC:  MOVWF  x64
0C5FE:  CLRF   x65
0C600:  CLRF   x66
0C602:  CLRF   x67
0C604:  CLRF   x68
0C606:  CLRF   x69
0C608:  CLRF   x6A
0C60A:  CLRF   x6B
0C60C:  CLRF   x6C
0C60E:  CLRF   x6D
0C610:  CLRF   x6E
0C612:  MOVLW  02
0C614:  MOVWF  x6F
0C616:  CLRF   x70
0C618:  CLRF   x71
0C61A:  CLRF   x72
0C61C:  CLRF   x73
0C61E:  CLRF   x74
0C620:  CLRF   x75
0C622:  CLRF   x76
0C624:  CLRF   x77
0C626:  CLRF   x78
0C628:  CLRF   x79
0C62A:  MOVLW  03
0C62C:  MOVWF  x7A
0C62E:  CLRF   x7B
0C630:  CLRF   x7C
0C632:  CLRF   x7D
0C634:  CLRF   x7E
0C636:  CLRF   x7F
0C638:  CLRF   x80
0C63A:  CLRF   x81
0C63C:  CLRF   x82
0C63E:  CLRF   x83
0C640:  CLRF   x84
0C642:  MOVLW  04
0C644:  MOVWF  x85
0C646:  CLRF   x86
0C648:  CLRF   x87
0C64A:  CLRF   x88
0C64C:  CLRF   x89
0C64E:  CLRF   x8A
0C650:  CLRF   x8B
0C652:  CLRF   x8C
0C654:  CLRF   x8D
0C656:  CLRF   x8E
0C658:  CLRF   x8F
0C65A:  MOVLW  05
0C65C:  MOVWF  x90
0C65E:  CLRF   x91
0C660:  CLRF   x92
0C662:  CLRF   x93
0C664:  CLRF   x94
0C666:  CLRF   x95
0C668:  CLRF   x96
0C66A:  CLRF   x97
0C66C:  CLRF   x98
0C66E:  CLRF   x99
0C670:  CLRF   x9A
0C672:  MOVLW  06
0C674:  MOVWF  x9B
0C676:  CLRF   x9C
0C678:  CLRF   x9D
0C67A:  CLRF   x9E
0C67C:  CLRF   x9F
0C67E:  CLRF   xA0
0C680:  CLRF   xA1
0C682:  CLRF   xA2
0C684:  CLRF   xA3
0C686:  CLRF   xA4
0C688:  CLRF   xA5
0C68A:  MOVLB  0
.................... { 
....................    delay_ms(100); // wait for power stable
0C68C:  MOVLW  64
0C68E:  MOVLB  A
0C690:  MOVWF  x94
0C692:  MOVLB  0
0C694:  CALL   1CB2
....................    fprintf(PC,"\r\n\r\n\r\n============================================================\r\n");
0C698:  MOVLW  54
0C69A:  MOVWF  FF6
0C69C:  MOVLW  1B
0C69E:  MOVWF  FF7
0C6A0:  MOVLW  00
0C6A2:  MOVWF  FF8
0C6A4:  CALL   1D32
....................    fprintf(PC,"This is MOMIJI CIGS PIC BBM for MIS7_BBM4.\r\n");
0C6A8:  MOVLW  9A
0C6AA:  MOVWF  FF6
0C6AC:  MOVLW  1B
0C6AE:  MOVWF  FF7
0C6B0:  MOVLW  00
0C6B2:  MOVWF  FF8
0C6B4:  CALL   1D32
....................    fprintf(PC,"Last updated on %s %s, by Inoue.\r\n\r\n", __DATE__, __TIME__);
0C6B8:  MOVLW  C8
0C6BA:  MOVWF  FF6
0C6BC:  MOVLW  1B
0C6BE:  MOVWF  FF7
0C6C0:  MOVLW  00
0C6C2:  MOVWF  FF8
0C6C4:  MOVLW  10
0C6C6:  MOVLB  3
0C6C8:  MOVWF  x12
0C6CA:  MOVLB  0
0C6CC:  CALL   1D62
0C6D0:  MOVLW  EE
0C6D2:  MOVWF  FF6
0C6D4:  MOVLW  1B
0C6D6:  MOVWF  FF7
0C6D8:  MOVLW  00
0C6DA:  MOVWF  FF8
0C6DC:  CALL   1D32
0C6E0:  MOVLW  20
0C6E2:  MOVLB  A
0C6E4:  MOVWF  xDB
0C6E6:  MOVLB  0
0C6E8:  CALL   1CE0
0C6EC:  MOVLW  F8
0C6EE:  MOVWF  FF6
0C6F0:  MOVLW  1B
0C6F2:  MOVWF  FF7
0C6F4:  MOVLW  00
0C6F6:  MOVWF  FF8
0C6F8:  CALL   1D32
0C6FC:  MOVLW  DD
0C6FE:  MOVWF  FF6
0C700:  MOVLW  1B
0C702:  MOVWF  FF7
0C704:  MOVLW  00
0C706:  MOVWF  FF8
0C708:  MOVLW  0F
0C70A:  MOVLB  3
0C70C:  MOVWF  x12
0C70E:  MOVLB  0
0C710:  CALL   1D62
....................    
....................    // io_init();
....................    setup_uart_to_boss();
0C714:  GOTO   1D98
....................    timer_init();
0C718:  GOTO   1DC2
....................    ad7490_init();
0C71C:  GOTO   1FD0
....................    mcp4901_init();
0C720:  GOTO   22AE
....................    misf_init();
0C724:  CALL   33BA
....................    
....................    piclog_make(PICLOG_STARTUP,0x00);
0C728:  MOVLB  2
0C72A:  CLRF   x0F
0C72C:  CLRF   x10
0C72E:  MOVLB  0
0C730:  CALL   4A82
.................... 
....................    int1 is_finished = FALSE;
0C734:  MOVLB  1
0C736:  BCF    xA6.0
....................    fprintf(PC,"____CIGS PIC Start Operation_____\r\n\r\n");
0C738:  MOVLW  02
0C73A:  MOVWF  FF6
0C73C:  MOVLW  1C
0C73E:  MOVWF  FF7
0C740:  MOVLW  00
0C742:  MOVWF  FF8
0C744:  MOVLB  0
0C746:  CALL   1D32
....................    
....................    output_low(EN_NPWR);
0C74A:  MOVLW  5E
0C74C:  MOVWF  F94
0C74E:  BCF    F8B.7
....................    
....................    
....................    fprintf(PC,"waiting for BOSS PIC command");
0C750:  MOVLW  28
0C752:  MOVWF  FF6
0C754:  MOVLW  1C
0C756:  MOVWF  FF7
0C758:  MOVLW  00
0C75A:  MOVWF  FF8
0C75C:  CALL   1D32
....................    
....................    //Start loop
....................    while(!is_finished)
0C760:  MOVLB  1
0C762:  BTFSS  xA6.0
0C764:  BRA    C76C
0C766:  MOVLB  0
0C768:  GOTO   C83A
0C76C:  MOVLB  0
....................    {
....................       // unsigned int16 cigs1_amp = ad7490_read(ADC_CIGS2_AMP);
....................       // unsigned int16 cigs1_curr = ad7490_read(ADC_CIGS2_CURR);
....................       // unsigned int16 cigs1_volt = ad7490_read(ADC_CIGS2_VOLT);
....................       
....................       // fprintf(PC, "CIGS1 Amp: %04LX, Current: %04LX, Voltage: %04LX\r\n", cigs1_amp, cigs1_curr, cigs1_volt);
....................       
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
0C76E:  MOVF   46,F
0C770:  BTFSC  FD8.2
0C772:  GOTO   C7F6
....................       {
....................          //Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
....................          volatile Command recieve_cmd = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0C776:  MOVLB  1
0C778:  CLRF   xBA
0C77A:  MOVLW  26
0C77C:  MOVWF  xB9
0C77E:  MOVFF  46,1BB
0C782:  MOVLB  0
0C784:  GOTO   50B6
0C788:  MOVFF  02,03
0C78C:  MOVF   01,W
0C78E:  MOVWF  FE1
0C790:  MOVFF  03,FE2
0C794:  MOVLW  01
0C796:  MOVWF  FEA
0C798:  MOVLW  A7
0C79A:  MOVWF  FE9
0C79C:  MOVLW  0C
0C79E:  MOVWF  01
0C7A0:  MOVFF  FE6,FEE
0C7A4:  DECFSZ 01,F
0C7A6:  GOTO   C7A0
....................          /*
....................          fprintf(PC, "Frame ID: %X\r\n", recieve_cmd.frame_id);
....................          fprintf(PC, "Content size: %u\r\n", recieve_cmd.size);
....................          fprintf(PC, "payload: ");
....................          for(int8 i = 0; i < recieve_cmd.size; i++)
....................             fprintf(PC, "%X ", recieve_cmd.content[i]);
....................          fprintf(PC, "\r\n\r\n");
....................          fprintf(PC, "is_exist: %d\r\n", recieve_cmd.is_exist);
....................          */
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0C7AA:  MOVLB  1
0C7AC:  CLRF   xB4
0C7AE:  MOVLW  26
0C7B0:  MOVWF  xB3
0C7B2:  CLRF   xB6
0C7B4:  MOVLW  46
0C7B6:  MOVWF  xB5
0C7B8:  MOVLB  0
0C7BA:  GOTO   52B2
....................          
....................          if(recieve_cmd.is_exist)
0C7BE:  MOVLB  1
0C7C0:  BTFSC  xA9.0
0C7C2:  BRA    C7CA
0C7C4:  MOVLB  0
0C7C6:  GOTO   C7E6
0C7CA:  MOVLB  0
....................             //is_finished = execute_command(&recieve_cmd); 
....................             int1 flag = execute_command(&recieve_cmd);
0C7CC:  MOVLW  01
0C7CE:  MOVLB  1
0C7D0:  MOVWF  xB4
0C7D2:  MOVLW  A7
0C7D4:  MOVWF  xB3
0C7D6:  MOVLB  0
0C7D8:  GOTO   C21E
0C7DC:  MOVLB  1
0C7DE:  BCF    xA6.1
0C7E0:  BTFSC  01.0
0C7E2:  BSF    xA6.1
0C7E4:  MOVLB  0
....................             fprintf(PC,"\r\nwaiting for BOSS PIC command");
0C7E6:  MOVLW  46
0C7E8:  MOVWF  FF6
0C7EA:  MOVLW  1C
0C7EC:  MOVWF  FF7
0C7EE:  MOVLW  00
0C7F0:  MOVWF  FF8
0C7F2:  CALL   1D32
....................       }
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
0C7F6:  MOVLB  1
0C7F8:  BTFSC  xA6.0
0C7FA:  BRA    C802
0C7FC:  MOVLB  0
0C7FE:  GOTO   C808
0C802:  MOVLB  0
....................          break;
0C804:  GOTO   C83A
....................          
....................       delay_ms(400);
0C808:  MOVLW  02
0C80A:  MOVLB  1
0C80C:  MOVWF  xB3
0C80E:  MOVLB  0
0C810:  MOVLW  C8
0C812:  MOVLB  A
0C814:  MOVWF  x94
0C816:  MOVLB  0
0C818:  CALL   1CB2
0C81C:  MOVLB  1
0C81E:  DECFSZ xB3,F
0C820:  BRA    C826
0C822:  BRA    C82A
0C824:  MOVLB  0
0C826:  MOVLB  0
0C828:  BRA    C810
....................       fprintf(PC, ".");
0C82A:  MOVLW  2E
0C82C:  MOVLB  A
0C82E:  MOVWF  xDB
0C830:  MOVLB  0
0C832:  CALL   1CE0
0C836:  GOTO   C760
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0C83A:  MOVLW  66
0C83C:  MOVWF  FF6
0C83E:  MOVLW  1C
0C840:  MOVWF  FF7
0C842:  MOVLW  00
0C844:  MOVWF  FF8
0C846:  CALL   1D32
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0C84A:  MOVLW  2E
0C84C:  MOVLB  A
0C84E:  MOVWF  xDB
0C850:  MOVLB  0
0C852:  CALL   1CE0
....................       delay_ms(1000);
0C856:  MOVLW  04
0C858:  MOVLB  1
0C85A:  MOVWF  xB3
0C85C:  MOVLB  0
0C85E:  MOVLW  FA
0C860:  MOVLB  A
0C862:  MOVWF  x94
0C864:  MOVLB  0
0C866:  CALL   1CB2
0C86A:  MOVLB  1
0C86C:  DECFSZ xB3,F
0C86E:  BRA    C874
0C870:  BRA    C878
0C872:  MOVLB  0
0C874:  MOVLB  0
0C876:  BRA    C85E
0C878:  MOVLB  0
0C87A:  GOTO   C84A
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0C87E:  MOVLW  A6
0C880:  MOVWF  FF6
0C882:  MOVLW  1C
0C884:  MOVWF  FF7
0C886:  MOVLW  00
0C888:  MOVWF  FF8
0C88A:  CALL   1D32
....................    
.................... }
.................... // Enf of files
0C88E:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
